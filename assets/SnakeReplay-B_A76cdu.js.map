{"version":3,"file":"SnakeReplay-B_A76cdu.js","sources":["../../src/views/practice/components/SnakeReplay.vue"],"sourcesContent":["<template>\n  <div class=\"relative bg-gray-100 dark:bg-[#0a0a0a] rounded-md p-2 overflow-hidden\">\n    <!-- Mini grid -->\n    <div class=\"grid grid-cols-15 gap-px\" style=\"grid-template-columns: repeat(15, minmax(0, 1fr));\">\n      <div\n        v-for=\"i in totalCells\"\n        :key=\"i\"\n        class=\"w-2 h-2 transition-colors duration-300\"\n        :class=\"baseCellClass(i - 1)\"\n      />\n    </div>\n\n    <!-- Animated snake segments -->\n    <div class=\"absolute inset-0 pointer-events-none\">\n      <!-- Body (excluding head) -->\n      <div\n        v-for=\"(seg, idx) in renderBody\"\n        :key=\"`seg-${idx}`\"\n        class=\"w-2 h-2 rounded-sm bg-green-300 dark:bg-green-600\"\n        :style=\"segmentStyle(seg, idx)\"\n      />\n      <!-- Head -->\n      <div\n        v-if=\"head\"\n        class=\"w-3 h-3 rounded-full bg-green-500 border border-green-300 animate-pulse\"\n        :style=\"headStyle(head)\"\n      >\n        <div class=\"w-full h-full flex items-center justify-center\">\n          <div class=\"w-1 h-1 bg-white rounded-full\" :style=\"directionDotStyle(currentDirection)\" />\n        </div>\n      </div>\n    </div>\n\n    <!-- Food pulse -->\n    <div class=\"absolute inset-0 pointer-events-none\">\n      <div\n        class=\"w-3 h-3 rounded-full animate-ping\"\n        :class=\"data.wasCorrect ? 'bg-emerald-400 dark:bg-emerald-500' : 'bg-red-400 dark:bg-red-500'\"\n        :style=\"foodStyle(scaledFood)\"\n      />\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, onMounted, onUnmounted, reactive, ref } from 'vue'\n\ntype Vec = { x: number; y: number }\n\nconst props = defineProps<{ data: {\n  position: Vec\n  wasCorrect: boolean\n  foodType: 'primary' | 'secondary'\n  snakeLength: number\n  gameScore: number\n  wordsCompleted: number\n  wrongEatenCount: number\n  snakeBody: Vec[]\n  direction: Vec\n  // Optional recorded timeline frames for accurate replay\n  timelineFrames?: Array<{ body: Vec[]; direction: Vec }>\n} }>()\n\n// Grid constants (scaled down from 30x20)\nconst gridW = 15\nconst gridH = 10\nconst cellSize = 8 // px\nconst gap = 1 // px\nconst padding = 8 // px (container p-2)\n\nconst totalCells = gridW * gridH\n\n// Scale helpers (from original 30x20 grid to 15x10)\nconst scalePos = (p: Vec): Vec => ({ x: Math.floor(p.x / 2), y: Math.floor(p.y / 2) })\n\nconst scaledFood = computed(() => scalePos(props.data.position))\n\n// Replay state\nconst state = reactive({\n  head: scalePos(props.data.snakeBody[0] || { x: 0, y: 0 }),\n  body: props.data.snakeBody.slice(1).map(scalePos) as Vec[],\n  dir: { ...props.data.direction } as Vec,\n})\n\n// Derivatives for template\nconst head = computed(() => state.head)\nconst renderBody = computed(() => state.body)\nconst currentDirection = computed(() => state.dir)\n\n// Base grid coloring (food cell highlight, otherwise subtle)\nconst baseCellClass = (index: number) => {\n  const x = index % gridW\n  const y = Math.floor(index / gridW)\n  if (x === scaledFood.value.x && y === scaledFood.value.y) {\n    return props.data.wasCorrect\n      ? 'bg-emerald-300/70 dark:bg-emerald-700/60'\n      : 'bg-red-300/70 dark:bg-red-700/60'\n  }\n  return 'bg-gray-200 dark:bg-dark-bg-soft hover:bg-gray-300 dark:hover:bg-dark-bg-soft'\n}\n\n// Position style helpers\nconst toPixel = (p: Vec) => ({\n  left: `${padding + p.x * (cellSize + gap)}px`,\n  top: `${padding + p.y * (cellSize + gap)}px`,\n})\n\nconst headStyle = (p: Vec) => ({\n  position: 'absolute',\n  zIndex: 10,\n  ...toPixel(p),\n} as const)\n\nconst segmentStyle = (p: Vec, idx: number) => ({\n  position: 'absolute',\n  zIndex: 5,\n  opacity: Math.max(0.35, 1 - idx * 0.1),\n  transition: 'left 120ms linear, top 120ms linear, opacity 300ms ease',\n  ...toPixel(p),\n} as const)\n\nconst foodStyle = (p: Vec) => ({\n  position: 'absolute',\n  ...toPixel(p),\n} as const)\n\nconst directionDotStyle = (d: Vec) => {\n  let transform = 'translate(-50%, -50%)'\n  if (d.x === 1) transform += ' translateX(25%)'\n  else if (d.x === -1) transform += ' translateX(-25%)'\n  else if (d.y === 1) transform += ' translateY(25%)'\n  else if (d.y === -1) transform += ' translateY(-25%)'\n  return { position: 'absolute', left: '50%', top: '50%', transform } as const\n}\n\n// Timeline-aware replay: prefer recorded frames; otherwise synthetic toward food\nlet rafId: number | null = null\nlet lastStep = 0\nconst stepInterval = 140 // ms\nconst maxSteps = 18\n\nconst inBounds = (p: Vec) => p.x >= 0 && p.y >= 0 && p.x < gridW && p.y < gridH\n\nlet frameIndex = 0\n\nconst nextStep = () => {\n  const now = performance.now()\n  if (now - lastStep < stepInterval) {\n    rafId = requestAnimationFrame(nextStep)\n    return\n  }\n  lastStep = now\n\n  const hasTimeline = props.data.timelineFrames && props.data.timelineFrames.length > 0\n  if (hasTimeline) {\n    const frames = props.data.timelineFrames as Array<{ body: Vec[]; direction: Vec }>\n    const f = frames[frameIndex % frames.length]\n    const headSeg = f.body[0] || { x: 0, y: 0 }\n    state.head = scalePos(headSeg)\n    state.body = f.body.slice(1).map(scalePos)\n    state.dir = { x: f.direction.x, y: f.direction.y }\n    frameIndex = (frameIndex + 1) % frames.length\n  } else {\n    // Decide direction towards food from current head\n    const target = scaledFood.value\n    const dx = target.x - state.head.x\n    const dy = target.y - state.head.y\n    const step: Vec = { x: Math.sign(dx), y: Math.sign(dy) }\n    // Prefer horizontal movement first for variety\n    const move: Vec = Math.abs(dx) >= Math.abs(dy) ? { x: step.x, y: 0 } : { x: 0, y: step.y }\n\n    // Shift body to follow\n    const newBody = [ { ...state.head }, ...state.body.slice(0, Math.max(0, state.body.length - 0)) ]\n    state.body = newBody.slice(0, props.data.snakeBody.length - 1)\n\n    // Move head\n    const newHead = { x: state.head.x + move.x, y: state.head.y + move.y }\n    state.dir = move\n    if (inBounds(newHead)) state.head = newHead\n\n    // Looping conditions\n    loopCounter.value++\n    const reached = state.head.x === target.x && state.head.y === target.y\n    if (reached || loopCounter.value >= maxSteps) {\n      // Reset to original snapshot\n      state.head = scalePos(props.data.snakeBody[0] || { x: 0, y: 0 })\n      state.body = props.data.snakeBody.slice(1).map(scalePos)\n      state.dir = { ...props.data.direction }\n      loopCounter.value = 0\n    }\n  }\n\n  rafId = requestAnimationFrame(nextStep)\n}\n\nconst loopCounter = ref(0)\n\nonMounted(() => {\n  lastStep = performance.now()\n  rafId = requestAnimationFrame(nextStep)\n})\n\nonUnmounted(() => {\n  if (rafId) cancelAnimationFrame(rafId)\n})\n</script>\n\n<style scoped>\n.grid-cols-15 { grid-template-columns: repeat(15, minmax(0, 1fr)); }\n</style>\n\n"],"names":["_openBlock","_createElementBlock","_createElementVNode","_Fragment","_renderList","_normalizeClass","_normalizeStyle","data"],"mappings":"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"}