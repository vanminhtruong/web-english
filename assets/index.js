true              &&(function polyfill() {
	const relList = document.createElement("link").relList;
	if (relList && relList.supports && relList.supports("modulepreload")) return;
	for (const link of document.querySelectorAll("link[rel=\"modulepreload\"]")) processPreload(link);
	new MutationObserver((mutations) => {
		for (const mutation of mutations) {
			if (mutation.type !== "childList") continue;
			for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
		}
	}).observe(document, {
		childList: true,
		subtree: true
	});
	function getFetchOpts(link) {
		const fetchOpts = {};
		if (link.integrity) fetchOpts.integrity = link.integrity;
		if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
		if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
		else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
		else fetchOpts.credentials = "same-origin";
		return fetchOpts;
	}
	function processPreload(link) {
		if (link.ep) return;
		link.ep = true;
		const fetchOpts = getFetchOpts(link);
		fetch(link.href, fetchOpts);
	}
}());

/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn$1 = (val, key) => hasOwnProperty$2.call(val, key);
const isArray$2 = Array.isArray;
const isMap = (val) => toTypeString$1(val) === "[object Map]";
const isSet = (val) => toTypeString$1(val) === "[object Set]";
const isDate$1 = (val) => toTypeString$1(val) === "[object Date]";
const isFunction$2 = (val) => typeof val === "function";
const isString$3 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$3 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return (isObject$3(val) || isFunction$2(val)) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString$1 = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString$1(value).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString$1(val) === "[object Object]";
const isIntegerKey = (key) => isString$3(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize$1 = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize$1(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString$3(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis$1;
const getGlobalThis$1 = () => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray$2(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$3(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$3(value) || isObject$3(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$3(value)) {
    res = value;
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$3(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate$1(a);
  let bValidType = isDate$1(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray$2(a);
  bValidType = isArray$2(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$3(a);
  bValidType = isObject$3(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString$1 = (val) => {
  return isString$3(val) ? val : val == null ? "" : isArray$2(val) || isObject$3(val) && (val.toString === objectToString$1 || !isFunction$2(val.toString)) ? isRef$1(val) ? toDisplayString$1(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$3(val) && !isArray$2(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};

/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this._on = 0;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = void 0;
    }
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed2) {
  if (computed2.flags & 4 && !(computed2.flags & 16)) {
    return;
  }
  computed2.flags &= -17;
  if (computed2.globalVersion === globalVersion) {
    return;
  }
  computed2.globalVersion = globalVersion;
  if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
    return;
  }
  computed2.flags |= 2;
  const dep = computed2.dep;
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed2;
  shouldTrack = true;
  try {
    prepareDeps(computed2);
    const value = computed2.fn(computed2._value);
    if (dep.version === 0 || hasChanged(value, computed2._value)) {
      computed2.flags |= 128;
      computed2._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed2);
    computed2.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  // TODO isolatedDeclarations "__v_skip"
  constructor(computed2) {
    this.computed = computed2;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
    this.__v_skip = true;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false) ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed2 = link.dep.computed;
    if (computed2 && !link.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l = computed2.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray$2(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray$2(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toReactive(value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply$1(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply$1(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
  },
  find(fn, thisArg) {
    return apply$1(this, "find", fn, thisArg, toReactive, arguments);
  },
  findIndex(fn, thisArg) {
    return apply$1(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply$1(this, "findLast", fn, thisArg, toReactive, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply$1(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply$1(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply$1(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply$1(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self, method, wrapValue) {
  const arr = shallowReadArray(self);
  const iter = arr[method]();
  if (arr !== self && !isShallow(self)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply$1(self, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self);
  const needsWrap = arr !== self && !isShallow(self);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toReactive(item), index, self);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self, method, fn, args) {
  const arr = shallowReadArray(self);
  let wrappedFn = fn;
  if (arr !== self) {
    if (!isShallow(self)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toReactive(item), index, self);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self, method, args) {
  const arr = toRaw(self);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self)[method].apply(self, args);
  endBatch();
  resetTracking();
  return res;
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty$1(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$2(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$3(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$1(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn$1(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$2(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend$1(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0);
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn$1(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$3(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!hasOwn$1(value, "__v_skip") && Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject$3(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$3(value) ? readonly(value) : value;
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  const ret = isArray$2(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
  }
  get value() {
    const val = this._object[this._key];
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this["__v_isRef"] = true;
    this["__v_isReadonly"] = true;
    this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction$2(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$3(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction$2(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$2(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction$2(s)) {
        return call ? call(s, 2) : s();
      } else ;
    });
  } else if (isFunction$2(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope && scope.active) {
      remove(scope.effects, effect2);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          oldValue = newValue;
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !isObject$3(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if (isPlainObject$2(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}

/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$3(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$2(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$2(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray$2(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex$1(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId$1(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId$1(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId$1(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex$1(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$2(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= -2;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId$1(a) - getId$1(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= -2;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId$1 = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false) ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= -2;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction$2(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$3(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          if (parentComponent && parentComponent.isCE) {
            parentComponent.ce._teleportTarget = container2;
          }
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace !== "svg" && isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (!disabled) {
            mount(target, targetAnchor);
            updateCssVars(n2, false);
          }
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        n2.el.__isMounted = false;
        queuePostRenderEffect(() => {
          mountToTarget();
          delete n2.el.__isMounted;
        }, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
        queuePostRenderEffect(() => {
          TeleportImpl.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        }, parentSuspense);
        return;
      }
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const disabled = isTeleportDisabled(vnode.props);
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetStart = targetNode;
        vnode.targetAnchor = targetNode && nextSibling(targetNode);
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c of children) {
      if (c.type !== Comment) {
        child = c;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$2(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  if (vnode.component) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction$2(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction$2(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$2(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
    return hasOwn$1(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref3) {
    if (isString$3(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$2(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString$3(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$2(existing) && remove(existing, refValue);
          } else {
            if (!isArray$2(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (canSetSetupRef(ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          ref3.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const isComment = (node) => node.nodeType === 8;
getGlobalThis$1().requestIdleCallback || ((cb) => setTimeout(cb, 1));
getGlobalThis$1().cancelIdleCallback || ((id) => clearTimeout(id));
function forEachElement(node, cb) {
  if (isComment(node) && node.data === "[") {
    let depth = 1;
    let next = node.nextSibling;
    while (next) {
      if (next.nodeType === 1) {
        const result = cb(next);
        if (result === false) {
          break;
        }
      } else if (isComment(next)) {
        if (next.data === "]") {
          if (--depth === 0) break;
        } else if (next.data === "[") {
          depth++;
        }
      }
      next = next.nextSibling;
    }
  } else {
    cb(node);
  }
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if (isFunction$2(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    hydrate: hydrateStrategy,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return /* @__PURE__ */ defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    __asyncHydrate(el, instance, hydrate) {
      const doHydrate = hydrateStrategy ? () => {
        const performHydrate = () => {
          hydrate();
        };
        const teardown = hydrateStrategy(
          performHydrate,
          (cb) => forEachElement(el, cb)
        );
        if (teardown) {
          (instance.bum || (instance.bum = [])).push(teardown);
        }
        (instance.u || (instance.u = [])).push(() => true);
      } : hydrate;
      if (resolvedComp) {
        doHydrate();
      } else {
        load().then(() => !instance.isUnmounted && doHydrate());
      }
    },
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      markAsyncBoundary(instance);
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.update();
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref22, props, children, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref22;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$3(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize$1(name) || selfName === capitalize$1(camelize$1(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize$1(name)] || registry[capitalize$1(camelize$1(name))]);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache;
  const sourceIsArray = isArray$2(source);
  if (sourceIsArray || isString$3(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    let isReadonlySource = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      isReadonlySource = isReadonly(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? isReadonlySource ? toReadonly(toReactive(source[i])) : toReactive(source[i]) : source[i],
        i,
        void 0,
        cached
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached);
    }
  } else if (isObject$3(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached)
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback)],
      64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || ([]),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode$1(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i) ,
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i) 
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn$1(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$1(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn$1(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray$2(props) ? props.reduce(
    (normalized, p) => (normalized[p] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$2(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$3(data)) ; else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$2(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$2(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$2(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$3(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$3(raw)) {
    const handler = ctx[raw];
    if (isFunction$2(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (isFunction$2(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject$3(raw)) {
    if (isArray$2(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$2(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions$1(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  if (isObject$3(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions$1(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions$1(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ; else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$1(
      isFunction$2(to) ? to.call(this, this) : to,
      isFunction$2(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$2(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$2(to) && isArray$2(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend$1(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (!isFunction$2(rootComponent)) {
      rootComponent = extend$1({}, rootComponent);
    }
    if (rootProps != null && !isObject$3(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$1,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ; else if (plugin && isFunction$2(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$2(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance) ; else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn$1(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize$1(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$1(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn$1(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn$1(options, camelKey = camelize$1(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn$1(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn$1(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$3(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$2(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize$1(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize$1(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? { type: opt } : extend$1({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray$2(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = isFunction$2(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction$2(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn$1(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$3(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot$1 = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if (isFunction$2(value)) {
      slots[key] = normalizeSlot$1(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || !isInternalKey(key)) {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const cacheIndexes = children.__;
    if (cacheIndexes) def(slots, "__", cacheIndexes, true);
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis$1();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    } else if (ref3 == null && n1 && n1.ref != null) {
      setRef(n1.ref, null, parentSuspense, n1, true);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        {
          if (root.ce && // @ts-expect-error _def is private
          root.ce._def.shadowRoot !== false) {
            root.ce._injectChildStyle(type);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance.scope.on();
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect2.run.bind(effect2);
    const job = instance.job = effect2.runIfDirty.bind(effect2);
    job.i = instance;
    job.id = instance.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => {
          if (vnode.ctx.isUnmounted) {
            hostRemove(el);
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      pauseTracking();
      setRef(ref3, null, parentSuspense, vnode, true);
      resetTracking();
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const {
      bum,
      scope,
      job,
      subTree,
      um,
      m,
      a,
      parent,
      slots: { __: slotCacheKeys }
    } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    if (parent && isArray$2(slotCacheKeys)) {
      slotCacheKeys.forEach((v) => {
        parent.renderCache[v] = void 0;
      });
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  return {
    render,
    hydrate,
    createApp: createAppAPI(render)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= -33;
    job.flags &= -5;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$2(ch1) && isArray$2(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend$1({}, options);
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$3(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$2(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize$1(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit$1(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => isString$3(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize$1(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$3(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray$2(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$3(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false) ;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render2(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root, vnode.transition);
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$2(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode$1(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$3(ref3) || isRef(ref3) || isFunction$2(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$3(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode$1(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$3(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$3(style)) {
      if (isProxy(style) && !isArray$2(style)) {
        style = extend$1({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$3(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$3(type) ? 4 : isFunction$2(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend$1({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$2(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode$1(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$2(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$2(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis$1();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1) setters.forEach((set) => set(v));
      else setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized || isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    pauseTracking();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = isPromise$1(setupResult);
    resetTracking();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult);
    }
  } else {
    finishComponentSetup(instance);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$2(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$3(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance);
}
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    instance.render = Component.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$2(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c;
};
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$3(propsOrChildren) && !isArray$2(propsOrChildren)) {
      if (isVNode$1(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode$1(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const version$1 = "3.5.17";

/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION$1 = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend$1(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if (isArray$2(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done, isCancelled) => {
    el._enterCancelled = isCancelled;
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };
  return extend$1(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      if (!el._enterCancelled) {
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
      } else {
        addTransitionClass(el, leaveActiveClass);
        forceReflow();
      }
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false, void 0, true);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true, void 0, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$3(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION$1}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION$1}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION$1) {
    if (transitionTimeout > 0) {
      type = TRANSITION$1;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION$1 : ANIMATION : null;
    propCount = type ? type === TRANSITION$1 ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION$1 && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION$1}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
const CSS_VAR_TEXT = Symbol("");
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    if (instance.ce) {
      setVarsOnNode(instance.ce, vars);
    } else {
      setVarsOnVNode(instance.subTree, vars);
    }
    updateTeleports(vars);
  };
  onBeforeUpdate(() => {
    queuePostFlushCb(setVars);
  });
  onMounted(() => {
    watch(setVars, NOOP, { flush: "post" });
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
      cssText += `--${key}: ${vars[key]};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString$3(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString$3(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray$2(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null) val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize$1(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean ? "" : isSymbol(value) ? String(value) : value
      );
    }
  }
}
function patchDOMProp(el, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(attrName || key);
}
function addEventListener$1(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener$1(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener$1(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener$1(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$2(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString$3(nextValue))
  ) {
    patchDOMProp(el, camelize$1(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$2(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$3(value)) {
    return false;
  }
  return key in el;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const decorate = (t) => {
  delete t.props.mode;
  return t;
};
const TransitionGroupImpl = /* @__PURE__ */ decorate({
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        prevChildren = [];
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
      prevChildren = [];
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = [];
      if (children) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            setTransitionHooks(
              child,
              resolveTransitionHooks(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        }
      }
      return createVNode(tag, null, children);
    };
  }
});
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$2(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener$1(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing) return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener$1(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener$1(el, "compositionstart", onCompositionStart);
      addEventListener$1(el, "compositionend", onCompositionEnd);
      addEventListener$1(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value === oldValue) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener$1(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el[assignKey];
      if (isArray$2(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  let checked;
  if (isArray$2(value)) {
    checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    checked = value.has(vnode.props.value);
  } else {
    if (value === oldValue) return;
    checked = looseEqual(value, getCheckboxValue(el, true));
  }
  if (el.checked !== checked) {
    el.checked = checked;
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener$1(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener$1(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? looseToNumber(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    if (!el._assigning) {
      setSelected(el, value);
    }
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  const isArrayValue = isArray$2(value);
  if (isMultiple && !isArrayValue && !isSet(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option.selected = value.some((v) => String(v) === String(optionValue));
        } else {
          option.selected = looseIndexOf(value, optionValue) > -1;
        }
      } else {
        option.selected = value.has(optionValue);
      }
    } else if (looseEqual(getValue(option), value)) {
      if (el.selectedIndex !== i) el.selectedIndex = i;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  const cache = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some(
      (k) => k === eventKey || keyNames[k] === eventKey
    )) {
      return fn(event);
    }
  });
};
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;
    if (!isFunction$2(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString$3(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}

/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia;
const setActivePinia = (pinia) => activePinia = pinia;
const piniaSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject$1(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia = markRaw({
    install(app) {
      setActivePinia(pinia);
      pinia._a = app;
      app.provide(piniaSymbol, pinia);
      app.config.globalProperties.$pinia = pinia;
      toBeInstalled.forEach((plugin) => _p.push(plugin));
      toBeInstalled = [];
    },
    use(plugin) {
      if (!this._a) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  return pinia;
}
const noop$1 = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop$1) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
const fallbackRunWithContext = (fn) => fn();
const ACTION_MARKER = Symbol();
const ACTION_NAME = Symbol();
function mergeReactiveObjects(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value, key) => target.set(key, value));
  } else if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function shouldHydrate(obj) {
  return !isPlainObject$1(obj) || !Object.prototype.hasOwnProperty.call(obj, skipHydrateSymbol);
}
const { assign: assign$3 } = Object;
function isComputed(o) {
  return !!(isRef(o) && o.effect);
}
function createOptionsStore(id, options, pinia, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia.state.value[id];
  let store;
  function setup() {
    if (!initialState && true) {
      pinia.state.value[id] = state ? state() : {};
    }
    const localState = toRefs(pinia.state.value[id]);
    return assign$3(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia);
        const store2 = pinia._s.get(id);
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id, setup, options, pinia, hot, true);
  return store;
}
function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$3({ actions: {} }, options);
  const $subscribeOptions = { deep: true };
  let isListening;
  let isSyncListening;
  let subscriptions = [];
  let actionSubscriptions = [];
  let debuggerEvents;
  const initialState = pinia.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    pinia.state.value[$id] = {};
  }
  ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state } = options;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign$3($state, newState);
    });
  } : (
    /* istanbul ignore next */
    noop$1
  );
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia._s.delete($id);
  }
  const action = (fn, name = "") => {
    if (ACTION_MARKER in fn) {
      fn[ACTION_NAME] = name;
      return fn;
    }
    const wrappedAction = function() {
      setActivePinia(pinia);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name: wrappedAction[ACTION_NAME],
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = fn.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          triggerSubscriptions(afterCallbackList, value);
          return value;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
    wrappedAction[ACTION_MARKER] = true;
    wrappedAction[ACTION_NAME] = name;
    return wrappedAction;
  };
  const partialStore = {
    _p: pinia,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign$3({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(partialStore);
  pinia._s.set($id, store);
  const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
  const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup({ action }))));
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        pinia.state.value[$id][key] = prop;
      }
    } else if (typeof prop === "function") {
      const actionValue = action(prop, key);
      setupStore[key] = actionValue;
      optionsForPlugin.actions[key] = prop;
    } else ;
  }
  assign$3(store, setupStore);
  assign$3(toRaw(store), setupStore);
  Object.defineProperty(store, "$state", {
    get: () => pinia.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        assign$3($state, state);
      });
    }
  });
  pinia._p.forEach((extender) => {
    {
      assign$3(store, scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineStore(id, setup, setupOptions) {
  let options;
  const isSetupStore = typeof setup === "function";
  options = isSetupStore ? setupOptions : setup;
  function useStore(pinia, hot) {
    const hasContext = hasInjectionContext();
    pinia = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    (pinia) || (hasContext ? inject(piniaSymbol, null) : null);
    if (pinia)
      setActivePinia(pinia);
    pinia = activePinia;
    if (!pinia._s.has(id)) {
      if (isSetupStore) {
        createSetupStore(id, setup, options, pinia);
      } else {
        createOptionsStore(id, options, pinia);
      }
    }
    const store = pinia._s.get(id);
    return store;
  }
  useStore.$id = id;
  return useStore;
}

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var isFunction$1 = (value) => typeof value === "function";
var isString$2 = (value) => typeof value === "string";
var isNonEmptyString = (value) => isString$2(value) && value.trim().length > 0;
var isNumber$1 = (value) => typeof value === "number";
var isUndefined = (value) => typeof value === "undefined";
var isObject$2 = (value) => typeof value === "object" && value !== null;
var isJSX = (obj) => hasProp(obj, "tag") && isNonEmptyString(obj.tag);
var isTouchEvent = (event) => window.TouchEvent && event instanceof TouchEvent;
var isToastComponent = (obj) => hasProp(obj, "component") && isToastContent(obj.component);
var isVueComponent = (c) => isFunction$1(c) || isObject$2(c);
var isToastContent = (obj) => !isUndefined(obj) && (isString$2(obj) || isVueComponent(obj) || isToastComponent(obj));
var isDOMRect = (obj) => isObject$2(obj) && ["height", "width", "right", "left", "top", "bottom"].every((p) => isNumber$1(obj[p]));
var hasProp = (obj, propKey) => (isObject$2(obj) || isFunction$1(obj)) && propKey in obj;
var getId = ((i) => () => i++)(0);
function getX(event) {
  return isTouchEvent(event) ? event.targetTouches[0].clientX : event.clientX;
}
function getY(event) {
  return isTouchEvent(event) ? event.targetTouches[0].clientY : event.clientY;
}
var removeElement = (el) => {
  if (!isUndefined(el.remove)) {
    el.remove();
  } else if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
};
var getVueComponentFromObj = (obj) => {
  if (isToastComponent(obj)) {
    return getVueComponentFromObj(obj.component);
  }
  if (isJSX(obj)) {
    return defineComponent({
      render() {
        return obj;
      }
    });
  }
  return typeof obj === "string" ? obj : toRaw(unref(obj));
};
var normalizeToastComponent = (obj) => {
  if (typeof obj === "string") {
    return obj;
  }
  const props = hasProp(obj, "props") && isObject$2(obj.props) ? obj.props : {};
  const listeners = hasProp(obj, "listeners") && isObject$2(obj.listeners) ? obj.listeners : {};
  return { component: getVueComponentFromObj(obj), props, listeners };
};
var isBrowser$1 = () => typeof window !== "undefined";

// src/ts/eventBus.ts
var EventBus = class {
  constructor() {
    this.allHandlers = {};
  }
  getHandlers(eventType) {
    return this.allHandlers[eventType] || [];
  }
  on(eventType, handler) {
    const handlers = this.getHandlers(eventType);
    handlers.push(handler);
    this.allHandlers[eventType] = handlers;
  }
  off(eventType, handler) {
    const handlers = this.getHandlers(eventType);
    handlers.splice(handlers.indexOf(handler) >>> 0, 1);
  }
  emit(eventType, event) {
    const handlers = this.getHandlers(eventType);
    handlers.forEach((handler) => handler(event));
  }
};
var isEventBusInterface = (e) => ["on", "off", "emit"].every((f) => hasProp(e, f) && isFunction$1(e[f]));

// src/ts/constants.ts
var TYPE;
(function(TYPE2) {
  TYPE2["SUCCESS"] = "success";
  TYPE2["ERROR"] = "error";
  TYPE2["WARNING"] = "warning";
  TYPE2["INFO"] = "info";
  TYPE2["DEFAULT"] = "default";
})(TYPE || (TYPE = {}));
var POSITION;
(function(POSITION2) {
  POSITION2["TOP_LEFT"] = "top-left";
  POSITION2["TOP_CENTER"] = "top-center";
  POSITION2["TOP_RIGHT"] = "top-right";
  POSITION2["BOTTOM_LEFT"] = "bottom-left";
  POSITION2["BOTTOM_CENTER"] = "bottom-center";
  POSITION2["BOTTOM_RIGHT"] = "bottom-right";
})(POSITION || (POSITION = {}));
var EVENTS;
(function(EVENTS2) {
  EVENTS2["ADD"] = "add";
  EVENTS2["DISMISS"] = "dismiss";
  EVENTS2["UPDATE"] = "update";
  EVENTS2["CLEAR"] = "clear";
  EVENTS2["UPDATE_DEFAULTS"] = "update_defaults";
})(EVENTS || (EVENTS = {}));
var VT_NAMESPACE = "Vue-Toastification";

// src/ts/propValidators.ts
var COMMON = {
  type: {
    type: String,
    default: TYPE.DEFAULT
  },
  classNames: {
    type: [String, Array],
    default: () => []
  },
  trueBoolean: {
    type: Boolean,
    default: true
  }
};
var ICON = {
  type: COMMON.type,
  customIcon: {
    type: [String, Boolean, Object, Function],
    default: true
  }
};
var CLOSE_BUTTON = {
  component: {
    type: [String, Object, Function, Boolean],
    default: "button"
  },
  classNames: COMMON.classNames,
  showOnHover: {
    type: Boolean,
    default: false
  },
  ariaLabel: {
    type: String,
    default: "close"
  }
};
var PROGRESS_BAR = {
  timeout: {
    type: [Number, Boolean],
    default: 5e3
  },
  hideProgressBar: {
    type: Boolean,
    default: false
  },
  isRunning: {
    type: Boolean,
    default: false
  }
};
var TRANSITION = {
  transition: {
    type: [Object, String],
    default: `${VT_NAMESPACE}__bounce`
  }
};
var CORE_TOAST = {
  position: {
    type: String,
    default: POSITION.TOP_RIGHT
  },
  draggable: COMMON.trueBoolean,
  draggablePercent: {
    type: Number,
    default: 0.6
  },
  pauseOnFocusLoss: COMMON.trueBoolean,
  pauseOnHover: COMMON.trueBoolean,
  closeOnClick: COMMON.trueBoolean,
  timeout: PROGRESS_BAR.timeout,
  hideProgressBar: PROGRESS_BAR.hideProgressBar,
  toastClassName: COMMON.classNames,
  bodyClassName: COMMON.classNames,
  icon: ICON.customIcon,
  closeButton: CLOSE_BUTTON.component,
  closeButtonClassName: CLOSE_BUTTON.classNames,
  showCloseButtonOnHover: CLOSE_BUTTON.showOnHover,
  accessibility: {
    type: Object,
    default: () => ({
      toastRole: "alert",
      closeButtonLabel: "close"
    })
  },
  rtl: {
    type: Boolean,
    default: false
  },
  eventBus: {
    type: Object,
    required: false,
    default: () => new EventBus()
  }
};
var TOAST = {
  id: {
    type: [String, Number],
    required: true,
    default: 0
  },
  type: COMMON.type,
  content: {
    type: [String, Object, Function],
    required: true,
    default: ""
  },
  onClick: {
    type: Function,
    default: void 0
  },
  onClose: {
    type: Function,
    default: void 0
  }
};
var CONTAINER = {
  container: {
    type: [
      Object,
      Function
    ],
    default: () => document.body
  },
  newestOnTop: COMMON.trueBoolean,
  maxToasts: {
    type: Number,
    default: 20
  },
  transition: TRANSITION.transition,
  toastDefaults: Object,
  filterBeforeCreate: {
    type: Function,
    default: (toast) => toast
  },
  filterToasts: {
    type: Function,
    default: (toasts) => toasts
  },
  containerClassName: COMMON.classNames,
  onMounted: Function,
  shareAppContext: [Boolean, Object]
};
var propValidators_default = {
  CORE_TOAST,
  TOAST,
  CONTAINER,
  PROGRESS_BAR,
  ICON,
  TRANSITION,
  CLOSE_BUTTON
};
var VtProgressBar_default = defineComponent({
  name: "VtProgressBar",
  props: propValidators_default.PROGRESS_BAR,
  data() {
    return {
      hasClass: true
    };
  },
  computed: {
    style() {
      return {
        animationDuration: `${this.timeout}ms`,
        animationPlayState: this.isRunning ? "running" : "paused",
        opacity: this.hideProgressBar ? 0 : 1
      };
    },
    cpClass() {
      return this.hasClass ? `${VT_NAMESPACE}__progress-bar` : "";
    }
  },
  watch: {
    timeout() {
      this.hasClass = false;
      this.$nextTick(() => this.hasClass = true);
    }
  },
  mounted() {
    this.$el.addEventListener("animationend", this.animationEnded);
  },
  beforeUnmount() {
    this.$el.removeEventListener("animationend", this.animationEnded);
  },
  methods: {
    animationEnded() {
      this.$emit("close-toast");
    }
  }
});
function render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", {
    style: normalizeStyle(_ctx.style),
    class: normalizeClass(_ctx.cpClass)
  }, null, 6);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtProgressBar.vue
VtProgressBar_default.render = render;
var VtProgressBar_default2 = VtProgressBar_default;
var VtCloseButton_default = defineComponent({
  name: "VtCloseButton",
  props: propValidators_default.CLOSE_BUTTON,
  computed: {
    buttonComponent() {
      if (this.component !== false) {
        return getVueComponentFromObj(this.component);
      }
      return "button";
    },
    classes() {
      const classes = [`${VT_NAMESPACE}__close-button`];
      if (this.showOnHover) {
        classes.push("show-on-hover");
      }
      return classes.concat(this.classNames);
    }
  }
});
var _hoisted_1$1t = /* @__PURE__ */ createTextVNode(" \xD7 ");
function render2(_ctx, _cache) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.buttonComponent), mergeProps({
    "aria-label": _ctx.ariaLabel,
    class: _ctx.classes
  }, _ctx.$attrs), {
    default: withCtx(() => [
      _hoisted_1$1t
    ]),
    _: 1
  }, 16, ["aria-label", "class"]);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtCloseButton.vue
VtCloseButton_default.render = render2;
var VtCloseButton_default2 = VtCloseButton_default;

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtSuccessIcon.vue?vue&type=script
var VtSuccessIcon_default = {};
var _hoisted_12$10 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "check-circle",
  class: "svg-inline--fa fa-check-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
var _hoisted_2$1q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"
}, null, -1);
var _hoisted_3$1m = [
  _hoisted_2$1q
];
function render3(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_12$10, _hoisted_3$1m);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtSuccessIcon.vue
VtSuccessIcon_default.render = render3;
var VtSuccessIcon_default2 = VtSuccessIcon_default;

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtInfoIcon.vue?vue&type=script
var VtInfoIcon_default = {};
var _hoisted_13$10 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "info-circle",
  class: "svg-inline--fa fa-info-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
var _hoisted_22$O = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"
}, null, -1);
var _hoisted_32$x = [
  _hoisted_22$O
];
function render4(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_13$10, _hoisted_32$x);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtInfoIcon.vue
VtInfoIcon_default.render = render4;
var VtInfoIcon_default2 = VtInfoIcon_default;

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtWarningIcon.vue?vue&type=script
var VtWarningIcon_default = {};
var _hoisted_14$$ = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "exclamation-circle",
  class: "svg-inline--fa fa-exclamation-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
var _hoisted_23$O = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
}, null, -1);
var _hoisted_33$w = [
  _hoisted_23$O
];
function render5(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_14$$, _hoisted_33$w);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtWarningIcon.vue
VtWarningIcon_default.render = render5;
var VtWarningIcon_default2 = VtWarningIcon_default;

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtErrorIcon.vue?vue&type=script
var VtErrorIcon_default = {};
var _hoisted_15$V = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "exclamation-triangle",
  class: "svg-inline--fa fa-exclamation-triangle fa-w-18",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 576 512"
};
var _hoisted_24$M = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
}, null, -1);
var _hoisted_34$t = [
  _hoisted_24$M
];
function render6(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_15$V, _hoisted_34$t);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtErrorIcon.vue
VtErrorIcon_default.render = render6;
var VtErrorIcon_default2 = VtErrorIcon_default;

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtIcon.vue?vue&type=script
var VtIcon_default = defineComponent({
  name: "VtIcon",
  props: propValidators_default.ICON,
  computed: {
    customIconChildren() {
      return hasProp(this.customIcon, "iconChildren") ? this.trimValue(this.customIcon.iconChildren) : "";
    },
    customIconClass() {
      if (isString$2(this.customIcon)) {
        return this.trimValue(this.customIcon);
      } else if (hasProp(this.customIcon, "iconClass")) {
        return this.trimValue(this.customIcon.iconClass);
      }
      return "";
    },
    customIconTag() {
      if (hasProp(this.customIcon, "iconTag")) {
        return this.trimValue(this.customIcon.iconTag, "i");
      }
      return "i";
    },
    hasCustomIcon() {
      return this.customIconClass.length > 0;
    },
    component() {
      if (this.hasCustomIcon) {
        return this.customIconTag;
      }
      if (isToastContent(this.customIcon)) {
        return getVueComponentFromObj(this.customIcon);
      }
      return this.iconTypeComponent;
    },
    iconTypeComponent() {
      const types = {
        [TYPE.DEFAULT]: VtInfoIcon_default2,
        [TYPE.INFO]: VtInfoIcon_default2,
        [TYPE.SUCCESS]: VtSuccessIcon_default2,
        [TYPE.ERROR]: VtErrorIcon_default2,
        [TYPE.WARNING]: VtWarningIcon_default2
      };
      return types[this.type];
    },
    iconClasses() {
      const classes = [`${VT_NAMESPACE}__icon`];
      if (this.hasCustomIcon) {
        return classes.concat(this.customIconClass);
      }
      return classes;
    }
  },
  methods: {
    trimValue(value, empty = "") {
      return isNonEmptyString(value) ? value.trim() : empty;
    }
  }
});
function render7(_ctx, _cache) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.component), {
    class: normalizeClass(_ctx.iconClasses)
  }, {
    default: withCtx(() => [
      createTextVNode(toDisplayString$1(_ctx.customIconChildren), 1)
    ]),
    _: 1
  }, 8, ["class"]);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtIcon.vue
VtIcon_default.render = render7;
var VtIcon_default2 = VtIcon_default;

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtToast.vue?vue&type=script
var VtToast_default = defineComponent({
  name: "VtToast",
  components: { ProgressBar: VtProgressBar_default2, CloseButton: VtCloseButton_default2, Icon: VtIcon_default2 },
  inheritAttrs: false,
  props: Object.assign({}, propValidators_default.CORE_TOAST, propValidators_default.TOAST),
  data() {
    const data = {
      isRunning: true,
      disableTransitions: false,
      beingDragged: false,
      dragStart: 0,
      dragPos: { x: 0, y: 0 },
      dragRect: {}
    };
    return data;
  },
  computed: {
    classes() {
      const classes = [
        `${VT_NAMESPACE}__toast`,
        `${VT_NAMESPACE}__toast--${this.type}`,
        `${this.position}`
      ].concat(this.toastClassName);
      if (this.disableTransitions) {
        classes.push("disable-transition");
      }
      if (this.rtl) {
        classes.push(`${VT_NAMESPACE}__toast--rtl`);
      }
      return classes;
    },
    bodyClasses() {
      const classes = [
        `${VT_NAMESPACE}__toast-${isString$2(this.content) ? "body" : "component-body"}`
      ].concat(this.bodyClassName);
      return classes;
    },
    draggableStyle() {
      if (this.dragStart === this.dragPos.x) {
        return {};
      } else if (this.beingDragged) {
        return {
          transform: `translateX(${this.dragDelta}px)`,
          opacity: 1 - Math.abs(this.dragDelta / this.removalDistance)
        };
      } else {
        return {
          transition: "transform 0.2s, opacity 0.2s",
          transform: "translateX(0)",
          opacity: 1
        };
      }
    },
    dragDelta() {
      return this.beingDragged ? this.dragPos.x - this.dragStart : 0;
    },
    removalDistance() {
      if (isDOMRect(this.dragRect)) {
        return (this.dragRect.right - this.dragRect.left) * this.draggablePercent;
      }
      return 0;
    }
  },
  mounted() {
    if (this.draggable) {
      this.draggableSetup();
    }
    if (this.pauseOnFocusLoss) {
      this.focusSetup();
    }
  },
  beforeUnmount() {
    if (this.draggable) {
      this.draggableCleanup();
    }
    if (this.pauseOnFocusLoss) {
      this.focusCleanup();
    }
  },
  methods: {
    hasProp,
    getVueComponentFromObj,
    closeToast() {
      this.eventBus.emit(EVENTS.DISMISS, this.id);
    },
    clickHandler() {
      if (this.onClick) {
        this.onClick(this.closeToast);
      }
      if (this.closeOnClick) {
        if (!this.beingDragged || this.dragStart === this.dragPos.x) {
          this.closeToast();
        }
      }
    },
    timeoutHandler() {
      this.closeToast();
    },
    hoverPause() {
      if (this.pauseOnHover) {
        this.isRunning = false;
      }
    },
    hoverPlay() {
      if (this.pauseOnHover) {
        this.isRunning = true;
      }
    },
    focusPause() {
      this.isRunning = false;
    },
    focusPlay() {
      this.isRunning = true;
    },
    focusSetup() {
      addEventListener("blur", this.focusPause);
      addEventListener("focus", this.focusPlay);
    },
    focusCleanup() {
      removeEventListener("blur", this.focusPause);
      removeEventListener("focus", this.focusPlay);
    },
    draggableSetup() {
      const element = this.$el;
      element.addEventListener("touchstart", this.onDragStart, {
        passive: true
      });
      element.addEventListener("mousedown", this.onDragStart);
      addEventListener("touchmove", this.onDragMove, { passive: false });
      addEventListener("mousemove", this.onDragMove);
      addEventListener("touchend", this.onDragEnd);
      addEventListener("mouseup", this.onDragEnd);
    },
    draggableCleanup() {
      const element = this.$el;
      element.removeEventListener("touchstart", this.onDragStart);
      element.removeEventListener("mousedown", this.onDragStart);
      removeEventListener("touchmove", this.onDragMove);
      removeEventListener("mousemove", this.onDragMove);
      removeEventListener("touchend", this.onDragEnd);
      removeEventListener("mouseup", this.onDragEnd);
    },
    onDragStart(event) {
      this.beingDragged = true;
      this.dragPos = { x: getX(event), y: getY(event) };
      this.dragStart = getX(event);
      this.dragRect = this.$el.getBoundingClientRect();
    },
    onDragMove(event) {
      if (this.beingDragged) {
        event.preventDefault();
        if (this.isRunning) {
          this.isRunning = false;
        }
        this.dragPos = { x: getX(event), y: getY(event) };
      }
    },
    onDragEnd() {
      if (this.beingDragged) {
        if (Math.abs(this.dragDelta) >= this.removalDistance) {
          this.disableTransitions = true;
          this.$nextTick(() => this.closeToast());
        } else {
          setTimeout(() => {
            this.beingDragged = false;
            if (isDOMRect(this.dragRect) && this.pauseOnHover && this.dragRect.bottom >= this.dragPos.y && this.dragPos.y >= this.dragRect.top && this.dragRect.left <= this.dragPos.x && this.dragPos.x <= this.dragRect.right) {
              this.isRunning = false;
            } else {
              this.isRunning = true;
            }
          });
        }
      }
    }
  }
});
var _hoisted_16$U = ["role"];
function render8(_ctx, _cache) {
  const _component_Icon = resolveComponent("Icon");
  const _component_CloseButton = resolveComponent("CloseButton");
  const _component_ProgressBar = resolveComponent("ProgressBar");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.draggableStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.clickHandler && _ctx.clickHandler(...args)),
    onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.hoverPause && _ctx.hoverPause(...args)),
    onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.hoverPlay && _ctx.hoverPlay(...args))
  }, [
    _ctx.icon ? (openBlock(), createBlock(_component_Icon, {
      key: 0,
      "custom-icon": _ctx.icon,
      type: _ctx.type
    }, null, 8, ["custom-icon", "type"])) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      role: _ctx.accessibility.toastRole || "alert",
      class: normalizeClass(_ctx.bodyClasses)
    }, [
      typeof _ctx.content === "string" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createTextVNode(toDisplayString$1(_ctx.content), 1)
      ], 2112)) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.getVueComponentFromObj(_ctx.content)), mergeProps({
        key: 1,
        "toast-id": _ctx.id
      }, _ctx.hasProp(_ctx.content, "props") ? _ctx.content.props : {}, toHandlers(_ctx.hasProp(_ctx.content, "listeners") ? _ctx.content.listeners : {}), { onCloseToast: _ctx.closeToast }), null, 16, ["toast-id", "onCloseToast"]))
    ], 10, _hoisted_16$U),
    !!_ctx.closeButton ? (openBlock(), createBlock(_component_CloseButton, {
      key: 1,
      component: _ctx.closeButton,
      "class-names": _ctx.closeButtonClassName,
      "show-on-hover": _ctx.showCloseButtonOnHover,
      "aria-label": _ctx.accessibility.closeButtonLabel,
      onClick: withModifiers(_ctx.closeToast, ["stop"])
    }, null, 8, ["component", "class-names", "show-on-hover", "aria-label", "onClick"])) : createCommentVNode("v-if", true),
    _ctx.timeout ? (openBlock(), createBlock(_component_ProgressBar, {
      key: 2,
      "is-running": _ctx.isRunning,
      "hide-progress-bar": _ctx.hideProgressBar,
      timeout: _ctx.timeout,
      onCloseToast: _ctx.timeoutHandler
    }, null, 8, ["is-running", "hide-progress-bar", "timeout", "onCloseToast"])) : createCommentVNode("v-if", true)
  ], 38);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtToast.vue
VtToast_default.render = render8;
var VtToast_default2 = VtToast_default;
var VtTransition_default = defineComponent({
  name: "VtTransition",
  props: propValidators_default.TRANSITION,
  emits: ["leave"],
  methods: {
    hasProp,
    leave(el) {
      if (el instanceof HTMLElement) {
        el.style.left = el.offsetLeft + "px";
        el.style.top = el.offsetTop + "px";
        el.style.width = getComputedStyle(el).width;
        el.style.position = "absolute";
      }
    }
  }
});
function render9(_ctx, _cache) {
  return openBlock(), createBlock(TransitionGroup, {
    tag: "div",
    "enter-active-class": _ctx.transition.enter ? _ctx.transition.enter : `${_ctx.transition}-enter-active`,
    "move-class": _ctx.transition.move ? _ctx.transition.move : `${_ctx.transition}-move`,
    "leave-active-class": _ctx.transition.leave ? _ctx.transition.leave : `${_ctx.transition}-leave-active`,
    onLeave: _ctx.leave
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["enter-active-class", "move-class", "leave-active-class", "onLeave"]);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtTransition.vue
VtTransition_default.render = render9;
var VtTransition_default2 = VtTransition_default;

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtToastContainer.vue?vue&type=script
var VtToastContainer_default = defineComponent({
  name: "VueToastification",
  devtools: {
    hide: true
  },
  components: { Toast: VtToast_default2, VtTransition: VtTransition_default2 },
  props: Object.assign({}, propValidators_default.CORE_TOAST, propValidators_default.CONTAINER, propValidators_default.TRANSITION),
  data() {
    const data = {
      count: 0,
      positions: Object.values(POSITION),
      toasts: {},
      defaults: {}
    };
    return data;
  },
  computed: {
    toastArray() {
      return Object.values(this.toasts);
    },
    filteredToasts() {
      return this.defaults.filterToasts(this.toastArray);
    }
  },
  beforeMount() {
    const events = this.eventBus;
    events.on(EVENTS.ADD, this.addToast);
    events.on(EVENTS.CLEAR, this.clearToasts);
    events.on(EVENTS.DISMISS, this.dismissToast);
    events.on(EVENTS.UPDATE, this.updateToast);
    events.on(EVENTS.UPDATE_DEFAULTS, this.updateDefaults);
    this.defaults = this.$props;
  },
  mounted() {
    this.setup(this.container);
  },
  methods: {
    async setup(container) {
      if (isFunction$1(container)) {
        container = await container();
      }
      removeElement(this.$el);
      container.appendChild(this.$el);
    },
    setToast(props) {
      if (!isUndefined(props.id)) {
        this.toasts[props.id] = props;
      }
    },
    addToast(params) {
      params.content = normalizeToastComponent(params.content);
      const props = Object.assign({}, this.defaults, params.type && this.defaults.toastDefaults && this.defaults.toastDefaults[params.type], params);
      const toast = this.defaults.filterBeforeCreate(props, this.toastArray);
      toast && this.setToast(toast);
    },
    dismissToast(id) {
      const toast = this.toasts[id];
      if (!isUndefined(toast) && !isUndefined(toast.onClose)) {
        toast.onClose();
      }
      delete this.toasts[id];
    },
    clearToasts() {
      Object.keys(this.toasts).forEach((id) => {
        this.dismissToast(id);
      });
    },
    getPositionToasts(position) {
      const toasts = this.filteredToasts.filter((toast) => toast.position === position).slice(0, this.defaults.maxToasts);
      return this.defaults.newestOnTop ? toasts.reverse() : toasts;
    },
    updateDefaults(update) {
      if (!isUndefined(update.container)) {
        this.setup(update.container);
      }
      this.defaults = Object.assign({}, this.defaults, update);
    },
    updateToast({
      id,
      options,
      create
    }) {
      if (this.toasts[id]) {
        if (options.timeout && options.timeout === this.toasts[id].timeout) {
          options.timeout++;
        }
        this.setToast(Object.assign({}, this.toasts[id], options));
      } else if (create) {
        this.addToast(Object.assign({}, { id }, options));
      }
    },
    getClasses(position) {
      const classes = [`${VT_NAMESPACE}__container`, position];
      return classes.concat(this.defaults.containerClassName);
    }
  }
});
function render10(_ctx, _cache) {
  const _component_Toast = resolveComponent("Toast");
  const _component_VtTransition = resolveComponent("VtTransition");
  return openBlock(), createElementBlock("div", null, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.positions, (pos) => {
      return openBlock(), createElementBlock("div", { key: pos }, [
        createVNode(_component_VtTransition, {
          transition: _ctx.defaults.transition,
          class: normalizeClass(_ctx.getClasses(pos))
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.getPositionToasts(pos), (toast) => {
              return openBlock(), createBlock(_component_Toast, mergeProps({
                key: toast.id
              }, toast), null, 16);
            }), 128))
          ]),
          _: 2
        }, 1032, ["transition", "class"])
      ]);
    }), 128))
  ]);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtToastContainer.vue
VtToastContainer_default.render = render10;
var VtToastContainer_default2 = VtToastContainer_default;

// src/ts/interface.ts
var buildInterface = (globalOptions = {}, mountContainer = true) => {
  const events = globalOptions.eventBus = globalOptions.eventBus || new EventBus();
  if (mountContainer) {
    nextTick(() => {
      const app = createApp(VtToastContainer_default2, __spreadValues({}, globalOptions));
      const component = app.mount(document.createElement("div"));
      const onMounted = globalOptions.onMounted;
      if (!isUndefined(onMounted)) {
        onMounted(component, app);
      }
      if (globalOptions.shareAppContext) {
        const baseApp = globalOptions.shareAppContext;
        if (baseApp === true) {
          console.warn(`[${VT_NAMESPACE}] App to share context with was not provided.`);
        } else {
          app._context.components = baseApp._context.components;
          app._context.directives = baseApp._context.directives;
          app._context.mixins = baseApp._context.mixins;
          app._context.provides = baseApp._context.provides;
          app.config.globalProperties = baseApp.config.globalProperties;
        }
      }
    });
  }
  const toast = (content, options) => {
    const props = Object.assign({}, { id: getId(), type: TYPE.DEFAULT }, options, {
      content
    });
    events.emit(EVENTS.ADD, props);
    return props.id;
  };
  toast.clear = () => events.emit(EVENTS.CLEAR, void 0);
  toast.updateDefaults = (update) => {
    events.emit(EVENTS.UPDATE_DEFAULTS, update);
  };
  toast.dismiss = (id) => {
    events.emit(EVENTS.DISMISS, id);
  };
  function updateToast(id, { content, options }, create = false) {
    const opt = Object.assign({}, options, { content });
    events.emit(EVENTS.UPDATE, {
      id,
      options: opt,
      create
    });
  }
  toast.update = updateToast;
  toast.success = (content, options) => toast(content, Object.assign({}, options, { type: TYPE.SUCCESS }));
  toast.info = (content, options) => toast(content, Object.assign({}, options, { type: TYPE.INFO }));
  toast.error = (content, options) => toast(content, Object.assign({}, options, { type: TYPE.ERROR }));
  toast.warning = (content, options) => toast(content, Object.assign({}, options, { type: TYPE.WARNING }));
  return toast;
};

// src/index.ts
var createMockToastInterface = () => {
  const toast = () => console.warn(`[${VT_NAMESPACE}] This plugin does not support SSR!`);
  return new Proxy(toast, {
    get() {
      return toast;
    }
  });
};
function createToastInterface(optionsOrEventBus) {
  if (!isBrowser$1()) {
    return createMockToastInterface();
  }
  if (isEventBusInterface(optionsOrEventBus)) {
    return buildInterface({ eventBus: optionsOrEventBus }, false);
  }
  return buildInterface(optionsOrEventBus, true);
}
var toastInjectionKey = Symbol("VueToastification");
var globalEventBus = new EventBus();
var VueToastificationPlugin = (App, options) => {
  if ((options == null ? void 0 : options.shareAppContext) === true) {
    options.shareAppContext = App;
  }
  const inter = createToastInterface(__spreadValues({
    eventBus: globalEventBus
  }, options));
  App.provide(toastInjectionKey, inter);
};
var useToast = (eventBus) => {
  const toast = getCurrentInstance() ? inject(toastInjectionKey, void 0) : void 0;
  return toast ? toast : createToastInterface(globalEventBus);
};
var src_default = VueToastificationPlugin;

const scriptRel = 'modulepreload';const assetsURL = function(dep) { return "/web-english/"+dep };const seen = {};const __vitePreload = function preload(baseModule, deps, importerUrl) {
	let promise = Promise.resolve();
	if (true               && deps && deps.length > 0) {
		document.getElementsByTagName("link");
		const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
		const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
		function allSettled(promises$2) {
			return Promise.all(promises$2.map((p$1) => Promise.resolve(p$1).then((value$1) => ({
				status: "fulfilled",
				value: value$1
			}), (reason) => ({
				status: "rejected",
				reason
			}))));
		}
		promise = allSettled(deps.map((dep) => {
			dep = assetsURL(dep);
			if (dep in seen) return;
			seen[dep] = true;
			const isCss = dep.endsWith(".css");
			const cssSelector = isCss ? "[rel=\"stylesheet\"]" : "";
			if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
			const link = document.createElement("link");
			link.rel = isCss ? "stylesheet" : scriptRel;
			if (!isCss) link.as = "script";
			link.crossOrigin = "";
			link.href = dep;
			if (cspNonce) link.setAttribute("nonce", cspNonce);
			document.head.appendChild(link);
			if (isCss) return new Promise((res, rej) => {
				link.addEventListener("load", res);
				link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
			});
		}));
	}
	function handlePreloadError(err$2) {
		const e$1 = new Event("vite:preloadError", { cancelable: true });
		e$1.payload = err$2;
		window.dispatchEvent(e$1);
		if (!e$1.defaultPrevented) throw err$2;
	}
	return promise.then((res) => {
		for (const item of res || []) {
			if (item.status !== "rejected") continue;
			handlePreloadError(item.reason);
		}
		return baseModule().catch(handlePreloadError);
	});
};

/*!
  * vue-router v4.5.1
  * (c) 2025 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof document !== "undefined";
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module" || // support CF with dynamic imports that do not
  // add the Module string tag
  obj.default && isRouteComponent(obj.default);
}
const assign$2 = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = isArray$1(value) ? value.map(fn) : fn(value);
  }
  return newParams;
}
const noop = () => {
};
const isArray$1 = Array.isArray;
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash = "";
  const hashPos = location2.indexOf("#");
  let searchPos = location2.indexOf("?");
  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash,
    path,
    query,
    hash: decode(hash)
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a, b) {
  const aLastIndex = a.matched.length - 1;
  const bLastIndex = b.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
}
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length)
    return false;
  for (const key in a) {
    if (!isSameRouteLocationParamsValue(a[key], b[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a, b) {
  return isArray$1(a) ? isEquivalentArray(a, b) : isArray$1(b) ? isEquivalentArray(b, a) : a === b;
}
function isEquivalentArray(a, b) {
  return isArray$1(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;
}
function resolveRelativePath(to, from) {
  if (to.startsWith("/"))
    return to;
  if (!to)
    return from;
  const fromSegments = from.split("/");
  const toSegments = to.split("/");
  const lastToSegment = toSegments[toSegments.length - 1];
  if (lastToSegment === ".." || lastToSegment === ".") {
    toSegments.push("");
  }
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".")
      continue;
    if (segment === "..") {
      if (position > 1)
        position--;
    } else
      break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition).join("/");
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  // TODO: could we use a symbol in the future?
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.scrollX,
  top: window.scrollY
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
  }
}
function getScrollKey(path, delta) {
  const position = history.state ? history.state.position - delta : -1;
  return position + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search, hash } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to = createCurrentLocation(base, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }
      delta = fromState ? state.position - fromState.position : 0;
    } else {
      replace(to);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index = listeners.indexOf(callback);
      if (index > -1)
        listeners.splice(index, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign$2({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener, {
    passive: true
  });
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      // the length is off by one, we need to decrease it
      position: history2.length - 1,
      replaced: true,
      // don't add a scroll as the user may have an anchor, and we want
      // scrollBehavior to be triggered without a saved position
      scroll: null
    }, true);
  }
  function changeLocation(to, state, replace2) {
    const hashIndex = base.indexOf("#");
    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state, "", url);
      historyState.value = state;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url);
    }
  }
  function replace(to, data) {
    const state = assign$2({}, history2.state, buildState(
      historyState.value.back,
      // keep back and forward entries but override current position
      to,
      historyState.value.forward,
      true
    ), data, { position: historyState.value.position });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  function push(to, data) {
    const currentState = assign$2(
      {},
      // use current history state to gracefully handle a wrong call to
      // history.replaceState
      // https://github.com/vuejs/router/issues/366
      historyState.value,
      history2.state,
      {
        forward: to,
        scroll: computeScrollPosition()
      }
    );
    changeLocation(currentState.current, currentState, true);
    const state = assign$2({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign$2({
    // it's overridden right after
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function createWebHashHistory(base) {
  base = location.host ? base || location.pathname + location.search : "";
  if (!base.includes("#"))
    base += "#";
  return createWebHistory(base);
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type, params) {
  {
    return assign$2(new Error(), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign$2({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [
      90
      /* PathScore.Root */
    ];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token.type === 1) {
        const { value, repeatable, optional, regexp } = token;
        keys.push({
          name: value,
          repeatable,
          optional
        });
        const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re2 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re2})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
        if (!tokenIndex)
          subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
          // or /:p?-:p2
          optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re2 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i = score.length - 1;
    score[i][score[i].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict && !pattern.endsWith("/"))
    pattern += "(?:/|$)";
  const re = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse(path) {
    const match = path.match(re);
    const params = {};
    if (!match)
      return null;
    for (let i = 1; i < match.length; i++) {
      const value = match[i] || "";
      const key = keys[i - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) {
        if (token.type === 0) {
          path += token.value;
        } else if (token.type === 1) {
          const { value, repeatable, optional } = token;
          const param = value in params ? params[value] : "";
          if (isArray$1(param) && !repeatable) {
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          }
          const text = isArray$1(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path += text;
        }
      }
    }
    return path || "/";
  }
  return {
    re,
    score,
    keys,
    parse,
    stringify
  };
}
function compareScoreArray(a, b) {
  let i = 0;
  while (i < a.length && i < b.length) {
    const diff = b[i] - a[i];
    if (diff)
      return diff;
    i++;
  }
  if (a.length < b.length) {
    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
  } else if (a.length > b.length) {
    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a, b) {
  let i = 0;
  const aScore = a.score;
  const bScore = b.score;
  while (i < aScore.length && i < bScore.length) {
    const comp = compareScoreArray(aScore[i], bScore[i]);
    if (comp)
      return comp;
    i++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i = 0;
  let char;
  let buffer = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer = "";
  }
  function addCharToBuffer() {
    buffer += char;
  }
  while (i < path.length) {
    char = path[i++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign$2(parser, {
    record,
    parent,
    // these needs to be populated by the parent
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [mainNormalizedRecord];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(
          // we need to normalize again to ensure the `mods` property
          // being non enumerable
          normalizeRouteRecord(assign$2({}, mainNormalizedRecord, {
            // this allows us to hold a copy of the `components` option
            // so that async components cache is hold on the original record
            components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
            path: alias,
            // we might be the child of an alias
            aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
            // the aliases are always of the same kind as the original since they
            // are defined on the same record
          }))
        );
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher)) {
          removeRoute(record.name);
        }
      }
      if (isMatchable(matcher)) {
        insertMatcher(matcher);
      }
      if (mainNormalizedRecord.children) {
        const children = mainNormalizedRecord.children;
        for (let i = 0; i < children.length; i++) {
          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
        }
      }
      originalRecord = originalRecord || matcher;
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index = matchers.indexOf(matcherRef);
      if (index > -1) {
        matchers.splice(index, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    const index = findInsertionIndex(matcher, matchers);
    matchers.splice(index, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name = matcher.record.name;
      params = assign$2(
        // paramsFromLocation is a new object
        paramsFromLocation(
          currentLocation.params,
          // only keep params that exist in the resolved location
          // only keep optional params coming from a parent record
          matcher.keys.filter((k) => !k.optional).concat(matcher.parent ? matcher.parent.keys.filter((k) => k.optional) : []).map((k) => k.name)
        ),
        // discard any existing params in the current location that do not exist here
        // #1497 this ensures better active/exact matching
        location2.params && paramsFromLocation(location2.params, matcher.keys.map((k) => k.name))
      );
      path = matcher.stringify(params);
    } else if (location2.path != null) {
      path = location2.path;
      matcher = matchers.find((m) => m.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher.record.name;
      params = assign$2({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes.forEach((route) => addRoute(route));
  function clearRoutes() {
    matchers.length = 0;
    matcherMap.clear();
  }
  return {
    addRoute,
    resolve,
    removeRoute,
    clearRoutes,
    getRoutes,
    getRecordMatcher
  };
}
function paramsFromLocation(params, keys) {
  const newParams = {};
  for (const key of keys) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  const normalized = {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: record.aliasOf,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    // must be declared afterwards
    // mods: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
  Object.defineProperty(normalized, "mods", {
    value: {}
  });
  return normalized;
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props === "object" ? props[name] : props;
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign$2(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
  const options = {};
  for (const key in defaults) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
  }
  return options;
}
function findInsertionIndex(matcher, matchers) {
  let lower = 0;
  let upper = matchers.length;
  while (lower !== upper) {
    const mid = lower + upper >> 1;
    const sortOrder = comparePathParserScore(matcher, matchers[mid]);
    if (sortOrder < 0) {
      upper = mid;
    } else {
      lower = mid + 1;
    }
  }
  const insertionAncestor = getInsertionAncestor(matcher);
  if (insertionAncestor) {
    upper = matchers.lastIndexOf(insertionAncestor, upper - 1);
  }
  return upper;
}
function getInsertionAncestor(matcher) {
  let ancestor = matcher;
  while (ancestor = ancestor.parent) {
    if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) {
      return ancestor;
    }
  }
  return;
}
function isMatchable({ record }) {
  return !!(record.name || record.components && Object.keys(record.components).length || record.redirect);
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?")
    return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i = 0; i < searchParams.length; ++i) {
    const searchParam = searchParams[i].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!isArray$1(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values = isArray$1(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
    values.forEach((value2) => {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value2 != null)
          search += "=" + value2;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value = query[key];
    if (value !== void 0) {
      normalizedQuery[key] = isArray$1(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
const matchedRouteKey = Symbol("");
const viewDepthKey = Symbol("");
const routerKey = Symbol("");
const routeLocationKey = Symbol("");
const routerViewLocationKey = Symbol("");
function useCallbacks() {
  let handlers = [];
  function add(handler) {
    handlers.push(handler);
    return () => {
      const i = handlers.indexOf(handler);
      if (i > -1)
        handlers.splice(i, 1);
    };
  }
  function reset() {
    handlers = [];
  }
  return {
    add,
    list: () => handlers.slice(),
    reset
  };
}
function guardToPromiseFn(guard, to, from, record, name, runWithContext = (fn) => fn()) {
  const enterCallbackArray = record && // name is defined if record is because of the function overload
  (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve, reject) => {
    const next = (valid) => {
      if (valid === false) {
        reject(createRouterError(4, {
          from,
          to
        }));
      } else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
        record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
          enterCallbackArray.push(valid);
        }
        resolve();
      }
    };
    const guardReturn = runWithContext(() => guard.call(record && record.instances[name], to, from, next));
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to, from, runWithContext = (fn) => fn()) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name, runWithContext));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            throw new Error(`Couldn't resolve component "${name}" at "${record.path}"`);
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.mods[name] = resolved;
          record.components[name] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to, from, record, name, runWithContext)();
        }));
      }
    }
  }
  return guards;
}
function useLink(props) {
  const router = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => {
    const to = unref(props.to);
    return router.resolve(to);
  });
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index > -1)
      return index;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return (
      // we are dealing with nested routes
      length > 1 && // if the parent and matched route have the same path, this link is
      // referring to the empty child. Or we currently are on a different
      // child of the same parent
      getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index
    );
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e = {}) {
    if (guardEvent(e)) {
      const p = router[unref(props.replace) ? "replace" : "push"](
        unref(props.to)
        // avoid uncaught errors are they are logged anyway
      ).catch(noop);
      if (props.viewTransition && typeof document !== "undefined" && "startViewTransition" in document) {
        document.startViewTransition(() => p);
      }
      return p;
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
function preferSingleVNode(vnodes) {
  return vnodes.length === 1 ? vnodes[0] : vnodes;
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    },
    viewTransition: Boolean
  },
  useLink,
  setup(props, { slots }) {
    const link = reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && preferSingleVNode(slots.default(link));
      return props.custom ? children : h("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        // this would override user added attrs but Vue will still add
        // the listener, so we end up triggering both
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
    return;
  if (e.defaultPrevented)
    return;
  if (e.button !== void 0 && e.button !== 0)
    return;
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target = e.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e.preventDefault)
    e.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray$1(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  // #674 we manually inherit them
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  // Better compat for @vue/compat users
  // https://github.com/vuejs/router/issues/1315
  compatConfig: { MODE: 3 },
  setup(props, { attrs, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const injectedDepth = inject(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
      if (to) {
        to.instances[name] = instance;
        if (from && from !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from.updateGuards;
          }
        }
      }
      if (instance && to && // if there is no instance but to and from are the same this might be
      // the first visit
      (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const currentName = props.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h(ViewComponent, assign$2({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return (
        // pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        normalizeSlot(slots.default, { Component: component, route }) || component
      );
    };
  }
});
function normalizeSlot(slot, data) {
  if (!slot)
    return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = (
    // @ts-expect-error: intentionally avoid the type check
    applyToParams.bind(null, decode)
  );
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve(rawLocation, currentLocation) {
    currentLocation = assign$2({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign$2(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if (rawLocation.path != null) {
      matcherLocation = assign$2({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign$2({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign$2({}, rawLocation, {
        params: encodeParams(targetParams)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign$2({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign$2({
      fullPath,
      // keep the hash encoded so fullPath is effectively path + encodedQuery +
      // hash
      hash,
      query: (
        // if the user is using a custom query lib like qs, we might have
        // nested objects, so we keep the query as is, meaning it can contain
        // numbers at `$route.query`, but at the point, the user will have to
        // use their own type anyway.
        // https://github.com/vuejs/router/issues/328#issuecomment-649481567
        stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
      )
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign$2({}, to);
  }
  function checkCanceledNavigation(to, from) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from,
        to
      });
    }
  }
  function push(to) {
    return pushWithRedirect(to);
  }
  function replace(to) {
    return push(assign$2(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
          // force empty params
          { path: newTargetLocation }
        );
        newTargetLocation.params = {};
      }
      return assign$2({
        query: to.query,
        hash: to.hash,
        // avoid transferring params if the redirect has a path
        params: newTargetLocation.path != null ? {} : to.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve(to);
    const from = currentRoute.value;
    const data = to.state;
    const force = to.force;
    const replace2 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign$2(locationAsObject(shouldRedirect), {
          state: typeof shouldRedirect === "object" ? assign$2({}, data, shouldRedirect.state) : data,
          force,
          replace: replace2
        }),
        // keep original redirectedFrom if it exists
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from });
      handleScroll(
        from,
        from,
        // this is a push, the only way for it to be triggered from a
        // history.listen is with a redirect, which makes it become a push
        true,
        // This cannot be the first navigation because the initial location
        // cannot be manually navigated to
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? (
      // navigation redirects still mark the router as ready
      isNavigationFailure(
        error,
        2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
      ) ? error : markAsReady(error)
    ) : (
      // reject any unknown error
      triggerError(error, toLocation, from)
    )).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(
          failure2,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          return pushWithRedirect(
            // keep options
            assign$2({
              // preserve an existing replacement but allow the redirect to override it
              replace: replace2
            }, locationAsObject(failure2.to), {
              state: typeof failure2.to === "object" ? assign$2({}, data, failure2.to.state) : data,
              force
            }),
            // preserve the original redirectedFrom if any
            redirectedFrom || toLocation
          );
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
      }
      triggerAfterEach(toLocation, from, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to, from) {
    const error = checkCanceledNavigation(to, from);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function runWithContext(fn) {
    const app = installedApps.values().next().value;
    return app && typeof app.runWithContext === "function" ? app.runWithContext(fn) : fn();
  }
  function navigate(to, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of enteringRecords) {
        if (record.beforeEnter) {
          if (isArray$1(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from, runWithContext);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(
      err,
      8
      /* ErrorTypes.NAVIGATION_CANCELLED */
    ) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to, from, failure) {
    afterGuards.list().forEach((guard) => runWithContext(() => guard(to, from, failure)));
  }
  function finalizeNavigation(toLocation, from, isPush, replace2, data) {
    const error = checkCanceledNavigation(toLocation, from);
    if (error)
      return error;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign$2({
          scroll: isFirstNavigation && state && state.scroll
        }, data));
      else
        routerHistory.push(toLocation.fullPath, data);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      if (!router.listening)
        return;
      const toLocation = resolve(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign$2(shouldRedirect, { replace: true, force: true }), toLocation).catch(noop);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from).catch((error) => {
        if (isNavigationFailure(
          error,
          4 | 8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        )) {
          return error;
        }
        if (isNavigationFailure(
          error,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          pushWithRedirect(
            assign$2(locationAsObject(error.to), {
              force: true
            }),
            toLocation
            // avoid an uncaught rejection, let push call triggerError
          ).then((failure) => {
            if (isNavigationFailure(
              failure,
              4 | 16
              /* ErrorTypes.NAVIGATION_DUPLICATED */
            ) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop);
          return Promise.reject();
        }
        if (info.delta) {
          routerHistory.go(-info.delta, false);
        }
        return triggerError(error, toLocation, from);
      }).then((failure) => {
        failure = failure || finalizeNavigation(
          // after navigation, all matched components are resolved
          toLocation,
          from,
          false
        );
        if (failure) {
          if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
          // entry while a different route is displayed
          !isNavigationFailure(
            failure,
            8
            /* ErrorTypes.NAVIGATION_CANCELLED */
          )) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(
            failure,
            4 | 16
            /* ErrorTypes.NAVIGATION_DUPLICATED */
          )) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from, failure);
      }).catch(noop);
    });
  }
  let readyHandlers = useCallbacks();
  let errorListeners = useCallbacks();
  let ready;
  function triggerError(error, to, from) {
    markAsReady(error);
    const list = errorListeners.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to, from));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve2, reject) => {
      readyHandlers.add([resolve2, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve2, reject]) => err ? reject(err) : resolve2());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    clearRoutes: matcher.clearRoutes,
    hasRoute,
    getRoutes,
    resolve,
    options,
    push,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorListeners.add,
    isReady,
    install(app) {
      const router2 = this;
      app.component("RouterLink", RouterLink);
      app.component("RouterView", RouterView);
      app.config.globalProperties.$router = router2;
      Object.defineProperty(app.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && // used for the initial navigation client side to avoid pushing
      // multiple times when the router is used in multiple apps
      !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        Object.defineProperty(reactiveRoute, key, {
          get: () => currentRoute.value[key],
          enumerable: true
        });
      }
      app.provide(routerKey, router2);
      app.provide(routeLocationKey, shallowReactive(reactiveRoute));
      app.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app.unmount;
      installedApps.add(app);
      app.unmount = function() {
        installedApps.delete(app);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
  }
  return router;
}
function extractChangingRecords(to, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to.matched.length);
  for (let i = 0; i < len; i++) {
    const recordFrom = from.matched[i];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
function useRouter() {
  return inject(routerKey);
}
function useRoute(_name) {
  return inject(routeLocationKey);
}

const useModalStore = defineStore("modal", () => {
  const showVocabularyForm = ref(false);
  const showTopicManager = ref(false);
  const showNoteDialog = ref(false);
  const showVocabularyDetail = ref(false);
  const showGrammarManager = ref(false);
  const showCompletionModal = ref(false);
  const shouldHideBackToTop = computed(() => {
    return showVocabularyForm.value || showTopicManager.value || showNoteDialog.value || showGrammarManager.value || showVocabularyDetail.value || showCompletionModal.value;
  });
  const shouldHideAddNewWord = computed(() => {
    return showTopicManager.value || showNoteDialog.value || showGrammarManager.value || showVocabularyDetail.value;
  });
  const setVocabularyForm = (show) => {
    showVocabularyForm.value = show;
  };
  const setTopicManager = (show) => {
    showTopicManager.value = show;
  };
  const setNoteDialog = (show) => {
    showNoteDialog.value = show;
  };
  const setVocabularyDetail = (show) => {
    showVocabularyDetail.value = show;
  };
  const setGrammarManager = (show) => {
    showGrammarManager.value = show;
  };
  const setCompletionModal = (show) => {
    showCompletionModal.value = show;
    if (show) {
      document.body.classList.add("modal-open");
    } else {
      document.body.classList.remove("modal-open");
    }
  };
  return {
    // States
    showVocabularyForm,
    showTopicManager,
    showNoteDialog,
    showVocabularyDetail,
    showGrammarManager,
    showCompletionModal,
    // Computed
    shouldHideBackToTop,
    shouldHideAddNewWord,
    // Actions
    setVocabularyForm,
    setTopicManager,
    setNoteDialog,
    setVocabularyDetail,
    setGrammarManager,
    setCompletionModal
  };
});

const _hoisted_1$1s = {
  id: "app",
  class: "min-h-screen"
};
const _hoisted_2$1p = { class: "flex-1 pt-16" };
const _sfc_main$1t = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    const AppHeader = defineAsyncComponent(
      () => __vitePreload(() => Promise.resolve().then(() => AppHeader$1),true              ?void 0:void 0)
    );
    const BackToTop = defineAsyncComponent(
      () => __vitePreload(() => Promise.resolve().then(() => BackToTop$1),true              ?void 0:void 0)
    );
    const modalStore = useModalStore();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1s, [
        createVNode(unref(AppHeader)),
        createBaseVNode("main", _hoisted_2$1p, [
          createVNode(unref(RouterView))
        ]),
        withDirectives(createVNode(unref(BackToTop), null, null, 512), [
          [vShow, !unref(modalStore).shouldHideBackToTop]
        ])
      ]);
    };
  }
});

/*!
  * shared v9.14.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
const inBrowser = typeof window !== "undefined";
const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber = (val) => typeof val === "number" && isFinite(val);
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
const assign$1 = Object.assign;
const _create = Object.create;
const create = (obj = null) => _create(obj);
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : create());
};
function escapeHtml(rawText) {
  return rawText.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/\//g, "&#x2F;").replace(/=/g, "&#x3D;");
}
function escapeAttributeValue(value) {
  return value.replace(/&(?![a-zA-Z0-9#]{2,6};)/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function sanitizeTranslatedHtml(html) {
  html = html.replace(/(\w+)\s*=\s*"([^"]*)"/g, (_, attrName, attrValue) => `${attrName}="${escapeAttributeValue(attrValue)}"`);
  html = html.replace(/(\w+)\s*=\s*'([^']*)'/g, (_, attrName, attrValue) => `${attrName}='${escapeAttributeValue(attrValue)}'`);
  const eventHandlerPattern = /\s*on\w+\s*=\s*["']?[^"'>]+["']?/gi;
  if (eventHandlerPattern.test(html)) {
    html = html.replace(/(\s+)(on)(\w+\s*=)/gi, "$1&#111;n$3");
  }
  const javascriptUrlPattern = [
    // In href, src, action, formaction attributes
    /(\s+(?:href|src|action|formaction)\s*=\s*["']?)\s*javascript:/gi,
    // In style attributes within url()
    /(style\s*=\s*["'][^"']*url\s*\(\s*)javascript:/gi
  ];
  javascriptUrlPattern.forEach((pattern) => {
    html = html.replace(pattern, "$1javascript&#58;");
  });
  return html;
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
const isArray = Array.isArray;
const isFunction = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isBoolean = (val) => typeof val === "boolean";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$1(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const isPlainObject = (val) => {
  if (!isObject$1(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
};
const toDisplayString = (val) => {
  return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
function join$1(items, separator = "") {
  return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
}
function incrementer(code) {
  let current = code;
  return () => ++current;
}
const isNotObjectOrIsArray = (val) => !isObject$1(val) || isArray(val);
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack = [{ src, des }];
  while (stack.length) {
    const { src: src2, des: des2 } = stack.pop();
    Object.keys(src2).forEach((key) => {
      if (key === "__proto__") {
        return;
      }
      if (isObject$1(src2[key]) && !isObject$1(des2[key])) {
        des2[key] = Array.isArray(src2[key]) ? [] : create();
      }
      if (isNotObjectOrIsArray(des2[key]) || isNotObjectOrIsArray(src2[key])) {
        des2[key] = src2[key];
      } else {
        stack.push({ src: src2[key], des: des2[key] });
      }
    });
  }
}

/*!
  * message-compiler v9.14.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function createPosition(line, column, offset) {
    return { line, column, offset };
}
function createLocation(start, end, source) {
    const loc = { start, end };
    return loc;
}

/**
 * Original Utilities
 * written by kazuya kawaguchi
 */
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
/* eslint-disable */
function format$1(message, ...args) {
    if (args.length === 1 && isObject(args[0])) {
        args = args[0];
    }
    if (!args || !args.hasOwnProperty) {
        args = {};
    }
    return message.replace(RE_ARGS, (match, identifier) => {
        return args.hasOwnProperty(identifier) ? args[identifier] : '';
    });
}
const assign = Object.assign;
const isString = (val) => typeof val === 'string';
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isObject = (val) => val !== null && typeof val === 'object';
function join(items, separator = '') {
    return items.reduce((str, item, index) => (index === 0 ? str + item : str + separator + item), '');
}

const CompileWarnCodes = {
    USE_MODULO_SYNTAX: 1,
    __EXTEND_POINT__: 2
};
/** @internal */
const warnMessages = {
    [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
};
function createCompileWarn(code, loc, ...args) {
    const msg = format$1(warnMessages[code], ...(args || [])) ;
    const message = { message: String(msg), code };
    if (loc) {
        message.location = loc;
    }
    return message;
}

const CompileErrorCodes = {
    // tokenizer error codes
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    // parser error codes
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    // generator error codes
    UNHANDLED_CODEGEN_NODE_TYPE: 15,
    // minifier error codes
    UNHANDLED_MINIFIER_NODE_TYPE: 16,
    // Special value for higher-order compilers to pick up the last code
    // to avoid collision of error codes. This should always be kept as the last
    // item.
    __EXTEND_POINT__: 17
};
/** @internal */
const errorMessages = {
    // tokenizer error messages
    [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
    [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
    [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
    [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
    [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
    [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
    [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
    [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
    [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
    [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
    // parser error messages
    [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
    [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
    // generator error messages
    [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
    // minimizer error messages
    [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code, loc, options = {}) {
    const { domain, messages, args } = options;
    const msg = format$1((messages || errorMessages)[code] || '', ...(args || []))
        ;
    const error = new SyntaxError(String(msg));
    error.code = code;
    if (loc) {
        error.location = loc;
    }
    error.domain = domain;
    return error;
}
/** @internal */
function defaultOnError(error) {
    throw error;
}

const CHAR_SP = ' ';
const CHAR_CR = '\r';
const CHAR_LF = '\n';
const CHAR_LS = String.fromCharCode(0x2028);
const CHAR_PS = String.fromCharCode(0x2029);
function createScanner(str) {
    const _buf = str;
    let _index = 0;
    let _line = 1;
    let _column = 1;
    let _peekOffset = 0;
    const isCRLF = (index) => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;
    const isLF = (index) => _buf[index] === CHAR_LF;
    const isPS = (index) => _buf[index] === CHAR_PS;
    const isLS = (index) => _buf[index] === CHAR_LS;
    const isLineEnd = (index) => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);
    const index = () => _index;
    const line = () => _line;
    const column = () => _column;
    const peekOffset = () => _peekOffset;
    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
    const currentChar = () => charAt(_index);
    const currentPeek = () => charAt(_index + _peekOffset);
    function next() {
        _peekOffset = 0;
        if (isLineEnd(_index)) {
            _line++;
            _column = 0;
        }
        if (isCRLF(_index)) {
            _index++;
        }
        _index++;
        _column++;
        return _buf[_index];
    }
    function peek() {
        if (isCRLF(_index + _peekOffset)) {
            _peekOffset++;
        }
        _peekOffset++;
        return _buf[_index + _peekOffset];
    }
    function reset() {
        _index = 0;
        _line = 1;
        _column = 1;
        _peekOffset = 0;
    }
    function resetPeek(offset = 0) {
        _peekOffset = offset;
    }
    function skipToPeek() {
        const target = _index + _peekOffset;
        // eslint-disable-next-line no-unmodified-loop-condition
        while (target !== _index) {
            next();
        }
        _peekOffset = 0;
    }
    return {
        index,
        line,
        column,
        peekOffset,
        charAt,
        currentChar,
        currentPeek,
        next,
        peek,
        reset,
        resetPeek,
        skipToPeek
    };
}

const EOF = undefined;
const DOT = '.';
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$3 = 'tokenizer';
function createTokenizer(source, options = {}) {
    const location = options.location !== false;
    const _scnr = createScanner(source);
    const currentOffset = () => _scnr.index();
    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
    const _initLoc = currentPosition();
    const _initOffset = currentOffset();
    const _context = {
        currentType: 14 /* TokenTypes.EOF */,
        offset: _initOffset,
        startLoc: _initLoc,
        endLoc: _initLoc,
        lastType: 14 /* TokenTypes.EOF */,
        lastOffset: _initOffset,
        lastStartLoc: _initLoc,
        lastEndLoc: _initLoc,
        braceNest: 0,
        inLinked: false,
        text: ''
    };
    const context = () => _context;
    const { onError } = options;
    function emitError(code, pos, offset, ...args) {
        const ctx = context();
        pos.column += offset;
        pos.offset += offset;
        if (onError) {
            const loc = location ? createLocation(ctx.startLoc, pos) : null;
            const err = createCompileError(code, loc, {
                domain: ERROR_DOMAIN$3,
                args
            });
            onError(err);
        }
    }
    function getToken(context, type, value) {
        context.endLoc = currentPosition();
        context.currentType = type;
        const token = { type };
        if (location) {
            token.loc = createLocation(context.startLoc, context.endLoc);
        }
        if (value != null) {
            token.value = value;
        }
        return token;
    }
    const getEndToken = (context) => getToken(context, 14 /* TokenTypes.EOF */);
    function eat(scnr, ch) {
        if (scnr.currentChar() === ch) {
            scnr.next();
            return ch;
        }
        else {
            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
            return '';
        }
    }
    function peekSpaces(scnr) {
        let buf = '';
        while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
            buf += scnr.currentPeek();
            scnr.peek();
        }
        return buf;
    }
    function skipSpaces(scnr) {
        const buf = peekSpaces(scnr);
        scnr.skipToPeek();
        return buf;
    }
    function isIdentifierStart(ch) {
        if (ch === EOF) {
            return false;
        }
        const cc = ch.charCodeAt(0);
        return ((cc >= 97 && cc <= 122) || // a-z
            (cc >= 65 && cc <= 90) || // A-Z
            cc === 95 // _
        );
    }
    function isNumberStart(ch) {
        if (ch === EOF) {
            return false;
        }
        const cc = ch.charCodeAt(0);
        return cc >= 48 && cc <= 57; // 0-9
    }
    function isNamedIdentifierStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 2 /* TokenTypes.BraceLeft */) {
            return false;
        }
        peekSpaces(scnr);
        const ret = isIdentifierStart(scnr.currentPeek());
        scnr.resetPeek();
        return ret;
    }
    function isListIdentifierStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 2 /* TokenTypes.BraceLeft */) {
            return false;
        }
        peekSpaces(scnr);
        const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();
        const ret = isNumberStart(ch);
        scnr.resetPeek();
        return ret;
    }
    function isLiteralStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 2 /* TokenTypes.BraceLeft */) {
            return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === LITERAL_DELIMITER;
        scnr.resetPeek();
        return ret;
    }
    function isLinkedDotStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 8 /* TokenTypes.LinkedAlias */) {
            return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === "." /* TokenChars.LinkedDot */;
        scnr.resetPeek();
        return ret;
    }
    function isLinkedModifierStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 9 /* TokenTypes.LinkedDot */) {
            return false;
        }
        peekSpaces(scnr);
        const ret = isIdentifierStart(scnr.currentPeek());
        scnr.resetPeek();
        return ret;
    }
    function isLinkedDelimiterStart(scnr, context) {
        const { currentType } = context;
        if (!(currentType === 8 /* TokenTypes.LinkedAlias */ ||
            currentType === 12 /* TokenTypes.LinkedModifier */)) {
            return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === ":" /* TokenChars.LinkedDelimiter */;
        scnr.resetPeek();
        return ret;
    }
    function isLinkedReferStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 10 /* TokenTypes.LinkedDelimiter */) {
            return false;
        }
        const fn = () => {
            const ch = scnr.currentPeek();
            if (ch === "{" /* TokenChars.BraceLeft */) {
                return isIdentifierStart(scnr.peek());
            }
            else if (ch === "@" /* TokenChars.LinkedAlias */ ||
                ch === "%" /* TokenChars.Modulo */ ||
                ch === "|" /* TokenChars.Pipe */ ||
                ch === ":" /* TokenChars.LinkedDelimiter */ ||
                ch === "." /* TokenChars.LinkedDot */ ||
                ch === CHAR_SP ||
                !ch) {
                return false;
            }
            else if (ch === CHAR_LF) {
                scnr.peek();
                return fn();
            }
            else {
                // other characters
                return isTextStart(scnr, false);
            }
        };
        const ret = fn();
        scnr.resetPeek();
        return ret;
    }
    function isPluralStart(scnr) {
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === "|" /* TokenChars.Pipe */;
        scnr.resetPeek();
        return ret;
    }
    function detectModuloStart(scnr) {
        const spaces = peekSpaces(scnr);
        const ret = scnr.currentPeek() === "%" /* TokenChars.Modulo */ &&
            scnr.peek() === "{" /* TokenChars.BraceLeft */;
        scnr.resetPeek();
        return {
            isModulo: ret,
            hasSpace: spaces.length > 0
        };
    }
    function isTextStart(scnr, reset = true) {
        const fn = (hasSpace = false, prev = '', detectModulo = false) => {
            const ch = scnr.currentPeek();
            if (ch === "{" /* TokenChars.BraceLeft */) {
                return prev === "%" /* TokenChars.Modulo */ ? false : hasSpace;
            }
            else if (ch === "@" /* TokenChars.LinkedAlias */ || !ch) {
                return prev === "%" /* TokenChars.Modulo */ ? true : hasSpace;
            }
            else if (ch === "%" /* TokenChars.Modulo */) {
                scnr.peek();
                return fn(hasSpace, "%" /* TokenChars.Modulo */, true);
            }
            else if (ch === "|" /* TokenChars.Pipe */) {
                return prev === "%" /* TokenChars.Modulo */ || detectModulo
                    ? true
                    : !(prev === CHAR_SP || prev === CHAR_LF);
            }
            else if (ch === CHAR_SP) {
                scnr.peek();
                return fn(true, CHAR_SP, detectModulo);
            }
            else if (ch === CHAR_LF) {
                scnr.peek();
                return fn(true, CHAR_LF, detectModulo);
            }
            else {
                return true;
            }
        };
        const ret = fn();
        reset && scnr.resetPeek();
        return ret;
    }
    function takeChar(scnr, fn) {
        const ch = scnr.currentChar();
        if (ch === EOF) {
            return EOF;
        }
        if (fn(ch)) {
            scnr.next();
            return ch;
        }
        return null;
    }
    function isIdentifier(ch) {
        const cc = ch.charCodeAt(0);
        return ((cc >= 97 && cc <= 122) || // a-z
            (cc >= 65 && cc <= 90) || // A-Z
            (cc >= 48 && cc <= 57) || // 0-9
            cc === 95 || // _
            cc === 36 // $
        );
    }
    function takeIdentifierChar(scnr) {
        return takeChar(scnr, isIdentifier);
    }
    function isNamedIdentifier(ch) {
        const cc = ch.charCodeAt(0);
        return ((cc >= 97 && cc <= 122) || // a-z
            (cc >= 65 && cc <= 90) || // A-Z
            (cc >= 48 && cc <= 57) || // 0-9
            cc === 95 || // _
            cc === 36 || // $
            cc === 45 // -
        );
    }
    function takeNamedIdentifierChar(scnr) {
        return takeChar(scnr, isNamedIdentifier);
    }
    function isDigit(ch) {
        const cc = ch.charCodeAt(0);
        return cc >= 48 && cc <= 57; // 0-9
    }
    function takeDigit(scnr) {
        return takeChar(scnr, isDigit);
    }
    function isHexDigit(ch) {
        const cc = ch.charCodeAt(0);
        return ((cc >= 48 && cc <= 57) || // 0-9
            (cc >= 65 && cc <= 70) || // A-F
            (cc >= 97 && cc <= 102)); // a-f
    }
    function takeHexDigit(scnr) {
        return takeChar(scnr, isHexDigit);
    }
    function getDigits(scnr) {
        let ch = '';
        let num = '';
        while ((ch = takeDigit(scnr))) {
            num += ch;
        }
        return num;
    }
    function readModulo(scnr) {
        skipSpaces(scnr);
        const ch = scnr.currentChar();
        if (ch !== "%" /* TokenChars.Modulo */) {
            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
        }
        scnr.next();
        return "%" /* TokenChars.Modulo */;
    }
    function readText(scnr) {
        let buf = '';
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const ch = scnr.currentChar();
            if (ch === "{" /* TokenChars.BraceLeft */ ||
                ch === "}" /* TokenChars.BraceRight */ ||
                ch === "@" /* TokenChars.LinkedAlias */ ||
                ch === "|" /* TokenChars.Pipe */ ||
                !ch) {
                break;
            }
            else if (ch === "%" /* TokenChars.Modulo */) {
                if (isTextStart(scnr)) {
                    buf += ch;
                    scnr.next();
                }
                else {
                    break;
                }
            }
            else if (ch === CHAR_SP || ch === CHAR_LF) {
                if (isTextStart(scnr)) {
                    buf += ch;
                    scnr.next();
                }
                else if (isPluralStart(scnr)) {
                    break;
                }
                else {
                    buf += ch;
                    scnr.next();
                }
            }
            else {
                buf += ch;
                scnr.next();
            }
        }
        return buf;
    }
    function readNamedIdentifier(scnr) {
        skipSpaces(scnr);
        let ch = '';
        let name = '';
        while ((ch = takeNamedIdentifierChar(scnr))) {
            name += ch;
        }
        if (scnr.currentChar() === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        return name;
    }
    function readListIdentifier(scnr) {
        skipSpaces(scnr);
        let value = '';
        if (scnr.currentChar() === '-') {
            scnr.next();
            value += `-${getDigits(scnr)}`;
        }
        else {
            value += getDigits(scnr);
        }
        if (scnr.currentChar() === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        return value;
    }
    function isLiteral(ch) {
        return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
    }
    function readLiteral(scnr) {
        skipSpaces(scnr);
        // eslint-disable-next-line no-useless-escape
        eat(scnr, `\'`);
        let ch = '';
        let literal = '';
        while ((ch = takeChar(scnr, isLiteral))) {
            if (ch === '\\') {
                literal += readEscapeSequence(scnr);
            }
            else {
                literal += ch;
            }
        }
        const current = scnr.currentChar();
        if (current === CHAR_LF || current === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
            // TODO: Is it correct really?
            if (current === CHAR_LF) {
                scnr.next();
                // eslint-disable-next-line no-useless-escape
                eat(scnr, `\'`);
            }
            return literal;
        }
        // eslint-disable-next-line no-useless-escape
        eat(scnr, `\'`);
        return literal;
    }
    function readEscapeSequence(scnr) {
        const ch = scnr.currentChar();
        switch (ch) {
            case '\\':
            case `\'`: // eslint-disable-line no-useless-escape
                scnr.next();
                return `\\${ch}`;
            case 'u':
                return readUnicodeEscapeSequence(scnr, ch, 4);
            case 'U':
                return readUnicodeEscapeSequence(scnr, ch, 6);
            default:
                emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
                return '';
        }
    }
    function readUnicodeEscapeSequence(scnr, unicode, digits) {
        eat(scnr, unicode);
        let sequence = '';
        for (let i = 0; i < digits; i++) {
            const ch = takeHexDigit(scnr);
            if (!ch) {
                emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
                break;
            }
            sequence += ch;
        }
        return `\\${unicode}${sequence}`;
    }
    function isInvalidIdentifier(ch) {
        return (ch !== "{" /* TokenChars.BraceLeft */ &&
            ch !== "}" /* TokenChars.BraceRight */ &&
            ch !== CHAR_SP &&
            ch !== CHAR_LF);
    }
    function readInvalidIdentifier(scnr) {
        skipSpaces(scnr);
        let ch = '';
        let identifiers = '';
        while ((ch = takeChar(scnr, isInvalidIdentifier))) {
            identifiers += ch;
        }
        return identifiers;
    }
    function readLinkedModifier(scnr) {
        let ch = '';
        let name = '';
        while ((ch = takeIdentifierChar(scnr))) {
            name += ch;
        }
        return name;
    }
    function readLinkedRefer(scnr) {
        const fn = (buf) => {
            const ch = scnr.currentChar();
            if (ch === "{" /* TokenChars.BraceLeft */ ||
                ch === "%" /* TokenChars.Modulo */ ||
                ch === "@" /* TokenChars.LinkedAlias */ ||
                ch === "|" /* TokenChars.Pipe */ ||
                ch === "(" /* TokenChars.ParenLeft */ ||
                ch === ")" /* TokenChars.ParenRight */ ||
                !ch) {
                return buf;
            }
            else if (ch === CHAR_SP) {
                return buf;
            }
            else if (ch === CHAR_LF || ch === DOT) {
                buf += ch;
                scnr.next();
                return fn(buf);
            }
            else {
                buf += ch;
                scnr.next();
                return fn(buf);
            }
        };
        return fn('');
    }
    function readPlural(scnr) {
        skipSpaces(scnr);
        const plural = eat(scnr, "|" /* TokenChars.Pipe */);
        skipSpaces(scnr);
        return plural;
    }
    // TODO: We need refactoring of token parsing ...
    function readTokenInPlaceholder(scnr, context) {
        let token = null;
        const ch = scnr.currentChar();
        switch (ch) {
            case "{" /* TokenChars.BraceLeft */:
                if (context.braceNest >= 1) {
                    emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
                }
                scnr.next();
                token = getToken(context, 2 /* TokenTypes.BraceLeft */, "{" /* TokenChars.BraceLeft */);
                skipSpaces(scnr);
                context.braceNest++;
                return token;
            case "}" /* TokenChars.BraceRight */:
                if (context.braceNest > 0 &&
                    context.currentType === 2 /* TokenTypes.BraceLeft */) {
                    emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
                }
                scnr.next();
                token = getToken(context, 3 /* TokenTypes.BraceRight */, "}" /* TokenChars.BraceRight */);
                context.braceNest--;
                context.braceNest > 0 && skipSpaces(scnr);
                if (context.inLinked && context.braceNest === 0) {
                    context.inLinked = false;
                }
                return token;
            case "@" /* TokenChars.LinkedAlias */:
                if (context.braceNest > 0) {
                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                }
                token = readTokenInLinked(scnr, context) || getEndToken(context);
                context.braceNest = 0;
                return token;
            default: {
                let validNamedIdentifier = true;
                let validListIdentifier = true;
                let validLiteral = true;
                if (isPluralStart(scnr)) {
                    if (context.braceNest > 0) {
                        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                    }
                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));
                    // reset
                    context.braceNest = 0;
                    context.inLinked = false;
                    return token;
                }
                if (context.braceNest > 0 &&
                    (context.currentType === 5 /* TokenTypes.Named */ ||
                        context.currentType === 6 /* TokenTypes.List */ ||
                        context.currentType === 7 /* TokenTypes.Literal */)) {
                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                    context.braceNest = 0;
                    return readToken(scnr, context);
                }
                if ((validNamedIdentifier = isNamedIdentifierStart(scnr, context))) {
                    token = getToken(context, 5 /* TokenTypes.Named */, readNamedIdentifier(scnr));
                    skipSpaces(scnr);
                    return token;
                }
                if ((validListIdentifier = isListIdentifierStart(scnr, context))) {
                    token = getToken(context, 6 /* TokenTypes.List */, readListIdentifier(scnr));
                    skipSpaces(scnr);
                    return token;
                }
                if ((validLiteral = isLiteralStart(scnr, context))) {
                    token = getToken(context, 7 /* TokenTypes.Literal */, readLiteral(scnr));
                    skipSpaces(scnr);
                    return token;
                }
                if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
                    // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...
                    token = getToken(context, 13 /* TokenTypes.InvalidPlace */, readInvalidIdentifier(scnr));
                    emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
                    skipSpaces(scnr);
                    return token;
                }
                break;
            }
        }
        return token;
    }
    // TODO: We need refactoring of token parsing ...
    function readTokenInLinked(scnr, context) {
        const { currentType } = context;
        let token = null;
        const ch = scnr.currentChar();
        if ((currentType === 8 /* TokenTypes.LinkedAlias */ ||
            currentType === 9 /* TokenTypes.LinkedDot */ ||
            currentType === 12 /* TokenTypes.LinkedModifier */ ||
            currentType === 10 /* TokenTypes.LinkedDelimiter */) &&
            (ch === CHAR_LF || ch === CHAR_SP)) {
            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        switch (ch) {
            case "@" /* TokenChars.LinkedAlias */:
                scnr.next();
                token = getToken(context, 8 /* TokenTypes.LinkedAlias */, "@" /* TokenChars.LinkedAlias */);
                context.inLinked = true;
                return token;
            case "." /* TokenChars.LinkedDot */:
                skipSpaces(scnr);
                scnr.next();
                return getToken(context, 9 /* TokenTypes.LinkedDot */, "." /* TokenChars.LinkedDot */);
            case ":" /* TokenChars.LinkedDelimiter */:
                skipSpaces(scnr);
                scnr.next();
                return getToken(context, 10 /* TokenTypes.LinkedDelimiter */, ":" /* TokenChars.LinkedDelimiter */);
            default:
                if (isPluralStart(scnr)) {
                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));
                    // reset
                    context.braceNest = 0;
                    context.inLinked = false;
                    return token;
                }
                if (isLinkedDotStart(scnr, context) ||
                    isLinkedDelimiterStart(scnr, context)) {
                    skipSpaces(scnr);
                    return readTokenInLinked(scnr, context);
                }
                if (isLinkedModifierStart(scnr, context)) {
                    skipSpaces(scnr);
                    return getToken(context, 12 /* TokenTypes.LinkedModifier */, readLinkedModifier(scnr));
                }
                if (isLinkedReferStart(scnr, context)) {
                    skipSpaces(scnr);
                    if (ch === "{" /* TokenChars.BraceLeft */) {
                        // scan the placeholder
                        return readTokenInPlaceholder(scnr, context) || token;
                    }
                    else {
                        return getToken(context, 11 /* TokenTypes.LinkedKey */, readLinkedRefer(scnr));
                    }
                }
                if (currentType === 8 /* TokenTypes.LinkedAlias */) {
                    emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
                }
                context.braceNest = 0;
                context.inLinked = false;
                return readToken(scnr, context);
        }
    }
    // TODO: We need refactoring of token parsing ...
    function readToken(scnr, context) {
        let token = { type: 14 /* TokenTypes.EOF */ };
        if (context.braceNest > 0) {
            return readTokenInPlaceholder(scnr, context) || getEndToken(context);
        }
        if (context.inLinked) {
            return readTokenInLinked(scnr, context) || getEndToken(context);
        }
        const ch = scnr.currentChar();
        switch (ch) {
            case "{" /* TokenChars.BraceLeft */:
                return readTokenInPlaceholder(scnr, context) || getEndToken(context);
            case "}" /* TokenChars.BraceRight */:
                emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
                scnr.next();
                return getToken(context, 3 /* TokenTypes.BraceRight */, "}" /* TokenChars.BraceRight */);
            case "@" /* TokenChars.LinkedAlias */:
                return readTokenInLinked(scnr, context) || getEndToken(context);
            default: {
                if (isPluralStart(scnr)) {
                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));
                    // reset
                    context.braceNest = 0;
                    context.inLinked = false;
                    return token;
                }
                const { isModulo, hasSpace } = detectModuloStart(scnr);
                if (isModulo) {
                    return hasSpace
                        ? getToken(context, 0 /* TokenTypes.Text */, readText(scnr))
                        : getToken(context, 4 /* TokenTypes.Modulo */, readModulo(scnr));
                }
                if (isTextStart(scnr)) {
                    return getToken(context, 0 /* TokenTypes.Text */, readText(scnr));
                }
                break;
            }
        }
        return token;
    }
    function nextToken() {
        const { currentType, offset, startLoc, endLoc } = _context;
        _context.lastType = currentType;
        _context.lastOffset = offset;
        _context.lastStartLoc = startLoc;
        _context.lastEndLoc = endLoc;
        _context.offset = currentOffset();
        _context.startLoc = currentPosition();
        if (_scnr.currentChar() === EOF) {
            return getToken(_context, 14 /* TokenTypes.EOF */);
        }
        return readToken(_scnr, _context);
    }
    return {
        nextToken,
        currentOffset,
        currentPosition,
        context
    };
}

const ERROR_DOMAIN$2 = 'parser';
// Backslash backslash, backslash quote, uHHHH, UHHHHHH.
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
    switch (match) {
        case `\\\\`:
            return `\\`;
        // eslint-disable-next-line no-useless-escape
        case `\\\'`:
            // eslint-disable-next-line no-useless-escape
            return `\'`;
        default: {
            const codePoint = parseInt(codePoint4 || codePoint6, 16);
            if (codePoint <= 0xd7ff || codePoint >= 0xe000) {
                return String.fromCodePoint(codePoint);
            }
            // invalid ...
            // Replace them with U+FFFD REPLACEMENT CHARACTER.
            return '�';
        }
    }
}
function createParser(options = {}) {
    const location = options.location !== false;
    const { onError, onWarn } = options;
    function emitError(tokenzer, code, start, offset, ...args) {
        const end = tokenzer.currentPosition();
        end.offset += offset;
        end.column += offset;
        if (onError) {
            const loc = location ? createLocation(start, end) : null;
            const err = createCompileError(code, loc, {
                domain: ERROR_DOMAIN$2,
                args
            });
            onError(err);
        }
    }
    function emitWarn(tokenzer, code, start, offset, ...args) {
        const end = tokenzer.currentPosition();
        end.offset += offset;
        end.column += offset;
        if (onWarn) {
            const loc = location ? createLocation(start, end) : null;
            onWarn(createCompileWarn(code, loc, args));
        }
    }
    function startNode(type, offset, loc) {
        const node = { type };
        if (location) {
            node.start = offset;
            node.end = offset;
            node.loc = { start: loc, end: loc };
        }
        return node;
    }
    function endNode(node, offset, pos, type) {
        if (location) {
            node.end = offset;
            if (node.loc) {
                node.loc.end = pos;
            }
        }
    }
    function parseText(tokenizer, value) {
        const context = tokenizer.context();
        const node = startNode(3 /* NodeTypes.Text */, context.offset, context.startLoc);
        node.value = value;
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseList(tokenizer, index) {
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc
        const node = startNode(5 /* NodeTypes.List */, offset, loc);
        node.index = parseInt(index, 10);
        tokenizer.nextToken(); // skip brach right
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseNamed(tokenizer, key, modulo) {
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc
        const node = startNode(4 /* NodeTypes.Named */, offset, loc);
        node.key = key;
        if (modulo === true) {
            node.modulo = true;
        }
        tokenizer.nextToken(); // skip brach right
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseLiteral(tokenizer, value) {
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc
        const node = startNode(9 /* NodeTypes.Literal */, offset, loc);
        node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
        tokenizer.nextToken(); // skip brach right
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseLinkedModifier(tokenizer) {
        const token = tokenizer.nextToken();
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context; // get linked dot loc
        const node = startNode(8 /* NodeTypes.LinkedModifier */, offset, loc);
        if (token.type !== 12 /* TokenTypes.LinkedModifier */) {
            // empty modifier
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
            node.value = '';
            endNode(node, offset, loc);
            return {
                nextConsumeToken: token,
                node
            };
        }
        // check token
        if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        node.value = token.value || '';
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return {
            node
        };
    }
    function parseLinkedKey(tokenizer, value) {
        const context = tokenizer.context();
        const node = startNode(7 /* NodeTypes.LinkedKey */, context.offset, context.startLoc);
        node.value = value;
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseLinked(tokenizer) {
        const context = tokenizer.context();
        const linkedNode = startNode(6 /* NodeTypes.Linked */, context.offset, context.startLoc);
        let token = tokenizer.nextToken();
        if (token.type === 9 /* TokenTypes.LinkedDot */) {
            const parsed = parseLinkedModifier(tokenizer);
            linkedNode.modifier = parsed.node;
            token = parsed.nextConsumeToken || tokenizer.nextToken();
        }
        // asset check token
        if (token.type !== 10 /* TokenTypes.LinkedDelimiter */) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        token = tokenizer.nextToken();
        // skip brace left
        if (token.type === 2 /* TokenTypes.BraceLeft */) {
            token = tokenizer.nextToken();
        }
        switch (token.type) {
            case 11 /* TokenTypes.LinkedKey */:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseLinkedKey(tokenizer, token.value || '');
                break;
            case 5 /* TokenTypes.Named */:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseNamed(tokenizer, token.value || '');
                break;
            case 6 /* TokenTypes.List */:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseList(tokenizer, token.value || '');
                break;
            case 7 /* TokenTypes.Literal */:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseLiteral(tokenizer, token.value || '');
                break;
            default: {
                // empty key
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
                const nextContext = tokenizer.context();
                const emptyLinkedKeyNode = startNode(7 /* NodeTypes.LinkedKey */, nextContext.offset, nextContext.startLoc);
                emptyLinkedKeyNode.value = '';
                endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
                linkedNode.key = emptyLinkedKeyNode;
                endNode(linkedNode, nextContext.offset, nextContext.startLoc);
                return {
                    nextConsumeToken: token,
                    node: linkedNode
                };
            }
        }
        endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
        return {
            node: linkedNode
        };
    }
    function parseMessage(tokenizer) {
        const context = tokenizer.context();
        const startOffset = context.currentType === 1 /* TokenTypes.Pipe */
            ? tokenizer.currentOffset()
            : context.offset;
        const startLoc = context.currentType === 1 /* TokenTypes.Pipe */
            ? context.endLoc
            : context.startLoc;
        const node = startNode(2 /* NodeTypes.Message */, startOffset, startLoc);
        node.items = [];
        let nextToken = null;
        let modulo = null;
        do {
            const token = nextToken || tokenizer.nextToken();
            nextToken = null;
            switch (token.type) {
                case 0 /* TokenTypes.Text */:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseText(tokenizer, token.value || ''));
                    break;
                case 6 /* TokenTypes.List */:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseList(tokenizer, token.value || ''));
                    break;
                case 4 /* TokenTypes.Modulo */:
                    modulo = true;
                    break;
                case 5 /* TokenTypes.Named */:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseNamed(tokenizer, token.value || '', !!modulo));
                    if (modulo) {
                        emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));
                        modulo = null;
                    }
                    break;
                case 7 /* TokenTypes.Literal */:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseLiteral(tokenizer, token.value || ''));
                    break;
                case 8 /* TokenTypes.LinkedAlias */: {
                    const parsed = parseLinked(tokenizer);
                    node.items.push(parsed.node);
                    nextToken = parsed.nextConsumeToken || null;
                    break;
                }
            }
        } while (context.currentType !== 14 /* TokenTypes.EOF */ &&
            context.currentType !== 1 /* TokenTypes.Pipe */);
        // adjust message node loc
        const endOffset = context.currentType === 1 /* TokenTypes.Pipe */
            ? context.lastOffset
            : tokenizer.currentOffset();
        const endLoc = context.currentType === 1 /* TokenTypes.Pipe */
            ? context.lastEndLoc
            : tokenizer.currentPosition();
        endNode(node, endOffset, endLoc);
        return node;
    }
    function parsePlural(tokenizer, offset, loc, msgNode) {
        const context = tokenizer.context();
        let hasEmptyMessage = msgNode.items.length === 0;
        const node = startNode(1 /* NodeTypes.Plural */, offset, loc);
        node.cases = [];
        node.cases.push(msgNode);
        do {
            const msg = parseMessage(tokenizer);
            if (!hasEmptyMessage) {
                hasEmptyMessage = msg.items.length === 0;
            }
            node.cases.push(msg);
        } while (context.currentType !== 14 /* TokenTypes.EOF */);
        if (hasEmptyMessage) {
            emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
        }
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseResource(tokenizer) {
        const context = tokenizer.context();
        const { offset, startLoc } = context;
        const msgNode = parseMessage(tokenizer);
        if (context.currentType === 14 /* TokenTypes.EOF */) {
            return msgNode;
        }
        else {
            return parsePlural(tokenizer, offset, startLoc, msgNode);
        }
    }
    function parse(source) {
        const tokenizer = createTokenizer(source, assign({}, options));
        const context = tokenizer.context();
        const node = startNode(0 /* NodeTypes.Resource */, context.offset, context.startLoc);
        if (location && node.loc) {
            node.loc.source = source;
        }
        node.body = parseResource(tokenizer);
        if (options.onCacheKey) {
            node.cacheKey = options.onCacheKey(source);
        }
        // assert whether achieved to EOF
        if (context.currentType !== 14 /* TokenTypes.EOF */) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');
        }
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    return { parse };
}
function getTokenCaption(token) {
    if (token.type === 14 /* TokenTypes.EOF */) {
        return 'EOF';
    }
    const name = (token.value || '').replace(/\r?\n/gu, '\\n');
    return name.length > 10 ? name.slice(0, 9) + '…' : name;
}

function createTransformer(ast, options = {} // eslint-disable-line
) {
    const _context = {
        ast,
        helpers: new Set()
    };
    const context = () => _context;
    const helper = (name) => {
        _context.helpers.add(name);
        return name;
    };
    return { context, helper };
}
function traverseNodes(nodes, transformer) {
    for (let i = 0; i < nodes.length; i++) {
        traverseNode(nodes[i], transformer);
    }
}
function traverseNode(node, transformer) {
    // TODO: if we need pre-hook of transform, should be implemented to here
    switch (node.type) {
        case 1 /* NodeTypes.Plural */:
            traverseNodes(node.cases, transformer);
            transformer.helper("plural" /* HelperNameMap.PLURAL */);
            break;
        case 2 /* NodeTypes.Message */:
            traverseNodes(node.items, transformer);
            break;
        case 6 /* NodeTypes.Linked */: {
            const linked = node;
            traverseNode(linked.key, transformer);
            transformer.helper("linked" /* HelperNameMap.LINKED */);
            transformer.helper("type" /* HelperNameMap.TYPE */);
            break;
        }
        case 5 /* NodeTypes.List */:
            transformer.helper("interpolate" /* HelperNameMap.INTERPOLATE */);
            transformer.helper("list" /* HelperNameMap.LIST */);
            break;
        case 4 /* NodeTypes.Named */:
            transformer.helper("interpolate" /* HelperNameMap.INTERPOLATE */);
            transformer.helper("named" /* HelperNameMap.NAMED */);
            break;
    }
    // TODO: if we need post-hook of transform, should be implemented to here
}
// transform AST
function transform(ast, options = {} // eslint-disable-line
) {
    const transformer = createTransformer(ast);
    transformer.helper("normalize" /* HelperNameMap.NORMALIZE */);
    // traverse
    ast.body && traverseNode(ast.body, transformer);
    // set meta information
    const context = transformer.context();
    ast.helpers = Array.from(context.helpers);
}

function optimize(ast) {
    const body = ast.body;
    if (body.type === 2 /* NodeTypes.Message */) {
        optimizeMessageNode(body);
    }
    else {
        body.cases.forEach(c => optimizeMessageNode(c));
    }
    return ast;
}
function optimizeMessageNode(message) {
    if (message.items.length === 1) {
        const item = message.items[0];
        if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {
            message.static = item.value;
            delete item.value; // optimization for size
        }
    }
    else {
        const values = [];
        for (let i = 0; i < message.items.length; i++) {
            const item = message.items[i];
            if (!(item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */)) {
                break;
            }
            if (item.value == null) {
                break;
            }
            values.push(item.value);
        }
        if (values.length === message.items.length) {
            message.static = join(values);
            for (let i = 0; i < message.items.length; i++) {
                const item = message.items[i];
                if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {
                    delete item.value; // optimization for size
                }
            }
        }
    }
}

const ERROR_DOMAIN$1 = 'minifier';
/* eslint-disable @typescript-eslint/no-explicit-any */
function minify(node) {
    node.t = node.type;
    switch (node.type) {
        case 0 /* NodeTypes.Resource */: {
            const resource = node;
            minify(resource.body);
            resource.b = resource.body;
            delete resource.body;
            break;
        }
        case 1 /* NodeTypes.Plural */: {
            const plural = node;
            const cases = plural.cases;
            for (let i = 0; i < cases.length; i++) {
                minify(cases[i]);
            }
            plural.c = cases;
            delete plural.cases;
            break;
        }
        case 2 /* NodeTypes.Message */: {
            const message = node;
            const items = message.items;
            for (let i = 0; i < items.length; i++) {
                minify(items[i]);
            }
            message.i = items;
            delete message.items;
            if (message.static) {
                message.s = message.static;
                delete message.static;
            }
            break;
        }
        case 3 /* NodeTypes.Text */:
        case 9 /* NodeTypes.Literal */:
        case 8 /* NodeTypes.LinkedModifier */:
        case 7 /* NodeTypes.LinkedKey */: {
            const valueNode = node;
            if (valueNode.value) {
                valueNode.v = valueNode.value;
                delete valueNode.value;
            }
            break;
        }
        case 6 /* NodeTypes.Linked */: {
            const linked = node;
            minify(linked.key);
            linked.k = linked.key;
            delete linked.key;
            if (linked.modifier) {
                minify(linked.modifier);
                linked.m = linked.modifier;
                delete linked.modifier;
            }
            break;
        }
        case 5 /* NodeTypes.List */: {
            const list = node;
            list.i = list.index;
            delete list.index;
            break;
        }
        case 4 /* NodeTypes.Named */: {
            const named = node;
            named.k = named.key;
            delete named.key;
            break;
        }
        default:
            {
                throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
                    domain: ERROR_DOMAIN$1,
                    args: [node.type]
                });
            }
    }
    delete node.type;
}
/* eslint-enable @typescript-eslint/no-explicit-any */

// eslint-disable-next-line @typescript-eslint/triple-slash-reference
/// <reference types="source-map-js" />
const ERROR_DOMAIN = 'parser';
function createCodeGenerator(ast, options) {
    const { filename, breakLineCode, needIndent: _needIndent } = options;
    const location = options.location !== false;
    const _context = {
        filename,
        code: '',
        column: 1,
        line: 1,
        offset: 0,
        map: undefined,
        breakLineCode,
        needIndent: _needIndent,
        indentLevel: 0
    };
    if (location && ast.loc) {
        _context.source = ast.loc.source;
    }
    const context = () => _context;
    function push(code, node) {
        _context.code += code;
    }
    function _newline(n, withBreakLine = true) {
        const _breakLineCode = withBreakLine ? breakLineCode : '';
        push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
    }
    function indent(withNewLine = true) {
        const level = ++_context.indentLevel;
        withNewLine && _newline(level);
    }
    function deindent(withNewLine = true) {
        const level = --_context.indentLevel;
        withNewLine && _newline(level);
    }
    function newline() {
        _newline(_context.indentLevel);
    }
    const helper = (key) => `_${key}`;
    const needIndent = () => _context.needIndent;
    return {
        context,
        push,
        indent,
        deindent,
        newline,
        helper,
        needIndent
    };
}
function generateLinkedNode(generator, node) {
    const { helper } = generator;
    generator.push(`${helper("linked" /* HelperNameMap.LINKED */)}(`);
    generateNode(generator, node.key);
    if (node.modifier) {
        generator.push(`, `);
        generateNode(generator, node.modifier);
        generator.push(`, _type`);
    }
    else {
        generator.push(`, undefined, _type`);
    }
    generator.push(`)`);
}
function generateMessageNode(generator, node) {
    const { helper, needIndent } = generator;
    generator.push(`${helper("normalize" /* HelperNameMap.NORMALIZE */)}([`);
    generator.indent(needIndent());
    const length = node.items.length;
    for (let i = 0; i < length; i++) {
        generateNode(generator, node.items[i]);
        if (i === length - 1) {
            break;
        }
        generator.push(', ');
    }
    generator.deindent(needIndent());
    generator.push('])');
}
function generatePluralNode(generator, node) {
    const { helper, needIndent } = generator;
    if (node.cases.length > 1) {
        generator.push(`${helper("plural" /* HelperNameMap.PLURAL */)}([`);
        generator.indent(needIndent());
        const length = node.cases.length;
        for (let i = 0; i < length; i++) {
            generateNode(generator, node.cases[i]);
            if (i === length - 1) {
                break;
            }
            generator.push(', ');
        }
        generator.deindent(needIndent());
        generator.push(`])`);
    }
}
function generateResource(generator, node) {
    if (node.body) {
        generateNode(generator, node.body);
    }
    else {
        generator.push('null');
    }
}
function generateNode(generator, node) {
    const { helper } = generator;
    switch (node.type) {
        case 0 /* NodeTypes.Resource */:
            generateResource(generator, node);
            break;
        case 1 /* NodeTypes.Plural */:
            generatePluralNode(generator, node);
            break;
        case 2 /* NodeTypes.Message */:
            generateMessageNode(generator, node);
            break;
        case 6 /* NodeTypes.Linked */:
            generateLinkedNode(generator, node);
            break;
        case 8 /* NodeTypes.LinkedModifier */:
            generator.push(JSON.stringify(node.value), node);
            break;
        case 7 /* NodeTypes.LinkedKey */:
            generator.push(JSON.stringify(node.value), node);
            break;
        case 5 /* NodeTypes.List */:
            generator.push(`${helper("interpolate" /* HelperNameMap.INTERPOLATE */)}(${helper("list" /* HelperNameMap.LIST */)}(${node.index}))`, node);
            break;
        case 4 /* NodeTypes.Named */:
            generator.push(`${helper("interpolate" /* HelperNameMap.INTERPOLATE */)}(${helper("named" /* HelperNameMap.NAMED */)}(${JSON.stringify(node.key)}))`, node);
            break;
        case 9 /* NodeTypes.Literal */:
            generator.push(JSON.stringify(node.value), node);
            break;
        case 3 /* NodeTypes.Text */:
            generator.push(JSON.stringify(node.value), node);
            break;
        default:
            {
                throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
                    domain: ERROR_DOMAIN,
                    args: [node.type]
                });
            }
    }
}
// generate code from AST
const generate = (ast, options = {} // eslint-disable-line
) => {
    const mode = isString(options.mode) ? options.mode : 'normal';
    const filename = isString(options.filename)
        ? options.filename
        : 'message.intl';
    !!options.sourceMap;
    // prettier-ignore
    const breakLineCode = options.breakLineCode != null
        ? options.breakLineCode
        : mode === 'arrow'
            ? ';'
            : '\n';
    const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';
    const helpers = ast.helpers || [];
    const generator = createCodeGenerator(ast, {
        filename,
        breakLineCode,
        needIndent
    });
    generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);
    generator.indent(needIndent);
    if (helpers.length > 0) {
        generator.push(`const { ${join(helpers.map(s => `${s}: _${s}`), ', ')} } = ctx`);
        generator.newline();
    }
    generator.push(`return `);
    generateNode(generator, ast);
    generator.deindent(needIndent);
    generator.push(`}`);
    delete ast.helpers;
    const { code, map } = generator.context();
    return {
        ast,
        code,
        map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any
    };
};

function baseCompile$1(source, options = {}) {
    const assignedOptions = assign({}, options);
    const jit = !!assignedOptions.jit;
    const enalbeMinify = !!assignedOptions.minify;
    const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
    // parse source codes
    const parser = createParser(assignedOptions);
    const ast = parser.parse(source);
    if (!jit) {
        // transform ASTs
        transform(ast, assignedOptions);
        // generate javascript codes
        return generate(ast, assignedOptions);
    }
    else {
        // optimize ASTs
        enambeOptimize && optimize(ast);
        // minimize ASTs
        enalbeMinify && minify(ast);
        // In JIT mode, no ast transform, no code generation.
        return { ast, code: '' };
    }
}

/*!
  * core-base v9.14.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function initFeatureFlags$1() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
}
function isMessageAST(val) {
  return isObject$1(val) && resolveType(val) === 0 && (hasOwn(val, "b") || hasOwn(val, "body"));
}
const PROPS_BODY = ["b", "body"];
function resolveBody(node) {
  return resolveProps(node, PROPS_BODY);
}
const PROPS_CASES = ["c", "cases"];
function resolveCases(node) {
  return resolveProps(node, PROPS_CASES, []);
}
const PROPS_STATIC = ["s", "static"];
function resolveStatic(node) {
  return resolveProps(node, PROPS_STATIC);
}
const PROPS_ITEMS = ["i", "items"];
function resolveItems(node) {
  return resolveProps(node, PROPS_ITEMS, []);
}
const PROPS_TYPE = ["t", "type"];
function resolveType(node) {
  return resolveProps(node, PROPS_TYPE);
}
const PROPS_VALUE = ["v", "value"];
function resolveValue$1(node, type) {
  const resolved = resolveProps(node, PROPS_VALUE);
  if (resolved != null) {
    return resolved;
  } else {
    throw createUnhandleNodeError(type);
  }
}
const PROPS_MODIFIER = ["m", "modifier"];
function resolveLinkedModifier(node) {
  return resolveProps(node, PROPS_MODIFIER);
}
const PROPS_KEY = ["k", "key"];
function resolveLinkedKey(node) {
  const resolved = resolveProps(node, PROPS_KEY);
  if (resolved) {
    return resolved;
  } else {
    throw createUnhandleNodeError(
      6
      /* NodeTypes.Linked */
    );
  }
}
function resolveProps(node, props, defaultValue) {
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (hasOwn(node, prop) && node[prop] != null) {
      return node[prop];
    }
  }
  return defaultValue;
}
const AST_NODE_PROPS_KEYS = [
  ...PROPS_BODY,
  ...PROPS_CASES,
  ...PROPS_STATIC,
  ...PROPS_ITEMS,
  ...PROPS_KEY,
  ...PROPS_MODIFIER,
  ...PROPS_VALUE,
  ...PROPS_TYPE
];
function createUnhandleNodeError(type) {
  return new Error(`unhandled node type: ${type}`);
}
const pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch) {
  if (ch === void 0 || ch === null) {
    return "o";
  }
  const code2 = ch.charCodeAt(0);
  switch (code2) {
    case 91:
    // [
    case 93:
    // ]
    case 46:
    // .
    case 34:
    // "
    case 39:
      return ch;
    case 95:
    // _
    case 36:
    // $
    case 45:
      return "i";
    case 9:
    // Tab (HT)
    case 10:
    // Newline (LF)
    case 13:
    // Return (CR)
    case 160:
    // No-break space (NBSP)
    case 65279:
    // Byte Order Mark (BOM)
    case 8232:
    // Line Separator (LS)
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse(path) {
  const keys = [];
  let index = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c;
  let key;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  while (mode !== null) {
    index++;
    c = path[index];
    if (c === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys;
    }
  }
}
const cache = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject$1(obj) ? obj[path] : null;
}
function resolveValue(obj, path) {
  if (!isObject$1(obj)) {
    return null;
  }
  let hit = cache.get(path);
  if (!hit) {
    hit = parse(path);
    if (hit) {
      cache.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i = 0;
  while (i < len) {
    const key = hit[i];
    if (AST_NODE_PROPS_KEYS.includes(key) && isMessageAST(last)) {
      return null;
    }
    const val = last[key];
    if (val === void 0) {
      return null;
    }
    if (isFunction(last)) {
      return null;
    }
    last = val;
    i++;
  }
  return last;
}
const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join$1(values);
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
  const index = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
  return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index : index;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject$1(options.pluralRules) && isString$1(locale) && isFunction(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject$1(options.pluralRules) && isString$1(locale) && isFunction(options.pluralRules[locale]) ? pluralDefault : void 0;
  const plural = (messages) => {
    return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
  };
  const _list = options.list || [];
  const list = (index) => _list[index];
  const _named = options.named || create();
  isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key) => _named[key];
  function message(key) {
    const msg = isFunction(options.messages) ? options.messages(key) : isObject$1(options.messages) ? options.messages[key] : false;
    return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
  const normalize = isPlainObject(options.processor) && isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject(options.processor) && isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject(options.processor) && isString$1(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type2 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject$1(arg1)) {
        modifier = arg1.modifier || modifier;
        type2 = arg1.type || type2;
      } else if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString$1(arg2)) {
        type2 = arg2 || type2;
      }
    }
    const ret = message(key)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type2 === "vnode" && isArray(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type2) : msg;
  };
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign$1(create(), _list, _named)
  };
  return ctx;
}
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n, version, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n,
    version,
    meta
  });
}
const translateDevTools = /* @__PURE__ */ createDevToolsHook(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
const inc$1$1 = incrementer(code$1$1);
const CoreWarnCodes = {
  // 2
  FALLBACK_TO_TRANSLATE: inc$1$1(),
  // 3
  CANNOT_FORMAT_NUMBER: inc$1$1(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
  // 5
  CANNOT_FORMAT_DATE: inc$1$1(),
  // 6
  FALLBACK_TO_DATE_FORMAT: inc$1$1(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
  // 8
  __EXTEND_POINT__: inc$1$1()
  // 9
};
const code$2 = CompileErrorCodes.__EXTEND_POINT__;
const inc$2 = incrementer(code$2);
const CoreErrorCodes = {
  INVALID_ARGUMENT: code$2,
  // 17
  INVALID_DATE_ARGUMENT: inc$2(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: inc$2(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: inc$2(),
  // 23
  __EXTEND_POINT__: inc$2()
  // 24
};
function createCoreError(code2) {
  return createCompileError(code2, null, void 0);
}
function getLocale$1(context, options) {
  return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
}
let _resolveLocale;
function resolveLocale(locale) {
  if (isString$1(locale)) {
    return locale;
  } else {
    if (isFunction(locale)) {
      if (locale.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale.constructor.name === "Function") {
        const resolve = locale();
        if (isPromise(resolve)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
function fallbackWithSimple(ctx, fallback, start) {
  return [.../* @__PURE__ */ new Set([
    start,
    ...isArray(fallback) ? fallback : isObject$1(fallback) ? Object.keys(fallback) : isString$1(fallback) ? [fallback] : [start]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = isString$1(start) ? start : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block = [start];
    while (isArray(block)) {
      block = appendBlockToChain(chain, block, fallback);
    }
    const defaults = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block = isString$1(defaults) ? [defaults] : defaults;
    if (isArray(block)) {
      appendBlockToChain(chain, block, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block, blocks) {
  let follow = true;
  for (let i = 0; i < block.length && isBoolean(follow); i++) {
    const locale = block[i];
    if (isString$1(locale)) {
      follow = appendLocaleToChain(chain, block[i], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens = locale.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target, blocks) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale = target.replace(/!/g, "");
      chain.push(locale);
      if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale]) {
        follow = blocks[locale];
      }
    }
  }
  return follow;
}
const VERSION$1 = "9.14.5";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type) => {
      return type === "text" && isString$1(val) ? val.toUpperCase() : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type) => {
      return type === "text" && isString$1(val) ? val.toLowerCase() : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type) => {
      return type === "text" && isString$1(val) ? capitalize(val) : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }
  };
}
let _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
let _additionalMeta = null;
const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
  _additionalMeta = meta;
};
const getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta;
let _fallbackContext = null;
const setFallbackContext = (context) => {
  _fallbackContext = context;
};
const getFallbackContext = () => _fallbackContext;
let _cid = 0;
function createCoreContext(options = {}) {
  const onWarn = isFunction(options.onWarn) ? options.onWarn : warn;
  const version = isString$1(options.version) ? options.version : VERSION$1;
  const locale = isString$1(options.locale) || isFunction(options.locale) ? options.locale : DEFAULT_LOCALE;
  const _locale = isFunction(locale) ? DEFAULT_LOCALE : locale;
  const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
  const messages = isPlainObject(options.messages) ? options.messages : createResources(_locale);
  const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : createResources(_locale);
  const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : createResources(_locale);
  const modifiers = assign$1(create(), options.modifiers, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || create();
  const missing = isFunction(options.missing) ? options.missing : null;
  const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
  const messageResolver = isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$1(options.fallbackContext) ? options.fallbackContext : void 0;
  const internalOptions = options;
  const __datetimeFormatters = isObject$1(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject$1(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject$1(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version,
    cid: _cid,
    locale,
    fallbackLocale,
    messages,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version, __meta);
  }
  return context;
}
const createResources = (locale) => ({ [locale]: create() });
function handleMissing(context, key, locale, missingWarn, type) {
  const { missing, onWarn } = context;
  if (missing !== null) {
    const ret = missing(context, locale, key, type);
    return isString$1(ret) ? ret : key;
  } else {
    return key;
  }
}
function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
function isAlmostSameLocale(locale, compareLocale) {
  if (locale === compareLocale)
    return false;
  return locale.split("-")[0] === compareLocale.split("-")[0];
}
function isImplicitFallback(targetLocale, locales) {
  const index = locales.indexOf(targetLocale);
  if (index === -1) {
    return false;
  }
  for (let i = index + 1; i < locales.length; i++) {
    if (isAlmostSameLocale(targetLocale, locales[i])) {
      return true;
    }
  }
  return false;
}
function format(ast) {
  const msg = (ctx) => formatParts(ctx, ast);
  return msg;
}
function formatParts(ctx, ast) {
  const body = resolveBody(ast);
  if (body == null) {
    throw createUnhandleNodeError(
      0
      /* NodeTypes.Resource */
    );
  }
  const type = resolveType(body);
  if (type === 1) {
    const plural = body;
    const cases = resolveCases(plural);
    return ctx.plural(cases.reduce((messages, c) => [
      ...messages,
      formatMessageParts(ctx, c)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
function formatMessageParts(ctx, node) {
  const static_ = resolveStatic(node);
  if (static_ != null) {
    return ctx.type === "text" ? static_ : ctx.normalize([static_]);
  } else {
    const messages = resolveItems(node).reduce((acm, c) => [...acm, formatMessagePart(ctx, c)], []);
    return ctx.normalize(messages);
  }
}
function formatMessagePart(ctx, node) {
  const type = resolveType(node);
  switch (type) {
    case 3: {
      return resolveValue$1(node, type);
    }
    case 9: {
      return resolveValue$1(node, type);
    }
    case 4: {
      const named = node;
      if (hasOwn(named, "k") && named.k) {
        return ctx.interpolate(ctx.named(named.k));
      }
      if (hasOwn(named, "key") && named.key) {
        return ctx.interpolate(ctx.named(named.key));
      }
      throw createUnhandleNodeError(type);
    }
    case 5: {
      const list = node;
      if (hasOwn(list, "i") && isNumber(list.i)) {
        return ctx.interpolate(ctx.list(list.i));
      }
      if (hasOwn(list, "index") && isNumber(list.index)) {
        return ctx.interpolate(ctx.list(list.index));
      }
      throw createUnhandleNodeError(type);
    }
    case 6: {
      const linked = node;
      const modifier = resolveLinkedModifier(linked);
      const key = resolveLinkedKey(linked);
      return ctx.linked(formatMessagePart(ctx, key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
    }
    case 7: {
      return resolveValue$1(node, type);
    }
    case 8: {
      return resolveValue$1(node, type);
    }
    default:
      throw new Error(`unhandled node on format message part: ${type}`);
  }
}
const defaultOnCacheKey = (message) => message;
let compileCache = create();
function baseCompile(message, options = {}) {
  let detectError = false;
  const onError = options.onError || defaultOnError;
  options.onError = (err) => {
    detectError = true;
    onError(err);
  };
  return { ...baseCompile$1(message, options), detectError };
}
const compileToFunction = /* @__NO_SIDE_EFFECTS__ */ (message, context) => {
  if (!isString$1(message)) {
    throw createCoreError(CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE);
  }
  {
    isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { code: code2, detectError } = baseCompile(message, context);
    const msg = new Function(`return ${code2}`)();
    return !detectError ? compileCache[cacheKey] = msg : msg;
  }
};
function compile(message, context) {
  if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && isString$1(message)) {
    isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile(message, {
      ...context,
      location: false,
      jit: true
    });
    const msg = format(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    const cacheKey = message.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format(message);
    } else {
      return format(message);
    }
  }
}
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction(val);
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;
  const [key, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage;
  const defaultMsgOrKey = isString$1(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale = getLocale$1(context, options);
  escapeParameter && escapeParams(options);
  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale,
    messages[locale] || create()
  ];
  let format2 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$1(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let occurred = false;
  const onError = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  let ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (escapeParameter && isString$1(ret)) {
    ret = sanitizeTranslatedHtml(ret);
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString$1(key) ? key : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString$1(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign$1({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options) {
  if (isArray(options.list)) {
    options.list = options.list.map((item) => isString$1(item) ? escapeHtml(item) : item);
  } else if (isObject$1(options.named)) {
    Object.keys(options.named).forEach((key) => {
      if (isString$1(options.named[key])) {
        options.named[key] = escapeHtml(options.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  let message = create();
  let targetLocale;
  let format2 = null;
  const type = "translate";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    message = messages[targetLocale] || create();
    if ((format2 = resolveValue2(message, key)) === null) {
      format2 = message[key];
    }
    if (isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
      break;
    }
    if (!isImplicitFallback(targetLocale, locales)) {
      const missingRet = handleMissing(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        key,
        targetLocale,
        missingWarn,
        type
      );
      if (missingRet !== key) {
        format2 = missingRet;
      }
    }
  }
  return [format2, targetLocale, message];
}
function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = () => format2;
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format2;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  const messaged = msg(msgCtx);
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = create();
  if (!isString$1(arg1) && !isNumber(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber(arg2)) {
    options.plural = arg2;
  } else if (isString$1(arg2)) {
    options.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (isArray(arg2)) {
    options.list = arg2;
  }
  if (isNumber(arg3)) {
    options.plural = arg3;
  } else if (isString$1(arg3)) {
    options.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign$1(options, arg3);
  }
  return [key, options];
}
function getCompileContext(context, locale, key, source, warnHtmlMessage, onError) {
  return {
    locale,
    key,
    warnHtmlMessage,
    onError: (err) => {
      onError && onError(err);
      {
        throw err;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
  };
}
function getMessageContextOptions(context, locale, message, options) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = (key) => {
    let val = resolveValue2(message, key);
    if (val == null && fallbackContext) {
      const [, , message2] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message2, key);
    }
    if (isString$1(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key, locale, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options.list) {
    ctxOptions.list = options.list;
  }
  if (options.named) {
    ctxOptions.named = options.named;
  }
  if (isNumber(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }
  return ctxOptions;
}
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  const [key, value, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale$1(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$1(key) || key === "") {
    return new Intl.DateTimeFormat(locale, overrides).format(value);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "datetime format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign$1({}, format2, overrides));
    __datetimeFormatters.set(id, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = create();
  let overrides = create();
  let value;
  if (isString$1(arg1)) {
    const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
    value = new Date(dateTime);
    try {
      value.toISOString();
    } catch (e) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value = arg1;
  } else if (isNumber(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearDateTimeFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id = `${locale}__${key}`;
    if (!context.__datetimeFormatters.has(id)) {
      continue;
    }
    context.__datetimeFormatters.delete(id);
  }
}
function number(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  const [key, value, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale$1(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$1(key) || key === "") {
    return new Intl.NumberFormat(locale, overrides).format(value);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "number format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign$1({}, format2, overrides));
    __numberFormatters.set(id, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = create();
  let overrides = create();
  if (!isNumber(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value = arg1;
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearNumberFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id = `${locale}__${key}`;
    if (!context.__numberFormatters.has(id)) {
      continue;
    }
    context.__numberFormatters.delete(id);
  }
}
{
  initFeatureFlags$1();
}

/*!
  * vue-i18n v9.14.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
const VERSION = "9.14.5";
function initFeatureFlags() {
  if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }
  if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
const code$1 = CoreWarnCodes.__EXTEND_POINT__;
const inc$1 = incrementer(code$1);
({
  // 9
  NOT_SUPPORTED_PRESERVE: inc$1(),
  // 10
  NOT_SUPPORTED_FORMATTER: inc$1(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  // 14
  NOT_FOUND_PARENT_SCOPE: inc$1(),
  // 15
  IGNORE_OBJ_FLATTEN: inc$1(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
  // 18
});
const code = CoreErrorCodes.__EXTEND_POINT__;
const inc = incrementer(code);
const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: inc(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc(),
  // 26
  NOT_INSTALLED: inc(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  // 28
  // directive module errors
  REQUIRED_VALUE: inc(),
  // 29
  INVALID_VALUE: inc(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: inc(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: inc(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
  // 37
  // for enhancement
  __EXTEND_POINT__: inc()
  // 38
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, void 0);
}
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
function handleFlatJson(obj) {
  if (!isObject$1(obj)) {
    return obj;
  }
  if (isMessageAST(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject$1(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i = 0; i < lastIndex; i++) {
        if (subKeys[i] === "__proto__") {
          throw new Error(`unsafe key: ${subKeys[i]}`);
        }
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = create();
        }
        if (!isObject$1(currentObj[subKeys[i]])) {
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i]];
      }
      if (!hasStringValue) {
        if (!isMessageAST(currentObj)) {
          currentObj[subKeys[lastIndex]] = obj[key];
          delete obj[key];
        } else {
          if (!AST_NODE_PROPS_KEYS.includes(subKeys[lastIndex])) {
            delete obj[key];
          }
        }
      }
      if (!isMessageAST(currentObj)) {
        const target = currentObj[subKeys[lastIndex]];
        if (isObject$1(target)) {
          handleFlatJson(target);
        }
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale, options) {
  const { messages, __i18n, messageResolver, flatJson } = options;
  const ret = isPlainObject(messages) ? messages : isArray(__i18n) ? create() : { [locale]: create() };
  if (isArray(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale2, resource } = custom;
        if (locale2) {
          ret[locale2] = ret[locale2] || create();
          deepCopy(resource, ret[locale2]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString$1(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
function getComponentOptions(instance) {
  return instance.type;
}
function adjustI18nResources(gl, options, componentOptions) {
  let messages = isObject$1(options.messages) ? options.messages : create();
  if ("__i18nGlobal" in componentOptions) {
    messages = getLocaleMessages(gl.locale.value, {
      messages,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages);
  if (locales.length) {
    locales.forEach((locale) => {
      gl.mergeLocaleMessage(locale, messages[locale]);
    });
  }
  {
    if (isObject$1(options.datetimeFormats)) {
      const locales2 = Object.keys(options.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    }
    if (isObject$1(options.numberFormats)) {
      const locales2 = Object.keys(options.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
const DEVTOOLS_META = "__INTLIFY_META__";
const NOOP_RETURN_ARRAY = () => [];
const NOOP_RETURN_FALSE = () => false;
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale, key, type) => {
    return missing(locale, key, getCurrentInstance() || void 0, type);
  };
}
const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options;
  const _isGlobal = __root === void 0;
  const flatJson = options.flatJson;
  const _ref = inBrowser ? ref : shallowRef;
  const translateExistCompatible = !!options.translateExistCompatible;
  let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = _ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = _ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  let _fallbackFormat = !!options.fallbackFormat;
  let _missing = isFunction(options.missing) ? options.missing : null;
  let _runtimeMissing = isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
  let _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  let _escapeParameter = !!options.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  let _pluralRules = options.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      messageCompiler: options.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn(_context);
    } finally {
      if (__INTLIFY_PROD_DEVTOOLS__) ;
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (warnType !== "translate exists" && // for not `te` (e.g `t`)
    isNumber(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root) => Reflect.apply(root.t, root, [...args]), (key) => key, (val) => isString$1(val));
  }
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$1(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t(...[arg1, arg2, assign$1({ resolvedMessage: true }, arg3 || {})]);
  }
  function d(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root) => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function n(...args) {
    return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root) => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function normalize(values) {
    return values.map((val) => isString$1(val) || isNumber(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  const interpolate = (val) => val;
  const processor = {
    normalize,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray(val)
    );
  }
  function numberParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(number, null, [context, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[NumberPartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray(val)
    );
  }
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(datetime, null, [context, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[DatetimePartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray(val)
    );
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te(key, locale2) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString$1(locale2) ? locale2 : _locale.value;
      const message = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message, key);
      return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString$1(resolved) : resolved != null;
    }, () => [key], "translate exists", (root) => {
      return Reflect.apply(root.te, root, [key, locale2]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
  }
  function resolveMessages(key) {
    let messages2 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i = 0; i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages2 = messageValue;
        break;
      }
    }
    return messages2;
  }
  function tm(key) {
    const messages2 = resolveMessages(key);
    return messages2 != null ? messages2 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message) {
    if (flatJson) {
      const _message = { [locale2]: message };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message = _message[locale2];
    }
    _messages.value[locale2] = message;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    const _message = { [locale2]: message };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message = _message[locale2];
    deepCopy(message, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function mergeDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = assign$1(_datetimeFormats.value[locale2] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  function mergeNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = assign$1(_numberFormats.value[locale2] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm;
    composer.d = d;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  return composer;
}
function convertComposerOptions(options) {
  const locale = isString$1(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const missing = isFunction(options.missing) ? options.missing : void 0;
  const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
  const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
  const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const fallbackFormat = !!options.formatFallbackMessages;
  const modifiers = isPlainObject(options.modifiers) ? options.modifiers : {};
  const pluralizationRules = options.pluralizationRules;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : void 0;
  const warnHtmlMessage = isString$1(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
  const escapeParameter = !!options.escapeParameterHtml;
  const inheritLocale = isBoolean(options.sync) ? options.sync : true;
  let messages = options.messages;
  if (isPlainObject(options.sharedMessages)) {
    const sharedMessages = options.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages = locales.reduce((messages2, locale2) => {
      const message = messages2[locale2] || (messages2[locale2] = {});
      assign$1(message, sharedMessages[locale2]);
      return messages2;
    }, messages || {});
  }
  const { __i18n, __root, __injectWithOption } = options;
  const datetimeFormats = options.datetimeFormats;
  const numberFormats = options.numberFormats;
  const flatJson = options.flatJson;
  const translateExistCompatible = options.translateExistCompatible;
  return {
    locale,
    fallbackLocale,
    messages,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options.messageResolver,
    inheritLocale,
    translateExistCompatible,
    __i18n,
    __root,
    __injectWithOption
  };
}
function createVueI18n(options = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options));
    const { __extender } = options;
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // formatter
      get formatter() {
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler) {
        composer.setMissingHandler(handler);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        return true;
      },
      set preserveDirectiveContent(val) {
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = {};
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options2.locale = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options2.locale = arg2;
        } else if (isNumber(arg2)) {
          options2.plural = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isString$1(arg3)) {
          options2.locale = arg3;
        } else if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      // te
      te(key, locale) {
        return composer.te(key, locale);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },
      // setLocaleMessage
      setLocaleMessage(locale, message) {
        composer.setLocaleMessage(locale, message);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale, message) {
        composer.mergeLocaleMessage(locale, message);
      },
      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale, format2) {
        composer.setDateTimeFormat(locale, format2);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale, format2) {
        composer.mergeDateTimeFormat(locale, format2);
      },
      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      // getNumberFormat
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },
      // setNumberFormat
      setNumberFormat(locale, format2) {
        composer.setNumberFormat(locale, format2);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale, format2) {
        composer.mergeNumberFormat(locale, format2);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
        return -1;
      }
    };
    vueI18n.__extender = __extender;
    return vueI18n;
  }
}
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys) {
  if (keys.length === 1 && keys[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, create());
  }
}
function getFragmentableTag(tag) {
  return Fragment;
}
const TranslationImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign$1({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (val) => isNumber(val) || !isNaN(val)
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const { slots, attrs } = context;
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys = Object.keys(slots).filter((key) => key !== "_");
      const options = create();
      if (props.locale) {
        options.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options.plural = isString$1(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys);
      const children = i18n[TranslateVNodeSymbol](props.keypath, arg, options);
      const assignedAttrs = assign$1(create(), attrs);
      const tag = isString$1(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
      return h(tag, assignedAttrs, children);
    };
  }
});
const Translation = TranslationImpl;
function isVNode(target) {
  return isArray(target) && !isString$1(target[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs } = context;
  return () => {
    const options = { part: true };
    let overrides = create();
    if (props.locale) {
      options.locale = props.locale;
    }
    if (isString$1(props.format)) {
      options.key = props.format;
    } else if (isObject$1(props.format)) {
      if (isString$1(props.format.key)) {
        options.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options2, prop) => {
        return slotKeys.includes(prop) ? assign$1(create(), options2, { [prop]: props.format[prop] }) : options2;
      }, create());
    }
    const parts = partFormatter(...[props.value, options, overrides]);
    let children = [options.key];
    if (isArray(parts)) {
      children = parts.map((part, index) => {
        const slot = slots[part.type];
        const node = slot ? slot({ [part.type]: part.value, index, parts }) : [part.value];
        if (isVNode(node)) {
          node[0].key = `${part.type}-${index}`;
        }
        return node;
      });
    } else if (isString$1(parts)) {
      children = [parts];
    }
    const assignedAttrs = assign$1(create(), attrs);
    const tag = isString$1(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
    return h(tag, assignedAttrs, children);
  };
}
const NumberFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign$1({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n[NumberPartsSymbol](...args)
    ));
  }
});
const NumberFormat = NumberFormatImpl;
const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign$1({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n[DatetimePartsSymbol](...args)
    ));
  }
});
const DatetimeFormat = DatetimeFormatImpl;
function getComposer$2(i18n, instance) {
  const i18nInternal = i18n;
  if (i18n.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n.global.__composer;
  }
}
function vTDirective(i18n) {
  const _process = (binding) => {
    const { instance, modifiers, value } = binding;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n, instance.$);
    const parsedValue = parseValue(value);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register = (el, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n.global === composer) {
      el.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el.__composer = composer;
    el.textContent = textContent;
  };
  const unregister = (el) => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();
      el.__i18nWatcher = void 0;
      delete el.__i18nWatcher;
    }
    if (el.__composer) {
      el.__composer = void 0;
      delete el.__composer;
    }
  };
  const update = (el, { value }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue(value);
      el.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  };
  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update,
    getSSRProps
  };
}
function parseValue(value) {
  if (isString$1(value)) {
    return { path: value };
  } else if (isPlainObject(value)) {
    if (!("path" in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value) {
  const { path, locale, args, choice, plural } = value;
  const options = {};
  const named = args || {};
  if (isString$1(locale)) {
    options.locale = locale;
  }
  if (isNumber(choice)) {
    options.plural = choice;
  }
  if (isNumber(plural)) {
    options.plural = plural;
  }
  return [path, named, options];
}
function apply(app, i18n, ...options) {
  const pluginOptions = isPlainObject(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app.component(name, Translation));
    [NumberFormat.name, "I18nN"].forEach((name) => app.component(name, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name) => app.component(name, DatetimeFormat));
  }
  {
    app.directive("t", vTDirective(i18n));
  }
}
function defineMixin(vuei18n, composer, i18n) {
  return {
    beforeCreate() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const options = this.$options;
      if (options.i18n) {
        const optionsI18n = options.i18n;
        if (options.__i18n) {
          optionsI18n.__i18n = options.__i18n;
        }
        optionsI18n.__root = composer;
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          optionsI18n.__extender = i18n.__vueI18nExtend;
          this.$i18n = createVueI18n(optionsI18n);
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else if (options.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, options);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options.__i18n,
            __injectWithOption: true,
            __extender: i18n.__vueI18nExtend,
            __root: composer
          });
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else {
        this.$i18n = vuei18n;
      }
      if (options.__i18nGlobal) {
        adjustI18nResources(composer, options, options);
      }
      this.$t = (...args) => this.$i18n.t(...args);
      this.$rt = (...args) => this.$i18n.rt(...args);
      this.$tc = (...args) => this.$i18n.tc(...args);
      this.$te = (key, locale) => this.$i18n.te(key, locale);
      this.$d = (...args) => this.$i18n.d(...args);
      this.$n = (...args) => this.$i18n.n(...args);
      this.$tm = (key) => this.$i18n.tm(key);
      i18n.__setInstance(instance, this.$i18n);
    },
    mounted() {
    },
    unmounted() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const _vueI18n = this.$i18n;
      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;
      if (_vueI18n.__disposer) {
        _vueI18n.__disposer();
        delete _vueI18n.__disposer;
        delete _vueI18n.__extender;
      }
      i18n.__deleteInstance(instance);
      delete this.$i18n;
    }
  };
}
function mergeToGlobal(g, options) {
  g.locale = options.locale || g.locale;
  g.fallbackLocale = options.fallbackLocale || g.fallbackLocale;
  g.missing = options.missing || g.missing;
  g.silentTranslationWarn = options.silentTranslationWarn || g.silentFallbackWarn;
  g.silentFallbackWarn = options.silentFallbackWarn || g.silentFallbackWarn;
  g.formatFallbackMessages = options.formatFallbackMessages || g.formatFallbackMessages;
  g.postTranslation = options.postTranslation || g.postTranslation;
  g.warnHtmlInMessage = options.warnHtmlInMessage || g.warnHtmlInMessage;
  g.escapeParameterHtml = options.escapeParameterHtml || g.escapeParameterHtml;
  g.sync = options.sync || g.sync;
  g.__composer[SetPluralRulesSymbol](options.pluralizationRules || g.pluralizationRules);
  const messages = getLocaleMessages(g.locale, {
    messages: options.messages,
    __i18n: options.__i18n
  });
  Object.keys(messages).forEach((locale) => g.mergeLocaleMessage(locale, messages[locale]));
  if (options.datetimeFormats) {
    Object.keys(options.datetimeFormats).forEach((locale) => g.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
  }
  if (options.numberFormats) {
    Object.keys(options.numberFormats).forEach((locale) => g.mergeNumberFormat(locale, options.numberFormats[locale]));
  }
  return g;
}
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options = {}, VueI18nLegacy) {
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
  const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options, __legacyMode);
  const symbol = /* @__PURE__ */ makeSymbol("");
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  {
    const i18n = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      async install(app, ...options2) {
        app.__VUE_I18N_SYMBOL__ = symbol;
        app.provide(app.__VUE_I18N_SYMBOL__, i18n);
        if (isPlainObject(options2[0])) {
          const opts = options2[0];
          i18n.__composerExtend = opts.__composerExtend;
          i18n.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (!__legacyMode && __globalInjection) {
          globalReleaseHandler = injectGlobalFields(app, i18n.global);
        }
        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app, i18n, ...options2);
        }
        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app.mixin(defineMixin(__global, __global.__composer, i18n));
        }
        const unmountApp = app.unmount;
        app.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n.dispose();
          unmountApp();
        };
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n;
  }
}
function useI18n(options = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n = getI18nInstance(instance);
  const gl = getGlobalComposer(i18n);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options, componentOptions);
  if (__VUE_I18N_LEGACY_API__) {
    if (i18n.mode === "legacy" && !options.__useComponent) {
      if (!i18n.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }
      return useI18nForLegacy(instance, scope, gl, options);
    }
  }
  if (scope === "global") {
    adjustI18nResources(gl, options, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n, instance, options.__useComponent);
    if (composer2 == null) {
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign$1({}, options);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance, composer);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
function createGlobal(options, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
function getI18nInstance(instance) {
  {
    const i18n = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n;
  }
}
function getScope(options, componentOptions) {
  return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
}
function getGlobalComposer(i18n) {
  return i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
}
function getComposer(i18n, target, useComponent = false) {
  let composer = null;
  const root = target.root;
  let current = getParentComponentInstance(target, useComponent);
  while (current != null) {
    const i18nInternal = i18n;
    if (i18n.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
          if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
            composer = null;
          }
        }
      }
    }
    if (composer != null) {
      break;
    }
    if (root === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function getParentComponentInstance(target, useComponent = false) {
  if (target == null) {
    return null;
  }
  {
    return !useComponent ? target.parent : target.vnode.ctx || target.parent;
  }
}
function setupLifeCycle(i18n, target, composer) {
  {
    onMounted(() => {
    }, target);
    onUnmounted(() => {
      const _composer = composer;
      i18n.__deleteInstance(target);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target);
  }
}
function useI18nForLegacy(instance, scope, root, options = {}) {
  const isLocalScope = scope === "local";
  const _composer = shallowRef(null);
  if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }
  const _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : !isString$1(options.locale);
  const _locale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  const _missingWarn = isLocalScope ? root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const _fallbackWarn = isLocalScope ? root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const _fallbackRoot = isLocalScope ? root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const _fallbackFormat = !!options.fallbackFormat;
  const _missing = isFunction(options.missing) ? options.missing : null;
  const _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const _warnHtmlMessage = isLocalScope ? root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const _escapeParameter = !!options.escapeParameter;
  const _modifiers = isLocalScope ? root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  const _pluralRules = options.pluralRules || isLocalScope && root.pluralRules;
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }
      _locale.value = val;
    }
  });
  const fallbackLocale = computed({
    get: () => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }
      _fallbackLocale.value = val;
    }
  });
  const messages = computed(() => {
    if (_composer.value) {
      return _composer.value.messages.value;
    } else {
      return _messages.value;
    }
  });
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }
  function setPostTranslationHandler(handler) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler);
    }
  }
  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }
  function setMissingHandler(handler) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler);
    }
  }
  function warpWithDeps(fn) {
    trackReactivityValues();
    return fn();
  }
  function t(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
  }
  function rt(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
  }
  function d(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
  }
  function n(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
  }
  function tm(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }
  function te(key, locale2) {
    return _composer.value ? _composer.value.te(key, locale2) : false;
  }
  function getLocaleMessage(locale2) {
    return _composer.value ? _composer.value.getLocaleMessage(locale2) : {};
  }
  function setLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale2, message);
      _messages.value[locale2] = message;
    }
  }
  function mergeLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale2, message);
    }
  }
  function getDateTimeFormat(locale2) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale2) : {};
  }
  function setDateTimeFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale2, format2);
      _datetimeFormats.value[locale2] = format2;
    }
  }
  function mergeDateTimeFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale2, format2);
    }
  }
  function getNumberFormat(locale2) {
    return _composer.value ? _composer.value.getNumberFormat(locale2) : {};
  }
  function setNumberFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale2, format2);
      _numberFormats.value[locale2] = format2;
    }
  }
  function mergeNumberFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale2, format2);
    }
  }
  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },
    locale,
    fallbackLocale,
    messages,
    datetimeFormats,
    numberFormats,
    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },
    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },
    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },
    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },
    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },
    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },
    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },
    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },
    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },
    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },
    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },
    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },
    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },
    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },
    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },
    t,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt,
    d,
    n,
    tm,
    te,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };
  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach((locale2) => {
      composer.mergeLocaleMessage(locale2, _messages.value[locale2]);
    });
    Object.keys(_datetimeFormats.value).forEach((locale2) => {
      composer.mergeDateTimeFormat(locale2, _datetimeFormats.value[locale2]);
    });
    Object.keys(_numberFormats.value).forEach((locale2) => {
      composer.mergeNumberFormat(locale2, _numberFormats.value[locale2]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }
  onBeforeMount(() => {
    if (instance.proxy == null || instance.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    }
    const composer = _composer.value = instance.proxy.$i18n.__composer;
    if (scope === "global") {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocalScope) {
      sync(composer);
    }
  });
  return wrapper;
}
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app, composer) {
  const i18n = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n, prop, wrap);
  });
  app.config.globalProperties.$i18n = i18n;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app.config.globalProperties, `$${method}`, desc);
  });
  const dispose = () => {
    delete app.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app.config.globalProperties[`$${method}`];
    });
  };
  return dispose;
}
{
  initFeatureFlags();
}
if (__INTLIFY_JIT_COMPILATION__) {
  registerMessageCompiler(compile);
} else {
  registerMessageCompiler(compileToFunction);
}
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}

function loadComponentSafely(importFn) {
  return async () => {
    try {
      const module = await importFn();
      return module.default || module;
    } catch (error) {
      console.error("Component loading failed:", error);
      return {
        template: '<div class="error-component">Component failed to load</div>'
      };
    }
  };
}

const vocabularies = ref([]);
let nextId = 1;
let isInitialized = false;
const isStoreReady = ref(false);
const customTopics = ref([]);
const loadCustomTopics = () => {
  try {
    const saved = localStorage.getItem("customTopics");
    if (saved) {
      const parsedTopics = JSON.parse(saved);
      if (Array.isArray(parsedTopics)) {
        customTopics.value = parsedTopics;
      }
    }
  } catch (error) {
    console.error("Error loading custom topics:", error);
    customTopics.value = [];
  }
};
const loadFromLocalStorage = () => {
  try {
    const saved = localStorage.getItem("vocabularies");
    const savedNextId = localStorage.getItem("nextVocabId");
    if (saved) {
      const parsedVocabs = JSON.parse(saved);
      if (Array.isArray(parsedVocabs)) {
        vocabularies.value = parsedVocabs;
      }
    }
    if (savedNextId) {
      nextId = parseInt(savedNextId, 10) || 1;
    }
    loadCustomTopics();
    isInitialized = true;
    isStoreReady.value = true;
  } catch (error) {
    console.error("Error loading vocabularies from localStorage:", error);
    isInitialized = true;
    isStoreReady.value = true;
  }
};
const saveToLocalStorage = () => {
  try {
    localStorage.setItem("vocabularies", JSON.stringify(vocabularies.value));
    localStorage.setItem("nextVocabId", nextId.toString());
    localStorage.setItem("customTopics", JSON.stringify(customTopics.value));
  } catch (error) {
    console.error("Error saving data to localStorage:", error);
  }
};
function normalizeCategoryKeys() {
  const categoryKeys = [
    "technology",
    "business",
    "travel",
    "food",
    "health",
    "education",
    "sports",
    "entertainment",
    "science",
    "art",
    "music",
    "literature",
    "politics",
    "environment",
    "fashion",
    "finance"
  ];
  const translationMap = {
    technology: ["Technology", "Công nghệ"],
    business: ["Business", "Kinh doanh"],
    travel: ["Travel", "Du lịch"],
    food: ["Food", "Ẩm thực"],
    health: ["Health", "Sức khỏe"],
    education: ["Education", "Giáo dục"],
    sports: ["Sports", "Thể thao"],
    entertainment: ["Entertainment", "Giải trí"],
    science: ["Science", "Khoa học"],
    art: ["Art", "Nghệ thuật"],
    music: ["Music", "Âm nhạc"],
    literature: ["Literature", "Văn học"],
    politics: ["Politics", "Chính trị"],
    environment: ["Environment", "Môi trường"],
    fashion: ["Fashion", "Thời trang"],
    finance: ["Finance", "Tài chính"]
  };
  vocabularies.value.forEach((vocab) => {
    for (const key of categoryKeys) {
      if (vocab.category === key || translationMap[key].includes(vocab.category)) {
        vocab.category = key;
        break;
      }
    }
  });
  saveToLocalStorage();
}
if (typeof window !== "undefined") {
  loadFromLocalStorage();
  normalizeCategoryKeys();
}
function useVocabularyStore() {
  const allVocabularies = computed(() => vocabularies.value);
  const totalCount = computed(() => vocabularies.value.length);
  const getVocabularyById = (id) => {
    return vocabularies.value.find((vocab) => vocab.id === Number(id));
  };
  const addVocabulary = (vocabularyData) => {
    const newVocabulary = {
      ...vocabularyData,
      id: nextId++,
      createdAt: vocabularyData.createdAt || (/* @__PURE__ */ new Date()).toISOString()
    };
    vocabularies.value.unshift(newVocabulary);
    saveToLocalStorage();
    return newVocabulary;
  };
  const updateVocabulary = (id, updates) => {
    const index = vocabularies.value.findIndex((vocab) => vocab.id === id);
    if (index !== -1) {
      const existingVocab = vocabularies.value[index];
      vocabularies.value[index] = {
        ...existingVocab,
        ...updates,
        synonyms: updates.synonyms !== void 0 ? updates.synonyms : existingVocab.synonyms,
        antonyms: updates.antonyms !== void 0 ? updates.antonyms : existingVocab.antonyms,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      saveToLocalStorage();
      return true;
    }
    return false;
  };
  const deleteVocabulary = (id) => {
    const index = vocabularies.value.findIndex((vocab) => vocab.id === id);
    if (index !== -1) {
      vocabularies.value.splice(index, 1);
      saveToLocalStorage();
      return true;
    }
    return false;
  };
  const importVocabularies = (newVocabularies) => {
    try {
      let importedCount = 0;
      let updatedCount = 0;
      newVocabularies.forEach((importedVocab) => {
        const existingIndex = vocabularies.value.findIndex(
          (vocab) => vocab.word.toLowerCase() === importedVocab.word.toLowerCase()
        );
        if (existingIndex !== -1) {
          const existingVocab = vocabularies.value[existingIndex];
          vocabularies.value[existingIndex] = {
            ...existingVocab,
            // Keep original id and createdAt
            ...importedVocab,
            // Override with imported data
            id: existingVocab.id,
            // Preserve original ID
            createdAt: existingVocab.createdAt,
            // Preserve original creation date
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
            // Update modification time
          };
          updatedCount++;
        } else {
          const newVocab = {
            ...importedVocab,
            id: nextId++,
            createdAt: importedVocab.createdAt || (/* @__PURE__ */ new Date()).toISOString(),
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          vocabularies.value.unshift(newVocab);
          importedCount++;
        }
      });
      saveToLocalStorage();
      console.log(`Import completed: ${importedCount} new vocabularies added, ${updatedCount} existing vocabularies updated`);
      return true;
    } catch (error) {
      console.error("Error importing vocabularies:", error);
      return false;
    }
  };
  const filterVocabularies = (filters) => {
    return computed(() => {
      return vocabularies.value.filter((vocab) => {
        const matchesSearch = !filters.search || vocab.word.toLowerCase().includes(filters.search.toLowerCase()) || vocab.meaning.toLowerCase().includes(filters.search.toLowerCase());
        const matchesCategory = !filters.category || vocab.category === filters.category;
        const matchesLevel = !filters.level || vocab.level === filters.level;
        return matchesSearch && matchesCategory && matchesLevel;
      });
    });
  };
  const getCategories = computed(() => {
    const standardCategories = [
      "technology",
      "business",
      "travel",
      "food",
      "health",
      "education",
      "sports",
      "entertainment",
      "science",
      "art",
      "music",
      "literature",
      "politics",
      "environment",
      "fashion",
      "finance"
    ];
    const customTopicKeys = customTopics.value.map((topic) => topic.key);
    const usedCategories = new Set(vocabularies.value.map((vocab) => vocab.category));
    const additionalCategories = Array.from(usedCategories).filter(
      (cat) => !standardCategories.includes(cat) && !customTopicKeys.includes(cat)
    );
    return [...standardCategories, ...customTopicKeys, ...additionalCategories].sort();
  });
  const getCategoryUsage = computed(() => {
    const usage = {};
    vocabularies.value.forEach((vocab) => {
      usage[vocab.category] = (usage[vocab.category] || 0) + 1;
    });
    return usage;
  });
  const getLevels = computed(() => {
    const levels = new Set(vocabularies.value.map((vocab) => vocab.level));
    return Array.from(levels).sort();
  });
  const toggleFavorite = (id) => {
    const index = vocabularies.value.findIndex((vocab) => vocab.id === id);
    if (index !== -1) {
      vocabularies.value[index] = {
        ...vocabularies.value[index],
        favorite: !vocabularies.value[index].favorite,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      saveToLocalStorage();
      return true;
    }
    return false;
  };
  const favoriteVocabularies = computed(() => {
    return vocabularies.value.filter((vocab) => vocab.favorite);
  });
  const clearAllVocabularies = () => {
    try {
      vocabularies.value = [];
      nextId = 1;
      saveToLocalStorage();
      console.log("All vocabularies cleared successfully");
      return true;
    } catch (error) {
      console.error("Error clearing all vocabularies:", error);
      return false;
    }
  };
  const initializeStore = () => {
    if (!isInitialized) {
      loadFromLocalStorage();
    }
    return isStoreReady;
  };
  const refreshCustomTopics = () => {
    loadCustomTopics();
  };
  const addCustomTopic = (topic) => {
    const existingTopic = customTopics.value.find((t) => t.key === topic.key);
    if (!existingTopic) {
      customTopics.value.push(topic);
      saveToLocalStorage();
    }
  };
  const updateCustomTopic = (oldKey, topic) => {
    const index = customTopics.value.findIndex((t) => t.key === oldKey);
    if (index !== -1) {
      customTopics.value[index] = topic;
      saveToLocalStorage();
    }
  };
  const deleteCustomTopic = (key) => {
    const index = customTopics.value.findIndex((t) => t.key === key);
    if (index !== -1) {
      customTopics.value.splice(index, 1);
      saveToLocalStorage();
    }
  };
  return {
    // State
    allVocabularies,
    totalCount,
    favoriteVocabularies,
    isStoreReady,
    // Getters
    getVocabularyById,
    getCategories,
    getLevels,
    getCategoryUsage,
    // Actions
    addVocabulary,
    updateVocabulary,
    deleteVocabulary,
    clearAllVocabularies,
    importVocabularies,
    toggleFavorite,
    filterVocabularies,
    initializeStore,
    // Utils
    saveToLocalStorage,
    // Custom topics management
    customTopics,
    refreshCustomTopics,
    addCustomTopic,
    updateCustomTopic,
    deleteCustomTopic
  };
}

const formatDate = (dateString, locale = "vi-VN") => {
  if (!dateString) return "";
  try {
    const date = new Date(dateString);
    return date.toLocaleDateString(locale, {
      year: "numeric",
      month: "long",
      day: "numeric"
    });
  } catch (error) {
    return "";
  }
};
const getRelativeTime = (dateString, t) => {
  if (!dateString) return "";
  try {
    const date = new Date(dateString);
    const now = /* @__PURE__ */ new Date();
    const diffInMs = now.getTime() - date.getTime();
    const diffInHours = Math.floor(diffInMs / (1e3 * 60 * 60));
    const diffInDays = Math.floor(diffInHours / 24);
    if (diffInHours < 1) {
      const diffInMinutes = Math.floor(diffInMs / (1e3 * 60));
      if (diffInMinutes < 1) {
        return t ? t("time.ago.justNow") : "Just now";
      }
      return t ? t("time.ago.minutesAgo", { minutes: diffInMinutes }) : `${diffInMinutes} minutes ago`;
    } else if (diffInHours < 24) {
      return t ? t("time.ago.hoursAgo", { hours: diffInHours }) : `${diffInHours} hours ago`;
    } else if (diffInDays === 1) {
      return t ? t("time.ago.yesterday") : "Yesterday";
    } else if (diffInDays < 7) {
      return t ? t("time.ago.daysAgo", { days: diffInDays }) : `${diffInDays} days ago`;
    } else {
      return formatDate(dateString);
    }
  } catch (error) {
    return "";
  }
};
const getDateKey = (dateString) => {
  if (!dateString) return "";
  try {
    const date = new Date(dateString);
    return date.toISOString().split("T")[0];
  } catch (error) {
    return "";
  }
};
const groupVocabulariesByTopic = (vocabularies) => {
  const grouped = /* @__PURE__ */ new Map();
  const uncategorizedKey = "Uncategorized";
  vocabularies.forEach((vocab) => {
    const topic = vocab.category || uncategorizedKey;
    if (!grouped.has(topic)) {
      grouped.set(topic, []);
    }
    grouped.get(topic).push(vocab);
  });
  const result = Array.from(grouped.entries()).map(([topic, vocabs]) => {
    const firstVocab = vocabs[0];
    const categoryName = firstVocab?.categoryName || null;
    return {
      topic,
      categoryName,
      // Preserve category name from imported data
      vocabularies: vocabs.sort((a, b) => {
        const timeA = new Date(a.createdAt || "").getTime();
        const timeB = new Date(b.createdAt || "").getTime();
        return timeB - timeA;
      })
    };
  });
  return result.sort((a, b) => {
    if (a.topic === uncategorizedKey) return 1;
    if (b.topic === uncategorizedKey) return -1;
    return a.topic.localeCompare(b.topic);
  });
};
const groupVocabulariesByDateAndTopic = (vocabularies, locale = "vi-VN", t) => {
  const groupedByDate = groupVocabulariesByDate(vocabularies, locale, t);
  return groupedByDate.map((dateGroup) => {
    return {
      ...dateGroup,
      topics: groupVocabulariesByTopic(dateGroup.vocabularies)
    };
  });
};
const groupVocabulariesByDate = (vocabularies, locale = "vi-VN", t) => {
  const grouped = /* @__PURE__ */ new Map();
  vocabularies.forEach((vocab) => {
    const dateKey = getDateKey(vocab.createdAt);
    if (!dateKey) return;
    if (!grouped.has(dateKey)) {
      grouped.set(dateKey, []);
    }
    grouped.get(dateKey).push(vocab);
  });
  const result = Array.from(grouped.entries()).map(([dateKey, vocabs]) => ({
    date: dateKey,
    displayDate: getGroupDisplayDate(dateKey, locale, t),
    vocabularies: vocabs.sort((a, b) => {
      const timeA = new Date(a.createdAt || "").getTime();
      const timeB = new Date(b.createdAt || "").getTime();
      return timeB - timeA;
    })
  })).sort((a, b) => {
    return b.date.localeCompare(a.date);
  });
  return result;
};
const getGroupDisplayDate = (dateKey, locale = "vi-VN", t) => {
  try {
    const date = /* @__PURE__ */ new Date(dateKey + "T00:00:00");
    const today = /* @__PURE__ */ new Date();
    const yesterday = new Date(today);
    yesterday.setDate(today.getDate() - 1);
    const todayKey = getDateKey(today.toISOString());
    const yesterdayKey = getDateKey(yesterday.toISOString());
    if (dateKey === todayKey) {
      if (t) return t("time.today") || "Today";
      const l = locale.toLowerCase();
      if (l.startsWith("vi")) return "Hôm nay";
      if (l.startsWith("ko")) return "오늘";
      return "Today";
    } else if (dateKey === yesterdayKey) {
      if (t) return t("time.yesterday") || "Yesterday";
      const l = locale.toLowerCase();
      if (l.startsWith("vi")) return "Hôm qua";
      if (l.startsWith("ko")) return "어제";
      return "Yesterday";
    } else {
      return formatDate(date.toISOString(), locale);
    }
  } catch (error) {
    return dateKey;
  }
};

const _hoisted_1$1r = { class: "min-h-screen overflow-x-hidden bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative" };
const _hoisted_2$1o = { class: "max-w-7xl mx-auto py-3 sm:py-5 px-3 sm:px-6 lg:px-8 relative" };
const _hoisted_3$1l = { class: "mb-6 sm:mb-8" };
const _hoisted_4$1g = { class: "grid grid-cols-1 md:grid-cols-2 gap-4 sm:gap-6 mb-6 sm:mb-8" };
const _hoisted_5$1d = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-105 hover:-translate-y-2 h-full min-h-[360px] sm:min-h-[420px] flex flex-col" };
const _hoisted_6$1a = { class: "px-4 py-5 sm:p-8 flex-1 flex flex-col" };
const _hoisted_7$16 = { class: "flex items-center mb-6" };
const _hoisted_8$14 = { class: "text-lg sm:text-xl md:text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent" };
const _hoisted_9$13 = { class: "grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4 flex-1" };
const _hoisted_10$12 = { class: "relative z-10 text-center" };
const _hoisted_11$12 = { class: "text-xs sm:text-sm md:text-base font-medium" };
const _hoisted_12$$ = { class: "relative z-10 text-center" };
const _hoisted_13$$ = { class: "text-xs sm:text-sm md:text-base font-medium" };
const _hoisted_14$_ = { class: "relative z-10 text-center" };
const _hoisted_15$U = { class: "text-xs sm:text-sm md:text-base font-medium" };
const _hoisted_16$T = { class: "relative z-10 text-center" };
const _hoisted_17$S = { class: "text-xs sm:text-sm md:text-base font-medium" };
const _hoisted_18$Q = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-105 hover:-translate-y-2 h-full min-h-[420px] flex flex-col" };
const _hoisted_19$Q = { class: "px-6 py-8 sm:p-8 flex-1 flex flex-col" };
const _hoisted_20$P = { class: "flex items-center mb-6" };
const _hoisted_21$P = { class: "text-lg sm:text-xl md:text-2xl font-bold bg-gradient-to-r from-green-600 to-blue-600 dark:from-green-400 dark:to-blue-400 bg-clip-text text-transparent" };
const _hoisted_22$N = { class: "space-y-4 flex-1" };
const _hoisted_23$N = { class: "flex-shrink-0" };
const _hoisted_24$L = { class: "flex-1 min-w-0" };
const _hoisted_25$L = { class: "text-xs sm:text-sm md:text-base font-semibold text-gray-900 dark:text-white truncate" };
const _hoisted_26$I = { class: "text-xs sm:text-sm text-blue-600 dark:text-blue-400 font-medium" };
const _sfc_main$1s = /* @__PURE__ */ defineComponent({
  __name: "DashboardView",
  setup(__props) {
    const LazyLoadComponent = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => LazyLoadComponent$1),true              ?void 0:void 0))
    );
    const DashboardHeader$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => DashboardHeader),true              ?void 0:void 0))
    );
    const DashboardStats$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => DashboardStats),true              ?void 0:void 0))
    );
    const FlashcardStats = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => FlashcardStats$1),true              ?void 0:void 0))
    );
    const router = useRouter();
    const { t } = useI18n();
    const vocabularyStore = useVocabularyStore();
    const stats = computed(() => {
      const allVocabs = vocabularyStore.allVocabularies.value;
      const favoriteCount = vocabularyStore.favoriteVocabularies.value.length;
      const categories = vocabularyStore.getCategories.value.length;
      const today = /* @__PURE__ */ new Date();
      const todayStr = today.toISOString().split("T")[0];
      const todayVocabs = allVocabs.filter(
        (v) => v.createdAt && v.createdAt.split("T")[0] === todayStr
      ).length;
      return {
        vocabularyLearned: allVocabs.length,
        grammarLessons: categories,
        // Use categories count as grammar lessons
        currentStreak: Math.max(1, todayVocabs),
        // At least 1 if there are vocabularies
        totalTime: favoriteCount * 5
        // Estimate 5 minutes per favorite vocabulary
      };
    });
    const recentActivities = computed(() => {
      const allVocabs = vocabularyStore.allVocabularies.value;
      const activities = [];
      const recentVocabs = [...allVocabs].sort((a, b) => {
        const aTime = a.updatedAt || a.createdAt || "";
        const bTime = b.updatedAt || b.createdAt || "";
        return new Date(bTime).getTime() - new Date(aTime).getTime();
      }).slice(0, 4);
      recentVocabs.forEach((vocab, index) => {
        const isUpdated = vocab.updatedAt && vocab.updatedAt !== vocab.createdAt;
        const timeStr = vocab.updatedAt || vocab.createdAt || "";
        const categoryTranslated = t(`categories.${vocab.category}`, vocab.category);
        activities.push({
          id: index + 1,
          title: isUpdated ? t("dashboard.activity.updated", { word: vocab.word, category: categoryTranslated }, `Updated '${vocab.word}' in ${categoryTranslated}`) : t("dashboard.activity.added", { word: vocab.word, category: categoryTranslated }, `Added '${vocab.word}' to ${categoryTranslated}`),
          time: timeStr ? getRelativeTime(timeStr, t) : t("dashboard.activity.justNow", "Just now"),
          iconColor: isUpdated ? "bg-blue-500" : "bg-green-500"
        });
      });
      if (activities.length === 0) {
        activities.push({
          id: 1,
          title: t("dashboard.activity.noActivity", "No recent activity"),
          time: t("dashboard.activity.addFirstVocab", "Add your first vocabulary to get started!"),
          iconColor: "bg-gray-500"
        });
      }
      return activities;
    });
    const navigateTo = (path) => {
      router.push(path);
    };
    onMounted(() => {
      vocabularyStore.initializeStore();
      console.log("Dashboard mounted with real data");
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1r, [
        _cache[20] || (_cache[20] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0"><div class="floating-shapes"><div class="absolute top-20 left-10 w-40 h-40 sm:w-64 sm:h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob"></div><div class="absolute top-40 right-10 w-48 h-48 sm:w-72 sm:h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000"></div><div class="absolute -bottom-8 left-20 w-56 h-56 sm:w-80 sm:h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000"></div></div></div>', 1)),
        createVNode(unref(LazyLoadComponent), { "animation-type": "fade-up" }, {
          default: withCtx(() => [
            createVNode(unref(DashboardHeader$1))
          ]),
          _: 1
        }),
        createBaseVNode("div", _hoisted_2$1o, [
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "slide-up",
            threshold: 0.2
          }, {
            default: withCtx(() => [
              createVNode(unref(DashboardStats$1), {
                stats: stats.value,
                class: "mb-8"
              }, null, 8, ["stats"])
            ]),
            _: 1
          }),
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "slide-up",
            threshold: 0.15
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_3$1l, [
                createVNode(unref(FlashcardStats))
              ])
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_4$1g, [
            createVNode(unref(LazyLoadComponent), {
              "animation-type": "slide-left",
              threshold: 0.15
            }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_5$1d, [
                  createBaseVNode("div", _hoisted_6$1a, [
                    createBaseVNode("div", _hoisted_7$16, [
                      _cache[4] || (_cache[4] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                        createBaseVNode("div", { class: "w-3 h-3 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full mr-3" })
                      ], -1)),
                      createBaseVNode("h3", _hoisted_8$14, toDisplayString$1(unref(t)("dashboard.quickActions", "Quick Actions")), 1)
                    ]),
                    createBaseVNode("div", _hoisted_9$13, [
                      createBaseVNode("button", {
                        onClick: _cache[0] || (_cache[0] = ($event) => navigateTo("/vocabulary")),
                        class: "group/btn relative overflow-hidden bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-semibold py-3 px-3 sm:py-4 sm:px-4 rounded-xl transition-all duration-300 transform hover:scale-105 hover:shadow-lg active:scale-95"
                      }, [
                        _cache[6] || (_cache[6] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-r from-blue-400 to-blue-500 opacity-0 group-hover/btn:opacity-100 transition-opacity duration-300" }, null, -1)),
                        createBaseVNode("div", _hoisted_10$12, [
                          _cache[5] || (_cache[5] = createBaseVNode("svg", {
                            class: "w-6 h-6 sm:w-7 sm:h-7 md:w-8 md:h-8 mx-auto mb-2 transform group-hover/btn:rotate-180 transition-transform duration-500",
                            fill: "currentColor",
                            viewBox: "0 0 20 20"
                          }, [
                            createBaseVNode("path", {
                              "fill-rule": "evenodd",
                              d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                              "clip-rule": "evenodd"
                            })
                          ], -1)),
                          createBaseVNode("span", _hoisted_11$12, toDisplayString$1(unref(t)("dashboard.actions.addVocabulary", "Add Vocabulary")), 1)
                        ]),
                        _cache[7] || (_cache[7] = createBaseVNode("div", { class: "absolute inset-0 bg-white opacity-0 group-hover/btn:opacity-20 transition-opacity duration-300" }, null, -1))
                      ]),
                      createBaseVNode("button", {
                        onClick: _cache[1] || (_cache[1] = ($event) => navigateTo("/practice/flashcard")),
                        class: "group/btn relative overflow-hidden bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-semibold py-3 px-3 sm:py-4 sm:px-4 rounded-xl transition-all duration-300 transform hover:scale-105 hover:shadow-lg active:scale-95"
                      }, [
                        _cache[9] || (_cache[9] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-r from-green-400 to-green-500 opacity-0 group-hover/btn:opacity-100 transition-opacity duration-300" }, null, -1)),
                        createBaseVNode("div", _hoisted_12$$, [
                          _cache[8] || (_cache[8] = createBaseVNode("svg", {
                            class: "w-6 h-6 sm:w-7 sm:h-7 md:w-8 md:h-8 mx-auto mb-2 transform group-hover/btn:scale-110 transition-transform duration-300",
                            fill: "currentColor",
                            viewBox: "0 0 20 20"
                          }, [
                            createBaseVNode("path", { d: "M7 3a1 1 0 000 2h6a1 1 0 100-2H7zM4 7a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zM2 11a2 2 0 012-2h12a2 2 0 012 2v4a2 2 0 01-2 2H4a2 2 0 01-2-2v-4z" })
                          ], -1)),
                          createBaseVNode("span", _hoisted_13$$, toDisplayString$1(unref(t)("dashboard.actions.practiceFlashcard", "Practice Flashcard")), 1)
                        ]),
                        _cache[10] || (_cache[10] = createBaseVNode("div", { class: "absolute inset-0 bg-white opacity-0 group-hover/btn:opacity-20 transition-opacity duration-300" }, null, -1))
                      ]),
                      createBaseVNode("button", {
                        onClick: _cache[2] || (_cache[2] = ($event) => navigateTo("/practice/quiz")),
                        class: "group/btn relative overflow-hidden bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 text-white font-semibold py-3 px-3 sm:py-4 sm:px-4 rounded-xl transition-all duration-300 transform hover:scale-105 hover:shadow-lg active:scale-95"
                      }, [
                        _cache[12] || (_cache[12] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-r from-yellow-400 to-yellow-500 opacity-0 group-hover/btn:opacity-100 transition-opacity duration-300" }, null, -1)),
                        createBaseVNode("div", _hoisted_14$_, [
                          _cache[11] || (_cache[11] = createBaseVNode("svg", {
                            class: "w-6 h-6 sm:w-7 sm:h-7 md:w-8 md:h-8 mx-auto mb-2 transform group-hover/btn:bounce",
                            fill: "currentColor",
                            viewBox: "0 0 20 20"
                          }, [
                            createBaseVNode("path", {
                              "fill-rule": "evenodd",
                              d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z",
                              "clip-rule": "evenodd"
                            })
                          ], -1)),
                          createBaseVNode("span", _hoisted_15$U, toDisplayString$1(unref(t)("dashboard.actions.takeQuiz", "Take a Quiz")), 1)
                        ]),
                        _cache[13] || (_cache[13] = createBaseVNode("div", { class: "absolute inset-0 bg-white opacity-0 group-hover/btn:opacity-20 transition-opacity duration-300" }, null, -1))
                      ]),
                      createBaseVNode("button", {
                        onClick: _cache[3] || (_cache[3] = ($event) => navigateTo("/grammar")),
                        class: "group/btn relative overflow-hidden bg-gradient-to-r from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700 text-white font-semibold py-3 px-3 sm:py-4 sm:px-4 rounded-xl transition-all duration-300 transform hover:scale-105 hover:shadow-lg active:scale-95"
                      }, [
                        _cache[15] || (_cache[15] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-r from-purple-400 to-purple-500 opacity-0 group-hover/btn:opacity-100 transition-opacity duration-300" }, null, -1)),
                        createBaseVNode("div", _hoisted_16$T, [
                          _cache[14] || (_cache[14] = createBaseVNode("svg", {
                            class: "w-6 h-6 sm:w-7 sm:h-7 md:w-8 md:h-8 mx-auto mb-2 transform group-hover/btn:rotate-12 transition-transform duration-300",
                            fill: "currentColor",
                            viewBox: "0 0 20 20"
                          }, [
                            createBaseVNode("path", { d: "M9 4.804A7.968 7.968 0 005.5 4c-1.255 0-2.443.29-3.5.804v10A7.969 7.969 0 015.5 14c1.669 0 3.218.51 4.5 1.385A7.962 7.962 0 0114.5 14c1.255 0 2.443.29 3.5.804v-10A7.968 7.968 0 0014.5 4c-1.255 0-2.443.29-3.5.804V12a1 1 0 11-2 0V4.804z" })
                          ], -1)),
                          createBaseVNode("span", _hoisted_17$S, toDisplayString$1(unref(t)("dashboard.actions.learnGrammar", "Learn Grammar")), 1)
                        ]),
                        _cache[16] || (_cache[16] = createBaseVNode("div", { class: "absolute inset-0 bg-white opacity-0 group-hover/btn:opacity-20 transition-opacity duration-300" }, null, -1))
                      ])
                    ])
                  ])
                ])
              ]),
              _: 1
            }),
            createVNode(unref(LazyLoadComponent), {
              "animation-type": "slide-up",
              threshold: 0.15
            }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_18$Q, [
                  createBaseVNode("div", _hoisted_19$Q, [
                    createBaseVNode("div", _hoisted_20$P, [
                      _cache[17] || (_cache[17] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                        createBaseVNode("div", { class: "w-3 h-3 bg-gradient-to-r from-green-400 to-blue-500 rounded-full mr-3" })
                      ], -1)),
                      createBaseVNode("h3", _hoisted_21$P, toDisplayString$1(unref(t)("dashboard.recentActivity", "Recent Activity")), 1)
                    ]),
                    createBaseVNode("div", _hoisted_22$N, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(recentActivities.value, (activity, index) => {
                        return openBlock(), createElementBlock("div", {
                          key: activity.id,
                          class: "group/activity flex items-center space-x-4 p-3 rounded-xl hover:bg-white/50 dark:hover:bg-white/5 transition-all duration-300 transform hover:scale-105",
                          style: normalizeStyle({ animationDelay: `${index * 100}ms` })
                        }, [
                          createBaseVNode("div", _hoisted_23$N, [
                            createBaseVNode("div", {
                              class: normalizeClass(["w-10 h-10 rounded-full flex items-center justify-center transform group-hover/activity:rotate-12 group-hover/activity:scale-110 transition-all duration-300", activity.iconColor])
                            }, _cache[18] || (_cache[18] = [
                              createBaseVNode("svg", {
                                class: "w-5 h-5 text-white",
                                fill: "currentColor",
                                viewBox: "0 0 20 20"
                              }, [
                                createBaseVNode("path", {
                                  "fill-rule": "evenodd",
                                  d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z",
                                  "clip-rule": "evenodd"
                                })
                              ], -1)
                            ]), 2)
                          ]),
                          createBaseVNode("div", _hoisted_24$L, [
                            createBaseVNode("p", _hoisted_25$L, toDisplayString$1(activity.title), 1),
                            createBaseVNode("p", _hoisted_26$I, toDisplayString$1(activity.time), 1)
                          ]),
                          _cache[19] || (_cache[19] = createBaseVNode("div", { class: "opacity-0 group-hover/activity:opacity-100 transition-opacity duration-300" }, [
                            createBaseVNode("svg", {
                              class: "w-5 h-5 text-blue-500 dark:text-blue-400",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M9 5l7 7-7 7"
                              })
                            ])
                          ], -1))
                        ], 4);
                      }), 128))
                    ])
                  ])
                ])
              ]),
              _: 1
            })
          ])
        ])
      ]);
    };
  }
});

const debugAvailableVoices = () => {
  if ("speechSynthesis" in window) {
    const voices = speechSynthesis.getVoices();
    console.log("=== AVAILABLE VOICES DEBUG ====");
    console.log(`Total voices found: ${voices.length}`);
    voices.forEach((voice, index) => {
      console.log(`${index + 1}. Name: "${voice.name}" | Lang: ${voice.lang} | Local: ${voice.localService} | Default: ${voice.default}`);
    });
    const koreanVoices = voices.filter((voice) => voice.lang.startsWith("ko"));
    console.log("\n=== KOREAN VOICES DETAIL ====");
    console.log(`Korean voices found: ${koreanVoices.length}`);
    koreanVoices.forEach((voice, index) => {
      const name = voice.name.toLowerCase();
      const genderGuess = name.includes("female") || name.includes("woman") ? "👩 Female" : name.includes("male") || name.includes("man") ? "👨 Male" : "❓ Unknown";
      console.log(`🇰🇷 ${index + 1}. "${voice.name}" | ${genderGuess} | Lang: ${voice.lang}`);
    });
    console.log("===============================");
    return voices;
  }
  return [];
};
const defaultSettings = {
  "female-sweet": { rate: 0.85, pitch: 1.1, volume: 1 },
  "female-clear": { rate: 1, pitch: 0.95, volume: 1 },
  "female-professional": { rate: 0.9, pitch: 0.85, volume: 1 },
  "male-strong": { rate: 0.8, pitch: 0.7, volume: 1 },
  "male-gentle": { rate: 0.9, pitch: 0.9, volume: 1 },
  "male-deep": { rate: 0.75, pitch: 0.6, volume: 1 },
  "korean-female": { rate: 0.95, pitch: 1.15, volume: 1 },
  "korean-male": { rate: 0.85, pitch: 0.5, volume: 1 }
};
const voiceSettings = ref({ ...defaultSettings });
const currentVoiceType = ref("female-sweet");
const availableVoices = ref([]);
const selectedVoice = ref(null);
const loadVoices = () => {
  if ("speechSynthesis" in window) {
    const voices = speechSynthesis.getVoices();
    console.log("Loading voices, total found:", voices.length);
    debugAvailableVoices();
    const englishVoices = voices.filter((voice) => voice.lang.startsWith("en"));
    const koreanVoices = voices.filter((voice) => voice.lang.startsWith("ko"));
    const allSupportedVoices = [...englishVoices, ...koreanVoices];
    console.log("English voices found:", englishVoices.length);
    console.log("Korean voices found:", koreanVoices.length);
    console.log("Total supported voices:", allSupportedVoices.length);
    availableVoices.value = allSupportedVoices;
    if (allSupportedVoices.length > 0) {
      updateSelectedVoice();
    }
  }
};
const updateSelectedVoice = () => {
  const voices = availableVoices.value;
  console.log("Updating voice selection, available voices:", voices.length);
  console.log("Current voice type:", currentVoiceType.value);
  if (voices.length === 0) {
    console.log("No voices available, loading voices...");
    loadVoices();
    return;
  }
  let targetVoice = null;
  const englishVoices = voices.filter((voice) => voice.lang.startsWith("en"));
  const koreanVoices = voices.filter((voice) => voice.lang.startsWith("ko"));
  const femaleVoices = englishVoices.filter((voice) => {
    const name = voice.name.toLowerCase();
    return name.includes("female") || name.includes("woman") || name.includes("zira") || name.includes("hazel") || name.includes("cortana") || name.includes("helena") || name.includes("susan") || name.includes("samantha") || name.includes("karen");
  });
  const maleVoices = englishVoices.filter((voice) => {
    const name = voice.name.toLowerCase();
    return name.includes("male") || name.includes("man") || name.includes("david") || name.includes("mark") || name.includes("daniel") || name.includes("richard") || name.includes("alex") || name.includes("tom") || name.includes("aaron");
  });
  const koreanFemaleVoices = koreanVoices.filter((voice) => {
    const name = voice.name.toLowerCase();
    if (name.includes("female") || name.includes("woman")) return true;
    if (name.includes("heami") || name.includes("yuna") || name.includes("seoyeon") || name.includes("sora") || name.includes("inha") || name.includes("nayeon") || name.includes("clara") || name.includes("aria")) return true;
    if (name.includes("male") || name.includes("man")) return false;
    return false;
  });
  const koreanMaleVoices = koreanVoices.filter((voice) => {
    const name = voice.name.toLowerCase();
    if (name.includes("male") || name.includes("man")) return true;
    if (name.includes("minho") || name.includes("woojin") || name.includes("taehyun") || name.includes("jun") || name.includes("alex") || name.includes("david") || name.includes("injoo")) return true;
    if (name.includes("female") || name.includes("woman")) return false;
    return false;
  });
  const remainingKoreanVoices = koreanVoices.filter(
    (voice) => !koreanFemaleVoices.includes(voice) && !koreanMaleVoices.includes(voice)
  );
  if (remainingKoreanVoices.length > 0) {
    const midPoint = Math.ceil(remainingKoreanVoices.length / 2);
    koreanFemaleVoices.push(...remainingKoreanVoices.slice(0, midPoint));
    koreanMaleVoices.push(...remainingKoreanVoices.slice(midPoint));
  }
  console.log(`English Female voices found: ${femaleVoices.length}`, femaleVoices.map((v) => v.name));
  console.log(`English Male voices found: ${maleVoices.length}`, maleVoices.map((v) => v.name));
  console.log(`Korean Female voices found: ${koreanFemaleVoices.length}`, koreanFemaleVoices.map((v) => v.name));
  console.log(`Korean Male voices found: ${koreanMaleVoices.length}`, koreanMaleVoices.map((v) => v.name));
  if (koreanFemaleVoices.length === 0 && koreanMaleVoices.length === 0 && koreanVoices.length > 0) {
    const halfPoint = Math.floor(koreanVoices.length / 2);
    koreanFemaleVoices.push(...koreanVoices.slice(0, halfPoint));
    koreanMaleVoices.push(...koreanVoices.slice(halfPoint));
    console.log("No Korean gender-specific voices found, splitting by index");
  }
  if (femaleVoices.length === 0 && maleVoices.length === 0 && englishVoices.length > 0) {
    const halfPoint = Math.floor(englishVoices.length / 2);
    femaleVoices.push(...englishVoices.slice(0, halfPoint));
    maleVoices.push(...englishVoices.slice(halfPoint));
    console.log("No English gender-specific voices found, splitting by index");
  }
  switch (currentVoiceType.value) {
    case "female-sweet":
      targetVoice = femaleVoices[0] || voices[0];
      console.log("Selected female-sweet:", targetVoice?.name);
      break;
    case "female-clear":
      targetVoice = femaleVoices[1] || femaleVoices[0] || voices[1] || voices[0];
      console.log("Selected female-clear:", targetVoice?.name);
      break;
    case "female-professional":
      targetVoice = femaleVoices[2] || femaleVoices[0] || voices[2] || voices[0];
      console.log("Selected female-professional:", targetVoice?.name);
      break;
    case "male-strong":
      targetVoice = maleVoices[0] || voices[Math.floor(voices.length / 2)] || voices[0];
      console.log("Selected male-strong:", targetVoice?.name);
      break;
    case "male-gentle":
      targetVoice = maleVoices[1] || maleVoices[0] || voices[Math.floor(voices.length / 2) + 1] || voices[0];
      console.log("Selected male-gentle:", targetVoice?.name);
      break;
    case "male-deep":
      targetVoice = maleVoices[2] || maleVoices[0] || voices[Math.floor(voices.length / 2) + 2] || voices[0];
      console.log("Selected male-deep:", targetVoice?.name);
      break;
    case "korean-female":
      targetVoice = koreanVoices[0] || voices[0];
      console.log("🇰🇷👩 KOREAN FEMALE - Selected voice:", targetVoice?.name, "Lang:", targetVoice?.lang);
      break;
    case "korean-male":
      if (koreanVoices.length >= 2) {
        targetVoice = koreanVoices[1];
        console.log("🇰🇷👨 KOREAN MALE - Using second Korean voice:", targetVoice?.name);
      } else if (koreanVoices.length === 1) {
        targetVoice = koreanVoices[0];
        console.log("🇰🇷👨 KOREAN MALE - Using same Korean voice with deep pitch (0.5):", targetVoice?.name);
      } else {
        targetVoice = maleVoices[0] || voices[0];
        console.log("🇰🇷👨 KOREAN MALE - No Korean voices, using male voice:", targetVoice?.name);
      }
      if (!targetVoice) {
        targetVoice = voices[0];
        console.log("⚠️ FALLBACK: Using first available voice:", targetVoice?.name);
      }
      console.log("🇰🇷 Total Korean voices:", koreanVoices.length, koreanVoices.map((v) => v.name));
      console.log("🎯 Final selected voice for Korean Male:", targetVoice?.name, "Lang:", targetVoice?.lang);
      break;
  }
  console.log(`Looking for ${currentVoiceType.value} voice, found:`, targetVoice?.name);
  const previousVoice = selectedVoice.value?.name;
  selectedVoice.value = targetVoice || voices[0] || null;
  console.log("Voice changed from", previousVoice, "to", selectedVoice.value?.name);
};
const loadSettings = () => {
  const saved = localStorage.getItem("voice-settings");
  const savedType = localStorage.getItem("voice-type");
  if (saved) {
    try {
      const parsedSettings = JSON.parse(saved);
      voiceSettings.value = {
        ...defaultSettings,
        ...Object.keys(parsedSettings).reduce((acc, key) => {
          const voiceType = key;
          if (defaultSettings[voiceType]) {
            acc[voiceType] = { ...defaultSettings[voiceType], ...parsedSettings[voiceType] };
          }
          return acc;
        }, {})
      };
    } catch (error) {
      console.error("Error loading voice settings:", error);
      voiceSettings.value = { ...defaultSettings };
    }
  }
  if (savedType) {
    currentVoiceType.value = savedType;
  }
};
const saveSettings = () => {
  localStorage.setItem("voice-settings", JSON.stringify(voiceSettings.value));
  localStorage.setItem("voice-type", currentVoiceType.value);
};
const createUtterance = (text) => {
  updateSelectedVoice();
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.lang = "en-US";
  const settings = voiceSettings.value[currentVoiceType.value];
  utterance.rate = Math.max(0.1, Math.min(10, settings.rate));
  utterance.pitch = Math.max(0, Math.min(2, settings.pitch));
  utterance.volume = Math.max(0, Math.min(1, settings.volume));
  console.log("Creating utterance with voice type:", currentVoiceType.value);
  console.log("Selected voice for utterance:", selectedVoice.value?.name);
  if (selectedVoice.value) {
    utterance.voice = selectedVoice.value;
  }
  return utterance;
};
const playAudio = (text) => {
  return new Promise((resolve, reject) => {
    if (!("speechSynthesis" in window)) {
      console.warn("Speech synthesis not supported");
      reject(new Error("Speech synthesis not supported"));
      return;
    }
    const utterance = createUtterance(text);
    utterance.onend = () => resolve();
    utterance.onerror = (event) => reject(event.error);
    speechSynthesis.speak(utterance);
  });
};
const setVoiceType = (type) => {
  console.log("Setting voice type to:", type);
  currentVoiceType.value = type;
  if (availableVoices.value.length === 0) {
    loadVoices();
  }
  updateSelectedVoice();
  saveSettings();
  console.log("Voice updated to:", selectedVoice.value?.name);
};
const updateVoiceSettings = (type, newSettings) => {
  if (voiceSettings.value[type]) {
    voiceSettings.value[type] = { ...voiceSettings.value[type], ...newSettings };
    saveSettings();
  }
};
const resetVoiceSettings = (type) => {
  if (defaultSettings[type]) {
    voiceSettings.value[type] = { ...defaultSettings[type] };
    saveSettings();
  }
};
const getVoiceTypeOptions = () => {
  const { t } = useI18n();
  return [
    { value: "female-sweet", label: t("voice.types.female_sweet", "Female Sweet"), icon: "👩💖" },
    { value: "female-clear", label: t("voice.types.female_clear", "Female Clear"), icon: "👩💼" },
    { value: "female-professional", label: t("voice.types.female_professional", "Female Professional"), icon: "👩🎯" },
    { value: "male-strong", label: t("voice.types.male_strong", "Male Strong"), icon: "👨💪" },
    { value: "male-gentle", label: t("voice.types.male_gentle", "Male Gentle"), icon: "👨😊" },
    { value: "male-deep", label: t("voice.types.male_deep", "Male Deep"), icon: "👨🎭" },
    { value: "korean-female", label: t("voice.types.korean_female", "Korean Female"), icon: "🇰🇷👩" },
    { value: "korean-male", label: t("voice.types.korean_male", "Korean Male"), icon: "🇰🇷👨" }
  ];
};
const getCurrentVoiceInfo = () => {
  if (!selectedVoice.value) return null;
  const gender = currentVoiceType.value.includes("female") ? "female" : "male";
  return {
    name: selectedVoice.value.name,
    lang: selectedVoice.value.lang,
    gender
  };
};
watch(voiceSettings, () => {
  saveSettings();
}, { deep: true });
watch(currentVoiceType, (newType, oldType) => {
  if (newType !== oldType) {
    console.log("Voice type changed from", oldType, "to", newType);
    updateSelectedVoice();
    saveSettings();
  }
});
if ("speechSynthesis" in window) {
  speechSynthesis.onvoiceschanged = () => {
    loadVoices();
  };
}
loadSettings();
loadVoices();
const forceReloadVoices = () => {
  console.log("🔄 Force reloading voices...");
  if ("speechSynthesis" in window) {
    speechSynthesis.cancel();
    speechSynthesis.getVoices();
    loadVoices();
    debugAvailableVoices();
  }
};
function useVoiceStore() {
  return {
    voiceSettings,
    currentVoiceType,
    availableVoices,
    selectedVoice,
    setVoiceType,
    updateVoiceSettings,
    resetVoiceSettings,
    playAudio,
    createUtterance,
    getVoiceTypeOptions,
    getCurrentVoiceInfo,
    loadVoices,
    forceReloadVoices,
    debugAvailableVoices
  };
}

const BUILT_IN_CATEGORIES = [
  "technology",
  "business",
  "travel",
  "food",
  "health",
  "education",
  "sports",
  "entertainment",
  "science",
  "art",
  "music",
  "literature",
  "politics",
  "environment",
  "fashion",
  "finance"
];
function normalizeLocale(input) {
  const s = (input || "").toLowerCase();
  if (s.startsWith("vi")) return "vi";
  if (s.startsWith("ko")) return "ko";
  return "en";
}
function getTopicName(categoryKey, t, locale, vocabularyItem) {
  const customTopics = getCustomTopics();
  const builtInKeys = BUILT_IN_CATEGORIES;
  const rawLocale = typeof locale === "string" ? locale : locale?.value;
  const currentLocale = normalizeLocale(rawLocale);
  let key = String(categoryKey || "").trim();
  const isNumericLike = /^\d+$/.test(key);
  if (isNumericLike && vocabularyItem && vocabularyItem.category && !/^\d+$/.test(String(vocabularyItem.category))) {
    key = String(vocabularyItem.category);
  }
  const keyLower = key.toLowerCase();
  if (vocabularyItem && vocabularyItem.categoryName) {
    const cn = String(vocabularyItem.categoryName).trim();
    const cnLower = cn.toLowerCase();
    const isKnownKey = builtInKeys.includes(cnLower) || customTopics.some((ct) => (ct.key || "").toLowerCase() === cnLower);
    if (!isKnownKey && currentLocale === "en") {
      return cn;
    }
  }
  const customTopic = customTopics.find((topic) => topic.key === key) || customTopics.find((topic) => (topic.key || "").toLowerCase() === keyLower);
  if (customTopic) {
    if (currentLocale === "vi") {
      return customTopic.vi || customTopic.en || customTopic.ko || key;
    }
    if (currentLocale === "ko") {
      return customTopic.ko || customTopic.en || customTopic.vi || key;
    }
    return customTopic.en || customTopic.vi || customTopic.ko || key;
  }
  if (t) {
    const translationKey = `vocabulary.categories.${keyLower}`;
    const translatedName = t(translationKey);
    if (translatedName && translatedName !== translationKey) {
      return translatedName;
    }
  }
  const builtInCategories = {
    "technology": { vi: "Công nghệ", en: "Technology", ko: "기술" },
    "business": { vi: "Kinh doanh", en: "Business", ko: "비즈니스" },
    "travel": { vi: "Du lịch", en: "Travel", ko: "여행" },
    "food": { vi: "Ẩm thực", en: "Food", ko: "음식" },
    "health": { vi: "Sức khỏe", en: "Health", ko: "건강" },
    "education": { vi: "Giáo dục", en: "Education", ko: "교육" },
    "sports": { vi: "Thể thao", en: "Sports", ko: "스포츠" },
    "entertainment": { vi: "Giải trí", en: "Entertainment", ko: "엔터테인먼트" },
    "science": { vi: "Khoa học", en: "Science", ko: "과학" },
    "art": { vi: "Nghệ thuật", en: "Art", ko: "예술" },
    "music": { vi: "Âm nhạc", en: "Music", ko: "음악" },
    "literature": { vi: "Văn học", en: "Literature", ko: "문학" },
    "politics": { vi: "Chính trị", en: "Politics", ko: "정치" },
    "environment": { vi: "Môi trường", en: "Environment", ko: "환경" },
    "fashion": { vi: "Thời trang", en: "Fashion", ko: "패션" },
    "finance": { vi: "Tài chính", en: "Finance", ko: "금융" }
  };
  if (builtInCategories[keyLower]) {
    if (currentLocale === "vi") return builtInCategories[keyLower].vi;
    if (currentLocale === "ko") return builtInCategories[keyLower].ko;
    return builtInCategories[keyLower].en;
  }
  if (vocabularyItem && vocabularyItem.categoryName) {
    return String(vocabularyItem.categoryName);
  }
  return key.charAt(0).toUpperCase() + key.slice(1);
}
function getAllTopicsWithNames(t, locale) {
  const builtInCategories = BUILT_IN_CATEGORIES;
  const result = [];
  builtInCategories.forEach((key) => {
    result.push({
      key,
      name: getTopicName(key, t, locale)
    });
  });
  const customTopics = getCustomTopics();
  customTopics.forEach((topic) => {
    result.push({
      key: topic.key,
      name: getTopicName(topic.key, t, locale)
    });
  });
  return result.sort((a, b) => a.name.localeCompare(b.name));
}
function getCustomTopics() {
  try {
    const saved = localStorage.getItem("customTopics");
    if (saved) {
      const topics = JSON.parse(saved);
      return Array.isArray(topics) ? topics : [];
    }
  } catch (error) {
    console.error("Error loading custom topics:", error);
  }
  return [];
}
function useTopicName() {
  const { t, locale } = useI18n();
  return {
    getTopicName: (categoryKey) => {
      return getTopicName(categoryKey, t, locale);
    },
    getAllTopicsWithNames: () => {
      return getAllTopicsWithNames(t, locale);
    },
    currentLocale: locale
  };
}

function useVocabularyFilters() {
  const searchQuery = ref("");
  const selectedCategory = ref("");
  const selectedLevel = ref("");
  const showFavoritesOnly = ref(false);
  const currentPage = ref(1);
  const dateGroupPages = ref({});
  function getStoredValue(key, defaultValue) {
    try {
      const stored = localStorage.getItem(key);
      return stored !== null ? JSON.parse(stored) : defaultValue;
    } catch {
      return defaultValue;
    }
  }
  function setStoredValue(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
  }
  showFavoritesOnly.value = getStoredValue("vocabulary-show-favorites-only", false);
  searchQuery.value = getStoredValue("vocabulary-search-query", "");
  selectedCategory.value = getStoredValue("vocabulary-selected-category", "");
  selectedLevel.value = getStoredValue("vocabulary-selected-level", "");
  const updateShowFavoritesOnly = (value) => {
    showFavoritesOnly.value = value;
    setStoredValue("vocabulary-show-favorites-only", value);
    currentPage.value = 1;
    dateGroupPages.value = {};
  };
  const updateSearchQuery = (value) => {
    searchQuery.value = value;
    setStoredValue("vocabulary-search-query", value);
    currentPage.value = 1;
    dateGroupPages.value = {};
  };
  const updateSelectedCategory = (value) => {
    selectedCategory.value = value;
    setStoredValue("vocabulary-selected-category", value);
    currentPage.value = 1;
    dateGroupPages.value = {};
  };
  const updateSelectedLevel = (value) => {
    selectedLevel.value = value;
    setStoredValue("vocabulary-selected-level", value);
    currentPage.value = 1;
    dateGroupPages.value = {};
  };
  return {
    searchQuery,
    selectedCategory,
    selectedLevel,
    showFavoritesOnly,
    currentPage,
    dateGroupPages,
    updateShowFavoritesOnly,
    updateSearchQuery,
    updateSelectedCategory,
    updateSelectedLevel
  };
}

function useVocabularyPagination(filteredVocabulary, useGrouping, itemsPerPage) {
  const currentPage = ref(1);
  const totalPages = computed(() => {
    if (useGrouping.value) return 1;
    return Math.ceil(filteredVocabulary.value.length / itemsPerPage.value);
  });
  const paginatedVocabulary = computed(() => {
    if (useGrouping.value) return filteredVocabulary.value;
    const start = (currentPage.value - 1) * itemsPerPage.value;
    const end = start + itemsPerPage.value;
    return filteredVocabulary.value.slice(start, end);
  });
  const startIndex = computed(() => (currentPage.value - 1) * itemsPerPage.value + 1);
  const endIndex = computed(() => Math.min(currentPage.value * itemsPerPage.value, filteredVocabulary.value.length));
  const visiblePages = computed(() => {
    const pages = [];
    const start = Math.max(1, currentPage.value - 2);
    const end = Math.min(totalPages.value, currentPage.value + 2);
    for (let i = start; i <= end; i++) {
      pages.push(i);
    }
    return pages;
  });
  const previousPage = () => {
    if (currentPage.value > 1) currentPage.value--;
  };
  const nextPage = () => {
    if (currentPage.value < totalPages.value) currentPage.value++;
  };
  const goToPage = (page) => {
    currentPage.value = page;
  };
  return {
    currentPage,
    totalPages,
    paginatedVocabulary,
    startIndex,
    endIndex,
    visiblePages,
    previousPage,
    nextPage,
    goToPage
  };
}

function useVocabularyGrouping() {
  const useGrouping = ref(false);
  const itemsPerPageGrouped = ref(5);
  const dateGroupPages = ref({});
  const getStoredUseGrouping = () => {
    const stored = localStorage.getItem("vocabulary-use-grouping");
    return stored ? JSON.parse(stored) : false;
  };
  const setStoredUseGrouping = (value) => {
    localStorage.setItem("vocabulary-use-grouping", JSON.stringify(value));
  };
  useGrouping.value = getStoredUseGrouping();
  const toggleGrouping = () => {
    useGrouping.value = !useGrouping.value;
    setStoredUseGrouping(useGrouping.value);
  };
  const reloadGroupingState = () => {
    useGrouping.value = getStoredUseGrouping();
  };
  const dateGroupPrevious = (date, filteredVocabulary) => {
    const currentPage = dateGroupPages.value[date] || 1;
    if (currentPage > 1) {
      dateGroupPages.value[date] = currentPage - 1;
    }
  };
  const dateGroupNext = (date, filteredVocabulary) => {
    const currentPage = dateGroupPages.value[date] || 1;
    const dateGroup = filteredVocabulary.filter((word) => getDateKey(word.createdAt) === date);
    const totalPages = Math.ceil(dateGroup.length / itemsPerPageGrouped.value);
    if (currentPage < totalPages) {
      dateGroupPages.value[date] = currentPage + 1;
    }
  };
  const dateGroupGoToPage = (date, page) => {
    dateGroupPages.value[date] = page;
  };
  return {
    useGrouping,
    itemsPerPageGrouped,
    dateGroupPages,
    toggleGrouping,
    reloadGroupingState,
    dateGroupPrevious,
    dateGroupNext,
    dateGroupGoToPage
  };
}

function useVocabularyDialogs() {
  const showFormDialog = ref(false);
  const selectedVocabulary = ref(null);
  const showDetailDialog = ref(false);
  const selectedVocabularyForDetail = ref(null);
  const openAddDialog = () => {
    selectedVocabulary.value = null;
    showFormDialog.value = true;
    window.dispatchEvent(new CustomEvent("vocabulary-edit-word"));
  };
  const openEditDialog = (word) => {
    selectedVocabulary.value = word;
    showFormDialog.value = true;
    window.dispatchEvent(new CustomEvent("vocabulary-edit-word"));
  };
  const onVocabularySaved = () => {
    showFormDialog.value = false;
    selectedVocabulary.value = null;
  };
  const openDetailsDialog = (word) => {
    selectedVocabularyForDetail.value = word;
    showDetailDialog.value = true;
    window.dispatchEvent(new CustomEvent("vocabulary-view-details"));
  };
  const openEditFromDetail = (word) => {
    showDetailDialog.value = false;
    selectedVocabulary.value = word;
    showFormDialog.value = true;
    window.dispatchEvent(new CustomEvent("vocabulary-edit-word"));
  };
  return {
    showFormDialog,
    selectedVocabulary,
    showDetailDialog,
    selectedVocabularyForDetail,
    openAddDialog,
    openEditDialog,
    onVocabularySaved,
    openDetailsDialog,
    openEditFromDetail
  };
}

function useTopicManager(debounceAutoSave) {
  const showTopicManager = ref(false);
  const vocabularyStore = useVocabularyStore();
  const modalStore = useModalStore();
  const openTopicManager = () => {
    showTopicManager.value = true;
    modalStore.setTopicManager(true);
  };
  watch(showTopicManager, (newValue) => {
    modalStore.setTopicManager(newValue);
  });
  const onTopicAdded = (topic) => {
    vocabularyStore.addCustomTopic(topic);
    debounceAutoSave();
    window.dispatchEvent(new CustomEvent("topics-updated"));
  };
  const onTopicUpdated = (oldKey, topic) => {
    vocabularyStore.allVocabularies.value.forEach((vocab) => {
      if (vocab.category === oldKey) {
        vocabularyStore.updateVocabulary(vocab.id, { category: topic.key });
      }
    });
    vocabularyStore.updateCustomTopic(oldKey, topic);
    debounceAutoSave();
    window.dispatchEvent(new CustomEvent("topics-updated"));
  };
  const onTopicDeleted = (key) => {
    vocabularyStore.deleteCustomTopic(key);
    debounceAutoSave();
    window.dispatchEvent(new CustomEvent("topics-updated"));
  };
  return {
    showTopicManager,
    openTopicManager,
    onTopicAdded,
    onTopicUpdated,
    onTopicDeleted
  };
}

const GOOGLE_CLIENT_ID = "330597757388-cdngesnvlcn7uiev2ptar27bu1gco9bt.apps.googleusercontent.com";
const GOOGLE_API_KEY = "AIzaSyDQONqrEK8FmTVj2ci8AM-DMmBKFMMZz20";
const DISCOVERY_DOC = "https://www.googleapis.com/discovery/v1/apis/drive/v3/rest";
const SCOPES = "https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email";
const isGoogleApiLoaded = ref(false);
const isGoogleSignedIn = ref(false);
const googleUser = ref(null);
const googleUserEmail = ref("");
const authError = ref("");
const GOOGLE_TOKEN_KEY = "vocabulary-google-token";
const GOOGLE_USER_KEY = "vocabulary-google-user";
const GOOGLE_USER_EMAIL_KEY = "vocabulary-google-user-email";
const GOOGLE_SIGNED_IN_KEY = "vocabulary-is-google-signed-in";
class GoogleDriveAuth {
  static instance;
  gapi = null;
  tokenClient = null;
  autoRefreshTimer = null;
  constructor() {
    this.loadSavedAuthState();
  }
  static getInstance() {
    if (!GoogleDriveAuth.instance) {
      GoogleDriveAuth.instance = new GoogleDriveAuth();
    }
    return GoogleDriveAuth.instance;
  }
  /**
   * Load saved authentication state from localStorage
   */
  loadSavedAuthState() {
    try {
      const savedToken = localStorage.getItem(GOOGLE_TOKEN_KEY);
      const savedUser = localStorage.getItem(GOOGLE_USER_KEY);
      const savedEmail = localStorage.getItem(GOOGLE_USER_EMAIL_KEY);
      const savedSignedIn = localStorage.getItem(GOOGLE_SIGNED_IN_KEY);
      if (savedToken && savedUser && savedSignedIn === "true") {
        console.log("📂 Loading saved Google authentication state...");
        const tokenData = JSON.parse(savedToken);
        const userData = JSON.parse(savedUser);
        const tokenAge = Date.now() - (tokenData.timestamp || 0);
        const isTokenExpired = tokenAge > 90 * 24 * 60 * 60 * 1e3;
        googleUser.value = userData;
        googleUserEmail.value = savedEmail || "";
        isGoogleSignedIn.value = true;
        if (isTokenExpired) {
          console.log("⏰ Saved Google token expired, will attempt silent refresh later");
        } else {
          console.log("✅ Google authentication state restored from localStorage");
        }
      } else {
        console.log("ℹ️ No saved Google authentication state found");
      }
    } catch (error) {
      console.error("❌ Error loading saved auth state:", error);
    }
  }
  /**
   * Save authentication state to localStorage
   */
  saveAuthState(token, user, email) {
    try {
      localStorage.setItem(GOOGLE_TOKEN_KEY, JSON.stringify({
        access_token: token.access_token,
        timestamp: Date.now()
      }));
      localStorage.setItem(GOOGLE_USER_KEY, JSON.stringify(user));
      localStorage.setItem(GOOGLE_SIGNED_IN_KEY, "true");
      if (email) {
        localStorage.setItem(GOOGLE_USER_EMAIL_KEY, email);
      }
      console.log("💾 Google auth state saved to localStorage");
    } catch (error) {
      console.error("❌ Error saving auth state:", error);
    }
  }
  /**
   * Clear saved authentication state from localStorage
   */
  clearSavedAuthState() {
    try {
      localStorage.removeItem(GOOGLE_TOKEN_KEY);
      localStorage.removeItem(GOOGLE_USER_KEY);
      localStorage.removeItem(GOOGLE_USER_EMAIL_KEY);
      localStorage.removeItem(GOOGLE_SIGNED_IN_KEY);
      console.log("🗑️ Google auth state cleared from localStorage");
    } catch (error) {
      console.error("❌ Error clearing auth state:", error);
    }
  }
  /**
   * Initialize Google APIs
   */
  async initialize() {
    if (isGoogleApiLoaded.value && this.tokenClient && this.gapi) {
      console.log("Google APIs already initialized");
      return;
    }
    try {
      console.log("🚀 Initializing Google APIs...");
      authError.value = "";
      await this.loadGoogleScripts();
      await Promise.all([
        this.initializeGapi(),
        this.initializeGIS()
      ]);
      if (!this.tokenClient || !this.gapi) {
        throw new Error("Google APIs initialization incomplete");
      }
      isGoogleApiLoaded.value = true;
      console.log("✅ Google APIs initialized successfully");
      await this.restoreTokenToGapi();
      if (isGoogleSignedIn.value) {
        this.startAutoRefresh();
        this.attachLifecycleListeners();
      }
    } catch (error) {
      console.error("❌ Failed to initialize Google APIs:", error);
      authError.value = "Failed to initialize Google APIs";
      isGoogleApiLoaded.value = false;
      throw error;
    }
  }
  /**
   * Restore saved token to gapi client
   */
  async restoreTokenToGapi() {
    try {
      const savedToken = localStorage.getItem(GOOGLE_TOKEN_KEY);
      if (savedToken && this.gapi && isGoogleSignedIn.value) {
        const tokenData = JSON.parse(savedToken);
        const tokenAge = Date.now() - (tokenData.timestamp || 0);
        const isTokenExpired = tokenAge > 90 * 24 * 60 * 60 * 1e3;
        if (!isTokenExpired) {
          console.log("🔑 Restoring token to GAPI client...");
          this.gapi.client.setToken({ access_token: tokenData.access_token });
          console.log("✅ Token restored to GAPI client");
          await this.verifyTokenValidity();
        } else {
          console.log("⏰ Token expired during restoration, attempting silent refresh...");
          const refreshSuccess = await this.attemptSilentRefresh();
          if (!refreshSuccess) {
            console.log("⚠️ Silent refresh failed during restoration. Keeping saved login state.");
            authError.value = "Token expired; will require refresh on next action";
          }
        }
      }
    } catch (error) {
      console.error("❌ Error restoring token to GAPI:", error);
      authError.value = "Failed to restore authentication";
    }
  }
  /**
   * Load Google API scripts dynamically
   */
  async loadGoogleScripts() {
    const loadScript = (src) => {
      return new Promise((resolve, reject) => {
        const existingScript = document.querySelector(`script[src="${src}"]`);
        if (existingScript && window.gapi && window.google) {
          resolve();
          return;
        }
        const script = document.createElement("script");
        script.src = src;
        script.async = true;
        script.defer = true;
        script.onload = () => {
          console.log(`✅ Script loaded: ${src}`);
          resolve();
        };
        script.onerror = () => {
          console.error(`❌ Failed to load script: ${src}`);
          reject(new Error(`Failed to load script: ${src}`));
        };
        document.head.appendChild(script);
      });
    };
    try {
      await Promise.all([
        loadScript("https://apis.google.com/js/api.js"),
        loadScript("https://accounts.google.com/gsi/client")
      ]);
      await new Promise((resolve) => setTimeout(resolve, 500));
      if (!window.gapi) {
        throw new Error("Google API (gapi) not loaded");
      }
      if (!window.google?.accounts) {
        throw new Error("Google Identity Services not loaded");
      }
      console.log("📚 Google scripts loaded and verified");
    } catch (error) {
      console.error("❌ Error loading Google scripts:", error);
      throw error;
    }
  }
  /**
   * Initialize Google API client
   */
  async initializeGapi() {
    return new Promise((resolve, reject) => {
      window.gapi.load("client", async () => {
        try {
          await window.gapi.client.init({
            apiKey: GOOGLE_API_KEY,
            discoveryDocs: [DISCOVERY_DOC]
          });
          this.gapi = window.gapi;
          console.log("✅ GAPI client initialized");
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    });
  }
  /**
   * Initialize Google Identity Services
   */
  async initializeGIS() {
    return new Promise((resolve, reject) => {
      try {
        this.tokenClient = window.google.accounts.oauth2.initTokenClient({
          client_id: GOOGLE_CLIENT_ID,
          scope: SCOPES,
          callback: (response) => {
            if (response.error) {
              console.error("❌ Token client error:", response.error);
              authError.value = response.error_description || "Authentication failed";
              isGoogleSignedIn.value = false;
            } else {
              console.log("✅ Token received successfully");
              this.handleAuthSuccess(response);
            }
          }
        });
        console.log("✅ Google Identity Services initialized");
        resolve();
      } catch (error) {
        reject(error);
      }
    });
  }
  /**
   * Sign in to Google account
   */
  async signIn() {
    try {
      console.log("🔐 Initiating Google sign-in...");
      if (!this.tokenClient || !isGoogleApiLoaded.value) {
        console.log("📡 Auto-initializing Google APIs for sign-in...");
        await this.initialize();
      }
      if (!this.tokenClient) {
        throw new Error("Failed to initialize Google Identity Services");
      }
      authError.value = "";
      this.tokenClient.requestAccessToken({ prompt: "consent" });
      return new Promise((resolve) => {
        const timeoutId = setTimeout(() => {
          console.warn("⚠️ Google sign-in timeout");
          authError.value = "Sign-in timeout";
          resolve(false);
        }, 3e4);
        const checkAuth = () => {
          if (isGoogleSignedIn.value) {
            clearTimeout(timeoutId);
            this.startAutoRefresh();
            this.attachLifecycleListeners();
            resolve(true);
          } else if (authError.value) {
            clearTimeout(timeoutId);
            resolve(false);
          } else {
            setTimeout(checkAuth, 100);
          }
        };
        checkAuth();
      });
    } catch (error) {
      console.error("❌ Sign-in failed:", error);
      authError.value = "Sign-in failed";
      return false;
    }
  }
  /**
   * Sign out from Google account
   */
  async signOut() {
    try {
      if (this.gapi?.client?.getToken()) {
        window.google.accounts.oauth2.revoke(this.gapi.client.getToken().access_token);
      }
      isGoogleSignedIn.value = false;
      googleUser.value = null;
      googleUserEmail.value = "";
      authError.value = "";
      this.stopAutoRefresh();
      this.detachLifecycleListeners();
      this.clearSavedAuthState();
      console.log("✅ Signed out successfully and cleared saved state");
    } catch (error) {
      console.error("❌ Sign-out failed:", error);
      throw error;
    }
  }
  /**
   * Handle successful authentication
   */
  async handleAuthSuccess(response) {
    googleUser.value = response;
    isGoogleSignedIn.value = true;
    this.gapi.client.setToken({ access_token: response.access_token });
    const userEmail = await this.fetchUserEmail();
    console.log("🔍 Fetched user email:", userEmail);
    if (userEmail) {
      googleUserEmail.value = userEmail;
      console.log("✅ Email set to reactive state:", googleUserEmail.value);
    } else {
      console.log("❌ No email received from API");
    }
    this.saveAuthState({ access_token: response.access_token }, response, userEmail || void 0);
    console.log("🔑 Authentication successful and persisted");
    this.startAutoRefresh();
  }
  /**
   * Verify token validity with a test API call
   */
  async verifyTokenValidity() {
    try {
      if (!this.gapi?.client) return false;
      const response = await this.gapi.client.request({
        path: "https://www.googleapis.com/drive/v3/about?fields=user"
      });
      if (response.status === 200) {
        console.log("✅ Token verification successful");
        return true;
      } else {
        console.log("❌ Token verification failed:", response.status);
        return false;
      }
    } catch (error) {
      console.log("❌ Token verification error:", error);
      return false;
    }
  }
  /**
   * Attempt silent token refresh
   */
  async attemptSilentRefresh() {
    try {
      if (!this.tokenClient) {
        console.log("❌ No token client available for refresh");
        return false;
      }
      console.log("🔄 Attempting silent token refresh...");
      return new Promise((resolve) => {
        const originalCallback = this.tokenClient.callback;
        let timeoutId;
        this.tokenClient.callback = (response) => {
          this.tokenClient.callback = originalCallback;
          if (timeoutId !== void 0) {
            clearTimeout(timeoutId);
          }
          if (response.error) {
            console.log("❌ Silent refresh failed:", response.error);
            if (response.error === "interaction_required" || response.error === "login_required") {
              console.log("⚠️ Silent refresh requires user interaction, skipping");
            }
            resolve(false);
          } else {
            console.log("✅ Silent refresh successful");
            this.handleAuthSuccess(response);
            resolve(true);
          }
        };
        try {
          this.tokenClient.requestAccessToken({ prompt: "none" });
          timeoutId = setTimeout(() => {
            this.tokenClient.callback = originalCallback;
            console.log("⏰ Silent refresh timeout");
            resolve(false);
          }, 5e3);
        } catch (error) {
          this.tokenClient.callback = originalCallback;
          if (timeoutId !== void 0) {
            clearTimeout(timeoutId);
          }
          console.log("❌ Silent refresh request failed:", error);
          resolve(false);
        }
      });
    } catch (error) {
      console.error("❌ Silent refresh error:", error);
      return false;
    }
  }
  /**
   * Get current access token with automatic refresh if needed
   */
  async getAccessToken() {
    try {
      let currentToken = this.gapi?.client?.getToken()?.access_token;
      if (!currentToken) {
        console.log("❌ No current token available, trying silent refresh...");
        const refreshed = await this.attemptSilentRefresh();
        if (!refreshed) {
          return null;
        }
        currentToken = this.gapi?.client?.getToken()?.access_token;
      }
      const savedToken = localStorage.getItem(GOOGLE_TOKEN_KEY);
      if (savedToken) {
        const tokenData = JSON.parse(savedToken);
        const tokenAge = Date.now() - (tokenData.timestamp || 0);
        const isNearExpiry = tokenAge > 90 * 24 * 60 * 60 * 1e3;
        if (isNearExpiry) {
          console.log("🔄 Token near expiry, attempting refresh...");
          const refreshSuccess = await this.attemptSilentRefresh();
          if (refreshSuccess) {
            return this.gapi?.client?.getToken()?.access_token || null;
          } else {
            console.log("⚠️ Token refresh failed, keeping saved login state");
            return null;
          }
        }
      }
      return currentToken;
    } catch (error) {
      console.error("❌ Error getting access token:", error);
      return null;
    }
  }
  /**
   * Check if user is signed in with token validation
   */
  async isSignedIn() {
    if (!isGoogleSignedIn.value) {
      return false;
    }
    const token = await this.getAccessToken();
    return token !== null || isGoogleSignedIn.value;
  }
  /**
   * Synchronous check for signed in state (for compatibility)
   */
  isSignedInSync() {
    return isGoogleSignedIn.value;
  }
  /**
   * Get current authentication error
   */
  getAuthError() {
    return authError.value;
  }
  /**
   * Auto refresh helpers
   */
  startAutoRefresh() {
    this.stopAutoRefresh();
    this.autoRefreshTimer = window.setInterval(async () => {
      if (!isGoogleSignedIn.value) return;
      const needsRefresh = await this.shouldRefreshToken();
      if (needsRefresh) {
        console.log("⏱️ Auto-refresh timer triggered - token needs refresh");
        await this.attemptSilentRefresh();
      } else {
        console.log("⏱️ Auto-refresh timer checked - token still valid");
      }
    }, 90 * 24 * 60 * 60 * 1e3);
    console.log("🕒 Auto-refresh timer started");
  }
  stopAutoRefresh() {
    if (this.autoRefreshTimer) {
      clearInterval(this.autoRefreshTimer);
      this.autoRefreshTimer = null;
      console.log("🛑 Auto-refresh timer stopped");
    }
  }
  visibilityHandler = async () => {
    if (document.visibilityState === "visible" && isGoogleSignedIn.value) {
      const needsRefresh = await this.shouldRefreshToken();
      if (needsRefresh) {
        console.log("👀 Page visible, token needs refresh");
        await this.attemptSilentRefresh();
      } else {
        console.log("👀 Page visible, token still valid");
      }
    }
  };
  onlineHandler = async () => {
    if (navigator.onLine && isGoogleSignedIn.value) {
      const needsRefresh = await this.shouldRefreshToken();
      if (needsRefresh) {
        console.log("🌐 Back online, token needs refresh");
        await this.attemptSilentRefresh();
      } else {
        console.log("🌐 Back online, token still valid");
      }
    }
  };
  attachLifecycleListeners() {
    document.addEventListener("visibilitychange", this.visibilityHandler);
    window.addEventListener("online", this.onlineHandler);
    console.log("🔗 Lifecycle listeners attached");
  }
  detachLifecycleListeners() {
    document.removeEventListener("visibilitychange", this.visibilityHandler);
    window.removeEventListener("online", this.onlineHandler);
    console.log("🔌 Lifecycle listeners detached");
  }
  /**
   * Fetch user email from Google API
   */
  async fetchUserEmail() {
    try {
      if (!this.gapi?.client) {
        console.log("❌ No GAPI client available for fetching user email");
        return null;
      }
      const response = await this.gapi.client.request({
        path: "https://www.googleapis.com/oauth2/v2/userinfo"
      });
      if (response.status === 200 && response.result?.email) {
        console.log("✅ User email fetched successfully");
        return response.result.email;
      } else {
        console.log("❌ Failed to fetch user email from API response");
        return null;
      }
    } catch (error) {
      console.error("❌ Error fetching user email:", error);
      return null;
    }
  }
  /**
   * Get current user email
   */
  async getUserEmail() {
    return googleUserEmail.value;
  }
  /**
   * Check if token actually needs refreshing
   */
  async shouldRefreshToken() {
    try {
      const currentToken = this.gapi?.client?.getToken()?.access_token;
      if (!currentToken) {
        console.log("🔍 No current token, refresh needed");
        return true;
      }
      const savedToken = localStorage.getItem(GOOGLE_TOKEN_KEY);
      if (!savedToken) {
        console.log("🔍 No saved token data, refresh needed");
        return true;
      }
      const tokenData = JSON.parse(savedToken);
      const tokenAge = Date.now() - (tokenData.timestamp || 0);
      const isNearExpiry = tokenAge > 90 * 24 * 60 * 60 * 1e3;
      if (isNearExpiry) {
        console.log("🔍 Token is near expiry, refresh needed");
        return true;
      }
      console.log("🔍 Token is still valid, no refresh needed");
      return false;
    } catch (error) {
      console.error("❌ Error checking token refresh need:", error);
      return false;
    }
  }
}
const useGoogleDriveAuth = () => {
  const authService = GoogleDriveAuth.getInstance();
  return {
    // Reactive states
    isGoogleApiLoaded: computed(() => isGoogleApiLoaded.value),
    isGoogleSignedIn: computed(() => isGoogleSignedIn.value),
    googleUser: computed(() => googleUser.value),
    googleUserEmail: computed(() => googleUserEmail.value),
    authError: computed(() => authError.value),
    // Methods
    initialize: () => authService.initialize(),
    signIn: () => authService.signIn(),
    signOut: () => authService.signOut(),
    isSignedIn: () => authService.isSignedIn(),
    isSignedInSync: () => authService.isSignedInSync(),
    getAccessToken: () => authService.getAccessToken(),
    getUserEmail: () => authService.getUserEmail()
  };
};
const googleDriveAuth = GoogleDriveAuth.getInstance();

class GoogleDriveApi {
  static instance;
  VOCABULARY_FOLDER_NAME = "Vocabulary Backup";
  BACKUP_FILE_NAME = "vocabulary-auto-backup.json";
  vocabularyFolderId = null;
  constructor() {
  }
  static getInstance() {
    if (!GoogleDriveApi.instance) {
      GoogleDriveApi.instance = new GoogleDriveApi();
    }
    return GoogleDriveApi.instance;
  }
  /**
   * Ensure user is authenticated before making API calls
   */
  async ensureAuthenticated() {
    if (!await googleDriveAuth.isSignedIn()) {
      console.log("⚠️ User not signed in, attempting to sign in...");
      return await googleDriveAuth.signIn();
    }
    return true;
  }
  /**
   * Handle 401 errors by refreshing token and retrying
   */
  async handleAuthError(operation) {
    try {
      const response = await operation();
      if (response.status === 401) {
        console.log("🔄 Received 401 error, attempting token refresh...");
        const newToken = await googleDriveAuth.getAccessToken();
        if (!newToken) {
          throw new Error("Unable to refresh authentication token");
        }
        console.log("♻️ Retrying operation with refreshed token...");
        const retryResponse = await operation();
        if (retryResponse.status === 401) {
          throw new Error("Authentication failed even after token refresh");
        }
        return retryResponse;
      }
      return response;
    } catch (error) {
      console.error("❌ Auth error handling failed:", error);
      throw error;
    }
  }
  /**
   * Find or create the vocabulary backup folder
   */
  async findOrCreateVocabularyFolder() {
    try {
      if (!await this.ensureAuthenticated()) {
        throw new Error("Authentication failed");
      }
      console.log("📁 Finding or creating vocabulary backup folder...");
      const response = await window.gapi.client.drive.files.list({
        q: `name='${this.VOCABULARY_FOLDER_NAME}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        spaces: "drive",
        fields: "files(id, name)"
      });
      if (response.result.files && response.result.files.length > 0) {
        this.vocabularyFolderId = response.result.files[0].id;
        console.log("✅ Found existing vocabulary folder:", this.vocabularyFolderId);
        return this.vocabularyFolderId;
      }
      const createResponse = await window.gapi.client.drive.files.create({
        resource: {
          name: this.VOCABULARY_FOLDER_NAME,
          mimeType: "application/vnd.google-apps.folder",
          description: "Automatically created folder for vocabulary backup files"
        },
        fields: "id"
      });
      this.vocabularyFolderId = createResponse.result.id;
      console.log("✅ Created new vocabulary folder:", this.vocabularyFolderId);
      return this.vocabularyFolderId;
    } catch (error) {
      console.error("❌ Failed to find or create vocabulary folder:", error);
      return null;
    }
  }
  /**
   * Upload vocabulary data to Google Drive
   */
  async uploadVocabularyData(data) {
    let dataSizeKB = 0;
    try {
      if (!await this.ensureAuthenticated()) {
        throw new Error("Authentication failed");
      }
      console.log("📤 Starting vocabulary data upload to Google Drive...");
      const folderId = await this.findOrCreateVocabularyFolder();
      if (!folderId) {
        throw new Error("Failed to create vocabulary folder");
      }
      const existingFile = await this.findVocabularyBackupFile();
      const jsonData = JSON.stringify(data, null, 2);
      dataSizeKB = Math.round(jsonData.length / 1024);
      console.log(`📊 Preparing upload: ${dataSizeKB}KB of vocabulary data`);
      const blob = new Blob([jsonData], { type: "application/json" });
      let response;
      if (existingFile) {
        console.log("🔄 Updating existing backup file:", existingFile.id);
        const createUpdateRequest = async () => {
          const accessToken = await googleDriveAuth.getAccessToken();
          if (!accessToken) {
            throw new Error("No access token available");
          }
          console.log(`🔄 Starting update request for ${dataSizeKB}KB data...`);
          const form = new FormData();
          form.append("metadata", new Blob([JSON.stringify({
            name: this.BACKUP_FILE_NAME,
            description: `Vocabulary backup - Updated: ${(/* @__PURE__ */ new Date()).toISOString()}`
          })], { type: "application/json" }));
          form.append("file", blob);
          const controller = new AbortController();
          const timeoutMs = Math.max(6e4, Math.min(6e5, 6e4 + dataSizeKB * 60));
          const timeoutMinutes = Math.round(timeoutMs / 6e4);
          console.log(`⏱️ Setting ${timeoutMinutes} minute timeout for ${dataSizeKB}KB file`);
          const timeoutId = setTimeout(() => {
            console.log(`⏰ Upload timeout after ${timeoutMinutes} minutes, aborting request...`);
            controller.abort();
          }, timeoutMs);
          try {
            const response2 = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${existingFile.id}?uploadType=multipart&fields=id,name,modifiedTime,size`, {
              method: "PATCH",
              headers: {
                "Authorization": `Bearer ${accessToken}`
              },
              body: form,
              signal: controller.signal
            });
            clearTimeout(timeoutId);
            console.log(`✅ Update request completed with status: ${response2.status}`);
            return response2;
          } catch (error) {
            clearTimeout(timeoutId);
            if (error.name === "AbortError") {
              throw new Error(`Upload timeout after ${timeoutMinutes} minutes for ${dataSizeKB}KB file`);
            }
            throw error;
          }
        };
        response = await this.handleAuthError(createUpdateRequest);
      } else {
        console.log("📄 Creating new backup file...");
        const createNewRequest = async () => {
          const accessToken = await googleDriveAuth.getAccessToken();
          if (!accessToken) {
            throw new Error("No access token available");
          }
          console.log(`📄 Starting new file creation for ${dataSizeKB}KB data...`);
          const form = new FormData();
          form.append("metadata", new Blob([JSON.stringify({
            name: this.BACKUP_FILE_NAME,
            parents: [folderId],
            description: `Vocabulary backup - Created: ${(/* @__PURE__ */ new Date()).toISOString()}`
          })], { type: "application/json" }));
          form.append("file", blob);
          const controller = new AbortController();
          const timeoutMs = Math.max(6e4, Math.min(6e5, 6e4 + dataSizeKB * 60));
          const timeoutMinutes = Math.round(timeoutMs / 6e4);
          console.log(`⏱️ Setting ${timeoutMinutes} minute timeout for ${dataSizeKB}KB file`);
          const timeoutId = setTimeout(() => {
            console.log(`⏰ Upload timeout after ${timeoutMinutes} minutes, aborting request...`);
            controller.abort();
          }, timeoutMs);
          try {
            const response2 = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name,modifiedTime,size", {
              method: "POST",
              headers: {
                "Authorization": `Bearer ${accessToken}`
              },
              body: form,
              signal: controller.signal
            });
            clearTimeout(timeoutId);
            console.log(`✅ New file creation completed with status: ${response2.status}`);
            return response2;
          } catch (error) {
            clearTimeout(timeoutId);
            if (error.name === "AbortError") {
              throw new Error(`Upload timeout after ${timeoutMinutes} minutes for ${dataSizeKB}KB file`);
            }
            throw error;
          }
        };
        response = await this.handleAuthError(createNewRequest);
      }
      console.log(`🔍 Checking response status: ${response.status}`);
      if (!response.ok) {
        const errorText = await response.text().catch(() => "Unknown error");
        console.error(`❌ HTTP error ${response.status} for ${dataSizeKB}KB upload:`, errorText);
        if (response.status === 401) {
          throw new Error("Authentication failed - please sign in to Google Drive again");
        } else if (response.status === 403) {
          throw new Error("Permission denied - please check Google Drive permissions");
        } else if (response.status === 413) {
          throw new Error(`File too large (${dataSizeKB}KB) - Google Drive limit exceeded`);
        } else if (response.status === 429) {
          throw new Error("Rate limit exceeded - please try again later");
        } else {
          throw new Error(`Upload failed with status ${response.status}: ${errorText}`);
        }
      }
      console.log("📥 Parsing response JSON...");
      const result = await response.json();
      console.log(`✅ Vocabulary data (${dataSizeKB}KB) uploaded successfully:`, {
        fileId: result.id,
        fileName: result.name,
        size: result.size,
        modifiedTime: result.modifiedTime
      });
      return {
        success: true,
        fileId: result.id
      };
    } catch (error) {
      const errorMessage = error.message;
      const sizeInfo = typeof dataSizeKB !== "undefined" ? `${dataSizeKB}KB` : "unknown size";
      console.error(`❌ Failed to upload vocabulary data (${sizeInfo}):`, {
        error: errorMessage,
        stack: error.stack
      });
      return {
        success: false,
        error: errorMessage
      };
    }
  }
  /**
   * Download vocabulary data from Google Drive
   */
  async downloadVocabularyData() {
    try {
      if (!await this.ensureAuthenticated()) {
        throw new Error("Authentication failed");
      }
      console.log("⬇️ Starting vocabulary data download from Google Drive...");
      const backupFile = await this.findVocabularyBackupFile();
      if (!backupFile) {
        return {
          success: false,
          error: "No vocabulary backup file found on Google Drive"
        };
      }
      console.log("📄 Found backup file:", backupFile.name, backupFile.id);
      const response = await window.gapi.client.drive.files.get({
        fileId: backupFile.id,
        alt: "media"
      });
      if (!response.body) {
        throw new Error("Empty response body");
      }
      const data = JSON.parse(response.body);
      console.log("✅ Vocabulary data downloaded successfully");
      return {
        success: true,
        data,
        lastModified: backupFile.modifiedTime
      };
    } catch (error) {
      console.error("❌ Failed to download vocabulary data:", error);
      return {
        success: false,
        error: error.message
      };
    }
  }
  /**
   * Find the vocabulary backup file in the vocabulary folder
   */
  async findVocabularyBackupFile() {
    try {
      const folderId = await this.findOrCreateVocabularyFolder();
      if (!folderId) return null;
      const response = await window.gapi.client.drive.files.list({
        q: `name='${this.BACKUP_FILE_NAME}' and parents in '${folderId}' and trashed=false`,
        spaces: "drive",
        fields: "files(id, name, modifiedTime, size, mimeType)"
      });
      if (response.result.files && response.result.files.length > 0) {
        return response.result.files[0];
      }
      return null;
    } catch (error) {
      console.error("❌ Failed to find vocabulary backup file:", error);
      return null;
    }
  }
  /**
   * Get vocabulary backup file info
   */
  async getVocabularyBackupInfo() {
    try {
      if (!await this.ensureAuthenticated()) {
        throw new Error("Authentication failed");
      }
      const backupFile = await this.findVocabularyBackupFile();
      return {
        exists: !!backupFile,
        file: backupFile || void 0
      };
    } catch (error) {
      return {
        exists: false,
        error: error.message
      };
    }
  }
  /**
   * Delete vocabulary backup file
   */
  async deleteVocabularyBackup() {
    try {
      if (!await this.ensureAuthenticated()) {
        throw new Error("Authentication failed");
      }
      const backupFile = await this.findVocabularyBackupFile();
      if (!backupFile) {
        return { success: true };
      }
      await window.gapi.client.drive.files.delete({
        fileId: backupFile.id
      });
      console.log("🗑️ Vocabulary backup file deleted successfully");
      return { success: true };
    } catch (error) {
      console.error("❌ Failed to delete vocabulary backup:", error);
      return {
        success: false,
        error: error.message
      };
    }
  }
  /**
   * Check if there are any conflicts between local and remote data
   */
  async checkForConflicts(localData) {
    try {
      const downloadResult = await this.downloadVocabularyData();
      if (!downloadResult.success) {
        return {
          hasConflicts: false,
          error: downloadResult.error
        };
      }
      const localModified = localData.exportDate || (/* @__PURE__ */ new Date()).toISOString();
      const remoteModified = downloadResult.lastModified;
      const hasConflicts = new Date(remoteModified) > new Date(localModified);
      return {
        hasConflicts,
        localModified,
        remoteModified,
        remoteData: downloadResult.data
      };
    } catch (error) {
      return {
        hasConflicts: false,
        error: error.message
      };
    }
  }
}
const useGoogleDriveApi = () => {
  const driveApi = GoogleDriveApi.getInstance();
  return {
    uploadVocabularyData: (data) => driveApi.uploadVocabularyData(data),
    downloadVocabularyData: () => driveApi.downloadVocabularyData(),
    getVocabularyBackupInfo: () => driveApi.getVocabularyBackupInfo(),
    deleteVocabularyBackup: () => driveApi.deleteVocabularyBackup(),
    checkForConflicts: (localData) => driveApi.checkForConflicts(localData)
  };
};
GoogleDriveApi.getInstance();

const ConfirmToast$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ConfirmToast),true              ?void 0:void 0));
function useVocabularySaving() {
  const { t } = useI18n();
  const vocabularyStore = useVocabularyStore();
  const toast = useToast();
  const googleAuth = useGoogleDriveAuth();
  const googleDriveApi = useGoogleDriveApi();
  const autoSaveEnabled = ref(true);
  const isSaving = ref(false);
  const lastSaveTime = ref("");
  const saveStatus = ref("idle");
  const autoSaveFileHandle = ref(null);
  const hasAutoSaveFile = ref(false);
  const hasGoogleDriveFile = ref(false);
  const storageType = ref("local");
  const autoSaveFileName = "vocabulary-auto-backup.json";
  let autoSaveTimer = null;
  let debounceTimer = null;
  const autoSaveFilePath = ref("");
  const DB_NAME = "vocabulary-file-handles";
  const DB_VERSION = 1;
  const STORE_NAME = "file-handles";
  const FILE_HANDLE_KEY = "auto-save-file-handle";
  const openDB = () => {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          db.createObjectStore(STORE_NAME);
        }
      };
    });
  };
  const saveFileHandleToIDB = async (fileHandle) => {
    try {
      const db = await openDB();
      const transaction = db.transaction([STORE_NAME], "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      await new Promise((resolve, reject) => {
        const request = store.put(fileHandle, FILE_HANDLE_KEY);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve();
      });
      console.log("File handle saved to IndexedDB");
    } catch (error) {
      console.error("Error saving file handle to IndexedDB:", error);
    }
  };
  const loadFileHandleFromIDB = async () => {
    try {
      const db = await openDB();
      const transaction = db.transaction([STORE_NAME], "readonly");
      const store = transaction.objectStore(STORE_NAME);
      return new Promise((resolve, reject) => {
        const request = store.get(FILE_HANDLE_KEY);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result || null);
      });
    } catch (error) {
      console.error("Error loading file handle from IndexedDB:", error);
      return null;
    }
  };
  const clearFileHandleFromIDB = async () => {
    try {
      const db = await openDB();
      const transaction = db.transaction([STORE_NAME], "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      await new Promise((resolve, reject) => {
        const request = store.delete(FILE_HANDLE_KEY);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve();
      });
      console.log("File handle cleared from IndexedDB");
    } catch (error) {
      console.error("Error clearing file handle from IndexedDB:", error);
    }
  };
  const getStoredValue = (key, defaultValue) => {
    try {
      const stored = localStorage.getItem(key);
      return stored !== null ? JSON.parse(stored) : defaultValue;
    } catch {
      return defaultValue;
    }
  };
  const setStoredValue = (key, value) => {
    localStorage.setItem(key, JSON.stringify(value));
  };
  autoSaveEnabled.value = getStoredValue("vocabulary-auto-save-enabled", true);
  hasAutoSaveFile.value = getStoredValue("vocabulary-has-auto-save-file", false);
  hasGoogleDriveFile.value = getStoredValue("vocabulary-has-google-drive-file", false);
  storageType.value = getStoredValue("vocabulary-storage-type", "local");
  lastSaveTime.value = getStoredValue("vocabulary-last-save-time", "");
  const initializeAutoSave = async () => {
    console.log("🔧 Initializing auto-save, hasAutoSaveFile:", hasAutoSaveFile.value);
    if (hasAutoSaveFile.value && "showSaveFilePicker" in window) {
      try {
        console.log("🔍 Attempting to restore file handle from IndexedDB...");
        const savedFileHandle = await loadFileHandleFromIDB();
        if (savedFileHandle) {
          console.log("✅ Found saved file handle in IndexedDB");
          try {
            const opts = { mode: "readwrite" };
            const permission = await savedFileHandle.queryPermission(opts);
            console.log("🔐 File handle permission:", permission);
            if (permission === "granted" || permission === "prompt") {
              autoSaveFileHandle.value = savedFileHandle;
              console.log("✅ File handle restored to autoSaveFileHandle");
              try {
                const fileProps = await savedFileHandle.getFile();
                autoSaveFilePath.value = fileProps.name;
                console.log("📁 File handle restored successfully:", fileProps.name);
                if (permission === "prompt") {
                  console.log("🔄 Requesting permission for file handle...");
                  await savedFileHandle.requestPermission(opts);
                }
              } catch (e) {
                console.log("⚠️ Could not get file properties, but handle seems valid:", e);
              }
            } else {
              console.log("❌ File handle permission denied, clearing stored handle");
              await clearFileHandleFromIDB();
              hasAutoSaveFile.value = false;
              setStoredValue("vocabulary-has-auto-save-file", false);
            }
          } catch (error) {
            console.log("❌ Saved file handle is invalid, clearing:", error);
            await clearFileHandleFromIDB();
            hasAutoSaveFile.value = false;
            setStoredValue("vocabulary-has-auto-save-file", false);
          }
        } else {
          console.log("❌ No file handle found in IndexedDB");
          hasAutoSaveFile.value = false;
          setStoredValue("vocabulary-has-auto-save-file", false);
        }
      } catch (error) {
        console.error("❌ Error initializing auto-save:", error);
        hasAutoSaveFile.value = false;
        setStoredValue("vocabulary-has-auto-save-file", false);
      }
    } else {
      console.log("ℹ️ Auto-save not enabled or File System API not supported");
    }
  };
  const saveToFileSystem = async (data) => {
    try {
      const fileHandle = await window.showSaveFilePicker({
        suggestedName: `vocabulary-backup-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`,
        types: [{
          description: "JSON files",
          accept: { "application/json": [".json"] }
        }]
      });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(data, null, 2));
      await writable.close();
      autoSaveFileHandle.value = fileHandle;
      hasAutoSaveFile.value = true;
      setStoredValue("vocabulary-has-auto-save-file", true);
      await saveFileHandleToIDB(fileHandle);
    } catch (error) {
      if (error.name !== "AbortError") {
        await downloadJsonFile(data);
      }
    }
  };
  const downloadJsonFile = async (data) => {
    const jsonString = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonString], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `vocabulary-backup-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };
  const getVocabularyData = () => {
    const getGroupTopics = () => {
      try {
        const stored = localStorage.getItem("vocabulary-group-topics");
        return stored ? JSON.parse(stored) : {};
      } catch (error) {
        return {};
      }
    };
    const getVocabularyNotes = () => {
      try {
        const stored = localStorage.getItem("vocabulary-notes");
        return stored ? JSON.parse(stored) : {};
      } catch (error) {
        return {};
      }
    };
    const getMarkedWords = () => {
      try {
        const stored = localStorage.getItem("vocabulary-marked-words");
        return stored ? JSON.parse(stored) : {};
      } catch (error) {
        return {};
      }
    };
    const getGrammarRules = () => {
      try {
        const stored = localStorage.getItem("grammar-rules");
        return stored ? JSON.parse(stored) : [];
      } catch (error) {
        return [];
      }
    };
    const getPracticeHistory = () => {
      try {
        const stored = localStorage.getItem("flashcard-practice-history");
        return stored ? JSON.parse(stored) : [];
      } catch (error) {
        return [];
      }
    };
    const getCategoryName = (categoryKey) => {
      const customTopics = getCustomTopics();
      const customTopic = customTopics.find((topic) => topic.key === categoryKey);
      if (customTopic) {
        return customTopic.en;
      }
      const builtInCategories = {
        "technology": "Technology",
        "business": "Business",
        "travel": "Travel",
        "food": "Food",
        "health": "Health",
        "education": "Education",
        "sports": "Sports",
        "entertainment": "Entertainment",
        "science": "Science",
        "art": "Art",
        "music": "Music",
        "literature": "Literature",
        "politics": "Politics",
        "environment": "Environment",
        "fashion": "Fashion",
        "finance": "Finance"
      };
      return builtInCategories[categoryKey] || categoryKey.charAt(0).toUpperCase() + categoryKey.slice(1);
    };
    const enhancedVocabularies = vocabularyStore.allVocabularies.value.map((vocab) => ({
      ...vocab,
      categoryName: getCategoryName(vocab.category)
      // Add category name alongside category key
    }));
    return {
      vocabularies: enhancedVocabularies,
      customTopics: vocabularyStore.customTopics.value,
      groupTopics: getGroupTopics(),
      vocabularyNotes: getVocabularyNotes(),
      markedWords: getMarkedWords(),
      grammarRules: getGrammarRules(),
      // Include grammar rules in export
      practiceHistory: getPracticeHistory(),
      // Include practice history in export
      accordionState: JSON.parse(localStorage.getItem("vocabulary-accordion-state") || "{}"),
      useGrouping: JSON.parse(localStorage.getItem("vocabulary-use-grouping") || "false"),
      // Save grouping state
      exportDate: (/* @__PURE__ */ new Date()).toISOString(),
      version: "1.6",
      // Increment version to indicate practice history support
      totalCount: vocabularyStore.totalCount.value
    };
  };
  const manualSave = async () => {
    if (isSaving.value) return;
    isSaving.value = true;
    saveStatus.value = "saving";
    try {
      const vocabularyData = getVocabularyData();
      if ("showSaveFilePicker" in window) {
        await saveToFileSystem(vocabularyData);
      } else {
        await downloadJsonFile(vocabularyData);
      }
      vocabularyStore.saveToLocalStorage();
      const now = (/* @__PURE__ */ new Date()).toLocaleString("vi-VN");
      lastSaveTime.value = now;
      setStoredValue("vocabulary-last-save-time", now);
      saveStatus.value = "success";
      setTimeout(() => {
        if (saveStatus.value === "success") saveStatus.value = "idle";
      }, 2e3);
    } catch (error) {
      saveStatus.value = "error";
      setTimeout(() => {
        if (saveStatus.value === "error") saveStatus.value = "idle";
      }, 3e3);
    } finally {
      isSaving.value = false;
    }
  };
  const performAutoSave = async () => {
    if (!autoSaveEnabled.value) return;
    try {
      saveStatus.value = "saving";
      const vocabularyData = getVocabularyData();
      vocabularyStore.saveToLocalStorage();
      let saveSuccess = false;
      if (storageType.value === "google-drive") {
        saveSuccess = await tryAutoSaveToGoogleDrive(vocabularyData);
      } else if (storageType.value === "local" && hasAutoSaveFile.value) {
        saveSuccess = await tryAutoSaveToFile(vocabularyData);
      } else {
        saveSuccess = true;
      }
      const now = (/* @__PURE__ */ new Date()).toLocaleString("vi-VN");
      lastSaveTime.value = now;
      setStoredValue("vocabulary-last-save-time", now);
      if (saveSuccess) {
        saveStatus.value = "success";
        console.log("✅ Auto-save completed successfully");
        setTimeout(() => {
          if (saveStatus.value === "success") {
            saveStatus.value = "idle";
          }
        }, 1e3);
      } else {
        saveStatus.value = "error";
        console.error("❌ Auto-save failed");
        setTimeout(() => {
          if (saveStatus.value === "error") {
            saveStatus.value = "idle";
          }
        }, 2e3);
      }
      return saveSuccess;
    } catch (error) {
      console.error("Auto-save error:", error);
      saveStatus.value = "error";
      setTimeout(() => {
        if (saveStatus.value === "error") {
          saveStatus.value = "idle";
        }
      }, 2e3);
      return false;
    }
  };
  const tryAutoSaveToFile = async (data) => {
    if (!("showSaveFilePicker" in window)) {
      console.log("Browser doesn't support File System Access API");
      return false;
    }
    if (!autoSaveFileHandle.value) {
      console.log("No auto-save file handle available");
      return false;
    }
    try {
      console.log("Attempting to auto-save to file...", autoSaveFilePath.value);
      const opts = { mode: "readwrite" };
      const permission = await autoSaveFileHandle.value.queryPermission(opts);
      if (permission !== "granted") {
        console.log("Requesting permission to write to file...");
        const newPermission = await autoSaveFileHandle.value.requestPermission(opts);
        if (newPermission !== "granted") {
          console.error("Permission to write to file denied");
          toast.error(t("vocabulary.save.errors.permissionDenied", "Permission denied"));
          return false;
        }
      }
      console.log("Creating writable stream...");
      const writable = await autoSaveFileHandle.value.createWritable();
      const jsonString = JSON.stringify(data, null, 2);
      console.log(`Writing ${jsonString.length} characters to file...`);
      await writable.write(jsonString);
      console.log("Closing writable stream...");
      await writable.close();
      console.log("Auto-save to file completed successfully:", autoSaveFilePath.value);
      const now = (/* @__PURE__ */ new Date()).toLocaleString("vi-VN");
      lastSaveTime.value = now;
      setStoredValue("vocabulary-last-save-time", now);
      return true;
    } catch (error) {
      console.error("Error auto-saving to file:", error);
      if (error instanceof DOMException && error.name === "NotAllowedError") {
        toast.error(t("vocabulary.save.errors.permissionDenied", "Permission denied"));
      } else {
        toast.error(t("vocabulary.save.errors.autoSaveFileFailed", "Auto save file failed"));
      }
      if (!(error instanceof DOMException && error.name === "NotAllowedError")) {
        autoSaveFileHandle.value = null;
        hasAutoSaveFile.value = false;
        setStoredValue("vocabulary-has-auto-save-file", false);
        await clearFileHandleFromIDB();
      }
      return false;
    }
  };
  const debounceAutoSave = () => {
    if (!autoSaveEnabled.value) {
      console.log("Auto-save is disabled, skipping debounce");
      return;
    }
    console.log("Setting up debounce auto-save timer...");
    if (debounceTimer) {
      console.log("Clearing existing debounce timer");
      clearTimeout(debounceTimer);
      debounceTimer = null;
    }
    console.log("Creating new debounce timer");
    debounceTimer = setTimeout(async () => {
      console.log("Debounce timer triggered, performing auto-save...");
      if (storageType.value === "local" && !hasAutoSaveFile.value) {
        console.log("No auto-save file selected, saving to localStorage only");
        vocabularyStore.saveToLocalStorage();
        return;
      }
      if (storageType.value === "google-drive") {
        const isSignedIn = await googleAuth.isSignedIn();
        if (!isSignedIn) {
          console.log("Google Drive selected but not signed in or token invalid, saving to localStorage only");
          vocabularyStore.saveToLocalStorage();
          return;
        }
      }
      const result = await performAutoSave();
      console.log("Auto-save result:", result ? "Success" : "Failed");
      if (!result) {
        const retryMessage = storageType.value === "google-drive" ? t("vocabulary.save.googleDriveRetry", "Google Drive save failed. Check connection.") || "Google Drive save failed. Check connection." : t("vocabulary.save.autoSaveRetry", "Auto save failed. Click to select a new file.") || "Auto save failed. Click to select a new file.";
        toast.info(retryMessage, {
          timeout: 5e3,
          onClick: () => {
            if (storageType.value === "local") {
              setupAutoSaveFile();
            }
          }
        });
      }
    }, 500);
  };
  const scheduleAutoSave = () => {
    if (autoSaveTimer) clearTimeout(autoSaveTimer);
    autoSaveTimer = window.setTimeout(() => {
      if (autoSaveEnabled.value) {
        performAutoSave();
        scheduleAutoSave();
      }
    }, 1e4);
  };
  const setupAutoSaveFile = async () => {
    if ("showSaveFilePicker" in window) {
      try {
        console.log("Setting up auto-save file...");
        const fileHandle = await window.showSaveFilePicker({
          suggestedName: autoSaveFileName,
          types: [{ description: "JSON files", accept: { "application/json": [".json"] } }]
        });
        autoSaveFileHandle.value = fileHandle;
        await saveFileHandleToIDB(fileHandle);
        try {
          const fileProps = await fileHandle.getFile();
          autoSaveFilePath.value = fileProps.name;
          console.log("Selected auto-save file:", fileProps.name);
        } catch (e) {
          console.log("Could not get file properties:", e);
        }
        hasAutoSaveFile.value = true;
        setStoredValue("vocabulary-has-auto-save-file", true);
        const vocabularyData = getVocabularyData();
        console.log("Testing auto-save with file handle:", autoSaveFileHandle.value);
        const saveResult = await tryAutoSaveToFile(vocabularyData);
        if (saveResult) {
          toast.success(t("vocabulary.save.autoSaveFileSetup", "Auto save file setup"));
          console.log("Auto-save file setup successful!");
        } else {
          toast.error(t("vocabulary.save.errors.autoSaveFileFailed", "Auto save file failed"));
          console.error("Auto-save file setup failed!");
        }
      } catch (error) {
        if (error.name !== "AbortError") {
          console.error("Error setting up auto-save file:", error);
          toast.error(t("vocabulary.save.errors.fileSelectError", { error: error.message }) || `File selection error: ${error.message}`);
        }
      }
    } else {
      toast.error(t("vocabulary.save.errors.browserNotSupported", "Browser not supported"));
    }
  };
  const handleFileImport = (file) => {
    if (!file || !file.name.endsWith(".json")) {
      toast.error(t("vocabulary.save.errors.invalidFile", "Invalid file"));
      return;
    }
    const toastId = toast(
      {
        component: ConfirmToast$1,
        props: {
          message: t("vocabulary.save.import.confirmMessage", { filename: file.name }, `Import ${file.name}? This will replace all current vocabulary.`),
          confirmText: t("common.confirm", "Confirm"),
          cancelText: t("common.cancel", "Cancel"),
          onConfirm: () => {
            const reader = new FileReader();
            reader.onload = (e) => {
              isSaving.value = true;
              try {
                const text = e.target?.result;
                const data = JSON.parse(text);
                if (!data.vocabularies || !Array.isArray(data.vocabularies)) {
                  toast.error(t("vocabulary.save.errors.invalidFile", "Invalid file"));
                  isSaving.value = false;
                  return;
                }
                vocabularyStore.importVocabularies(data.vocabularies);
                if (data.customTopics && Array.isArray(data.customTopics)) {
                  localStorage.setItem("customTopics", JSON.stringify(data.customTopics));
                  vocabularyStore.refreshCustomTopics();
                  console.log("Imported custom topics:", data.customTopics);
                }
                if (data.topics && Array.isArray(data.topics)) {
                  localStorage.setItem("customTopics", JSON.stringify(data.topics));
                  vocabularyStore.refreshCustomTopics();
                  console.log("Imported legacy topics:", data.topics);
                }
                if (data.groupTopics && typeof data.groupTopics === "object") {
                  localStorage.setItem("vocabulary-group-topics", JSON.stringify(data.groupTopics));
                  console.log("Imported group topics:", data.groupTopics);
                }
                if (data.accordionState && typeof data.accordionState === "object") {
                  localStorage.setItem("vocabulary-accordion-state", JSON.stringify(data.accordionState));
                  console.log("Imported accordion state:", data.accordionState);
                }
                if (typeof data.useGrouping === "boolean") {
                  localStorage.setItem("vocabulary-use-grouping", JSON.stringify(data.useGrouping));
                  console.log("Imported grouping state:", data.useGrouping);
                }
                if (data.vocabularyNotes && typeof data.vocabularyNotes === "object") {
                  localStorage.setItem("vocabulary-notes", JSON.stringify(data.vocabularyNotes));
                  console.log("Imported vocabulary notes:", data.vocabularyNotes);
                }
                if (data.markedWords && typeof data.markedWords === "object") {
                  localStorage.setItem("vocabulary-marked-words", JSON.stringify(data.markedWords));
                  console.log("Imported marked words:", data.markedWords);
                }
                if (data.grammarRules && Array.isArray(data.grammarRules)) {
                  localStorage.setItem("grammar-rules", JSON.stringify(data.grammarRules));
                  console.log("Imported grammar rules:", data.grammarRules);
                }
                if (data.practiceHistory && Array.isArray(data.practiceHistory)) {
                  localStorage.setItem("flashcard-practice-history", JSON.stringify(data.practiceHistory));
                  console.log("Imported practice history:", data.practiceHistory);
                }
                isSaving.value = false;
                let importMessage = t("vocabulary.save.import.successMessage", { count: data.vocabularies.length }, `Successfully imported ${data.vocabularies.length} vocabulary words`);
                if (data.customTopics?.length > 0) {
                  importMessage += ` + ${data.customTopics.length} custom categories`;
                }
                if (data.groupTopics && Object.keys(data.groupTopics).length > 0) {
                  importMessage += ` + ${Object.keys(data.groupTopics).length} group topics`;
                }
                if (typeof data.useGrouping === "boolean") {
                  importMessage += ` + grouping preference`;
                }
                if (data.vocabularyNotes && Object.keys(data.vocabularyNotes).length > 0) {
                  importMessage += ` + ${Object.keys(data.vocabularyNotes).length} vocabulary notes`;
                }
                if (data.markedWords && Object.keys(data.markedWords).length > 0) {
                  let totalMarkedWords = 0;
                  Object.values(data.markedWords).forEach((words) => {
                    if (Array.isArray(words)) {
                      totalMarkedWords += words.length;
                    }
                  });
                  importMessage += ` + ${totalMarkedWords} marked words`;
                }
                if (data.grammarRules && data.grammarRules.length > 0) {
                  importMessage += ` + ${data.grammarRules.length} grammar rules`;
                }
                if (data.practiceHistory && data.practiceHistory.length > 0) {
                  importMessage += ` + ${data.practiceHistory.length} practice sessions`;
                }
                toast.success(importMessage);
                window.dispatchEvent(new CustomEvent("vocabularyImportComplete", {
                  detail: { useGrouping: data.useGrouping }
                }));
                if (autoSaveEnabled.value) {
                  debounceAutoSave();
                }
              } catch (error) {
                isSaving.value = false;
                console.error(t("vocabulary.save.errors.invalidFile"), error);
                toast.error(t("vocabulary.save.errors.invalidFile", "Invalid file"));
              }
            };
            reader.onerror = () => {
              isSaving.value = false;
              console.error("Error reading file");
              toast.error(t("vocabulary.save.errors.fileReadError", { error: reader.error?.message || "Unknown error" }) || `Error reading file: ${reader.error?.message || "Unknown error"}`);
            };
            reader.readAsText(file);
            toast.dismiss(toastId);
          },
          onCancel: () => {
            isSaving.value = false;
            toast.dismiss(toastId);
          }
        }
      },
      {
        position: POSITION.TOP_CENTER,
        timeout: false,
        closeButton: false,
        draggable: false,
        icon: false
      }
    );
  };
  const tryAutoSaveToGoogleDrive = async (data) => {
    try {
      const isSignedIn = await googleAuth.isSignedIn();
      if (!isSignedIn) {
        console.log("❌ Not signed in to Google Drive or token invalid");
        return false;
      }
      console.log("⬆️ Attempting to auto-save to Google Drive...");
      let lastError = null;
      const maxAttempts = 2;
      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          console.log(`📤 Google Drive upload attempt ${attempt}/${maxAttempts}...`);
          const result = await googleDriveApi.uploadVocabularyData(data);
          if (result.success) {
            console.log(`✅ Auto-save to Google Drive completed successfully (attempt ${attempt})`);
            hasGoogleDriveFile.value = true;
            setStoredValue("vocabulary-has-google-drive-file", true);
            return true;
          } else {
            lastError = result.error;
            console.error(`❌ Google Drive save failed (attempt ${attempt}):`, result.error);
            if (result.error?.includes("timeout")) {
              console.log("⏰ Upload timeout detected, stopping retries to avoid excessive wait");
              break;
            }
            if (result.error?.includes("401") || result.error?.includes("unauthorized")) {
              console.log("🔄 Auth error detected, refreshing token...");
              const token = await googleAuth.getAccessToken();
              if (!token) {
                console.log("❌ Token refresh failed, stopping retries");
                break;
              }
            }
            if (attempt < maxAttempts) {
              console.log(`⏳ Waiting ${attempt * 2}s before retry...`);
              await new Promise((resolve) => setTimeout(resolve, 2e3 * attempt));
            }
          }
        } catch (apiError) {
          lastError = apiError;
          const errorMsg2 = apiError?.message || String(apiError);
          console.error(`❌ Google Drive API error (attempt ${attempt}):`, errorMsg2);
          if (errorMsg2.includes("timeout")) {
            console.log("⏰ API timeout detected, stopping retries");
            break;
          }
          if (attempt < maxAttempts) {
            console.log(`⏳ Waiting ${attempt * 2}s before retry...`);
            await new Promise((resolve) => setTimeout(resolve, 2e3 * attempt));
          }
        }
      }
      const errorMsg = lastError?.message || String(lastError);
      console.error("❌ All Google Drive auto-save attempts failed:", errorMsg);
      if (errorMsg?.includes("timeout")) {
        const dataSize = Math.round(JSON.stringify(data).length / 1024);
        console.warn(`⚠️ Auto-save failed due to timeout for ${dataSize}KB file. Consider reducing vocabulary size or checking internet connection.`);
      }
      return false;
    } catch (error) {
      console.error("❌ Error saving to Google Drive:", error);
      return false;
    }
  };
  const setupGoogleDrive = async () => {
    try {
      console.log("Setting up Google Drive auto-save...");
      const isSignedIn = await googleAuth.isSignedIn();
      if (!isSignedIn) {
        const signInResult = await googleAuth.signIn();
        if (!signInResult) {
          toast.error(t("vocabulary.save.errors.googleSignInFailed", "Google sign-in failed") || "Google sign-in failed");
          return false;
        }
      }
      const vocabularyData = getVocabularyData();
      let lastError = null;
      for (let attempt = 1; attempt <= 2; attempt++) {
        try {
          const result = await googleDriveApi.uploadVocabularyData(vocabularyData);
          if (result.success) {
            hasGoogleDriveFile.value = true;
            setStoredValue("vocabulary-has-google-drive-file", true);
            toast.success(t("vocabulary.save.googleDriveSetup", "Google Drive setup successful") || "Google Drive setup successful");
            return true;
          } else {
            lastError = result.error;
            console.error(`❌ Google Drive setup test failed (attempt ${attempt}):`, result.error);
            if (attempt < 2) {
              await new Promise((resolve) => setTimeout(resolve, 1e3));
            }
          }
        } catch (apiError) {
          lastError = apiError;
          console.error(`❌ Google Drive setup API error (attempt ${attempt}):`, apiError);
          if (attempt < 2) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          }
        }
      }
      toast.error(t("vocabulary.save.errors.googleDriveSetupFailed", "Google Drive setup failed") || `Google Drive setup failed: ${lastError}`);
      return false;
    } catch (error) {
      console.error("Error setting up Google Drive:", error);
      toast.error(t("vocabulary.save.errors.googleDriveSetupFailed", "Google Drive setup failed") || "Google Drive setup failed");
      return false;
    }
  };
  const syncFromGoogleDrive = async () => {
    try {
      const isSignedIn = await googleAuth.isSignedIn();
      if (!isSignedIn) {
        toast.error(t("vocabulary.save.errors.notSignedIn", "Not signed in to Google") || "Not signed in to Google");
        return false;
      }
      console.log("Syncing from Google Drive...");
      let lastError = null;
      for (let attempt = 1; attempt <= 2; attempt++) {
        try {
          const result = await googleDriveApi.downloadVocabularyData();
          if (result.success && result.data) {
            if (result.data.vocabularies && Array.isArray(result.data.vocabularies)) {
              vocabularyStore.importVocabularies(result.data.vocabularies);
              if (result.data.customTopics && Array.isArray(result.data.customTopics)) {
                localStorage.setItem("customTopics", JSON.stringify(result.data.customTopics));
                vocabularyStore.refreshCustomTopics();
              }
              if (result.data.groupTopics && typeof result.data.groupTopics === "object") {
                localStorage.setItem("vocabulary-group-topics", JSON.stringify(result.data.groupTopics));
              }
              if (result.data.grammarRules && Array.isArray(result.data.grammarRules)) {
                localStorage.setItem("grammar-rules", JSON.stringify(result.data.grammarRules));
              }
              if (result.data.practiceHistory && Array.isArray(result.data.practiceHistory)) {
                localStorage.setItem("flashcard-practice-history", JSON.stringify(result.data.practiceHistory));
              }
              toast.success(t("vocabulary.save.syncFromDriveSuccess", "Successfully synced from Google Drive") || "Successfully synced from Google Drive");
              return true;
            }
          } else {
            lastError = result.error;
            console.error(`❌ Google Drive sync failed (attempt ${attempt}):`, result.error);
            if (attempt < 2) {
              await new Promise((resolve) => setTimeout(resolve, 1e3));
            }
          }
        } catch (apiError) {
          lastError = apiError;
          console.error(`❌ Google Drive sync API error (attempt ${attempt}):`, apiError);
          if (attempt < 2) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          }
        }
      }
      toast.error(lastError || t("vocabulary.save.errors.syncFailed", "Sync failed") || "Sync failed");
      return false;
    } catch (error) {
      console.error("Error syncing from Google Drive:", error);
      toast.error(t("vocabulary.save.errors.syncFailed", "Sync failed") || "Sync failed");
      return false;
    }
  };
  const handleGoogleSignIn = async () => {
    try {
      console.log("Initiating Google sign-in...");
      await googleAuth.initialize();
      const result = await googleAuth.signIn();
      if (result) {
        toast.success(t("vocabulary.save.googleSignInSuccess", "Successfully signed in to Google") || "Successfully signed in to Google");
        try {
          const backupInfo = await googleDriveApi.getVocabularyBackupInfo();
          if (backupInfo.exists) {
            hasGoogleDriveFile.value = true;
            setStoredValue("vocabulary-has-google-drive-file", true);
          }
        } catch (backupError) {
          console.warn("⚠️ Could not check backup status after sign-in:", backupError);
        }
      } else {
        toast.error(t("vocabulary.save.errors.googleSignInFailed", "Google sign-in failed") || "Google sign-in failed");
      }
      return result;
    } catch (error) {
      console.error("Google sign-in error:", error);
      toast.error(t("vocabulary.save.errors.googleSignInFailed", "Google sign-in failed") || "Google sign-in failed");
      return false;
    }
  };
  const handleGoogleSignOut = async () => {
    try {
      await googleAuth.signOut();
      hasGoogleDriveFile.value = false;
      setStoredValue("vocabulary-has-google-drive-file", false);
      toast.success(t("vocabulary.save.googleSignOutSuccess", "Successfully signed out from Google") || "Successfully signed out from Google");
    } catch (error) {
      console.error("Google sign-out error:", error);
      toast.error(t("vocabulary.save.errors.googleSignOutFailed", "Google sign-out failed") || "Google sign-out failed");
    }
  };
  const resetAutoSaveFile = async () => {
    autoSaveFileHandle.value = null;
    hasAutoSaveFile.value = false;
    setStoredValue("vocabulary-has-auto-save-file", false);
    autoSaveFilePath.value = "";
    await clearFileHandleFromIDB();
    console.log("Auto-save file reset completed");
  };
  const getSaveStatusColor = computed(() => {
    switch (saveStatus.value) {
      case "saving":
        return "bg-yellow-500";
      case "success":
        return "bg-green-500";
      case "error":
        return "bg-red-500";
      default:
        return "bg-gray-400";
    }
  });
  const getSaveStatusText = computed(() => {
    switch (saveStatus.value) {
      case "saving":
        return autoSaveEnabled.value ? t("vocabulary.save.status.autoSaving", "Auto Saving...") : t("vocabulary.save.status.saving", "Saving...");
      case "success":
        if (autoSaveEnabled.value) {
          if (storageType.value === "google-drive" && hasGoogleDriveFile.value) {
            return t("vocabulary.save.status.autoGoogleDrive", "Auto saved to Google Drive");
          } else if (storageType.value === "local" && hasAutoSaveFile.value) {
            return t("vocabulary.save.status.autoWithFile", "Auto saved to file");
          } else {
            return t("vocabulary.save.status.autoLocalStorage", "Auto saved locally");
          }
        }
        return t("vocabulary.save.status.fileSaved", "Saved to file");
      case "error":
        return t("vocabulary.save.status.error", "Save error");
      default:
        if (autoSaveEnabled.value) {
          if (storageType.value === "google-drive") {
            return googleAuth.isSignedInSync() ? t("vocabulary.save.status.googleDriveReady", "Google Drive ready") : t("vocabulary.save.status.googleDriveSignIn", "Sign in to Google Drive");
          } else {
            return hasAutoSaveFile.value ? t("vocabulary.save.status.autoFile", "Auto save ready") : t("vocabulary.save.status.autoNoFile", "Auto save (no file)");
          }
        }
        return t("vocabulary.save.manual", "Manual save");
    }
  });
  onMounted(async () => {
    console.log("🚀 Component mounted, initializing auto-save...");
    await initializeAutoSave();
    console.log("📱 Initializing Google APIs...");
    try {
      await googleAuth.initialize();
      console.log("✅ Google APIs initialized");
      const isSignedIn = await googleAuth.isSignedIn();
      if (isSignedIn) {
        console.log("✅ Google Drive authentication restored and validated");
        try {
          const backupInfo = await googleDriveApi.getVocabularyBackupInfo();
          if (backupInfo.exists) {
            hasGoogleDriveFile.value = true;
            setStoredValue("vocabulary-has-google-drive-file", true);
            console.log("✅ Google Drive backup file found");
          }
        } catch (error) {
          console.warn("⚠️ Could not check Google Drive backup status:", error);
        }
      } else {
        console.log("⚠️ Google Drive authentication could not be restored");
      }
    } catch (error) {
      console.error("❌ Failed to initialize Google APIs:", error);
    }
  });
  onUnmounted(() => {
    if (autoSaveTimer) clearTimeout(autoSaveTimer);
    if (debounceTimer) clearTimeout(debounceTimer);
  });
  return {
    autoSaveEnabled,
    isSaving,
    lastSaveTime,
    hasAutoSaveFile,
    hasGoogleDriveFile,
    storageType,
    autoSaveFilePath,
    saveStatus,
    getSaveStatusColor,
    getSaveStatusText,
    manualSave,
    debounceAutoSave,
    scheduleAutoSave,
    setupAutoSaveFile,
    setupGoogleDrive,
    syncFromGoogleDrive,
    handleGoogleSignIn,
    handleGoogleSignOut,
    handleFileImport,
    resetAutoSaveFile,
    // Google auth states  
    isGoogleSignedIn: computed(() => googleAuth.isSignedInSync()),
    googleUserEmail: googleAuth.googleUserEmail,
    googleAuthError: googleAuth.authError
  };
}

function useMoveMode() {
  const { t, locale } = useI18n();
  const vocabularyStore = useVocabularyStore();
  const toast = useToast();
  const globalMoveMode = ref(getStoredMoveMode());
  const showMoveModal = ref(false);
  const wordToMove = ref(null);
  const selectedTargetDate = ref("");
  const availableDateGroups = ref([]);
  const currentSourceDate = ref("");
  function getStoredMoveMode() {
    try {
      const stored = localStorage.getItem("vocabulary-global-move-mode-enabled");
      return stored ? JSON.parse(stored) : false;
    } catch (error) {
      console.warn("Failed to parse stored move mode preference:", error);
      return false;
    }
  }
  function setStoredMoveMode(enabled) {
    try {
      localStorage.setItem("vocabulary-global-move-mode-enabled", JSON.stringify(enabled));
    } catch (error) {
      console.warn("Failed to store move mode preference:", error);
    }
  }
  const toggleMoveMode = (enabled) => {
    globalMoveMode.value = enabled;
    setStoredMoveMode(enabled);
  };
  const handleMoveVocabulary = (data) => {
    if (!data.targetDate) {
      wordToMove.value = {
        ...data.word,
        categoryName: data.word.category,
        isBatchMove: false
      };
      currentSourceDate.value = data.sourceDate || "";
      loadAvailableDateGroups(data.word.category);
      showMoveModal.value = true;
    } else {
      performMoveVocabulary(data);
    }
  };
  const loadAvailableDateGroups = (topic) => {
    const allDateGroups = groupVocabulariesByDate(vocabularyStore.allVocabularies.value);
    availableDateGroups.value = allDateGroups.filter((group) => group.date !== currentSourceDate.value).map((group) => ({
      date: group.date,
      count: group.vocabularies.length
    })).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
  };
  const performMoveVocabulary = async (data) => {
    try {
      const wordIndex = vocabularyStore.allVocabularies.value.findIndex((w) => w.id === data.word.id);
      if (wordIndex !== -1) {
        const updatedWord = {
          ...data.word,
          createdAt: data.targetDate,
          updatedAt: data.targetDate
        };
        vocabularyStore.allVocabularies.value[wordIndex] = updatedWord;
        toast.success(
          t(
            "vocabulary.moveSuccess",
            { word: data.word.word, date: formatDateForDisplay(data.targetDate) },
            `Successfully moved "${data.word.word}" to ${formatDateForDisplay(data.targetDate)}`
          ),
          { timeout: 3e3 }
        );
        console.log(`Moved vocabulary "${data.word.word}" to ${data.targetDate}`);
      } else {
        throw new Error("Word not found");
      }
    } catch (error) {
      console.error("Failed to move vocabulary:", error);
      toast.error(
        t(
          "vocabulary.moveError",
          { word: data.word.word, error: error.message },
          `Failed to move "${data.word.word}": ${error.message}`
        ),
        { timeout: 5e3 }
      );
    }
  };
  const formatDateForDisplay = (dateStr) => {
    const date = new Date(dateStr);
    return date.toLocaleDateString(locale.value, {
      year: "numeric",
      month: "short",
      day: "numeric"
    });
  };
  const closeMoveModal = () => {
    showMoveModal.value = false;
    wordToMove.value = null;
    selectedTargetDate.value = "";
    availableDateGroups.value = [];
    currentSourceDate.value = "";
  };
  const confirmMove = (data) => {
    if (data.word.isBatchMove) {
      performBatchMove(data.targetDate);
    } else {
      performMoveVocabulary(data);
    }
    closeMoveModal();
  };
  const handleBatchMoveCategory = (data) => {
    const batchWords = data.words;
    const categoryName = data.topic;
    wordToMove.value = {
      ...batchWords[0],
      isBatchMove: true,
      batchWords,
      categoryName
    };
    currentSourceDate.value = data.sourceDate;
    const allGroups = groupVocabulariesByDate(vocabularyStore.allVocabularies.value);
    availableDateGroups.value = allGroups.filter((group) => group.date !== data.sourceDate).map((group) => ({
      date: group.date,
      count: group.vocabularies.length
    })).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
    showMoveModal.value = true;
  };
  const performBatchMove = async (targetDate) => {
    try {
      const batchWords = wordToMove.value?.batchWords || [];
      const categoryName = wordToMove.value?.categoryName || "";
      batchWords.forEach((word) => {
        const wordIndex = vocabularyStore.allVocabularies.value.findIndex((w) => w.id === word.id);
        if (wordIndex !== -1) {
          const updatedWord = {
            ...word,
            createdAt: targetDate,
            updatedAt: targetDate
          };
          vocabularyStore.allVocabularies.value[wordIndex] = updatedWord;
        }
      });
      toast.success(
        t(
          "vocabulary.batchMoveSuccess",
          { count: batchWords.length, category: categoryName, date: formatDateForDisplay(targetDate) },
          `Successfully moved ${batchWords.length} words from "${categoryName}" to ${formatDateForDisplay(targetDate)}`
        ),
        { timeout: 3e3 }
      );
      console.log(`Batch moved ${batchWords.length} words from category "${categoryName}" to ${targetDate}`);
    } catch (error) {
      console.error("Failed to batch move vocabulary:", error);
      toast.error(
        t(
          "vocabulary.batchMoveError",
          { error: error.message },
          `Failed to batch move: ${error.message}`
        ),
        { timeout: 5e3 }
      );
    }
  };
  return {
    // State
    globalMoveMode,
    showMoveModal,
    wordToMove,
    selectedTargetDate,
    availableDateGroups,
    currentSourceDate,
    // Actions
    toggleMoveMode,
    handleMoveVocabulary,
    handleBatchMoveCategory,
    loadAvailableDateGroups,
    performMoveVocabulary,
    performBatchMove,
    closeMoveModal,
    confirmMove,
    formatDateForDisplay,
    // Helpers
    getStoredMoveMode,
    setStoredMoveMode
  };
}

const _hoisted_1$1q = { class: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative overflow-x-hidden" };
const _hoisted_2$1n = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto px-2 xs:px-3 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 pt-3 sm:pt-6" };
const _hoisted_3$1k = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6 mb-3 xs:mb-4 sm:mb-6" };
const _hoisted_4$1f = { class: "flex items-center mb-4" };
const _hoisted_5$1c = { class: "text-lg sm:text-xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 dark:from-blue-400 dark:to-indigo-400 bg-clip-text text-transparent" };
const _hoisted_6$19 = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto py-3 px-2 xs:py-4 xs:px-3 sm:py-6 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 overflow-x-hidden" };
const _hoisted_7$15 = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] mb-3 xs:mb-4 sm:mb-6 p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_8$13 = { class: "flex items-center mb-4" };
const _hoisted_9$12 = { class: "text-base sm:text-lg font-semibold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent" };
const _hoisted_10$11 = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] mb-3 xs:mb-4 sm:mb-6 p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_11$11 = { class: "flex items-center mb-4" };
const _hoisted_12$_ = { class: "text-base sm:text-lg font-semibold bg-gradient-to-r from-green-600 to-blue-600 dark:from-green-400 dark:to-blue-400 bg-clip-text text-transparent" };
const _hoisted_13$_ = { class: "space-y-4 sm:space-y-6" };
const _hoisted_14$Z = { class: "bg-white/60 dark:bg-[#0a0a0a]/60 backdrop-blur-sm rounded-xl border border-white/20 dark:border-white/10 p-3 sm:p-4 md:p-5" };
const _hoisted_15$T = { class: "flex items-center mb-3 sm:mb-4" };
const _hoisted_16$S = { class: "text-sm sm:text-base font-semibold bg-gradient-to-r from-purple-600 to-pink-600 dark:from-purple-400 dark:to-pink-400 bg-clip-text text-transparent" };
const _hoisted_17$R = { class: "bg-white/60 dark:bg-[#0a0a0a]/60 backdrop-blur-sm rounded-xl border border-white/20 dark:border-white/10 p-3 sm:p-4 md:p-5" };
const _hoisted_18$P = { class: "flex items-center mb-3 sm:mb-4" };
const _hoisted_19$P = { class: "text-sm sm:text-base font-semibold bg-gradient-to-r from-yellow-600 to-orange-600 dark:from-yellow-400 dark:to-orange-400 bg-clip-text text-transparent" };
const _hoisted_20$O = { class: "bg-white/60 dark:bg-[#0a0a0a]/60 backdrop-blur-sm rounded-xl border border-white/20 dark:border-white/10 p-3 sm:p-4 md:p-5" };
const _hoisted_21$O = { class: "flex items-center mb-3 sm:mb-4" };
const _hoisted_22$M = { class: "text-sm sm:text-base font-semibold bg-gradient-to-r from-cyan-600 to-blue-600 dark:from-cyan-400 dark:to-blue-400 bg-clip-text text-transparent" };
const _hoisted_23$M = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.003] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_24$K = { class: "fixed bottom-6 z-50 left-1/2 translate-x-4 md:translate-x-4 lg:left-auto lg:right-6 lg:translate-x-0" };
const _hoisted_25$K = {
  key: 0,
  class: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs font-medium text-white bg-gray-900 dark:bg-black dark:text-white dark:border dark:border-dark-bg-mute rounded shadow-lg whitespace-nowrap z-50"
};
const HOVER_EXPAND_STORAGE_KEY = "vocabulary-hover-expand-enabled";
const _sfc_main$1r = /* @__PURE__ */ defineComponent({
  __name: "VocabularyListView",
  setup(__props) {
    const LazyLoadComponent = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => LazyLoadComponent$1),true              ?void 0:void 0));
    const BaseAccordion = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => BaseAccordion$1),true              ?void 0:void 0));
    const GroupingToggle$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => GroupingToggle),true              ?void 0:void 0));
    const ConfirmToast$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ConfirmToast),true              ?void 0:void 0));
    const TopicManagerPanel$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => TopicManagerPanel),true              ?void 0:void 0));
    const SaveControlPanel$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => SaveControlPanel),true              ?void 0:void 0));
    const VocabularyHeader$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VocabularyHeader),true              ?void 0:void 0));
    const VocabularyFilters$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VocabularyFilters),true              ?void 0:void 0));
    const VocabularyList$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VocabularyList),true              ?void 0:void 0));
    const VocabularyFormDialog = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VocabularyFormDialog$1),true              ?void 0:void 0));
    const VocabularyDetailDialog = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VocabularyDetailDialog$1),true              ?void 0:void 0));
    const VocabularyNoteDialog = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VocabularyNoteDialog$1),true              ?void 0:void 0));
    const GrammarManagerModal = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => GrammarManagerModal$1),true              ?void 0:void 0));
    const MoveModal = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => MoveModal$1),true              ?void 0:void 0));
    const VoiceSelector$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VoiceSelector),true              ?void 0:void 0));
    const TopicManager = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => TopicManager$1),true              ?void 0:void 0));
    const DeleteAllVocabulariesPanel$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => DeleteAllVocabulariesPanel),true              ?void 0:void 0));
    const { t, locale } = useI18n();
    const toast = useToast();
    const vocabularyStore = useVocabularyStore();
    const voiceStore = useVoiceStore();
    const modalStore = useModalStore();
    const itemsPerPage = ref(5);
    const {
      searchQuery,
      selectedCategory,
      selectedLevel,
      showFavoritesOnly,
      updateShowFavoritesOnly,
      updateSearchQuery,
      updateSelectedCategory,
      updateSelectedLevel
    } = useVocabularyFilters();
    const {
      useGrouping,
      itemsPerPageGrouped,
      dateGroupPages,
      toggleGrouping,
      reloadGroupingState,
      dateGroupPrevious,
      dateGroupNext,
      dateGroupGoToPage
    } = useVocabularyGrouping();
    const getStoredHoverState = () => {
      try {
        const stored = localStorage.getItem(HOVER_EXPAND_STORAGE_KEY);
        return stored ? JSON.parse(stored) : false;
      } catch (error) {
        console.warn("Failed to load hover expand state from localStorage:", error);
        return false;
      }
    };
    const setStoredHoverState = (enabled) => {
      try {
        localStorage.setItem(HOVER_EXPAND_STORAGE_KEY, JSON.stringify(enabled));
      } catch (error) {
        console.warn("Failed to save hover expand state to localStorage:", error);
      }
    };
    const hoverToExpandEnabled = ref(getStoredHoverState());
    const {
      globalMoveMode,
      showMoveModal,
      wordToMove,
      availableDateGroups,
      currentSourceDate,
      toggleMoveMode,
      handleMoveVocabulary,
      handleBatchMoveCategory,
      closeMoveModal,
      confirmMove} = useMoveMode();
    const showNoteDialog = ref(false);
    const noteDialogDate = ref("");
    const noteDialogWords = ref([]);
    const filteredVocabulary = computed(() => {
      return vocabularyStore.allVocabularies.value.filter((word) => {
        const matchesSearch = !searchQuery.value || word.word.toLowerCase().includes(searchQuery.value.toLowerCase()) || word.meaning.toLowerCase().includes(searchQuery.value.toLowerCase());
        const matchesCategory = !selectedCategory.value || word.category === selectedCategory.value;
        const matchesLevel = !selectedLevel.value || word.level === selectedLevel.value;
        const matchesFavorite = !showFavoritesOnly.value || word.favorite === true;
        return matchesSearch && matchesCategory && matchesLevel && matchesFavorite;
      });
    });
    const {
      currentPage,
      totalPages,
      paginatedVocabulary,
      startIndex,
      endIndex,
      visiblePages,
      previousPage,
      nextPage,
      goToPage
    } = useVocabularyPagination(filteredVocabulary, useGrouping, itemsPerPage);
    const {
      showFormDialog,
      selectedVocabulary,
      showDetailDialog,
      selectedVocabularyForDetail,
      openAddDialog,
      openEditDialog,
      onVocabularySaved: originalOnVocabularySaved,
      openDetailsDialog,
      openEditFromDetail
    } = useVocabularyDialogs();
    const recentlyAddedCategory = ref(null);
    const onVocabularySaved = (data) => {
      originalOnVocabularySaved();
      targetDateForNewVocabulary.value = null;
      if (data?.category) {
        recentlyAddedCategory.value = data.category;
        console.log("Recently added category:", data.category);
      }
      if (autoSaveEnabled.value) {
        debounceAutoSave();
        console.log("Auto-save triggered from Add Word in date group");
      }
      if (useGrouping.value) {
        nextTick(() => {
          reloadGroupingState();
          console.log("Grouping state reloaded after vocabulary saved");
        });
      }
    };
    const {
      autoSaveEnabled,
      isSaving,
      lastSaveTime,
      hasAutoSaveFile,
      hasGoogleDriveFile,
      storageType,
      saveStatus,
      getSaveStatusColor,
      getSaveStatusText,
      manualSave,
      debounceAutoSave,
      scheduleAutoSave,
      setupAutoSaveFile,
      setupGoogleDrive,
      syncFromGoogleDrive,
      handleGoogleSignIn,
      handleGoogleSignOut,
      handleFileImport,
      resetAutoSaveFile,
      autoSaveFilePath,
      isGoogleSignedIn,
      googleUserEmail,
      googleAuthError
    } = useVocabularySaving();
    const {
      showTopicManager,
      openTopicManager,
      onTopicAdded,
      onTopicUpdated,
      onTopicDeleted
    } = useTopicManager(debounceAutoSave);
    const categories = computed(() => {
      const usedCategories = new Set(vocabularyStore.allVocabularies.value.map((vocab) => vocab.category));
      return Array.from(usedCategories).sort();
    });
    const categoryUsage = computed(() => vocabularyStore.getCategoryUsage.value);
    const showStickyButtonVisible = computed(() => {
      return showStickyButton.value && !showFormDialog.value && !modalStore.shouldHideAddNewWord;
    });
    const formattedSaveStatusForAccordion = computed(() => {
      if (!lastSaveTime.value) {
        return t("vocabulary.save.notSaved", "Not saved");
      }
      const statusText = getSaveStatusText.value;
      const timeText = lastSaveTime.value;
      const lastSaveLabel = t("vocabulary.save.lastSave", { time: timeText }, "Last saved: {time}");
      let finalText;
      if (lastSaveLabel && lastSaveLabel.includes("{time}")) {
        finalText = lastSaveLabel.replace("{time}", timeText);
      } else {
        finalText = lastSaveLabel || `Last saved: ${timeText}`;
      }
      return `${finalText} - ${statusText}`;
    });
    const deleteWord = (word) => {
      const toastId = toast(
        {
          component: ConfirmToast$1,
          props: {
            message: t("vocabulary.confirmDelete", { word: word.word }),
            confirmText: t("common.confirm"),
            cancelText: t("common.cancel"),
            onConfirm: () => {
              vocabularyStore.deleteVocabulary(word.id);
              debounceAutoSave();
              toast.dismiss(toastId);
              toast.success(t("vocabulary.deleteSuccess", { word: word.word }) || `Successfully deleted "${word.word}"`);
            },
            onCancel: () => {
              toast.dismiss(toastId);
            }
          }
        },
        {
          position: POSITION.TOP_CENTER,
          timeout: false,
          closeButton: false,
          draggable: false,
          icon: false
        }
      );
    };
    const toggleFavorite = (word) => {
      vocabularyStore.toggleFavorite(word.id);
      if (selectedVocabularyForDetail.value && selectedVocabularyForDetail.value.id === word.id) {
        selectedVocabularyForDetail.value.favorite = !selectedVocabularyForDetail.value.favorite;
      }
      debounceAutoSave();
    };
    const playAudio = async (word) => {
      try {
        const utterance = voiceStore.createUtterance(word);
        await new Promise((resolve, reject) => {
          utterance.onend = () => resolve();
          utterance.onerror = (event) => reject(event.error);
          if ("speechSynthesis" in window) {
            speechSynthesis.speak(utterance);
          } else {
            reject(new Error("Speech synthesis not supported"));
          }
        });
      } catch (error) {
        console.error("Error playing audio:", error);
        if ("speechSynthesis" in window) {
          const utterance = new SpeechSynthesisUtterance(word);
          utterance.lang = "en-US";
          speechSynthesis.speak(utterance);
        }
      }
    };
    watch(
      () => vocabularyStore.allVocabularies.value,
      (newVocabularies, oldVocabularies) => {
        const newCount = newVocabularies?.length || 0;
        const oldCount = oldVocabularies?.length || 0;
        if (autoSaveEnabled.value && newCount > 0 && oldCount !== void 0 && newCount !== oldCount) {
          saveStatus.value = "saving";
          debounceAutoSave();
        }
        if (useGrouping.value && newCount !== oldCount && newCount > 0) {
          nextTick(() => {
            reloadGroupingState();
            console.log("Grouping state reloaded due to vocabulary count change");
          });
        }
      },
      { deep: true, immediate: false }
    );
    watch(
      () => vocabularyStore.allVocabularies.value.map((v) => ({ id: v.id, favorite: v.favorite, word: v.word, meaning: v.meaning })),
      (newData, oldData) => {
        if (autoSaveEnabled.value && newData.length > 0 && oldData && JSON.stringify(newData) !== JSON.stringify(oldData)) {
          debounceAutoSave();
        }
      },
      { deep: true }
    );
    watch(
      hoverToExpandEnabled,
      (newValue) => {
        setStoredHoverState(newValue);
      }
    );
    watch(showNoteDialog, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        if (!showFormDialog.value) {
          document.body.classList.remove("modal-open");
        }
      }
      modalStore.setNoteDialog(newValue);
    });
    watch(showFormDialog, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
        showStickyTooltip.value = false;
      } else {
        if (!showNoteDialog.value) {
          document.body.classList.remove("modal-open");
        }
      }
      modalStore.setVocabularyForm(newValue);
    });
    onMounted(() => {
      vocabularyStore.initializeStore();
      if (autoSaveEnabled.value) {
        scheduleAutoSave();
      }
      window.addEventListener("vocabulary-notes-updated", () => {
        if (autoSaveEnabled.value) {
          debounceAutoSave();
        }
      });
      window.addEventListener("grammar-rules-updated", () => {
        if (autoSaveEnabled.value) {
          debounceAutoSave();
        }
      });
      window.addEventListener("scroll", handleScroll, { passive: true });
      handleScroll();
    });
    const handleFileImportWithReload = (file) => {
      const handleImportComplete = (event) => {
        nextTick(() => {
          reloadGroupingState();
          console.log("Grouping state reloaded after import");
        });
        window.removeEventListener("vocabularyImportComplete", handleImportComplete);
      };
      window.addEventListener("vocabularyImportComplete", handleImportComplete);
      handleFileImport(file);
    };
    const showStickyButton = ref(false);
    const showStickyTooltip = ref(false);
    const headerHeight = ref(0);
    ref(false);
    const lastScrollY = ref(0);
    const accordionState = ref(true);
    const handleScroll = () => {
      const scrollY = window.scrollY;
      const headerElement = document.querySelector("[data-vocabulary-header]") || document.querySelector("header");
      if (headerHeight.value === 0 && headerElement) {
        headerHeight.value = headerElement.offsetHeight;
      }
      const currentAccordionState = (() => {
        try {
          const stored = localStorage.getItem("accordion-vocabulary-header");
          return stored !== null ? JSON.parse(stored) : true;
        } catch {
          return true;
        }
      })();
      accordionState.value = currentAccordionState;
      const originalAddButton = document.querySelector("[data-original-add-button]");
      let originalButtonVisible = false;
      if (originalAddButton) {
        const rect = originalAddButton.getBoundingClientRect();
        const computedStyle = window.getComputedStyle(originalAddButton);
        originalButtonVisible = rect.height > 0 && rect.width > 0 && computedStyle.display !== "none" && computedStyle.visibility !== "hidden" && computedStyle.opacity !== "0";
      }
      const headerBottom = headerHeight.value || 120;
      let shouldShowSticky;
      if (!accordionState.value) {
        shouldShowSticky = true;
      } else if (originalButtonVisible) {
        shouldShowSticky = false;
      } else {
        shouldShowSticky = scrollY > headerBottom;
      }
      showStickyButton.value = shouldShowSticky;
      lastScrollY.value = scrollY;
    };
    const openNoteDialog = (date, words) => {
      noteDialogDate.value = date;
      noteDialogWords.value = words;
      showNoteDialog.value = true;
    };
    const targetDateForNewVocabulary = ref(null);
    const showGrammarManagerModal = ref(false);
    const grammarManagerDate = ref(null);
    const openAddVocabularyForDate = (date) => {
      targetDateForNewVocabulary.value = date;
      selectedVocabulary.value = null;
      showFormDialog.value = true;
      window.dispatchEvent(new CustomEvent("vocabulary-edit-word"));
    };
    const openGrammarManagerForDate = (date) => {
      console.log("Opening grammar manager for date:", date);
      grammarManagerDate.value = date;
      showGrammarManagerModal.value = true;
      modalStore.setGrammarManager(true);
      console.log("Modal state:", showGrammarManagerModal.value);
    };
    watch(showGrammarManagerModal, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        if (!showNoteDialog.value && !showFormDialog.value) {
          document.body.classList.remove("modal-open");
        }
      }
      modalStore.setGrammarManager(newValue);
    });
    const handleNoteSaved = (note, markedWords) => {
      toast.success(t("vocabulary.notes.saveSuccess", "Notes saved successfully"), {
        timeout: 2e3
      });
      if (autoSaveEnabled.value) {
        toast.info(t("vocabulary.notes.autoSaveNotice", "Notes will be included in auto-save"), {
          timeout: 3e3
        });
        debounceAutoSave();
      }
      console.log(`Note saved for ${noteDialogDate.value} with ${markedWords.length} marked words`);
    };
    const handleVocabulariesDeleted = () => {
      currentPage.value = 1;
      recentlyAddedCategory.value = null;
      if (useGrouping.value) {
        nextTick(() => {
          reloadGroupingState();
          console.log("Grouping state reloaded after delete all");
        });
      }
      if (autoSaveEnabled.value) {
        debounceAutoSave();
      }
    };
    const handleLocalStoreCleared = () => {
      currentPage.value = 1;
      recentlyAddedCategory.value = null;
      useGrouping.value = false;
      autoSaveEnabled.value = false;
      hoverToExpandEnabled.value = false;
      globalMoveMode.value = false;
      nextTick(() => {
        reloadGroupingState();
        console.log("Grouping state reloaded after local store clear");
      });
      toast.info(
        t("vocabulary.deleteAll.localStoreClearedInfo", "Application has been reset to initial state. All local preferences have been cleared."),
        { timeout: 5e3 }
      );
      console.log("Local store cleared, application reset to initial state");
    };
    watch(hoverToExpandEnabled, (newValue) => {
      setStoredHoverState(newValue);
    });
    watch(globalMoveMode, (newValue) => {
      toggleMoveMode(newValue);
    });
    const handleStorageChange = (e) => {
      if (e.key === "accordion-vocabulary-header") {
        setTimeout(() => handleScroll(), 50);
      }
    };
    onMounted(() => {
      document.addEventListener("scroll", handleScroll);
      window.addEventListener("storage", handleStorageChange);
      const accordionButton = document.querySelector("[data-vocabulary-header] button");
      if (accordionButton) {
        accordionButton.addEventListener("click", () => {
          setTimeout(() => handleScroll(), 100);
        });
      }
      handleScroll();
    });
    onUnmounted(() => {
      document.removeEventListener("scroll", handleScroll);
      window.removeEventListener("storage", handleStorageChange);
      document.body.classList.remove("modal-open");
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1q, [
        _cache[26] || (_cache[26] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0"><div class="floating-shapes"><div class="absolute top-20 left-10 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob"></div><div class="absolute top-40 right-10 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000"></div><div class="absolute -bottom-8 left-20 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000"></div><div class="hidden sm:block absolute top-10 left-1/2 -translate-x-1/2 w-40 h-40 bg-cyan-300 dark:bg-cyan-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-1000"></div><div class="hidden sm:block absolute bottom-24 right-24 w-52 h-52 bg-indigo-300 dark:bg-indigo-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-3000"></div><div class="hidden md:block absolute top-1/3 right-1/3 w-36 h-36 bg-emerald-300 dark:bg-emerald-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-1500"></div><div class="hidden md:block absolute -bottom-20 -right-10 w-96 h-96 bg-blue-200 dark:bg-blue-600 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-2xl opacity-20 animate-blob animation-delay-2500"></div><div class="hidden lg:block absolute top-1/2 -left-16 w-72 h-72 bg-fuchsia-300 dark:bg-fuchsia-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-3500"></div><div class="hidden xl:block absolute top-6 right-1/4 w-44 h-44 bg-teal-300 dark:bg-teal-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-500"></div><div class="hidden sm:block absolute top-1/4 left-6 w-24 h-24 bg-sky-300 dark:bg-sky-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-lg opacity-20 animate-blob animation-delay-4500"></div><div class="hidden sm:block absolute bottom-8 left-1/3 w-28 h-28 bg-rose-300 dark:bg-rose-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-lg opacity-20 animate-blob animation-delay-5500"></div><div class="hidden md:block absolute top-16 right-1/3 w-20 h-20 bg-violet-300 dark:bg-violet-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-lg opacity-20 animate-blob animation-delay-6500"></div><div class="hidden md:block absolute bottom-1/3 right-6 w-24 h-24 bg-lime-300 dark:bg-lime-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-lg opacity-20 animate-blob animation-delay-7500"></div><div class="hidden lg:block absolute top-3/4 left-1/4 w-32 h-32 bg-amber-300 dark:bg-amber-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-20 animate-blob animation-delay-8500"></div><div class="hidden lg:block absolute top-8 right-8 w-16 h-16 bg-orange-300 dark:bg-orange-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-md opacity-25 animate-blob animation-delay-1200"></div><div class="hidden xl:block absolute bottom-10 left-1/2 -translate-x-1/2 w-28 h-28 bg-cyan-200 dark:bg-cyan-600 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-15 animate-blob animation-delay-2200"></div><div class="hidden 2xl:block absolute top-1/5 right-1/5 w-40 h-40 bg-indigo-200 dark:bg-indigo-600 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-2xl opacity-15 animate-blob animation-delay-5200"></div><div class="hidden lg:block absolute -top-24 left-1/3 w-96 h-96 bg-blue-100 dark:bg-blue-700 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-3xl opacity-10 animate-blob animation-delay-900"></div><div class="hidden lg:block absolute bottom-[-120px] left-[-80px] w-[420px] h-[420px] bg-purple-100 dark:bg-purple-700 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-3xl opacity-10 animate-blob animation-delay-1900"></div><div class="hidden xl:block absolute top-1/3 left-[70%] w-48 h-48 bg-pink-200 dark:bg-pink-600 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-2xl opacity-15 animate-blob animation-delay-3300"></div><div class="hidden xl:block absolute bottom-1/4 right-[35%] w-32 h-32 bg-cyan-300 dark:bg-cyan-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-15 animate-blob animation-delay-6100"></div><div class="hidden 2xl:block absolute top-[12%] left-[12%] w-56 h-56 bg-emerald-200 dark:bg-emerald-600 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-2xl opacity-15 animate-blob animation-delay-7100"></div><div class="hidden 2xl:block absolute bottom-[8%] right-[12%] w-64 h-64 bg-teal-200 dark:bg-teal-600 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-2xl opacity-15 animate-blob animation-delay-9100"></div></div></div>', 1)),
        createBaseVNode("div", _hoisted_2$1n, [
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "fade-up",
            threshold: 0.1,
            "root-margin": "0px"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_3$1k, [
                createBaseVNode("div", _hoisted_4$1f, [
                  _cache[18] || (_cache[18] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                    createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-indigo-500 rounded-full mr-2.5" })
                  ], -1)),
                  createBaseVNode("h1", _hoisted_5$1c, toDisplayString$1(unref(t)("vocabulary.header.title", "Vocabulary")), 1)
                ]),
                createVNode(unref(VocabularyHeader$1), { onAddVocabulary: unref(openAddDialog) }, null, 8, ["onAddVocabulary"])
              ])
            ]),
            _: 1
          })
        ]),
        createBaseVNode("div", _hoisted_6$19, [
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "slide-left",
            threshold: 0.1,
            "root-margin": "-50px"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_7$15, [
                createBaseVNode("div", _hoisted_8$13, [
                  _cache[19] || (_cache[19] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                    createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full mr-2.5" })
                  ], -1)),
                  createBaseVNode("h3", _hoisted_9$12, toDisplayString$1(unref(t)("vocabulary.filters.title", "Filters")), 1)
                ]),
                createVNode(unref(VocabularyFilters$1), {
                  "search-query": unref(searchQuery),
                  "selected-category": unref(selectedCategory),
                  "selected-level": unref(selectedLevel),
                  categories: categories.value,
                  "show-favorites-only": unref(showFavoritesOnly),
                  "onUpdate:searchQuery": unref(updateSearchQuery),
                  "onUpdate:selectedCategory": unref(updateSelectedCategory),
                  "onUpdate:selectedLevel": unref(updateSelectedLevel),
                  "onUpdate:showFavoritesOnly": unref(updateShowFavoritesOnly)
                }, null, 8, ["search-query", "selected-category", "selected-level", "categories", "show-favorites-only", "onUpdate:searchQuery", "onUpdate:selectedCategory", "onUpdate:selectedLevel", "onUpdate:showFavoritesOnly"])
              ])
            ]),
            _: 1
          }),
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "slide-right",
            threshold: 0.1,
            "root-margin": "-50px"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_10$11, [
                createBaseVNode("div", _hoisted_11$11, [
                  _cache[20] || (_cache[20] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                    createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-green-400 to-blue-500 rounded-full mr-2.5" })
                  ], -1)),
                  createBaseVNode("h3", _hoisted_12$_, toDisplayString$1(unref(t)("vocabulary.grouping.title", "Grouping & Move Mode")), 1)
                ]),
                createVNode(unref(GroupingToggle$1), {
                  "model-value": unref(useGrouping),
                  "hover-enabled": hoverToExpandEnabled.value,
                  "move-mode": unref(globalMoveMode),
                  "onUpdate:modelValue": unref(toggleGrouping),
                  "onUpdate:hoverEnabled": _cache[0] || (_cache[0] = ($event) => hoverToExpandEnabled.value = $event),
                  "onUpdate:moveMode": _cache[1] || (_cache[1] = ($event) => globalMoveMode.value = $event)
                }, null, 8, ["model-value", "hover-enabled", "move-mode", "onUpdate:modelValue"])
              ])
            ]),
            _: 1
          }),
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "scale",
            threshold: 0.1,
            "root-margin": "-50px"
          }, {
            default: withCtx(() => [
              createVNode(unref(BaseAccordion), {
                title: unref(t)("vocabulary.tools.accordionTitle", "Tools & Settings"),
                description: unref(t)("vocabulary.tools.accordionDescription", "Voice settings, topic manager, and save & sync options"),
                icon: "settings",
                "default-open": true,
                "persist-key": "vocabulary-tools",
                "status-text": formattedSaveStatusForAccordion.value,
                "status-color": unref(getSaveStatusColor),
                "show-status-when-closed": true,
                class: "mb-3 xs:mb-4 sm:mb-6"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_13$_, [
                    createBaseVNode("div", _hoisted_14$Z, [
                      createBaseVNode("div", _hoisted_15$T, [
                        _cache[21] || (_cache[21] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                          createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-purple-400 to-pink-500 rounded-full mr-2.5" })
                        ], -1)),
                        createBaseVNode("h3", _hoisted_16$S, toDisplayString$1(unref(t)("voice.settings.title", "Voice Settings")), 1)
                      ]),
                      createVNode(unref(VoiceSelector$1), { "show-voice-info": true })
                    ]),
                    createBaseVNode("div", _hoisted_17$R, [
                      createBaseVNode("div", _hoisted_18$P, [
                        _cache[22] || (_cache[22] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                          createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-yellow-400 to-orange-500 rounded-full mr-2.5" })
                        ], -1)),
                        createBaseVNode("h3", _hoisted_19$P, toDisplayString$1(unref(t)("vocabulary.topicManager.title", "Topic Manager")), 1)
                      ]),
                      createVNode(unref(TopicManagerPanel$1), { onOpen: unref(openTopicManager) }, null, 8, ["onOpen"])
                    ]),
                    createBaseVNode("div", _hoisted_20$O, [
                      createBaseVNode("div", _hoisted_21$O, [
                        _cache[23] || (_cache[23] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                          createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-cyan-400 to-blue-500 rounded-full mr-2.5" })
                        ], -1)),
                        createBaseVNode("h3", _hoisted_22$M, toDisplayString$1(unref(t)("vocabulary.save.title", "Save & Sync")), 1)
                      ]),
                      createVNode(unref(SaveControlPanel$1), {
                        "auto-save-enabled": unref(autoSaveEnabled),
                        "onUpdate:autoSaveEnabled": _cache[2] || (_cache[2] = ($event) => autoSaveEnabled.value = $event),
                        "is-saving": unref(isSaving),
                        "has-auto-save-file": unref(hasAutoSaveFile),
                        "onUpdate:hasAutoSaveFile": _cache[3] || (_cache[3] = ($event) => hasAutoSaveFile.value = $event),
                        "has-google-drive-file": unref(hasGoogleDriveFile),
                        "onUpdate:hasGoogleDriveFile": _cache[4] || (_cache[4] = ($event) => hasGoogleDriveFile.value = $event),
                        "storage-type": unref(storageType),
                        "onUpdate:storageType": _cache[5] || (_cache[5] = ($event) => storageType.value = $event),
                        "is-google-signed-in": unref(isGoogleSignedIn),
                        "onUpdate:isGoogleSignedIn": _cache[6] || (_cache[6] = ($event) => isGoogleSignedIn.value = $event),
                        "google-user-email": unref(googleUserEmail),
                        "google-auth-error": unref(googleAuthError),
                        "auto-save-file-path": unref(autoSaveFilePath),
                        "onUpdate:autoSaveFilePath": _cache[7] || (_cache[7] = ($event) => autoSaveFilePath.value = $event),
                        "last-save-time": unref(lastSaveTime),
                        "save-status-color": unref(getSaveStatusColor),
                        "save-status-text": unref(getSaveStatusText),
                        onManualSave: unref(manualSave),
                        onSetupAutoSave: unref(setupAutoSaveFile),
                        onSetupGoogleDrive: unref(setupGoogleDrive),
                        onGoogleSignIn: unref(handleGoogleSignIn),
                        onGoogleSignOut: unref(handleGoogleSignOut),
                        onSyncFromGoogleDrive: unref(syncFromGoogleDrive),
                        onResetAutoSave: unref(resetAutoSaveFile),
                        onImportFile: handleFileImportWithReload
                      }, null, 8, ["auto-save-enabled", "is-saving", "has-auto-save-file", "has-google-drive-file", "storage-type", "is-google-signed-in", "google-user-email", "google-auth-error", "auto-save-file-path", "last-save-time", "save-status-color", "save-status-text", "onManualSave", "onSetupAutoSave", "onSetupGoogleDrive", "onGoogleSignIn", "onGoogleSignOut", "onSyncFromGoogleDrive", "onResetAutoSave"])
                    ]),
                    createVNode(unref(DeleteAllVocabulariesPanel$1), {
                      "total-count": filteredVocabulary.value.length,
                      "auto-save-enabled": unref(autoSaveEnabled),
                      "use-grouping": unref(useGrouping),
                      onVocabulariesDeleted: handleVocabulariesDeleted,
                      onLocalStoreCleared: handleLocalStoreCleared
                    }, null, 8, ["total-count", "auto-save-enabled", "use-grouping"])
                  ])
                ]),
                _: 1
              }, 8, ["title", "description", "status-text", "status-color"])
            ]),
            _: 1
          }),
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "slide-left",
            threshold: 0.05,
            "root-margin": "-50px"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_23$M, [
                createVNode(unref(VocabularyList$1), {
                  "paginated-words": unref(useGrouping) ? [] : unref(paginatedVocabulary),
                  "current-page": unref(currentPage),
                  "total-pages": unref(totalPages),
                  "total-count": filteredVocabulary.value.length,
                  "start-index": unref(startIndex),
                  "end-index": unref(endIndex),
                  "visible-pages": unref(visiblePages),
                  "use-grouping": unref(useGrouping),
                  "all-words": unref(useGrouping) ? filteredVocabulary.value : void 0,
                  "date-group-pages": unref(dateGroupPages),
                  "items-per-page-grouped": unref(itemsPerPageGrouped),
                  "hover-to-expand-enabled": hoverToExpandEnabled.value,
                  "global-move-mode": unref(globalMoveMode),
                  "recently-added-category": recentlyAddedCategory.value,
                  onPlayAudio: playAudio,
                  onEditWord: unref(openEditDialog),
                  onDeleteWord: deleteWord,
                  onToggleFavorite: toggleFavorite,
                  onViewDetails: unref(openDetailsDialog),
                  onPreviousPage: unref(previousPage),
                  onNextPage: unref(nextPage),
                  onGoToPage: unref(goToPage),
                  onDateGroupPrevious: _cache[8] || (_cache[8] = (date) => unref(dateGroupPrevious)(date, filteredVocabulary.value)),
                  onDateGroupNext: _cache[9] || (_cache[9] = (date) => unref(dateGroupNext)(date, filteredVocabulary.value)),
                  onDateGroupGoToPage: unref(dateGroupGoToPage),
                  onMoveVocabulary: unref(handleMoveVocabulary),
                  onOpenNoteDialog: openNoteDialog,
                  onOpenAddVocabularyDialog: openAddVocabularyForDate,
                  onOpenGrammarManager: openGrammarManagerForDate,
                  onBatchMoveCategory: unref(handleBatchMoveCategory)
                }, null, 8, ["paginated-words", "current-page", "total-pages", "total-count", "start-index", "end-index", "visible-pages", "use-grouping", "all-words", "date-group-pages", "items-per-page-grouped", "hover-to-expand-enabled", "global-move-mode", "recently-added-category", "onEditWord", "onViewDetails", "onPreviousPage", "onNextPage", "onGoToPage", "onDateGroupGoToPage", "onMoveVocabulary", "onBatchMoveCategory"])
              ])
            ]),
            _: 1
          })
        ]),
        createVNode(unref(VocabularyFormDialog), {
          modelValue: unref(showFormDialog),
          "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => isRef(showFormDialog) ? showFormDialog.value = $event : null),
          vocabulary: unref(selectedVocabulary),
          "target-date": targetDateForNewVocabulary.value,
          onVocabularySaved
        }, null, 8, ["modelValue", "vocabulary", "target-date"]),
        createVNode(unref(VocabularyDetailDialog), {
          modelValue: unref(showDetailDialog),
          "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => isRef(showDetailDialog) ? showDetailDialog.value = $event : null),
          vocabulary: unref(selectedVocabularyForDetail),
          onEditVocabulary: unref(openEditFromDetail),
          onToggleFavorite: toggleFavorite
        }, null, 8, ["modelValue", "vocabulary", "onEditVocabulary"]),
        createVNode(unref(TopicManager), {
          modelValue: unref(showTopicManager),
          "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => isRef(showTopicManager) ? showTopicManager.value = $event : null),
          "vocabulary-usage": categoryUsage.value,
          onTopicAdded: unref(onTopicAdded),
          onTopicUpdated: unref(onTopicUpdated),
          onTopicDeleted: unref(onTopicDeleted)
        }, null, 8, ["modelValue", "vocabulary-usage", "onTopicAdded", "onTopicUpdated", "onTopicDeleted"]),
        createVNode(unref(VocabularyNoteDialog), {
          modelValue: showNoteDialog.value,
          "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => showNoteDialog.value = $event),
          date: noteDialogDate.value,
          "today-words": noteDialogWords.value,
          onSaveNote: handleNoteSaved
        }, null, 8, ["modelValue", "date", "today-words"]),
        createVNode(unref(GrammarManagerModal), {
          modelValue: showGrammarManagerModal.value,
          "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => showGrammarManagerModal.value = $event),
          selectedDate: grammarManagerDate.value
        }, null, 8, ["modelValue", "selectedDate"]),
        createVNode(Transition, { name: "fade-scale" }, {
          default: withCtx(() => [
            withDirectives(createBaseVNode("div", _hoisted_24$K, [
              createBaseVNode("button", {
                onClick: _cache[15] || (_cache[15] = //@ts-ignore
                (...args) => unref(openAddDialog) && unref(openAddDialog)(...args)),
                onMouseenter: _cache[16] || (_cache[16] = ($event) => showStickyTooltip.value = true),
                onMouseleave: _cache[17] || (_cache[17] = ($event) => showStickyTooltip.value = false),
                class: "relative bg-blue-500 hover:bg-blue-600 text-white font-medium w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 rounded-full shadow-lg hover:shadow-xl transition-all duration-300 transform hover:scale-105 flex items-center justify-center"
              }, [
                _cache[25] || (_cache[25] = createBaseVNode("svg", {
                  class: "w-6 h-6 sm:w-7 sm:h-7 md:w-8 md:h-8",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                    "clip-rule": "evenodd"
                  })
                ], -1)),
                showStickyTooltip.value ? (openBlock(), createElementBlock("div", _hoisted_25$K, [
                  createTextVNode(toDisplayString$1(unref(t)("vocabulary.addNew", "Add New Word")) + " ", 1),
                  _cache[24] || (_cache[24] = createBaseVNode("div", { class: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900 dark:border-t-black" }, null, -1))
                ])) : createCommentVNode("", true)
              ], 32)
            ], 512), [
              [vShow, showStickyButtonVisible.value]
            ])
          ]),
          _: 1
        }),
        createVNode(unref(MoveModal), {
          "show-modal": unref(showMoveModal),
          "word-to-move": unref(wordToMove),
          "available-date-groups": unref(availableDateGroups),
          "source-date": unref(currentSourceDate),
          "all-vocabularies": unref(vocabularyStore).allVocabularies.value,
          onClose: unref(closeMoveModal),
          onConfirmMove: unref(confirmMove)
        }, null, 8, ["show-modal", "word-to-move", "available-date-groups", "source-date", "all-vocabularies", "onClose", "onConfirmMove"])
      ]);
    };
  }
});

const _hoisted_1$1p = { class: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative overflow-x-hidden" };
const _hoisted_2$1m = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto px-2 xs:px-3 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 pt-3 sm:pt-6" };
const _hoisted_3$1j = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6 mb-3 xs:mb-4 sm:mb-6" };
const _hoisted_4$1e = { class: "flex items-center justify-between mb-4" };
const _hoisted_5$1b = { class: "flex items-center" };
const _hoisted_6$18 = { class: "text-lg sm:text-xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 dark:from-blue-400 dark:to-indigo-400 bg-clip-text text-transparent mb-2" };
const _hoisted_7$14 = { class: "text-sm sm:text-base text-gray-600 dark:text-gray-300" };
const _hoisted_8$12 = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto py-3 px-2 xs:py-4 xs:px-3 sm:py-6 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 overflow-x-hidden" };
const _hoisted_9$11 = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] mb-3 xs:mb-4 sm:mb-6 p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_10$10 = { class: "flex items-center mb-4" };
const _hoisted_11$10 = { class: "text-base sm:text-lg font-semibold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent" };
const _hoisted_12$Z = { class: "grid grid-cols-1 md:grid-cols-3 gap-4" };
const _hoisted_13$Z = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_14$Y = ["placeholder"];
const _hoisted_15$S = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_16$R = { value: "" };
const _hoisted_17$Q = ["value"];
const _hoisted_18$O = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_19$O = { value: "" };
const _hoisted_20$N = { value: "multiple-choice" };
const _hoisted_21$N = { value: "fill-blank" };
const _hoisted_22$L = { value: "true-false" };
const _hoisted_23$L = { value: "short-answer" };
const _hoisted_24$J = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto py-3 px-2 xs:py-4 xs:px-3 sm:py-6 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 overflow-x-hidden" };
const _hoisted_25$J = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_26$H = { class: "flex items-center mb-4" };
const _hoisted_27$G = { class: "text-base sm:text-lg font-semibold bg-gradient-to-r from-green-600 to-blue-600 dark:from-green-400 dark:to-blue-400 bg-clip-text text-transparent" };
const _hoisted_28$E = { class: "space-y-4" };
const _hoisted_29$C = {
  key: 0,
  class: "text-center py-8"
};
const _hoisted_30$A = { class: "text-gray-500 dark:text-gray-400" };
const _hoisted_31$z = { class: "flex items-start justify-between" };
const _hoisted_32$w = { class: "flex-1" };
const _hoisted_33$v = { class: "flex items-center gap-3 mb-3" };
const _hoisted_34$s = {
  key: 1,
  class: "text-sm text-gray-600 dark:text-gray-400"
};
const _hoisted_35$s = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-2" };
const _hoisted_36$r = {
  key: 0,
  class: "mb-3"
};
const _hoisted_37$q = { class: "grid grid-cols-1 sm:grid-cols-2 gap-2" };
const _hoisted_38$q = {
  key: 1,
  class: "mb-3"
};
const _hoisted_39$o = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_40$o = { class: "ml-2 px-2 py-1 bg-green-50/50 dark:bg-green-900/20 text-green-700 dark:text-green-400 rounded" };
const _hoisted_41$n = {
  key: 2,
  class: "mb-3"
};
const _hoisted_42$l = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_43$k = { class: "text-xs text-gray-500 dark:text-gray-400" };
const _hoisted_44$j = { class: "flex items-center gap-2 ml-4" };
const _hoisted_45$i = ["onClick"];
const _hoisted_46$i = ["onClick"];
const _sfc_main$1q = /* @__PURE__ */ defineComponent({
  __name: "VocabularyQuestionsView",
  setup(__props) {
    const QuestionFormDialog$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => QuestionFormDialog),true              ?void 0:void 0));
    const { t } = useI18n();
    const vocabularyStore = useVocabularyStore();
    const questions = ref([]);
    const showCreateDialog = ref(false);
    const showEditDialog = ref(false);
    const currentQuestion = ref(null);
    const searchTerm = ref("");
    const selectedVocabulary = ref("");
    const selectedType = ref("");
    const vocabularyList = computed(() => vocabularyStore.allVocabularies.value.map((v) => ({ id: v.id.toString(), word: v.word, meaning: v.meaning })));
    const filteredQuestions = computed(() => {
      let filtered = questions.value;
      if (searchTerm.value) {
        const term = searchTerm.value.toLowerCase();
        filtered = filtered.filter(
          (q) => q.question.toLowerCase().includes(term) || q.vocabulary?.word.toLowerCase().includes(term)
        );
      }
      if (selectedVocabulary.value) {
        filtered = filtered.filter((q) => q.vocabularyId === selectedVocabulary.value);
      }
      if (selectedType.value) {
        filtered = filtered.filter((q) => q.type === selectedType.value);
      }
      return filtered;
    });
    const loadQuestions = () => {
      const stored = localStorage.getItem("vocabulary-questions");
      if (stored) {
        questions.value = JSON.parse(stored);
        questions.value.forEach((question) => {
          const vocab = vocabularyList.value.find((v) => v.id === question.vocabularyId);
          if (vocab) {
            question.vocabulary = { id: vocab.id, word: vocab.word };
          }
        });
      }
    };
    const saveQuestionsToStorage = () => {
      localStorage.setItem("vocabulary-questions", JSON.stringify(questions.value));
    };
    const editQuestion = (question) => {
      currentQuestion.value = { ...question };
      showEditDialog.value = true;
    };
    const deleteQuestion = (question) => {
      if (confirm(t("vocabulary.questions.confirmDelete", "Are you sure you want to delete this question?"))) {
        questions.value = questions.value.filter((q) => q.id !== question.id);
        saveQuestionsToStorage();
      }
    };
    const saveQuestion = (questionData) => {
      if (currentQuestion.value && showEditDialog.value) {
        const index = questions.value.findIndex((q) => q.id === currentQuestion.value.id);
        if (index !== -1) {
          questions.value[index] = {
            ...questions.value[index],
            vocabularyId: questionData.vocabularyId || questions.value[index].vocabularyId,
            question: questionData.question || questions.value[index].question,
            type: questionData.type || questions.value[index].type,
            options: questionData.options || questions.value[index].options,
            correctAnswer: questionData.correctAnswer || questions.value[index].correctAnswer,
            difficulty: questionData.difficulty || questions.value[index].difficulty,
            explanation: questionData.explanation || questions.value[index].explanation,
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          const vocab = vocabularyList.value.find((v) => v.id === questions.value[index].vocabularyId);
          if (vocab) {
            questions.value[index].vocabulary = { id: vocab.id, word: vocab.word };
          }
        }
      } else {
        const newQuestion = {
          id: Date.now().toString(),
          vocabularyId: questionData.vocabularyId,
          question: questionData.question,
          type: questionData.type,
          options: questionData.options,
          correctAnswer: questionData.correctAnswer,
          difficulty: questionData.difficulty || "medium",
          explanation: questionData.explanation,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        const vocab = vocabularyList.value.find((v) => v.id === newQuestion.vocabularyId);
        if (vocab) {
          newQuestion.vocabulary = { id: vocab.id, word: vocab.word };
        }
        questions.value.push(newQuestion);
      }
      saveQuestionsToStorage();
      closeDialog();
    };
    const openCreateDialog = () => {
      currentQuestion.value = null;
      showCreateDialog.value = true;
    };
    const closeDialog = () => {
      showCreateDialog.value = false;
      showEditDialog.value = false;
      currentQuestion.value = null;
    };
    const getTypeLabel = (type) => {
      const labels = {
        "multiple-choice": t("vocabulary.questions.types.multipleChoice", "Multiple Choice"),
        "fill-blank": t("vocabulary.questions.types.fillBlank", "Fill in the Blank"),
        "true-false": t("vocabulary.questions.types.trueFalse", "True/False"),
        "short-answer": t("vocabulary.questions.types.shortAnswer", "Short Answer")
      };
      return labels[type] || type;
    };
    const getTypeColorClass = (type) => {
      const classes = {
        "multiple-choice": "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300",
        "fill-blank": "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300",
        "true-false": "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300",
        "short-answer": "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-300"
      };
      return classes[type] || "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300";
    };
    const getDifficultyLabel = (difficulty) => {
      if (!difficulty) return "";
      const labels = {
        "easy": t("common.easy", "Easy"),
        "medium": t("vocabulary.questions.difficulty.medium", "Medium"),
        "hard": t("common.difficult", "Difficult")
      };
      return labels[difficulty] || difficulty;
    };
    const getDifficultyColorClass = (difficulty) => {
      const classes = {
        "easy": "text-green-600 dark:text-green-400",
        "medium": "text-yellow-600 dark:text-yellow-400",
        "hard": "text-red-600 dark:text-red-400"
      };
      return classes[difficulty] || "text-gray-600 dark:text-gray-400";
    };
    const formatDate = (dateString) => {
      return new Date(dateString).toLocaleDateString();
    };
    onMounted(() => {
      loadQuestions();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1p, [
        _cache[7] || (_cache[7] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0"><div class="floating-shapes"><div class="absolute top-20 left-10 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob"></div><div class="absolute top-40 right-10 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000"></div><div class="absolute -bottom-8 left-20 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000"></div><div class="hidden sm:block absolute top-10 left-1/2 -translate-x-1/2 w-40 h-40 bg-cyan-300 dark:bg-cyan-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-1000"></div><div class="hidden sm:block absolute bottom-24 right-24 w-52 h-52 bg-indigo-300 dark:bg-indigo-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-3000"></div></div></div>', 1)),
        createBaseVNode("div", _hoisted_2$1m, [
          createBaseVNode("div", _hoisted_3$1j, [
            createBaseVNode("div", _hoisted_4$1e, [
              createBaseVNode("div", _hoisted_5$1b, [
                _cache[3] || (_cache[3] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                  createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-indigo-500 rounded-full mr-2.5" })
                ], -1)),
                createBaseVNode("div", null, [
                  createBaseVNode("h1", _hoisted_6$18, toDisplayString$1(unref(t)("vocabulary.questions.title", "Question Manager")), 1),
                  createBaseVNode("p", _hoisted_7$14, toDisplayString$1(unref(t)("vocabulary.questions.description", "Create and manage questions based on your vocabulary words")), 1)
                ])
              ]),
              createBaseVNode("button", {
                onClick: openCreateDialog,
                class: "px-4 sm:px-6 py-2 sm:py-3 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white rounded-lg font-medium transition-all duration-300 shadow-lg hover:shadow-xl"
              }, toDisplayString$1(unref(t)("vocabulary.questions.addQuestion", "Add New Question")), 1)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_8$12, [
          createBaseVNode("div", _hoisted_9$11, [
            createBaseVNode("div", _hoisted_10$10, [
              _cache[4] || (_cache[4] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full mr-2.5" })
              ], -1)),
              createBaseVNode("h3", _hoisted_11$10, toDisplayString$1(unref(t)("vocabulary.filters.title", "Filters")), 1)
            ]),
            createBaseVNode("div", _hoisted_12$Z, [
              createBaseVNode("div", null, [
                createBaseVNode("label", _hoisted_13$Z, toDisplayString$1(unref(t)("vocabulary.questions.searchQuestions", "Search questions...")), 1),
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchTerm.value = $event),
                  type: "text",
                  placeholder: unref(t)("vocabulary.questions.searchQuestions", "Search questions..."),
                  class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white/50 dark:bg-[#0a0a0a]/50 backdrop-blur-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900 dark:text-white transition-all duration-300"
                }, null, 8, _hoisted_14$Y), [
                  [vModelText, searchTerm.value]
                ])
              ]),
              createBaseVNode("div", null, [
                createBaseVNode("label", _hoisted_15$S, toDisplayString$1(unref(t)("vocabulary.questions.filterByVocabulary", "Filter by vocabulary")), 1),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedVocabulary.value = $event),
                  class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white/50 dark:bg-[#0a0a0a]/50 backdrop-blur-sm text-gray-900 dark:text-white transition-all duration-300"
                }, [
                  createBaseVNode("option", _hoisted_16$R, toDisplayString$1(unref(t)("vocabulary.questions.allVocabulary", "All Vocabulary")), 1),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(vocabularyList.value, (vocab) => {
                    return openBlock(), createElementBlock("option", {
                      key: vocab.id,
                      value: vocab.id
                    }, toDisplayString$1(vocab.word) + " - " + toDisplayString$1(vocab.meaning), 9, _hoisted_17$Q);
                  }), 128))
                ], 512), [
                  [vModelSelect, selectedVocabulary.value]
                ])
              ]),
              createBaseVNode("div", null, [
                createBaseVNode("label", _hoisted_18$O, toDisplayString$1(unref(t)("vocabulary.questions.filterByType", "Filter by type")), 1),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => selectedType.value = $event),
                  class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white/50 dark:bg-[#0a0a0a]/50 backdrop-blur-sm text-gray-900 dark:text-white transition-all duration-300"
                }, [
                  createBaseVNode("option", _hoisted_19$O, toDisplayString$1(unref(t)("vocabulary.questions.allTypes", "All Types")), 1),
                  createBaseVNode("option", _hoisted_20$N, toDisplayString$1(unref(t)("vocabulary.questions.multipleChoice", "Multiple Choice")), 1),
                  createBaseVNode("option", _hoisted_21$N, toDisplayString$1(unref(t)("vocabulary.questions.fillBlank", "Fill in the Blank")), 1),
                  createBaseVNode("option", _hoisted_22$L, toDisplayString$1(unref(t)("vocabulary.questions.trueFalse", "True/False")), 1),
                  createBaseVNode("option", _hoisted_23$L, toDisplayString$1(unref(t)("vocabulary.questions.shortAnswer", "Short Answer")), 1)
                ], 512), [
                  [vModelSelect, selectedType.value]
                ])
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_24$J, [
          createBaseVNode("div", _hoisted_25$J, [
            createBaseVNode("div", _hoisted_26$H, [
              _cache[5] || (_cache[5] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-green-400 to-blue-500 rounded-full mr-2.5" })
              ], -1)),
              createBaseVNode("h3", _hoisted_27$G, toDisplayString$1(unref(t)("vocabulary.questions.title", "Questions List")), 1)
            ]),
            createBaseVNode("div", _hoisted_28$E, [
              filteredQuestions.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_29$C, [
                _cache[6] || (_cache[6] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                  createBaseVNode("div", { class: "w-3 h-3 bg-gradient-to-r from-gray-400 to-gray-500 rounded-full mx-auto mb-3" })
                ], -1)),
                createBaseVNode("p", _hoisted_30$A, toDisplayString$1(unref(t)("vocabulary.questions.noQuestions", "No questions found")), 1)
              ])) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredQuestions.value, (question) => {
                return openBlock(), createElementBlock("div", {
                  key: question.id,
                  class: "bg-white/60 dark:bg-[#0a0a0a]/60 backdrop-blur-sm rounded-xl border border-white/20 dark:border-white/10 p-3 sm:p-4 md:p-5 hover:shadow-lg transition-all duration-300 hover:scale-[1.002]"
                }, [
                  createBaseVNode("div", _hoisted_31$z, [
                    createBaseVNode("div", _hoisted_32$w, [
                      createBaseVNode("div", _hoisted_33$v, [
                        createBaseVNode("span", {
                          class: normalizeClass(["px-2 py-1 text-xs font-medium rounded-full", getTypeColorClass(question.type)])
                        }, toDisplayString$1(getTypeLabel(question.type)), 3),
                        question.difficulty ? (openBlock(), createElementBlock("span", {
                          key: 0,
                          class: normalizeClass(["px-2 py-1 text-xs font-medium rounded-full", getDifficultyColorClass(question.difficulty)])
                        }, toDisplayString$1(getDifficultyLabel(question.difficulty)), 3)) : createCommentVNode("", true),
                        question.vocabulary ? (openBlock(), createElementBlock("span", _hoisted_34$s, toDisplayString$1(question.vocabulary.word), 1)) : createCommentVNode("", true)
                      ]),
                      createBaseVNode("h3", _hoisted_35$s, toDisplayString$1(question.question), 1),
                      question.options && question.type === "multiple-choice" ? (openBlock(), createElementBlock("div", _hoisted_36$r, [
                        createBaseVNode("div", _hoisted_37$q, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(question.options, (option, index) => {
                            return openBlock(), createElementBlock("div", {
                              key: index,
                              class: normalizeClass(["px-3 py-2 bg-white/50 dark:bg-[#0a0a0a]/50 backdrop-blur-sm rounded border border-gray-200 dark:border-white/10", { "border-green-500 bg-green-50/50 dark:bg-green-900/20": index === Number(question.correctAnswer) }])
                            }, toDisplayString$1(option), 3);
                          }), 128))
                        ])
                      ])) : (openBlock(), createElementBlock("div", _hoisted_38$q, [
                        createBaseVNode("p", _hoisted_39$o, [
                          createBaseVNode("strong", null, toDisplayString$1(unref(t)("vocabulary.questions.correctAnswer", "Correct Answer")) + ":", 1),
                          createBaseVNode("span", _hoisted_40$o, toDisplayString$1(question.correctAnswer), 1)
                        ])
                      ])),
                      question.explanation ? (openBlock(), createElementBlock("div", _hoisted_41$n, [
                        createBaseVNode("p", _hoisted_42$l, [
                          createBaseVNode("strong", null, toDisplayString$1(unref(t)("vocabulary.questions.explanation", "Explanation")) + ":", 1),
                          createTextVNode(" " + toDisplayString$1(question.explanation), 1)
                        ])
                      ])) : createCommentVNode("", true),
                      createBaseVNode("p", _hoisted_43$k, toDisplayString$1(unref(t)("vocabulary.questions.createdAt", "Created At")) + ": " + toDisplayString$1(formatDate(question.createdAt)), 1)
                    ]),
                    createBaseVNode("div", _hoisted_44$j, [
                      createBaseVNode("button", {
                        onClick: ($event) => editQuestion(question),
                        class: "px-3 py-2 text-blue-600 hover:text-blue-700 hover:bg-blue-50/50 dark:text-blue-400 dark:hover:text-blue-300 dark:hover:bg-blue-900/20 rounded-lg transition-all duration-300"
                      }, toDisplayString$1(unref(t)("common.edit", "Edit")), 9, _hoisted_45$i),
                      createBaseVNode("button", {
                        onClick: ($event) => deleteQuestion(question),
                        class: "px-3 py-2 text-red-600 hover:text-red-700 hover:bg-red-50/50 dark:text-red-400 dark:hover:text-red-300 dark:hover:bg-red-900/20 rounded-lg transition-all duration-300"
                      }, toDisplayString$1(unref(t)("common.delete", "Delete")), 9, _hoisted_46$i)
                    ])
                  ])
                ]);
              }), 128))
            ])
          ])
        ]),
        showCreateDialog.value || showEditDialog.value ? (openBlock(), createBlock(unref(QuestionFormDialog$1), {
          key: 0,
          show: showCreateDialog.value || showEditDialog.value,
          question: currentQuestion.value,
          "vocabulary-list": vocabularyList.value,
          onClose: closeDialog,
          onSave: saveQuestion
        }, null, 8, ["show", "question", "vocabulary-list"])) : createCommentVNode("", true)
      ]);
    };
  }
});

class AudioSystem {
  voiceStore = useVoiceStore();
  createAudioContext() {
    try {
      return new (window.AudioContext || window.webkitAudioContext)();
    } catch (error) {
      console.log("Audio context not available");
      return null;
    }
  }
  playImpactSound() {
    const audioContext = this.createAudioContext();
    if (!audioContext) return;
    try {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
      gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
      oscillator.type = "sine";
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.15);
    } catch (error) {
      console.log("Impact sound failed:", error);
    }
  }
  playExplosionSound() {
    const audioContext = this.createAudioContext();
    if (!audioContext) return;
    try {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      const filterNode = audioContext.createBiquadFilter();
      oscillator.connect(filterNode);
      filterNode.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.3);
      filterNode.frequency.setValueAtTime(2e3, audioContext.currentTime);
      filterNode.frequency.exponentialRampToValueAtTime(500, audioContext.currentTime + 0.3);
      filterNode.Q.setValueAtTime(3, audioContext.currentTime);
      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      oscillator.type = "sawtooth";
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.3);
    } catch (error) {
      console.log("Explosion sound failed:", error);
    }
  }
  playBounceSound() {
    const audioContext = this.createAudioContext();
    if (!audioContext) return;
    try {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.08);
      gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
      oscillator.type = "triangle";
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.08);
    } catch (error) {
      console.log("Bounce sound failed:", error);
    }
  }
  playVocabularySound(text, language = "en") {
    try {
      if (!("speechSynthesis" in window)) {
        console.log("Speech Synthesis not supported");
        return;
      }
      window.speechSynthesis.cancel();
      const utterance = this.voiceStore.createUtterance(text);
      if (language === "vi") {
        utterance.lang = "vi-VN";
        const vietnameseVoices = window.speechSynthesis.getVoices().filter(
          (voice) => voice.lang.startsWith("vi")
        );
        if (vietnameseVoices.length > 0) {
          utterance.voice = vietnameseVoices[0];
        }
      } else if (language === "ko") {
        utterance.lang = "ko-KR";
        const koreanVoices = window.speechSynthesis.getVoices().filter(
          (voice) => voice.lang.startsWith("ko")
        );
        if (koreanVoices.length > 0) {
          utterance.voice = koreanVoices[0];
        }
      }
      window.speechSynthesis.speak(utterance);
    } catch (error) {
      console.log("Vocabulary sound failed:", error);
    }
  }
}
const useAudioSystem = () => {
  return new AudioSystem();
};

const _hoisted_1$1o = { class: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative overflow-x-hidden" };
const _hoisted_2$1l = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto px-2 xs:px-3 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 pt-3 sm:pt-6" };
const _hoisted_3$1i = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6 mb-3 xs:mb-4 sm:mb-6" };
const _hoisted_4$1d = { class: "flex flex-col xs:flex-col sm:flex-row items-start xs:items-start sm:items-center justify-between mb-3 xs:mb-3 sm:mb-4 gap-3 xs:gap-3 sm:gap-4" };
const _hoisted_5$1a = { class: "flex items-center" };
const _hoisted_6$17 = { class: "text-base xs:text-lg sm:text-xl md:text-xl font-bold bg-gradient-to-r from-green-600 to-emerald-600 dark:from-green-400 dark:to-emerald-400 bg-clip-text text-transparent mb-1 xs:mb-1 sm:mb-2" };
const _hoisted_7$13 = { class: "text-xs xs:text-sm sm:text-base md:text-base text-gray-600 dark:text-gray-300" };
const _hoisted_8$11 = { class: "flex items-center space-x-2 xs:space-x-3 sm:space-x-4" };
const _hoisted_9$10 = { class: "flex items-center space-x-2 xs:space-x-2 sm:space-x-3" };
const _hoisted_10$$ = { class: "text-xs xs:text-sm sm:text-sm md:text-sm font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_11$$ = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto py-3 px-2 xs:py-4 xs:px-3 sm:py-6 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 overflow-x-hidden" };
const _hoisted_12$Y = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] mb-3 xs:mb-4 sm:mb-6 p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_13$Y = { class: "flex items-center mb-3 xs:mb-3 sm:mb-4" };
const _hoisted_14$X = { class: "text-sm xs:text-base sm:text-lg md:text-lg font-semibold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent" };
const _hoisted_15$R = { class: "relative" };
const _hoisted_16$Q = ["placeholder"];
const _hoisted_17$P = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto py-3 px-2 xs:py-4 xs:px-3 sm:py-6 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 overflow-x-hidden" };
const _hoisted_18$N = { class: "space-y-6" };
const _hoisted_19$N = {
  key: 0,
  class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6"
};
const _hoisted_20$M = { class: "text-center py-6 xs:py-6 sm:py-8" };
const _hoisted_21$M = { class: "text-base xs:text-lg sm:text-lg md:text-lg font-medium text-gray-900 dark:text-white mb-1 xs:mb-1 sm:mb-2" };
const _hoisted_22$K = { class: "text-xs xs:text-sm sm:text-base md:text-base text-gray-600 dark:text-gray-300" };
const _hoisted_23$K = ["onClick"];
const _hoisted_24$I = { class: "flex items-start space-x-2 xs:space-x-2 sm:space-x-3 flex-1" };
const _hoisted_25$I = { class: "flex-1 min-w-0" };
const _hoisted_26$G = { class: "flex items-center space-x-1 xs:space-x-1 sm:space-x-2 mb-1" };
const _hoisted_27$F = { class: "text-base xs:text-lg sm:text-lg md:text-lg font-bold text-gray-900 dark:text-white truncate" };
const _hoisted_28$D = ["onClick", "title"];
const _hoisted_29$B = ["onClick", "title"];
const _hoisted_30$z = { class: "text-xs xs:text-sm sm:text-sm md:text-sm text-gray-600 dark:text-gray-300 mb-1 xs:mb-1 sm:mb-2" };
const _hoisted_31$y = { class: "flex items-center space-x-1 xs:space-x-1 sm:space-x-2" };
const _hoisted_32$v = { class: "inline-flex items-center px-1.5 xs:px-2 sm:px-2.5 py-0.5 rounded-full text-2xs xs:text-xs sm:text-xs font-medium bg-blue-100 text-blue-800 dark:bg-blue-900/20 dark:text-blue-300" };
const _hoisted_33$u = { class: "text-2xs xs:text-xs sm:text-xs text-gray-500 dark:text-gray-400" };
const _hoisted_34$r = ["onClick"];
const _hoisted_35$r = { class: "hidden xs:inline sm:inline" };
const _hoisted_36$q = { class: "xs:hidden sm:hidden" };
const _hoisted_37$p = {
  key: 0,
  class: "border-t border-slate-200 dark:border-dark-bg-mute bg-slate-50 dark:bg-dark-bg-mute"
};
const _hoisted_38$p = {
  key: 0,
  class: "p-3 xs:p-4 sm:p-6 text-center text-slate-500 dark:text-slate-400"
};
const _hoisted_39$n = { class: "text-xs xs:text-sm sm:text-base" };
const _hoisted_40$n = { key: 1 };
const _hoisted_41$m = { class: "p-2 xs:p-3 sm:p-4 space-y-2 xs:space-y-3 sm:space-y-4" };
const _hoisted_42$k = { class: "flex flex-col sm:flex-row sm:items-start sm:justify-between gap-2 xs:gap-2 sm:gap-3" };
const _hoisted_43$j = { class: "flex-1 min-w-0" };
const _hoisted_44$i = { class: "flex items-center gap-1 xs:gap-1 sm:gap-2 mb-1 xs:mb-1 sm:mb-2" };
const _hoisted_45$h = { class: "text-xs xs:text-sm sm:text-sm md:text-sm font-medium text-slate-900 dark:text-slate-100 truncate flex-1" };
const _hoisted_46$h = ["onClick", "title"];
const _hoisted_47$h = { class: "text-slate-700 dark:text-slate-300 text-xs xs:text-sm sm:text-sm md:text-sm mb-1 xs:mb-1 sm:mb-2 leading-relaxed" };
const _hoisted_48$h = { class: "flex flex-wrap gap-1 xs:gap-1 sm:gap-2 text-2xs xs:text-xs sm:text-xs" };
const _hoisted_49$g = { class: "px-1.5 xs:px-2 sm:px-2 py-0.5 bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200 rounded-full capitalize" };
const _hoisted_50$f = {
  key: 0,
  class: "px-1.5 xs:px-2 sm:px-2 py-0.5 bg-orange-100 dark:bg-orange-900/30 text-orange-800 dark:text-orange-200 rounded-full capitalize"
};
const _hoisted_51$e = {
  key: 1,
  class: "px-1.5 xs:px-2 sm:px-2 py-0.5 bg-purple-100 dark:bg-purple-900/30 text-purple-800 dark:text-purple-200 rounded-full"
};
const _hoisted_52$d = { class: "flex flex-row xs:flex-row sm:flex-row gap-1 xs:gap-1 sm:gap-2 flex-shrink-0 mt-2 xs:mt-0 sm:mt-0" };
const _hoisted_53$d = ["onClick"];
const _hoisted_54$d = { class: "hidden xs:inline sm:inline" };
const _hoisted_55$d = ["onClick"];
const _hoisted_56$c = { class: "hidden xs:inline sm:inline" };
const _hoisted_57$c = {
  key: 0,
  class: "border-t border-slate-200 dark:border-dark-bg-mute px-2 xs:px-3 sm:px-4 py-2 xs:py-2 sm:py-3"
};
const _hoisted_58$c = { class: "flex items-center justify-between" };
const _hoisted_59$b = { class: "flex sm:hidden items-center gap-1 xs:gap-1 sm:gap-2" };
const _hoisted_60$b = ["onClick", "disabled"];
const _hoisted_61$a = { class: "text-2xs xs:text-xs text-slate-600 dark:text-slate-400 px-1" };
const _hoisted_62$a = ["onClick", "disabled"];
const _hoisted_63$8 = { class: "hidden sm:flex items-center gap-2" };
const _hoisted_64$8 = ["onClick", "disabled"];
const _hoisted_65$8 = { class: "flex gap-1" };
const _hoisted_66$8 = ["onClick"];
const _hoisted_67$7 = ["onClick", "disabled"];
const _hoisted_68$6 = { class: "text-2xs xs:text-xs sm:text-xs text-slate-500 dark:text-slate-400" };
const _hoisted_69$6 = {
  key: 0,
  class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-4"
};
const _hoisted_70$6 = { class: "flex items-center justify-between" };
const _hoisted_71$6 = { class: "flex-1 flex justify-between sm:hidden" };
const _hoisted_72$6 = ["disabled"];
const _hoisted_73$6 = { class: "flex items-center px-2" };
const _hoisted_74$6 = { class: "text-2xs xs:text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_75$5 = ["disabled"];
const _hoisted_76$5 = { class: "hidden sm:flex-1 sm:flex sm:items-center sm:justify-between" };
const _hoisted_77$5 = { class: "text-xs xs:text-sm sm:text-sm md:text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_78$4 = { class: "relative z-0 inline-flex rounded-md shadow-sm -space-x-px" };
const _hoisted_79$4 = ["disabled"];
const _hoisted_80$4 = { class: "sr-only" };
const _hoisted_81$4 = ["onClick"];
const _hoisted_82$4 = ["disabled"];
const _hoisted_83$4 = { class: "sr-only" };
const _sfc_main$1p = /* @__PURE__ */ defineComponent({
  __name: "VocabularyExamplesView",
  setup(__props) {
    const TopicGroupAccordion = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => TopicGroupAccordion$1),true              ?void 0:void 0));
    const ExampleFormDialog$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ExampleFormDialog),true              ?void 0:void 0));
    const ConfirmToast$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ConfirmToast),true              ?void 0:void 0));
    const { t } = useI18n();
    const toast = useToast();
    const vocabularyStore = useVocabularyStore();
    const audioSystem = useAudioSystem();
    const examples = ref([]);
    const showCreateDialog = ref(false);
    const showEditDialog = ref(false);
    const currentExample = ref(null);
    const searchTerm = ref("");
    const selectedVocabulary = ref("");
    const selectedType = ref("");
    const groupByTopic = ref(false);
    const currentPage = ref(1);
    const itemsPerPage = ref(5);
    const expandedExamples = ref({});
    const examplePages = ref({});
    const examplesPerPage = ref(5);
    const vocabularyList = computed(() => vocabularyStore.allVocabularies.value.map((v) => ({
      id: v.id.toString(),
      word: v.word,
      meaning: v.meaning,
      partOfSpeech: v.partOfSpeech || "unknown",
      category: v.category || "uncategorized",
      level: v.level || "unknown"
    })));
    const filteredVocabulary = computed(() => {
      let filtered = vocabularyList.value;
      if (searchTerm.value) {
        const term = searchTerm.value.toLowerCase();
        filtered = filtered.filter(
          (v) => v.word.toLowerCase().includes(term) || v.meaning.toLowerCase().includes(term)
        );
      }
      return filtered;
    });
    const totalPages = computed(() => {
      if (groupByTopic.value) return 1;
      return Math.ceil(filteredVocabulary.value.length / itemsPerPage.value);
    });
    const paginatedVocabulary = computed(() => {
      if (groupByTopic.value) return filteredVocabulary.value;
      const start = (currentPage.value - 1) * itemsPerPage.value;
      const end = start + itemsPerPage.value;
      return filteredVocabulary.value.slice(start, end);
    });
    const startIndex = computed(() => {
      if (groupByTopic.value) return 1;
      return (currentPage.value - 1) * itemsPerPage.value + 1;
    });
    const endIndex = computed(() => {
      if (groupByTopic.value) return filteredVocabulary.value.length;
      return Math.min(currentPage.value * itemsPerPage.value, filteredVocabulary.value.length);
    });
    const visiblePages = computed(() => {
      const pages = [];
      const maxVisible = 5;
      const totalP = totalPages.value;
      if (totalP <= maxVisible) {
        for (let i = 1; i <= totalP; i++) {
          pages.push(i);
        }
      } else {
        const start = Math.max(1, currentPage.value - Math.floor(maxVisible / 2));
        const end = Math.min(totalP, start + maxVisible - 1);
        for (let i = start; i <= end; i++) {
          pages.push(i);
        }
      }
      return pages;
    });
    computed(() => {
      let filtered = examples.value;
      if (searchTerm.value) {
        const term = searchTerm.value.toLowerCase();
        filtered = filtered.filter(
          (e) => e.title.toLowerCase().includes(term) || e.content.toLowerCase().includes(term) || e.vocabulary?.word.toLowerCase().includes(term)
        );
      }
      if (selectedVocabulary.value) {
        filtered = filtered.filter((e) => e.vocabularyId === selectedVocabulary.value);
      }
      if (selectedType.value) {
        filtered = filtered.filter((e) => e.type === selectedType.value);
      }
      return filtered;
    });
    const loadExamples = () => {
      const stored = localStorage.getItem("vocabulary-examples");
      if (stored) {
        examples.value = JSON.parse(stored);
        examples.value.forEach((example) => {
          const vocab = vocabularyList.value.find((v) => v.id === example.vocabularyId);
          if (vocab) {
            example.vocabulary = { id: vocab.id, word: vocab.word };
          }
        });
      }
    };
    const saveExamplesToStorage = () => {
      localStorage.setItem("vocabulary-examples", JSON.stringify(examples.value));
    };
    const getVocabExamples = (vocabId) => {
      return examples.value.filter((e) => e.vocabularyId === vocabId);
    };
    const getPaginatedVocabExamples = (vocabId) => {
      const allExamples = getVocabExamples(vocabId);
      const currentPage2 = examplePages.value[vocabId] || 1;
      const start = (currentPage2 - 1) * examplesPerPage.value;
      const end = start + examplesPerPage.value;
      return allExamples.slice(start, end);
    };
    const getVocabExamplePages = (vocabId) => {
      const totalExamples = getVocabExamples(vocabId).length;
      return Math.ceil(totalExamples / examplesPerPage.value);
    };
    const goToExamplePage = (vocabId, page) => {
      const totalPages2 = getVocabExamplePages(vocabId);
      if (page >= 1 && page <= totalPages2) {
        examplePages.value[vocabId] = page;
        saveExamplePagesState();
      }
    };
    const previousExamplePage = (vocabId) => {
      const currentPage2 = examplePages.value[vocabId] || 1;
      if (currentPage2 > 1) {
        goToExamplePage(vocabId, currentPage2 - 1);
      }
    };
    const nextExamplePage = (vocabId) => {
      const currentPage2 = examplePages.value[vocabId] || 1;
      const totalPages2 = getVocabExamplePages(vocabId);
      if (currentPage2 < totalPages2) {
        goToExamplePage(vocabId, currentPage2 + 1);
      }
    };
    const getExamplePaginationInfo = (vocabId) => {
      const totalExamples = getVocabExamples(vocabId).length;
      const currentPage2 = examplePages.value[vocabId] || 1;
      const totalPages2 = getVocabExamplePages(vocabId);
      const start = (currentPage2 - 1) * examplesPerPage.value + 1;
      const end = Math.min(currentPage2 * examplesPerPage.value, totalExamples);
      return {
        totalExamples,
        totalPages: totalPages2,
        currentPage: currentPage2,
        start,
        end,
        hasNext: currentPage2 < totalPages2,
        hasPrevious: currentPage2 > 1
      };
    };
    const getVocabExampleCount = (vocabId) => {
      return examples.value.filter((e) => e.vocabularyId === vocabId).length;
    };
    const openCreateDialogForVocab = (vocab) => {
      currentExample.value = null;
      selectedVocabulary.value = vocab.id;
      showCreateDialog.value = true;
    };
    const editExample = (example) => {
      currentExample.value = { ...example };
      showEditDialog.value = true;
    };
    const deleteExample = (example) => {
      const toastId = toast(
        {
          component: ConfirmToast$1,
          props: {
            message: t("vocabulary.examples.confirmDelete", "Are you sure you want to delete this example?"),
            confirmText: t("common.confirm", "Confirm"),
            cancelText: t("common.cancel", "Cancel"),
            onConfirm: () => {
              examples.value = examples.value.filter((e) => e.id !== example.id);
              saveExamplesToStorage();
              toast.dismiss(toastId);
              toast.success(t("vocabulary.examples.deleteSuccess", "Example deleted successfully"));
            },
            onCancel: () => {
              toast.dismiss(toastId);
            }
          }
        },
        {
          position: POSITION.TOP_CENTER,
          timeout: false,
          closeButton: false,
          draggable: false,
          icon: false
        }
      );
    };
    const saveExample = (exampleData) => {
      if (currentExample.value && showEditDialog.value) {
        const index = examples.value.findIndex((e) => e.id === currentExample.value.id);
        if (index !== -1) {
          examples.value[index] = {
            ...examples.value[index],
            ...exampleData,
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          const vocab = vocabularyList.value.find((v) => v.id === examples.value[index].vocabularyId);
          if (vocab) {
            examples.value[index].vocabulary = { id: vocab.id, word: vocab.word };
          }
        }
      } else {
        const newExample = {
          id: Date.now().toString(),
          vocabularyId: exampleData.vocabularyId,
          title: exampleData.title,
          content: exampleData.content,
          translation: exampleData.translation,
          context: exampleData.context,
          type: exampleData.type,
          difficulty: exampleData.difficulty,
          tags: exampleData.tags,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        const vocab = vocabularyList.value.find((v) => v.id === newExample.vocabularyId);
        if (vocab) {
          newExample.vocabulary = { id: vocab.id, word: vocab.word };
        }
        examples.value.push(newExample);
      }
      saveExamplesToStorage();
      closeDialog();
    };
    const closeDialog = () => {
      showCreateDialog.value = false;
      showEditDialog.value = false;
      currentExample.value = null;
    };
    const playVocabularyAudio = (word) => {
      audioSystem.playVocabularySound(word, "en");
    };
    const previousPage = () => {
      if (currentPage.value > 1) {
        currentPage.value--;
      }
    };
    const nextPage = () => {
      if (currentPage.value < totalPages.value) {
        currentPage.value++;
      }
    };
    const goToPage = (page) => {
      if (page >= 1 && page <= totalPages.value) {
        currentPage.value = page;
      }
    };
    const toggleVocabExamples = (vocabId) => {
      expandedExamples.value[vocabId] = !expandedExamples.value[vocabId];
      saveExpandedExamplesState();
    };
    const loadExpandedExamplesState = () => {
      try {
        const saved = localStorage.getItem("vocabulary-examples-expanded-vocab");
        if (saved) {
          const parsed = JSON.parse(saved);
          expandedExamples.value = { ...parsed };
        }
      } catch (error) {
        console.error("Error loading expanded examples state:", error);
      }
    };
    const saveExpandedExamplesState = () => {
      try {
        localStorage.setItem("vocabulary-examples-expanded-vocab", JSON.stringify(expandedExamples.value));
      } catch (error) {
        console.error("Error saving expanded examples state:", error);
      }
    };
    const loadExamplePagesState = () => {
      try {
        const saved = localStorage.getItem("vocabulary-examples-pages");
        if (saved) {
          const parsed = JSON.parse(saved);
          examplePages.value = { ...parsed };
        }
      } catch (error) {
        console.error("Error loading example pages state:", error);
      }
    };
    const saveExamplePagesState = () => {
      try {
        localStorage.setItem("vocabulary-examples-pages", JSON.stringify(examplePages.value));
      } catch (error) {
        console.error("Error saving example pages state:", error);
      }
    };
    const initializeExpandedExamplesState = () => {
      let hasChanges = false;
      paginatedVocabulary.value.forEach((vocab) => {
        if (expandedExamples.value[vocab.id] === void 0) {
          expandedExamples.value[vocab.id] = false;
          hasChanges = true;
        }
        if (examplePages.value[vocab.id] === void 0) {
          examplePages.value[vocab.id] = 1;
          hasChanges = true;
        }
      });
      if (hasChanges) {
        saveExpandedExamplesState();
        saveExamplePagesState();
      }
    };
    const cleanupOldVocabularyStates = () => {
      try {
        const currentVocabIds = new Set(vocabularyList.value.map((v) => v.id));
        const expandedKeys = Object.keys(expandedExamples.value);
        let expandedChanged = false;
        expandedKeys.forEach((vocabId) => {
          if (!currentVocabIds.has(vocabId)) {
            delete expandedExamples.value[vocabId];
            expandedChanged = true;
          }
        });
        const pagesKeys = Object.keys(examplePages.value);
        let pagesChanged = false;
        pagesKeys.forEach((vocabId) => {
          if (!currentVocabIds.has(vocabId)) {
            delete examplePages.value[vocabId];
            pagesChanged = true;
          }
        });
        if (expandedChanged) {
          saveExpandedExamplesState();
        }
        if (pagesChanged) {
          saveExamplePagesState();
        }
      } catch (error) {
        console.error("Error cleaning up old vocabulary states:", error);
      }
    };
    const examplesEnter = (el) => {
      const element = el;
      element.style.height = "0";
      element.style.overflow = "hidden";
    };
    const examplesAfterEnter = (el) => {
      const element = el;
      element.style.height = "auto";
      element.style.overflow = "visible";
    };
    const examplesEnterCancelled = (el) => {
      const element = el;
      element.style.height = "auto";
      element.style.overflow = "visible";
    };
    const examplesBeforeLeave = (el) => {
      const element = el;
      element.style.height = element.scrollHeight + "px";
      element.style.overflow = "hidden";
    };
    const examplesLeave = (el) => {
      const element = el;
      element.style.height = element.scrollHeight + "px";
      element.style.overflow = "hidden";
      element.offsetHeight;
      element.style.height = "0";
    };
    const examplesAfterLeave = (el) => {
      const element = el;
      element.style.height = "auto";
      element.style.overflow = "visible";
    };
    const toggleGrouping = () => {
      groupByTopic.value = !groupByTopic.value;
      localStorage.setItem("vocabulary-examples-group-by-topic", JSON.stringify(groupByTopic.value));
    };
    const loadGroupingPreference = () => {
      try {
        const saved = localStorage.getItem("vocabulary-examples-group-by-topic");
        if (saved) {
          groupByTopic.value = JSON.parse(saved);
        }
      } catch (error) {
        console.error("Error loading grouping preference:", error);
        groupByTopic.value = false;
      }
    };
    watch(() => paginatedVocabulary.value, () => {
      initializeExpandedExamplesState();
    }, { immediate: true });
    watch(() => vocabularyList.value, () => {
      cleanupOldVocabularyStates();
    }, { deep: true });
    watch(() => expandedExamples.value, () => {
      saveExpandedExamplesState();
    }, { deep: true });
    watch(() => examplePages.value, () => {
      saveExamplePagesState();
    }, { deep: true });
    onMounted(() => {
      loadExamples();
      loadGroupingPreference();
      loadExpandedExamplesState();
      loadExamplePagesState();
      setTimeout(() => {
        cleanupOldVocabularyStates();
      }, 100);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1o, [
        _cache[15] || (_cache[15] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0" data-v-42779dea><div class="floating-shapes" data-v-42779dea><div class="absolute top-20 left-10 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob" data-v-42779dea></div><div class="absolute top-40 right-10 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000" data-v-42779dea></div><div class="absolute -bottom-8 left-20 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000" data-v-42779dea></div><div class="hidden sm:block absolute top-10 left-1/2 -translate-x-1/2 w-40 h-40 bg-cyan-300 dark:bg-cyan-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-1000" data-v-42779dea></div><div class="hidden sm:block absolute bottom-24 right-24 w-52 h-52 bg-indigo-300 dark:bg-indigo-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-3000" data-v-42779dea></div></div></div>', 1)),
        createBaseVNode("div", _hoisted_2$1l, [
          createBaseVNode("div", _hoisted_3$1i, [
            createBaseVNode("div", _hoisted_4$1d, [
              createBaseVNode("div", _hoisted_5$1a, [
                _cache[1] || (_cache[1] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                  createBaseVNode("div", { class: "w-2 xs:w-2.5 sm:w-2.5 h-2 xs:h-2.5 sm:h-2.5 bg-gradient-to-r from-green-400 to-emerald-500 rounded-full mr-2 xs:mr-2.5 sm:mr-2.5" })
                ], -1)),
                createBaseVNode("div", null, [
                  createBaseVNode("h1", _hoisted_6$17, toDisplayString$1(unref(t)("vocabulary.examples.title", "Example Manager")), 1),
                  createBaseVNode("p", _hoisted_7$13, toDisplayString$1(unref(t)("vocabulary.examples.description", "Create and manage example sentences based on your vocabulary words")), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_8$11, [
                createBaseVNode("div", _hoisted_9$10, [
                  createBaseVNode("span", _hoisted_10$$, toDisplayString$1(unref(t)("vocabulary.examples.groupByTopic", "Group by Topic")), 1),
                  createBaseVNode("button", {
                    onClick: toggleGrouping,
                    class: normalizeClass(["relative inline-flex h-5 xs:h-6 sm:h-6 w-9 xs:w-11 sm:w-11 items-center rounded-full transition-colors duration-300", groupByTopic.value ? "bg-gradient-to-r from-green-600 to-emerald-600" : "bg-gray-200 dark:bg-[#0a0a0a]"])
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(["inline-block h-3 xs:h-4 sm:h-4 w-3 xs:w-4 sm:w-4 transform rounded-full bg-white transition-transform duration-300 shadow-lg", groupByTopic.value ? "translate-x-5 xs:translate-x-6 sm:translate-x-6" : "translate-x-1"])
                    }, null, 2)
                  ], 2)
                ])
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_11$$, [
          createBaseVNode("div", _hoisted_12$Y, [
            createBaseVNode("div", _hoisted_13$Y, [
              _cache[2] || (_cache[2] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                createBaseVNode("div", { class: "w-2 xs:w-2.5 sm:w-2.5 h-2 xs:h-2.5 sm:h-2.5 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full mr-2 xs:mr-2.5 sm:mr-2.5" })
              ], -1)),
              createBaseVNode("h3", _hoisted_14$X, toDisplayString$1(unref(t)("common.search", "Search")), 1)
            ]),
            createBaseVNode("div", _hoisted_15$R, [
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchTerm.value = $event),
                type: "text",
                placeholder: unref(t)("vocabulary.examples.searchVocabulary", "Search vocabulary words..."),
                class: "w-full pl-8 xs:pl-9 sm:pl-10 md:pl-10 pr-3 xs:pr-4 sm:pr-4 py-1.5 xs:py-2 sm:py-2 md:py-2 text-sm xs:text-sm sm:text-base md:text-base border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white/50 dark:bg-[#0a0a0a]/50 backdrop-blur-sm focus:ring-2 focus:ring-green-500 focus:border-transparent text-gray-900 dark:text-white transition-all duration-300"
              }, null, 8, _hoisted_16$Q), [
                [vModelText, searchTerm.value]
              ]),
              _cache[3] || (_cache[3] = createBaseVNode("svg", {
                class: "absolute left-2 xs:left-2.5 sm:left-3 top-1.5 xs:top-2 sm:top-2.5 h-4 xs:h-4 sm:h-5 w-4 xs:w-4 sm:w-5 text-gray-400",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                })
              ], -1))
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_17$P, [
          createBaseVNode("div", _hoisted_18$N, [
            filteredVocabulary.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_19$N, [
              createBaseVNode("div", _hoisted_20$M, [
                _cache[4] || (_cache[4] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                  createBaseVNode("div", { class: "w-2.5 xs:w-3 sm:w-3 h-2.5 xs:h-3 sm:h-3 bg-gradient-to-r from-gray-400 to-gray-500 rounded-full mx-auto mb-2 xs:mb-2 sm:mb-3" })
                ], -1)),
                _cache[5] || (_cache[5] = createBaseVNode("svg", {
                  class: "mx-auto h-8 xs:h-10 sm:h-12 w-8 xs:w-10 sm:w-12 text-gray-400 mb-3 xs:mb-3 sm:mb-4",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                  })
                ], -1)),
                createBaseVNode("h3", _hoisted_21$M, toDisplayString$1(unref(t)("vocabulary.examples.noVocabulary", "No vocabulary words found")), 1),
                createBaseVNode("p", _hoisted_22$K, toDisplayString$1(unref(t)("vocabulary.examples.noVocabularyDescription", "Add some vocabulary words first to create examples for them.")), 1)
              ])
            ])) : !groupByTopic.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(paginatedVocabulary.value, (vocab) => {
                return openBlock(), createElementBlock("div", {
                  key: vocab.id,
                  class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6"
                }, [
                  createBaseVNode("div", {
                    onClick: ($event) => toggleVocabExamples(vocab.id),
                    class: "flex flex-col xs:flex-col sm:flex-row items-start justify-between mb-3 xs:mb-3 sm:mb-4 pb-2 xs:pb-2 sm:pb-3 border-b border-gray-200/50 dark:border-gray-700/50 gap-3 xs:gap-3 sm:gap-0"
                  }, [
                    createBaseVNode("div", _hoisted_24$I, [
                      _cache[8] || (_cache[8] = createBaseVNode("div", { class: "animate-pulse-slow mt-1" }, [
                        createBaseVNode("div", { class: "w-2 xs:w-2.5 sm:w-2.5 h-2 xs:h-2.5 sm:h-2.5 bg-gradient-to-r from-green-400 to-blue-500 rounded-full" })
                      ], -1)),
                      createBaseVNode("div", _hoisted_25$I, [
                        createBaseVNode("div", _hoisted_26$G, [
                          createBaseVNode("h3", _hoisted_27$F, toDisplayString$1(vocab.word), 1),
                          createBaseVNode("button", {
                            onClick: withModifiers(($event) => playVocabularyAudio(vocab.word), ["stop"]),
                            class: "p-1 xs:p-1.5 sm:p-1.5 text-blue-600 hover:text-blue-700 hover:bg-blue-50/50 dark:text-blue-400 dark:hover:text-blue-300 dark:hover:bg-blue-900/20 rounded-lg transition-all duration-300 group flex-shrink-0",
                            title: unref(t)("vocabulary.examples.playPronunciation", "Play pronunciation")
                          }, _cache[6] || (_cache[6] = [
                            createBaseVNode("svg", {
                              class: "w-3 xs:w-4 sm:w-4 h-3 xs:h-4 sm:h-4 group-hover:scale-110 transition-transform duration-200",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M15.536 8.464a5 5 0 010 7.072m2.464-9.536a9 9 0 010 12.728M9 9l3-3v6l-3-3H4a1 1 0 01-1-1V10a1 1 0 011-1h5z"
                              })
                            ], -1)
                          ]), 8, _hoisted_28$D),
                          getVocabExampleCount(vocab.id) > 0 ? (openBlock(), createElementBlock("button", {
                            key: 0,
                            onClick: withModifiers(($event) => toggleVocabExamples(vocab.id), ["stop"]),
                            class: "p-1 xs:p-1.5 sm:p-1.5 text-gray-600 hover:text-gray-700 hover:bg-gray-50/50 dark:text-gray-400 dark:hover:text-gray-300 dark:hover:bg-[#0a0a0a]/20 rounded-lg transition-all duration-300 group flex-shrink-0",
                            title: expandedExamples.value[vocab.id] ? unref(t)("vocabulary.examples.hideExamples", "Hide examples") : unref(t)("vocabulary.examples.showExamples", "Show examples")
                          }, [
                            (openBlock(), createElementBlock("svg", {
                              class: normalizeClass(["w-3 xs:w-4 sm:w-4 h-3 xs:h-4 sm:h-4 group-hover:scale-110 transition-all duration-200", { "rotate-180": expandedExamples.value[vocab.id] }]),
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, _cache[7] || (_cache[7] = [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M19 9l-7 7-7-7"
                              }, null, -1)
                            ]), 2))
                          ], 8, _hoisted_29$B)) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("p", _hoisted_30$z, toDisplayString$1(vocab.meaning), 1),
                        createBaseVNode("div", _hoisted_31$y, [
                          createBaseVNode("span", _hoisted_32$v, toDisplayString$1(vocab.partOfSpeech), 1),
                          createBaseVNode("span", _hoisted_33$u, toDisplayString$1(getVocabExampleCount(vocab.id)) + " " + toDisplayString$1(getVocabExampleCount(vocab.id) === 1 ? "example" : "examples"), 1)
                        ])
                      ])
                    ]),
                    createBaseVNode("button", {
                      onClick: withModifiers(($event) => openCreateDialogForVocab(vocab), ["stop"]),
                      class: "px-2 xs:px-2.5 sm:px-3 py-1.5 xs:py-1.5 sm:py-2 text-xs xs:text-xs sm:text-sm bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 text-white rounded-lg font-medium transition-all duration-300 shadow-lg hover:shadow-xl flex items-center space-x-1 xs:space-x-1 sm:space-x-2 flex-shrink-0"
                    }, [
                      _cache[9] || (_cache[9] = createBaseVNode("svg", {
                        class: "w-3 xs:w-3 sm:w-4 h-3 xs:h-3 sm:h-4",
                        fill: "none",
                        stroke: "currentColor",
                        viewBox: "0 0 24 24"
                      }, [
                        createBaseVNode("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M12 4v16m8-8H4"
                        })
                      ], -1)),
                      createBaseVNode("span", _hoisted_35$r, toDisplayString$1(unref(t)("vocabulary.examples.addExample", "Add Example")), 1),
                      createBaseVNode("span", _hoisted_36$q, toDisplayString$1(unref(t)("common.add", "Add")), 1)
                    ], 8, _hoisted_34$r)
                  ], 8, _hoisted_23$K),
                  createVNode(Transition, {
                    name: "examples-accordion",
                    onEnter: examplesEnter,
                    onAfterEnter: examplesAfterEnter,
                    onEnterCancelled: examplesEnterCancelled,
                    onBeforeLeave: examplesBeforeLeave,
                    onLeave: examplesLeave,
                    onAfterLeave: examplesAfterLeave
                  }, {
                    default: withCtx(() => [
                      expandedExamples.value[vocab.id] ? (openBlock(), createElementBlock("div", _hoisted_37$p, [
                        getVocabExamples(vocab.id).length === 0 ? (openBlock(), createElementBlock("div", _hoisted_38$p, [
                          createBaseVNode("p", _hoisted_39$n, toDisplayString$1(unref(t)("vocabulary.examples.noExamples", "No examples found for this vocabulary.")), 1)
                        ])) : (openBlock(), createElementBlock("div", _hoisted_40$n, [
                          createBaseVNode("div", _hoisted_41$m, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(getPaginatedVocabExamples(vocab.id), (example) => {
                              return openBlock(), createElementBlock("div", {
                                key: example.id,
                                class: "bg-white dark:bg-dark-bg border border-slate-200 dark:border-dark-bg-mute rounded-lg p-2 xs:p-3 sm:p-4 md:p-4 shadow-sm hover:shadow-md transition-shadow duration-200"
                              }, [
                                createBaseVNode("div", _hoisted_42$k, [
                                  createBaseVNode("div", _hoisted_43$j, [
                                    createBaseVNode("div", _hoisted_44$i, [
                                      createBaseVNode("h4", _hoisted_45$h, toDisplayString$1(example.title), 1),
                                      createBaseVNode("button", {
                                        onClick: ($event) => unref(audioSystem).playVocabularySound(example.content, "en"),
                                        class: "flex-shrink-0 p-1 xs:p-1.5 sm:p-1.5 text-emerald-600 hover:text-emerald-700 dark:text-emerald-400 dark:hover:text-emerald-300 bg-emerald-50 dark:bg-emerald-900/20 rounded-full hover:bg-emerald-100 dark:hover:bg-emerald-900/30 transition-all duration-200 transform hover:scale-110",
                                        title: unref(t)("vocabulary.examples.playExample", "Play example pronunciation")
                                      }, _cache[10] || (_cache[10] = [
                                        createBaseVNode("svg", {
                                          class: "w-3 xs:w-4 sm:w-4 h-3 xs:h-4 sm:h-4",
                                          fill: "none",
                                          stroke: "currentColor",
                                          viewBox: "0 0 24 24"
                                        }, [
                                          createBaseVNode("path", {
                                            "stroke-linecap": "round",
                                            "stroke-linejoin": "round",
                                            "stroke-width": "2",
                                            d: "M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 14.142M9 9l3-3v12l-3-3H5a2 2 0 01-2-2V9a2 2 0 012-2h4z"
                                          })
                                        ], -1)
                                      ]), 8, _hoisted_46$h)
                                    ]),
                                    createBaseVNode("p", _hoisted_47$h, toDisplayString$1(example.content), 1),
                                    createBaseVNode("div", _hoisted_48$h, [
                                      createBaseVNode("span", _hoisted_49$g, toDisplayString$1(example.type), 1),
                                      example.difficulty ? (openBlock(), createElementBlock("span", _hoisted_50$f, toDisplayString$1(example.difficulty), 1)) : createCommentVNode("", true),
                                      example.context ? (openBlock(), createElementBlock("span", _hoisted_51$e, toDisplayString$1(example.context), 1)) : createCommentVNode("", true)
                                    ])
                                  ]),
                                  createBaseVNode("div", _hoisted_52$d, [
                                    createBaseVNode("button", {
                                      onClick: ($event) => editExample(example),
                                      class: "px-2 xs:px-2.5 sm:px-3 py-1 xs:py-1 sm:py-1.5 text-2xs xs:text-xs sm:text-xs bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors duration-200 flex items-center gap-1"
                                    }, [
                                      _cache[11] || (_cache[11] = createBaseVNode("svg", {
                                        class: "w-2.5 xs:w-3 sm:w-3 h-2.5 xs:h-3 sm:h-3",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                                        })
                                      ], -1)),
                                      createBaseVNode("span", _hoisted_54$d, toDisplayString$1(unref(t)("common.edit", "Edit")), 1)
                                    ], 8, _hoisted_53$d),
                                    createBaseVNode("button", {
                                      onClick: ($event) => deleteExample(example),
                                      class: "px-2 xs:px-2.5 sm:px-3 py-1 xs:py-1 sm:py-1.5 text-2xs xs:text-xs sm:text-xs bg-red-600 hover:bg-red-700 text-white rounded-md transition-colors duration-200 flex items-center gap-1"
                                    }, [
                                      _cache[12] || (_cache[12] = createBaseVNode("svg", {
                                        class: "w-2.5 xs:w-3 sm:w-3 h-2.5 xs:h-3 sm:h-3",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                                        })
                                      ], -1)),
                                      createBaseVNode("span", _hoisted_56$c, toDisplayString$1(unref(t)("common.delete", "Delete")), 1)
                                    ], 8, _hoisted_55$d)
                                  ])
                                ])
                              ]);
                            }), 128))
                          ]),
                          getVocabExamplePages(vocab.id) > 1 ? (openBlock(), createElementBlock("div", _hoisted_57$c, [
                            createBaseVNode("div", _hoisted_58$c, [
                              createBaseVNode("div", _hoisted_59$b, [
                                createBaseVNode("button", {
                                  onClick: ($event) => previousExamplePage(vocab.id),
                                  disabled: !getExamplePaginationInfo(vocab.id).hasPrevious,
                                  class: "px-1.5 xs:px-2 py-0.5 xs:py-1 text-2xs xs:text-xs bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                }, toDisplayString$1(unref(t)("common.previous", "Prev")), 9, _hoisted_60$b),
                                createBaseVNode("span", _hoisted_61$a, toDisplayString$1(getExamplePaginationInfo(vocab.id).currentPage) + " / " + toDisplayString$1(getExamplePaginationInfo(vocab.id).totalPages), 1),
                                createBaseVNode("button", {
                                  onClick: ($event) => nextExamplePage(vocab.id),
                                  disabled: !getExamplePaginationInfo(vocab.id).hasNext,
                                  class: "px-1.5 xs:px-2 py-0.5 xs:py-1 text-2xs xs:text-xs bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_62$a)
                              ]),
                              createBaseVNode("div", _hoisted_63$8, [
                                createBaseVNode("button", {
                                  onClick: ($event) => previousExamplePage(vocab.id),
                                  disabled: !getExamplePaginationInfo(vocab.id).hasPrevious,
                                  class: "px-3 py-1.5 text-sm bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_64$8),
                                createBaseVNode("div", _hoisted_65$8, [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(Math.min(getExamplePaginationInfo(vocab.id).totalPages, 5), (page) => {
                                    return openBlock(), createElementBlock("button", {
                                      key: page,
                                      onClick: ($event) => goToExamplePage(vocab.id, page),
                                      class: normalizeClass([
                                        "px-3 py-1.5 text-sm rounded transition-colors",
                                        getExamplePaginationInfo(vocab.id).currentPage === page ? "bg-blue-600 text-white" : "bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600"
                                      ])
                                    }, toDisplayString$1(page), 11, _hoisted_66$8);
                                  }), 128))
                                ]),
                                createBaseVNode("button", {
                                  onClick: ($event) => nextExamplePage(vocab.id),
                                  disabled: !getExamplePaginationInfo(vocab.id).hasNext,
                                  class: "px-3 py-1.5 text-sm bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_67$7)
                              ]),
                              createBaseVNode("div", _hoisted_68$6, toDisplayString$1(unref(t)("vocabulary.examples.showingExamples", { start: getExamplePaginationInfo(vocab.id).start, end: getExamplePaginationInfo(vocab.id).end, total: getExamplePaginationInfo(vocab.id).totalExamples }, "Showing {start} to {end} of {total} examples")), 1)
                            ])
                          ])) : createCommentVNode("", true)
                        ]))
                      ])) : createCommentVNode("", true)
                    ]),
                    _: 2
                  }, 1024)
                ]);
              }), 128)),
              totalPages.value > 1 ? (openBlock(), createElementBlock("div", _hoisted_69$6, [
                createBaseVNode("div", _hoisted_70$6, [
                  createBaseVNode("div", _hoisted_71$6, [
                    createBaseVNode("button", {
                      onClick: previousPage,
                      disabled: currentPage.value === 1,
                      class: "relative inline-flex items-center px-2 xs:px-3 py-1 xs:py-1.5 border border-gray-300 dark:border-gray-600 text-xs xs:text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, toDisplayString$1(unref(t)("common.previous", "Prev")), 9, _hoisted_72$6),
                    createBaseVNode("div", _hoisted_73$6, [
                      createBaseVNode("span", _hoisted_74$6, toDisplayString$1(currentPage.value) + " / " + toDisplayString$1(totalPages.value), 1)
                    ]),
                    createBaseVNode("button", {
                      onClick: nextPage,
                      disabled: currentPage.value === totalPages.value,
                      class: "relative inline-flex items-center px-2 xs:px-3 py-1 xs:py-1.5 border border-gray-300 dark:border-gray-600 text-xs xs:text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_75$5)
                  ]),
                  createBaseVNode("div", _hoisted_76$5, [
                    createBaseVNode("div", null, [
                      createBaseVNode("p", _hoisted_77$5, toDisplayString$1(unref(t)("vocabulary.examples.showingVocabulary", {
                        start: startIndex.value,
                        end: endIndex.value,
                        total: filteredVocabulary.value.length
                      }, `Showing ${startIndex.value} to ${endIndex.value} of ${filteredVocabulary.value.length} vocabulary words`)), 1)
                    ]),
                    createBaseVNode("nav", _hoisted_78$4, [
                      createBaseVNode("button", {
                        onClick: previousPage,
                        disabled: currentPage.value === 1,
                        class: "relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                      }, [
                        createBaseVNode("span", _hoisted_80$4, toDisplayString$1(unref(t)("common.previous", "Previous")), 1),
                        _cache[13] || (_cache[13] = createBaseVNode("svg", {
                          class: "h-5 w-5",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                            "clip-rule": "evenodd"
                          })
                        ], -1))
                      ], 8, _hoisted_79$4),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(visiblePages.value, (page) => {
                        return openBlock(), createElementBlock("button", {
                          key: page,
                          onClick: ($event) => goToPage(page),
                          class: normalizeClass([
                            page === currentPage.value ? "z-10 bg-blue-50 dark:bg-blue-900 border-blue-500 dark:border-blue-400 text-blue-600 dark:text-blue-300" : "bg-white dark:bg-[#0a0a0a] border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600",
                            "relative inline-flex items-center px-4 py-2 border text-sm font-medium"
                          ])
                        }, toDisplayString$1(page), 11, _hoisted_81$4);
                      }), 128)),
                      createBaseVNode("button", {
                        onClick: nextPage,
                        disabled: currentPage.value === totalPages.value,
                        class: "relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                      }, [
                        createBaseVNode("span", _hoisted_83$4, toDisplayString$1(unref(t)("common.next", "Next")), 1),
                        _cache[14] || (_cache[14] = createBaseVNode("svg", {
                          class: "h-5 w-5",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                            "clip-rule": "evenodd"
                          })
                        ], -1))
                      ], 8, _hoisted_82$4)
                    ])
                  ])
                ])
              ])) : createCommentVNode("", true)
            ], 64)) : (openBlock(), createBlock(unref(TopicGroupAccordion), {
              key: 2,
              "vocabulary-list": filteredVocabulary.value,
              examples: examples.value,
              onAddExample: openCreateDialogForVocab,
              onEditExample: editExample,
              onDeleteExample: deleteExample
            }, null, 8, ["vocabulary-list", "examples"]))
          ])
        ]),
        showCreateDialog.value || showEditDialog.value ? (openBlock(), createBlock(unref(ExampleFormDialog$1), {
          key: 0,
          show: showCreateDialog.value || showEditDialog.value,
          example: currentExample.value,
          "vocabulary-id": selectedVocabulary.value,
          "vocabulary-list": vocabularyList.value,
          onClose: closeDialog,
          onSave: saveExample
        }, null, 8, ["show", "example", "vocabulary-id", "vocabulary-list"])) : createCommentVNode("", true)
      ]);
    };
  }
});

const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

const VocabularyExamplesView = /* @__PURE__ */ _export_sfc(_sfc_main$1p, [["__scopeId", "data-v-42779dea"]]);

const _hoisted_1$1n = { class: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative overflow-x-hidden" };
const _hoisted_2$1k = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto px-2 xs:px-3 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 pt-3 sm:pt-6" };
const _hoisted_3$1h = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6 mb-3 xs:mb-4 sm:mb-6" };
const _hoisted_4$1c = { class: "flex items-center mb-4" };
const _hoisted_5$19 = { class: "text-lg sm:text-xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 dark:from-purple-400 dark:to-pink-400 bg-clip-text text-transparent" };
const _hoisted_6$16 = { class: "text-sm sm:text-base text-gray-600 dark:text-gray-300 mb-4" };
const _hoisted_7$12 = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto py-3 px-2 xs:py-4 xs:px-3 sm:py-6 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 overflow-x-hidden" };
const _hoisted_8$10 = { class: "grid gap-6 md:grid-cols-2 lg:grid-cols-3 mb-6" };
const _hoisted_9$$ = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.02] p-4 sm:p-6" };
const _hoisted_10$_ = { class: "flex items-center mb-4" };
const _hoisted_11$_ = { class: "text-base sm:text-lg font-semibold text-gray-800 dark:text-white" };
const _hoisted_12$X = { class: "text-sm text-gray-600 dark:text-gray-300 mb-4" };
const _hoisted_13$X = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.02] p-4 sm:p-6" };
const _hoisted_14$W = { class: "flex items-center mb-4" };
const _hoisted_15$Q = { class: "text-base sm:text-lg font-semibold text-gray-800 dark:text-white" };
const _hoisted_16$P = { class: "text-sm text-gray-600 dark:text-gray-300 mb-4" };
const _hoisted_17$O = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.02] p-4 sm:p-6" };
const _hoisted_18$M = { class: "flex items-center mb-4" };
const _hoisted_19$M = { class: "text-base sm:text-lg font-semibold text-gray-800 dark:text-white" };
const _hoisted_20$L = { class: "text-sm text-gray-600 dark:text-gray-300 mb-4" };
const _hoisted_21$L = {
  key: 0,
  class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-4 sm:p-6 mb-6"
};
const _hoisted_22$J = {
  key: 0,
  class: "space-y-6"
};
const _hoisted_23$J = { class: "flex items-center mb-4" };
const _hoisted_24$H = { class: "text-lg font-semibold text-gray-800 dark:text-white" };
const _hoisted_25$H = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_26$F = ["placeholder", "disabled"];
const _hoisted_27$E = { class: "grid gap-4 md:grid-cols-2" };
const _hoisted_28$C = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_29$A = ["disabled"];
const _hoisted_30$y = { value: "beginner" };
const _hoisted_31$x = { value: "intermediate" };
const _hoisted_32$u = { value: "advanced" };
const _hoisted_33$t = { value: "mixed" };
const _hoisted_34$q = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_35$q = ["disabled"];
const _hoisted_36$p = { class: "flex justify-end mt-6" };
const _hoisted_37$o = ["disabled"];
const _hoisted_38$o = {
  key: 0,
  class: "animate-spin w-5 h-5",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _hoisted_39$m = {
  key: 1,
  class: "w-5 h-5",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_40$m = {
  key: 1,
  class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-4 sm:p-6"
};
const _hoisted_41$l = { class: "flex items-center justify-between mb-6" };
const _hoisted_42$j = { class: "flex items-center" };
const _hoisted_43$i = { class: "text-lg font-semibold text-gray-800 dark:text-white" };
const _hoisted_44$h = { class: "flex space-x-2" };
const _hoisted_45$g = ["disabled"];
const _hoisted_46$g = { class: "grid gap-4 md:grid-cols-2 lg:grid-cols-3" };
const _hoisted_47$g = { class: "flex items-start justify-between mb-2" };
const _hoisted_48$g = { class: "font-semibold text-gray-800 dark:text-white text-lg" };
const _hoisted_49$f = { class: "text-xs px-2 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400 rounded-full" };
const _hoisted_50$e = { class: "text-sm text-gray-600 dark:text-gray-300 mb-3" };
const _hoisted_51$d = {
  key: 0,
  class: "text-xs text-gray-500 dark:text-gray-400 italic border-l-2 border-gray-300 dark:border-gray-600 pl-2"
};
const _sfc_main$1o = /* @__PURE__ */ defineComponent({
  __name: "AutoGeneratorView",
  setup(__props) {
    const { t } = useI18n();
    const vocabularyStore = useVocabularyStore();
    const toast = useToast();
    const selectedMethod = ref(null);
    const textInput = ref("");
    const selectedTopic = ref("");
    const aiPreferences = ref("");
    const difficultyLevel = ref("intermediate");
    const maxWords = ref("20");
    ref("vocabulary");
    const isGenerating = ref(false);
    const isSaving = ref(false);
    const generatedWords = ref([]);
    const canGenerate = computed(() => {
      if (selectedMethod.value === "text") {
        return textInput.value.trim().length > 10;
      } else if (selectedMethod.value === "topic") {
        return selectedTopic.value !== "";
      } else if (selectedMethod.value === "ai") {
        return aiPreferences.value.trim().length > 5;
      }
      return false;
    });
    const generateVocabulary = async () => {
      if (!canGenerate.value || isGenerating.value) return;
      isGenerating.value = true;
      try {
        await new Promise((resolve) => setTimeout(resolve, 2e3));
        generatedWords.value = generateMockWords();
      } catch (error) {
        console.error("Error generating vocabulary:", error);
      } finally {
        isGenerating.value = false;
      }
    };
    const generateMockWords = () => {
      const mockWords = [
        { word: "Articulate", meaning: "Having or showing the ability to speak fluently and coherently", type: "Adjective", example: "She gave an articulate presentation to the board." },
        { word: "Resilience", meaning: "The capacity to recover quickly from difficulties", type: "Noun", example: "His resilience helped him overcome many challenges." },
        { word: "Innovative", meaning: "Featuring new methods; advanced and original", type: "Adjective", example: "The company is known for its innovative products." },
        { word: "Collaborate", meaning: "Work jointly on an activity", type: "Verb", example: "We need to collaborate to complete this project." },
        { word: "Efficient", meaning: "Achieving maximum productivity with minimum effort", type: "Adjective", example: "The new system is more efficient than the old one." }
      ];
      const count = Math.min(parseInt(maxWords.value), 10);
      return mockWords.slice(0, count);
    };
    const saveAllWords = async () => {
      if (generatedWords.value.length === 0) return;
      isSaving.value = true;
      try {
        let savedCount = 0;
        for (const word of generatedWords.value) {
          const vocabularyData = {
            word: word.word,
            pronunciation: "",
            // Would be generated by TTS or manual input
            partOfSpeech: word.type,
            meaning: word.meaning,
            example: word.example || "",
            category: selectedTopic.value || "uncategorized",
            level: difficultyLevel.value,
            synonyms: [],
            antonyms: [],
            notes: `Generated via ${selectedMethod.value} method`,
            favorite: false,
            image: void 0
          };
          const result = vocabularyStore.addVocabulary(vocabularyData);
          if (result) {
            savedCount++;
          }
        }
        toast.success(
          t("autoGenerator.saveSuccess", `Successfully saved ${savedCount} words to your vocabulary list`),
          {
            position: POSITION.TOP_RIGHT,
            timeout: 3e3
          }
        );
        generatedWords.value = [];
        selectedMethod.value = null;
        textInput.value = "";
        selectedTopic.value = "";
        aiPreferences.value = "";
      } catch (error) {
        console.error("Error saving vocabulary:", error);
        toast.error(
          t("autoGenerator.saveError", "Failed to save vocabulary words"),
          {
            position: POSITION.TOP_RIGHT,
            timeout: 3e3
          }
        );
      } finally {
        isSaving.value = false;
      }
    };
    const clearGenerated = () => {
      generatedWords.value = [];
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1n, [
        _cache[16] || (_cache[16] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0" data-v-c4401a47><div class="floating-shapes" data-v-c4401a47><div class="absolute top-20 left-10 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob" data-v-c4401a47></div><div class="absolute top-40 right-10 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000" data-v-c4401a47></div><div class="absolute -bottom-8 left-20 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000" data-v-c4401a47></div></div></div>', 1)),
        createBaseVNode("div", _hoisted_2$1k, [
          createBaseVNode("div", _hoisted_3$1h, [
            createBaseVNode("div", _hoisted_4$1c, [
              _cache[6] || (_cache[6] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-purple-400 to-pink-500 rounded-full mr-2.5" })
              ], -1)),
              createBaseVNode("h1", _hoisted_5$19, toDisplayString$1(unref(t)("autoGenerator.title", "Auto Generator")), 1)
            ]),
            createBaseVNode("p", _hoisted_6$16, toDisplayString$1(unref(t)("autoGenerator.description", "Generate vocabulary words automatically from text, topics, or AI suggestions")), 1)
          ])
        ]),
        createBaseVNode("div", _hoisted_7$12, [
          createBaseVNode("div", _hoisted_8$10, [
            createBaseVNode("div", _hoisted_9$$, [
              createBaseVNode("div", _hoisted_10$_, [
                _cache[7] || (_cache[7] = createBaseVNode("div", { class: "w-12 h-12 bg-gradient-to-r from-blue-500 to-cyan-500 rounded-full flex items-center justify-center mr-3" }, [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 text-white",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M4 4a2 2 0 012-2h8a2 2 0 012 2v12a1 1 0 110 2h-3a1 1 0 01-1-1v-2a1 1 0 00-1-1H9a1 1 0 00-1 1v2a1 1 0 01-1 1H4a1 1 0 110-2V4zm3 1h2v2H7V5zm2 4H7v2h2V9zm2-4h2v2h-2V5zm2 4h-2v2h2V9z",
                      "clip-rule": "evenodd"
                    })
                  ])
                ], -1)),
                createBaseVNode("h3", _hoisted_11$_, toDisplayString$1(unref(t)("autoGenerator.methods.textAnalysis", "Text Analysis")), 1)
              ]),
              createBaseVNode("p", _hoisted_12$X, toDisplayString$1(unref(t)("autoGenerator.methods.textAnalysisDesc", "Extract vocabulary from articles, books, or any text content")), 1),
              createBaseVNode("button", {
                onClick: _cache[0] || (_cache[0] = ($event) => selectedMethod.value = "text"),
                class: normalizeClass([
                  "w-full py-2 px-4 rounded-lg font-medium transition-all duration-200",
                  selectedMethod.value === "text" ? "bg-gradient-to-r from-blue-500 to-cyan-500 text-white shadow-lg" : "bg-gray-100 dark:bg-dark-bg-mute text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-dark-bg-soft"
                ])
              }, toDisplayString$1(unref(t)("common.select", "Select")), 3)
            ]),
            createBaseVNode("div", _hoisted_13$X, [
              createBaseVNode("div", _hoisted_14$W, [
                _cache[8] || (_cache[8] = createBaseVNode("div", { class: "w-12 h-12 bg-gradient-to-r from-green-500 to-teal-500 rounded-full flex items-center justify-center mr-3" }, [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 text-white",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", { d: "M7 3a1 1 0 000 2h6a1 1 0 100-2H7zM4 7a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zM2 11a2 2 0 012-2h12a2 2 0 012 2v4a2 2 0 01-2 2H4a2 2 0 01-2-2v-4z" })
                  ])
                ], -1)),
                createBaseVNode("h3", _hoisted_15$Q, toDisplayString$1(unref(t)("autoGenerator.methods.topicBased", "Topic-based")), 1)
              ]),
              createBaseVNode("p", _hoisted_16$P, toDisplayString$1(unref(t)("autoGenerator.methods.topicBasedDesc", "Generate words based on specific topics or categories")), 1),
              createBaseVNode("button", {
                onClick: _cache[1] || (_cache[1] = ($event) => selectedMethod.value = "topic"),
                class: normalizeClass([
                  "w-full py-2 px-4 rounded-lg font-medium transition-all duration-200",
                  selectedMethod.value === "topic" ? "bg-gradient-to-r from-green-500 to-teal-500 text-white shadow-lg" : "bg-gray-100 dark:bg-dark-bg-mute text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-dark-bg-soft"
                ])
              }, toDisplayString$1(unref(t)("common.select", "Select")), 3)
            ]),
            createBaseVNode("div", _hoisted_17$O, [
              createBaseVNode("div", _hoisted_18$M, [
                _cache[9] || (_cache[9] = createBaseVNode("div", { class: "w-12 h-12 bg-gradient-to-r from-purple-500 to-pink-500 rounded-full flex items-center justify-center mr-3" }, [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 text-white",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z",
                      "clip-rule": "evenodd"
                    })
                  ])
                ], -1)),
                createBaseVNode("h3", _hoisted_19$M, toDisplayString$1(unref(t)("autoGenerator.methods.aiSuggestions", "AI Suggestions")), 1)
              ]),
              createBaseVNode("p", _hoisted_20$L, toDisplayString$1(unref(t)("autoGenerator.methods.aiSuggestionsDesc", "Get intelligent word suggestions based on your learning level")), 1),
              createBaseVNode("button", {
                onClick: _cache[2] || (_cache[2] = ($event) => selectedMethod.value = "ai"),
                class: normalizeClass([
                  "w-full py-2 px-4 rounded-lg font-medium transition-all duration-200",
                  selectedMethod.value === "ai" ? "bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-lg" : "bg-gray-100 dark:bg-dark-bg-mute text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-dark-bg-soft"
                ])
              }, toDisplayString$1(unref(t)("common.select", "Select")), 3)
            ])
          ]),
          selectedMethod.value ? (openBlock(), createElementBlock("div", _hoisted_21$L, [
            selectedMethod.value === "text" ? (openBlock(), createElementBlock("div", _hoisted_22$J, [
              createBaseVNode("div", _hoisted_23$J, [
                _cache[10] || (_cache[10] = createBaseVNode("div", { class: "w-8 h-8 bg-gradient-to-r from-blue-500 to-cyan-500 rounded-full flex items-center justify-center mr-3" }, [
                  createBaseVNode("svg", {
                    class: "w-4 h-4 text-white",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M4 4a2 2 0 012-2h8a2 2 0 012 2v12a1 1 0 110 2h-3a1 1 0 01-1-1v-2a1 1 0 00-1-1H9a1 1 0 00-1 1v2a1 1 0 01-1 1H4a1 1 0 110-2V4zm3 1h2v2H7V5zm2 4H7v2h2V9zm2-4h2v2h-2V5zm2 4h-2v2h2V9z",
                      "clip-rule": "evenodd"
                    })
                  ])
                ], -1)),
                createBaseVNode("h3", _hoisted_24$H, toDisplayString$1(unref(t)("autoGenerator.forms.textAnalysis.title", "Analyze Text Content")), 1)
              ]),
              createBaseVNode("div", null, [
                createBaseVNode("label", _hoisted_25$H, toDisplayString$1(unref(t)("autoGenerator.forms.textAnalysis.inputLabel", "Paste your text content here:")), 1),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => textInput.value = $event),
                  placeholder: unref(t)("autoGenerator.forms.textAnalysis.placeholder", "Paste article, book excerpt, or any English text..."),
                  class: "w-full h-40 px-4 py-3 border border-gray-300 dark:border-dark-bg-mute rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white resize-none",
                  disabled: isGenerating.value
                }, null, 8, _hoisted_26$F), [
                  [vModelText, textInput.value]
                ])
              ]),
              createBaseVNode("div", _hoisted_27$E, [
                createBaseVNode("div", null, [
                  createBaseVNode("label", _hoisted_28$C, toDisplayString$1(unref(t)("autoGenerator.forms.common.difficultyLevel", "Difficulty Level")), 1),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => difficultyLevel.value = $event),
                    class: "w-full px-4 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white",
                    disabled: isGenerating.value
                  }, [
                    createBaseVNode("option", _hoisted_30$y, toDisplayString$1(unref(t)("autoGenerator.levels.beginner", "Beginner")), 1),
                    createBaseVNode("option", _hoisted_31$x, toDisplayString$1(unref(t)("autoGenerator.levels.intermediate", "Intermediate")), 1),
                    createBaseVNode("option", _hoisted_32$u, toDisplayString$1(unref(t)("autoGenerator.levels.advanced", "Advanced")), 1),
                    createBaseVNode("option", _hoisted_33$t, toDisplayString$1(unref(t)("autoGenerator.levels.mixed", "Mixed Levels")), 1)
                  ], 8, _hoisted_29$A), [
                    [vModelSelect, difficultyLevel.value]
                  ])
                ]),
                createBaseVNode("div", null, [
                  createBaseVNode("label", _hoisted_34$q, toDisplayString$1(unref(t)("autoGenerator.forms.common.maxWords", "Maximum Words")), 1),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => maxWords.value = $event),
                    class: "w-full px-4 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white",
                    disabled: isGenerating.value
                  }, _cache[11] || (_cache[11] = [
                    createBaseVNode("option", { value: "10" }, "10", -1),
                    createBaseVNode("option", { value: "20" }, "20", -1),
                    createBaseVNode("option", { value: "30" }, "30", -1),
                    createBaseVNode("option", { value: "50" }, "50", -1)
                  ]), 8, _hoisted_35$q), [
                    [vModelSelect, maxWords.value]
                  ])
                ])
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_36$p, [
              createBaseVNode("button", {
                onClick: generateVocabulary,
                disabled: !canGenerate.value || isGenerating.value,
                class: normalizeClass([
                  "px-6 py-3 rounded-lg font-semibold transition-all duration-200 flex items-center space-x-2",
                  canGenerate.value && !isGenerating.value ? "bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white shadow-lg hover:shadow-xl transform hover:scale-105" : "bg-gray-300 dark:bg-dark-bg-mute text-gray-500 dark:text-gray-400 cursor-not-allowed"
                ])
              }, [
                isGenerating.value ? (openBlock(), createElementBlock("svg", _hoisted_38$o, _cache[12] || (_cache[12] = [
                  createBaseVNode("circle", {
                    class: "opacity-25",
                    cx: "12",
                    cy: "12",
                    r: "10",
                    stroke: "currentColor",
                    "stroke-width": "4"
                  }, null, -1),
                  createBaseVNode("path", {
                    class: "opacity-75",
                    fill: "currentColor",
                    d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 002 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                  }, null, -1)
                ]))) : (openBlock(), createElementBlock("svg", _hoisted_39$m, _cache[13] || (_cache[13] = [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                    "clip-rule": "evenodd"
                  }, null, -1)
                ]))),
                createBaseVNode("span", null, toDisplayString$1(isGenerating.value ? unref(t)("autoGenerator.generating", "Generating...") : unref(t)("autoGenerator.generate", "Generate Vocabulary")), 1)
              ], 10, _hoisted_37$o)
            ])
          ])) : createCommentVNode("", true),
          generatedWords.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_40$m, [
            createBaseVNode("div", _hoisted_41$l, [
              createBaseVNode("div", _hoisted_42$j, [
                _cache[14] || (_cache[14] = createBaseVNode("div", { class: "w-8 h-8 bg-gradient-to-r from-green-500 to-blue-500 rounded-full flex items-center justify-center mr-3" }, [
                  createBaseVNode("svg", {
                    class: "w-4 h-4 text-white",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                      "clip-rule": "evenodd"
                    })
                  ])
                ], -1)),
                createBaseVNode("h3", _hoisted_43$i, toDisplayString$1(unref(t)("autoGenerator.preview.title", "Generated Vocabulary")), 1)
              ]),
              createBaseVNode("div", _hoisted_44$h, [
                createBaseVNode("button", {
                  onClick: saveAllWords,
                  disabled: isSaving.value,
                  class: normalizeClass([
                    "px-4 py-2 rounded-lg font-medium transition-all duration-200 flex items-center space-x-2",
                    "bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white shadow-lg hover:shadow-xl transform hover:scale-105"
                  ])
                }, [
                  _cache[15] || (_cache[15] = createBaseVNode("svg", {
                    class: "w-4 h-4",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)),
                  createBaseVNode("span", null, toDisplayString$1(unref(t)("autoGenerator.saveAll", "Save All")), 1)
                ], 8, _hoisted_45$g),
                createBaseVNode("button", {
                  onClick: clearGenerated,
                  class: "px-4 py-2 rounded-lg font-medium text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20 transition-all duration-200"
                }, toDisplayString$1(unref(t)("common.clear", "Clear")), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_46$g, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(generatedWords.value, (word, index) => {
                return openBlock(), createElementBlock("div", {
                  key: index,
                  class: "bg-gray-50 dark:bg-dark-bg-mute rounded-lg p-4 hover:shadow-md transition-shadow duration-200"
                }, [
                  createBaseVNode("div", _hoisted_47$g, [
                    createBaseVNode("h4", _hoisted_48$g, toDisplayString$1(word.word), 1),
                    createBaseVNode("span", _hoisted_49$f, toDisplayString$1(word.type), 1)
                  ]),
                  createBaseVNode("p", _hoisted_50$e, toDisplayString$1(word.meaning), 1),
                  word.example ? (openBlock(), createElementBlock("div", _hoisted_51$d, ' "' + toDisplayString$1(word.example) + '" ', 1)) : createCommentVNode("", true)
                ]);
              }), 128))
            ])
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const AutoGeneratorView = /* @__PURE__ */ _export_sfc(_sfc_main$1o, [["__scopeId", "data-v-c4401a47"]]);

const grammarLessons = ref([
  {
    id: "1",
    title: "Present Perfect Tense",
    description: "Học cách sử dụng thì hiện tại hoàn thành trong tiếng Anh với các ví dụ thực tế và bài tập.",
    level: "intermediate",
    category: "Tenses",
    duration: 30,
    rating: 4.8,
    progress: 75,
    exercises: 15,
    theory: `
      <h3>Cấu trúc Present Perfect</h3>
      <p><strong>Khẳng định:</strong> S + have/has + V3/ed</p>
      <p><strong>Phủ định:</strong> S + have/has + not + V3/ed</p>
      <p><strong>Nghi vấn:</strong> Have/Has + S + V3/ed?</p>
      
      <h3>Cách sử dụng</h3>
      <p>Thì hiện tại hoàn thành được sử dụng để:</p>
      <ul>
        <li>Diễn tả hành động đã xảy ra trong quá khứ nhưng không rõ thời gian</li>
        <li>Diễn tả hành động bắt đầu trong quá khứ và tiếp tục đến hiện tại</li>
        <li>Diễn tả kinh nghiệm sống</li>
      </ul>
    `,
    structure: "Subject + have/has + past participle",
    examples: [
      {
        id: 1,
        text: "I have lived in this city for 5 years.",
        translation: "Tôi đã sống ở thành phố này được 5 năm.",
        note: "Hành động bắt đầu trong quá khứ và tiếp tục đến hiện tại"
      },
      {
        id: 2,
        text: "She has just finished her homework.",
        translation: "Cô ấy vừa mới hoàn thành bài tập về nhà.",
        note: "Hành động vừa mới hoàn thành"
      }
    ],
    rules: [
      {
        id: 1,
        title: "Sử dụng với 'for' và 'since'",
        description: "'For' + khoảng thời gian, 'since' + mốc thời gian"
      },
      {
        id: 2,
        title: "Sử dụng với 'already', 'yet', 'just'",
        description: "Các trạng từ này thường đi kèm với thì hiện tại hoàn thành"
      }
    ],
    usageRules: [
      { title: "Sử dụng với 'for' và 'since'", description: "'For' + khoảng thời gian, 'since' + mốc thời gian" },
      { title: "Sử dụng với 'already', 'yet', 'just'", description: "Các trạng từ này thường đi kèm với thì hiện tại hoàn thành" }
    ],
    commonMistakes: [
      {
        id: 1,
        wrong: "I have seen him yesterday.",
        correct: "I saw him yesterday.",
        explanation: "Không dùng Present Perfect với thời gian cụ thể trong quá khứ"
      }
    ]
  }
]);
const useGrammarStore = () => {
  const allLessons = computed(() => grammarLessons.value);
  const getLesson = (id) => {
    return grammarLessons.value.find((lesson) => lesson.id === id);
  };
  const updateLesson = (id, updates) => {
    const index = grammarLessons.value.findIndex((lesson) => lesson.id === id);
    if (index !== -1) {
      grammarLessons.value[index] = { ...grammarLessons.value[index], ...updates };
    }
  };
  const addLesson = (lesson) => {
    grammarLessons.value.push(lesson);
  };
  const deleteLesson = (id) => {
    const index = grammarLessons.value.findIndex((lesson) => lesson.id === id);
    if (index !== -1) {
      grammarLessons.value.splice(index, 1);
    }
  };
  const getRelatedLessons = (currentId, category) => {
    return grammarLessons.value.filter((lesson) => lesson.id !== currentId && lesson.category === category).slice(0, 3).map((lesson) => ({
      id: lesson.id,
      title: lesson.title,
      category: lesson.category
    }));
  };
  return {
    allLessons,
    getLesson,
    updateLesson,
    addLesson,
    deleteLesson,
    getRelatedLessons
  };
};

const _hoisted_1$1m = { class: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative overflow-x-hidden" };
const _hoisted_2$1j = { class: "relative z-10 max-w-7xl mx-auto py-6 px-4 sm:px-6 lg:px-8" };
const _hoisted_3$1g = {
  key: 0,
  class: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
};
const _sfc_main$1n = /* @__PURE__ */ defineComponent({
  __name: "GrammarListView",
  setup(__props) {
    const LazyLoadComponent = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => LazyLoadComponent$1),true              ?void 0:void 0));
    const GrammarHeader$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => GrammarHeader),true              ?void 0:void 0))
    );
    const GrammarFilters$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => GrammarFilters),true              ?void 0:void 0))
    );
    const GrammarCard$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => GrammarCard),true              ?void 0:void 0))
    );
    const GrammarEmptyState$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => GrammarEmptyState),true              ?void 0:void 0))
    );
    const GrammarFormDialog = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => GrammarFormDialog$1),true              ?void 0:void 0))
    );
    const router = useRouter();
    const { t } = useI18n();
    const grammarStore = useGrammarStore();
    const showFormDialog = ref(false);
    const currentEditId = ref("");
    const searchQuery = ref("");
    const selectedLevel = ref("");
    const selectedCategory = ref("");
    const categories = ref([
      "Tenses",
      "Conditionals",
      "Passive Voice",
      "Modal Verbs",
      "Reported Speech",
      "Articles",
      "Prepositions",
      "Adjectives & Adverbs",
      "Phrasal Verbs",
      "Gerunds & Infinitives"
    ]);
    const filteredLessons = computed(() => {
      return grammarStore.allLessons.value.filter((lesson) => {
        const matchesSearch = lesson.title.toLowerCase().includes(searchQuery.value.toLowerCase()) || lesson.description.toLowerCase().includes(searchQuery.value.toLowerCase());
        const matchesLevel = !selectedLevel.value || lesson.level === selectedLevel.value;
        const matchesCategory = !selectedCategory.value || lesson.category === selectedCategory.value;
        return matchesSearch && matchesLevel && matchesCategory;
      });
    });
    const openAddDialog = () => {
      currentEditId.value = "";
      showFormDialog.value = true;
    };
    const openEditDialog = (lesson) => {
      currentEditId.value = lesson.id;
      showFormDialog.value = true;
    };
    const onLessonSaved = (lesson) => {
      console.log("Lesson saved:", lesson);
    };
    const viewLesson = (lesson) => {
      router.push(`/grammar/${lesson.id}`);
    };
    const practiceLesson = (lesson) => {
      router.push(`/grammar/${lesson.id}/practice`);
    };
    const deleteLesson = (lesson) => {
      if (confirm(t("grammar.confirmDelete", { title: lesson.title }) || `Delete lesson "${lesson.title}"?`)) {
        grammarStore.deleteLesson(lesson.id);
      }
    };
    onMounted(() => {
      console.log("Grammar list mounted");
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1m, [
        _cache[4] || (_cache[4] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0" data-v-41de1874><div class="floating-shapes" data-v-41de1874><div class="absolute top-20 left-10 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob" data-v-41de1874></div><div class="absolute top-40 right-10 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000" data-v-41de1874></div><div class="absolute -bottom-8 left-20 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000" data-v-41de1874></div></div></div>', 1)),
        createVNode(unref(LazyLoadComponent), { "animation-type": "fade-up" }, {
          default: withCtx(() => [
            createVNode(unref(GrammarHeader$1), { onAddLesson: openAddDialog })
          ]),
          _: 1
        }),
        createBaseVNode("div", _hoisted_2$1j, [
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "slide-left",
            threshold: 0.2,
            "root-margin": "100px"
          }, {
            default: withCtx(() => [
              createVNode(unref(GrammarFilters$1), {
                searchQuery: searchQuery.value,
                selectedLevel: selectedLevel.value,
                selectedCategory: selectedCategory.value,
                categories: categories.value,
                "onUpdate:searchQuery": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
                "onUpdate:selectedLevel": _cache[1] || (_cache[1] = ($event) => selectedLevel.value = $event),
                "onUpdate:selectedCategory": _cache[2] || (_cache[2] = ($event) => selectedCategory.value = $event)
              }, null, 8, ["searchQuery", "selectedLevel", "selectedCategory", "categories"])
            ]),
            _: 1
          }),
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "scale",
            threshold: 0.2,
            "root-margin": "150px"
          }, {
            default: withCtx(() => [
              filteredLessons.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$1g, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(filteredLessons.value, (lesson) => {
                  return openBlock(), createBlock(unref(GrammarCard$1), {
                    key: lesson.id,
                    lesson,
                    onViewLesson: viewLesson,
                    onPracticeLesson: practiceLesson,
                    onEditLesson: openEditDialog,
                    onDeleteLesson: deleteLesson
                  }, null, 8, ["lesson"]);
                }), 128))
              ])) : (openBlock(), createBlock(unref(GrammarEmptyState$1), {
                key: 1,
                onAddLesson: openAddDialog
              }))
            ]),
            _: 1
          })
        ]),
        createVNode(unref(GrammarFormDialog), {
          modelValue: showFormDialog.value,
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => showFormDialog.value = $event),
          "edit-id": currentEditId.value,
          onSaved: onLessonSaved
        }, null, 8, ["modelValue", "edit-id"])
      ]);
    };
  }
});

const GrammarListView = /* @__PURE__ */ _export_sfc(_sfc_main$1n, [["__scopeId", "data-v-41de1874"]]);

const _hoisted_1$1l = { class: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative overflow-x-hidden" };
const _hoisted_2$1i = {
  key: 0,
  class: "relative z-10 max-w-4xl mx-auto py-6 px-4 sm:px-6 lg:px-8"
};
const _hoisted_3$1f = {
  key: 1,
  class: "relative z-10 max-w-4xl mx-auto py-6 px-4 sm:px-6 lg:px-8"
};
const _hoisted_4$1b = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 p-6 mb-6 transition-all duration-500" };
const _hoisted_5$18 = { class: "flex items-center justify-between mb-4" };
const _hoisted_6$15 = { class: "flex space-x-2" };
const _hoisted_7$11 = { class: "flex items-center justify-between" };
const _hoisted_8$$ = { class: "flex items-center mb-1" };
const _hoisted_9$_ = { class: "text-2xl sm:text-3xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 dark:from-blue-400 dark:to-indigo-400 bg-clip-text text-transparent" };
const _hoisted_10$Z = { class: "mt-2 text-gray-700 dark:text-white/80" };
const _hoisted_11$Z = { class: "text-right" };
const _hoisted_12$W = { class: "text-sm text-gray-500 dark:text-white/60 mt-2" };
const _hoisted_13$W = { class: "mt-6" };
const _hoisted_14$V = { class: "flex justify-between text-sm text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_15$P = { class: "w-full bg-gray-200 dark:bg-dark-bg-mute rounded-full h-3" };
const _hoisted_16$O = { class: "grid grid-cols-1 lg:grid-cols-3 gap-6" };
const _hoisted_17$N = { class: "lg:col-span-2 space-y-6" };
const _hoisted_18$L = { class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6" };
const _hoisted_19$L = { class: "text-xl font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_20$K = { class: "prose dark:prose-invert max-w-none" };
const _hoisted_21$K = ["innerHTML"];
const _hoisted_22$I = { class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6" };
const _hoisted_23$I = { class: "text-xl font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_24$G = { class: "space-y-4" };
const _hoisted_25$G = { class: "text-gray-900 dark:text-white font-medium" };
const _hoisted_26$E = { class: "text-gray-600 dark:text-white/80 text-sm mt-1" };
const _hoisted_27$D = {
  key: 0,
  class: "text-gray-500 dark:text-white/60 text-xs mt-1"
};
const _hoisted_28$B = { class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6" };
const _hoisted_29$z = { class: "text-xl font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_30$x = { class: "space-y-3" };
const _hoisted_31$w = { class: "flex-shrink-0 w-6 h-6 bg-blue-100 dark:bg-dark-bg-mute rounded-full flex items-center justify-center" };
const _hoisted_32$t = { class: "text-blue-600 dark:text-blue-400 text-sm font-medium" };
const _hoisted_33$s = { class: "text-gray-900 dark:text-white" };
const _hoisted_34$p = { class: "text-gray-600 dark:text-white/80 text-sm" };
const _hoisted_35$p = {
  key: 0,
  class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6"
};
const _hoisted_36$o = { class: "text-xl font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_37$n = { class: "space-y-4" };
const _hoisted_38$n = { class: "flex items-start space-x-3" };
const _hoisted_39$l = { class: "text-red-800 dark:text-red-400 font-medium" };
const _hoisted_40$l = { class: "text-green-800 dark:text-green-400 font-medium mt-1" };
const _hoisted_41$k = { class: "text-gray-600 dark:text-white/80 text-sm mt-1" };
const _hoisted_42$i = { class: "space-y-6" };
const _hoisted_43$h = { class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6" };
const _hoisted_44$g = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_45$f = { class: "space-y-3" };
const _hoisted_46$f = { class: "flex justify-between" };
const _hoisted_47$f = { class: "text-gray-600 dark:text-white/60" };
const _hoisted_48$f = { class: "text-gray-900 dark:text-white" };
const _hoisted_49$e = { class: "flex justify-between" };
const _hoisted_50$d = { class: "text-gray-600 dark:text-white/60" };
const _hoisted_51$c = { class: "text-gray-900 dark:text-white" };
const _hoisted_52$c = { class: "flex justify-between" };
const _hoisted_53$c = { class: "text-gray-600 dark:text-white/60" };
const _hoisted_54$c = { class: "text-gray-900 dark:text-white" };
const _hoisted_55$c = { class: "flex justify-between" };
const _hoisted_56$b = { class: "text-gray-600 dark:text-white/60" };
const _hoisted_57$b = { class: "flex items-center" };
const _hoisted_58$b = { class: "text-gray-900 dark:text-white" };
const _hoisted_59$a = { class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6" };
const _hoisted_60$a = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_61$9 = { class: "space-y-3" };
const _hoisted_62$9 = ["onClick"];
const _hoisted_63$7 = { class: "text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_64$7 = { class: "text-xs text-gray-500 dark:text-white/60" };
const _hoisted_65$7 = { class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6" };
const _hoisted_66$7 = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_67$6 = { class: "space-y-3" };
const _sfc_main$1m = /* @__PURE__ */ defineComponent({
  __name: "GrammarDetailView",
  setup(__props) {
    const GrammarFormDialog = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => GrammarFormDialog$1),true              ?void 0:void 0))
    );
    const router = useRouter();
    const route = useRoute();
    const grammarStore = useGrammarStore();
    const { t } = useI18n();
    const showEditDialog = ref(false);
    const currentLessonId = ref("");
    const isLoading = ref(true);
    const lesson = ref({});
    const relatedLessons = ref([]);
    const loadLesson = async () => {
      const id = route.params.id;
      currentLessonId.value = id;
      try {
        await new Promise((resolve) => setTimeout(resolve, 500));
        const grammarLesson = grammarStore.getLesson(id);
        if (grammarLesson) {
          lesson.value = {
            id: grammarLesson.id,
            title: grammarLesson.title,
            description: grammarLesson.description,
            level: grammarLesson.level,
            category: grammarLesson.category,
            duration: grammarLesson.duration,
            rating: grammarLesson.rating,
            progress: grammarLesson.progress,
            exercises: grammarLesson.exercises,
            theory: grammarLesson.theory,
            examples: grammarLesson.examples.map((ex) => ({
              id: ex.id,
              sentence: ex.text,
              translation: ex.translation,
              note: ex.note
            })),
            rules: grammarLesson.rules,
            commonMistakes: grammarLesson.commonMistakes || []
          };
          const related = grammarStore.getRelatedLessons(id, grammarLesson.category);
          relatedLessons.value = related.map((rel) => ({
            id: parseInt(rel.id),
            title: rel.title,
            category: rel.category
          }));
        } else {
          console.error("Lesson not found:", id);
        }
      } catch (error) {
        console.error("Error loading lesson:", error);
      } finally {
        isLoading.value = false;
      }
    };
    const goBack = () => {
      router.back();
    };
    const practiceLesson = () => {
      router.push(`/grammar/${route.params.id}/practice`);
    };
    const openEditDialog = () => {
      showEditDialog.value = true;
    };
    const onLessonUpdated = () => {
      loadLesson();
    };
    const viewRelatedLesson = (relatedLesson) => {
      router.push(`/grammar/${relatedLesson.id}`);
    };
    const markAsCompleted = () => {
      lesson.value.progress = 100;
      grammarStore.updateLesson(currentLessonId.value, { progress: 100 });
    };
    const addToFavorites = () => {
      alert(t("grammar.detail.addedToFavorites", "Added to favorites"));
    };
    const shareLesson = () => {
      if (navigator.share) {
        navigator.share({
          title: lesson.value.title,
          text: lesson.value.description,
          url: window.location.href
        });
      } else {
        navigator.clipboard.writeText(window.location.href);
        alert(t("grammar.detail.linkCopied", "Link copied to clipboard"));
      }
    };
    const getLevelColor = (level) => {
      switch (level) {
        case "beginner":
          return "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300";
        case "intermediate":
          return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300";
        case "advanced":
          return "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300";
        default:
          return "bg-gray-100 text-gray-800 dark:bg-dark-bg-mute dark:text-white/80";
      }
    };
    const getLevelText = (level) => {
      const fallbackMap = {
        beginner: "Beginner",
        intermediate: "Intermediate",
        advanced: "Advanced"
      };
      return t(`grammar.levels.${level}`, fallbackMap[level] || "Level");
    };
    onMounted(() => {
      loadLesson();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1l, [
        _cache[8] || (_cache[8] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0" data-v-4d2c13f2><div class="floating-shapes" data-v-4d2c13f2><div class="absolute top-20 left-10 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob" data-v-4d2c13f2></div><div class="absolute top-40 right-10 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000" data-v-4d2c13f2></div><div class="absolute -bottom-8 left-20 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000" data-v-4d2c13f2></div></div></div>', 1)),
        isLoading.value ? (openBlock(), createElementBlock("div", _hoisted_2$1i, _cache[1] || (_cache[1] = [
          createStaticVNode('<div class="bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6" data-v-4d2c13f2><div class="animate-pulse" data-v-4d2c13f2><div class="h-8 bg-gray-200 dark:bg-dark-bg-mute rounded w-1/2 mb-4" data-v-4d2c13f2></div><div class="space-y-3" data-v-4d2c13f2><div class="h-4 bg-gray-200 dark:bg-dark-bg-mute rounded" data-v-4d2c13f2></div><div class="h-4 bg-gray-200 dark:bg-dark-bg-mute rounded w-5/6" data-v-4d2c13f2></div><div class="h-4 bg-gray-200 dark:bg-dark-bg-mute rounded w-3/4" data-v-4d2c13f2></div></div></div></div>', 1)
        ]))) : (openBlock(), createElementBlock("div", _hoisted_3$1f, [
          createBaseVNode("div", _hoisted_4$1b, [
            createBaseVNode("div", _hoisted_5$18, [
              createBaseVNode("button", {
                onClick: goBack,
                class: "p-2 rounded-lg text-gray-600 dark:text-white/70 hover:text-gray-800 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-[#0f0f0f] transition-colors"
              }, _cache[2] || (_cache[2] = [
                createBaseVNode("svg", {
                  class: "w-6 h-6",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                    "clip-rule": "evenodd"
                  })
                ], -1)
              ])),
              createBaseVNode("div", _hoisted_6$15, [
                createBaseVNode("button", {
                  onClick: practiceLesson,
                  class: "bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                }, [
                  _cache[3] || (_cache[3] = createBaseVNode("svg", {
                    class: "w-5 h-5 inline mr-2",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)),
                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.practice.title", "Practice")), 1)
                ]),
                createBaseVNode("button", {
                  onClick: openEditDialog,
                  class: "bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                }, [
                  _cache[4] || (_cache[4] = createBaseVNode("svg", {
                    class: "w-5 h-5 inline mr-2",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
                  ], -1)),
                  createTextVNode(" " + toDisplayString$1(unref(t)("common.edit", "Edit")), 1)
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_7$11, [
              createBaseVNode("div", null, [
                createBaseVNode("div", _hoisted_8$$, [
                  _cache[5] || (_cache[5] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                    createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-indigo-500 rounded-full mr-2.5" })
                  ], -1)),
                  createBaseVNode("h1", _hoisted_9$_, toDisplayString$1(lesson.value.title), 1)
                ]),
                createBaseVNode("p", _hoisted_10$Z, toDisplayString$1(lesson.value.description), 1)
              ]),
              createBaseVNode("div", _hoisted_11$Z, [
                createBaseVNode("span", {
                  class: normalizeClass([getLevelColor(lesson.value.level), "px-3 py-1 text-sm font-medium rounded-full"])
                }, toDisplayString$1(getLevelText(lesson.value.level)), 3),
                createBaseVNode("p", _hoisted_12$W, toDisplayString$1(lesson.value.duration) + " " + toDisplayString$1(unref(t)("grammar.duration", "mins")), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_13$W, [
              createBaseVNode("div", _hoisted_14$V, [
                createBaseVNode("span", null, toDisplayString$1(unref(t)("grammar.progress", "Progress")), 1),
                createBaseVNode("span", null, toDisplayString$1(lesson.value.progress) + "%", 1)
              ]),
              createBaseVNode("div", _hoisted_15$P, [
                createBaseVNode("div", {
                  class: "bg-blue-500 h-3 rounded-full transition-all duration-300",
                  style: normalizeStyle({ width: lesson.value.progress + "%" })
                }, null, 4)
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_16$O, [
            createBaseVNode("div", _hoisted_17$N, [
              createBaseVNode("div", _hoisted_18$L, [
                createBaseVNode("h2", _hoisted_19$L, toDisplayString$1(unref(t)("grammar.detail.theory", "Theory")), 1),
                createBaseVNode("div", _hoisted_20$K, [
                  createBaseVNode("div", {
                    innerHTML: lesson.value.theory
                  }, null, 8, _hoisted_21$K)
                ])
              ]),
              createBaseVNode("div", _hoisted_22$I, [
                createBaseVNode("h2", _hoisted_23$I, toDisplayString$1(unref(t)("grammar.detail.examples", "Examples")), 1),
                createBaseVNode("div", _hoisted_24$G, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(lesson.value.examples, (example) => {
                    return openBlock(), createElementBlock("div", {
                      key: example.id,
                      class: "border-l-4 border-blue-500 pl-4"
                    }, [
                      createBaseVNode("p", _hoisted_25$G, toDisplayString$1(example.sentence), 1),
                      createBaseVNode("p", _hoisted_26$E, toDisplayString$1(example.translation), 1),
                      example.note ? (openBlock(), createElementBlock("p", _hoisted_27$D, toDisplayString$1(example.note), 1)) : createCommentVNode("", true)
                    ]);
                  }), 128))
                ])
              ]),
              createBaseVNode("div", _hoisted_28$B, [
                createBaseVNode("h2", _hoisted_29$z, toDisplayString$1(unref(t)("grammar.detail.usageRules", "Usage Rules")), 1),
                createBaseVNode("div", _hoisted_30$x, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(lesson.value.rules, (rule) => {
                    return openBlock(), createElementBlock("div", {
                      key: rule.id,
                      class: "flex items-start space-x-3"
                    }, [
                      createBaseVNode("div", _hoisted_31$w, [
                        createBaseVNode("span", _hoisted_32$t, toDisplayString$1(rule.id), 1)
                      ]),
                      createBaseVNode("div", null, [
                        createBaseVNode("p", _hoisted_33$s, toDisplayString$1(rule.title), 1),
                        createBaseVNode("p", _hoisted_34$p, toDisplayString$1(rule.description), 1)
                      ])
                    ]);
                  }), 128))
                ])
              ]),
              lesson.value.commonMistakes && lesson.value.commonMistakes.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_35$p, [
                createBaseVNode("h2", _hoisted_36$o, toDisplayString$1(unref(t)("grammar.detail.commonMistakes", "Common Mistakes")), 1),
                createBaseVNode("div", _hoisted_37$n, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(lesson.value.commonMistakes, (mistake) => {
                    return openBlock(), createElementBlock("div", {
                      key: mistake.id,
                      class: "bg-red-50 dark:bg-dark-bg-mute border border-red-200 dark:border-red-900 rounded-lg p-4"
                    }, [
                      createBaseVNode("div", _hoisted_38$n, [
                        _cache[6] || (_cache[6] = createBaseVNode("svg", {
                          class: "w-5 h-5 text-red-500 dark:text-red-400 mt-0.5",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z",
                            "clip-rule": "evenodd"
                          })
                        ], -1)),
                        createBaseVNode("div", null, [
                          createBaseVNode("p", _hoisted_39$l, "❌ " + toDisplayString$1(mistake.wrong), 1),
                          createBaseVNode("p", _hoisted_40$l, "✅ " + toDisplayString$1(mistake.correct), 1),
                          createBaseVNode("p", _hoisted_41$k, toDisplayString$1(mistake.explanation), 1)
                        ])
                      ])
                    ]);
                  }), 128))
                ])
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_42$i, [
              createBaseVNode("div", _hoisted_43$h, [
                createBaseVNode("h3", _hoisted_44$g, toDisplayString$1(unref(t)("grammar.detail.info", "Info")), 1),
                createBaseVNode("div", _hoisted_45$f, [
                  createBaseVNode("div", _hoisted_46$f, [
                    createBaseVNode("span", _hoisted_47$f, toDisplayString$1(unref(t)("grammar.detail.topic", "Topic")) + ":", 1),
                    createBaseVNode("span", _hoisted_48$f, toDisplayString$1(lesson.value.category), 1)
                  ]),
                  createBaseVNode("div", _hoisted_49$e, [
                    createBaseVNode("span", _hoisted_50$d, toDisplayString$1(unref(t)("grammar.detail.duration", "Duration")) + ":", 1),
                    createBaseVNode("span", _hoisted_51$c, toDisplayString$1(lesson.value.duration) + " " + toDisplayString$1(unref(t)("grammar.duration", "mins")), 1)
                  ]),
                  createBaseVNode("div", _hoisted_52$c, [
                    createBaseVNode("span", _hoisted_53$c, toDisplayString$1(unref(t)("grammar.detail.exercises", "Exercises")) + ":", 1),
                    createBaseVNode("span", _hoisted_54$c, toDisplayString$1(lesson.value.exercises), 1)
                  ]),
                  createBaseVNode("div", _hoisted_55$c, [
                    createBaseVNode("span", _hoisted_56$b, toDisplayString$1(unref(t)("grammar.detail.rating", "Rating")) + ":", 1),
                    createBaseVNode("div", _hoisted_57$b, [
                      _cache[7] || (_cache[7] = createBaseVNode("svg", {
                        class: "w-4 h-4 text-yellow-400 mr-1",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" })
                      ], -1)),
                      createBaseVNode("span", _hoisted_58$b, toDisplayString$1(lesson.value.rating), 1)
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_59$a, [
                createBaseVNode("h3", _hoisted_60$a, toDisplayString$1(unref(t)("grammar.detail.relatedLessons", "Related Lessons")), 1),
                createBaseVNode("div", _hoisted_61$9, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(relatedLessons.value, (related) => {
                    return openBlock(), createElementBlock("div", {
                      key: related.id,
                      class: "border border-white/20 dark:border-white/10 rounded-lg p-3 hover:bg-white/60 dark:hover:bg-[#0f0f0f] transition-colors cursor-pointer",
                      onClick: ($event) => viewRelatedLesson(related)
                    }, [
                      createBaseVNode("p", _hoisted_63$7, toDisplayString$1(related.title), 1),
                      createBaseVNode("p", _hoisted_64$7, toDisplayString$1(related.category), 1)
                    ], 8, _hoisted_62$9);
                  }), 128))
                ])
              ]),
              createBaseVNode("div", _hoisted_65$7, [
                createBaseVNode("h3", _hoisted_66$7, toDisplayString$1(unref(t)("common.actions", "Actions")), 1),
                createBaseVNode("div", _hoisted_67$6, [
                  createBaseVNode("button", {
                    onClick: markAsCompleted,
                    class: "w-full bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                  }, toDisplayString$1(unref(t)("grammar.detail.markCompleted", "Mark as Completed")), 1),
                  createBaseVNode("button", {
                    onClick: addToFavorites,
                    class: "w-full bg-yellow-500 hover:bg-yellow-600 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                  }, toDisplayString$1(unref(t)("grammar.detail.addToFavorites", "Add to Favorites")), 1),
                  createBaseVNode("button", {
                    onClick: shareLesson,
                    class: "w-full bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                  }, toDisplayString$1(unref(t)("grammar.detail.shareLesson", "Share Lesson")), 1)
                ])
              ])
            ])
          ])
        ])),
        createVNode(unref(GrammarFormDialog), {
          modelValue: showEditDialog.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showEditDialog.value = $event),
          "edit-id": currentLessonId.value,
          onSaved: onLessonUpdated
        }, null, 8, ["modelValue", "edit-id"])
      ]);
    };
  }
});

const GrammarDetailView = /* @__PURE__ */ _export_sfc(_sfc_main$1m, [["__scopeId", "data-v-4d2c13f2"]]);

const _hoisted_1$1k = { class: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative overflow-x-hidden" };
const _hoisted_2$1h = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-3 sm:pt-6" };
const _hoisted_3$1e = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_4$1a = { class: "flex items-center justify-between" };
const _hoisted_5$17 = { class: "flex items-center space-x-4" };
const _hoisted_6$14 = { class: "flex items-center mb-1" };
const _hoisted_7$10 = { class: "text-xl sm:text-2xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 dark:from-blue-400 dark:to-indigo-400 bg-clip-text text-transparent" };
const _hoisted_8$_ = { class: "text-sm text-gray-600 dark:text-white/70" };
const _hoisted_9$Z = { class: "flex items-center space-x-4" };
const _hoisted_10$Y = { class: "text-sm text-gray-600 dark:text-white/70" };
const _hoisted_11$Y = { class: "font-medium text-blue-600 dark:text-blue-400" };
const _hoisted_12$V = ["title"];
const _hoisted_13$V = ["title"];
const _hoisted_14$U = { class: "relative z-10 max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8" };
const _hoisted_15$O = {
  key: 0,
  class: "space-y-6"
};
const _hoisted_16$N = { class: "text-center" };
const _hoisted_17$M = { class: "text-2xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 dark:from-blue-400 dark:to-indigo-400 bg-clip-text text-transparent mb-4" };
const _hoisted_18$K = { class: "text-gray-700 dark:text-white/70 mb-8" };
const _hoisted_19$K = { class: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6" };
const _hoisted_20$J = ["onClick"];
const _hoisted_21$J = { class: "text-center" };
const _hoisted_22$H = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-2" };
const _hoisted_23$H = { class: "text-sm text-gray-600 dark:text-white/70 mb-4" };
const _hoisted_24$F = { class: "flex items-center justify-center space-x-4 text-xs text-gray-500 dark:text-white/60" };
const _hoisted_25$F = {
  key: 1,
  class: "space-y-6"
};
const _hoisted_26$D = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-gray-700 p-6" };
const _hoisted_27$C = { class: "flex items-center justify-between" };
const _hoisted_28$A = { class: "flex items-center space-x-4" };
const _hoisted_29$y = { class: "text-xl font-semibold text-gray-900 dark:text-white" };
const _hoisted_30$w = { class: "text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_31$v = { class: "flex items-center space-x-4" };
const _hoisted_32$s = { class: "w-32 bg-gray-200 dark:bg-mute rounded-full h-2" };
const _hoisted_33$r = { class: "text-sm font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_34$o = {
  key: 0,
  class: "fixed inset-0 bg-black/50 dark:bg-black/60 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_35$o = { class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-dark-bg-mute flex flex-col h-full overflow-hidden transform" };
const _hoisted_36$n = { class: "px-6 py-4 border-b border-gray-200 dark:border-dark-bg-mute flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_37$m = { class: "flex items-center justify-between" };
const _hoisted_38$m = { class: "text-lg sm:text-xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_39$k = { class: "px-6 py-4 flex-1 overflow-y-auto min-h-0 space-y-4" };
const _hoisted_40$k = { class: "block text-sm font-medium text-gray-700 dark:text-white mb-2" };
const _hoisted_41$j = { value: "easy" };
const _hoisted_42$h = { value: "medium" };
const _hoisted_43$g = { value: "hard" };
const _hoisted_44$f = { class: "flex items-center justify-between" };
const _hoisted_45$e = { class: "text-sm font-medium text-gray-700 dark:text-white" };
const _hoisted_46$e = { class: "flex items-center justify-between" };
const _hoisted_47$e = { class: "text-sm font-medium text-gray-700 dark:text-white" };
const _hoisted_48$e = { class: "px-6 py-4 border-t border-gray-200 dark:border-dark-bg-mute flex-shrink-0 bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_49$d = { class: "flex justify-end space-x-3" };
const _hoisted_50$c = {
  key: 0,
  class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
};
const _hoisted_51$b = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-gray-700 p-6 max-w-lg w-full mx-4" };
const _hoisted_52$b = { class: "text-center" };
const _hoisted_53$b = { class: "text-2xl font-bold text-gray-900 dark:text-white mb-2" };
const _hoisted_54$b = { class: "space-y-4 mb-6" };
const _hoisted_55$b = { class: "grid grid-cols-3 gap-4 text-center" };
const _hoisted_56$a = { class: "bg-blue-50 dark:bg-blue-900/30 rounded-lg p-4" };
const _hoisted_57$a = { class: "text-2xl font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_58$a = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_59$9 = { class: "bg-red-50 dark:bg-red-900/30 rounded-lg p-4" };
const _hoisted_60$9 = { class: "text-2xl font-bold text-red-600 dark:text-red-400" };
const _hoisted_61$8 = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_62$8 = { class: "bg-green-50 dark:bg-green-900/30 rounded-lg p-4" };
const _hoisted_63$6 = { class: "text-2xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_64$6 = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_65$6 = { class: "flex justify-center space-x-4" };
const _hoisted_66$6 = {
  key: 1,
  class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
};
const _hoisted_67$5 = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-gray-700 p-6 max-w-6xl w-full mx-4 max-h-[90vh] overflow-y-auto" };
const _hoisted_68$5 = { class: "flex items-center justify-between mb-6" };
const _hoisted_69$5 = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_70$5 = { class: "space-y-6" };
const _hoisted_71$5 = { class: "bg-gray-50 dark:bg-gray-800/30 border border-gray-200 dark:border-gray-600 rounded-lg p-4" };
const _hoisted_72$5 = { class: "text-md font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_73$5 = {
  key: 0,
  class: "space-y-4"
};
const _hoisted_74$5 = { class: "grid grid-cols-1 md:grid-cols-2 gap-4" };
const _hoisted_75$4 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_76$4 = { value: "essay" };
const _hoisted_77$4 = { value: "email" };
const _hoisted_78$3 = { value: "letter" };
const _hoisted_79$3 = { value: "paragraph" };
const _hoisted_80$3 = { class: "grid grid-cols-2 gap-2" };
const _hoisted_81$3 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_82$3 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_83$3 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_84$3 = ["placeholder"];
const _hoisted_85$3 = { class: "flex items-center justify-between mb-2" };
const _hoisted_86$2 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_87$2 = { class: "space-y-2" };
const _hoisted_88$2 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_89$2 = ["onClick", "disabled"];
const _hoisted_90$2 = {
  key: 1,
  class: "space-y-4"
};
const _hoisted_91$2 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_92$2 = ["placeholder"];
const _hoisted_93$2 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_94$2 = { class: "space-y-2" };
const _hoisted_95$2 = { class: "text-sm font-medium text-gray-500 dark:text-gray-400 w-6" };
const _hoisted_96$2 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_97$2 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_98$2 = ["value"];
const _hoisted_99$2 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_100$1 = ["placeholder"];
const _hoisted_101$1 = {
  key: 2,
  class: "space-y-4"
};
const _hoisted_102$1 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_103$1 = { class: "relative" };
const _hoisted_104$1 = ["placeholder"];
const _hoisted_105$1 = { class: "mt-2 text-xs text-gray-500 dark:text-gray-400" };
const _hoisted_106$1 = {
  key: 0,
  class: "mt-3 p-3 bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded-lg"
};
const _hoisted_107$1 = { class: "flex items-center space-x-2 text-sm text-blue-800 dark:text-blue-200" };
const _hoisted_108$1 = { class: "mt-2 text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_109$1 = { class: "grid grid-cols-1 md:grid-cols-3 gap-4" };
const _hoisted_110$1 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_111$1 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_112 = { value: "easy" };
const _hoisted_113 = { value: "medium" };
const _hoisted_114 = { value: "hard" };
const _hoisted_115 = { class: "flex items-center" };
const _hoisted_116 = { class: "flex items-center space-x-2 cursor-pointer" };
const _hoisted_117 = { class: "text-sm font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_118 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_119 = ["placeholder"];
const _hoisted_120 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_121 = { class: "space-y-3" };
const _hoisted_122 = { class: "flex items-center justify-between mb-2" };
const _hoisted_123 = { class: "text-sm font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_124 = ["onClick", "disabled"];
const _hoisted_125 = { class: "space-y-2" };
const _hoisted_126 = ["onUpdate:modelValue"];
const _hoisted_127 = { value: "multiple-choice" };
const _hoisted_128 = { value: "fill-blank" };
const _hoisted_129 = { value: "ordering" };
const _hoisted_130 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_131 = {
  key: 0,
  class: "space-y-1"
};
const _hoisted_132 = { class: "text-xs font-medium text-gray-500 dark:text-gray-400 w-4" };
const _hoisted_133 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_134 = ["onUpdate:modelValue"];
const _hoisted_135 = { value: "" };
const _hoisted_136 = ["value"];
const _hoisted_137 = { key: 1 };
const _hoisted_138 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_139 = {
  key: 3,
  class: "space-y-4"
};
const _hoisted_140 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_141 = ["placeholder"];
const _hoisted_142 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_143 = ["placeholder"];
const _hoisted_144 = { class: "flex justify-end mt-4" };
const _hoisted_145 = { key: 0 };
const _hoisted_146 = { class: "text-md font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_147 = { class: "space-y-4 max-h-96 overflow-y-auto" };
const _hoisted_148 = { class: "flex items-start justify-between" };
const _hoisted_149 = { class: "flex-1" };
const _hoisted_150 = { class: "mb-2" };
const _hoisted_151 = { class: "inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200" };
const _hoisted_152 = {
  key: 0,
  class: "ml-2 inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200"
};
const _hoisted_153 = { class: "text-sm text-gray-900 dark:text-white mb-2" };
const _hoisted_154 = { class: "mt-1" };
const _hoisted_155 = {
  key: 0,
  class: "text-xs text-gray-600 dark:text-gray-400"
};
const _hoisted_156 = { class: "list-disc list-inside mt-1" };
const _hoisted_157 = {
  key: 1,
  class: "text-xs text-gray-600 dark:text-gray-400 mt-2"
};
const _hoisted_158 = { class: "flex items-center space-x-2 ml-4" };
const _hoisted_159 = ["onClick", "title"];
const _hoisted_160 = ["onClick", "title"];
const _hoisted_161 = {
  key: 1,
  class: "text-center py-8"
};
const _hoisted_162 = { class: "text-gray-500 dark:text-gray-400" };
const _hoisted_163 = { class: "text-sm mt-1" };
const _hoisted_164 = { class: "flex justify-end space-x-4 mt-6" };
const _sfc_main$1l = /* @__PURE__ */ defineComponent({
  __name: "GrammarPracticeView",
  setup(__props) {
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      const translated = params ? t(key, params) : t(key);
      const text = typeof translated === "string" ? translated : String(translated);
      if (text === key) return fallback;
      return text;
    };
    const route = useRoute();
    const router = useRouter();
    const { playAudio } = useVoiceStore();
    const MultipleChoiceExercise$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => MultipleChoiceExercise),true              ?void 0:void 0));
    const FillBlankExercise$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FillBlankExercise),true              ?void 0:void 0));
    const PronunciationExercise$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => PronunciationExercise),true              ?void 0:void 0));
    const ReadingExercise$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ReadingExercise),true              ?void 0:void 0));
    const ListeningExercise$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ListeningExercise),true              ?void 0:void 0));
    const WritingExercise$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => WritingExercise),true              ?void 0:void 0));
    const ExerciseManager$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ExerciseManager),true              ?void 0:void 0));
    const BookOpenIcon = () => h("svg", { class: "w-8 h-8 text-white", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" }, [
      h("path", { "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C20.168 18.477 18.582 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" })
    ]);
    const PencilIcon = () => h("svg", { class: "w-8 h-8 text-white", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" }, [
      h("path", { "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" })
    ]);
    const SpeakerWaveIcon = () => h("svg", { class: "w-8 h-8 text-white", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" }, [
      h("path", { "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5.25 5.25 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.59-.71-1.59-1.59V9.84c0-.88.71-1.59 1.59-1.59h2.24z" })
    ]);
    const MicrophoneIcon = () => h("svg", { class: "w-8 h-8 text-white", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" }, [
      h("path", { "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3zM19 10v2a7 7 0 0 1-14 0v-2M12 19v4M8 23h8" })
    ]);
    const EyeIcon = () => h("svg", { class: "w-8 h-8 text-white", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" }, [
      h("path", { "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z" }),
      h("path", { "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" })
    ]);
    const EditIcon = () => h("svg", { class: "w-8 h-8 text-white", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" }, [
      h("path", { "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" })
    ]);
    computed(() => route.params.id);
    const selectedExercise = ref(null);
    const currentQuestionIndex = ref(0);
    const totalQuestions = ref(10);
    const currentQuestion = ref(null);
    const exerciseResults = ref({
      correct: 0,
      incorrect: 0,
      percentage: 0,
      answers: []
    });
    const showSettings = ref(false);
    const showResults = ref(false);
    const showExerciseManager = ref(false);
    const totalScore = ref(0);
    const newExercise = ref({
      type: "",
      title: "",
      description: "",
      difficulty: "medium",
      duration: ""
    });
    const exerciseQuestions = ref({});
    const showQuestionManager = ref(false);
    const selectedExerciseTypeForQuestions = ref("");
    const newQuestion = ref({
      id: "",
      type: "",
      question: "",
      options: ["", "", "", ""],
      correctAnswer: "",
      explanation: "",
      difficulty: "medium",
      // Writing specific fields
      taskType: "essay",
      prompt: "",
      requirements: [""],
      minWords: 100,
      timeLimit: 20,
      // Listening specific fields
      audioUrl: "",
      originalUrl: "",
      maxPlays: 3,
      allowNotes: false,
      transcript: "",
      questions: []
    });
    const editingQuestionIndex = ref(-1);
    const settings = ref({
      difficulty: "medium",
      autoPlayAudio: true,
      showExplanations: true
    });
    const exerciseTypes = ref([
      {
        type: "multiple-choice",
        title: "Multiple Choice",
        description: "Choose the correct answer from multiple options",
        icon: BookOpenIcon,
        colorClass: "bg-gray-500",
        duration: "10-15 min",
        difficulty: "Easy"
      },
      {
        type: "fill-blank",
        title: "Fill in the Blanks",
        description: "Complete sentences by filling in missing words",
        icon: PencilIcon,
        colorClass: "bg-green-500",
        duration: "15-20 min",
        difficulty: "Medium"
      },
      {
        type: "pronunciation",
        title: "Pronunciation Practice",
        description: "Practice speaking and pronunciation skills",
        icon: MicrophoneIcon,
        colorClass: "bg-purple-500",
        duration: "10-15 min",
        difficulty: "Medium"
      },
      {
        type: "reading",
        title: "Reading Comprehension",
        description: "Read passages and answer comprehension questions",
        icon: EyeIcon,
        colorClass: "bg-orange-500",
        duration: "20-25 min",
        difficulty: "Hard"
      },
      {
        type: "listening",
        title: "Listening Exercise",
        description: "Listen to audio and answer related questions",
        icon: SpeakerWaveIcon,
        colorClass: "bg-indigo-500",
        duration: "15-20 min",
        difficulty: "Medium"
      },
      {
        type: "writing",
        title: "Writing Practice",
        description: "Practice writing skills with various prompts",
        icon: EditIcon,
        colorClass: "bg-red-500",
        duration: "25-30 min",
        difficulty: "Hard"
      }
    ]);
    const currentExerciseComponent = computed(() => {
      const componentMap = {
        "multiple-choice": MultipleChoiceExercise$1,
        "fill-blank": FillBlankExercise$1,
        "pronunciation": PronunciationExercise$1,
        "reading": ReadingExercise$1,
        "listening": ListeningExercise$1,
        "writing": WritingExercise$1
      };
      return selectedExercise.value ? componentMap[selectedExercise.value] || null : null;
    });
    const startExercise = (exerciseType) => {
      selectedExercise.value = exerciseType;
      currentQuestionIndex.value = 0;
      exerciseResults.value = {
        correct: 0,
        incorrect: 0,
        percentage: 0,
        answers: []
      };
      generateQuestions();
      const newQuery = { ...route.query, exercise: exerciseType };
      router.replace({ query: newQuery });
    };
    const generateQuestions = () => {
      if (!selectedExercise.value) return;
      const savedQuestions = exerciseQuestions.value[selectedExercise.value] || [];
      if (savedQuestions.length > 0) {
        const questionIndex = currentQuestionIndex.value % savedQuestions.length;
        currentQuestion.value = savedQuestions[questionIndex];
      } else {
        generateDefaultQuestions();
      }
    };
    const generateDefaultQuestions = () => {
      if (selectedExercise.value === "writing") {
        const writingTasks = [
          {
            id: 1,
            type: "writing",
            taskType: "essay",
            prompt: "Write an essay about the importance of learning English in today's globalized world. Discuss how English proficiency can benefit individuals in their personal and professional lives.",
            requirements: [
              "Write at least 250 words",
              "Include an introduction, body paragraphs, and conclusion",
              "Use specific examples to support your points",
              "Demonstrate proper grammar and vocabulary usage"
            ],
            minWords: 250,
            timeLimit: 30
          },
          {
            id: 2,
            type: "writing",
            taskType: "email",
            prompt: "Write a formal email to your manager requesting time off for a family vacation. Include the dates, reason, and any work arrangements you have made.",
            requirements: [
              "Use formal email format",
              "Include appropriate subject line",
              "Be polite and professional",
              "Provide all necessary details"
            ],
            minWords: 150,
            timeLimit: 20
          },
          {
            id: 3,
            type: "writing",
            taskType: "letter",
            prompt: "Write a letter to a friend describing your recent trip to a new city. Share your experiences, what you liked most, and recommend places to visit.",
            requirements: [
              "Use informal, friendly tone",
              "Include specific details about places visited",
              "Share personal experiences and feelings",
              "Make recommendations"
            ],
            minWords: 200,
            timeLimit: 25
          }
        ];
        const taskIndex = currentQuestionIndex.value % writingTasks.length;
        currentQuestion.value = writingTasks[taskIndex];
      } else if (selectedExercise.value === "multiple-choice") {
        const mcQuestions = [
          {
            id: 1,
            type: "multiple-choice",
            question: 'Choose the correct form of the verb: "She _____ to the store yesterday."',
            options: ["go", "goes", "went", "going"],
            correctAnswer: "went",
            explanation: "Past tense is used for actions completed in the past."
          },
          {
            id: 2,
            type: "multiple-choice",
            question: "Which sentence is grammatically correct?",
            options: [
              "I have been living here since 5 years.",
              "I have been living here for 5 years.",
              "I am living here since 5 years.",
              "I live here since 5 years."
            ],
            correctAnswer: "I have been living here for 5 years.",
            explanation: 'Use "for" with duration and present perfect continuous for ongoing actions.'
          }
        ];
        const questionIndex = currentQuestionIndex.value % mcQuestions.length;
        currentQuestion.value = mcQuestions[questionIndex];
      } else if (selectedExercise.value === "fill-blank") {
        const fillBlankQuestions = [
          {
            id: 1,
            type: "fill-blank",
            question: 'Complete the sentence: "I _____ been studying English _____ three years."',
            blanks: ["have", "for"],
            sentence: "I _____ been studying English _____ three years.",
            explanation: 'Present perfect continuous with "have" and duration with "for".'
          }
        ];
        const questionIndex = currentQuestionIndex.value % fillBlankQuestions.length;
        currentQuestion.value = fillBlankQuestions[questionIndex];
      } else {
        currentQuestion.value = {
          id: 1,
          type: selectedExercise.value,
          question: `Sample ${selectedExercise.value} question`,
          options: ["Option A", "Option B", "Option C", "Option D"],
          correctAnswer: "Option A",
          explanation: "This is the correct answer because..."
        };
      }
    };
    const handleAnswer = (answer) => {
      const isCorrect = answer.isCorrect;
      if (isCorrect) {
        exerciseResults.value.correct++;
      } else {
        exerciseResults.value.incorrect++;
      }
      exerciseResults.value.answers.push({
        questionIndex: currentQuestionIndex.value,
        userAnswer: answer.userAnswer,
        correctAnswer: answer.correctAnswer,
        isCorrect
      });
    };
    const nextQuestion = () => {
      if (currentQuestionIndex.value < totalQuestions.value - 1) {
        currentQuestionIndex.value++;
        generateQuestions();
      } else {
        completeExercise();
      }
    };
    const completeExercise = () => {
      const total = exerciseResults.value.correct + exerciseResults.value.incorrect;
      exerciseResults.value.percentage = total > 0 ? Math.round(exerciseResults.value.correct / total * 100) : 0;
      totalScore.value += exerciseResults.value.correct * 10;
      showResults.value = true;
    };
    const restartExercise = () => {
      showResults.value = false;
      currentQuestionIndex.value = 0;
      exerciseResults.value = {
        correct: 0,
        incorrect: 0,
        percentage: 0,
        answers: []
      };
      generateQuestions();
    };
    const goBackToSelection = () => {
      selectedExercise.value = null;
      showResults.value = false;
      currentQuestionIndex.value = 0;
      const newQuery = { ...route.query };
      delete newQuery.exercise;
      router.replace({ query: newQuery });
    };
    const saveSettings = () => {
      localStorage.setItem("grammarPracticeSettings", JSON.stringify(settings.value));
      showSettings.value = false;
    };
    const goBackToGrammarDetail = () => {
      const grammarId2 = route.params.id;
      if (grammarId2) {
        router.push(`/grammar/${grammarId2}`);
      } else {
        router.push("/grammar");
      }
    };
    const addExerciseType = () => {
      if (!newExercise.value.type || !newExercise.value.title) {
        return;
      }
      const exerciseToAdd = {
        type: newExercise.value.type,
        title: newExercise.value.title,
        description: newExercise.value.description,
        difficulty: newExercise.value.difficulty,
        duration: newExercise.value.duration,
        icon: BookOpenIcon,
        colorClass: "bg-blue-500"
      };
      exerciseTypes.value.push(exerciseToAdd);
      newExercise.value = {
        type: "",
        title: "",
        description: "",
        difficulty: "medium",
        duration: ""
      };
    };
    const editExerciseType = (index) => {
      const exercise = exerciseTypes.value[index];
      newExercise.value = {
        type: exercise.type,
        title: exercise.title,
        description: exercise.description,
        difficulty: exercise.difficulty,
        duration: exercise.duration
      };
      exerciseTypes.value.splice(index, 1);
    };
    const deleteExerciseType = (index) => {
      if (confirm(t("common.confirmDelete", "Are you sure you want to delete this?"))) {
        exerciseTypes.value.splice(index, 1);
      }
    };
    const saveExerciseTypes = () => {
      localStorage.setItem("grammarExerciseTypes", JSON.stringify(exerciseTypes.value));
      showExerciseManager.value = false;
    };
    const openQuestionManager = (exerciseType) => {
      selectedExerciseTypeForQuestions.value = exerciseType;
      showQuestionManager.value = true;
      resetNewQuestionForm();
    };
    const closeQuestionManager = () => {
      showQuestionManager.value = false;
      selectedExerciseTypeForQuestions.value = "";
      resetNewQuestionForm();
      editingQuestionIndex.value = -1;
    };
    const resetNewQuestionForm = () => {
      if (selectedExerciseTypeForQuestions.value === "listening") {
        newQuestion.value = {
          id: "",
          type: "listening",
          audioUrl: "",
          maxPlays: 3,
          allowNotes: true,
          difficulty: "medium",
          transcript: "",
          questions: [{
            question: "",
            type: "multiple-choice",
            options: ["", "", "", ""],
            correctAnswer: ""
          }]
        };
      } else if (selectedExerciseTypeForQuestions.value === "writing") {
        newQuestion.value = {
          id: "",
          type: "writing",
          question: "",
          options: ["", "", "", ""],
          correctAnswer: "",
          explanation: "",
          difficulty: "medium",
          // Writing specific fields
          taskType: "essay",
          prompt: "",
          requirements: [""],
          minWords: 100,
          timeLimit: 20,
          // Listening specific fields (default values)
          audioUrl: "",
          originalUrl: "",
          maxPlays: 3,
          allowNotes: false,
          transcript: "",
          questions: []
        };
      } else {
        newQuestion.value = {
          id: "",
          type: selectedExerciseTypeForQuestions.value || "",
          question: "",
          options: ["", "", "", ""],
          correctAnswer: "",
          explanation: "",
          difficulty: "medium",
          // Add missing properties to satisfy TypeScript
          taskType: "essay",
          prompt: "",
          requirements: [""],
          minWords: 100,
          timeLimit: 20,
          // Listening specific fields (default values)
          audioUrl: "",
          originalUrl: "",
          maxPlays: 3,
          allowNotes: false,
          transcript: "",
          questions: []
        };
      }
    };
    const addQuestion = () => {
      const exerciseType = selectedExerciseTypeForQuestions.value;
      if (!exerciseType) return;
      const id = Date.now().toString();
      const questionToAdd = {
        ...newQuestion.value,
        id,
        type: exerciseType
      };
      if (exerciseType === "writing") {
        questionToAdd.requirements = questionToAdd.requirements.filter((req) => req.trim() !== "");
      }
      if (!exerciseQuestions.value[exerciseType]) {
        exerciseQuestions.value[exerciseType] = [];
      }
      if (editingQuestionIndex.value >= 0) {
        exerciseQuestions.value[exerciseType][editingQuestionIndex.value] = questionToAdd;
        editingQuestionIndex.value = -1;
      } else {
        exerciseQuestions.value[exerciseType].push(questionToAdd);
      }
      saveQuestionsToStorage();
      resetNewQuestionForm();
    };
    const editQuestion = (index) => {
      const exerciseType = selectedExerciseTypeForQuestions.value;
      const question = exerciseQuestions.value[exerciseType][index];
      newQuestion.value = { ...question };
      editingQuestionIndex.value = index;
    };
    const deleteQuestion = (index) => {
      if (confirm(t("common.confirmDelete", "Are you sure you want to delete this?"))) {
        const exerciseType = selectedExerciseTypeForQuestions.value;
        exerciseQuestions.value[exerciseType].splice(index, 1);
        saveQuestionsToStorage();
      }
    };
    const addRequirement = () => {
      newQuestion.value.requirements.push("");
    };
    const removeRequirement = (index) => {
      if (newQuestion.value.requirements.length > 1) {
        newQuestion.value.requirements.splice(index, 1);
      }
    };
    const addListeningQuestion = () => {
      const listeningQuestion = newQuestion.value;
      if (listeningQuestion.questions) {
        listeningQuestion.questions.push({
          question: "",
          type: "multiple-choice",
          options: ["", "", "", ""],
          correctAnswer: ""
        });
      }
    };
    const removeListeningQuestion = (index) => {
      const listeningQuestion = newQuestion.value;
      if (listeningQuestion.questions && listeningQuestion.questions.length > 1) {
        listeningQuestion.questions.splice(index, 1);
      }
    };
    const isYouTubeUrl = (url) => {
      if (!url) return false;
      const youtubeRegex = /^(https?\:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/.+/;
      return youtubeRegex.test(url);
    };
    const extractYouTubeVideoId = (url) => {
      const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
      const match = url.match(regex);
      return match ? match[1] : null;
    };
    const convertYouTubeToAudioUrl = (url) => {
      const videoId = extractYouTubeVideoId(url);
      if (videoId) {
        return `youtube:${videoId}`;
      }
      return url;
    };
    const handleAudioUrlChange = () => {
      if (isYouTubeUrl(newQuestion.value.audioUrl)) {
        const convertedUrl = convertYouTubeToAudioUrl(newQuestion.value.audioUrl);
        newQuestion.value.originalUrl = newQuestion.value.audioUrl;
        newQuestion.value.audioUrl = convertedUrl;
      }
    };
    const handleUrlPaste = (event) => {
      const pastedText = event.clipboardData?.getData("text") || "";
      if (pastedText) {
        let cleanUrl = pastedText.trim();
        if (cleanUrl.includes("youtube.com") || cleanUrl.includes("youtu.be")) {
          const url = new URL(cleanUrl);
          if (url.hostname.includes("youtube.com")) {
            const videoId = url.searchParams.get("v");
            if (videoId) {
              cleanUrl = `https://www.youtube.com/watch?v=${videoId}`;
            }
          } else if (url.hostname.includes("youtu.be")) {
            const videoId = url.pathname.slice(1);
            if (videoId) {
              cleanUrl = `https://youtu.be/${videoId}`;
            }
          }
        }
        newQuestion.value.audioUrl = cleanUrl;
        event.preventDefault();
        handleAudioUrlChange();
      }
    };
    const clearAudioUrl = () => {
      newQuestion.value.audioUrl = "";
      newQuestion.value.originalUrl = "";
    };
    const saveQuestionsToStorage = () => {
      localStorage.setItem("grammarExerciseQuestions", JSON.stringify(exerciseQuestions.value));
    };
    const loadQuestionsFromStorage = () => {
      const saved = localStorage.getItem("grammarExerciseQuestions");
      if (saved) {
        exerciseQuestions.value = JSON.parse(saved);
      }
    };
    const initializeFromUrl = () => {
      const exerciseFromUrl = route.query.exercise;
      if (exerciseFromUrl && exerciseTypes.value.some((ex) => ex.type === exerciseFromUrl)) {
        selectedExercise.value = exerciseFromUrl;
        generateQuestions();
      } else {
        selectedExercise.value = null;
      }
    };
    watch(() => route.query.exercise, (newExercise2) => {
      if (newExercise2 && exerciseTypes.value.some((ex) => ex.type === newExercise2)) {
        if (selectedExercise.value !== newExercise2) {
          selectedExercise.value = newExercise2;
          currentQuestionIndex.value = 0;
          exerciseResults.value = {
            correct: 0,
            incorrect: 0,
            percentage: 0,
            answers: []
          };
          generateQuestions();
        }
      } else {
        selectedExercise.value = null;
      }
    });
    watch([showQuestionManager, showSettings, showResults, showExerciseManager], ([questionManager, settings2, results, exerciseManager]) => {
      const anyModalOpen = questionManager || settings2 || results || exerciseManager;
      if (anyModalOpen) {
        document.body.style.overflow = "hidden";
      } else {
        document.body.style.overflow = "";
      }
    });
    onMounted(() => {
      const savedSettings = localStorage.getItem("grammarPracticeSettings");
      if (savedSettings) {
        settings.value = { ...settings.value, ...JSON.parse(savedSettings) };
      }
      const savedScore = localStorage.getItem("grammarPracticeScore");
      if (savedScore) {
        totalScore.value = parseInt(savedScore);
      }
      loadQuestionsFromStorage();
      initializeFromUrl();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1k, [
        _cache[40] || (_cache[40] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0"><div class="floating-shapes"><div class="absolute top-16 left-8 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob"></div><div class="absolute top-36 right-8 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000"></div><div class="absolute -bottom-10 left-24 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000"></div></div></div>', 1)),
        createBaseVNode("div", _hoisted_2$1h, [
          createBaseVNode("div", _hoisted_3$1e, [
            createBaseVNode("div", _hoisted_4$1a, [
              createBaseVNode("div", _hoisted_5$17, [
                createBaseVNode("button", {
                  onClick: goBackToGrammarDetail,
                  class: "p-2 rounded-lg text-gray-600 dark:text-white/70 hover:text-gray-800 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-[#0f0f0f] transition-colors"
                }, _cache[23] || (_cache[23] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M15 19l-7-7 7-7"
                    })
                  ], -1)
                ])),
                createBaseVNode("div", null, [
                  createBaseVNode("div", _hoisted_6$14, [
                    _cache[24] || (_cache[24] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                      createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-indigo-500 rounded-full mr-2.5" })
                    ], -1)),
                    createBaseVNode("h1", _hoisted_7$10, toDisplayString$1(unref(t)("grammar.practice.title", "Practice")), 1)
                  ]),
                  createBaseVNode("p", _hoisted_8$_, toDisplayString$1(unref(t)("grammar.practice.subtitle", "Choose a mode to practice grammar with interactive exercises")), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_9$Z, [
                createBaseVNode("div", _hoisted_10$Y, [
                  createTextVNode(toDisplayString$1(unref(t)("grammar.practice.score", "Score")) + ": ", 1),
                  createBaseVNode("span", _hoisted_11$Y, toDisplayString$1(totalScore.value), 1)
                ]),
                createBaseVNode("button", {
                  onClick: _cache[0] || (_cache[0] = ($event) => showExerciseManager.value = true),
                  class: "p-2 rounded-lg text-gray-600 dark:text-white/70 hover:text-gray-800 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-[#0f0f0f] transition-colors",
                  title: unref(t)("grammar.practice.exerciseManager.title", "Manage exercises")
                }, _cache[25] || (_cache[25] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 100 4m0-4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 100 4m0-4v2m0-6V4"
                    })
                  ], -1)
                ]), 8, _hoisted_12$V),
                createBaseVNode("button", {
                  onClick: _cache[1] || (_cache[1] = ($event) => showSettings.value = true),
                  class: "p-2 rounded-lg text-gray-600 dark:text-white/70 hover:text-gray-800 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-[#0f0f0f] transition-colors",
                  title: unref(t)("grammar.practice.settings.title", "Settings")
                }, _cache[26] || (_cache[26] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"
                    }),
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                    })
                  ], -1)
                ]), 8, _hoisted_13$V)
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_14$U, [
          !selectedExercise.value ? (openBlock(), createElementBlock("div", _hoisted_15$O, [
            createBaseVNode("div", _hoisted_16$N, [
              createBaseVNode("h2", _hoisted_17$M, toDisplayString$1(unref(t)("grammar.practice.chooseExercise", "Choose an exercise")), 1),
              createBaseVNode("p", _hoisted_18$K, toDisplayString$1(unref(t)("grammar.practice.chooseDescription", "Select a practice type below to get started")), 1)
            ]),
            createBaseVNode("div", _hoisted_19$K, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(exerciseTypes.value, (exercise) => {
                return openBlock(), createElementBlock("div", {
                  key: exercise.type,
                  onClick: ($event) => startExercise(exercise.type),
                  class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md rounded-2xl shadow-xl border border-white/20 dark:border-white/10 p-6 cursor-pointer hover:shadow-2xl hover:scale-[1.03] transition-all duration-300"
                }, [
                  createBaseVNode("div", _hoisted_21$J, [
                    createBaseVNode("div", {
                      class: normalizeClass(["w-16 h-16 mx-auto mb-4 rounded-full flex items-center justify-center", exercise.colorClass])
                    }, [
                      (openBlock(), createBlock(resolveDynamicComponent(exercise.icon), { class: "w-8 h-8 text-white" }))
                    ], 2),
                    createBaseVNode("h3", _hoisted_22$H, toDisplayString$1(tf(`grammar.practice.exercises.${exercise.type}.title`, exercise.title)), 1),
                    createBaseVNode("p", _hoisted_23$H, toDisplayString$1(tf(`grammar.practice.exercises.${exercise.type}.description`, exercise.description)), 1),
                    createBaseVNode("div", _hoisted_24$F, [
                      createBaseVNode("span", null, toDisplayString$1(exercise.duration), 1),
                      _cache[27] || (_cache[27] = createBaseVNode("span", null, "•", -1)),
                      createBaseVNode("span", null, toDisplayString$1(exercise.difficulty), 1)
                    ])
                  ])
                ], 8, _hoisted_20$J);
              }), 128))
            ])
          ])) : (openBlock(), createElementBlock("div", _hoisted_25$F, [
            createBaseVNode("div", _hoisted_26$D, [
              createBaseVNode("div", _hoisted_27$C, [
                createBaseVNode("div", _hoisted_28$A, [
                  createBaseVNode("button", {
                    onClick: goBackToSelection,
                    class: "p-2 rounded-lg text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
                  }, _cache[28] || (_cache[28] = [
                    createBaseVNode("svg", {
                      class: "w-5 h-5",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M15 19l-7-7 7-7"
                      })
                    ], -1)
                  ])),
                  createBaseVNode("div", null, [
                    createBaseVNode("h2", _hoisted_29$y, toDisplayString$1(tf(`grammar.practice.exercises.${selectedExercise.value}.title`, "Exercise")), 1),
                    createBaseVNode("p", _hoisted_30$w, toDisplayString$1(unref(t)("grammar.practice.question", "Question")) + " " + toDisplayString$1(currentQuestionIndex.value + 1) + " / " + toDisplayString$1(totalQuestions.value), 1)
                  ])
                ]),
                createBaseVNode("div", _hoisted_31$v, [
                  createBaseVNode("div", _hoisted_32$s, [
                    createBaseVNode("div", {
                      class: "bg-blue-600 h-2 rounded-full transition-all duration-300",
                      style: normalizeStyle({ width: `${currentQuestionIndex.value / totalQuestions.value * 100}%` })
                    }, null, 4)
                  ]),
                  createBaseVNode("span", _hoisted_33$r, toDisplayString$1(Math.round(currentQuestionIndex.value / totalQuestions.value * 100)) + "% ", 1)
                ])
              ])
            ]),
            (openBlock(), createBlock(resolveDynamicComponent(currentExerciseComponent.value), {
              question: currentQuestion.value,
              "question-index": currentQuestionIndex.value,
              "total-questions": totalQuestions.value,
              difficulty: settings.value.difficulty,
              onAnswer: handleAnswer,
              onNext: nextQuestion,
              onComplete: completeExercise
            }, null, 40, ["question", "question-index", "total-questions", "difficulty"]))
          ]))
        ]),
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            showSettings.value ? (openBlock(), createElementBlock("div", _hoisted_34$o, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: "w-full max-h-[90vh] flex flex-col max-w-md sm:max-w-md md:max-w-lg",
                    onClick: _cache[7] || (_cache[7] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("div", _hoisted_35$o, [
                      createBaseVNode("div", _hoisted_36$n, [
                        createBaseVNode("div", _hoisted_37$m, [
                          createBaseVNode("h3", _hoisted_38$m, [
                            _cache[29] || (_cache[29] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("grammar.practice.settings.title", "Settings")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: _cache[2] || (_cache[2] = ($event) => showSettings.value = false),
                            class: "text-gray-400 dark:text-white hover:text-gray-600 dark:hover:text-white transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-dark-bg-mute"
                          }, _cache[30] || (_cache[30] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_39$k, [
                        createBaseVNode("div", null, [
                          createBaseVNode("label", _hoisted_40$k, toDisplayString$1(unref(t)("grammar.practice.settings.difficulty", "Difficulty")), 1),
                          withDirectives(createBaseVNode("select", {
                            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => settings.value.difficulty = $event),
                            class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:focus:border-blue-500"
                          }, [
                            createBaseVNode("option", _hoisted_41$j, toDisplayString$1(unref(t)("grammar.practice.settings.levels.easy", "Easy")), 1),
                            createBaseVNode("option", _hoisted_42$h, toDisplayString$1(unref(t)("grammar.practice.settings.levels.medium", "Medium")), 1),
                            createBaseVNode("option", _hoisted_43$g, toDisplayString$1(unref(t)("grammar.practice.settings.levels.hard", "Hard")), 1)
                          ], 512), [
                            [vModelSelect, settings.value.difficulty]
                          ])
                        ]),
                        createBaseVNode("div", _hoisted_44$f, [
                          createBaseVNode("label", _hoisted_45$e, toDisplayString$1(unref(t)("grammar.practice.settings.autoPlay", "Auto-play audio")), 1),
                          createBaseVNode("button", {
                            onClick: _cache[4] || (_cache[4] = ($event) => settings.value.autoPlayAudio = !settings.value.autoPlayAudio),
                            class: normalizeClass([
                              "relative inline-flex h-6 w-11 items-center rounded-full transition-colors",
                              settings.value.autoPlayAudio ? "bg-blue-600" : "bg-gray-200 dark:bg-dark-bg-mute"
                            ])
                          }, [
                            createBaseVNode("span", {
                              class: normalizeClass([
                                "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                                settings.value.autoPlayAudio ? "translate-x-6" : "translate-x-1"
                              ])
                            }, null, 2)
                          ], 2)
                        ]),
                        createBaseVNode("div", _hoisted_46$e, [
                          createBaseVNode("label", _hoisted_47$e, toDisplayString$1(unref(t)("grammar.practice.settings.showExplanations", "Show explanations")), 1),
                          createBaseVNode("button", {
                            onClick: _cache[5] || (_cache[5] = ($event) => settings.value.showExplanations = !settings.value.showExplanations),
                            class: normalizeClass([
                              "relative inline-flex h-6 w-11 items-center rounded-full transition-colors",
                              settings.value.showExplanations ? "bg-blue-600" : "bg-gray-200 dark:bg-dark-bg-mute"
                            ])
                          }, [
                            createBaseVNode("span", {
                              class: normalizeClass([
                                "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                                settings.value.showExplanations ? "translate-x-6" : "translate-x-1"
                              ])
                            }, null, 2)
                          ], 2)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_48$e, [
                        createBaseVNode("div", _hoisted_49$d, [
                          createBaseVNode("button", {
                            onClick: _cache[6] || (_cache[6] = ($event) => showSettings.value = false),
                            class: "px-6 py-2 text-gray-700 dark:text-white bg-gray-100 dark:bg-dark-bg-mute hover:bg-gray-200 dark:hover:bg-dark-bg-soft rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium"
                          }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                          createBaseVNode("button", {
                            onClick: saveSettings,
                            class: "px-6 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg hover:from-blue-600 hover:to-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium"
                          }, toDisplayString$1(unref(t)("common.save", "Save")), 1)
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        }),
        showResults.value ? (openBlock(), createElementBlock("div", _hoisted_50$c, [
          createBaseVNode("div", _hoisted_51$b, [
            createBaseVNode("div", _hoisted_52$b, [
              _cache[31] || (_cache[31] = createBaseVNode("div", { class: "w-20 h-20 mx-auto mb-4 rounded-full bg-green-100 dark:bg-green-900/30 flex items-center justify-center" }, [
                createBaseVNode("svg", {
                  class: "w-10 h-10 text-green-600 dark:text-green-400",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
                  })
                ])
              ], -1)),
              createBaseVNode("h3", _hoisted_53$b, toDisplayString$1(unref(t)("grammar.practice.results.title", "Great job!")), 1),
              createBaseVNode("div", _hoisted_54$b, [
                createBaseVNode("div", _hoisted_55$b, [
                  createBaseVNode("div", _hoisted_56$a, [
                    createBaseVNode("div", _hoisted_57$a, toDisplayString$1(exerciseResults.value.correct), 1),
                    createBaseVNode("div", _hoisted_58$a, toDisplayString$1(unref(t)("grammar.practice.results.correct", "Correct")), 1)
                  ]),
                  createBaseVNode("div", _hoisted_59$9, [
                    createBaseVNode("div", _hoisted_60$9, toDisplayString$1(exerciseResults.value.incorrect), 1),
                    createBaseVNode("div", _hoisted_61$8, toDisplayString$1(unref(t)("grammar.practice.results.incorrect", "Incorrect")), 1)
                  ]),
                  createBaseVNode("div", _hoisted_62$8, [
                    createBaseVNode("div", _hoisted_63$6, toDisplayString$1(exerciseResults.value.percentage) + "%", 1),
                    createBaseVNode("div", _hoisted_64$6, toDisplayString$1(unref(t)("grammar.practice.results.accuracy", "Accuracy")), 1)
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_65$6, [
                createBaseVNode("button", {
                  onClick: restartExercise,
                  class: "px-6 py-3 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
                }, toDisplayString$1(unref(t)("grammar.practice.results.tryAgain", "Try again")), 1),
                createBaseVNode("button", {
                  onClick: goBackToSelection,
                  class: "px-6 py-3 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700 transition-colors"
                }, toDisplayString$1(unref(t)("grammar.practice.results.chooseAnother", "Choose another exercise")), 1)
              ])
            ])
          ])
        ])) : createCommentVNode("", true),
        createVNode(unref(ExerciseManager$1), {
          modelValue: showExerciseManager.value,
          "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => showExerciseManager.value = $event),
          "exercise-types": exerciseTypes.value,
          onAddExercise: addExerciseType,
          onEditExercise: editExerciseType,
          onDeleteExercise: deleteExerciseType,
          onSaveExercises: saveExerciseTypes,
          onOpenQuestionManager: openQuestionManager
        }, null, 8, ["modelValue", "exercise-types"]),
        showQuestionManager.value ? (openBlock(), createElementBlock("div", _hoisted_66$6, [
          createBaseVNode("div", _hoisted_67$5, [
            createBaseVNode("div", _hoisted_68$5, [
              createBaseVNode("h3", _hoisted_69$5, toDisplayString$1(unref(t)("grammar.practice.questionManager.title")) + ": " + toDisplayString$1(unref(t)(`grammar.practice.exercises.${selectedExerciseTypeForQuestions.value}.title`)), 1),
              createBaseVNode("button", {
                onClick: closeQuestionManager,
                class: "p-2 rounded-lg text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
              }, _cache[32] || (_cache[32] = [
                createBaseVNode("svg", {
                  class: "w-5 h-5",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M6 18L18 6M6 6l12 12"
                  })
                ], -1)
              ]))
            ]),
            createBaseVNode("div", _hoisted_70$5, [
              createBaseVNode("div", _hoisted_71$5, [
                createBaseVNode("h4", _hoisted_72$5, toDisplayString$1(editingQuestionIndex.value >= 0 ? unref(t)("grammar.practice.questionManager.editQuestion") : unref(t)("grammar.practice.questionManager.addNew")), 1),
                selectedExerciseTypeForQuestions.value === "writing" ? (openBlock(), createElementBlock("div", _hoisted_73$5, [
                  createBaseVNode("div", _hoisted_74$5, [
                    createBaseVNode("div", null, [
                      createBaseVNode("label", _hoisted_75$4, toDisplayString$1(unref(t)("grammar.practice.questionManager.taskType")), 1),
                      withDirectives(createBaseVNode("select", {
                        "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => newQuestion.value.taskType = $event),
                        class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                      }, [
                        createBaseVNode("option", _hoisted_76$4, toDisplayString$1(unref(t)("grammar.practice.exercises.writing.essay")), 1),
                        createBaseVNode("option", _hoisted_77$4, toDisplayString$1(unref(t)("grammar.practice.exercises.writing.email")), 1),
                        createBaseVNode("option", _hoisted_78$3, toDisplayString$1(unref(t)("grammar.practice.exercises.writing.letter")), 1),
                        createBaseVNode("option", _hoisted_79$3, toDisplayString$1(unref(t)("grammar.practice.exercises.writing.paragraph")), 1)
                      ], 512), [
                        [vModelSelect, newQuestion.value.taskType]
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_80$3, [
                      createBaseVNode("div", null, [
                        createBaseVNode("label", _hoisted_81$3, toDisplayString$1(unref(t)("grammar.practice.questionManager.minWords")), 1),
                        withDirectives(createBaseVNode("input", {
                          "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => newQuestion.value.minWords = $event),
                          type: "number",
                          min: "50",
                          class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        }, null, 512), [
                          [
                            vModelText,
                            newQuestion.value.minWords,
                            void 0,
                            { number: true }
                          ]
                        ])
                      ]),
                      createBaseVNode("div", null, [
                        createBaseVNode("label", _hoisted_82$3, toDisplayString$1(unref(t)("grammar.practice.questionManager.timeLimit")), 1),
                        withDirectives(createBaseVNode("input", {
                          "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => newQuestion.value.timeLimit = $event),
                          type: "number",
                          min: "5",
                          class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        }, null, 512), [
                          [
                            vModelText,
                            newQuestion.value.timeLimit,
                            void 0,
                            { number: true }
                          ]
                        ])
                      ])
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_83$3, toDisplayString$1(unref(t)("grammar.practice.questionManager.prompt")), 1),
                    withDirectives(createBaseVNode("textarea", {
                      "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => newQuestion.value.prompt = $event),
                      rows: "3",
                      class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                      placeholder: unref(t)("grammar.practice.questionManager.promptPlaceholder")
                    }, null, 8, _hoisted_84$3), [
                      [vModelText, newQuestion.value.prompt]
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("div", _hoisted_85$3, [
                      createBaseVNode("label", _hoisted_86$2, toDisplayString$1(unref(t)("grammar.practice.questionManager.requirements")), 1),
                      createBaseVNode("button", {
                        onClick: addRequirement,
                        class: "text-sm text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300"
                      }, " + " + toDisplayString$1(unref(t)("grammar.practice.questionManager.addRequirement")), 1)
                    ]),
                    createBaseVNode("div", _hoisted_87$2, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(newQuestion.value.requirements, (requirement, index) => {
                        return openBlock(), createElementBlock("div", {
                          key: index,
                          class: "flex items-center space-x-2"
                        }, [
                          withDirectives(createBaseVNode("input", {
                            "onUpdate:modelValue": ($event) => newQuestion.value.requirements[index] = $event,
                            type: "text",
                            class: "flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                            placeholder: unref(t)("grammar.practice.questionManager.requirementPlaceholder")
                          }, null, 8, _hoisted_88$2), [
                            [vModelText, newQuestion.value.requirements[index]]
                          ]),
                          createBaseVNode("button", {
                            onClick: ($event) => removeRequirement(index),
                            class: "p-2 text-red-600 dark:text-red-400 hover:bg-red-100 dark:hover:bg-red-900/30 rounded",
                            disabled: newQuestion.value.requirements.length === 1
                          }, _cache[33] || (_cache[33] = [
                            createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                              })
                            ], -1)
                          ]), 8, _hoisted_89$2)
                        ]);
                      }), 128))
                    ])
                  ])
                ])) : selectedExerciseTypeForQuestions.value === "multiple-choice" ? (openBlock(), createElementBlock("div", _hoisted_90$2, [
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_91$2, toDisplayString$1(unref(t)("grammar.practice.questionManager.question")), 1),
                    withDirectives(createBaseVNode("textarea", {
                      "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => newQuestion.value.question = $event),
                      rows: "2",
                      class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                      placeholder: unref(t)("grammar.practice.questionManager.questionPlaceholder")
                    }, null, 8, _hoisted_92$2), [
                      [vModelText, newQuestion.value.question]
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_93$2, toDisplayString$1(unref(t)("grammar.practice.questionManager.options")), 1),
                    createBaseVNode("div", _hoisted_94$2, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(newQuestion.value.options, (option, index) => {
                        return openBlock(), createElementBlock("div", {
                          key: index,
                          class: "flex items-center space-x-2"
                        }, [
                          createBaseVNode("span", _hoisted_95$2, toDisplayString$1(String.fromCharCode(65 + index)) + ".", 1),
                          withDirectives(createBaseVNode("input", {
                            "onUpdate:modelValue": ($event) => newQuestion.value.options[index] = $event,
                            type: "text",
                            class: "flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                            placeholder: unref(t)("grammar.practice.questionManager.optionPlaceholder")
                          }, null, 8, _hoisted_96$2), [
                            [vModelText, newQuestion.value.options[index]]
                          ])
                        ]);
                      }), 128))
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_97$2, toDisplayString$1(unref(t)("grammar.practice.questionManager.correctAnswer")), 1),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => newQuestion.value.correctAnswer = $event),
                      class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(newQuestion.value.options, (option, index) => {
                        return openBlock(), createElementBlock("option", {
                          key: index,
                          value: option
                        }, toDisplayString$1(String.fromCharCode(65 + index)) + ". " + toDisplayString$1(option), 9, _hoisted_98$2);
                      }), 128))
                    ], 512), [
                      [vModelSelect, newQuestion.value.correctAnswer]
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_99$2, toDisplayString$1(unref(t)("grammar.practice.questionManager.explanation")), 1),
                    withDirectives(createBaseVNode("textarea", {
                      "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => newQuestion.value.explanation = $event),
                      rows: "2",
                      class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                      placeholder: unref(t)("grammar.practice.questionManager.explanationPlaceholder")
                    }, null, 8, _hoisted_100$1), [
                      [vModelText, newQuestion.value.explanation]
                    ])
                  ])
                ])) : selectedExerciseTypeForQuestions.value === "listening" ? (openBlock(), createElementBlock("div", _hoisted_101$1, [
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_102$1, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.audioUrl")), 1),
                    createBaseVNode("div", _hoisted_103$1, [
                      withDirectives(createBaseVNode("input", {
                        "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => newQuestion.value.audioUrl = $event),
                        type: "text",
                        onInput: handleAudioUrlChange,
                        onPaste: handleUrlPaste,
                        class: "w-full px-3 py-2 pr-20 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                        placeholder: unref(t)("grammar.practice.exercises.listening.audioUrlPlaceholder")
                      }, null, 40, _hoisted_104$1), [
                        [vModelText, newQuestion.value.audioUrl]
                      ]),
                      newQuestion.value.audioUrl ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        onClick: clearAudioUrl,
                        type: "button",
                        class: "absolute right-2 top-1/2 transform -translate-y-1/2 p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors"
                      }, _cache[34] || (_cache[34] = [
                        createBaseVNode("svg", {
                          class: "w-4 h-4",
                          fill: "none",
                          stroke: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          createBaseVNode("path", {
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            "stroke-width": "2",
                            d: "M6 18L18 6M6 6l12 12"
                          })
                        ], -1)
                      ]))) : createCommentVNode("", true)
                    ]),
                    createBaseVNode("div", _hoisted_105$1, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.audioUrlHint")), 1),
                    isYouTubeUrl(newQuestion.value.audioUrl) ? (openBlock(), createElementBlock("div", _hoisted_106$1, [
                      createBaseVNode("div", _hoisted_107$1, [
                        _cache[35] || (_cache[35] = createBaseVNode("svg", {
                          class: "w-4 h-4",
                          fill: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          createBaseVNode("path", { d: "M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z" })
                        ], -1)),
                        createBaseVNode("span", null, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.youtubeDetected")), 1)
                      ]),
                      createBaseVNode("div", _hoisted_108$1, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.youtubeNote")), 1)
                    ])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_109$1, [
                    createBaseVNode("div", null, [
                      createBaseVNode("label", _hoisted_110$1, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.maxPlays")), 1),
                      withDirectives(createBaseVNode("input", {
                        "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => newQuestion.value.maxPlays = $event),
                        type: "number",
                        min: "1",
                        max: "10",
                        class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                      }, null, 512), [
                        [
                          vModelText,
                          newQuestion.value.maxPlays,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("div", null, [
                      createBaseVNode("label", _hoisted_111$1, toDisplayString$1(unref(t)("grammar.practice.settings.difficulty")), 1),
                      withDirectives(createBaseVNode("select", {
                        "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => newQuestion.value.difficulty = $event),
                        class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                      }, [
                        createBaseVNode("option", _hoisted_112, toDisplayString$1(unref(t)("grammar.practice.settings.levels.easy")), 1),
                        createBaseVNode("option", _hoisted_113, toDisplayString$1(unref(t)("grammar.practice.settings.levels.medium")), 1),
                        createBaseVNode("option", _hoisted_114, toDisplayString$1(unref(t)("grammar.practice.settings.levels.hard")), 1)
                      ], 512), [
                        [vModelSelect, newQuestion.value.difficulty]
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_115, [
                      createBaseVNode("label", _hoisted_116, [
                        withDirectives(createBaseVNode("input", {
                          "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => newQuestion.value.allowNotes = $event),
                          type: "checkbox",
                          class: "w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                        }, null, 512), [
                          [vModelCheckbox, newQuestion.value.allowNotes]
                        ]),
                        createBaseVNode("span", _hoisted_117, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.allowNotes")), 1)
                      ])
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_118, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.transcript")), 1),
                    withDirectives(createBaseVNode("textarea", {
                      "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => newQuestion.value.transcript = $event),
                      rows: "3",
                      class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                      placeholder: unref(t)("grammar.practice.exercises.listening.transcriptPlaceholder")
                    }, null, 8, _hoisted_119), [
                      [vModelText, newQuestion.value.transcript]
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_120, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.questions")), 1),
                    createBaseVNode("div", _hoisted_121, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(newQuestion.value.questions, (question, qIndex) => {
                        return openBlock(), createElementBlock("div", {
                          key: qIndex,
                          class: "border border-gray-200 dark:border-gray-600 rounded-lg p-3"
                        }, [
                          createBaseVNode("div", _hoisted_122, [
                            createBaseVNode("span", _hoisted_123, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.question")) + " " + toDisplayString$1(qIndex + 1), 1),
                            createBaseVNode("button", {
                              onClick: ($event) => removeListeningQuestion(qIndex),
                              class: "p-1 text-red-600 dark:text-red-400 hover:bg-red-100 dark:hover:bg-red-900/30 rounded",
                              disabled: newQuestion.value.questions.length === 1
                            }, _cache[36] || (_cache[36] = [
                              createBaseVNode("svg", {
                                class: "w-4 h-4",
                                fill: "none",
                                stroke: "currentColor",
                                viewBox: "0 0 24 24"
                              }, [
                                createBaseVNode("path", {
                                  "stroke-linecap": "round",
                                  "stroke-linejoin": "round",
                                  "stroke-width": "2",
                                  d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                                })
                              ], -1)
                            ]), 8, _hoisted_124)
                          ]),
                          createBaseVNode("div", _hoisted_125, [
                            createBaseVNode("div", null, [
                              withDirectives(createBaseVNode("select", {
                                "onUpdate:modelValue": ($event) => question.type = $event,
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
                              }, [
                                createBaseVNode("option", _hoisted_127, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.multipleChoice")), 1),
                                createBaseVNode("option", _hoisted_128, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.fillBlank")), 1),
                                createBaseVNode("option", _hoisted_129, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.ordering")), 1)
                              ], 8, _hoisted_126), [
                                [vModelSelect, question.type]
                              ])
                            ]),
                            createBaseVNode("div", null, [
                              withDirectives(createBaseVNode("textarea", {
                                "onUpdate:modelValue": ($event) => question.question = $event,
                                rows: "2",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm",
                                placeholder: unref(t)("grammar.practice.questionManager.questionPlaceholder")
                              }, null, 8, _hoisted_130), [
                                [vModelText, question.question]
                              ])
                            ]),
                            question.type === "multiple-choice" ? (openBlock(), createElementBlock("div", _hoisted_131, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(question.options, (option, oIndex) => {
                                return openBlock(), createElementBlock("div", {
                                  key: oIndex,
                                  class: "flex items-center space-x-2"
                                }, [
                                  createBaseVNode("span", _hoisted_132, toDisplayString$1(String.fromCharCode(65 + oIndex)) + ".", 1),
                                  withDirectives(createBaseVNode("input", {
                                    "onUpdate:modelValue": ($event) => question.options[oIndex] = $event,
                                    type: "text",
                                    class: "flex-1 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-1 focus:ring-blue-500 focus:border-transparent text-sm",
                                    placeholder: unref(t)("grammar.practice.questionManager.optionPlaceholder")
                                  }, null, 8, _hoisted_133), [
                                    [vModelText, question.options[oIndex]]
                                  ])
                                ]);
                              }), 128)),
                              createBaseVNode("div", null, [
                                withDirectives(createBaseVNode("select", {
                                  "onUpdate:modelValue": ($event) => question.correctAnswer = $event,
                                  class: "w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-1 focus:ring-blue-500 focus:border-transparent text-sm"
                                }, [
                                  createBaseVNode("option", _hoisted_135, toDisplayString$1(unref(t)("grammar.practice.questionManager.selectCorrectAnswer")), 1),
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(question.options, (option, oIndex) => {
                                    return openBlock(), createElementBlock("option", {
                                      key: oIndex,
                                      value: oIndex
                                    }, toDisplayString$1(String.fromCharCode(65 + oIndex)) + ". " + toDisplayString$1(option), 9, _hoisted_136);
                                  }), 128))
                                ], 8, _hoisted_134), [
                                  [vModelSelect, question.correctAnswer]
                                ])
                              ])
                            ])) : question.type === "fill-blank" ? (openBlock(), createElementBlock("div", _hoisted_137, [
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": ($event) => question.correctAnswer = $event,
                                type: "text",
                                class: "w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-1 focus:ring-blue-500 focus:border-transparent text-sm",
                                placeholder: unref(t)("grammar.practice.exercises.listening.correctAnswerPlaceholder")
                              }, null, 8, _hoisted_138), [
                                [vModelText, question.correctAnswer]
                              ])
                            ])) : createCommentVNode("", true)
                          ])
                        ]);
                      }), 128)),
                      createBaseVNode("button", {
                        onClick: addListeningQuestion,
                        class: "w-full px-3 py-2 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg text-gray-500 dark:text-gray-400 hover:border-blue-400 hover:text-blue-500 transition-colors text-sm"
                      }, " + " + toDisplayString$1(unref(t)("grammar.practice.exercises.listening.addQuestion")), 1)
                    ])
                  ])
                ])) : (openBlock(), createElementBlock("div", _hoisted_139, [
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_140, toDisplayString$1(unref(t)("grammar.practice.questionManager.question")), 1),
                    withDirectives(createBaseVNode("textarea", {
                      "onUpdate:modelValue": _cache[21] || (_cache[21] = ($event) => newQuestion.value.question = $event),
                      rows: "3",
                      class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                      placeholder: unref(t)("grammar.practice.questionManager.questionPlaceholder")
                    }, null, 8, _hoisted_141), [
                      [vModelText, newQuestion.value.question]
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_142, toDisplayString$1(unref(t)("grammar.practice.questionManager.explanation")), 1),
                    withDirectives(createBaseVNode("textarea", {
                      "onUpdate:modelValue": _cache[22] || (_cache[22] = ($event) => newQuestion.value.explanation = $event),
                      rows: "2",
                      class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                      placeholder: unref(t)("grammar.practice.questionManager.explanationPlaceholder")
                    }, null, 8, _hoisted_143), [
                      [vModelText, newQuestion.value.explanation]
                    ])
                  ])
                ])),
                createBaseVNode("div", _hoisted_144, [
                  createBaseVNode("button", {
                    onClick: addQuestion,
                    class: "px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700 transition-colors"
                  }, toDisplayString$1(editingQuestionIndex.value >= 0 ? unref(t)("common.update") : unref(t)("grammar.practice.questionManager.addQuestion")), 1)
                ])
              ]),
              exerciseQuestions.value[selectedExerciseTypeForQuestions.value]?.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_145, [
                createBaseVNode("h4", _hoisted_146, toDisplayString$1(unref(t)("grammar.practice.questionManager.existingQuestions")) + " (" + toDisplayString$1(exerciseQuestions.value[selectedExerciseTypeForQuestions.value].length) + ") ", 1),
                createBaseVNode("div", _hoisted_147, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(exerciseQuestions.value[selectedExerciseTypeForQuestions.value], (question, index) => {
                    return openBlock(), createElementBlock("div", {
                      key: question.id,
                      class: "bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-4"
                    }, [
                      createBaseVNode("div", _hoisted_148, [
                        createBaseVNode("div", _hoisted_149, [
                          createBaseVNode("div", _hoisted_150, [
                            createBaseVNode("span", _hoisted_151, " #" + toDisplayString$1(index + 1), 1),
                            selectedExerciseTypeForQuestions.value === "writing" ? (openBlock(), createElementBlock("span", _hoisted_152, toDisplayString$1(unref(t)(`grammar.practice.exercises.writing.${question.taskType}`)), 1)) : createCommentVNode("", true)
                          ]),
                          createBaseVNode("div", _hoisted_153, [
                            createBaseVNode("strong", null, toDisplayString$1(selectedExerciseTypeForQuestions.value === "writing" ? unref(t)("grammar.practice.questionManager.prompt") : unref(t)("grammar.practice.questionManager.question")) + ":", 1),
                            createBaseVNode("p", _hoisted_154, toDisplayString$1(selectedExerciseTypeForQuestions.value === "writing" ? question.prompt : question.question), 1)
                          ]),
                          selectedExerciseTypeForQuestions.value === "writing" && question.requirements?.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_155, [
                            createBaseVNode("strong", null, toDisplayString$1(unref(t)("grammar.practice.questionManager.requirements")) + ":", 1),
                            createBaseVNode("ul", _hoisted_156, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(question.requirements, (req) => {
                                return openBlock(), createElementBlock("li", { key: req }, toDisplayString$1(req), 1);
                              }), 128))
                            ])
                          ])) : createCommentVNode("", true),
                          selectedExerciseTypeForQuestions.value === "multiple-choice" && question.options ? (openBlock(), createElementBlock("div", _hoisted_157, [
                            createBaseVNode("strong", null, toDisplayString$1(unref(t)("grammar.practice.questionManager.correctAnswer")) + ":", 1),
                            createTextVNode(" " + toDisplayString$1(question.correctAnswer), 1)
                          ])) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("div", _hoisted_158, [
                          createBaseVNode("button", {
                            onClick: ($event) => editQuestion(index),
                            class: "p-1 rounded text-blue-600 dark:text-blue-400 hover:bg-blue-100 dark:hover:bg-blue-900/30 transition-colors",
                            title: unref(t)("common.edit")
                          }, _cache[37] || (_cache[37] = [
                            createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                              })
                            ], -1)
                          ]), 8, _hoisted_159),
                          createBaseVNode("button", {
                            onClick: ($event) => deleteQuestion(index),
                            class: "p-1 rounded text-red-600 dark:text-red-400 hover:bg-red-100 dark:hover:bg-red-900/30 transition-colors",
                            title: unref(t)("common.delete")
                          }, _cache[38] || (_cache[38] = [
                            createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                              })
                            ], -1)
                          ]), 8, _hoisted_160)
                        ])
                      ])
                    ]);
                  }), 128))
                ])
              ])) : (openBlock(), createElementBlock("div", _hoisted_161, [
                createBaseVNode("div", _hoisted_162, [
                  _cache[39] || (_cache[39] = createBaseVNode("svg", {
                    class: "w-12 h-12 mx-auto mb-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                    })
                  ], -1)),
                  createBaseVNode("p", null, toDisplayString$1(unref(t)("grammar.practice.questionManager.noQuestions")), 1),
                  createBaseVNode("p", _hoisted_163, toDisplayString$1(unref(t)("grammar.practice.questionManager.addFirstQuestion")), 1)
                ])
              ]))
            ]),
            createBaseVNode("div", _hoisted_164, [
              createBaseVNode("button", {
                onClick: closeQuestionManager,
                class: "px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-[#0a0a0a] rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
              }, toDisplayString$1(unref(t)("common.close")), 1)
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const LazyLoadComponent$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => LazyLoadComponent$1),true              ?void 0:void 0));
const VoiceSelector$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VoiceSelector),true              ?void 0:void 0));
const FlashcardHeader$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardHeader),true              ?void 0:void 0));
const FlashcardProgress$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardProgress),true              ?void 0:void 0));
const FlashcardDateFilter$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardDateFilter),true              ?void 0:void 0));
const FlashcardCard$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardCard$1),true              ?void 0:void 0));
const FlashcardQuiz$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardQuiz),true              ?void 0:void 0));
const FlashcardTyping$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardTyping),true              ?void 0:void 0));
const FlashcardImage$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardImage),true              ?void 0:void 0));
const FlashcardControls$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardControls),true              ?void 0:void 0));
const PracticeTimer$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => PracticeTimer$1),true              ?void 0:void 0));
const ExitWarningModal$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ExitWarningModal),true              ?void 0:void 0));
const CompletionModal$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => CompletionModal$1),true              ?void 0:void 0));
const HistoryModal$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => HistoryModal),true              ?void 0:void 0));
const SessionDetailModal$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => SessionDetailModal),true              ?void 0:void 0));
const SettingsModal$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => SettingsModal),true              ?void 0:void 0));
const PronunciationMode$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => PronunciationMode),true              ?void 0:void 0));
const ListeningMode$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ListeningMode$1),true              ?void 0:void 0));
const PracticeStats$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => PracticeStats),true              ?void 0:void 0));
const FlashcardEmptyState$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardEmptyState),true              ?void 0:void 0));
const PictionaryMode$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => PictionaryMode$1),true              ?void 0:void 0));
const FlipTileMode$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlipTileMode$1),true              ?void 0:void 0));
const BubbleShooterMode$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => BubbleShooterMode$1),true              ?void 0:void 0));
const SnakeGameMode$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => SnakeGameMode$1),true              ?void 0:void 0));
const AsyncComponents = {
  LazyLoadComponent: LazyLoadComponent$2,
  VoiceSelector: VoiceSelector$1,
  FlashcardHeader: FlashcardHeader$1,
  FlashcardProgress: FlashcardProgress$1,
  FlashcardDateFilter: FlashcardDateFilter$1,
  FlashcardCard: FlashcardCard$2,
  FlashcardQuiz: FlashcardQuiz$1,
  FlashcardTyping: FlashcardTyping$1,
  FlashcardImage: FlashcardImage$1,
  FlashcardControls: FlashcardControls$1,
  PracticeTimer: PracticeTimer$2,
  ExitWarningModal: ExitWarningModal$1,
  CompletionModal: CompletionModal$2,
  HistoryModal: HistoryModal$1,
  SessionDetailModal: SessionDetailModal$1,
  SettingsModal: SettingsModal$1,
  PronunciationMode: PronunciationMode$1,
  ListeningMode: ListeningMode$2,
  PracticeStats: PracticeStats$1,
  FlashcardEmptyState: FlashcardEmptyState$1,
  PictionaryMode: PictionaryMode$2,
  FlipTileMode: FlipTileMode$2,
  BubbleShooterMode: BubbleShooterMode$2,
  SnakeGameMode: SnakeGameMode$2
};

function useFlashcardGame(flashcards) {
  const router = useRouter();
  const PRACTICE_MODE_STORAGE_KEY = "flashcard-practice-mode";
  const loadPracticeModeFromStorage = () => {
    try {
      const saved = localStorage.getItem(PRACTICE_MODE_STORAGE_KEY);
      if (saved && ["flashcard", "quiz", "typing", "image", "listening", "pronunciation", "pictionary", "flip-tile", "bubble-shooter", "snake-game"].includes(saved)) {
        return saved;
      }
    } catch (error) {
      console.error("Error loading practice mode from localStorage:", error);
    }
    return "flashcard";
  };
  const savePracticeModeToStorage = (mode) => {
    try {
      localStorage.setItem(PRACTICE_MODE_STORAGE_KEY, mode);
    } catch (error) {
      console.error("Error saving practice mode to localStorage:", error);
    }
  };
  const currentIndex = ref(0);
  const isFlipped = ref(false);
  const practiceMode = ref(loadPracticeModeFromStorage());
  const showSettings = ref(false);
  const showCompletionModal = ref(false);
  const isCompleted = ref(false);
  const settings = ref({
    cardCount: 20,
    difficulty: "all",
    autoFlip: false,
    flipDelay: 3,
    showDefinition: true,
    showExample: true,
    showPronunciation: true,
    shuffleCards: false,
    voiceType: "female",
    practiceMode: loadPracticeModeFromStorage()
  });
  const stats = ref({
    easy: 0,
    difficult: 0,
    reviewed: 0,
    correct: 0,
    incorrect: 0,
    total: 0,
    startTime: /* @__PURE__ */ new Date(),
    endTime: null,
    mode: "flashcard"
  });
  stats.value.mode = practiceMode.value;
  watch(practiceMode, (mode) => {
    stats.value.mode = mode;
  });
  const currentCard = computed(() => {
    if (flashcards.value.length === 0) return null;
    return flashcards.value[currentIndex.value];
  });
  const nextCard = () => {
    if (currentIndex.value < flashcards.value.length - 1) {
      currentIndex.value++;
      resetCurrentCard();
    } else {
      completeSession();
    }
  };
  const previousCard = () => {
    if (currentIndex.value > 0) {
      currentIndex.value--;
      resetCurrentCard();
    }
  };
  const flipCard = () => {
    isFlipped.value = !isFlipped.value;
  };
  const resetCurrentCard = () => {
    isFlipped.value = false;
  };
  const completeSession = () => {
    isCompleted.value = true;
    stats.value.endTime = /* @__PURE__ */ new Date();
    showCompletionModal.value = true;
  };
  const restartSession = () => {
    currentIndex.value = 0;
    isCompleted.value = false;
    showCompletionModal.value = false;
    stats.value = {
      easy: 0,
      difficult: 0,
      reviewed: 0,
      correct: 0,
      incorrect: 0,
      total: 0,
      startTime: /* @__PURE__ */ new Date(),
      endTime: null,
      mode: practiceMode.value
    };
    resetCurrentCard();
  };
  const changePracticeMode = (mode) => {
    practiceMode.value = mode;
    settings.value.practiceMode = mode;
    savePracticeModeToStorage(mode);
    resetCurrentCard();
  };
  const applySettings = () => {
    showSettings.value = false;
  };
  const goBack = () => {
    router.push("/");
  };
  const goToVocabulary = () => {
    router.push("/practice/flashcard");
  };
  const markEasy = () => {
    nextCard();
  };
  const markDifficult = () => {
    nextCard();
  };
  let autoFlipTimer = null;
  watch([currentIndex, isFlipped], () => {
    if (autoFlipTimer) {
      clearTimeout(autoFlipTimer);
    }
    if (settings.value.autoFlip && !isFlipped.value) {
      autoFlipTimer = window.setTimeout(() => {
        if (!isFlipped.value) {
          flipCard();
        }
      }, settings.value.flipDelay * 1e3);
    }
  });
  const cleanup = () => {
    if (autoFlipTimer) {
      clearTimeout(autoFlipTimer);
    }
  };
  return {
    // State
    currentIndex,
    isFlipped,
    practiceMode,
    showSettings,
    showCompletionModal,
    isCompleted,
    settings,
    stats,
    // Computed
    flashcards,
    currentCard,
    // Methods
    nextCard,
    previousCard,
    flipCard,
    resetCurrentCard,
    completeSession,
    restartSession,
    changePracticeMode,
    applySettings,
    goBack,
    goToVocabulary,
    markEasy,
    markDifficult,
    cleanup
  };
}

function useFlashcardModes(currentCard, flashcards, allVocabularies, onCorrectAnswer, onIncorrectAnswer) {
  const { playAudio: playVoiceAudio } = useVoiceStore();
  const quizOptions = ref([]);
  const selectedAnswer = ref("");
  const quizAnswered = ref(false);
  const typingAnswer = ref("");
  const typingAnswered = ref(false);
  const typingCorrect = ref(false);
  const typingQuizEnabled = ref(false);
  const typingQuizOptions = ref([]);
  const typingQuizSelected = ref("");
  const typingQuizAnswered = ref(false);
  const listeningAnswer = ref("");
  const listeningAnswered = ref(false);
  const listeningCorrect = ref(false);
  const listeningQuizEnabled = ref(false);
  const listeningQuizOptions = ref([]);
  const listeningQuizSelected = ref("");
  const listeningQuizAnswered = ref(false);
  const imageAnswer = ref("");
  const imageAnswered = ref(false);
  const imageCorrect = ref(false);
  const imageQuizEnabled = ref(false);
  const imageQuizOptions = ref([]);
  const imageQuizSelected = ref("");
  const imageQuizAnswered = ref(false);
  const pictionaryAnswer = ref("");
  const pictionaryAnswered = ref(false);
  const pictionaryCorrect = ref(false);
  const flipTileAnswer = ref("");
  const flipTileAnswered = ref(false);
  const flipTileCorrect = ref(false);
  const bubbleShooterVietnameseMode = ref(false);
  const STORAGE_KEYS = {
    image: "pe_imageQuizEnabled",
    listening: "pe_listeningQuizEnabled",
    typing: "pe_typingQuizEnabled",
    bubbleShooterVietnamese: "pe_bubbleShooterVietnameseMode",
    imagePos: "pe_imageQuiz_correct_pos",
    listeningPos: "pe_listeningQuiz_correct_pos",
    typingPos: "pe_typingQuiz_correct_pos"
  };
  const readBool = (key, def = false) => {
    try {
      const v = localStorage.getItem(key);
      return v === null ? def : v === "true";
    } catch {
      return def;
    }
  };
  imageQuizEnabled.value = readBool(STORAGE_KEYS.image, false);
  listeningQuizEnabled.value = readBool(STORAGE_KEYS.listening, false);
  typingQuizEnabled.value = readBool(STORAGE_KEYS.typing, false);
  bubbleShooterVietnameseMode.value = readBool(STORAGE_KEYS.bubbleShooterVietnamese, false);
  const writeBool = (key, val) => {
    try {
      localStorage.setItem(key, String(val));
    } catch {
    }
  };
  const readNumber = (key, def = 0) => {
    try {
      const v = localStorage.getItem(key);
      const n = v === null ? def : Number(v);
      return Number.isFinite(n) && n >= 0 ? n : def;
    } catch {
      return def;
    }
  };
  const writeNumber = (key, val) => {
    try {
      localStorage.setItem(key, String(val));
    } catch {
    }
  };
  watch(imageQuizEnabled, (v) => writeBool(STORAGE_KEYS.image, v));
  watch(listeningQuizEnabled, (v) => writeBool(STORAGE_KEYS.listening, v));
  watch(typingQuizEnabled, (v) => writeBool(STORAGE_KEYS.typing, v));
  watch(bubbleShooterVietnameseMode, (v) => writeBool(STORAGE_KEYS.bubbleShooterVietnamese, v));
  const imageCorrectPos = ref(readNumber(STORAGE_KEYS.imagePos, Math.floor(Math.random() * 4)));
  const listeningCorrectPos = ref(readNumber(STORAGE_KEYS.listeningPos, Math.floor(Math.random() * 4)));
  const typingCorrectPos = ref(readNumber(STORAGE_KEYS.typingPos, Math.floor(Math.random() * 4)));
  watch(imageCorrectPos, (n) => writeNumber(STORAGE_KEYS.imagePos, n));
  watch(listeningCorrectPos, (n) => writeNumber(STORAGE_KEYS.listeningPos, n));
  watch(typingCorrectPos, (n) => writeNumber(STORAGE_KEYS.typingPos, n));
  const placeWithRotation = (correct, wrongs, posRef) => {
    const options = new Array(4);
    const idx = posRef.value % 4;
    options[idx] = correct;
    const shuffledWrongs = [...wrongs].sort(() => Math.random() - 0.5);
    let wi = 0;
    for (let i = 0; i < 4; i++) {
      if (i === idx) continue;
      options[i] = shuffledWrongs[wi++] ?? "";
    }
    posRef.value = (posRef.value + 1) % 4;
    return options;
  };
  const isRecording = ref(false);
  const pronunciationResult = ref("");
  const pronunciationAnswered = ref(false);
  const pronunciationCorrect = ref(false);
  let recognition = null;
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const isSpeechRecognitionSupported = !!SpeechRecognition;
  if (isSpeechRecognitionSupported) {
    recognition = new SpeechRecognition();
    recognition.continuous = false;
    recognition.lang = "en-US";
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;
    recognition.onresult = (event) => {
      const transcript = event.results[0][0].transcript;
      pronunciationResult.value = transcript;
      checkPronunciationAnswer(transcript);
    };
    recognition.onerror = (event) => {
      console.error("Speech recognition error", event.error);
      isRecording.value = false;
    };
    recognition.onend = () => {
      isRecording.value = false;
    };
  }
  const startRecording = () => {
    if (isRecording.value || !isSpeechRecognitionSupported) return;
    pronunciationResult.value = "";
    pronunciationAnswered.value = false;
    pronunciationCorrect.value = false;
    isRecording.value = true;
    recognition.start();
  };
  const checkPronunciationAnswer = (transcript) => {
    if (!currentCard.value) return false;
    pronunciationAnswered.value = true;
    const userAnswer = transcript.toLowerCase().trim().replace(/[.,/#!$%^&*;:{}=\-_`~()]/g, "");
    const correctAnswer = currentCard.value.word.toLowerCase().trim().replace(/[.,/#!$%^&*;:{}=\-_`~()]/g, "");
    pronunciationCorrect.value = userAnswer === correctAnswer;
    if (pronunciationCorrect.value) ;
    return pronunciationCorrect.value;
  };
  const generateQuizOptions = () => {
    if (!currentCard.value) return;
    const correctAnswer = getShortMeaning(currentCard.value.meaning);
    const allOptions = allVocabularies.value.filter((card) => card.id !== currentCard.value?.id).map((card) => getShortMeaning(card.meaning)).filter((meaning) => meaning !== correctAnswer).sort(() => Math.random() - 0.5).slice(0, 3);
    const wrongOptions = allOptions.length >= 3 ? allOptions.slice(0, 3) : allOptions;
    quizOptions.value = [correctAnswer, ...wrongOptions].sort(() => Math.random() - 0.5);
  };
  const selectQuizAnswer = (answer) => {
    if (quizAnswered.value) return;
    selectedAnswer.value = answer;
    quizAnswered.value = true;
    const correctAnswer = currentCard.value ? getShortMeaning(currentCard.value.meaning) : "";
    const isCorrect = answer === correctAnswer;
    return isCorrect;
  };
  const generateImageQuizOptions = () => {
    if (!currentCard.value) return;
    const correctWord = currentCard.value.word.trim();
    const allWrong = allVocabularies.value.filter((card) => card.id !== currentCard.value?.id).map((card) => card.word.trim()).filter((word) => word.toLowerCase() !== correctWord.toLowerCase()).sort(() => Math.random() - 0.5).slice(0, 3);
    const wrongOptions = allWrong.length >= 3 ? allWrong.slice(0, 3) : allWrong;
    const paddedWrongs = [...new Set(wrongOptions)];
    while (paddedWrongs.length < 3) paddedWrongs.push("");
    imageQuizOptions.value = placeWithRotation(correctWord, paddedWrongs, imageCorrectPos);
  };
  const selectImageQuizAnswer = (answer) => {
    if (imageQuizAnswered.value) return;
    imageQuizSelected.value = answer;
    imageQuizAnswered.value = true;
    const correctWord = currentCard.value ? currentCard.value.word.trim().toLowerCase() : "";
    const isCorrect = answer.trim().toLowerCase() === correctWord;
    imageAnswered.value = true;
    imageCorrect.value = isCorrect;
    return isCorrect;
  };
  const checkTypingAnswer = () => {
    if (!currentCard.value || typingAnswered.value) return;
    typingAnswered.value = true;
    const userAnswer = typingAnswer.value.toLowerCase().trim();
    const correctAnswer = currentCard.value.word.toLowerCase().trim();
    typingCorrect.value = userAnswer === correctAnswer;
    if (typingCorrect.value) ;
    return typingCorrect.value;
  };
  const generateTypingQuizOptions = () => {
    if (!currentCard.value) return;
    const correctWord = currentCard.value.word.trim();
    const allWrong = allVocabularies.value.filter((card) => card.id !== currentCard.value?.id).map((card) => card.word.trim()).filter((word) => word.toLowerCase() !== correctWord.toLowerCase()).sort(() => Math.random() - 0.5).slice(0, 3);
    const wrongOptions = allWrong.length >= 3 ? allWrong.slice(0, 3) : allWrong;
    const paddedWrongs = [...new Set(wrongOptions)];
    while (paddedWrongs.length < 3) paddedWrongs.push("");
    typingQuizOptions.value = placeWithRotation(correctWord, paddedWrongs, typingCorrectPos);
  };
  const selectTypingQuizAnswer = (answer) => {
    if (typingQuizAnswered.value) return;
    typingQuizSelected.value = answer;
    typingQuizAnswered.value = true;
    const correctWord = currentCard.value ? currentCard.value.word.trim().toLowerCase() : "";
    const isCorrect = answer.trim().toLowerCase() === correctWord;
    typingAnswered.value = true;
    typingCorrect.value = isCorrect;
    return isCorrect;
  };
  const checkListeningAnswer = () => {
    if (!currentCard.value || listeningAnswered.value) return;
    listeningAnswered.value = true;
    const userAnswer = listeningAnswer.value.toLowerCase().trim();
    const correctAnswer = currentCard.value.word.toLowerCase().trim();
    listeningCorrect.value = userAnswer === correctAnswer;
    if (listeningCorrect.value) ;
    return listeningCorrect.value;
  };
  const generateListeningQuizOptions = () => {
    if (!currentCard.value) return;
    const correctWord = currentCard.value.word.trim();
    const allWrong = allVocabularies.value.filter((card) => card.id !== currentCard.value?.id).map((card) => card.word.trim()).filter((word) => word.toLowerCase() !== correctWord.toLowerCase()).sort(() => Math.random() - 0.5).slice(0, 3);
    const wrongOptions = allWrong.length >= 3 ? allWrong.slice(0, 3) : allWrong;
    const paddedWrongs = [...new Set(wrongOptions)];
    while (paddedWrongs.length < 3) paddedWrongs.push("");
    listeningQuizOptions.value = placeWithRotation(correctWord, paddedWrongs, listeningCorrectPos);
  };
  const selectListeningQuizAnswer = (answer) => {
    if (listeningQuizAnswered.value) return;
    listeningQuizSelected.value = answer;
    listeningQuizAnswered.value = true;
    const correctWord = currentCard.value ? currentCard.value.word.trim().toLowerCase() : "";
    const isCorrect = answer.trim().toLowerCase() === correctWord;
    listeningAnswered.value = true;
    listeningCorrect.value = isCorrect;
    return isCorrect;
  };
  const checkImageAnswer = () => {
    if (!currentCard.value || imageAnswered.value) return;
    imageAnswered.value = true;
    const userAnswer = imageAnswer.value.toLowerCase().trim();
    const correctAnswer = currentCard.value.word.toLowerCase().trim();
    imageCorrect.value = userAnswer === correctAnswer;
    if (imageCorrect.value) ;
    return imageCorrect.value;
  };
  const checkPictionaryAnswer = () => {
    if (!currentCard.value || pictionaryAnswered.value) return;
    pictionaryAnswered.value = true;
    const userAnswer = pictionaryAnswer.value.toLowerCase().trim();
    const correctAnswer = currentCard.value.word.toLowerCase().trim();
    pictionaryCorrect.value = userAnswer === correctAnswer;
    if (pictionaryCorrect.value) ;
    return pictionaryCorrect.value;
  };
  const checkFlipTileAnswer = () => {
    if (!currentCard.value || flipTileAnswered.value) return;
    flipTileAnswered.value = true;
    const userAnswer = flipTileAnswer.value.toLowerCase().trim();
    const correctAnswer = currentCard.value.word.toLowerCase().trim();
    flipTileCorrect.value = userAnswer === correctAnswer;
    if (flipTileCorrect.value) ;
    return flipTileCorrect.value;
  };
  const playAudio = async () => {
    if (!currentCard.value) return;
    try {
      await playVoiceAudio(currentCard.value.word);
    } catch (error) {
      console.error("Error playing audio:", error);
      const utterance = new SpeechSynthesisUtterance(currentCard.value.word);
      utterance.lang = "en-US";
      utterance.rate = 0.8;
      speechSynthesis.speak(utterance);
    }
  };
  const resetQuizMode = () => {
    quizOptions.value = [];
    selectedAnswer.value = "";
    quizAnswered.value = false;
  };
  const resetTypingMode = () => {
    typingAnswer.value = "";
    typingAnswered.value = false;
    typingCorrect.value = false;
    typingQuizOptions.value = [];
    typingQuizSelected.value = "";
    typingQuizAnswered.value = false;
  };
  const resetListeningMode = () => {
    listeningAnswer.value = "";
    listeningAnswered.value = false;
    listeningCorrect.value = false;
    listeningQuizOptions.value = [];
    listeningQuizSelected.value = "";
    listeningQuizAnswered.value = false;
  };
  const resetImageMode = () => {
    imageAnswer.value = "";
    imageAnswered.value = false;
    imageCorrect.value = false;
    imageQuizOptions.value = [];
    imageQuizSelected.value = "";
    imageQuizAnswered.value = false;
  };
  const resetPictionaryMode = () => {
    pictionaryAnswer.value = "";
    pictionaryAnswered.value = false;
    pictionaryCorrect.value = false;
  };
  const resetFlipTileMode = () => {
    flipTileAnswer.value = "";
    flipTileAnswered.value = false;
    flipTileCorrect.value = false;
  };
  const resetPronunciationMode = () => {
    if (recognition && isRecording.value) {
      recognition.stop();
    }
    isRecording.value = false;
    pronunciationResult.value = "";
    pronunciationAnswered.value = false;
    pronunciationCorrect.value = false;
  };
  const resetAllModes = () => {
    resetQuizMode();
    resetTypingMode();
    resetListeningMode();
    resetImageMode();
    resetPronunciationMode();
    resetPictionaryMode();
    resetFlipTileMode();
  };
  const getCanProceed = () => {
    return {
      flashcard: true,
      quiz: quizAnswered.value,
      typing: typingAnswered.value,
      listening: listeningAnswered.value,
      image: imageAnswered.value,
      pronunciation: pronunciationAnswered.value,
      pictionary: pictionaryAnswered.value,
      "flip-tile": flipTileAnswered.value,
      "snake-game": true,
      "bubble-shooter": true
    };
  };
  const getShortMeaning = (meaning) => {
    return meaning.split(" - ")[0].trim();
  };
  return {
    // Quiz mode
    quizOptions,
    selectedAnswer,
    quizAnswered,
    generateQuizOptions,
    selectQuizAnswer,
    resetQuizMode,
    // Typing mode
    typingAnswer,
    typingAnswered,
    typingCorrect,
    checkTypingAnswer,
    resetTypingMode,
    // Typing-Quiz (within Typing mode)
    typingQuizEnabled,
    typingQuizOptions,
    typingQuizSelected,
    typingQuizAnswered,
    generateTypingQuizOptions,
    selectTypingQuizAnswer,
    // Listening mode
    listeningAnswer,
    listeningAnswered,
    listeningCorrect,
    checkListeningAnswer,
    playAudio,
    resetListeningMode,
    // Listening-Quiz (within Listening mode)
    listeningQuizEnabled,
    listeningQuizOptions,
    listeningQuizSelected,
    listeningQuizAnswered,
    generateListeningQuizOptions,
    selectListeningQuizAnswer,
    // Image mode
    imageAnswer,
    imageAnswered,
    imageCorrect,
    checkImageAnswer,
    resetImageMode,
    // Image-Quiz (within Image mode)
    imageQuizEnabled,
    imageQuizOptions,
    imageQuizSelected,
    imageQuizAnswered,
    generateImageQuizOptions,
    selectImageQuizAnswer,
    // Pictionary mode
    pictionaryAnswer,
    pictionaryAnswered,
    pictionaryCorrect,
    checkPictionaryAnswer,
    resetPictionaryMode,
    // Flip tile mode
    flipTileAnswer,
    flipTileAnswered,
    flipTileCorrect,
    checkFlipTileAnswer,
    resetFlipTileMode,
    // Bubble Shooter mode
    bubbleShooterVietnameseMode,
    // Pronunciation mode
    isRecording,
    pronunciationResult,
    pronunciationAnswered,
    pronunciationCorrect,
    isSpeechRecognitionSupported,
    startRecording,
    resetPronunciationMode,
    // General
    resetAllModes,
    getCanProceed,
    getShortMeaning
  };
}

function useFlashcardHistory() {
  const showHistory = ref(false);
  const practiceHistory = ref([]);
  const { t, locale } = useI18n();
  const loadPracticeHistory = () => {
    const saved = localStorage.getItem("flashcard-practice-history");
    if (saved) {
      const parsed = JSON.parse(saved);
      practiceHistory.value = parsed.map((item) => {
        if (item.hasDetails === void 0) {
          const has = !!localStorage.getItem(`flashcard-session-details:${item.id}`);
          return { ...item, hasDetails: has };
        }
        return item;
      });
      savePracticeHistory();
    }
  };
  const savePracticeHistory = () => {
    localStorage.setItem("flashcard-practice-history", JSON.stringify(practiceHistory.value));
  };
  const saveSessionToHistory = (stats, totalCards, sessionId) => {
    const duration = stats.endTime && stats.startTime ? Math.round((stats.endTime.getTime() - stats.startTime.getTime()) / 1e3) : 0;
    const total = stats.correct + stats.incorrect;
    const accuracy = total > 0 ? Math.round(stats.correct / total * 100) : 0;
    const score = Math.round(accuracy * (totalCards / 100));
    const id = sessionId || Date.now().toString();
    const historyItem = {
      id,
      date: (/* @__PURE__ */ new Date()).toISOString(),
      mode: stats.mode,
      totalCards,
      correctAnswers: stats.correct,
      incorrectAnswers: stats.incorrect,
      accuracy,
      duration,
      score,
      categories: stats.categories || [],
      hasDetails: true
    };
    practiceHistory.value.unshift(historyItem);
    if (practiceHistory.value.length > 50) {
      practiceHistory.value = practiceHistory.value.slice(0, 50);
    }
    savePracticeHistory();
    return id;
  };
  const getModeColor = (mode) => {
    switch (mode) {
      case "flashcard":
        return "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200";
      case "quiz":
        return "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200";
      case "typing":
        return "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200";
      case "listening":
        return "bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200";
      case "image":
        return "bg-pink-100 text-pink-800 dark:bg-pink-900 dark:text-pink-200";
      case "pictionary":
        return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200";
      case "pronunciation":
        return "bg-indigo-100 text-indigo-800 dark:bg-indigo-900 dark:text-indigo-200";
      case "bubble-shooter":
        return "bg-teal-100 text-teal-800 dark:bg-teal-900 dark:text-teal-200";
      case "snake-game":
        return "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200";
      default:
        return "bg-cyan-100 text-cyan-800 dark:bg-cyan-900 dark:text-cyan-200";
    }
  };
  const getModeText = (mode) => {
    switch (mode) {
      case "flashcard":
        return t("flashcard.modes.flashcard", "Flashcard");
      case "quiz":
        return t("flashcard.modes.quiz", "Quiz");
      case "typing":
        return t("flashcard.modes.typing", "Typing");
      case "listening":
        return t("flashcard.modes.listening", "Listening");
      case "image":
        return t("flashcard.modes.image", "Image");
      case "pictionary":
        return t("flashcard.modes.pictionary", "Pictionary");
      case "pronunciation":
        return t("flashcard.modes.pronunciation", "Pronunciation");
      case "bubble-shooter":
        return t("flashcard.modes.bubbleShooter", "Bubble Shooter");
      case "snake-game":
        return t("flashcard.modes.snakeGame", "Snake Hunt");
      default:
        return "Unknown";
    }
  };
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    const now = /* @__PURE__ */ new Date();
    const diffTime = now.getTime() - date.getTime();
    const diffDays = Math.floor(diffTime / (1e3 * 60 * 60 * 24));
    const currentLocale = locale.value === "en" ? "en-US" : "vi-VN";
    if (diffDays === 0) {
      return locale.value === "en" ? "Today" : "Hôm nay";
    } else if (diffDays === 1) {
      return locale.value === "en" ? "Yesterday" : "Hôm qua";
    } else if (diffDays < 7) {
      return locale.value === "en" ? `${diffDays} days ago` : `${diffDays} ngày trước`;
    } else {
      return date.toLocaleDateString(currentLocale);
    }
  };
  const formatDuration = (seconds) => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
  };
  const clearHistory = () => {
    practiceHistory.value = [];
    savePracticeHistory();
    Object.keys(localStorage).forEach((key) => {
      if (key.startsWith("flashcard-session-details:")) {
        localStorage.removeItem(key);
      }
    });
  };
  const deleteSession = (sessionId) => {
    practiceHistory.value = practiceHistory.value.filter((item) => item.id !== sessionId);
    savePracticeHistory();
    localStorage.removeItem(`flashcard-session-details:${sessionId}`);
  };
  const getHistoryStats = () => {
    if (practiceHistory.value.length === 0) {
      return {
        totalSessions: 0,
        averageAccuracy: 0,
        totalCards: 0,
        totalTime: 0,
        bestScore: 0,
        favoriteMode: ""
      };
    }
    const totalSessions = practiceHistory.value.length;
    const totalCards = practiceHistory.value.reduce((sum, item) => sum + item.totalCards, 0);
    const totalTime = practiceHistory.value.reduce((sum, item) => sum + item.duration, 0);
    const averageAccuracy = Math.round(
      practiceHistory.value.reduce((sum, item) => sum + item.accuracy, 0) / totalSessions
    );
    const bestScore = Math.max(...practiceHistory.value.map((item) => item.score));
    const modeCount = practiceHistory.value.reduce((acc, item) => {
      acc[item.mode] = (acc[item.mode] || 0) + 1;
      return acc;
    }, {});
    const favoriteMode = Object.entries(modeCount).sort(([, a], [, b]) => b - a)[0]?.[0] || "";
    return {
      totalSessions,
      averageAccuracy,
      totalCards,
      totalTime,
      bestScore,
      favoriteMode
    };
  };
  onMounted(() => {
    loadPracticeHistory();
  });
  return {
    showHistory,
    practiceHistory,
    saveSessionToHistory,
    getModeColor,
    getModeText,
    formatDate,
    formatDuration,
    clearHistory,
    deleteSession,
    getHistoryStats
  };
}

function useFlashcardSettings() {
  const showSettings = ref(false);
  const defaultSettings = {
    cardCount: 20,
    difficulty: "all",
    autoFlip: false,
    flipDelay: 3,
    showDefinition: true,
    showExample: true,
    showPronunciation: true,
    shuffleCards: false,
    voiceType: "female",
    practiceMode: "flashcard",
    category: "",
    level: "",
    useFlipTileHints: true
  };
  const settings = ref({ ...defaultSettings });
  const localSettings = ref({ ...defaultSettings });
  const loadSettings = () => {
    const saved = localStorage.getItem("flashcard-settings");
    if (saved) {
      try {
        const parsedSettings = JSON.parse(saved);
        settings.value = { ...defaultSettings, ...parsedSettings };
        localSettings.value = { ...settings.value };
      } catch (error) {
        console.error("Error loading settings:", error);
        settings.value = { ...defaultSettings };
        localSettings.value = { ...defaultSettings };
      }
    }
  };
  const saveSettings = () => {
    localStorage.setItem("flashcard-settings", JSON.stringify(settings.value));
  };
  const applySettings = () => {
    settings.value = { ...localSettings.value };
    saveSettings();
    showSettings.value = false;
  };
  const resetSettings = () => {
    settings.value = { ...defaultSettings };
    localSettings.value = { ...defaultSettings };
    saveSettings();
  };
  const cancelSettings = () => {
    localSettings.value = { ...settings.value };
    showSettings.value = false;
  };
  const openSettings = () => {
    localSettings.value = { ...settings.value };
    showSettings.value = true;
  };
  const validateSettings = (settingsToValidate) => {
    const errors = [];
    if (settingsToValidate.cardCount < 1 || settingsToValidate.cardCount > 100) {
      errors.push("Số lượng thẻ phải từ 1 đến 100");
    }
    if (settingsToValidate.flipDelay < 1 || settingsToValidate.flipDelay > 10) {
      errors.push("Thời gian lật thẻ phải từ 1 đến 10 giây");
    }
    return errors;
  };
  const getDifficultyLevels = () => {
    return [
      { value: "all", label: "Tất cả" },
      { value: "easy", label: "Dễ" },
      { value: "medium", label: "Trung bình" },
      { value: "hard", label: "Khó" }
    ];
  };
  const getFlipDelayOptions = () => {
    return [
      { value: 1, label: "1 giây" },
      { value: 2, label: "2 giây" },
      { value: 3, label: "3 giây" },
      { value: 4, label: "4 giây" },
      { value: 5, label: "5 giây" },
      { value: 10, label: "10 giây" }
    ];
  };
  const getCardCountOptions = () => {
    return [
      { value: 10, label: "10 thẻ" },
      { value: 20, label: "20 thẻ" },
      { value: 30, label: "30 thẻ" },
      { value: 50, label: "50 thẻ" },
      { value: 100, label: "100 thẻ" }
    ];
  };
  const getVoiceTypeOptions = () => {
    return [
      { value: "female", label: "Giọng nữ", icon: "👩" },
      { value: "male", label: "Giọng nam", icon: "👨" }
    ];
  };
  const getSettingsPresets = () => {
    return {
      beginner: {
        ...defaultSettings,
        cardCount: 10,
        difficulty: "easy",
        autoFlip: true,
        flipDelay: 5,
        showDefinition: true,
        showExample: true,
        showPronunciation: true
      },
      intermediate: {
        ...defaultSettings,
        cardCount: 20,
        difficulty: "medium",
        autoFlip: false,
        showDefinition: true,
        showExample: true,
        showPronunciation: false
      },
      advanced: {
        ...defaultSettings,
        cardCount: 50,
        difficulty: "hard",
        autoFlip: false,
        showDefinition: false,
        showExample: false,
        showPronunciation: false
      }
    };
  };
  const applyPreset = (presetName) => {
    const presets = getSettingsPresets();
    localSettings.value = { ...presets[presetName] };
  };
  watch(settings, () => {
    saveSettings();
  }, { deep: true });
  onMounted(() => {
    loadSettings();
  });
  return {
    showSettings,
    settings,
    localSettings,
    applySettings,
    resetSettings,
    cancelSettings,
    openSettings,
    validateSettings,
    getDifficultyLevels,
    getFlipDelayOptions,
    getCardCountOptions,
    getVoiceTypeOptions,
    getSettingsPresets,
    applyPreset
  };
}

function useFlashcardStats(stats) {
  const sessionStats = ref({
    totalCards: 0,
    currentCard: 0,
    correctAnswers: 0,
    incorrectAnswers: 0,
    accuracy: 0,
    streak: 0,
    maxStreak: 0,
    timeSpent: 0,
    averageTimePerCard: 0,
    score: 0
  });
  const currentStreak = ref(0);
  const maxStreak = ref(0);
  const cardStartTime = ref(null);
  const cardTimes = ref([]);
  const initializeStats = (totalCards) => {
    sessionStats.value = {
      totalCards,
      currentCard: 0,
      correctAnswers: 0,
      incorrectAnswers: 0,
      accuracy: 0,
      streak: 0,
      maxStreak: 0,
      timeSpent: 0,
      averageTimePerCard: 0,
      score: 0
    };
    currentStreak.value = 0;
    maxStreak.value = 0;
    cardTimes.value = [];
    cardStartTime.value = /* @__PURE__ */ new Date();
  };
  const recordAnswer = (isCorrect) => {
    if (isCorrect) {
      sessionStats.value.correctAnswers++;
      stats.value.correct++;
      currentStreak.value++;
      if (currentStreak.value > maxStreak.value) {
        maxStreak.value = currentStreak.value;
      }
    } else {
      sessionStats.value.incorrectAnswers++;
      stats.value.incorrect++;
      currentStreak.value = 0;
    }
    stats.value.total++;
    if (cardStartTime.value) {
      const timeSpent = (/* @__PURE__ */ new Date()).getTime() - cardStartTime.value.getTime();
      cardTimes.value.push(timeSpent);
      cardStartTime.value = /* @__PURE__ */ new Date();
    }
    nextCardStats();
  };
  const nextCardStats = () => {
    stats.value.reviewed++;
    sessionStats.value.currentCard++;
    cardStartTime.value = /* @__PURE__ */ new Date();
  };
  const getPerformanceLevel = computed(() => {
    const accuracy = sessionStats.value.accuracy;
    if (accuracy >= 90) return { level: "Xuất sắc", color: "text-green-600 dark:text-green-400" };
    if (accuracy >= 80) return { level: "Tốt", color: "text-blue-600 dark:text-blue-400" };
    if (accuracy >= 70) return { level: "Khá", color: "text-yellow-600 dark:text-yellow-400" };
    if (accuracy >= 60) return { level: "Trung bình", color: "text-orange-600 dark:text-orange-400" };
    return { level: "Cần cải thiện", color: "text-red-600 dark:text-red-400" };
  });
  const getStreakMessage = computed(() => {
    const streak = currentStreak.value;
    if (streak === 0) return "";
    if (streak < 3) return "Bắt đầu tốt!";
    if (streak < 5) return "Đang tiến bộ!";
    if (streak < 10) return "Tuyệt vời!";
    return "Xuất sắc!";
  });
  const getSpeedRating = computed(() => {
    const avgTime = sessionStats.value.averageTimePerCard / 1e3;
    if (avgTime === 0) return { rating: "", color: "" };
    if (avgTime < 2) return { rating: "Rất nhanh", color: "text-green-600 dark:text-green-400" };
    if (avgTime < 4) return { rating: "Nhanh", color: "text-blue-600 dark:text-blue-400" };
    if (avgTime < 6) return { rating: "Trung bình", color: "text-yellow-600 dark:text-yellow-400" };
    if (avgTime < 10) return { rating: "Chậm", color: "text-orange-600 dark:text-orange-400" };
    return { rating: "Rất chậm", color: "text-red-600 dark:text-red-400" };
  });
  const formatTime = (milliseconds) => {
    const seconds = Math.floor(milliseconds / 1e3);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    if (minutes > 0) {
      return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
    }
    return `${remainingSeconds}s`;
  };
  const getDetailedStats = computed(() => {
    return {
      ...sessionStats.value,
      performanceLevel: getPerformanceLevel.value,
      streakMessage: getStreakMessage.value,
      speedRating: getSpeedRating.value,
      timeSpentFormatted: formatTime(sessionStats.value.timeSpent),
      averageTimeFormatted: formatTime(sessionStats.value.averageTimePerCard),
      completion: sessionStats.value.totalCards > 0 ? Math.round(sessionStats.value.currentCard / sessionStats.value.totalCards * 100) : 0
    };
  });
  return {
    sessionStats,
    currentStreak,
    maxStreak,
    initializeStats,
    recordAnswer,
    nextCardStats,
    getPerformanceLevel,
    getStreakMessage,
    getSpeedRating,
    formatTime,
    getDetailedStats
  };
}

const makeKey = (sessionId) => `flashcard-session-details:${sessionId}`;
function usePracticeSessionDetails() {
  const currentSessionId = ref(null);
  const currentMode = ref("");
  const startSessionDetails = (sessionId, mode) => {
    currentSessionId.value = sessionId;
    currentMode.value = mode;
    const initial = {
      sessionId,
      mode,
      total: 0,
      correct: 0,
      incorrect: 0,
      entries: []
    };
    try {
      localStorage.setItem(makeKey(sessionId), JSON.stringify(initial));
    } catch {
    }
  };
  const appendAnswer = (payload) => {
    if (!currentSessionId.value) return;
    const key = makeKey(currentSessionId.value);
    let data = null;
    try {
      const raw = localStorage.getItem(key);
      data = raw ? JSON.parse(raw) : null;
    } catch {
    }
    if (!data) {
      data = {
        sessionId: currentSessionId.value,
        mode: currentMode.value,
        total: 0,
        correct: 0,
        incorrect: 0,
        entries: []
      };
    }
    const entry = {
      ...payload,
      timestamp: payload.timestamp || (/* @__PURE__ */ new Date()).toISOString()
    };
    data.entries.push(entry);
    data.total += 1;
    if (entry.isCorrect) data.correct += 1;
    else data.incorrect += 1;
    try {
      localStorage.setItem(key, JSON.stringify(data));
    } catch {
    }
  };
  const loadDetails = (sessionId) => {
    try {
      const raw = localStorage.getItem(makeKey(sessionId));
      return raw ? JSON.parse(raw) : null;
    } catch {
      return null;
    }
  };
  const clearDetails = (sessionId) => {
    try {
      localStorage.removeItem(makeKey(sessionId));
    } catch {
    }
  };
  return {
    currentSessionId,
    currentMode,
    startSessionDetails,
    appendAnswer,
    loadDetails,
    clearDetails
  };
}

const _hoisted_1$1j = { class: "min-h-screen overflow-x-hidden bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-dark-bg-soft dark:to-dark-bg-mute relative" };
const _hoisted_2$1g = { class: "max-w-4xl mx-auto px-3 sm:px-4 md:px-6 py-2 sm:py-3 md:py-4" };
const _hoisted_3$1d = { class: "group bg-white/80 dark:bg-dark-bg-soft/80 backdrop-blur-md rounded-2xl shadow-xl hover:shadow-2xl border border-white/20 dark:border-dark-bg-mute transition-all duration-500 hover:scale-[1.01] hover:-translate-y-0.5 p-3 sm:p-4 md:p-5" };
const _hoisted_4$19 = { class: "max-w-4xl mx-auto px-3 sm:px-4 md:px-6 py-2 sm:py-3 md:py-4" };
const _hoisted_5$16 = { class: "group relative overflow-visible bg-white/80 dark:bg-dark-bg-soft/80 backdrop-blur-md rounded-2xl shadow-xl hover:shadow-2xl border border-white/20 dark:border-dark-bg-mute transition-all duration-500 hover:scale-[1.01] hover:-translate-y-0.5 p-3 sm:p-4 md:p-5" };
const _hoisted_6$13 = { class: "max-w-4xl mx-auto px-3 sm:px-4 md:px-6 py-4 sm:py-6 md:py-8" };
const _hoisted_7$$ = {
  key: 0,
  class: "relative"
};
const _hoisted_8$Z = { class: "group relative overflow-hidden bg-white/80 dark:bg-dark-bg-soft/80 backdrop-blur-md rounded-2xl shadow-xl hover:shadow-2xl border border-white/20 dark:border-dark-bg-mute transition-all duration-500 p-3 sm:p-4 md:p-6" };
const _hoisted_9$Y = { class: "space-y-4 sm:space-y-5 md:space-y-6" };
const _hoisted_10$X = { class: "flex justify-center max-w-md mx-auto" };
const _hoisted_11$X = { key: 0 };
const STORAGE_KEY = "flashcard-date-filter";
const _sfc_main$1k = /* @__PURE__ */ defineComponent({
  ...{ components: AsyncComponents },
  __name: "FlashcardView",
  setup(__props) {
    const ConfirmToast$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ConfirmToast),true              ?void 0:void 0));
    const { t } = useI18n();
    const router = useRouter();
    const toast = useToast();
    const { allVocabularies } = useVocabularyStore();
    const modalStore = useModalStore();
    const {
      startSessionDetails,
      appendAnswer,
      loadDetails
    } = usePracticeSessionDetails();
    const activeSessionId = ref(null);
    const showSessionDetail = ref(false);
    const selectedSessionDetails = ref(null);
    const latestPictionarySnapshot = ref(null);
    const onPictionarySnapshot = (payload) => {
      latestPictionarySnapshot.value = payload;
    };
    const openHistoryDetails = (sessionId) => {
      const details = loadDetails(sessionId);
      selectedSessionDetails.value = details;
      showSessionDetail.value = true;
    };
    const handleDeleteSession = (sessionId) => {
      const toastId = toast(
        {
          component: ConfirmToast$1,
          props: {
            message: t("flashcard.history.confirmDelete.message", "Are you sure you want to delete this practice session? This action cannot be undone."),
            confirmText: t("flashcard.history.confirmDelete.confirm", "Delete"),
            cancelText: t("flashcard.history.confirmDelete.cancel", "Cancel"),
            onConfirm: () => {
              deleteSession(sessionId);
              toast.success(t("flashcard.history.confirmDelete.success", "Session deleted successfully"));
              toast.dismiss(toastId);
            },
            onCancel: () => {
              toast.dismiss(toastId);
            }
          }
        },
        {
          timeout: 0,
          closeOnClick: false,
          showCloseButtonOnHover: false,
          hideProgressBar: true
        }
      );
    };
    const loadDateFilterState = () => {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const parsed = JSON.parse(saved);
          return {
            selectedDate: parsed.selectedDate || ""
          };
        }
      } catch (error) {
        console.error("Error loading date filter state:", error);
      }
      return { selectedDate: "" };
    };
    const saveDateFilterState = () => {
      try {
        const state = { selectedDate: selectedDate.value };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (error) {
        console.error("Error saving date filter state:", error);
      }
    };
    const initialState = loadDateFilterState();
    const dateFilterEnabled = ref(true);
    const selectedDate = ref(initialState.selectedDate);
    watch(selectedDate, () => {
      saveDateFilterState();
    });
    const bubbleShooterVietnameseMode = ref(false);
    const snakeDoubleBaitMode = ref(false);
    const pictionaryDefinitionMode = ref(false);
    const scrambleWordsEnabled = ref(false);
    const wordsCrushEnabled = ref(false);
    const loadBubbleShooterVietnameseModeFromStorage = () => {
      try {
        const saved = localStorage.getItem("pe_bubbleShooterVietnameseMode");
        return saved === null ? false : saved === "true";
      } catch {
        return false;
      }
    };
    const saveBubbleShooterVietnameseModeToStorage = (enabled) => {
      try {
        localStorage.setItem("pe_bubbleShooterVietnameseMode", String(enabled));
      } catch {
      }
    };
    const loadSnakeDoubleBaitModeFromStorage = () => {
      try {
        const saved = localStorage.getItem("pe_snakeDoubleBaitMode");
        return saved === null ? false : saved === "true";
      } catch {
        return false;
      }
    };
    const saveSnakeDoubleBaitModeToStorage = (enabled) => {
      try {
        localStorage.setItem("pe_snakeDoubleBaitMode", String(enabled));
      } catch {
      }
    };
    const loadPictionaryDefinitionModeFromStorage = () => {
      try {
        const saved = localStorage.getItem("pe_pictionaryDefinitionMode");
        return saved === null ? false : saved === "true";
      } catch {
        return false;
      }
    };
    const savePictionaryDefinitionModeToStorage = (enabled) => {
      try {
        localStorage.setItem("pe_pictionaryDefinitionMode", String(enabled));
      } catch {
      }
    };
    const loadScrambleWordsModeFromStorage = () => {
      try {
        const saved = localStorage.getItem("pe_scrambleWordsEnabled");
        return saved === null ? false : saved === "true";
      } catch {
        return false;
      }
    };
    const saveScrambleWordsModeToStorage = (enabled) => {
      try {
        localStorage.setItem("pe_scrambleWordsEnabled", String(enabled));
      } catch {
      }
    };
    const loadWordsCrushModeFromStorage = () => {
      try {
        const saved = localStorage.getItem("pe_wordsCrushEnabled");
        return saved === null ? false : saved === "true";
      } catch {
        return false;
      }
    };
    const saveWordsCrushModeToStorage = (enabled) => {
      try {
        localStorage.setItem("pe_wordsCrushEnabled", String(enabled));
      } catch {
      }
    };
    bubbleShooterVietnameseMode.value = loadBubbleShooterVietnameseModeFromStorage();
    snakeDoubleBaitMode.value = loadSnakeDoubleBaitModeFromStorage();
    pictionaryDefinitionMode.value = loadPictionaryDefinitionModeFromStorage();
    scrambleWordsEnabled.value = loadScrambleWordsModeFromStorage();
    wordsCrushEnabled.value = loadWordsCrushModeFromStorage();
    watch(bubbleShooterVietnameseMode, (newVal) => {
      saveBubbleShooterVietnameseModeToStorage(newVal);
    });
    watch(snakeDoubleBaitMode, (newVal) => {
      saveSnakeDoubleBaitModeToStorage(newVal);
    });
    watch(pictionaryDefinitionMode, (newVal) => {
      savePictionaryDefinitionModeToStorage(newVal);
    });
    watch(scrambleWordsEnabled, (newVal) => {
      saveScrambleWordsModeToStorage(newVal);
    });
    watch(wordsCrushEnabled, (newVal) => {
      saveWordsCrushModeToStorage(newVal);
    });
    const {
      showSettings: showSettingsDialog,
      settings: flashcardSettings,
      localSettings,
      applySettings: applyGameSettings,
      cancelSettings} = useFlashcardSettings();
    const filteredVocabularies = computed(() => {
      let vocabularies = allVocabularies.value;
      if (selectedDate.value) {
        vocabularies = vocabularies.filter((vocab) => {
          const vocabDateKey = getDateKey(vocab.createdAt);
          return vocabDateKey === selectedDate.value;
        });
      }
      if (flashcardSettings.value.category) {
        vocabularies = vocabularies.filter((vocab) => vocab.category === flashcardSettings.value.category);
      }
      return vocabularies;
    });
    const baseFlashcards = computed(() => {
      return filteredVocabularies.value.filter((vocab) => {
        const category = flashcardSettings.value.category;
        const difficulty = flashcardSettings.value.difficulty;
        const categoryMatch = !category || vocab.category === category;
        const levelMatch = !difficulty || difficulty === "all" || vocab.level === difficulty;
        return categoryMatch && levelMatch;
      });
    });
    const imageModeAvailable = computed(() => {
      const cards = baseFlashcards.value;
      if (cards.length === 0) return false;
      return cards.every((v) => {
        const img = v.image;
        if (img == null) return false;
        const s = typeof img === "string" ? img : String(img);
        return s.trim().length > 0;
      });
    });
    const pictionaryModeAvailable = computed(() => {
      const cards = baseFlashcards.value;
      if (cards.length === 0) return false;
      return cards.every((v) => {
        const img = v.image;
        if (img == null) return false;
        const s = typeof img === "string" ? img : String(img);
        return s.trim().length > 0;
      });
    });
    const flipTileModeAvailable = computed(() => {
      const cards = baseFlashcards.value;
      if (cards.length === 0) return false;
      return cards.every((v) => {
        const img = v.image;
        if (img == null) return false;
        const s = typeof img === "string" ? img : String(img);
        return s.trim().length > 0;
      });
    });
    const bubbleShooterModeAvailable = computed(() => {
      if (!selectedDate.value) {
        return filteredVocabularies.value.length <= 8;
      }
      const dateFilteredVocabs = allVocabularies.value.filter((vocab) => {
        const vocabDateKey = getDateKey(vocab.createdAt);
        return vocabDateKey === selectedDate.value;
      });
      return dateFilteredVocabs.length <= 8;
    });
    const practiceStarted = ref(false);
    const practiceTimerRef = ref();
    const showExitWarning = ref(false);
    const allowExit = ref(false);
    const handlePracticeStart = () => {
      practiceStarted.value = true;
      console.log("Practice started!");
      activeSessionId.value = `${Date.now()}`;
      startSessionDetails(activeSessionId.value, practiceMode.value);
    };
    const handleExitPractice = () => {
      if (practiceStarted.value && !allowExit.value) {
        showExitWarning.value = true;
      } else {
        router.push("/practice/flashcard");
      }
    };
    const handleTimeout = () => {
      console.log("Time out for current card!");
    };
    const handleTimerRestart = () => {
      console.log("Timer restarted: restarting from the first card");
      practiceStarted.value = true;
      if (flashcardSettings.value.shuffleCards && baseFlashcards.value.length > 0) {
        shuffleFlashcards();
      }
      cardStateStorage.value = {};
      currentIndex.value = 0;
      resetAndRestoreCard();
      if (practiceTimerRef.value) {
        practiceTimerRef.value.startTimer();
      }
    };
    const handleSkip = () => {
      console.log("Skip current card");
      practiceStarted.value = false;
      if (practiceTimerRef.value) {
        practiceTimerRef.value.resetPractice();
      }
      restartSession();
      router.push("/practice/flashcard");
    };
    const continueSession = () => {
      showExitWarning.value = false;
    };
    const confirmExit = () => {
      allowExit.value = true;
      showExitWarning.value = false;
      practiceStarted.value = false;
      if (practiceTimerRef.value) {
        practiceTimerRef.value.resetPractice();
      }
      removeNavigationGuard();
      router.push("/practice/flashcard");
    };
    let unregisterGuard = null;
    const setupNavigationGuard = () => {
      if (unregisterGuard) {
        unregisterGuard();
      }
      unregisterGuard = router.beforeEach((to, from, next) => {
        if (practiceStarted.value && !allowExit.value && from.path.includes("/practice/flashcard")) {
          showExitWarning.value = true;
          return false;
        }
        next();
      });
    };
    const removeNavigationGuard = () => {
      if (unregisterGuard) {
        unregisterGuard();
        unregisterGuard = null;
      }
    };
    const handleImageAnswer = () => {
      checkImageAnswer();
      recordAnswer(imageCorrect.value);
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handleBeforeUnload = (event) => {
      if (practiceStarted.value && !allowExit.value) {
        event.preventDefault();
        event.returnValue = "";
        return "";
      }
    };
    const {
      showHistory,
      practiceHistory,
      saveSessionToHistory,
      getModeColor,
      getModeText,
      formatDate,
      formatDuration,
      deleteSession
    } = useFlashcardHistory();
    const {
      currentIndex,
      isFlipped,
      practiceMode,
      showCompletionModal,
      settings,
      stats,
      flashcards,
      nextCard,
      flipCard,
      completeSession,
      restartSession,
      changePracticeMode,
      goBack,
      goToVocabulary,
      cleanup
    } = useFlashcardGame(baseFlashcards);
    watch(imageModeAvailable, (available) => {
      if (practiceMode.value === "image" && !available) {
        if (practiceStarted.value) {
          console.log("[Flashcard] Image mode became unavailable but practice is active; not switching mode.");
          return;
        }
        console.log("[Flashcard] Image mode unavailable for current filter; switching to flashcard mode.");
        changePracticeMode("flashcard");
      }
    }, { immediate: true });
    watch(pictionaryModeAvailable, (available) => {
      if (practiceMode.value === "pictionary" && !available) {
        if (practiceStarted.value) {
          console.log("[Flashcard] Pictionary mode became unavailable but practice is active; not switching mode.");
          return;
        }
        console.log("[Flashcard] Pictionary mode unavailable for current filter; switching to flashcard mode.");
        changePracticeMode("flashcard");
      }
    }, { immediate: true });
    const {
      initializeStats,
      recordAnswer} = useFlashcardStats(stats);
    const currentFlashcards = computed(() => {
      if (flashcardSettings.value.shuffleCards && shuffledFlashcards.value.length > 0) {
        return shuffledFlashcards.value;
      }
      return baseFlashcards.value;
    });
    const currentShuffledCard = computed(() => {
      if (currentFlashcards.value.length === 0) return null;
      return currentFlashcards.value[currentIndex.value];
    });
    const currentProgressPercentage = computed(() => {
      if (currentFlashcards.value.length === 0) return 0;
      if (typeof currentIndex.value !== "number" || isNaN(currentIndex.value)) return 0;
      if (currentIndex.value >= currentFlashcards.value.length) return 100;
      return (currentIndex.value + 1) / currentFlashcards.value.length * 100;
    });
    const shuffleEnabled = computed(() => flashcardSettings.value.shuffleCards);
    const shuffledFlashcards = ref([]);
    const shuffleFlashcards = (cards = baseFlashcards.value) => {
      const shuffled = [...cards];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      shuffledFlashcards.value = shuffled;
    };
    const {
      quizOptions,
      selectedAnswer,
      quizAnswered,
      generateQuizOptions,
      selectQuizAnswer,
      typingAnswer,
      typingAnswered,
      typingCorrect,
      checkTypingAnswer,
      // Typing-quiz
      typingQuizEnabled,
      typingQuizOptions,
      typingQuizSelected,
      typingQuizAnswered,
      generateTypingQuizOptions,
      selectTypingQuizAnswer,
      listeningAnswer,
      listeningAnswered,
      listeningCorrect,
      checkListeningAnswer,
      playAudio,
      imageAnswer,
      imageAnswered,
      imageCorrect,
      checkImageAnswer,
      resetImageMode,
      // Pictionary mode
      pictionaryAnswer,
      pictionaryAnswered,
      pictionaryCorrect,
      checkPictionaryAnswer,
      // Flip tile mode
      flipTileAnswer,
      flipTileAnswered,
      flipTileCorrect,
      checkFlipTileAnswer,
      imageQuizEnabled,
      imageQuizOptions,
      imageQuizSelected,
      imageQuizAnswered,
      generateImageQuizOptions,
      selectImageQuizAnswer,
      resetAllModes,
      getCanProceed,
      getShortMeaning,
      // Pronunciation mode
      isRecording,
      pronunciationResult,
      pronunciationAnswered,
      pronunciationCorrect,
      isSpeechRecognitionSupported,
      startRecording,
      listeningQuizEnabled,
      listeningQuizOptions,
      listeningQuizSelected,
      listeningQuizAnswered,
      generateListeningQuizOptions,
      selectListeningQuizAnswer
    } = useFlashcardModes(currentShuffledCard, currentFlashcards, allVocabularies);
    const cardStateStorage = ref({});
    const saveCurrentCardState = () => {
      if (!currentShuffledCard.value) return;
      const cardId = currentShuffledCard.value.id;
      cardStateStorage.value[cardId] = {
        // Quiz mode
        quizAnswer: selectedAnswer.value,
        quizAnswered: quizAnswered.value,
        quizOptions: quizOptions.value,
        // Typing mode
        typingAnswer: typingAnswer.value || void 0,
        typingAnswered: typingAnswered.value || void 0,
        typingCorrect: typingCorrect.value || void 0,
        // Typing-quiz
        typingQuizOptions: typingQuizOptions.value || void 0,
        typingQuizSelected: typingQuizSelected.value || void 0,
        typingQuizAnswered: typingQuizAnswered.value || void 0,
        // Listening mode
        listeningAnswer: listeningAnswer.value || void 0,
        listeningAnswered: listeningAnswered.value || void 0,
        listeningCorrect: listeningCorrect.value || void 0,
        // Listening-quiz
        listeningQuizOptions: listeningQuizOptions.value || void 0,
        listeningQuizSelected: listeningQuizSelected.value || void 0,
        listeningQuizAnswered: listeningQuizAnswered.value || void 0,
        // Image mode
        imageAnswer: imageAnswer.value || void 0,
        imageAnswered: imageAnswered.value || void 0,
        imageCorrect: imageCorrect.value || void 0,
        imageQuizOptions: imageQuizOptions.value && imageQuizOptions.value.length ? imageQuizOptions.value : void 0,
        imageQuizSelected: imageQuizSelected.value || void 0,
        imageQuizAnswered: imageQuizAnswered.value || void 0,
        // Pronunciation mode
        pronunciationResult: pronunciationResult.value || void 0,
        pronunciationAnswered: pronunciationAnswered.value || void 0,
        pronunciationCorrect: pronunciationCorrect.value || void 0,
        // Pictionary mode
        pictionaryAnswer: pictionaryAnswer.value || void 0,
        pictionaryAnswered: pictionaryAnswered.value || void 0,
        pictionaryCorrect: pictionaryCorrect.value || void 0,
        // Flip tile mode
        flipTileAnswer: flipTileAnswer.value || void 0,
        flipTileAnswered: flipTileAnswered.value || void 0,
        flipTileCorrect: flipTileCorrect.value || void 0
      };
    };
    const restoreCardState = () => {
      if (!currentShuffledCard.value) return;
      const cardId = currentShuffledCard.value.id;
      const savedState = cardStateStorage.value[cardId];
      if (savedState) {
        if (savedState.quizOptions) {
          quizOptions.value = savedState.quizOptions;
        }
        if (savedState.quizAnswer !== void 0) {
          selectedAnswer.value = savedState.quizAnswer;
        }
        if (savedState.quizAnswered !== void 0) {
          quizAnswered.value = savedState.quizAnswered;
        }
        if (savedState.typingAnswer !== void 0) {
          typingAnswer.value = savedState.typingAnswer;
        }
        if (savedState.typingAnswered !== void 0) {
          typingAnswered.value = savedState.typingAnswered;
        }
        if (savedState.typingCorrect !== void 0) {
          typingCorrect.value = savedState.typingCorrect;
        }
        if (savedState.typingQuizOptions !== void 0) {
          typingQuizOptions.value = savedState.typingQuizOptions;
        }
        if (savedState.typingQuizSelected !== void 0) {
          typingQuizSelected.value = savedState.typingQuizSelected;
        }
        if (savedState.typingQuizAnswered !== void 0) {
          typingQuizAnswered.value = savedState.typingQuizAnswered;
        }
        if (savedState.listeningAnswer !== void 0) {
          listeningAnswer.value = savedState.listeningAnswer;
        }
        if (savedState.listeningAnswered !== void 0) {
          listeningAnswered.value = savedState.listeningAnswered;
        }
        if (savedState.listeningCorrect !== void 0) {
          listeningCorrect.value = savedState.listeningCorrect;
        }
        if (savedState.listeningQuizOptions !== void 0) {
          listeningQuizOptions.value = savedState.listeningQuizOptions;
        }
        if (savedState.listeningQuizSelected !== void 0) {
          listeningQuizSelected.value = savedState.listeningQuizSelected;
        }
        if (savedState.listeningQuizAnswered !== void 0) {
          listeningQuizAnswered.value = savedState.listeningQuizAnswered;
        }
        if (savedState.imageAnswer !== void 0) {
          imageAnswer.value = savedState.imageAnswer;
        }
        if (savedState.imageAnswered !== void 0) {
          imageAnswered.value = savedState.imageAnswered;
        }
        if (savedState.imageCorrect !== void 0) {
          imageCorrect.value = savedState.imageCorrect;
        }
        if (savedState.imageQuizOptions !== void 0) {
          imageQuizOptions.value = savedState.imageQuizOptions;
        }
        if (savedState.imageQuizSelected !== void 0) {
          imageQuizSelected.value = savedState.imageQuizSelected;
        }
        if (savedState.imageQuizAnswered !== void 0) {
          imageQuizAnswered.value = savedState.imageQuizAnswered;
        }
        if (savedState.pronunciationResult !== void 0) {
          pronunciationResult.value = savedState.pronunciationResult;
        }
        if (savedState.pronunciationAnswered !== void 0) {
          pronunciationAnswered.value = savedState.pronunciationAnswered;
        }
        if (savedState.pronunciationCorrect !== void 0) {
          pronunciationCorrect.value = savedState.pronunciationCorrect;
        }
        if (savedState.pictionaryAnswer !== void 0) {
          pictionaryAnswer.value = savedState.pictionaryAnswer;
        }
        if (savedState.pictionaryAnswered !== void 0) {
          pictionaryAnswered.value = savedState.pictionaryAnswered;
        }
        if (savedState.pictionaryCorrect !== void 0) {
          pictionaryCorrect.value = savedState.pictionaryCorrect;
        }
        if (savedState.flipTileAnswer !== void 0) {
          flipTileAnswer.value = savedState.flipTileAnswer;
        }
        if (savedState.flipTileAnswered !== void 0) {
          flipTileAnswered.value = savedState.flipTileAnswered;
        }
        if (savedState.flipTileCorrect !== void 0) {
          flipTileCorrect.value = savedState.flipTileCorrect;
        }
      }
    };
    const handleQuizAnswer = (answer) => {
      const isCorrect = selectQuizAnswer(answer);
      recordAnswer(!!isCorrect);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: answer,
          correctAnswer: getShortMeaning(currentShuffledCard.value.meaning),
          isCorrect: !!isCorrect,
          mode: "quiz"
        });
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handleTypingAnswer = () => {
      checkTypingAnswer();
      recordAnswer(typingCorrect.value);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: typingAnswer.value,
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: !!typingCorrect.value,
          mode: "typing"
        });
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handleTypingQuizAnswer = (answer) => {
      const isCorrect = selectTypingQuizAnswer(answer);
      recordAnswer(!!isCorrect);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: answer,
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: !!isCorrect,
          mode: "typing-quiz"
        });
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handleListeningAnswer = () => {
      checkListeningAnswer();
      recordAnswer(listeningCorrect.value);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: listeningAnswer.value,
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: !!listeningCorrect.value,
          mode: "listening"
        });
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handleListeningQuizAnswer = (answer) => {
      const isCorrect = selectListeningQuizAnswer(answer);
      recordAnswer(!!isCorrect);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: answer,
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: !!isCorrect,
          mode: "listening-quiz"
        });
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const onToggleImageQuiz = (enabled) => {
      imageQuizEnabled.value = enabled;
      resetImageMode();
      if (enabled) {
        generateImageQuizOptions();
      }
    };
    const handleImageQuizAnswer = (answer) => {
      const isCorrect = selectImageQuizAnswer(answer);
      recordAnswer(!!isCorrect);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: answer,
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: !!isCorrect,
          mode: "image-quiz"
        });
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handleFlipTileAnswer = () => {
      checkFlipTileAnswer();
      recordAnswer(flipTileCorrect.value);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: flipTileAnswer.value || "",
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: !!flipTileCorrect.value,
          mode: "flip-tile"
        });
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handlePictionaryAnswer = () => {
      checkPictionaryAnswer();
      recordAnswer(pictionaryCorrect.value);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: pictionaryAnswer.value || "",
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: !!pictionaryCorrect.value,
          mode: "pictionary",
          extra: {
            pictionary: {
              image: currentShuffledCard.value.image,
              slots: latestPictionarySnapshot.value?.slots || []
            }
          }
        });
        latestPictionarySnapshot.value = null;
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handleScrambleAnswer = (isCorrect) => {
      recordAnswer(isCorrect);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: "scrambled",
          // User assembled the scrambled word
          correctAnswer: currentShuffledCard.value.word,
          isCorrect,
          mode: "scramble-words"
        });
      }
    };
    const handleBubbleShooterComplete = () => {
      recordAnswer(true);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: "completed",
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: true,
          mode: "bubble-shooter"
        });
      }
      handleSessionComplete();
    };
    const handleWordsCrushCompleted = (isCorrect) => {
      recordAnswer(isCorrect);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: isCorrect ? currentShuffledCard.value.word : "incomplete",
          correctAnswer: currentShuffledCard.value.word,
          isCorrect,
          mode: "words-crush"
        });
      }
      pronunciationAnswered.value = true;
      pronunciationCorrect.value = isCorrect;
      const isSmallScreen = window.innerWidth < 768;
      if (isSmallScreen) {
        setTimeout(() => {
          nextCard();
        }, 2e3);
      }
    };
    const resetAndRestoreCard = () => {
      resetAllModes();
      restoreCardState();
      if (practiceMode.value === "quiz" && currentShuffledCard.value) {
        const cardId = currentShuffledCard.value.id;
        const savedState = cardStateStorage.value[cardId];
        if (!savedState || savedState.quizAnswer === void 0) {
          generateQuizOptions();
        }
      }
      if (practiceMode.value === "image" && imageQuizEnabled.value && currentShuffledCard.value) {
        if (!imageQuizOptions.value || imageQuizOptions.value.length === 0) {
          generateImageQuizOptions();
        }
      }
      if (practiceMode.value === "typing" && typingQuizEnabled.value && currentShuffledCard.value) {
        if (!typingQuizOptions.value || typingQuizOptions.value.length === 0) {
          generateTypingQuizOptions();
        }
      }
      if (practiceMode.value === "listening" && listeningQuizEnabled.value && currentShuffledCard.value) {
        if (!listeningQuizOptions.value || listeningQuizOptions.value.length === 0) {
          generateListeningQuizOptions();
        }
      }
    };
    const toggleShuffle = () => {
      flashcardSettings.value.shuffleCards = !flashcardSettings.value.shuffleCards;
      if (flashcardSettings.value.shuffleCards) {
        shuffleFlashcards();
      } else {
        shuffledFlashcards.value = [];
      }
      cardStateStorage.value = {};
      currentIndex.value = 0;
      resetAndRestoreCard();
    };
    const enhancedNextCard = () => {
      saveCurrentCardState();
      if (practiceMode.value === "pronunciation" && pronunciationAnswered.value) {
        recordAnswer(pronunciationCorrect.value);
        if (currentShuffledCard.value && activeSessionId.value) {
          appendAnswer({
            cardId: currentShuffledCard.value.id,
            word: currentShuffledCard.value.word,
            meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
            userAnswer: pronunciationResult.value,
            correctAnswer: currentShuffledCard.value.word,
            isCorrect: !!pronunciationCorrect.value,
            mode: "pronunciation"
          });
        }
      }
      if (currentIndex.value < currentFlashcards.value.length - 1) {
        currentIndex.value++;
        resetAndRestoreCard();
        if (practiceStarted.value && practiceTimerRef.value) {
          practiceTimerRef.value.nextCard();
        }
      } else {
        handleSessionComplete();
      }
    };
    const enhancedPreviousCard = () => {
      saveCurrentCardState();
      if (currentIndex.value > 0) {
        currentIndex.value--;
        resetAndRestoreCard();
        if (practiceStarted.value && practiceTimerRef.value) {
          practiceTimerRef.value.stopTimer();
        }
      }
    };
    const enhancedMarkEasy = () => {
      recordAnswer(true);
      enhancedNextCard();
    };
    const enhancedMarkDifficult = () => {
      recordAnswer(false);
      enhancedNextCard();
    };
    const handleSessionComplete = () => {
      completeSession();
      const totalCards = currentFlashcards.value.length;
      const id = saveSessionToHistory(stats.value, totalCards, activeSessionId.value || void 0);
      if (!activeSessionId.value) {
        activeSessionId.value = id;
      }
    };
    const handleRestartSession = () => {
      restartSession();
      practiceStarted.value = false;
      cardStateStorage.value = {};
      modalStore.setCompletionModal(false);
      if (flashcardSettings.value.shuffleCards && baseFlashcards.value.length > 0) {
        shuffleFlashcards();
      }
      resetAndRestoreCard();
      if (practiceTimerRef.value) {
        practiceTimerRef.value.resetPractice();
      }
    };
    const handleCompletionGoBack = () => {
      modalStore.setCompletionModal(false);
      goBack();
    };
    const handleSnakeGameComplete = () => {
      const expectedCorrect = currentFlashcards.value.length;
      const actualCorrect = stats.value.correct;
      if (actualCorrect < expectedCorrect) {
        recordAnswer(true);
      }
      handleSessionComplete();
    };
    const handleSnakeCorrectFoodEaten = (details) => {
      console.log("[DEBUG] Snake correct food eaten, recording answer true");
      console.log("[DEBUG] Stats before:", { correct: stats.value.correct, incorrect: stats.value.incorrect, total: stats.value.total });
      recordAnswer(true);
      console.log("[DEBUG] Stats after:", { correct: stats.value.correct, incorrect: stats.value.incorrect, total: stats.value.total });
      if (details && activeSessionId.value) {
        console.log("[DEBUG] FlashcardView - Recording snake correct food:", details);
        console.log("[DEBUG] FlashcardView - Snake body to save:", details.snakeBody);
        console.log("[DEBUG] FlashcardView - Snake direction to save:", details.direction);
        appendAnswer({
          cardId: Date.now(),
          // Unique numeric ID for snake game food eaten
          word: details.word,
          meaningShort: details.meaningShort,
          userAnswer: details.word,
          // Correct food eaten
          correctAnswer: details.word,
          isCorrect: true,
          mode: "snake-game",
          extra: {
            snakeGame: {
              position: details.position,
              wasCorrect: true,
              foodType: "primary",
              // Correct food is always primary target
              snakeLength: details.snakeLength,
              gameScore: details.gameScore,
              wordsCompleted: details.wordsCompleted,
              wrongEatenCount: details.wrongEatenCount,
              snakeBody: details.snakeBody,
              direction: details.direction,
              timelineFrames: details.timelineFrames
            }
          }
        });
      }
    };
    const handleSnakeWrongFoodEaten = (details) => {
      recordAnswer(false);
      if (details && activeSessionId.value) {
        appendAnswer({
          cardId: Date.now(),
          // Unique numeric ID for snake game food eaten
          word: details.word,
          meaningShort: details.meaningShort,
          userAnswer: details.word,
          // Wrong food eaten
          correctAnswer: "",
          // No specific correct answer for wrong food
          isCorrect: false,
          mode: "snake-game",
          extra: {
            snakeGame: {
              position: details.position,
              wasCorrect: false,
              foodType: "secondary",
              // Wrong food is secondary/decoy
              snakeLength: details.snakeLength,
              gameScore: details.gameScore,
              wordsCompleted: details.wordsCompleted,
              wrongEatenCount: details.wrongEatenCount,
              snakeBody: details.snakeBody,
              direction: details.direction,
              timelineFrames: details.timelineFrames
            }
          }
        });
      }
    };
    let autoFlipTimer = null;
    watch([currentIndex, isFlipped], () => {
      if (autoFlipTimer) {
        clearTimeout(autoFlipTimer);
      }
      if (flashcardSettings.value.autoFlip && !isFlipped.value) {
        autoFlipTimer = setTimeout(() => {
          isFlipped.value = true;
        }, 3e3);
      }
    });
    watch(practiceMode, () => {
      resetAndRestoreCard();
      if (flashcardSettings.value.shuffleCards && shuffledFlashcards.value.length === 0) {
        shuffleFlashcards();
      }
    });
    watch(showCompletionModal, (newValue) => {
      if (newValue) {
        if (practiceTimerRef.value) {
          practiceTimerRef.value.stopTimer();
        }
        modalStore.setCompletionModal(true);
      } else {
        modalStore.setCompletionModal(false);
      }
    });
    watch(showHistory, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        document.body.classList.remove("modal-open");
      }
    });
    watch(showSessionDetail, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        document.body.classList.remove("modal-open");
      }
    });
    watch(showSettingsDialog, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        document.body.classList.remove("modal-open");
      }
    });
    watch(dateFilterEnabled, () => {
      saveDateFilterState();
    });
    watch(selectedDate, () => {
      saveDateFilterState();
    });
    watch(baseFlashcards, (newCards) => {
      if (flashcardSettings.value.shuffleCards && newCards.length > 0) {
        shuffleFlashcards(newCards);
        currentIndex.value = 0;
        resetAndRestoreCard();
      } else if (flashcardSettings.value.shuffleCards && newCards.length === 0) {
        shuffledFlashcards.value = [];
        currentIndex.value = 0;
      }
    }, { immediate: false });
    const handleFlipTileHintsToggle = (enabled) => {
      flashcardSettings.value.useFlipTileHints = enabled;
    };
    onMounted(() => {
      console.log("FlashcardView mounted");
      initializeStats(currentFlashcards.value.length);
      if (practiceMode.value === "quiz") {
        generateQuizOptions();
      }
      if (flashcardSettings.value.shuffleCards) {
        shuffleFlashcards();
      }
      setupNavigationGuard();
      window.addEventListener("beforeunload", handleBeforeUnload);
    });
    onUnmounted(() => {
      document.body.classList.remove("modal-open");
      cleanup();
      removeNavigationGuard();
      window.removeEventListener("beforeunload", handleBeforeUnload);
    });
    return (_ctx, _cache) => {
      const _component_FlashcardHeader = resolveComponent("FlashcardHeader");
      const _component_FlashcardProgress = resolveComponent("FlashcardProgress");
      const _component_LazyLoadComponent = resolveComponent("LazyLoadComponent");
      const _component_VoiceSelector = resolveComponent("VoiceSelector");
      const _component_FlashcardDateFilter = resolveComponent("FlashcardDateFilter");
      const _component_PracticeTimer = resolveComponent("PracticeTimer");
      const _component_FlashcardCard = resolveComponent("FlashcardCard");
      const _component_PictionaryMode = resolveComponent("PictionaryMode");
      const _component_FlashcardQuiz = resolveComponent("FlashcardQuiz");
      const _component_FlashcardTyping = resolveComponent("FlashcardTyping");
      const _component_FlashcardImage = resolveComponent("FlashcardImage");
      const _component_ListeningMode = resolveComponent("ListeningMode");
      const _component_PronunciationMode = resolveComponent("PronunciationMode");
      const _component_BubbleShooterMode = resolveComponent("BubbleShooterMode");
      const _component_SnakeGameMode = resolveComponent("SnakeGameMode");
      const _component_FlipTileMode = resolveComponent("FlipTileMode");
      const _component_FlashcardControls = resolveComponent("FlashcardControls");
      const _component_PracticeStats = resolveComponent("PracticeStats");
      const _component_FlashcardEmptyState = resolveComponent("FlashcardEmptyState");
      const _component_SettingsModal = resolveComponent("SettingsModal");
      const _component_HistoryModal = resolveComponent("HistoryModal");
      const _component_SessionDetailModal = resolveComponent("SessionDetailModal");
      const _component_CompletionModal = resolveComponent("CompletionModal");
      const _component_ExitWarningModal = resolveComponent("ExitWarningModal");
      return openBlock(), createElementBlock("div", _hoisted_1$1j, [
        _cache[24] || (_cache[24] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none" data-v-b1cf9130><div class="floating-shapes" data-v-b1cf9130><div class="absolute top-24 left-8 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob" data-v-b1cf9130></div><div class="absolute top-40 right-10 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000" data-v-b1cf9130></div><div class="absolute -bottom-10 left-24 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000" data-v-b1cf9130></div></div></div>', 1)),
        createVNode(_component_FlashcardHeader, {
          "current-index": unref(currentIndex),
          "total-cards": currentFlashcards.value.length,
          "practice-mode": unref(practiceMode),
          "shuffle-enabled": shuffleEnabled.value,
          "practice-started": practiceStarted.value,
          "image-quiz-enabled": unref(imageQuizEnabled),
          "listening-quiz-enabled": unref(listeningQuizEnabled),
          "typing-quiz-enabled": unref(typingQuizEnabled),
          "image-mode-available": imageModeAvailable.value,
          "pictionary-mode-available": pictionaryModeAvailable.value,
          "flip-tile-mode-available": flipTileModeAvailable.value,
          "bubble-shooter-mode-available": bubbleShooterModeAvailable.value,
          "bubble-shooter-vietnamese-mode": bubbleShooterVietnameseMode.value,
          "snake-double-bait-enabled": snakeDoubleBaitMode.value,
          "pictionary-definition-mode": pictionaryDefinitionMode.value,
          "scramble-words-enabled": scrambleWordsEnabled.value,
          "words-crush-enabled": wordsCrushEnabled.value,
          "use-flip-tile-hints": unref(flashcardSettings).useFlipTileHints,
          onGoBack: unref(goBack),
          onShowHistory: _cache[0] || (_cache[0] = ($event) => showHistory.value = true),
          onChangePracticeMode: _cache[1] || (_cache[1] = ($event) => unref(changePracticeMode)($event)),
          onShowSettings: _cache[2] || (_cache[2] = ($event) => showSettingsDialog.value = true),
          onToggleShuffle: toggleShuffle,
          "onUpdate:imageQuizEnabled": _cache[3] || (_cache[3] = ($event) => imageQuizEnabled.value = $event),
          "onUpdate:listeningQuizEnabled": _cache[4] || (_cache[4] = ($event) => listeningQuizEnabled.value = $event),
          "onUpdate:typingQuizEnabled": _cache[5] || (_cache[5] = ($event) => typingQuizEnabled.value = $event),
          "onUpdate:bubbleShooterVietnameseMode": _cache[6] || (_cache[6] = ($event) => bubbleShooterVietnameseMode.value = $event),
          "onUpdate:snakeDoubleBaitEnabled": _cache[7] || (_cache[7] = ($event) => snakeDoubleBaitMode.value = $event),
          "onUpdate:pictionaryDefinitionMode": _cache[8] || (_cache[8] = ($event) => pictionaryDefinitionMode.value = $event),
          "onUpdate:scrambleWordsEnabled": _cache[9] || (_cache[9] = ($event) => scrambleWordsEnabled.value = $event),
          "onUpdate:wordsCrushEnabled": _cache[10] || (_cache[10] = ($event) => wordsCrushEnabled.value = $event),
          "onUpdate:useFlipTileHints": handleFlipTileHintsToggle
        }, null, 8, ["current-index", "total-cards", "practice-mode", "shuffle-enabled", "practice-started", "image-quiz-enabled", "listening-quiz-enabled", "typing-quiz-enabled", "image-mode-available", "pictionary-mode-available", "flip-tile-mode-available", "bubble-shooter-mode-available", "bubble-shooter-vietnamese-mode", "snake-double-bait-enabled", "pictionary-definition-mode", "scramble-words-enabled", "words-crush-enabled", "use-flip-tile-hints", "onGoBack"]),
        createVNode(_component_LazyLoadComponent, {
          "animation-type": "slide-left",
          threshold: 0.1,
          "root-margin": "-50px"
        }, {
          default: withCtx(() => [
            createVNode(_component_FlashcardProgress, { "progress-percentage": currentProgressPercentage.value }, null, 8, ["progress-percentage"])
          ]),
          _: 1
        }),
        createVNode(_component_LazyLoadComponent, {
          "animation-type": "scale",
          threshold: 0.1,
          "root-margin": "-50px"
        }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_2$1g, [
              createBaseVNode("div", _hoisted_3$1d, [
                createVNode(_component_VoiceSelector, { "show-voice-info": false })
              ])
            ])
          ]),
          _: 1
        }),
        createVNode(_component_LazyLoadComponent, {
          "animation-type": "slide-right",
          threshold: 0.1,
          "root-margin": "-50px"
        }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_4$19, [
              createBaseVNode("div", _hoisted_5$16, [
                createVNode(_component_FlashcardDateFilter, {
                  vocabularies: unref(allVocabularies),
                  selectedDate: selectedDate.value,
                  "practice-started": practiceStarted.value,
                  "onUpdate:selectedDate": _cache[11] || (_cache[11] = ($event) => selectedDate.value = $event)
                }, null, 8, ["vocabularies", "selectedDate", "practice-started"])
              ])
            ])
          ]),
          _: 1
        }),
        createBaseVNode("div", _hoisted_6$13, [
          currentFlashcards.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_7$$, [
            createBaseVNode("div", _hoisted_8$Z, [
              createBaseVNode("div", _hoisted_9$Y, [
                createVNode(_component_LazyLoadComponent, {
                  "animation-type": "fade-up",
                  threshold: 0.1,
                  "root-margin": "-50px"
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_10$X, [
                      unref(practiceMode) === "bubble-shooter" || unref(practiceMode) === "snake-game" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        !practiceStarted.value ? (openBlock(), createElementBlock("button", {
                          key: 0,
                          onClick: handlePracticeStart,
                          class: "px-8 py-4 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 dark:from-purple-700 dark:to-pink-700 dark:hover:from-purple-800 dark:hover:to-pink-800 text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200"
                        }, toDisplayString$1(unref(t)("practice.startGame", "Start Game")), 1)) : createCommentVNode("", true)
                      ], 64)) : (openBlock(), createBlock(_component_PracticeTimer, {
                        key: 1,
                        ref_key: "practiceTimerRef",
                        ref: practiceTimerRef,
                        "max-time": 30,
                        onStart: handlePracticeStart,
                        onTimeout: handleTimeout,
                        onRestart: handleTimerRestart,
                        onSkip: handleSkip
                      }, null, 512))
                    ])
                  ]),
                  _: 1
                }),
                practiceStarted.value ? (openBlock(), createElementBlock("div", _hoisted_11$X, [
                  createVNode(_component_LazyLoadComponent, {
                    "animation-type": "scale",
                    threshold: 0.1,
                    "root-margin": "-50px"
                  }, {
                    default: withCtx(() => [
                      unref(practiceMode) === "flashcard" ? (openBlock(), createBlock(_component_FlashcardCard, {
                        key: 0,
                        "current-card": currentShuffledCard.value,
                        "is-flipped": unref(isFlipped),
                        "scramble-words-enabled": scrambleWordsEnabled.value,
                        "current-index": unref(currentIndex),
                        "total-cards": currentFlashcards.value.length,
                        onFlipCard: unref(flipCard),
                        onNextCard: enhancedNextCard,
                        onShowResults: unref(completeSession),
                        onScrambleAnswer: handleScrambleAnswer
                      }, null, 8, ["current-card", "is-flipped", "scramble-words-enabled", "current-index", "total-cards", "onFlipCard", "onShowResults"])) : unref(practiceMode) === "pictionary" ? (openBlock(), createBlock(_component_PictionaryMode, {
                        key: 1,
                        card: currentShuffledCard.value,
                        "pictionary-answer": unref(pictionaryAnswer),
                        "pictionary-answered": unref(pictionaryAnswered),
                        "pictionary-correct": unref(pictionaryCorrect),
                        "definition-mode": pictionaryDefinitionMode.value,
                        "get-topic-name": unref(getTopicName),
                        "onUpdate:pictionaryAnswer": _cache[12] || (_cache[12] = ($event) => pictionaryAnswer.value = $event),
                        onCheckAnswer: handlePictionaryAnswer,
                        onPictionarySnapshot
                      }, null, 8, ["card", "pictionary-answer", "pictionary-answered", "pictionary-correct", "definition-mode", "get-topic-name"])) : unref(practiceMode) === "quiz" ? (openBlock(), createBlock(_component_FlashcardQuiz, {
                        key: 2,
                        "current-card": currentShuffledCard.value,
                        "quiz-options": unref(quizOptions),
                        "selected-answer": unref(selectedAnswer),
                        "quiz-answered": unref(quizAnswered),
                        onSelectAnswer: handleQuizAnswer
                      }, null, 8, ["current-card", "quiz-options", "selected-answer", "quiz-answered"])) : unref(practiceMode) === "typing" ? (openBlock(), createBlock(_component_FlashcardTyping, {
                        key: 3,
                        "current-card": currentShuffledCard.value,
                        "typing-answer": unref(typingAnswer),
                        "typing-answered": unref(typingAnswered),
                        "typing-correct": unref(typingCorrect),
                        "typing-quiz-enabled": unref(typingQuizEnabled),
                        "typing-quiz-options": unref(typingQuizOptions),
                        "typing-quiz-selected": unref(typingQuizSelected),
                        "typing-quiz-answered": unref(typingQuizAnswered),
                        "onUpdate:typingAnswer": _cache[13] || (_cache[13] = ($event) => typingAnswer.value = $event),
                        onCheckAnswer: handleTypingAnswer,
                        onSelectTypingQuizAnswer: _cache[14] || (_cache[14] = ($event) => handleTypingQuizAnswer($event))
                      }, null, 8, ["current-card", "typing-answer", "typing-answered", "typing-correct", "typing-quiz-enabled", "typing-quiz-options", "typing-quiz-selected", "typing-quiz-answered"])) : unref(practiceMode) === "image" ? (openBlock(), createBlock(_component_FlashcardImage, {
                        key: 4,
                        "current-card": currentShuffledCard.value,
                        "image-answer": unref(imageAnswer),
                        "image-answered": unref(imageAnswered),
                        "image-correct": unref(imageCorrect),
                        "image-quiz-enabled": unref(imageQuizEnabled),
                        "image-quiz-options": unref(imageQuizOptions),
                        "image-quiz-selected": unref(imageQuizSelected),
                        "image-quiz-answered": unref(imageQuizAnswered),
                        "onUpdate:imageAnswer": _cache[15] || (_cache[15] = ($event) => imageAnswer.value = $event),
                        onCheckAnswer: handleImageAnswer,
                        "onUpdate:imageQuizEnabled": _cache[16] || (_cache[16] = ($event) => onToggleImageQuiz($event)),
                        onSelectImageQuizAnswer: _cache[17] || (_cache[17] = ($event) => handleImageQuizAnswer($event))
                      }, null, 8, ["current-card", "image-answer", "image-answered", "image-correct", "image-quiz-enabled", "image-quiz-options", "image-quiz-selected", "image-quiz-answered"])) : unref(practiceMode) === "listening" ? (openBlock(), createBlock(_component_ListeningMode, {
                        key: 5,
                        card: currentShuffledCard.value,
                        "listening-answer": unref(listeningAnswer),
                        "onUpdate:listeningAnswer": _cache[18] || (_cache[18] = ($event) => listeningAnswer.value = $event),
                        "listening-answered": unref(listeningAnswered),
                        "listening-correct": unref(listeningCorrect),
                        "listening-quiz-enabled": unref(listeningQuizEnabled),
                        "listening-quiz-options": unref(listeningQuizOptions),
                        "listening-quiz-selected": unref(listeningQuizSelected),
                        "listening-quiz-answered": unref(listeningQuizAnswered),
                        "get-topic-name": unref(getTopicName),
                        onCheckAnswer: handleListeningAnswer,
                        onPlayAudio: unref(playAudio),
                        onSelectListeningQuizAnswer: _cache[19] || (_cache[19] = ($event) => handleListeningQuizAnswer($event))
                      }, null, 8, ["card", "listening-answer", "listening-answered", "listening-correct", "listening-quiz-enabled", "listening-quiz-options", "listening-quiz-selected", "listening-quiz-answered", "get-topic-name", "onPlayAudio"])) : unref(practiceMode) === "pronunciation" ? (openBlock(), createBlock(_component_PronunciationMode, {
                        key: 6,
                        card: currentShuffledCard.value,
                        "is-recording": unref(isRecording),
                        "pronunciation-result": unref(pronunciationResult),
                        "pronunciation-answered": unref(pronunciationAnswered),
                        "pronunciation-correct": unref(pronunciationCorrect),
                        "is-speech-recognition-supported": unref(isSpeechRecognitionSupported),
                        "get-topic-name": unref(getTopicName),
                        "words-crush-enabled": wordsCrushEnabled.value,
                        onStartRecording: unref(startRecording),
                        onGameCompleted: handleWordsCrushCompleted,
                        onPlayAudio: unref(playAudio)
                      }, null, 8, ["card", "is-recording", "pronunciation-result", "pronunciation-answered", "pronunciation-correct", "is-speech-recognition-supported", "get-topic-name", "words-crush-enabled", "onStartRecording", "onPlayAudio"])) : unref(practiceMode) === "bubble-shooter" ? (openBlock(), createBlock(_component_BubbleShooterMode, {
                        key: 7,
                        words: currentFlashcards.value,
                        "vietnamese-mode": bubbleShooterVietnameseMode.value,
                        onGameComplete: handleBubbleShooterComplete
                      }, null, 8, ["words", "vietnamese-mode"])) : unref(practiceMode) === "snake-game" ? (openBlock(), createBlock(_component_SnakeGameMode, {
                        key: 8,
                        words: currentFlashcards.value,
                        "vietnamese-mode": bubbleShooterVietnameseMode.value,
                        "double-bait-mode": snakeDoubleBaitMode.value,
                        "record-timeline": true,
                        onGameComplete: handleSnakeGameComplete,
                        onCorrectFoodEaten: handleSnakeCorrectFoodEaten,
                        onWrongFoodEaten: handleSnakeWrongFoodEaten
                      }, null, 8, ["words", "vietnamese-mode", "double-bait-mode"])) : unref(practiceMode) === "flip-tile" ? (openBlock(), createBlock(_component_FlipTileMode, {
                        key: 9,
                        card: currentShuffledCard.value,
                        "flip-tile-answer": unref(flipTileAnswer),
                        "flip-tile-answered": unref(flipTileAnswered),
                        "flip-tile-correct": unref(flipTileCorrect),
                        "get-topic-name": unref(getTopicName),
                        "use-hints": unref(flashcardSettings).useFlipTileHints,
                        "onUpdate:flipTileAnswer": _cache[20] || (_cache[20] = ($event) => flipTileAnswer.value = $event),
                        onCheckAnswer: handleFlipTileAnswer
                      }, null, 8, ["card", "flip-tile-answer", "flip-tile-answered", "flip-tile-correct", "get-topic-name", "use-hints"])) : createCommentVNode("", true)
                    ]),
                    _: 1
                  }),
                  createVNode(_component_LazyLoadComponent, {
                    "animation-type": "slide-left",
                    threshold: 0.1,
                    "root-margin": "-50px"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_FlashcardControls, {
                        "practice-mode": unref(practiceMode),
                        "current-index": unref(currentIndex),
                        "total-cards": currentFlashcards.value.length,
                        "can-proceed": unref(getCanProceed)()[unref(practiceMode)],
                        "practice-started": practiceStarted.value,
                        "scramble-words-enabled": scrambleWordsEnabled.value,
                        "typing-answer": unref(typingAnswer),
                        "typing-answered": unref(typingAnswered),
                        "listening-answer": unref(listeningAnswer),
                        "listening-answered": unref(listeningAnswered),
                        "image-answer": unref(imageAnswer),
                        "image-answered": unref(imageAnswered),
                        onMarkDifficult: enhancedMarkDifficult,
                        onMarkEasy: enhancedMarkEasy,
                        onPreviousCard: enhancedPreviousCard,
                        onNextCard: enhancedNextCard,
                        onCheckTypingAnswer: handleTypingAnswer,
                        onCheckListeningAnswer: handleListeningAnswer,
                        onCheckImageAnswer: handleImageAnswer,
                        onExitPractice: handleExitPractice
                      }, null, 8, ["practice-mode", "current-index", "total-cards", "can-proceed", "practice-started", "scramble-words-enabled", "typing-answer", "typing-answered", "listening-answer", "listening-answered", "image-answer", "image-answered"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_LazyLoadComponent, {
                    "animation-type": "scale",
                    threshold: 0.1,
                    "root-margin": "-50px"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_PracticeStats, {
                        stats: unref(stats),
                        mode: unref(practiceMode)
                      }, null, 8, ["stats", "mode"])
                    ]),
                    _: 1
                  })
                ])) : createCommentVNode("", true)
              ])
            ])
          ])) : createCommentVNode("", true),
          createVNode(_component_LazyLoadComponent, {
            "animation-type": "fade-up",
            threshold: 0.1,
            "root-margin": "-50px"
          }, {
            default: withCtx(() => [
              currentFlashcards.value.length === 0 ? (openBlock(), createBlock(_component_FlashcardEmptyState, {
                key: 0,
                onGoToVocabulary: unref(goToVocabulary)
              }, null, 8, ["onGoToVocabulary"])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ]),
        createVNode(_component_SettingsModal, {
          show: unref(showSettingsDialog),
          settings: unref(settings),
          "local-settings": unref(localSettings),
          "date-filter-enabled": dateFilterEnabled.value,
          "selected-date": selectedDate.value,
          "onUpdate:localSettings": _cache[21] || (_cache[21] = ($event) => localSettings.value = $event),
          onCancel: unref(cancelSettings),
          onApply: unref(applyGameSettings)
        }, null, 8, ["show", "settings", "local-settings", "date-filter-enabled", "selected-date", "onCancel", "onApply"]),
        createVNode(_component_HistoryModal, {
          show: unref(showHistory),
          history: unref(practiceHistory),
          "get-mode-color": unref(getModeColor),
          "get-mode-text": unref(getModeText),
          "format-date": unref(formatDate),
          "format-duration": unref(formatDuration),
          onClose: _cache[22] || (_cache[22] = ($event) => showHistory.value = false),
          onOpenDetails: openHistoryDetails,
          onDeleteSession: handleDeleteSession
        }, null, 8, ["show", "history", "get-mode-color", "get-mode-text", "format-date", "format-duration"]),
        createVNode(_component_SessionDetailModal, {
          show: showSessionDetail.value,
          details: selectedSessionDetails.value,
          onClose: _cache[23] || (_cache[23] = ($event) => showSessionDetail.value = false)
        }, null, 8, ["show", "details"]),
        createVNode(_component_CompletionModal, {
          show: unref(showCompletionModal),
          stats: unref(stats),
          "card-count": unref(flashcards).length,
          onRestart: handleRestartSession,
          onGoBack: handleCompletionGoBack
        }, null, 8, ["show", "stats", "card-count"]),
        createVNode(_component_ExitWarningModal, {
          show: showExitWarning.value,
          onContinue: continueSession,
          onConfirm: confirmExit
        }, null, 8, ["show"])
      ]);
    };
  }
});

const FlashcardView = /* @__PURE__ */ _export_sfc(_sfc_main$1k, [["__scopeId", "data-v-b1cf9130"]]);

const _hoisted_1$1i = { class: "min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 dark:from-gray-900 dark:to-[#0a0a0a]" };
const _hoisted_2$1f = { class: "max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8" };
const _sfc_main$1j = /* @__PURE__ */ defineComponent({
  __name: "QuizView",
  setup(__props) {
    const QuizHeader$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => QuizHeader),true              ?void 0:void 0))
    );
    const QuizProgress$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => QuizProgress),true              ?void 0:void 0))
    );
    const QuizSetup$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => QuizSetup),true              ?void 0:void 0))
    );
    const QuizQuestion$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => QuizQuestion),true              ?void 0:void 0))
    );
    const QuizResults$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => QuizResults),true              ?void 0:void 0))
    );
    const router = useRouter();
    const vocabularyStore = useVocabularyStore();
    const quizStarted = ref(false);
    const quizCompleted = ref(false);
    const currentQuestionIndex = ref(0);
    const selectedAnswer = ref(null);
    const userAnswers = ref([]);
    const score = ref(0);
    const timeRemaining = ref(0);
    let timer = null;
    const quizSettings = ref({
      type: "vocabulary",
      level: "",
      questionCount: "10",
      timeLimit: "10"
    });
    const questions = ref([]);
    const generateQuestionsFromVocabulary = (vocabularies) => {
      console.log("Generating questions from", vocabularies.length, "vocabularies");
      if (vocabularies.length === 0) return [];
      const vocabQuestions = vocabularies.map((vocab, index) => {
        const otherVocabs = vocabularies.filter((v) => v.id !== vocab.id);
        let incorrectOptions = [];
        if (otherVocabs.length > 0) {
          incorrectOptions = otherVocabs.slice(0, 3).map((v) => v.meaning.split(" - ")[0]);
        }
        const genericOptions = ["Không có nghĩa", "Từ khác", "Khái niệm khác", "Nghĩa khác", "Ý nghĩa khác"];
        while (incorrectOptions.length < 3) {
          const randomGeneric = genericOptions[Math.floor(Math.random() * genericOptions.length)];
          if (!incorrectOptions.includes(randomGeneric)) {
            incorrectOptions.push(randomGeneric);
          }
        }
        const correctMeaning = vocab.meaning.split(" - ")[0];
        const allOptions = [correctMeaning, ...incorrectOptions.slice(0, 3)];
        const shuffledOptions = allOptions.sort(() => Math.random() - 0.5);
        const correctAnswer = shuffledOptions.indexOf(correctMeaning);
        return {
          id: vocab.id,
          type: "vocabulary",
          level: vocab.level,
          question: `What does "${vocab.word}" mean?`,
          options: shuffledOptions,
          correctAnswer,
          explanation: `"${vocab.word}" có nghĩa là: ${vocab.meaning}`
        };
      });
      return vocabQuestions.sort(() => Math.random() - 0.5);
    };
    const updateQuestions = () => {
      const vocabularies = vocabularyStore.allVocabularies.value;
      console.log("Updating questions from", vocabularies.length, "total vocabularies");
      const filteredVocabs = vocabularies.filter((vocab) => {
        if (quizSettings.value.level && vocab.level !== quizSettings.value.level) {
          return false;
        }
        return true;
      });
      console.log("Filtered to", filteredVocabs.length, "vocabularies for quiz");
      const generatedQuestions = generateQuestionsFromVocabulary(filteredVocabs);
      const questionCount = parseInt(quizSettings.value.questionCount);
      questions.value = generatedQuestions.slice(0, questionCount);
      console.log("Generated", questions.value.length, "questions");
    };
    const availableLevels = computed(() => {
      return vocabularyStore.getLevels.value;
    });
    const currentQuestion = computed(() => questions.value[currentQuestionIndex.value] || {});
    const progressPercentage = computed(() => (currentQuestionIndex.value + 1) / questions.value.length * 100);
    const correctAnswers = computed(() => {
      return userAnswers.value.filter((answer, index) => answer === questions.value[index].correctAnswer).length;
    });
    const accuracy = computed(() => correctAnswers.value / questions.value.length * 100);
    const startQuiz = (settings) => {
      if (settings) {
        quizSettings.value = { ...settings };
      }
      if (questions.value.length === 0) {
        updateQuestions();
      }
      if (questions.value.length === 0) {
        alert("Không có từ vựng nào để luyện tập. Vui lòng thêm từ vựng trước!");
        return;
      }
      quizStarted.value = true;
      if (quizSettings.value.timeLimit !== "0") {
        timeRemaining.value = parseInt(quizSettings.value.timeLimit) * 60;
        startTimer();
      }
      userAnswers.value = new Array(questions.value.length).fill(-1);
    };
    const startTimer = () => {
      timer = setInterval(() => {
        timeRemaining.value--;
        if (timeRemaining.value <= 0) {
          completeQuiz();
        }
      }, 1e3);
    };
    const selectAnswer = (index) => {
      selectedAnswer.value = index;
    };
    const nextQuestion = () => {
      if (selectedAnswer.value !== null) {
        userAnswers.value[currentQuestionIndex.value] = selectedAnswer.value;
        if (currentQuestionIndex.value === questions.value.length - 1) {
          completeQuiz();
        } else {
          currentQuestionIndex.value++;
          selectedAnswer.value = userAnswers.value[currentQuestionIndex.value] !== -1 ? userAnswers.value[currentQuestionIndex.value] : null;
        }
      }
    };
    const previousQuestion = () => {
      if (currentQuestionIndex.value > 0) {
        userAnswers.value[currentQuestionIndex.value] = selectedAnswer.value || -1;
        currentQuestionIndex.value--;
        selectedAnswer.value = userAnswers.value[currentQuestionIndex.value] !== -1 ? userAnswers.value[currentQuestionIndex.value] : null;
      }
    };
    const completeQuiz = () => {
      if (selectedAnswer.value !== null) {
        userAnswers.value[currentQuestionIndex.value] = selectedAnswer.value;
      }
      score.value = correctAnswers.value * 10;
      quizCompleted.value = true;
      if (timer) {
        clearInterval(timer);
      }
    };
    const restartQuiz = () => {
      quizStarted.value = false;
      quizCompleted.value = false;
      currentQuestionIndex.value = 0;
      selectedAnswer.value = null;
      userAnswers.value = [];
      score.value = 0;
      timeRemaining.value = 0;
      updateQuestions();
      if (timer) {
        clearInterval(timer);
      }
    };
    const goBack = () => {
      router.back();
    };
    onMounted(async () => {
      const isReady = vocabularyStore.initializeStore();
      if (!isReady.value) {
        await new Promise(
          (resolve) => watch(isReady, (ready) => {
            if (ready) resolve(true);
          }, { immediate: true })
        );
      }
      updateQuestions();
      console.log("Quiz view mounted", vocabularyStore.allVocabularies.value.length, "vocabularies loaded");
    });
    watch(
      () => vocabularyStore.isStoreReady.value,
      (isReady) => {
        if (isReady) {
          updateQuestions();
        }
      },
      { immediate: true }
    );
    watch(
      () => vocabularyStore.allVocabularies.value,
      () => {
        if (vocabularyStore.isStoreReady.value) {
          updateQuestions();
        }
      },
      { deep: true }
    );
    watch(
      () => quizSettings.value,
      () => {
        updateQuestions();
      },
      { deep: true }
    );
    onUnmounted(() => {
      if (timer) {
        clearInterval(timer);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1i, [
        createVNode(unref(QuizHeader$1), {
          "time-remaining": timeRemaining.value,
          score: score.value,
          onGoBack: goBack
        }, null, 8, ["time-remaining", "score"]),
        createVNode(unref(QuizProgress$1), {
          "current-question-index": currentQuestionIndex.value,
          "total-questions": questions.value.length,
          "progress-percentage": progressPercentage.value
        }, null, 8, ["current-question-index", "total-questions", "progress-percentage"]),
        createBaseVNode("div", _hoisted_2$1f, [
          !quizStarted.value ? (openBlock(), createBlock(unref(QuizSetup$1), {
            key: 0,
            settings: quizSettings.value,
            "available-levels": availableLevels.value,
            onStartQuiz: startQuiz
          }, null, 8, ["settings", "available-levels"])) : !quizCompleted.value ? (openBlock(), createBlock(unref(QuizQuestion$1), {
            key: 1,
            question: currentQuestion.value,
            "selected-answer": selectedAnswer.value,
            "is-first-question": currentQuestionIndex.value === 0,
            "is-last-question": currentQuestionIndex.value === questions.value.length - 1,
            onSelectAnswer: selectAnswer,
            onPreviousQuestion: previousQuestion,
            onNextQuestion: nextQuestion
          }, null, 8, ["question", "selected-answer", "is-first-question", "is-last-question"])) : (openBlock(), createBlock(unref(QuizResults$1), {
            key: 2,
            score: score.value,
            "correct-answers": correctAnswers.value,
            "total-questions": questions.value.length,
            accuracy: Math.round(accuracy.value),
            questions: questions.value,
            "user-answers": userAnswers.value,
            onRestartQuiz: restartQuiz,
            onGoBack: goBack
          }, null, 8, ["score", "correct-answers", "total-questions", "accuracy", "questions", "user-answers"]))
        ])
      ]);
    };
  }
});

const useThemeStore = defineStore("theme", () => {
  const isDarkMode = ref(false);
  const toggleTheme = () => {
    isDarkMode.value = !isDarkMode.value;
    applyTheme();
    saveThemeToStorage();
  };
  const setTheme = (dark) => {
    isDarkMode.value = dark;
    applyTheme();
    saveThemeToStorage();
  };
  const applyTheme = () => {
    const html = document.documentElement;
    if (isDarkMode.value) {
      html.classList.add("dark");
      html.style.colorScheme = "dark";
    } else {
      html.classList.remove("dark");
      html.style.colorScheme = "light";
    }
  };
  const saveThemeToStorage = () => {
    localStorage.setItem("theme", isDarkMode.value ? "dark" : "light");
  };
  const loadThemeFromStorage = () => {
    const savedTheme = localStorage.getItem("theme");
    if (savedTheme) {
      isDarkMode.value = savedTheme === "dark";
    } else {
      isDarkMode.value = window.matchMedia("(prefers-color-scheme: dark)").matches;
    }
    applyTheme();
  };
  const initTheme = () => {
    loadThemeFromStorage();
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    mediaQuery.addEventListener("change", (e) => {
      if (!localStorage.getItem("theme")) {
        isDarkMode.value = e.matches;
        applyTheme();
      }
    });
  };
  const currentTheme = () => isDarkMode.value ? "dark" : "light";
  const themeIcon = () => isDarkMode.value ? "🌙" : "☀️";
  const themeLabel = () => isDarkMode.value ? "Chế độ tối" : "Chế độ sáng";
  return {
    // State
    isDarkMode,
    // Actions
    toggleTheme,
    setTheme,
    initTheme,
    // Getters
    currentTheme,
    themeIcon,
    themeLabel
  };
});

const _hoisted_1$1h = { class: "max-w-4xl mx-auto space-y-8" };
const _hoisted_2$1e = { class: "grid grid-cols-1 md:grid-cols-2 gap-6" };
const _hoisted_3$1c = { class: "bg-white dark:bg-black rounded-xl shadow-md overflow-hidden border border-gray-200 dark:border-gray-700" };
const _hoisted_4$18 = { class: "p-6" };
const _hoisted_5$15 = { class: "mt-4" };
const _hoisted_6$12 = { class: "flex items-center space-x-2" };
const _hoisted_7$_ = { class: "px-2 py-1 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 text-xs font-medium rounded-full" };
const _sfc_main$1i = /* @__PURE__ */ defineComponent({
  __name: "TailwindTest",
  setup(__props) {
    const themeStore = useThemeStore();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1h, [
        _cache[5] || (_cache[5] = createBaseVNode("div", { class: "text-center" }, [
          createBaseVNode("h1", { class: "text-4xl font-bold text-gray-900 dark:text-white mb-4" }, " Tailwind CSS & Dark Mode Test "),
          createBaseVNode("p", { class: "text-lg text-gray-600 dark:text-gray-300" }, " Test các component với chế độ sáng/tối ")
        ], -1)),
        createBaseVNode("div", _hoisted_2$1e, [
          _cache[4] || (_cache[4] = createStaticVNode('<div class="bg-white dark:bg-gray-800 rounded-xl shadow-md overflow-hidden border border-gray-200 dark:border-gray-700"><div class="p-6"><div class="uppercase tracking-wide text-sm text-indigo-500 dark:text-indigo-400 font-semibold"> Tailwind CSS </div><h2 class="block mt-1 text-lg leading-tight font-medium text-gray-900 dark:text-white"> Dark Mode Support </h2><p class="mt-2 text-gray-500 dark:text-gray-400"> Tailwind CSS đã được cấu hình với dark mode sử dụng màu đen. </p><div class="mt-4 space-x-2"><button class="bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition-colors"> Primary Button </button><button class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-900 dark:text-white font-medium py-2 px-4 rounded-lg transition-colors"> Secondary Button </button></div></div></div>', 1)),
          createBaseVNode("div", _hoisted_3$1c, [
            createBaseVNode("div", _hoisted_4$18, [
              _cache[1] || (_cache[1] = createBaseVNode("div", { class: "uppercase tracking-wide text-sm text-green-500 dark:text-green-400 font-semibold" }, " Pinia Store ", -1)),
              _cache[2] || (_cache[2] = createBaseVNode("h2", { class: "block mt-1 text-lg leading-tight font-medium text-gray-900 dark:text-white" }, " Theme Management ", -1)),
              _cache[3] || (_cache[3] = createBaseVNode("p", { class: "mt-2 text-gray-500 dark:text-gray-400" }, " Sử dụng Pinia để quản lý state của theme. ", -1)),
              createBaseVNode("div", _hoisted_5$15, [
                createBaseVNode("div", _hoisted_6$12, [
                  _cache[0] || (_cache[0] = createBaseVNode("span", { class: "text-sm text-gray-600 dark:text-gray-300" }, "Current theme:", -1)),
                  createBaseVNode("span", _hoisted_7$_, toDisplayString$1(unref(themeStore).currentTheme()), 1)
                ])
              ])
            ])
          ])
        ]),
        _cache[6] || (_cache[6] = createStaticVNode('<div class="bg-white dark:bg-black rounded-xl shadow-md p-6 border border-gray-200 dark:border-gray-700"><h3 class="text-lg font-medium text-gray-900 dark:text-white mb-4">Form Elements</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"> Text Input </label><input type="text" placeholder="Enter text..." class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 transition-colors"></div><div><label class="block text-sm font-medium text-gray-700 dark:text-dark-text-secondary mb-2"> Select </label><select class="w-full px-3 py-2 border border-gray-300 dark:border-dark-border rounded-md bg-white dark:bg-dark-surface text-gray-900 dark:text-dark-text-primary focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 transition-colors"><option>Option 1</option><option>Option 2</option><option>Option 3</option></select></div></div></div><div class="bg-white dark:bg-black rounded-xl shadow-md p-6 border border-gray-200 dark:border-gray-700"><h3 class="text-lg font-medium text-gray-900 dark:text-white mb-4">Color Palette</h3><div class="grid grid-cols-2 md:grid-cols-4 gap-4"><div class="text-center"><div class="w-16 h-16 bg-blue-500 dark:bg-blue-600 rounded-lg mx-auto mb-2"></div><span class="text-sm text-gray-600 dark:text-gray-300">Blue</span></div><div class="text-center"><div class="w-16 h-16 bg-green-500 dark:bg-green-600 rounded-lg mx-auto mb-2"></div><span class="text-sm text-gray-600 dark:text-gray-300">Green</span></div><div class="text-center"><div class="w-16 h-16 bg-red-500 dark:bg-red-600 rounded-lg mx-auto mb-2"></div><span class="text-sm text-gray-600 dark:text-gray-300">Red</span></div><div class="text-center"><div class="w-16 h-16 bg-purple-500 dark:bg-purple-600 rounded-lg mx-auto mb-2"></div><span class="text-sm text-gray-600 dark:text-gray-300">Purple</span></div></div></div>', 2))
      ]);
    };
  }
});

const _hoisted_1$1g = { class: "min-h-screen bg-gray-50 dark:bg-black flex flex-col justify-center py-12 sm:px-6 lg:px-8" };
const _hoisted_2$1d = { class: "sm:mx-auto sm:w-full sm:max-w-md" };
const _hoisted_3$1b = { class: "text-center" };
const _hoisted_4$17 = { class: "mt-8 space-y-4" };
const _hoisted_5$14 = { class: "text-center" };
const _hoisted_6$11 = { class: "mt-4 flex justify-center space-x-6" };
const _sfc_main$1h = /* @__PURE__ */ defineComponent({
  __name: "NotFoundView",
  setup(__props) {
    const router = useRouter();
    const goBack = () => {
      router.back();
    };
    const goHome = () => {
      router.push("/dashboard");
    };
    return (_ctx, _cache) => {
      const _component_router_link = resolveComponent("router-link");
      return openBlock(), createElementBlock("div", _hoisted_1$1g, [
        createBaseVNode("div", _hoisted_2$1d, [
          createBaseVNode("div", _hoisted_3$1b, [
            _cache[7] || (_cache[7] = createStaticVNode('<div class="mx-auto h-24 w-24 flex items-center justify-center rounded-full bg-red-100 dark:bg-red-900"><svg class="h-12 w-12 text-red-600 dark:text-red-300" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path></svg></div><h1 class="mt-6 text-6xl font-bold text-gray-900 dark:text-white">404</h1><h2 class="mt-4 text-3xl font-bold text-gray-900 dark:text-white">Không tìm thấy trang</h2><p class="mt-2 text-lg text-gray-600 dark:text-gray-300"> Xin lỗi, chúng tôi không thể tìm thấy trang bạn đang tìm kiếm. </p>', 4)),
            createBaseVNode("div", _hoisted_4$17, [
              createBaseVNode("div", { class: "flex justify-center space-x-4" }, [
                createBaseVNode("button", {
                  onClick: goBack,
                  class: "bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                }, _cache[0] || (_cache[0] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5 inline mr-2",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                      "clip-rule": "evenodd"
                    })
                  ], -1),
                  createTextVNode(" Quay lại ")
                ])),
                createBaseVNode("button", {
                  onClick: goHome,
                  class: "bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                }, _cache[1] || (_cache[1] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5 inline mr-2",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", { d: "M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z" })
                  ], -1),
                  createTextVNode(" Về trang chủ ")
                ]))
              ]),
              createBaseVNode("div", _hoisted_5$14, [
                _cache[6] || (_cache[6] = createBaseVNode("p", { class: "text-sm text-gray-500 dark:text-gray-400" }, " Hoặc thử các liên kết hữu ích dưới đây: ", -1)),
                createBaseVNode("div", _hoisted_6$11, [
                  createVNode(_component_router_link, {
                    to: "/vocabulary",
                    class: "text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300 text-sm font-medium"
                  }, {
                    default: withCtx(() => _cache[2] || (_cache[2] = [
                      createTextVNode(" Từ vựng ")
                    ])),
                    _: 1,
                    __: [2]
                  }),
                  createVNode(_component_router_link, {
                    to: "/grammar",
                    class: "text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300 text-sm font-medium"
                  }, {
                    default: withCtx(() => _cache[3] || (_cache[3] = [
                      createTextVNode(" Ngữ pháp ")
                    ])),
                    _: 1,
                    __: [3]
                  }),
                  createVNode(_component_router_link, {
                    to: "/practice/flashcard",
                    class: "text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300 text-sm font-medium"
                  }, {
                    default: withCtx(() => _cache[4] || (_cache[4] = [
                      createTextVNode(" Luyện tập ")
                    ])),
                    _: 1,
                    __: [4]
                  }),
                  createVNode(_component_router_link, {
                    to: "/test",
                    class: "text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300 text-sm font-medium"
                  }, {
                    default: withCtx(() => _cache[5] || (_cache[5] = [
                      createTextVNode(" Test Tailwind ")
                    ])),
                    _: 1,
                    __: [5]
                  })
                ])
              ])
            ])
          ])
        ])
      ]);
    };
  }
});

const router = createRouter({
  history: createWebHashHistory("/web-english/"),
  routes: [
    {
      path: "/",
      redirect: "/dashboard"
    },
    {
      path: "/dashboard",
      name: "dashboard",
      component: _sfc_main$1s
    },
    {
      path: "/vocabulary",
      name: "vocabulary-list",
      component: _sfc_main$1r
    },
    {
      path: "/vocabulary/questions",
      name: "vocabulary-questions",
      component: _sfc_main$1q
    },
    {
      path: "/vocabulary/examples",
      name: "vocabulary-examples",
      component: VocabularyExamplesView
    },
    {
      path: "/vocabulary/generator",
      name: "vocabulary-generator",
      component: AutoGeneratorView
    },
    {
      path: "/grammar",
      name: "grammar-list",
      component: GrammarListView
    },
    {
      path: "/grammar/:id",
      name: "grammar-detail",
      component: GrammarDetailView
    },
    {
      path: "/grammar/:id/practice",
      name: "grammar-practice",
      component: _sfc_main$1l
    },
    {
      path: "/practice/flashcard",
      name: "practice-flashcard",
      component: FlashcardView
    },
    {
      path: "/practice/quiz",
      name: "practice-quiz",
      component: _sfc_main$1j
    },
    {
      path: "/test",
      name: "tailwind-test",
      component: _sfc_main$1i
    },
    {
      path: "/:pathMatch(.*)*",
      name: "NotFound",
      component: _sfc_main$1h
    }
  ]
});

const common$2 = {"easy":"Easy","difficult":"Difficult","reviewed":"Reviewed","correct":"Correct","incorrect":"Incorrect","apply":"Apply","back":"Back","restart":"Practice Again","vocabulary":"Vocabulary","grammar":"Grammar","practice":"Practice","dashboard":"Dashboard","save":"Save","saving":"Saving...","update":"Update","delete":"Delete","edit":"Edit","add":"Add","search":"Search","all":"All","title":"Title","previous":"Previous","next":"Next","minutes":"minutes","finish":"Finish","close":"Close","confirm":"Confirm","cancel":"Cancel","reset":"Reset","resetToDefault":"Reset to Default","actions":"Actions","backToTop":"Back to Top","backToTopTooltip":"Back to Top ({percent}%)","backspace":"Backspace","clear":"Clear","space":"Space","select":"Select"};
const autoGenerator$2 = {"title":"Auto Generator","description":"Generate vocabulary words automatically from text, topics, or AI suggestions","methods":{"textAnalysis":"Text Analysis","textAnalysisDesc":"Extract vocabulary from articles, books, or any text content","topicBased":"Topic-based","topicBasedDesc":"Generate words based on specific topics or categories","aiSuggestions":"AI Suggestions","aiSuggestionsDesc":"Get intelligent word suggestions based on your learning level"},"forms":{"textAnalysis":{"title":"Analyze Text Content","inputLabel":"Paste your text content here:","placeholder":"Paste article, book excerpt, or any English text..."},"topicBased":{"title":"Generate by Topic","selectTopic":"Select Topic:","chooseTopic":"Choose a topic..."},"aiSuggestions":{"title":"AI-Powered Generation","preferences":"Learning Preferences:","preferencesPlaceholder":"Describe what type of words you want to learn (e.g., academic words, daily conversation, business terms)...","focusArea":"Focus Area"},"common":{"difficultyLevel":"Difficulty Level","maxWords":"Maximum Words"}},"levels":{"beginner":"Beginner","intermediate":"Intermediate","advanced":"Advanced","mixed":"Mixed Levels"},"topics":{"business":"Business & Finance","technology":"Technology","travel":"Travel & Tourism","health":"Health & Medicine","education":"Education","environment":"Environment","food":"Food & Cooking","sports":"Sports & Fitness"},"focusAreas":{"vocabulary":"General Vocabulary","academic":"Academic Words","conversation":"Conversational","professional":"Professional"},"generate":"Generate Vocabulary","generating":"Generating...","saveAll":"Save All","saveSuccess":"Successfully saved {count} words to your vocabulary list","saveError":"Failed to save vocabulary words","preview":{"title":"Generated Vocabulary"}};
const vocabulary$2 = /* #__PURE__ */ JSON.parse("{\"title\":\"Vocabulary\",\"description\":\"Manage and learn English vocabulary\",\"topics\":{\"uncategorized\":\"Uncategorized\",\"technology\":\"Technology\",\"business\":\"Business\",\"travel\":\"Travel\",\"food\":\"Food\",\"health\":\"Health\",\"education\":\"Education\",\"sports\":\"Sports\",\"entertainment\":\"Entertainment\",\"science\":\"Science\",\"art\":\"Art\",\"music\":\"Music\",\"literature\":\"Literature\",\"politics\":\"Politics\",\"environment\":\"Environment\",\"fashion\":\"Fashion\",\"finance\":\"Finance\"},\"submenu\":{\"manageWords\":\"Manage Words\",\"manageQuestions\":\"Manage Questions\",\"manageExamples\":\"Manage Examples\",\"autoGenerator\":\"Auto Generator\"},\"header\":{\"title\":\"Vocabulary\",\"accordionTitle\":\"Vocabulary Manager\",\"accordionDescription\":\"Add and manage your vocabulary words\"},\"filters\":{\"accordionTitle\":\"Search & Filter\",\"accordionDescription\":\"Search and filter vocabulary words\"},\"grouping\":{\"accordionTitle\":\"Group by Date Settings\",\"accordionDescription\":\"Configure how vocabulary is grouped and displayed\",\"title\":\"Group by Date\",\"description\":\"Group vocabulary words by creation date\",\"hoverToExpand\":\"Hover to Expand\",\"hoverDescription\":\"Open categories on hover when enabled\"},\"tools\":{\"accordionTitle\":\"Tools & Settings\",\"accordionDescription\":\"Voice settings, topic manager, and save & sync options\"},\"addNew\":\"Add New Word\",\"addWord\":\"Add Word\",\"addVocabulary\":\"Add New Vocabulary\",\"editVocabulary\":\"Edit Vocabulary\",\"saveVocabulary\":\"Save Vocabulary\",\"deleteVocabulary\":\"Delete Vocabulary\",\"vocabularyList\":\"Vocabulary List\",\"word\":\"Word\",\"pronunciation\":{\"label\":\"Pronunciation\",\"ipaPickerTitle\":\"IPA Picker\",\"previewPlaceholder\":\"Start building IPA...\",\"wrap\":\"Wrap with slashes\",\"vowels\":\"Vowels\",\"diphthongs\":\"Diphthongs\",\"consonants\":\"Consonants\",\"marks\":\"Marks\",\"openIpaPicker\":\"Open IPA Picker\"},\"meaning\":\"Meaning\",\"category\":\"Category\",\"level\":\"Level\",\"wordType\":\"Word Type\",\"note\":\"Note\",\"favorite\":\"Favorite\",\"isFavorite\":\"Mark as favorite vocabulary\",\"showFavoritesOnly\":\"Show favorites only\",\"searchPlaceholder\":\"Search vocabulary...\",\"wordPlaceholder\":\"Enter word...\",\"meaningPlaceholder\":\"Enter word meaning...\",\"example\":\"Example\",\"examplePlaceholder\":\"Enter example sentence...\",\"synonyms\":\"Synonyms\",\"antonyms\":\"Antonyms\",\"separateByComma\":\"Separate by comma\",\"notePlaceholder\":\"Additional notes about this word...\",\"selectCategory\":\"Select category\",\"selectLevel\":\"Select level\",\"selectWordType\":\"Select word type\",\"confirmDelete\":\"Are you sure you want to delete \\\"{word}\\\"?\",\"confirmDeleteTitle\":\"Confirm Delete\",\"confirmDeleteMessage\":\"Are you sure you want to delete this vocabulary? This action cannot be undone.\",\"updateInfo\":\"Update vocabulary information\",\"vocabInfo\":\"Vocabulary Information\",\"updateSuccess\":\"Vocabulary has been updated successfully.\",\"addSuccess\":\"Vocabulary added successfully!\",\"deleteSuccess\":\"Deleted \\\"{word}\\\" successfully.\",\"deleteAll\":{\"title\":\"Delete All Vocabularies\",\"description\":\"This will permanently delete all vocabulary words from your collection. This action cannot be undone.\",\"button\":\"Delete All Vocabularies\",\"confirmTitle\":\"Delete All Vocabularies\",\"confirmMessage\":\"Are you sure you want to delete all vocabulary words? This action cannot be undone and will permanently remove all your saved words.\",\"warningCount\":\"You are about to delete {count} vocabulary words.\",\"confirm\":\"Delete All\",\"success\":\"All vocabulary words have been deleted successfully\",\"error\":\"Failed to delete all vocabularies. Please try again.\",\"clearLocalStore\":\"Clear Local Store\",\"clearLocalStoreTitle\":\"Clear Local Store Data\",\"clearLocalStoreMessage\":\"This will clear all data stored in your browser's local storage, including vocabulary words, practice sessions, and user preferences. This action cannot be undone.\",\"clearLocalStoreWarning\":\"Warning: This will remove all locally stored data and reset the application to its initial state.\",\"clearLocalStoreConfirm\":\"Clear All Data\",\"clearLocalStoreSuccess\":\"All local store data has been cleared successfully\",\"clearLocalStoreError\":\"Failed to clear local store data. Please try again.\",\"localStoreClearedInfo\":\"Application has been reset to initial state. All local preferences have been cleared.\",\"pageReloadNotice\":\"Note: Page will automatically reload after clearing to ensure complete reset.\"},\"words\":\"words\",\"createdAt\":\"Created at\",\"updatedAt\":\"Updated at\",\"notes\":{\"title\":\"Vocabulary Notes\",\"description\":\"Manage notes for vocabulary words learned today\",\"manageNotes\":\"Manage Notes\",\"noteLabel\":\"Notes for vocabulary\",\"placeholder\":\"Write your notes about this vocabulary learning session...\",\"wordsLearned\":\"Words in this group\",\"noWordsLearned\":\"No vocabulary words in this group\",\"saveSuccess\":\"Notes saved successfully!\",\"autoSaveNotice\":\"Auto-save enabled. Your notes will be included in the next backup.\",\"today\":\"Today\",\"yesterday\":\"Yesterday\"},\"lazyLoading\":{\"loading\":\"Loading...\",\"componentVisible\":\"Component is now visible\",\"componentHidden\":\"Component is hidden\"},\"accordion\":{\"expand\":\"Expand group\",\"editTopic\":\"Edit Topic\",\"saveTopic\":\"Save Topic\",\"cancelTopic\":\"Cancel\",\"topicPlaceholder\":\"Enter topic name...\"},\"progress\":{\"dailyTarget\":\"Daily Target: {target} words\",\"wordsLearned\":\"Words learned: {count}\",\"percentage\":\"{percent}% complete\",\"completed\":\"Completed!\",\"noProgress\":\"No practice yet\",\"tooltip\":\"Daily learning progress: {learned}/{target} words ({percent}%)\"},\"sameTopicDatesTitle\":\"Dates with same topic\",\"sameTopicDatesEmpty\":\"No other dates found for this topic\",\"sameTopicDatesAria\":\"Show dates with same topic\",\"notFound\":\"Vocabulary not found!\",\"updateError\":\"An error occurred while updating vocabulary. Please try again.\",\"deleteError\":\"An error occurred while deleting vocabulary. Please try again.\",\"showingResults\":\"Showing {start} to {end} of {total} results\",\"showingDateGroups\":\"Showing {start} to {end} of {total} date groups\",\"showingCategoryItems\":\"Showing {start} to {end} of {total} items\",\"categories\":{\"technology\":\"Technology\",\"business\":\"Business\",\"travel\":\"Travel\",\"food\":\"Food\",\"health\":\"Health\",\"education\":\"Education\",\"sports\":\"Sports\",\"entertainment\":\"Entertainment\",\"science\":\"Science\",\"art\":\"Art\",\"music\":\"Music\",\"literature\":\"Literature\",\"politics\":\"Politics\",\"environment\":\"Environment\",\"fashion\":\"Fashion\",\"finance\":\"Finance\"},\"levels\":{\"beginner\":\"Beginner\",\"intermediate\":\"Intermediate\",\"advanced\":\"Advanced\"},\"wordTypes\":{\"noun\":\"Noun\",\"verb\":\"Verb\",\"adjective\":\"Adjective\",\"adverb\":\"Adverb\",\"preposition\":\"Preposition\",\"conjunction\":\"Conjunction\",\"interjection\":\"Interjection\"},\"questions\":{\"title\":\"Question Manager\",\"description\":\"Create and manage questions based on your vocabulary words\",\"addQuestion\":\"Add New Question\",\"editQuestion\":\"Edit Question\",\"selectVocabulary\":\"Select Vocabulary\",\"questionText\":\"Question Text\",\"questionType\":\"Question Type\",\"multipleChoice\":\"Multiple Choice\",\"fillBlank\":\"Fill in the Blank\",\"trueFalse\":\"True/False\",\"shortAnswer\":\"Short Answer\",\"options\":\"Options\",\"addOption\":\"Add Option\",\"removeOption\":\"Remove Option\",\"correctAnswer\":\"Correct Answer\",\"difficulty\":\"Difficulty\",\"easy\":\"Easy\",\"medium\":\"Medium\",\"hard\":\"Hard\",\"explanation\":\"Explanation\",\"optional\":\"(Optional)\",\"searchQuestions\":\"Search questions...\",\"filterByVocabulary\":\"Filter by vocabulary\",\"filterByType\":\"Filter by type\",\"allVocabulary\":\"All Vocabulary\",\"allTypes\":\"All Types\",\"createdAt\":\"Created At\",\"noQuestions\":\"No questions found\",\"deleteConfirm\":\"Are you sure you want to delete this question?\",\"true\":\"True\",\"false\":\"False\"},\"examples\":{\"title\":\"Example Manager\",\"description\":\"Create and manage examples based on your vocabulary words\",\"groupByTopic\":\"Group by Topic\",\"addNew\":\"Add New Example\",\"addExample\":\"Add Example\",\"editExample\":\"Edit Example\",\"selectVocabulary\":\"Select Vocabulary\",\"exampleTitle\":\"Example Title\",\"exampleContent\":\"Example Content\",\"translation\":\"Translation\",\"context\":\"Context\",\"exampleType\":\"Example Type\",\"types\":{\"sentence\":\"Sentence\",\"dialogue\":\"Dialogue\",\"phrase\":\"Phrase\",\"context\":\"Context\"},\"difficulty\":{\"medium\":\"Medium\"},\"tags\":\"Tags\",\"addTag\":\"Add tag and press Enter\",\"searchVocabulary\":\"Search vocabulary words...\",\"searchExamples\":\"Search examples...\",\"filterByVocabulary\":\"Filter by vocabulary\",\"filterByType\":\"Filter by type\",\"allVocabulary\":\"All Vocabulary\",\"allTypes\":\"All Types\",\"createdAt\":\"Created At\",\"noVocabulary\":\"No vocabulary words found\",\"noVocabularyDescription\":\"Add some vocabulary words first to create examples for them.\",\"noExamplesForWord\":\"No examples yet\",\"noExamples\":\"No examples found\",\"examples\":\"examples\",\"confirmDelete\":\"Are you sure you want to delete this example?\",\"deleteConfirm\":\"Are you sure you want to delete this example?\",\"playPronunciation\":\"Play pronunciation\",\"playExample\":\"Play example\",\"showExamples\":\"Show examples\",\"hideExamples\":\"Hide examples\",\"showingExamples\":\"Showing {start} to {end} of {total} examples\",\"deleteSuccess\":\"Example deleted successfully\",\"showingVocabulary\":\"Showing {start} to {end} of {total} vocabulary words\",\"showingTopics\":\"Showing {start} to {end} of {total} topics\"},\"image\":{\"title\":\"Image\",\"upload\":\"Upload\",\"url\":\"URL\",\"clickToUpload\":\"Click to upload\",\"orDragDrop\":\" or drag and drop here\",\"supportedFormats\":\"PNG, JPG, GIF, WebP up to 5MB\",\"urlPlaceholder\":\"Paste image URL from the internet...\",\"loadFromUrl\":\"Load from URL\",\"loading\":\"Loading...\",\"preview\":\"Image preview\",\"change\":\"Change\",\"changeUrl\":\"Change URL\",\"remove\":\"Remove\",\"fromUrl\":\"From URL\",\"processing\":\"Processing...\",\"errors\":{\"unsupportedFormat\":\"Unsupported file format. Please choose PNG, JPG, GIF or WebP.\",\"fileTooLarge\":\"File too large. Please choose a file under 5MB.\",\"processingFailed\":\"Unable to process image. Please try again.\",\"emptyUrl\":\"Please enter an image URL.\",\"invalidUrl\":\"Invalid URL or not an image.\",\"urlLoadFailed\":\"Unable to load image from URL. Please check the URL again.\",\"corsWarning\":\"Image accepted but may not display due to the original website's security settings.\"}},\"imageInfo\":{\"title\":\"Missing images\",\"none\":\"All vocabulary have images\",\"date\":\"Date\",\"category\":\"Category\",\"missingCount\":\"{count} without image\",\"aria\":\"Show info about missing images\"},\"save\":{\"title\":\"Save & Sync\",\"subtitle\":\"Manage your vocabulary data storage\",\"mode\":\"Save Mode:\",\"auto\":\"Auto\",\"manual\":\"Manual\",\"saveNow\":\"Save Now\",\"chooseAutoFile\":\"Choose Auto-save File\",\"setup\":\"Setup\",\"changeAutoFile\":\"Change Auto-save File\",\"change\":\"Change\",\"importFile\":\"Import File\",\"importFromComputer\":\"Import from Computer\",\"importExport\":\"Import & Export\",\"importFromDrive\":\"Import from Google Drive\",\"selectFromDrive\":\"Select from Google Drive\",\"signInRequiredForImport\":\"Sign in to Google Drive to import files\",\"noFilesFound\":\"No JSON files found in Google Drive\",\"importShort\":\"Import\",\"lastSave\":\"Last saved: {time}\",\"notSaved\":\"Not saved\",\"autoSaveFileSetup\":\"Auto-save file setup successfully!\",\"autoSaveRetry\":\"Click here to select a new auto-save file\",\"storageType\":\"Storage Type:\",\"autoSaveConfiguration\":\"Auto Save Configuration\",\"localFile\":\"Local File\",\"googleDrive\":\"Google Drive\",\"googleSignIn\":\"Sign In\",\"googleSignOut\":\"Sign Out\",\"googleSync\":\"Sync\",\"googleDriveSetup\":\"Google Drive setup successful\",\"storageInformation\":\"Storage Information\",\"type\":\"Type\",\"googleSignInSuccess\":\"Successfully signed in to Google\",\"googleSignOutSuccess\":\"Successfully signed out from Google\",\"syncFromDriveSuccess\":\"Successfully synced from Google Drive\",\"googleDriveRetry\":\"Google Drive save failed. Check connection.\",\"account\":\"Account\",\"status\":{\"title\":\"Save Status\",\"saving\":\"Saving...\",\"autoSaving\":\"Auto-saving...\",\"autoWithFile\":\"Auto (file saved)\",\"autoLocalStorage\":\"Auto (localStorage)\",\"autoFile\":\"Auto (file)\",\"autoNoFile\":\"Auto (no file selected)\",\"autoGoogleDrive\":\"Auto saved to Google Drive\",\"googleDriveReady\":\"Google Drive ready\",\"googleDriveSignIn\":\"Sign in to Google Drive\",\"fileSaved\":\"File saved\",\"error\":\"Save error\"},\"errors\":{\"browserNotSupported\":\"Browser doesn't support this feature. Please use Chrome or Edge.\",\"fileSelectError\":\"Error selecting file: {error}\",\"invalidFile\":\"Please select a valid JSON file!\",\"invalidFormat\":\"Invalid file format\",\"autoSaveFileFailed\":\"Auto-save to file failed. Please select a new file.\",\"permissionDenied\":\"Permission to write to file denied. Please select a new file.\",\"googleSignInFailed\":\"Google sign-in failed\",\"googleSignOutFailed\":\"Google sign-out failed\",\"googleDriveFailed\":\"Google Drive save failed\",\"googleDriveSetupFailed\":\"Google Drive setup failed\",\"notSignedIn\":\"Not signed in to Google\",\"syncFailed\":\"Sync failed\"},\"import\":{\"confirmMessage\":\"Do you want to import {count} vocabulary from file \\\"{filename}\\\"?\\n\\nCurrent data will be replaced!\",\"confirmGoogleDriveMessage\":\"Do you want to import {count} vocabulary from Google Drive file \\\"{filename}\\\"?\\n\\nCurrent data will be replaced!\",\"successMessage\":\"Successfully imported {count} vocabulary!\",\"googleDriveSuccessMessage\":\"Successfully imported {count} vocabulary from Google Drive!\"}},\"validation\":{\"wordRequired\":\"Word is required\",\"wordTooShort\":\"Word must be at least 1 character\",\"wordTooLong\":\"Word must be less than 100 characters\",\"meaningRequired\":\"Meaning is required\",\"meaningTooShort\":\"Meaning must be at least 1 character\",\"meaningTooLong\":\"Meaning must be less than 500 characters\",\"partOfSpeechRequired\":\"Part of speech is required\",\"categoryRequired\":\"Category is required\",\"levelRequired\":\"Level is required\",\"exampleTooLong\":\"Example must be less than 500 characters\",\"notesTooLong\":\"Notes must be less than 500 characters\",\"pronunciationTooLong\":\"Pronunciation must be less than 100 characters\",\"synonymsInvalid\":\"Please enter valid synonyms separated by commas\",\"antonymsInvalid\":\"Please enter valid antonyms separated by commas\",\"saveError\":\"Error saving vocabulary. Please try again.\",\"saveSuccess\":\"Vocabulary saved successfully!\",\"updateSuccess\":\"Vocabulary updated successfully!\"},\"details\":{\"title\":\"Vocabulary Details\",\"playAudio\":\"Play vocabulary audio\",\"playExample\":\"Play example audio\",\"addFavorite\":\"Add to favorites\",\"removeFavorite\":\"Remove from favorites\"},\"moveMode\":{\"title\":\"Move Mode\",\"active\":\"Active - Click arrows to move words\",\"inactive\":\"Inactive\"},\"moveVocabulary\":\"Move Vocabulary\",\"movingWord\":\"Moving word\",\"movingCategory\":\"Moving all words in category\",\"wordsWillBeMoved\":\"words will be moved to the selected date\",\"selectTargetDate\":\"Select target date\",\"moveToDateGroup\":\"Move to another date group\",\"moveToDate\":\"Move to Date\",\"moveWord\":\"Move Word\",\"moveAll\":\"Move All\",\"moveSuccess\":\"Successfully moved {count} word(s) to {date}\",\"moveError\":\"Failed to move vocabulary\",\"moveAutoSaveNotice\":\"Word moved and will be included in auto-save\",\"batchMoveSuccess\":\"Successfully moved {count} words to {date}\",\"batchMoveError\":\"Failed to move category\",\"filterBySameTopic\":\"Filter by same topic\",\"showingDatesWithSameTopic\":\"Showing only dates with the same topic\",\"selectTargetDateGroup\":\"Select target date group\",\"selectDate\":\"Select Date\",\"noMatchingDates\":\"No dates found matching this topic. Try disabling the filter.\",\"topicManager\":{\"title\":\"Topic Manager\",\"addNewTopic\":\"Add New Topic\",\"editTopic\":\"Edit Topic\",\"topicKey\":\"Topic Key\",\"topicKeyPlaceholder\":\"Example: cooking, programming...\",\"keyDescription\":\"This key will be used in the system. Use only lowercase letters, numbers and underscores.\",\"vietnameseName\":\"Vietnamese Name\",\"vietnameseNamePlaceholder\":\"Ví dụ: Nấu ăn, Lập trình...\",\"englishName\":\"English Name\",\"englishNamePlaceholder\":\"Example: Cooking, Programming...\",\"existingTopics\":\"Existing Topics\",\"noCustomTopics\":\"No custom topics yet.\",\"cannotDeleteInUse\":\"Cannot delete topic in use\",\"confirmDeleteTitle\":\"Confirm Delete Topic\",\"confirmDeleteMessage\":\"Are you sure you want to delete topic \\\"{topic}\\\"?\",\"duplicateKey\":\"Topic key already exists!\",\"builtInTopics\":\"Built-in Topics\",\"builtInTopicsDescription\":\"The system has 16 built-in topics like Technology, Business, Travel... You can add custom topics here.\",\"builtIn\":\"Built-in\",\"manageTopics\":\"Manage Topics\",\"searchPlaceholder\":\"Search topics by name...\",\"pageOf\":\"Page {current} of {total}\",\"koreanName\":\"Korean Name\",\"koreanNamePlaceholder\":\"Example: 요리, 프로그래밍...\"}}");
const korean$2 = {"inputHelper":{"title":"Korean Input Helper","preview":"Preview","placeholder":"Type or click characters below...","consonants":"Consonants (자음)","vowels":"Vowels (모음)","commonSyllables":"Common Syllables","openHelper":"Open Korean Input Helper"},"pronunciationHelper":{"title":"Korean Pronunciation Helper","preview":"Pronunciation Preview","placeholder":"Click Korean sounds below...","consonantSounds":"Consonant Sounds (자음 소리)","vowelSounds":"Vowel Sounds (모음 소리)","commonPatterns":"Common Patterns","specialChars":"Special Characters","openHelper":"Open Korean Pronunciation Helper"},"wordPlaceholder":"Enter Korean word or click + for help","pronunciationPlaceholder":"an-nyeong-ha-se-yo"};
const flashcard$2 = {"header":{"history":"History","settings":"Settings","progress":"Progress","description":"Practice vocabulary with flashcards","exit":"Exit","selectMode":"Select mode"},"empty":{"title":"No flashcards","description":"Add vocabulary to start practicing.","action":"Add Vocabulary"},"settings":{"title":"Flashcard Settings","category":"Category","level":"Level","all":"All","beginner":"Beginner","intermediate":"Intermediate","advanced":"Advanced","autoFlip":"Auto flip card after 3 seconds","shuffle":"Shuffle order","shuffle_disabled_during_practice":"Shuffle is disabled during practice","disabledDuringPractice":"Settings are disabled during practice"},"history":{"title":"Practice History","empty":{"title":"No history","description":"Start practicing to see your history."},"totalCards":"Total cards","correct":"Correct","incorrect":"Incorrect","duration":"Duration","categories":"Categories","accuracy":"Accuracy","result":"Result","pass":"Pass","fail":"Fail","viewDetails":"View details","noDetails":"No details available","deleteSession":"Delete session","confirmDelete":{"title":"Delete Session","message":"Are you sure you want to delete this practice session? This action cannot be undone.","confirm":"Delete","cancel":"Cancel","success":"Session deleted successfully"},"details":{"title":"Session Details","noData":"No details available for this session","yourAnswer":"Your answer","noAnswer":"No answer","correctAnswer":"Correct answer"}},"completion":{"title":"Completed!","description":"You have completed {count} flashcards.","correct":"Correct","incorrect":"Incorrect","accuracy":"Accuracy","result":"Result"},"modes":{"flashcard":"Flashcard","quiz":"Quiz","typing":"Typing","listening":"Listening","image":"Image","pictionary":"Pictionary","flipTile":"Flip Tile","bubbleShooter":"Bubble Shooter","snakeGame":"Snake Hunt","pronunciation":"Pronunciation","change_disabled_during_practice":"Mode change is disabled during practice","selectMode":"Select mode","mode":"Mode"},"image":{"imageAlt":"Vocabulary image","imageError":"Cannot load image","noImage":"No image available","placeholder":"Type the word...","instruction":"Look at the image and type the corresponding word:","correctAnswer":"Correct answer","unavailable":"Image mode is unavailable for the selected date","quizToggle":"Multiple Choice"},"pictionary":{"imageAlt":"Pictionary image","instruction":"Click the boxes and type to fill in the missing letters. Press Enter to check.","instructionDefinition":"Look at the definition and type the word. Press Enter to check.","dragInstructionDefinition":"Look at the definition and drag letters to form the word.","definitionToggle":"Definition Mode","definitionHint":"Definition","noDefinition":"No definition available","unavailable":"Pictionary mode is unavailable for the selected date"},"flipTile":{"tilesFlipped":"Tiles flipped","imageAlt":"Flip tile image","noDefinition":"No definition available","noContent":"No content available for this card.","answerPlaceholder":"Type your answer...","check":"Check","instruction":"Click on tiles to reveal letters (max {maxFlips}), then type your answer and press Enter.","unavailable":"Flip Tile mode is unavailable for the selected date","hintsToggle":"Use Definition Hints"},"scrambleWords":{"toggle":"Scramble Words","instruction":"Arrange the letters to form the word","correct":"Correct!","incorrect":"Try again!","clear":"Clear","check":"Check","backspace":"Backspace"},"card":{"flip_to_meaning":"Click to see meaning","flip_back":"Click to flip back"},"bubbleShooter":{"title":"Bubble Shooter","instruction":"Shoot bubbles to match 4 or more words!","score":"Score","currentWord":"Current Word","gameComplete":"Game Complete!","finalScore":"Final Score: {score}","wordsMatched":"Words Matched: {count}","playAgain":"Play Again"},"snakeGame":{"title":"Snake Hunt","instruction":"Guide the snake to eat the foods with matching first letters!","score":"Score","currentWord":"Current Word","gameComplete":"Game Complete!","finalScore":"Final Score: {score}","wordsEaten":"Words Eaten: {count}","playAgain":"Play Again","gameOver":"Game Over!"},"snake":{"doubleBaitToggle":"Double Bait Mode"},"listening":{"instruction":"Listen and type the word you hear:","placeholder":"Type the word you hear...","correct":"✓ Correct!","incorrect":"✗ Correct answer:","quizToggle":"Multiple Choice"},"typing":{"quizToggle":"Multiple Choice"},"dateFilter":{"enable":"Filter by creation date","allDates":"All dates","info":"Showing {count} vocabulary from {date}"},"pronunciation":{"microphoneError":"Microphone error! Please check microphone access permissions.","yourRecording":"Your Recording","tryAgain":"Try Again!","wordsCrushToggle":"Hidden Words Mode","wordsCrush":{"title":"Words Crush: Hidden Words","instruction":"Fill in the missing letters to complete the word","playAudio":"Play Audio","checkAnswer":"Check Answer","hint":"Hint","reset":"Reset","correct":"🎉 Correct!","tryAgain":"Try Again!","correctWord":"Correct word","meaning":"Meaning"}}};
const grammar$2 = {"title":"Grammar","description":"Learn and practice English grammar","addLesson":"Add Lesson","addNewLesson":"Add New Lesson","editLesson":"Edit Lesson","deleteLesson":"Delete Lesson","confirmDelete":"Are you sure you want to delete the lesson \"{title}\"?","search":"Search grammar lessons...","level":"Level","category":"Category","duration":"minutes","durationLabel":"Duration (minutes)","progress":"Progress","continue":"Continue","start":"Start","emptyState":{"title":"No lessons found","description":"Try changing your filters or add a new lesson."},"levels":{"beginner":"Beginner","intermediate":"Intermediate","advanced":"Advanced"},"manager":{"title":"Grammar Manager","manageGrammar":"Manage Grammar","addNew":"Add New Grammar Rule","editGrammar":"Edit Grammar Rule","existingRules":"Grammar Rules","category":"Category","level":"Level","formula":"Grammar Formula","description":"Description","examples":"Examples","titlePlaceholder":"e.g., Present Perfect Tense","formulaPlaceholder":"e.g., Subject + have/has + past participle","descriptionPlaceholder":"Explain how and when to use this grammar rule...","examplePlaceholder":"e.g., I have studied English for 5 years.","selectCategory":"Select Category","selectLevel":"Select Level","addExample":"Add Example","removeExample":"Remove Example","noRulesYet":"No grammar rules added yet","createdAt":"Created","lastModified":"Last Modified","confirmDelete":"Are you sure you want to delete this grammar rule?","ruleAdded":"Grammar rule added successfully","ruleUpdated":"Grammar rule updated successfully","ruleDeleted":"Grammar rule deleted successfully","globalMode":"Global","perDateMode":"Per Date","perDateDescription":"Managing grammar rules for date: {date}","noDateSelected":"No date selected for per-date mode","showVocabulary":"Show Vocabulary","vocabularyForDate":"Vocabulary for {date}","noVocabularyFound":"No vocabulary found for this date"},"categories":{"tenses":"Tenses","conditionals":"Conditionals","passive":"Passive Voice","modals":"Modal Verbs","articles":"Articles","prepositions":"Prepositions","conjunctions":"Conjunctions","other":"Other"},"selectCategory":"Select category","selectLevel":"Select level","titlePlaceholder":"Enter lesson title...","descriptionPlaceholder":"Enter a brief description of the lesson...","lessonContent":"Lesson Content","theory":"Theory","theoryPlaceholder":"Enter the theory content of the lesson...","structure":"Structure","structurePlaceholder":"Enter the grammar structure...","examples":"Examples","examplePlaceholder":"Example {index}","translationPlaceholder":"Translation {index}","addExample":"Add Example","usageRules":"Usage Rules","ruleTitlePlaceholder":"Rule title {index}","ruleDescriptionPlaceholder":"Rule description {index}","addRule":"Add Rule","commonMistakes":"Common Mistakes","wrongSentencePlaceholder":"Wrong sentence {index}","correctSentencePlaceholder":"Correct sentence {index}","explanationPlaceholder":"Explanation {index}","addMistake":"Add Common Mistake","markdownSupported":"Basic Markdown formatting is supported.","practice":{"title":"Grammar Practice","subtitle":"Choose an exercise type to practice","chooseExercise":"Choose Exercise Type","chooseDescription":"Select an exercise type to start practicing","score":"Score","question":"Question","checkAnswer":"Check Answer","next":"Next","finish":"Finish","explanation":"Explanation","reading":{"passage":"Passage","readingTime":"Reading Time","questions":"Questions","showHighlights":"Show Highlights"},"exercises":{"checkAnswer":"Check Answer","next":"Next","multiple-choice":{"title":"Multiple Choice","description":"Choose the correct answer from multiple options"},"fill-blank":{"title":"Fill in the Blanks","description":"Complete sentences with the correct words"},"pronunciation":{"title":"Pronunciation","description":"Practice speaking and pronunciation"},"reading":{"title":"Reading Comprehension","description":"Read passages and answer questions","passage":"Passage","listen":"Listen","readingTime":"Reading Time","questions":"Questions","true":"True","false":"False","yourAnswer":"Your Answer","correctAnswer":"Correct Answer","correct":"Correct","incorrect":"Incorrect","accuracy":"Accuracy","showHighlights":"Show Highlights","hideHighlights":"Hide Highlights"},"listening":{"title":"Listening","description":"Listen to audio and answer questions","instruction":"Listen to the audio and answer the questions:","speed":"Speed","playsLeft":"Plays Left","loading":"Loading...","questions":"Questions","audioUrl":"Audio URL","audioUrlPlaceholder":"Enter audio file URL or YouTube URL...","maxPlays":"Maximum Plays","allowNotes":"Allow Notes","transcript":"Transcript","transcriptPlaceholder":"Enter audio transcript...","question":"Question","multipleChoice":"Multiple Choice","fillBlank":"Fill in the Blank","ordering":"Ordering","addQuestion":"Add Question","correctAnswerPlaceholder":"Enter correct answer...","notesAllowed":"Notes Allowed","takeNotes":"Take Notes","notesPlaceholder":"Write your notes here...","correct":"Correct","incorrect":"Incorrect","accuracy":"Accuracy","showTranscript":"Show Transcript","correctAnswer":"Correct Answer","audioUrlHint":"Enter direct audio URL or YouTube video URL","youtubeDetected":"YouTube URL detected","youtubeNote":"Audio will be extracted from this YouTube video for listening practice"},"writing":{"title":"Writing","description":"Write essays and get feedback","instruction":"Write a paragraph about the following topic:","essay":"Essay","email":"Email","letter":"Letter","paragraph":"Paragraph","requirements":"Requirements","minWords":"Minimum Words","timeLimit":"Time Limit","yourResponse":"Your Response","words":"words","timeRemaining":"Time Remaining","paragraphPlaceholder":"Enter your paragraph here...","essayPlaceholder":"Write your essay here...","emailPlaceholder":"Write your email here...","letterPlaceholder":"Write your letter here...","tips":"Writing Tips","showTips":"Show Tips","hideTips":"Hide Tips","tip1":"Use varied sentence structures","tip2":"Check grammar and spelling","tip3":"Use connecting words to link ideas","tip4":"Ensure your writing has introduction, body, and conclusion","tip5":"Use vocabulary appropriate to the topic","saveDraft":"Save Draft","clear":"Clear","confirmClear":"Are you sure you want to clear all content?","submit":"Submit","analyzing":"Analyzing...","feedback":"Feedback","overallScore":"Overall Score","grammar":"Grammar","vocabulary":"Vocabulary","coherence":"Coherence","taskResponse":"Task Response","strengths":"Strengths","improvements":"Areas for Improvement","corrections":"Specific Corrections","original":"Original","corrected":"Corrected","explanation":"Explanation"}},"fillBlank":{"instruction":"Fill in the blanks with appropriate words:","clear":"Clear All"},"pronunciation":{"instruction":"Listen and repeat the following sentence:","listen":"Listen","ready":"Ready","recording":"Recording...","recorded":"Recorded","processing":"Processing...","analyze":"Analyze","feedback":"Feedback","tips":"Tips","tryAgain":"Try Again","yourRecording":"Your Recording","microphoneError":"Microphone error! Please check microphone access permissions."},"settings":{"title":"Exercise Settings","difficulty":"Difficulty","autoPlay":"Auto-play Audio","autoplayAudio":"Auto-play Audio","showExplanations":"Show Explanations","timeLimit":"Time Limit (minutes)","questionCount":"Number of Questions","close":"Close","save":"Save Settings","levels":{"easy":"Easy","medium":"Medium","hard":"Hard"}},"exerciseManager":{"title":"Exercise Manager","addNew":"Add New Exercise","existing":"Existing Exercises","exerciseType":"Exercise Type","typePlaceholder":"Enter exercise type...","titlePlaceholder":"Enter exercise title...","description":"Description","descriptionPlaceholder":"Enter exercise description...","difficulty":"Difficulty","duration":"Duration","durationPlaceholder":"e.g. 10-15 minutes","add":"Add Exercise","manageQuestions":"Manage Questions"},"questionManager":{"title":"Question Manager","addNew":"Add New Question","editQuestion":"Edit Question","addQuestion":"Add Question","existingQuestions":"Existing Questions","noQuestions":"No questions yet","addFirstQuestion":"Add your first question","question":"Question","questionPlaceholder":"Enter question...","options":"Options","optionPlaceholder":"Enter option...","correctAnswer":"Correct Answer","explanation":"Explanation","explanationPlaceholder":"Enter explanation...","taskType":"Writing Type","prompt":"Prompt","promptPlaceholder":"Enter writing prompt...","requirements":"Requirements","addRequirement":"Add Requirement","requirementPlaceholder":"Enter requirement...","minWords":"Min Words","timeLimit":"Time Limit (minutes)","selectCorrectAnswer":"Select Correct Answer"},"progress":{"question":"Question","of":"of","score":"Score","timeRemaining":"Time Remaining"},"results":{"title":"Exercise Results","score":"Your Score","correct":"Correct","total":"Total","accuracy":"Accuracy","timeSpent":"Time Spent","tryAgain":"Try Again","backToMenu":"Back to Menu","reviewAnswers":"Review Answers"},"common":{"submit":"Submit","next":"Next","previous":"Previous","finish":"Finish","check":"Check Answer","checkAnswer":"Check Answer","showAnswer":"Show Answer","explanation":"Explanation","hint":"Hint","loading":"Loading...","noAnswer":"No answer provided","correct":"Correct!","incorrect":"Incorrect","skip":"Skip","retry":"Retry"}}};
const categories$2 = {"technology":"Technology","business":"Business","travel":"Travel","food":"Food","health":"Health","education":"Education","sports":"Sports","entertainment":"Entertainment","science":"Science","art":"Art","music":"Music","literature":"Literature","politics":"Politics","environment":"Environment"};
const dashboard$2 = {"title":"Dashboard","welcomeMessage":"Welcome to your English learning journey!","todaysProgress":"Today's Progress","currentLevel":"Current Level","stats":{"vocabularyLearned":"Vocabulary Learned","grammarLessons":"Grammar Lessons","currentStreak":"Current Streak","totalTime":"Total Time","days":"days","hours":"hours"},"flashcardStats":{"title":"Flashcard Practice","noData":"No practice sessions yet","startPracticing":"Start practicing to see your stats!","sessions":"Sessions","streak":"Streak","days":"days","accuracy":"Accuracy","bestScore":"Best Score","totalTime":"Total Practice Time","cardsStudied":"Cards Studied","favoriteMode":"Favorite Mode","weeklyProgress":"This Week"},"quickActions":"Quick Actions","recentActivity":"Recent Activity","actions":{"addVocabulary":"Add Vocabulary","practiceFlashcard":"Practice Flashcard","takeQuiz":"Take a Quiz","learnGrammar":"Learn Grammar"},"activity":{"added":"Added '{word}' to {category}","updated":"Updated '{word}' in {category}","justNow":"Just now","noActivity":"No recent activity","addFirstVocab":"Add your first vocabulary to get started!"}};
const app$3 = {"title":"English Learning App","titleShort":"English App"};
const time$2 = {"today":"Today","yesterday":"Yesterday","ago":{"justNow":"Just now","minutesAgo":"{minutes} minutes ago","hoursAgo":"{hours} hours ago","daysAgo":"{days} days ago","yesterday":"Yesterday"}};
const practice$2 = {"controls":{"next":"Next","complete":"Complete","difficult":"Difficult","easy":"Easy","exit":"Exit"},"timer":{"startPractice":"Start Practice","timeLimit":"Time limit per question: {seconds} seconds","timeUp":"Time's Up!","timeUpMessage":"You've run out of time for this question. Try again or skip.","tryAgain":"Try Again","skip":"Skip"},"exitWarning":{"title":"Exit Practice Warning","message":"You are currently in a practice session. If you leave now, you will lose your progress and score. Are you sure you want to exit?","continue":"Continue Practice","exit":"Exit Practice"}};
const quiz$2 = {"progress":{"question":"Question"},"setup":{"title":"Quiz Settings","description":"Customize your quiz preferences","type":"Quiz Type","level":"Difficulty Level","questionCount":"Number of Questions","timeLimit":"Time Limit (minutes)","start":"Start Quiz","allLevels":"All Levels","unlimited":"Unlimited"},"types":{"vocabulary":"Vocabulary","grammar":"Grammar","mixed":"Mixed"},"navigation":{"previous":"Previous","next":"Next","finish":"Finish"},"results":{"completed":"Quiz Completed!","yourResults":"Your Results","score":"Score","correct":"Correct","accuracy":"Accuracy","passed":"Passed","failed":"Failed","above":"Above","below":"Below","reviewAnswers":"Review Answers","correctAnswer":"Correct Answer","yourAnswer":"Your Answer","noAnswer":"No Answer","explanation":"Explanation","restartQuiz":"Restart Quiz"}};
const voice$2 = {"selector":{"title":"Voice Selection"},"gender":{"female":"Female","male":"Male"},"types":{"female_sweet":"Sweet Female","female_clear":"Clear Female","female_professional":"Professional Female","male_strong":"Strong Male","male_gentle":"Gentle Male","male_deep":"Deep Male","korean_female":"Korean Female","korean_male":"Korean Male"},"info":{"name":"Voice Name","language":"Language","gender":"Gender"},"test":"Test Voice","testing":"Testing...","testText":"Hello! This is a voice test.","testTextKorean":"안녕하세요! 이것은 음성 테스트입니다.","settings":{"title":"Voice Settings","rate":"Rate","pitch":"Pitch","volume":"Volume"}};
const en = {
  common: common$2,
  autoGenerator: autoGenerator$2,
  vocabulary: vocabulary$2,
  korean: korean$2,
  flashcard: flashcard$2,
  grammar: grammar$2,
  categories: categories$2,
  dashboard: dashboard$2,
  app: app$3,
  time: time$2,
  practice: practice$2,
  quiz: quiz$2,
  voice: voice$2,
};

const common$1 = {"easy":"Dễ","difficult":"Khó","reviewed":"Đã xem","correct":"Đúng","incorrect":"Sai","cancel":"Hủy","back":"Quay lại","restart":"Luyện tập lại","vocabulary":"Từ vựng","grammar":"Ngữ pháp","practice":"Luyện tập","dashboard":"Trang chủ","save":"Lưu","saving":"Đang lưu...","update":"Cập nhật","delete":"Xóa","edit":"Sửa","add":"Thêm","search":"Tìm kiếm","all":"Tất cả","title":"Tiêu đề","previous":"Trước","next":"Tiếp","minutes":"phút","finish":"Hoàn thành","close":"Đóng","confirm":"Xác nhận","reset":"Đặt lại","apply":"Áp dụng","resetToDefault":"Về mặc định","actions":"Thao tác","backToTop":"Lên đầu trang","backToTopTooltip":"Lên đầu trang ({percent}%)","checking":"Đang kiểm tra...","backspace":"Xóa lùi","clear":"Xóa","space":"Dấu cách","select":"Chọn"};
const autoGenerator$1 = {"title":"Tự Động Tạo","description":"Tự động tạo từ vựng từ văn bản, chủ đề hoặc gợi ý AI","methods":{"textAnalysis":"Phân Tích Văn Bản","textAnalysisDesc":"Trích xuất từ vựng từ bài báo, sách hoặc bất kỳ nội dung văn bản nào","topicBased":"Theo Chủ Đề","topicBasedDesc":"Tạo từ vựng dựa trên các chủ đề hoặc danh mục cụ thể","aiSuggestions":"Gợi Ý AI","aiSuggestionsDesc":"Nhận gợi ý từ vựng thông minh dựa trên trình độ học tập của bạn"},"forms":{"textAnalysis":{"title":"Phân Tích Nội Dung Văn Bản","inputLabel":"Dán nội dung văn bản của bạn vào đây:","placeholder":"Dán bài báo, đoạn sách hoặc bất kỳ văn bản tiếng Anh nào..."},"topicBased":{"title":"Tạo Theo Chủ Đề","selectTopic":"Chọn Chủ Đề:","chooseTopic":"Chọn một chủ đề..."},"aiSuggestions":{"title":"Tạo Bằng AI","preferences":"Sở Thích Học Tập:","preferencesPlaceholder":"Mô tả loại từ bạn muốn học (ví dụ: từ học thuật, hội thoại hàng ngày, thuật ngữ kinh doanh)...","focusArea":"Lĩnh Vực Tập Trung"},"common":{"difficultyLevel":"Mức Độ Khó","maxWords":"Số Từ Tối Đa"}},"levels":{"beginner":"Cơ Bản","intermediate":"Trung Cấp","advanced":"Nâng Cao","mixed":"Cấp Độ Hỗn Hợp"},"topics":{"business":"Kinh Doanh & Tài Chính","technology":"Công Nghệ","travel":"Du Lịch & Du Lịch","health":"Sức Khỏe & Y Học","education":"Giáo Dục","environment":"Môi Trường","food":"Thức Ăn & Nấu Ăn","sports":"Thể Thao & Thể Hình"},"focusAreas":{"vocabulary":"Từ Vựng Tổng Quát","academic":"Từ Học Thuật","conversation":"Hội Thoại","professional":"Chuyên Nghiệp"},"generate":"Tạo Từ Vựng","generating":"Đang tạo...","saveAll":"Lưu Tất Cả","saveSuccess":"Đã lưu thành công {count} từ vào danh sách từ vựng của bạn","saveError":"Không thể lưu từ vựng","preview":{"title":"Từ Vựng Đã Tạo"}};
const levels = {"beginner":"Cơ bản","intermediate":"Trung cấp","advanced":"Nâng cao"};
const vocabulary$1 = /* #__PURE__ */ JSON.parse("{\"title\":\"Từ vựng\",\"description\":\"Quản lý và học từ vựng tiếng Anh\",\"topics\":{\"uncategorized\":\"Chưa phân loại\",\"technology\":\"Công nghệ\",\"business\":\"Kinh doanh\",\"travel\":\"Du lịch\",\"food\":\"Ẩm thực\",\"health\":\"Sức khỏe\",\"education\":\"Giáo dục\",\"sports\":\"Thể thao\",\"entertainment\":\"Giải trí\",\"science\":\"Khoa học\",\"art\":\"Nghệ thuật\",\"music\":\"Âm nhạc\",\"literature\":\"Văn học\",\"politics\":\"Chính trị\",\"environment\":\"Môi trường\",\"fashion\":\"Thời trang\",\"finance\":\"Tài chính\"},\"submenu\":{\"manageWords\":\"Quản lý từ vựng\",\"manageQuestions\":\"Quản lý câu hỏi\",\"manageExamples\":\"Quản lý ví dụ\",\"autoGenerator\":\"Tự động tạo\"},\"header\":{\"title\":\"Từ vựng\",\"accordionTitle\":\"Quản lý từ vựng\",\"accordionDescription\":\"Thêm và quản lý từ vựng của bạn\"},\"filters\":{\"accordionTitle\":\"Tìm kiếm & Lọc\",\"accordionDescription\":\"Tìm kiếm và lọc từ vựng\"},\"grouping\":{\"accordionTitle\":\"Cài đặt nhóm theo ngày\",\"accordionDescription\":\"Thiết lập cách hiển thị và nhóm từ vựng\",\"title\":\"Nhóm theo ngày\",\"description\":\"Nhóm từ vựng theo ngày tạo\",\"hoverToExpand\":\"Mở rộng khi hover\",\"hoverDescription\":\"Mở rộng nhóm ngày khi di chuột qua thay vì nhấp chuột\"},\"tools\":{\"accordionTitle\":\"Công cụ & Cài đặt\",\"accordionDescription\":\"Cài đặt giọng đọc, quản lý chủ đề và đồng bộ dữ liệu\"},\"addNew\":\"Thêm từ mới\",\"addWord\":\"Thêm từ\",\"addVocabulary\":\"Thêm từ vựng mới\",\"editVocabulary\":\"Chỉnh sửa từ vựng\",\"saveVocabulary\":\"Lưu từ vựng\",\"deleteVocabulary\":\"Xóa từ vựng\",\"vocabularyList\":\"Danh sách từ vựng\",\"word\":\"Từ vựng\",\"pronunciation\":{\"label\":\"Phát âm\",\"ipaPickerTitle\":\"Bảng ký hiệu IPA\",\"previewPlaceholder\":\"Bắt đầu xây dựng IPA...\",\"wrap\":\"Bọc bằng dấu gạch chéo\",\"vowels\":\"Nguyên âm\",\"diphthongs\":\"Nguyên âm đôi\",\"consonants\":\"Phụ âm\",\"marks\":\"Ký hiệu\",\"openIpaPicker\":\"Mở bảng IPA\"},\"meaning\":\"Nghĩa\",\"category\":\"Chủ đề\",\"level\":\"Mức độ\",\"wordType\":\"Từ loại\",\"note\":\"Ghi chú\",\"favorite\":\"Yêu thích\",\"isFavorite\":\"Đánh dấu là từ vựng yêu thích\",\"showFavoritesOnly\":\"Chỉ hiển thị từ vựng yêu thích\",\"searchPlaceholder\":\"Tìm từ vựng...\",\"wordPlaceholder\":\"Nhập từ vựng...\",\"meaningPlaceholder\":\"Nhập nghĩa của từ...\",\"example\":\"Ví dụ\",\"examplePlaceholder\":\"Nhập câu ví dụ...\",\"synonyms\":\"Từ đồng nghĩa\",\"antonyms\":\"Từ trái nghĩa\",\"separateByComma\":\"Cách nhau bằng dấu phẩy\",\"notePlaceholder\":\"Ghi chú thêm về từ này...\",\"selectCategory\":\"Chọn chủ đề\",\"selectLevel\":\"Chọn mức độ\",\"selectWordType\":\"Chọn từ loại\",\"confirmDelete\":\"Bạn có chắc chắn muốn xóa từ \\\"{word}\\\"?\",\"confirmDeleteTitle\":\"Xác nhận xóa\",\"confirmDeleteMessage\":\"Bạn có chắc chắn muốn xóa từ vựng này? Hành động này không thể hoàn tác.\",\"updateInfo\":\"Cập nhật thông tin từ vựng\",\"vocabInfo\":\"Thông tin từ vựng\",\"updateSuccess\":\"Từ vựng đã được cập nhật thành công.\",\"addSuccess\":\"Thêm từ vựng thành công!\",\"deleteSuccess\":\"Đã xóa \\\"{word}\\\" thành công.\",\"deleteAll\":{\"title\":\"Xóa tất cả từ vựng\",\"description\":\"Thao tác này sẽ xóa vĩnh viễn tất cả từ vựng trong bộ sưu tập của bạn. Hành động này không thể hoàn tác.\",\"button\":\"Xóa tất cả từ vựng\",\"confirmTitle\":\"Xóa tất cả từ vựng\",\"confirmMessage\":\"Bạn có chắc chắn muốn xóa tất cả từ vựng? Hành động này không thể hoàn tác và sẽ xóa vĩnh viễn tất cả từ vựng đã lưu.\",\"warningCount\":\"Bạn sắp xóa {count} từ vựng.\",\"confirm\":\"Xóa tất cả\",\"success\":\"Đã xóa tất cả từ vựng thành công\",\"error\":\"Không thể xóa tất cả từ vựng. Vui lòng thử lại.\",\"clearLocalStore\":\"Xóa dữ liệu local store\",\"clearLocalStoreTitle\":\"Xóa dữ liệu local store\",\"clearLocalStoreMessage\":\"Thao tác này sẽ xóa tất cả dữ liệu được lưu trong local storage của trình duyệt, bao gồm từ vựng, phiên luyện tập và tùy chọn người dùng. Hành động này không thể hoàn tác.\",\"clearLocalStoreWarning\":\"Cảnh báo: Thao tác này sẽ xóa tất cả dữ liệu được lưu cục bộ và đặt lại ứng dụng về trạng thái ban đầu.\",\"clearLocalStoreConfirm\":\"Xóa tất cả dữ liệu\",\"clearLocalStoreSuccess\":\"Đã xóa tất cả dữ liệu local store thành công\",\"clearLocalStoreError\":\"Không thể xóa dữ liệu local store. Vui lòng thử lại.\",\"localStoreClearedInfo\":\"Ứng dụng đã được đặt lại về trạng thái ban đầu. Tất cả tùy chọn cục bộ đã được xóa.\",\"pageReloadNotice\":\"Lưu ý: Trang sẽ tự động tải lại sau khi xóa để đảm bảo reset hoàn toàn.\"},\"topic\":\"Chủ đề\",\"words\":\"từ\",\"createdAt\":\"Tạo lúc\",\"updatedAt\":\"Cập nhật\",\"notes\":{\"title\":\"Ghi chú từ vựng\",\"description\":\"Quản lý ghi chú cho các từ vựng đã học\",\"manageNotes\":\"Quản lý ghi chú\",\"noteLabel\":\"Ghi chú cho từ vựng\",\"placeholder\":\"Viết ghi chú về buổi học từ vựng này của bạn...\",\"wordsLearned\":\"Các từ trong nhóm này\",\"noWordsLearned\":\"Chưa có từ vựng nào trong nhóm này\",\"saveSuccess\":\"Đã lưu ghi chú thành công!\",\"autoSaveNotice\":\"Đã bật lưu tự động. Ghi chú của bạn sẽ được đưa vào bản sao lưu tiếp theo.\",\"today\":\"Hôm nay\",\"yesterday\":\"Hôm qua\",\"grammarCheck\":\"Bật kiểm tra ngữ pháp (tiếng Anh)\",\"preview\":\"Xem trước với gợi ý ngữ pháp\",\"grammarDisclaimer\":\"Kiểm tra ngữ pháp sử dụng LanguageTool (public API) và có thể bị giới hạn tần suất.\",\"grammarError\":\"Kiểm tra ngữ pháp thất bại. Vui lòng thử lại sau.\",\"lt\":{\"spelling\":\"Có thể có lỗi chính tả.\",\"grammar\":\"Lỗi ngữ pháp\",\"punctuation\":\"Lỗi chấm câu\",\"style\":\"Lỗi phong cách\",\"typographical\":\"Lỗi đánh máy\",\"suggestion\":\"Gợi ý\"}},\"lazyLoading\":{\"loading\":\"Đang tải...\",\"componentVisible\":\"Thành phần hiện đã hiển thị\",\"componentHidden\":\"Thành phần đã ẩn\"},\"accordion\":{\"expand\":\"Mở rộng nhóm\",\"collapse\":\"Thu gọn nhóm\",\"addTopic\":\"Thêm chủ đề\",\"editTopic\":\"Sửa chủ đề\",\"saveTopic\":\"Lưu chủ đề\",\"cancelTopic\":\"Hủy\",\"topicPlaceholder\":\"Nhập tên chủ đề...\"},\"progress\":{\"dailyTarget\":\"Mục tiêu hàng ngày: {target} từ\",\"wordsLearned\":\"Từ đã học: {count}\",\"percentage\":\"Hoàn thành {percent}%\",\"completed\":\"Đã hoàn thành!\",\"noProgress\":\"Chưa luyện tập\",\"tooltip\":\"Tiến trình học tập hàng ngày: {learned}/{target} từ ({percent}%)\"},\"sameTopicDatesTitle\":\"Các ngày có cùng chủ đề\",\"sameTopicDatesEmpty\":\"Không tìm thấy ngày nào khác cho chủ đề này\",\"sameTopicDatesAria\":\"Hiển thị các ngày có cùng chủ đề\",\"notFound\":\"Không tìm thấy từ vựng!\",\"updateError\":\"Có lỗi xảy ra khi cập nhật từ vựng. Vui lòng thử lại.\",\"deleteError\":\"Có lỗi xảy ra khi xóa từ vựng. Vui lòng thử lại.\",\"showingResults\":\"Hiển thị {start} đến {end} của {total} kết quả\",\"showingDateGroups\":\"Hiển thị {start} đến {end} của {total} nhóm ngày\",\"showingCategoryItems\":\"Hiển thị {start} đến {end} của {total} mục\",\"categories\":{\"technology\":\"Công nghệ\",\"business\":\"Kinh doanh\",\"travel\":\"Du lịch\",\"food\":\"Ẩm thực\",\"health\":\"Sức khỏe\",\"education\":\"Giáo dục\",\"sports\":\"Thể thao\",\"entertainment\":\"Giải trí\",\"science\":\"Khoa học\",\"art\":\"Nghệ thuật\",\"music\":\"Âm nhạc\",\"literature\":\"Văn học\",\"politics\":\"Chính trị\",\"environment\":\"Môi trường\",\"fashion\":\"Thời trang\",\"finance\":\"Tài chính\"},\"levels\":{\"beginner\":\"Cơ bản\",\"intermediate\":\"Trung cấp\",\"advanced\":\"Nâng cao\"},\"wordTypes\":{\"noun\":\"Danh từ (noun)\",\"verb\":\"Động từ (verb)\",\"adjective\":\"Tính từ (adjective)\",\"adverb\":\"Trạng từ (adverb)\",\"preposition\":\"Giới từ (preposition)\",\"conjunction\":\"Liên từ (conjunction)\",\"interjection\":\"Thán từ (interjection)\"},\"questions\":{\"title\":\"Quản lý câu hỏi\",\"description\":\"Tạo và quản lý câu hỏi dựa trên từ vựng của bạn\",\"addQuestion\":\"Thêm câu hỏi mới\",\"editQuestion\":\"Chỉnh sửa câu hỏi\",\"selectVocabulary\":\"Chọn từ vựng\",\"questionText\":\"Nội dung câu hỏi\",\"questionType\":\"Loại câu hỏi\",\"multipleChoice\":\"Trắc nghiệm\",\"fillBlank\":\"Điền vào chỗ trống\",\"trueFalse\":\"Đúng/Sai\",\"shortAnswer\":\"Câu trả lời ngắn\",\"options\":\"Lựa chọn\",\"addOption\":\"Thêm lựa chọn\",\"removeOption\":\"Xóa lựa chọn\",\"correctAnswer\":\"Đáp án đúng\",\"difficulty\":\"Độ khó\",\"easy\":\"Dễ\",\"medium\":\"Trung bình\",\"hard\":\"Khó\",\"explanation\":\"Giải thích\",\"optional\":\"(Tùy chọn)\",\"searchQuestions\":\"Tìm kiếm câu hỏi...\",\"filterByVocabulary\":\"Lọc theo từ vựng\",\"filterByType\":\"Lọc theo loại\",\"allVocabulary\":\"Tất cả từ vựng\",\"allTypes\":\"Tất cả loại\",\"createdAt\":\"Ngày tạo\",\"noQuestions\":\"Không tìm thấy câu hỏi\",\"deleteConfirm\":\"Bạn có chắc chắn muốn xóa câu hỏi này?\",\"true\":\"Đúng\",\"false\":\"Sai\"},\"examples\":{\"title\":\"Quản lý ví dụ\",\"description\":\"Tạo và quản lý ví dụ dựa trên từ vựng của bạn\",\"groupByTopic\":\"Nhóm theo chủ đề\",\"addNew\":\"Thêm ví dụ mới\",\"addExample\":\"Thêm ví dụ\",\"editExample\":\"Chỉnh sửa ví dụ\",\"selectVocabulary\":\"Chọn từ vựng\",\"exampleTitle\":\"Tiêu đề ví dụ\",\"exampleContent\":\"Nội dung ví dụ\",\"translation\":\"Dịch nghĩa\",\"context\":\"Ngữ cảnh\",\"exampleType\":\"Loại ví dụ\",\"types\":{\"sentence\":\"Câu văn\",\"dialogue\":\"Đối thoại\",\"phrase\":\"Cụm từ\",\"context\":\"Ngữ cảnh\"},\"difficulty\":{\"medium\":\"Trung bình\"},\"tags\":\"Thẻ\",\"addTag\":\"Thêm thẻ và nhấn Enter\",\"searchVocabulary\":\"Tìm kiếm từ vựng...\",\"searchExamples\":\"Tìm kiếm ví dụ...\",\"filterByVocabulary\":\"Lọc theo từ vựng\",\"filterByType\":\"Lọc theo loại\",\"allVocabulary\":\"Tất cả từ vựng\",\"allTypes\":\"Tất cả loại\",\"createdAt\":\"Ngày tạo\",\"noVocabulary\":\"Không tìm thấy từ vựng\",\"noVocabularyDescription\":\"Hãy thêm từ vựng trước để tạo ví dụ cho chúng.\",\"noExamplesForWord\":\"Chưa có ví dụ\",\"noExamples\":\"Không tìm thấy ví dụ\",\"examples\":\"ví dụ\",\"confirmDelete\":\"Bạn có chắc chắn muốn xóa ví dụ này?\",\"deleteConfirm\":\"Bạn có chắc chắn muốn xóa ví dụ này?\",\"playPronunciation\":\"Phát âm\",\"playExample\":\"Phát ví dụ\",\"showExamples\":\"Hiển thị ví dụ\",\"hideExamples\":\"Ẩn ví dụ\",\"showingExamples\":\"Hiển thị {start} đến {end} trong {total} ví dụ\",\"deleteSuccess\":\"Xóa ví dụ thành công\",\"showingVocabulary\":\"Hiển thị {start} đến {end} trong {total} từ vựng\",\"showingTopics\":\"Hiển thị {start} đến {end} trong {total} chủ đề\"},\"image\":{\"title\":\"Hình ảnh\",\"upload\":\"Tải lên\",\"url\":\"URL\",\"clickToUpload\":\"Nhấp để tải lên\",\"orDragDrop\":\" hoặc kéo thả tại đây\",\"supportedFormats\":\"PNG, JPG, GIF, WebP tối đa 5MB\",\"urlPlaceholder\":\"Dán URL hình ảnh từ internet...\",\"loadFromUrl\":\"Tải từ URL\",\"loading\":\"Đang tải...\",\"preview\":\"Xem trước hình ảnh\",\"change\":\"Thay đổi\",\"changeUrl\":\"Đổi URL\",\"remove\":\"Xóa\",\"fromUrl\":\"Từ URL\",\"processing\":\"Đang xử lý...\",\"errors\":{\"unsupportedFormat\":\"Định dạng file không được hỗ trợ. Vui lòng chọn PNG, JPG, GIF hoặc WebP.\",\"fileTooLarge\":\"File quá lớn. Vui lòng chọn file dưới 5MB.\",\"processingFailed\":\"Không thể xử lý hình ảnh. Vui lòng thử lại.\",\"emptyUrl\":\"Vui lòng nhập URL hình ảnh.\",\"invalidUrl\":\"URL không hợp lệ hoặc không phải là hình ảnh.\",\"urlLoadFailed\":\"Không thể tải hình ảnh từ URL. Vui lòng kiểm tra lại.\",\"corsWarning\":\"Hình ảnh đã được chấp nhận nhưng có thể không hiển thị do bảo mật website gốc.\"}},\"imageInfo\":{\"title\":\"Thiếu hình ảnh\",\"none\":\"Tất cả từ vựng đều có hình ảnh\",\"date\":\"Ngày\",\"category\":\"Chủ đề\",\"missingCount\":\"{count} không có ảnh\",\"aria\":\"Hiển thị thông tin về các từ thiếu hình ảnh\"},\"save\":{\"title\":\"Lưu & Đồng Bộ\",\"subtitle\":\"Quản lý lưu trữ dữ liệu từ vựng của bạn\",\"mode\":\"Chế độ lưu:\",\"auto\":\"Tự động\",\"manual\":\"Thủ công\",\"saveNow\":\"Lưu Ngay\",\"chooseAutoFile\":\"Chọn Tệp Lưu Tự Động\",\"setup\":\"Thiết Lập\",\"changeAutoFile\":\"Thay Đổi Tệp Lưu Tự Động\",\"change\":\"Thay Đổi\",\"importFile\":\"Import Tệp\",\"importFromComputer\":\"Import từ Máy tính\",\"importExport\":\"Nhập & Xuất\",\"importFromDrive\":\"Import từ Google Drive\",\"selectFromDrive\":\"Chọn từ Google Drive\",\"signInRequiredForImport\":\"Đăng nhập Google Drive để import file\",\"noFilesFound\":\"Không tìm thấy file JSON trong Google Drive\",\"importShort\":\"Import\",\"lastSave\":\"Lưu lần cuối: {time}\",\"notSaved\":\"Chưa lưu\",\"autoSaveFileSetup\":\"Thiết lập tệp lưu tự động thành công!\",\"autoSaveRetry\":\"Nhấp vào đây để chọn tệp lưu tự động mới\",\"storageType\":\"Loại lưu trữ:\",\"autoSaveConfiguration\":\"Cấu Hình Lưu Tự Động\",\"localFile\":\"Tệp Cục Bộ\",\"googleDrive\":\"Google Drive\",\"googleSignIn\":\"Đăng Nhập\",\"googleSignOut\":\"Đăng Xuất\",\"googleSync\":\"Đồng Bộ\",\"googleDriveSetup\":\"Thiết lập Google Drive thành công\",\"storageInformation\":\"Thông Tin Lưu Trữ\",\"type\":\"Loại\",\"googleSignInSuccess\":\"Đăng nhập Google thành công\",\"googleSignOutSuccess\":\"Đăng xuất Google thành công\",\"syncFromDriveSuccess\":\"Đồng bộ từ Google Drive thành công\",\"googleDriveRetry\":\"Lưu Google Drive thất bại. Kiểm tra kết nối.\",\"account\":\"Tài khoản\",\"status\":{\"title\":\"Trạng Thái Lưu\",\"saving\":\"Đang lưu...\",\"autoSaving\":\"Đang tự động lưu...\",\"autoWithFile\":\"Tự động (đã lưu tệp)\",\"autoLocalStorage\":\"Tự động (localStorage)\",\"autoFile\":\"Tự động (tệp)\",\"autoNoFile\":\"Tự động (chưa chọn tệp)\",\"autoGoogleDrive\":\"Đã lưu tự động lên Google Drive\",\"googleDriveReady\":\"Google Drive sẵn sàng\",\"googleDriveSignIn\":\"Đăng nhập Google Drive\",\"fileSaved\":\"Đã lưu tệp\",\"error\":\"Lỗi lưu\"},\"errors\":{\"browserNotSupported\":\"Trình duyệt không hỗ trợ tính năng này. Vui lòng sử dụng Chrome hoặc Edge.\",\"fileSelectError\":\"Lỗi chọn tệp: {error}\",\"invalidFile\":\"Vui lòng chọn tệp JSON hợp lệ!\",\"invalidFormat\":\"Định dạng tệp không hợp lệ\",\"autoSaveFileFailed\":\"Lưu tự động vào tệp thất bại. Vui lòng chọn tệp mới.\",\"permissionDenied\":\"Quyền ghi vào tệp bị từ chối. Vui lòng chọn tệp mới.\",\"googleSignInFailed\":\"Đăng nhập Google thất bại\",\"googleSignOutFailed\":\"Đăng xuất Google thất bại\",\"googleDriveFailed\":\"Lưu Google Drive thất bại\",\"googleDriveSetupFailed\":\"Thiết lập Google Drive thất bại\",\"notSignedIn\":\"Chưa đăng nhập Google\",\"syncFailed\":\"Đồng bộ thất bại\"},\"import\":{\"confirmMessage\":\"Bạn có muốn import {count} từ vựng từ tệp \\\"{filename}\\\"?\\n\\nDữ liệu hiện tại sẽ bị thay thế!\",\"confirmGoogleDriveMessage\":\"Bạn có muốn import {count} từ vựng từ Google Drive file \\\"{filename}\\\"?\\n\\nDữ liệu hiện tại sẽ bị thay thế!\",\"successMessage\":\"Import thành công {count} từ vựng!\",\"googleDriveSuccessMessage\":\"Import thành công {count} từ vựng từ Google Drive!\"}},\"validation\":{\"wordRequired\":\"Từ vựng là bắt buộc\",\"wordTooShort\":\"Từ vựng phải có ít nhất 1 ký tự\",\"wordTooLong\":\"Từ vựng phải ít hơn 100 ký tự\",\"meaningRequired\":\"Nghĩa của từ là bắt buộc\",\"meaningTooShort\":\"Nghĩa của từ phải có ít nhất 1 ký tự\",\"meaningTooLong\":\"Nghĩa của từ phải ít hơn 500 ký tự\",\"partOfSpeechRequired\":\"Loại từ là bắt buộc\",\"categoryRequired\":\"Danh mục là bắt buộc\",\"levelRequired\":\"Cấp độ là bắt buộc\",\"exampleTooLong\":\"Ví dụ phải ít hơn 500 ký tự\",\"notesTooLong\":\"Ghi chú phải ít hơn 500 ký tự\",\"pronunciationTooLong\":\"Phiên âm phải ít hơn 100 ký tự\",\"synonymsInvalid\":\"Vui lòng nhập từ đồng nghĩa hợp lệ, ngăn cách bằng dấu phẩy\",\"antonymsInvalid\":\"Vui lòng nhập từ trái nghĩa hợp lệ, ngăn cách bằng dấu phẩy\",\"saveError\":\"Có lỗi khi lưu từ vựng. Vui lòng thử lại.\",\"saveSuccess\":\"Lưu từ vựng thành công!\",\"updateSuccess\":\"Cập nhật từ vựng thành công!\"},\"details\":{\"title\":\"Chi tiết từ vựng\",\"playAudio\":\"Phát âm thanh từ vựng\",\"playExample\":\"Phát âm thanh ví dụ\",\"addFavorite\":\"Thêm vào yêu thích\",\"removeFavorite\":\"Xóa khỏi yêu thích\"},\"moveMode\":{\"title\":\"Chế độ di chuyển\",\"active\":\"Đang bật - Nhấn mũi tên để di chuyển từ\",\"inactive\":\"Không hoạt động\"},\"moveVocabulary\":\"Di chuyển từ vựng\",\"movingWord\":\"Đang di chuyển từ\",\"movingCategory\":\"Di chuyển tất cả từ trong chủ đề\",\"wordsWillBeMoved\":\"từ sẽ được di chuyển đến ngày đã chọn\",\"selectTargetDate\":\"Chọn ngày đích\",\"moveToDateGroup\":\"Di chuyển đến nhóm ngày khác\",\"moveToDate\":\"Di chuyển đến ngày\",\"moveWord\":\"Di chuyển từ\",\"moveAll\":\"Di chuyển tất cả\",\"moveSuccess\":\"Đã di chuyển thành công {count} từ đến {date}\",\"moveError\":\"Lỗi khi di chuyển từ vựng\",\"moveAutoSaveNotice\":\"Từ đã di chuyển và sẽ được tự động lưu\",\"batchMoveSuccess\":\"Đã di chuyển thành công {count} từ đến {date}\",\"batchMoveError\":\"Lỗi khi di chuyển chủ đề\",\"filterBySameTopic\":\"Lọc theo cùng chủ đề\",\"showingDatesWithSameTopic\":\"Chỉ hiển thị các ngày có cùng chủ đề\",\"selectTargetDateGroup\":\"Chọn nhóm ngày đích\",\"selectDate\":\"Chọn ngày\",\"noMatchingDates\":\"Không tìm thấy ngày nào phù hợp với chủ đề này. Hãy thử tắt bộ lọc.\",\"topicManager\":{\"title\":\"Quản lý chủ đề\",\"editTopic\":\"Sửa chủ đề\",\"addNewTopic\":\"Thêm chủ đề mới\",\"topicKey\":\"Mã chủ đề\",\"topicKeyPlaceholder\":\"Ví dụ: cooking, programming...\",\"keyDescription\":\"Mã này sẽ được sử dụng trong hệ thống. Chỉ dùng chữ thường, số và dấu gạch dưới.\",\"vietnameseName\":\"Tên tiếng Việt\",\"vietnameseNamePlaceholder\":\"Ví dụ: Nấu ăn, Lập trình...\",\"englishName\":\"Tên tiếng Anh\",\"englishNamePlaceholder\":\"Ví dụ: Cooking, Programming...\",\"existingTopics\":\"Chủ đề hiện có\",\"noCustomTopics\":\"Chưa có chủ đề tùy chỉnh nào.\",\"cannotDeleteInUse\":\"Không thể xóa chủ đề đang được sử dụng\",\"confirmDeleteTitle\":\"Xác nhận xóa chủ đề\",\"confirmDeleteMessage\":\"Bạn có chắc chắn muốn xóa chủ đề \\\"{topic}\\\"?\",\"duplicateKey\":\"Mã chủ đề đã tồn tại!\",\"builtInTopics\":\"Chủ đề có sẵn\",\"builtInTopicsDescription\":\"Hệ thống có 16 chủ đề có sẵn như Công nghệ, Kinh doanh, Du lịch... Bạn có thể thêm chủ đề tùy chỉnh tại đây.\",\"builtIn\":\"Có sẵn\",\"manageTopics\":\"Quản lý chủ đề\",\"searchPlaceholder\":\"Tìm kiếm chủ đề theo tên...\",\"pageOf\":\"Trang {current} trong {total}\",\"koreanName\":\"Tên tiếng Hàn\",\"koreanNamePlaceholder\":\"Ví dụ: 요리, 프로그래밍...\"},\"flashcard\":{\"header\":{\"history\":\"Lịch sử\",\"settings\":\"Cài đặt\",\"progress\":\"Tiến độ\",\"description\":\"Luyện tập từ vựng với thẻ ghi nhớ\",\"exit\":\"Thoát\"},\"topicKey\":\"Mã chủ đề\",\"topicKeyPlaceholder\":\"Ví dụ: cooking, programming...\",\"keyDescription\":\"Mã này sẽ được dùng trong hệ thống. Chỉ dùng chữ thường, số và dấu gạch dưới.\",\"vietnameseName\":\"Tên tiếng Việt\",\"vietnameseNamePlaceholder\":\"Ví dụ: Nấu ăn, Lập trình...\",\"englishName\":\"Tên tiếng Anh\",\"englishNamePlaceholder\":\"Example: Cooking, Programming...\",\"existingTopics\":\"Chủ đề hiện có\",\"noCustomTopics\":\"Chưa có chủ đề tùy chỉnh nào.\",\"cannotDeleteInUse\":\"Không thể xóa chủ đề đang được sử dụng\",\"confirmDeleteTitle\":\"Xác nhận xóa chủ đề\",\"confirmDeleteMessage\":\"Bạn có chắc chắn muốn xóa chủ đề \\\"{topic}\\\"?\",\"duplicateKey\":\"Mã chủ đề đã tồn tại!\",\"builtInTopics\":\"Chủ đề có sẵn\",\"builtInTopicsDescription\":\"Hệ thống có sẵn 16 chủ đề cơ bản như Technology, Business, Travel... Bạn có thể thêm chủ đề tùy chỉnh ở đây.\",\"builtIn\":\"Có sẵn\",\"manageTopics\":\"Quản lý chủ đề\"}}");
const korean$1 = {"inputHelper":{"title":"Trợ lý nhập tiếng Hàn","preview":"Xem trước","placeholder":"Gõ hoặc nhấp vào ký tự bên dưới...","consonants":"Phụ âm (자음)","vowels":"Nguyên âm (모음)","commonSyllables":"Âm tiết thông dụng","openHelper":"Mở trợ lý nhập tiếng Hàn"},"pronunciationHelper":{"title":"Trợ lý phiên âm tiếng Hàn","preview":"Xem trước phiên âm","placeholder":"Nhấp vào âm thanh tiếng Hàn bên dưới...","consonantSounds":"Âm phụ âm (자음 소리)","vowelSounds":"Âm nguyên âm (모음 소리)","commonPatterns":"Mẫu thông dụng","specialChars":"Ký tự đặc biệt","openHelper":"Mở trợ lý phiên âm tiếng Hàn"},"wordPlaceholder":"Nhập từ tiếng Hàn hoặc nhấp + để được trợ giúp","pronunciationPlaceholder":"an-nyeong-ha-se-yo"};
const flashcard$1 = {"header":{"history":"Lịch sử","settings":"Cài đặt","progress":"Tiến độ","description":"Luyện tập từ vựng với thẻ ghi nhớ","exit":"Thoát","selectMode":"Chọn chế độ"},"empty":{"title":"Không có flashcard nào","description":"Hãy thêm từ vựng để bắt đầu luyện tập.","action":"Thêm từ vựng"},"settings":{"title":"Cài đặt Flashcard","category":"Chủ đề","level":"Mức độ","all":"Tất cả","beginner":"Cơ bản","intermediate":"Trung cấp","advanced":"Nâng cao","autoFlip":"Tự động lật thẻ sau 3 giây","shuffle":"Xáo trộn thứ tự","shuffle_disabled_during_practice":"Không thể xáo trộn trong quá trình luyện tập","disabledDuringPractice":"Cài đặt bị vô hiệu hóa trong quá trình luyện tập"},"history":{"title":"Lịch sử luyện tập","empty":{"title":"Chưa có lịch sử","description":"Bắt đầu luyện tập để xem lịch sử của bạn."},"totalCards":"Tổng số thẻ","correct":"Đúng","incorrect":"Sai","duration":"Thời gian","categories":"Chủ đề","accuracy":"Độ chính xác","result":"Kết quả","pass":"Đạt","fail":"Chưa đạt","viewDetails":"Xem chi tiết","noDetails":"Không có chi tiết","deleteSession":"Xóa phiên luyện tập","confirmDelete":{"title":"Xóa Phiên Luyện Tập","message":"Bạn có chắc chắn muốn xóa phiên luyện tập này? Hành động này không thể hoàn tác.","confirm":"Xóa","cancel":"Hủy","success":"Đã xóa phiên luyện tập thành công"},"details":{"title":"Chi tiết phiên luyện tập","noData":"Không có chi tiết cho phiên luyện tập này","yourAnswer":"Câu trả lời của bạn","noAnswer":"Chưa trả lời","correctAnswer":"Đáp án đúng"}},"completion":{"title":"Hoàn thành!","description":"Bạn đã hoàn thành {count} flashcard.","correct":"Đúng","incorrect":"Sai","accuracy":"Độ chính xác","result":"Kết quả"},"modes":{"flashcard":"Thẻ ghi nhớ","quiz":"Trắc nghiệm","typing":"Gõ từ","listening":"Nghe","image":"Nhìn ảnh","pictionary":"Đuổi hình bắt chữ","flipTile":"Lật ô","bubbleShooter":"Bắn bóng từ vựng","snakeGame":"Rắn săn từ","pronunciation":"Phát âm","change_disabled_during_practice":"Không thể thay đổi chế độ trong quá trình luyện tập","selectMode":"Chọn chế độ","mode":"Chế độ"},"image":{"imageAlt":"Hình ảnh từ vựng","imageError":"Không thể tải hình ảnh","noImage":"Không có hình ảnh","placeholder":"Nhập từ vựng...","instruction":"Nhìn vào hình ảnh và nhập từ vựng tương ứng:","correctAnswer":"Đáp án đúng","unavailable":"Chế độ nhìn ảnh không khả dụng cho ngày đã chọn","quizToggle":"Trắc nghiệm"},"pictionary":{"imageAlt":"Hình ảnh đuổi hình bắt chữ","instruction":"Nhấp vào các ô và gõ để điền các chữ cái còn thiếu. Nhấn Enter để kiểm tra.","instructionDefinition":"Xem định nghĩa và gõ từ tương ứng. Nhấn Enter để kiểm tra.","dragInstructionDefinition":"Xem định nghĩa và kéo thả các chữ cái để tạo thành từ.","definitionToggle":"Chế độ định nghĩa","definitionHint":"Định nghĩa","noDefinition":"Không có định nghĩa","unavailable":"Chế độ đuổi hình bắt chữ không khả dụng cho ngày đã chọn"},"flipTile":{"tilesFlipped":"Ô đã lật","imageAlt":"Hình ảnh lật ô","noDefinition":"Không có định nghĩa","noContent":"Không có nội dung cho thẻ này.","answerPlaceholder":"Nhập câu trả lời của bạn...","check":"Kiểm tra","instruction":"Nhấp vào các ô để lộ các chữ cái (tối đa 2), sau đó nhập câu trả lời và nhấn Enter.","unavailable":"Chế độ lật ô không khả dụng cho ngày đã chọn","hintsToggle":"Sử dụng gợi ý định nghĩa"},"scrambleWords":{"toggle":"Xếp từ","instruction":"Sắp xếp các chữ cái để tạo thành từ","correct":"Chính xác!","incorrect":"Thử lại!","backspace":"Xóa lùi","clear":"Xóa","check":"Kiểm tra"},"card":{"flip_to_meaning":"Nhấp để xem nghĩa","flip_back":"Nhấp để lật lại"},"bubbleShooter":{"title":"Bắn Bóng Từ Vựng","instruction":"Bắn những quả bóng để ghép 4 từ giống nhau trở lên!","score":"Điểm","currentWord":"Từ Hiện Tại","gameComplete":"Hoàn Thành Game!","finalScore":"Điểm Cuối: {score}","wordsMatched":"Từ Đã Ghép: {count}","playAgain":"Chơi Lại"},"snakeGame":{"title":"Rắn Săn Từ","instruction":"Điều khiển rắn ăn những thức ăn có chữ cái đầu phù hợp!","score":"Điểm","currentWord":"Từ Hiện Tại","gameComplete":"Hoàn Thành Game!","finalScore":"Điểm Cuối: {score}","wordsEaten":"Từ Đã Ăn: {count}","playAgain":"Chơi Lại","gameOver":"Game Over!"},"snake":{"doubleBaitToggle":"Chế độ mồi đôi"},"listening":{"instruction":"Nghe và nhập từ bạn nghe được:","placeholder":"Nhập từ bạn nghe được...","correct":"✓ Chính xác!","incorrect":"✗ Đáp án đúng:","quizToggle":"Trắc nghiệm"},"typing":{"quizToggle":"Trắc nghiệm"},"dateFilter":{"enable":"Lọc theo ngày tạo","allDates":"Tất cả ngày","info":"Hiển thị {count} từ vựng từ {date}"},"pronunciation":{"microphoneError":"Lỗi microphone! Vui lòng kiểm tra quyền truy cập microphone.","yourRecording":"Bản Ghi Âm Của Bạn","tryAgain":"Thử Lại!","wordsCrushToggle":"Chế Độ Từ Ẩn","wordsCrush":{"title":"Words Crush: Từ Ẩn","instruction":"Điền các chữ cái còn thiếu để hoàn thành từ","playAudio":"Phát Âm Thanh","checkAnswer":"Kiểm Tra Đáp Án","hint":"Gợi Ý","reset":"Đặt Lại","correct":"🎉 Chính xác!","tryAgain":"Thử Lại!","correctWord":"Từ đúng","meaning":"Nghĩa"}}};
const grammar$1 = {"title":"Ngữ pháp","description":"Học và luyện tập ngữ pháp tiếng Anh","addLesson":"Thêm bài học","addNewLesson":"Thêm bài học mới","editLesson":"Sửa bài học","deleteLesson":"Xóa bài học","confirmDelete":"Bạn có chắc chắn muốn xóa bài học \"{title}\"?","search":"Tìm bài học ngữ pháp...","level":"Mức độ","category":"Chủ đề","duration":"phút","durationLabel":"Thời lượng (phút)","progress":"Tiến độ","continue":"Tiếp tục","start":"Bắt đầu","emptyState":{"title":"Không tìm thấy bài học nào","description":"Hãy thử thay đổi bộ lọc hoặc thêm bài học mới."},"levels":{"beginner":"Cơ bản","intermediate":"Trung cấp","advanced":"Nâng cao"},"manager":{"title":"Quản lý ngữ pháp","manageGrammar":"Quản lý ngữ pháp","addNew":"Thêm quy tắc ngữ pháp mới","editGrammar":"Sửa quy tắc ngữ pháp","existingRules":"Quy tắc ngữ pháp","category":"Chủ đề","level":"Mức độ","formula":"Công thức ngữ pháp","description":"Mô tả","examples":"Ví dụ","titlePlaceholder":"vd: Thì hiện tại hoàn thành","formulaPlaceholder":"vd: Chủ ngữ + have/has + quá khứ phân từ","descriptionPlaceholder":"Giải thích cách và khi nào sử dụng quy tắc ngữ pháp này...","examplePlaceholder":"vd: Tôi đã học tiếng Anh được 5 năm.","selectCategory":"Chọn chủ đề","selectLevel":"Chọn mức độ","addExample":"Thêm ví dụ","removeExample":"Xóa ví dụ","noRulesYet":"Chưa có quy tắc ngữ pháp nào","createdAt":"Tạo lúc","lastModified":"Sửa lần cuối","confirmDelete":"Bạn có chắc chắn muốn xóa quy tắc ngữ pháp này?","ruleAdded":"Đã thêm quy tắc ngữ pháp thành công","ruleUpdated":"Đã cập nhật quy tắc ngữ pháp thành công","ruleDeleted":"Đã xóa quy tắc ngữ pháp thành công","globalMode":"Chung","perDateMode":"Theo ngày","perDateDescription":"Đang quản lý quy tắc ngữ pháp cho ngày: {date}","noDateSelected":"Chưa chọn ngày cho chế độ theo ngày","showVocabulary":"Hiển thị từ vựng","vocabularyForDate":"Từ vựng ngày {date}","noVocabularyFound":"Không tìm thấy từ vựng nào cho ngày này"},"categories":{"tenses":"Thì","conditionals":"Câu điều kiện","passive":"Câu bị động","modals":"Động từ khuyết thiếu","articles":"Mạo từ","prepositions":"Giới từ","conjunctions":"Liên từ","other":"Khác"},"selectCategory":"Chọn chủ đề","selectLevel":"Chọn mức độ","titlePlaceholder":"Nhập tiêu đề bài học...","descriptionPlaceholder":"Nhập mô tả ngắn về bài học...","lessonContent":"Nội dung bài học","theory":"Lý thuyết","theoryPlaceholder":"Nhập nội dung lý thuyết của bài học...","structure":"Cấu trúc","structurePlaceholder":"Nhập cấu trúc ngữ pháp...","examples":"Ví dụ","examplePlaceholder":"Ví dụ {index}","translationPlaceholder":"Dịch nghĩa {index}","addExample":"Thêm ví dụ","usageRules":"Quy tắc sử dụng","ruleTitlePlaceholder":"Tiêu đề quy tắc {index}","ruleDescriptionPlaceholder":"Mô tả quy tắc {index}","addRule":"Thêm quy tắc","commonMistakes":"Lỗi thường gặp","wrongSentencePlaceholder":"Câu sai {index}","correctSentencePlaceholder":"Câu đúng {index}","explanationPlaceholder":"Giải thích {index}","addMistake":"Thêm lỗi thường gặp","markdownSupported":"Hỗ trợ định dạng Markdown cơ bản.","practice":{"title":"Luyện tập ngữ pháp","subtitle":"Chọn loại bài tập để luyện tập","chooseExercise":"Chọn loại bài tập","chooseDescription":"Chọn một loại bài tập để bắt đầu luyện tập","score":"Điểm","question":"Câu hỏi","checkAnswer":"Kiểm tra đáp án","next":"Tiếp theo","finish":"Hoàn thành","explanation":"Giải thích","reading":{"passage":"Đoạn văn","readingTime":"Thời gian đọc","questions":"Câu hỏi","showHighlights":"Hiển thị đánh dấu"},"exercises":{"checkAnswer":"Kiểm tra đáp án","next":"Tiếp theo","multiple-choice":{"title":"Trắc nghiệm","description":"Chọn đáp án đúng từ nhiều lựa chọn"},"fill-blank":{"title":"Điền vào chỗ trống","description":"Hoàn thành câu với từ đúng"},"pronunciation":{"title":"Phát âm","description":"Luyện tập nói và phát âm"},"reading":{"title":"Đọc hiểu","description":"Đọc đoạn văn và trả lời câu hỏi","passage":"Đoạn văn","listen":"Nghe","readingTime":"Thời gian đọc","questions":"Câu hỏi","true":"Đúng","false":"Sai","yourAnswer":"Câu trả lời của bạn","correctAnswer":"Câu trả lời đúng","correct":"Đúng","incorrect":"Sai","accuracy":"Độ chính xác","showHighlights":"Hiển thị đánh dấu","hideHighlights":"Ẩn đánh dấu"},"listening":{"title":"Nghe","description":"Nghe audio và trả lời câu hỏi","instruction":"Nghe đoạn audio và trả lời câu hỏi:","speed":"Tốc độ","playsLeft":"Lượt nghe còn lại","loading":"Đang tải...","questions":"Câu hỏi","audioUrl":"URL âm thanh","audioUrlPlaceholder":"Nhập đường dẫn file âm thanh...","maxPlays":"Số lần nghe tối đa","allowNotes":"Cho phép ghi chú","transcript":"Bản ghi âm","transcriptPlaceholder":"Nhập nội dung bản ghi âm...","question":"Câu hỏi","multipleChoice":"Trắc nghiệm","fillBlank":"Điền vào chỗ trống","ordering":"Sắp xếp thứ tự","addQuestion":"Thêm câu hỏi","correctAnswerPlaceholder":"Nhập đáp án đúng...","notesAllowed":"Cho phép ghi chú","takeNotes":"Ghi chú","notesPlaceholder":"Viết ghi chú của bạn ở đây...","correct":"Đúng","incorrect":"Sai","accuracy":"Độ chính xác","showTranscript":"Hiện bản ghi âm","correctAnswer":"Đáp án đúng","audioUrlHint":"Nhập URL âm thanh trực tiếp hoặc URL video YouTube","youtubeDetected":"Phát hiện URL YouTube","youtubeNote":"Âm thanh sẽ được trích xuất từ video YouTube này để luyện nghe"},"writing":{"title":"Luyện viết","description":"Viết bài luận và nhận phản hồi","instruction":"Viết một đoạn văn về chủ đề sau:","essay":"Bài luận","email":"Email","letter":"Thư","paragraph":"Đoạn văn","requirements":"Yêu cầu","minWords":"Số từ tối thiểu","timeLimit":"Thời gian giới hạn","yourResponse":"Câu trả lời của bạn","words":"từ","timeRemaining":"Thời gian còn lại","paragraphPlaceholder":"Nhập đoạn văn của bạn ở đây...","essayPlaceholder":"Viết bài luận của bạn ở đây...","emailPlaceholder":"Viết email của bạn ở đây...","letterPlaceholder":"Viết thư của bạn ở đây...","tips":"Mẹo viết","showTips":"Hiển thị mẹo","hideTips":"Ẩn mẹo","tip1":"Sử dụng cấu trúc câu đa dạng","tip2":"Kiểm tra ngữ pháp và chính tả","tip3":"Sử dụng từ nối để liên kết ý tưởng","tip4":"Đảm bảo bài viết có mở bài, thân bài và kết luận","tip5":"Sử dụng từ vựng phù hợp với chủ đề","saveDraft":"Lưu nháp","clear":"Xóa","confirmClear":"Bạn có chắc chắn muốn xóa toàn bộ nội dung?","submit":"Nộp bài","analyzing":"Đang phân tích...","feedback":"Phản hồi","overallScore":"Điểm tổng thể","grammar":"Ngữ pháp","vocabulary":"Từ vựng","coherence":"Tính mạch lạc","taskResponse":"Phản hồi chủ đề","strengths":"Điểm mạnh","improvements":"Cần cải thiện","corrections":"Sửa lỗi cụ thể","original":"Gốc","corrected":"Đã sửa","explanation":"Giải thích"}},"fillBlank":{"instruction":"Điền từ thích hợp vào chỗ trống:","clear":"Xóa tất cả"},"pronunciation":{"instruction":"Nghe và lặp lại câu sau:","listen":"Nghe","ready":"Sẵn sàng","recording":"Đang ghi âm...","recorded":"Đã ghi âm","processing":"Đang xử lý...","analyze":"Phân tích","feedback":"Phản hồi","tips":"Mẹo","tryAgain":"Thử lại","yourRecording":"Bản ghi âm của bạn","microphoneError":"Lỗi microphone! Vui lòng kiểm tra quyền truy cập microphone."},"settings":{"title":"Cài đặt bài tập","difficulty":"Độ khó","autoPlay":"Tự động phát âm thanh","autoplayAudio":"Tự động phát âm thanh","showExplanations":"Hiển thị giải thích","timeLimit":"Giới hạn thời gian (phút)","questionCount":"Số câu hỏi","close":"Đóng","save":"Lưu cài đặt","levels":{"easy":"Dễ","medium":"Trung bình","hard":"Khó"}},"exerciseManager":{"title":"Quản lý bài tập","addNew":"Thêm bài tập mới","existing":"Bài tập hiện có","exerciseType":"Loại bài tập","typePlaceholder":"Nhập loại bài tập...","titlePlaceholder":"Nhập tiêu đề bài tập...","description":"Mô tả","descriptionPlaceholder":"Nhập mô tả bài tập...","difficulty":"Độ khó","duration":"Thời lượng","durationPlaceholder":"Ví dụ: 10-15 phút","add":"Thêm bài tập","manageQuestions":"Quản lý đề bài"},"questionManager":{"title":"Quản lý đề bài","addNew":"Thêm đề bài mới","editQuestion":"Sửa đề bài","addQuestion":"Thêm đề bài","existingQuestions":"Đề bài hiện có","noQuestions":"Chưa có đề bài nào","addFirstQuestion":"Hãy thêm đề bài đầu tiên","question":"Câu hỏi","questionPlaceholder":"Nhập câu hỏi...","options":"Các lựa chọn","optionPlaceholder":"Nhập lựa chọn...","correctAnswer":"Đáp án đúng","explanation":"Giải thích","explanationPlaceholder":"Nhập giải thích...","taskType":"Loại bài viết","prompt":"Đề bài","promptPlaceholder":"Nhập đề bài viết...","requirements":"Yêu cầu","addRequirement":"Thêm yêu cầu","requirementPlaceholder":"Nhập yêu cầu...","minWords":"Số từ tối thiểu","timeLimit":"Thời gian (phút)","selectCorrectAnswer":"Chọn đáp án đúng"},"progress":{"question":"Câu hỏi","of":"của","score":"Điểm","timeRemaining":"Thời gian còn lại"},"results":{"title":"Kết quả bài tập","score":"Điểm của bạn","correct":"Đúng","total":"Tổng","accuracy":"Độ chính xác","timeSpent":"Thời gian làm bài","tryAgain":"Thử lại","backToMenu":"Về menu","reviewAnswers":"Xem lại đáp án"},"common":{"submit":"Nộp bài","next":"Tiếp theo","previous":"Trước","finish":"Hoàn thành","check":"Kiểm tra đáp án","checkAnswer":"Kiểm tra đáp án","showAnswer":"Hiện đáp án","explanation":"Giải thích","hint":"Gợi ý","loading":"Đang tải...","noAnswer":"Không có đáp án","correct":"Đúng!","incorrect":"Sai","skip":"Bỏ qua","retry":"Thử lại"}}};
const categories$1 = {"technology":"Công nghệ","business":"Kinh doanh","travel":"Du lịch","food":"Ẩm thực","health":"Sức khỏe","education":"Giáo dục","sports":"Thể thao","entertainment":"Giải trí","science":"Khoa học","art":"Nghệ thuật","music":"Âm nhạc","literature":"Văn học","politics":"Chính trị","environment":"Môi trường","fashion":"Thời trang","finance":"Tài chính"};
const dashboard$1 = {"title":"Trang chủ","description":"Tổng quan về tiến độ học tập của bạn","welcomeMessage":"Chào mừng bạn đến với hành trình học tiếng Anh!","todaysProgress":"Tiến độ hôm nay","currentLevel":"Cấp độ hiện tại","quickActions":"Thao tác nhanh","recentActivity":"Hoạt động gần đây","stats":{"vocabularyLearned":"Từ vựng đã học","grammarLessons":"Bài ngữ pháp","currentStreak":"Chuỗi liên tiếp","totalTime":"Tổng thời gian","days":"ngày","hours":"giờ"},"flashcardStats":{"title":"Luyện tập Flashcard","noData":"Chưa có phiên luyện tập nào","startPracticing":"Bắt đầu luyện tập để xem thống kê!","sessions":"Phiên","streak":"Chuỗi","days":"ngày","accuracy":"Độ chính xác","bestScore":"Điểm cao nhất","totalTime":"Tổng thời gian luyện tập","cardsStudied":"Thẻ đã học","favoriteMode":"Chế độ yêu thích","weeklyProgress":"Tuần này"},"actions":{"addVocabulary":"Thêm từ vựng","practiceFlashcard":"Luyện tập Flashcard","takeQuiz":"Làm bài kiểm tra","learnGrammar":"Học ngữ pháp"},"activity":{"added":"Đã thêm '{word}' vào {category}","updated":"Đã cập nhật '{word}' trong {category}","justNow":"Vừa xong","noActivity":"Không có hoạt động gần đây","addFirstVocab":"Thêm từ vựng đầu tiên để bắt đầu!"}};
const app$2 = {"title":"Ứng dụng Học Tiếng Anh","titleShort":"Ứng dụng Tiếng Anh"};
const time$1 = {"today":"Hôm nay","yesterday":"Hôm qua","ago":{"justNow":"Vừa xong","minutesAgo":"{minutes} phút trước","hoursAgo":"{hours} giờ trước","daysAgo":"{days} ngày trước","yesterday":"Hôm qua"}};
const practice$1 = {"controls":{"next":"Tiếp theo","complete":"Hoàn thành","difficult":"Khó","easy":"Dễ","exit":"Thoát"},"timer":{"startPractice":"Bắt đầu luyện tập","timeLimit":"Thời gian cho mỗi câu: {seconds} giây","timeUp":"Hết thời gian!","timeUpMessage":"Bạn đã hết thởi gian cho câu này. Hãy thử lại hoặc bỏ qua.","tryAgain":"Thử lại","skip":"Bỏ qua"},"exitWarning":{"title":"Cảnh báo rời khỏi bài tập","message":"Bạn đang trong quá trình luyện tập. Nếu rời khỏi bây giờ, bạn sẽ mất tiến độ và không đạt điểm. Bạn có chắc chắn muốn rời?","continue":"Tiếp tục luyện tập","exit":"Rời khỏi bài tập"}};
const quiz$1 = {"progress":{"question":"Câu hỏi"},"setup":{"title":"Cài đặt Quiz","description":"Tùy chỉnh quiz theo sở thích của bạn","type":"Loại quiz","level":"Mức độ","questionCount":"Số câu hỏi","timeLimit":"Thời gian (phút)","start":"Bắt đầu Quiz","allLevels":"Tất cả","unlimited":"Không giới hạn"},"types":{"vocabulary":"Từ vựng","grammar":"Ngữ pháp","mixed":"Hỗn hợp"},"navigation":{"previous":"Câu trước","next":"Câu tiếp","finish":"Hoàn thành"},"results":{"title":"Kết quả quiz","score":"Điểm số","correct":"Đúng","accuracy":"Độ chính xác","passed":"Đạt","failed":"Chưa đạt","above":"Trên","below":"Dưới","reviewAnswers":"Xem lại đáp án","correctAnswer":"Đáp án đúng","yourAnswer":"Bạn chọn","noAnswer":"Không chọn","explanation":"Giải thích","restartQuiz":"Làm lại Quiz"}};
const voice$1 = {"selector":{"title":"Giọng đọc"},"gender":{"female":"Nữ","male":"Nam"},"types":{"female_sweet":"Giọng nữ Ngọt ngào","female_clear":"Giọng nữ Trong trẻo","female_professional":"Giọng nữ Chuyên nghiệp","male_strong":"Giọng nam Mạnh mẽ","male_gentle":"Giọng nam Dịu dàng","male_deep":"Giọng nam Trầm ấm","korean_female":"Giọng nữ Hàn Quốc","korean_male":"Giọng nam Hàn Quốc"},"info":{"name":"Tên","language":"Ngôn ngữ","gender":"Giới tính"},"test":"Thử nghiệm giọng","testing":"Đang thử nghiệm...","testText":"Xin chào! Đây là bài kiểm tra giọng nói.","testTextKorean":"안녕하세요! 이것은 음성 테스트입니다.","settings":{"title":"Cài đặt giọng nói","rate":"Tốc độ","pitch":"Cao độ","volume":"Âm lượng"}};
const vi = {
  common: common$1,
  autoGenerator: autoGenerator$1,
  levels,
  vocabulary: vocabulary$1,
  korean: korean$1,
  flashcard: flashcard$1,
  grammar: grammar$1,
  categories: categories$1,
  dashboard: dashboard$1,
  app: app$2,
  time: time$1,
  practice: practice$1,
  quiz: quiz$1,
  voice: voice$1,
};

const common = {"easy":"쉬움","difficult":"어려움","reviewed":"복습 완료","correct":"정답","incorrect":"오답","cancel":"취소","apply":"적용","back":"뒤로","restart":"다시 연습","vocabulary":"어휘","grammar":"문법","practice":"연습","dashboard":"대시보드","save":"저장","saving":"저장 중...","update":"업데이트","delete":"삭제","edit":"편집","add":"추가","search":"검색","all":"전체","title":"제목","previous":"이전","next":"다음","minutes":"분","finish":"완료","close":"닫기","confirm":"확인","reset":"초기화","resetToDefault":"기본값으로 재설정","actions":"작업","backToTop":"맨 위로","backToTopTooltip":"맨 위로 ({percent}%)","backspace":"백스페이스","clear":"지우기","space":"공백","select":"선택"};
const autoGenerator = {"title":"자동 생성기","description":"텍스트, 주제 또는 AI 제안으로부터 자동으로 어휘를 생성합니다","methods":{"textAnalysis":"텍스트 분석","textAnalysisDesc":"기사, 책 또는 모든 텍스트 콘텐츠에서 어휘를 추출합니다","topicBased":"주제 기반","topicBasedDesc":"특정 주제나 카테고리를 기반으로 단어를 생성합니다","aiSuggestions":"AI 제안","aiSuggestionsDesc":"학습 수준에 맞는 지능적인 단어 제안을 받습니다"},"forms":{"textAnalysis":{"title":"텍스트 콘텐츠 분석","inputLabel":"여기에 텍스트 콘텐츠를 붙여넣으세요:","placeholder":"기사, 책 발췌 또는 영어 텍스트를 붙여넣으세요..."},"topicBased":{"title":"주제별 생성","selectTopic":"주제 선택:","chooseTopic":"주제를 선택하세요..."},"aiSuggestions":{"title":"AI 기반 생성","preferences":"학습 선호도:","preferencesPlaceholder":"학습하고 싶은 단어 유형을 설명하세요 (예: 학술 단어, 일상 대화, 비즈니스 용어)...","focusArea":"집중 영역"},"common":{"difficultyLevel":"난이도","maxWords":"최대 단어 수"}},"levels":{"beginner":"초급","intermediate":"중급","advanced":"고급","mixed":"혼합 레벨"},"topics":{"business":"비즈니스 & 금융","technology":"기술","travel":"여행 & 관광","health":"건강 & 의학","education":"교육","environment":"환경","food":"음식 & 요리","sports":"스포츠 & 피트니스"},"focusAreas":{"vocabulary":"일반 어휘","academic":"학술 단어","conversation":"대화","professional":"전문 용어"},"generate":"어휘 생성","generating":"생성 중...","saveAll":"모두 저장","saveSuccess":"{count}개 단어를 어휘 목록에 성공적으로 저장했습니다","saveError":"어휘 저장에 실패했습니다","preview":{"title":"생성된 어휘"}};
const vocabulary = /* #__PURE__ */ JSON.parse("{\"title\":\"어휘\",\"description\":\"영어 어휘를 관리하고 학습하세요\",\"topics\":{\"uncategorized\":\"미분류\",\"technology\":\"기술\",\"business\":\"비즈니스\",\"travel\":\"여행\",\"food\":\"음식\",\"health\":\"건강\",\"education\":\"교육\",\"sports\":\"스포츠\",\"entertainment\":\"엔터테인먼트\",\"science\":\"과학\",\"art\":\"예술\",\"music\":\"음악\",\"literature\":\"문학\",\"politics\":\"정치\",\"environment\":\"환경\",\"fashion\":\"패션\",\"finance\":\"금융\"},\"submenu\":{\"manageWords\":\"단어 관리\",\"manageQuestions\":\"문제 관리\",\"manageExamples\":\"예문 관리\",\"autoGenerator\":\"자동 생성기\"},\"header\":{\"title\":\"어휘\",\"accordionTitle\":\"어휘 관리\",\"accordionDescription\":\"어휘를 추가하고 관리하세요\"},\"filters\":{\"accordionTitle\":\"검색 및 필터\",\"accordionDescription\":\"어휘를 검색하고 필터링하세요\"},\"grouping\":{\"accordionTitle\":\"날짜별 그룹 설정\",\"accordionDescription\":\"어휘 표시 및 그룹화 방법을 설정하세요\",\"title\":\"날짜별 그룹\",\"description\":\"생성일 기준으로 어휘를 묶어 표시\",\"hoverToExpand\":\"호버하여 펼치기\",\"hoverDescription\":\"활성화 시 호버로 카테고리를 엽니다\"},\"tools\":{\"accordionTitle\":\"도구 및 설정\",\"accordionDescription\":\"음성 설정, 주제 관리자 및 저장 동기화 옵션\"},\"addNew\":\"새 단어 추가\",\"addWord\":\"단어 추가\",\"addVocabulary\":\"새 어휘 추가\",\"editVocabulary\":\"어휘 편집\",\"saveVocabulary\":\"어휘 저장\",\"deleteVocabulary\":\"어휘 삭제\",\"vocabularyList\":\"어휘 목록\",\"word\":\"단어\",\"pronunciation\":{\"label\":\"발음\",\"ipaPickerTitle\":\"IPA 선택기\",\"previewPlaceholder\":\"IPA 조합을 시작하세요...\",\"wrap\":\"슬래시로 감싸기\",\"vowels\":\"모음\",\"diphthongs\":\"이중모음\",\"consonants\":\"자음\",\"marks\":\"표식\",\"openIpaPicker\":\"IPA 선택기 열기\"},\"meaning\":\"의미\",\"category\":\"카테고리\",\"level\":\"난이도\",\"wordType\":\"품사\",\"note\":\"메모\",\"favorite\":\"즐겨찾기\",\"isFavorite\":\"즐겨찾는 어휘로 표시\",\"showFavoritesOnly\":\"즐겨찾기만 보기\",\"searchPlaceholder\":\"어휘 검색...\",\"wordPlaceholder\":\"단어 입력...\",\"meaningPlaceholder\":\"단어의 의미 입력...\",\"example\":\"예문\",\"examplePlaceholder\":\"예문을 입력하세요...\",\"synonyms\":\"유의어\",\"antonyms\":\"반의어\",\"separateByComma\":\"쉼표로 구분\",\"notePlaceholder\":\"이 단어에 대한 추가 메모...\",\"imageUrl\":\"이미지 URL\",\"imageUrlPlaceholder\":\"이미지 URL 입력 (선택사항)\",\"selectCategory\":\"카테고리 선택\",\"selectLevel\":\"난이도 선택\",\"selectWordType\":\"품사 선택\",\"confirmDelete\":\"\\\"{word}\\\"를 삭제하시겠습니까?\",\"confirmDeleteTitle\":\"삭제 확인\",\"confirmDeleteMessage\":\"이 어휘를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.\",\"updateInfo\":\"어휘 정보 업데이트\",\"vocabInfo\":\"어휘 정보\",\"updateSuccess\":\"어휘가 성공적으로 업데이트되었습니다.\",\"addSuccess\":\"어휘가 성공적으로 추가되었습니다!\",\"deleteSuccess\":\"\\\"{word}\\\"를 성공적으로 삭제했습니다.\",\"deleteAll\":{\"title\":\"모든 어휘 삭제\",\"description\":\"이 작업은 컬렉션의 모든 어휘를 영구적으로 삭제합니다. 이 작업은 되돌릴 수 없습니다.\",\"button\":\"모든 어휘 삭제\",\"confirmTitle\":\"모든 어휘 삭제\",\"confirmMessage\":\"정말로 모든 어휘를 삭제하시겠습니까? 이 작업은 되돌릴 수 없으며 저장된 모든 단어를 영구적으로 제거합니다.\",\"warningCount\":\"{count}개의 어휘를 삭제하려고 합니다.\",\"confirm\":\"모두 삭제\",\"success\":\"모든 어휘가 성공적으로 삭제되었습니다\",\"error\":\"모든 어휘를 삭제하지 못했습니다. 다시 시도해주세요.\",\"clearLocalStore\":\"로컬 스토어 데이터 삭제\",\"clearLocalStoreTitle\":\"로컬 스토어 데이터 삭제\",\"clearLocalStoreMessage\":\"이 작업은 브라우저의 로컬 스토리지에 저장된 모든 데이터를 삭제합니다. 어휘, 연습 세션 및 사용자 설정이 포함됩니다. 이 작업은 되돌릴 수 없습니다.\",\"clearLocalStoreWarning\":\"경고: 이 작업은 로컬에 저장된 모든 데이터를 제거하고 애플리케이션을 초기 상태로 재설정합니다.\",\"clearLocalStoreConfirm\":\"모든 데이터 삭제\",\"clearLocalStoreSuccess\":\"로컬 스토어 데이터가 성공적으로 삭제되었습니다\",\"clearLocalStoreError\":\"로컬 스토어 데이터를 삭제하지 못했습니다. 다시 시도해주세요.\",\"localStoreClearedInfo\":\"애플리케이션이 초기 상태로 재설정되었습니다. 모든 로컬 설정이 삭제되었습니다.\",\"pageReloadNotice\":\"참고: 완전한 재설정을 위해 삭제 후 페이지가 자동으로 다시 로드됩니다.\"},\"words\":\"단어\",\"createdAt\":\"생성일\",\"updatedAt\":\"수정일\",\"notes\":{\"title\":\"어휘 메모\",\"description\":\"오늘 학습한 어휘에 대한 메모를 관리하세요\",\"manageNotes\":\"메모 관리\",\"noteLabel\":\"어휘 메모\",\"placeholder\":\"이번 어휘 학습에 대한 메모를 작성하세요...\",\"wordsLearned\":\"이 그룹의 단어\",\"noWordsLearned\":\"이 그룹에 어휘가 없습니다\",\"saveSuccess\":\"메모가 성공적으로 저장되었습니다!\",\"autoSaveNotice\":\"자동 저장이 활성화되었습니다. 메모는 다음 백업에 포함됩니다.\",\"today\":\"오늘\",\"yesterday\":\"어제\"},\"lazyLoading\":{\"loading\":\"로딩 중...\",\"componentVisible\":\"컴포넌트가 표시되었습니다\",\"componentHidden\":\"컴포넌트가 숨겨졌습니다\"},\"accordion\":{\"expand\":\"그룹 펼치기\",\"collapse\":\"그룹 접기\",\"addTopic\":\"주제 추가\",\"editTopic\":\"주제 편집\",\"saveTopic\":\"주제 저장\",\"cancelTopic\":\"취소\",\"topicPlaceholder\":\"주제 이름 입력...\"},\"progress\":{\"dailyTarget\":\"일일 목표: {target}개 단어\",\"wordsLearned\":\"학습한 단어: {count}개\",\"percentage\":\"{percent}% 완료\",\"completed\":\"완료!\",\"noProgress\":\"아직 학습하지 않음\",\"tooltip\":\"일일 학습 진행상황: {learned}/{target}개 단어 ({percent}%)\"},\"sameTopicDatesTitle\":\"같은 주제의 다른 날짜\",\"sameTopicDatesEmpty\":\"이 주제의 다른 날짜가 없습니다\",\"sameTopicDatesAria\":\"같은 주제의 날짜 표시\",\"notFound\":\"어휘를 찾을 수 없습니다!\",\"updateError\":\"어휘 업데이트 중 오류가 발생했습니다. 다시 시도하세요.\",\"deleteError\":\"어휘 삭제 중 오류가 발생했습니다. 다시 시도하세요.\",\"showingResults\":\"총 {total}개 중 {start}–{end} 표시\",\"showingDateGroups\":\"총 {total}개 날짜 그룹 중 {start}–{end} 표시\",\"showingCategoryItems\":\"총 {total}개 항목 중 {start}–{end} 표시\",\"categories\":{\"technology\":\"기술\",\"business\":\"비즈니스\",\"travel\":\"여행\",\"food\":\"음식\",\"health\":\"건강\",\"education\":\"교육\",\"sports\":\"스포츠\",\"entertainment\":\"엔터테인먼트\",\"science\":\"과학\",\"art\":\"예술\",\"music\":\"음악\",\"literature\":\"문학\",\"politics\":\"정치\",\"environment\":\"환경\",\"fashion\":\"패션\",\"finance\":\"금융\"},\"levels\":{\"beginner\":\"초급\",\"intermediate\":\"중급\",\"advanced\":\"고급\"},\"wordTypes\":{\"noun\":\"명사\",\"verb\":\"동사\",\"adjective\":\"형용사\",\"adverb\":\"부사\",\"preposition\":\"전치사\",\"conjunction\":\"접속사\",\"interjection\":\"감탄사\"},\"questions\":{\"title\":\"문제 관리\",\"description\":\"어휘를 기반으로 문제를 생성하고 관리합니다\",\"addQuestion\":\"새 문제 추가\",\"editQuestion\":\"문제 수정\",\"selectVocabulary\":\"어휘 선택\",\"questionText\":\"문제 내용\",\"questionType\":\"문제 유형\",\"multipleChoice\":\"객관식\",\"fillBlank\":\"빈칸 채우기\",\"trueFalse\":\"참/거짓\",\"shortAnswer\":\"단답형\",\"options\":\"선택지\",\"addOption\":\"선택지 추가\",\"removeOption\":\"선택지 제거\",\"correctAnswer\":\"정답\",\"difficulty\":\"난이도\",\"easy\":\"쉬움\",\"medium\":\"보통\",\"hard\":\"어려움\",\"explanation\":\"설명\",\"optional\":\"(선택사항)\",\"searchQuestions\":\"문제 검색...\",\"filterByVocabulary\":\"어휘별 필터\",\"filterByType\":\"유형별 필터\",\"allVocabulary\":\"모든 어휘\",\"allTypes\":\"모든 유형\",\"createdAt\":\"생성일\",\"noQuestions\":\"문제를 찾을 수 없습니다\",\"deleteConfirm\":\"이 문제를 삭제하시겠습니까?\",\"true\":\"참\",\"false\":\"거짓\"},\"examples\":{\"title\":\"예문 관리\",\"description\":\"어휘를 기반으로 예문을 생성하고 관리합니다\",\"groupByTopic\":\"주제별 그룹화\",\"addNew\":\"새 예문 추가\",\"addExample\":\"예문 추가\",\"editExample\":\"예문 편집\",\"selectVocabulary\":\"어휘 선택\",\"exampleTitle\":\"예문 제목\",\"exampleContent\":\"예문 내용\",\"translation\":\"번역\",\"context\":\"맥락\",\"exampleType\":\"예문 유형\",\"types\":{\"sentence\":\"문장\",\"dialogue\":\"대화\",\"phrase\":\"구문\",\"context\":\"맥락\"},\"difficulty\":{\"medium\":\"보통\"},\"tags\":\"태그\",\"addTag\":\"태그 추가 후 Enter\",\"searchVocabulary\":\"어휘 검색...\",\"searchExamples\":\"예문 검색...\",\"filterByVocabulary\":\"어휘별 필터\",\"filterByType\":\"유형별 필터\",\"allVocabulary\":\"모든 어휘\",\"allTypes\":\"모든 유형\",\"createdAt\":\"생성일\",\"noVocabulary\":\"어휘를 찾을 수 없습니다\",\"noVocabularyDescription\":\"예문을 만들기 위해 먼저 어휘를 추가하세요.\",\"noExamplesForWord\":\"예문 없음\",\"noExamples\":\"예문을 찾을 수 없습니다\",\"examples\":\"예문\",\"confirmDelete\":\"이 예문을 삭제하시겠습니까?\",\"deleteConfirm\":\"이 예문을 삭제하시겠습니까?\",\"playPronunciation\":\"발음 재생\",\"playExample\":\"예문 재생\",\"showExamples\":\"예문 보기\",\"hideExamples\":\"예문 숨기기\",\"showingVocabulary\":\"{total}개 어휘 중 {start}에서 {end}까지 표시\",\"showingTopics\":\"{total}개 주제 중 {start}에서 {end}까지 표시\",\"showingExamples\":\"{start}에서 {end}까지 표시 ({total}개 예문)\",\"deleteSuccess\":\"예문 삭제 완료\"},\"image\":{\"title\":\"이미지\",\"upload\":\"업로드\",\"url\":\"URL\",\"imageUrl\":\"이미지 URL\",\"imageUrlPlaceholder\":\"이미지 URL 입력 (선택사항)\",\"copyTab\":\"복사\",\"clickToUpload\":\"클릭하여 업로드\",\"orDragDrop\":\" 또는 여기로 드래그 앤 드롭\",\"supportedFormats\":\"PNG, JPG, GIF, WebP (최대 5MB)\",\"urlPlaceholder\":\"인터넷의 이미지 URL을 붙여넣으세요...\",\"loadFromUrl\":\"URL에서 불러오기\",\"loading\":\"로딩 중...\",\"preview\":\"이미지 미리보기\",\"change\":\"변경\",\"changeUrl\":\"URL 변경\",\"remove\":\"제거\",\"fromUrl\":\"URL에서\",\"processing\":\"처리 중...\",\"errors\":{\"unsupportedFormat\":\"지원되지 않는 파일 형식입니다. PNG, JPG, GIF 또는 WebP를 선택하세요.\",\"fileTooLarge\":\"파일이 너무 큽니다. 5MB 이하 파일을 선택하세요.\",\"processingFailed\":\"이미지를 처리할 수 없습니다. 다시 시도하세요.\",\"emptyUrl\":\"이미지 URL을 입력하세요.\",\"invalidUrl\":\"유효하지 않은 URL이거나 이미지가 아닙니다.\",\"urlLoadFailed\":\"URL에서 이미지를 불러올 수 없습니다. URL을 다시 확인하세요.\",\"corsWarning\":\"이미지가 허용되었지만 원본 사이트의 보안 설정으로 표시되지 않을 수 있습니다.\"}},\"imageInfo\":{\"title\":\"누락된 이미지\",\"none\":\"모든 어휘에 이미지가 있습니다\",\"date\":\"날짜\",\"category\":\"카테고리\",\"missingCount\":\"이미지 없음 {count}개\",\"aria\":\"누락된 이미지 정보 보기\"},\"save\":{\"title\":\"저장 및 동기화\",\"subtitle\":\"어휘 데이터 저장소를 관리하세요\",\"mode\":\"저장 모드:\",\"auto\":\"자동\",\"manual\":\"수동\",\"saveNow\":\"지금 저장\",\"chooseAutoFile\":\"자동 저장 파일 선택\",\"setup\":\"설정\",\"changeAutoFile\":\"자동 저장 파일 변경\",\"change\":\"변경\",\"importFromComputer\":\"컴퓨터에서 가져오기\",\"importExport\":\"가져오기 및 내보내기\",\"importFromGoogleDrive\":\"구글 드라이브에서 가져오기\",\"selectFromGoogleDrive\":\"구글 드라이브에서 선택\",\"signInRequired\":\"구글 드라이브에 로그인이 필요합니다\",\"noJsonFiles\":\"JSON 파일을 찾을 수 없습니다\",\"selectFile\":\"파일을 선택하세요\",\"loadingFiles\":\"파일을 불러오는 중...\",\"importConfirm\":\"가져오기 확인\",\"importSuccess\":\"가져오기 성공\",\"importShort\":\"가져오기\",\"lastSave\":\"마지막 저장: {time}\",\"notSaved\":\"저장되지 않음\",\"autoSaveFileSetup\":\"자동 저장 파일 설정이 완료되었습니다!\",\"autoSaveRetry\":\"새 자동 저장 파일을 선택하려면 여기를 클릭하세요\",\"storageType\":\"저장 유형:\",\"autoSaveConfiguration\":\"자동 저장 설정\",\"localFile\":\"로컬 파일\",\"googleDrive\":\"구글 드라이브\",\"googleSignIn\":\"로그인\",\"googleSignOut\":\"로그아웃\",\"googleSync\":\"동기화\",\"googleDriveSetup\":\"구글 드라이브 설정 완료\",\"storageInformation\":\"저장소 정보\",\"type\":\"유형\",\"googleSignInSuccess\":\"구글 로그인 성공\",\"googleSignOutSuccess\":\"구글 로그아웃 성공\",\"syncFromDriveSuccess\":\"구글 드라이브에서 동기화 성공\",\"googleDriveRetry\":\"구글 드라이브 저장 실패. 연결을 확인하세요.\",\"account\":\"계정\",\"status\":{\"title\":\"저장 상태\",\"saving\":\"저장 중...\",\"autoSaving\":\"자동 저장 중...\",\"autoWithFile\":\"자동 (파일 저장됨)\",\"autoLocalStorage\":\"자동 (localStorage)\",\"autoFile\":\"자동 (파일)\",\"autoNoFile\":\"자동 (파일 선택 안됨)\",\"autoGoogleDrive\":\"구글 드라이브에 자동 저장됨\",\"googleDriveReady\":\"구글 드라이브 준비됨\",\"googleDriveSignIn\":\"구글 드라이브 로그인\",\"fileSaved\":\"파일 저장됨\",\"error\":\"저장 오류\"},\"errors\":{\"browserNotSupported\":\"브라우저에서 이 기능을 지원하지 않습니다. Chrome 또는 Edge를 사용해 주세요.\",\"fileSelectError\":\"파일 선택 오류: {error}\",\"invalidFile\":\"유효한 JSON 파일을 선택해 주세요!\",\"invalidFormat\":\"잘못된 파일 형식\",\"autoSaveFileFailed\":\"파일 자동 저장에 실패했습니다. 새 파일을 선택해 주세요.\",\"permissionDenied\":\"파일 쓰기 권한이 거부되었습니다. 새 파일을 선택해 주세요.\",\"googleSignInFailed\":\"구글 로그인 실패\",\"googleSignOutFailed\":\"구글 로그아웃 실패\",\"googleDriveFailed\":\"구글 드라이브 저장 실패\",\"googleDriveSetupFailed\":\"구글 드라이브 설정 실패\",\"notSignedIn\":\"구글에 로그인하지 않음\",\"syncFailed\":\"동기화 실패\",\"googleDriveImportFailed\":\"구글 드라이브 가져오기 실패\",\"fileReadError\":\"파일 읽기 오류: {error}\"},\"import\":{\"confirmMessage\":\"파일 \\\"{filename}\\\"에서 {count}개의 단어를 가져오시겠습니까?\\n\\n현재 데이터가 대체됩니다!\",\"successMessage\":\"{count}개의 단어를 성공적으로 가져왔습니다!\",\"confirmGoogleDriveMessage\":\"구글 드라이브에서 \\\"{filename}\\\"을(를) 가져오시겠습니까? 현재 모든 어휘가 대체됩니다.\",\"googleDriveSuccessMessage\":\"구글 드라이브에서 {count}개의 어휘를 성공적으로 가져왔습니다\"}},\"validation\":{\"wordRequired\":\"단어는 필수입니다\",\"wordTooShort\":\"단어는 최소 1자 이상이어야 합니다\",\"wordTooLong\":\"단어는 100자 미만이어야 합니다\",\"meaningRequired\":\"의미는 필수입니다\",\"meaningTooShort\":\"의미는 최소 1자 이상이어야 합니다\",\"meaningTooLong\":\"의미는 500자 미만이어야 합니다\",\"partOfSpeechRequired\":\"품사는 필수입니다\",\"categoryRequired\":\"카테고리는 필수입니다\",\"levelRequired\":\"난이도는 필수입니다\",\"exampleTooLong\":\"예문은 500자 미만이어야 합니다\",\"notesTooLong\":\"메모는 500자 미만이어야 합니다\",\"pronunciationTooLong\":\"발음은 100자 미만이어야 합니다\",\"synonymsInvalid\":\"쉼표로 구분된 올바른 유의어를 입력하세요\",\"antonymsInvalid\":\"쉼표로 구분된 올바른 반의어를 입력하세요\",\"saveError\":\"어휘 저장 중 오류가 발생했습니다. 다시 시도하세요.\",\"saveSuccess\":\"어휘가 성공적으로 저장되었습니다!\",\"updateSuccess\":\"어휘가 성공적으로 업데이트되었습니다!\"},\"details\":{\"title\":\"어휘 상세\",\"playAudio\":\"어휘 발음 재생\",\"playExample\":\"예문 오디오 재생\",\"addFavorite\":\"즐겨찾기에 추가\",\"removeFavorite\":\"즐겨찾기에서 제거\"},\"moveMode\":{\"title\":\"이동 모드\",\"active\":\"활성 - 화살표를 클릭해 단어 이동\",\"inactive\":\"비활성\"},\"moveVocabulary\":\"어휘 이동\",\"movingWord\":\"단어 이동 중\",\"movingCategory\":\"카테고리의 모든 단어 이동 중\",\"wordsWillBeMoved\":\"선택한 날짜로 이동될 예정입니다\",\"selectTargetDate\":\"대상 날짜 선택\",\"moveToDateGroup\":\"다른 날짜 그룹으로 이동\",\"moveToDate\":\"날짜로 이동\",\"moveWord\":\"단어 이동\",\"moveAll\":\"모두 이동\",\"moveSuccess\":\"{date}로 {count}개 단어를 성공적으로 이동했습니다\",\"moveError\":\"어휘 이동 실패\",\"moveAutoSaveNotice\":\"단어가 이동되었으며 자동 저장에 포함됩니다\",\"batchMoveSuccess\":\"{date}로 {count}개 단어를 성공적으로 이동했습니다\",\"batchMoveError\":\"카테고리 이동 실패\",\"filterBySameTopic\":\"같은 주제별로 필터링\",\"showingDatesWithSameTopic\":\"같은 주제를 가진 날짜만 표시 중\",\"selectTargetDateGroup\":\"대상 날짜 그룹 선택\",\"selectDate\":\"날짜 선택\",\"noMatchingDates\":\"이 주제와 일치하는 날짜를 찾을 수 없습니다. 필터를 비활성화해 보세요.\",\"topicManager\":{\"title\":\"주제 관리자\",\"addNewTopic\":\"새 주제 추가\",\"editTopic\":\"주제 편집\",\"topicKey\":\"주제 키\",\"topicKeyPlaceholder\":\"예: cooking, programming...\",\"keyDescription\":\"이 키는 시스템에서 사용됩니다. 소문자, 숫자, 밑줄만 사용하세요.\",\"vietnameseName\":\"베트남어 이름\",\"vietnameseNamePlaceholder\":\"예: Nấu ăn, Lập trình...\",\"englishName\":\"영어 이름\",\"englishNamePlaceholder\":\"예: Cooking, Programming...\",\"existingTopics\":\"기존 주제\",\"noCustomTopics\":\"사용자 지정 주제가 없습니다.\",\"cannotDeleteInUse\":\"사용 중인 주제는 삭제할 수 없습니다\",\"confirmDeleteTitle\":\"주제 삭제 확인\",\"confirmDeleteMessage\":\"주제 \\\"{topic}\\\"를 삭제하시겠습니까?\",\"duplicateKey\":\"주제 키가 이미 존재합니다!\",\"builtInTopics\":\"기본 제공 주제\",\"builtInTopicsDescription\":\"시스템에는 기술, 비즈니스, 여행 등 16개의 기본 제공 주제가 있습니다. 여기에서 사용자 지정 주제를 추가할 수 있습니다.\",\"builtIn\":\"기본 제공\",\"manageTopics\":\"주제 관리\",\"searchPlaceholder\":\"이름으로 주제 검색...\",\"pageOf\":\"{total} 중 {current} 페이지\",\"koreanName\":\"한국어 이름\",\"koreanNamePlaceholder\":\"예: 요리, 프로그래밍...\"}}");
const flashcard = {"header":{"history":"기록","settings":"설정","progress":"진행","description":"플래시카드로 어휘를 연습하세요","exit":"나가기","selectMode":"모드 선택"},"empty":{"title":"플래시카드 없음","description":"어휘를 추가하고 연습을 시작하세요.","action":"어휘 추가"},"settings":{"title":"플래시카드 설정","category":"카테고리","level":"난이도","all":"전체","beginner":"초급","intermediate":"중급","advanced":"고급","autoFlip":"3초 후 자동으로 카드 뒤집기","shuffle":"순서 섞기","shuffle_disabled_during_practice":"연습 중에는 섞기가 비활성화됩니다","disabledDuringPractice":"연습 중에는 설정이 비활성화됩니다"},"history":{"title":"연습 기록","empty":{"title":"기록 없음","description":"연습을 시작하여 기록을 확인하세요."},"totalCards":"총 카드 수","correct":"정답","incorrect":"오답","duration":"소요 시간","categories":"카테고리","accuracy":"정확도","result":"결과","pass":"통과","fail":"실패","viewDetails":"자세히 보기","noDetails":"세부 정보가 없습니다","deleteSession":"세션 삭제","confirmDelete":{"title":"세션 삭제","message":"이 연습 세션을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.","confirm":"삭제","cancel":"취소","success":"세션이 성공적으로 삭제되었습니다"},"details":{"title":"세션 세부 정보","noData":"이 세션에 대한 세부 정보가 없습니다","yourAnswer":"당신의 답변","noAnswer":"답변 없음","correctAnswer":"정답"}},"completion":{"title":"완료!","description":"{count}개의 플래시카드를 완료했습니다.","correct":"정답","incorrect":"오답","accuracy":"정확도","result":"결과"},"modes":{"flashcard":"플래시카드","quiz":"퀴즈","typing":"타이핑","listening":"리스닝","image":"이미지","pictionary":"픽셔너리","flipTile":"플립 타일","bubbleShooter":"버블 슈터","snakeGame":"스네이크 헌트","pronunciation":"발음","change_disabled_during_practice":"연습 중에는 모드 변경이 비활성화됩니다","selectMode":"모드 선택","mode":"모드"},"image":{"imageAlt":"어휘 이미지","imageError":"이미지를 불러올 수 없습니다","noImage":"사용 가능한 이미지가 없습니다","placeholder":"단어를 입력하세요...","instruction":"이미지를 보고 해당하는 단어를 입력하세요:","instructionQuiz":"이미지에 맞는 올바른 단어를 선택하세요:","correctAnswer":"정답","unavailable":"선택한 날짜에는 이미지 모드를 사용할 수 없습니다","quizToggle":"객관식"},"pictionary":{"imageAlt":"픽셔너리 이미지","instruction":"칸을 클릭하고 입력하여 빠진 글자를 채우세요. Enter 키로 확인합니다.","instructionDefinition":"정의를 보고 단어를 입력하세요. Enter 키로 확인합니다.","dragInstructionDefinition":"정의를 보고 글자를 드래그하여 단어를 만드세요.","definitionToggle":"정의 모드","definitionHint":"정의","noDefinition":"정의가 없습니다","unavailable":"선택한 날짜에는 픽셔너리 모드를 사용할 수 없습니다"},"flipTile":{"tilesFlipped":"뒤집힌 타일","imageAlt":"그림 맞추기 이미지","noDefinition":"정의를 사용할 수 없음","noContent":"이 카드에 사용할 수 있는 내용이 없습니다.","answerPlaceholder":"답을 입력하세요...","check":"확인","instruction":"타일을 클릭하여 글자를 공개하고(최대 {maxFlips}개), 답을 입력한 후 Enter를 누르세요.","unavailable":"선택한 날짜에 대해 타일 뒤집기 모드를 사용할 수 없습니다","hintsToggle":"정의 힌트 사용"},"scrambleWords":{"toggle":"단어 배열","instruction":"글자를 배열하여 단어를 만드세요","correct":"정답!","incorrect":"다시 시도하세요!","backspace":"백스페이스","clear":"지우기","check":"확인"},"card":{"flip_to_meaning":"클릭하여 의미 보기","flip_back":"클릭하여 뒤집기"},"bubbleShooter":{"title":"버블 슈터","instruction":"버블을 쏴서 4개 이상의 단어를 매칭하세요!","score":"점수","currentWord":"현재 단어","gameComplete":"게임 완료!","finalScore":"최종 점수: {score}","wordsMatched":"매칭된 단어: {count}","playAgain":"다시 하기","unavailable":"8개를 초과하는 어휘가 있는 날짜에는 버블 슈터 모드가 비활성화됩니다","vietnameseModeToggle":"베트남어 첫 글자 모드"},"snakeGame":{"title":"스네이크 헌트","instruction":"뱀이 첫 글자가 같은 먹이를 먹도록 유도하세요!","score":"점수","currentWord":"현재 단어","target":"목표","controls":"조작법","arrowKeys":"화살표 키 / WASD","clickToStart":"시작하려면 START 클릭","completed":"완료","start":"사냥 시작","up":"위","down":"아래","left":"왼쪽","right":"오른쪽","gameComplete":"사냥 완료!","finalScore":"최종 점수: {score}","wordsHunted":"사냥한 단어: {count}","playAgain":"다시 사냥","gameOver":"게임 오버!"},"snake":{"doubleBaitToggle":"더블 미끼 모드"},"listening":{"instruction":"듣고 들은 단어를 입력하세요:","instructionQuiz":"들은 단어를 선택하세요:","placeholder":"들은 단어를 입력하세요...","correct":"✓ 정답!","incorrect":"✗ 정답:","quizToggle":"객관식"},"typing":{"instruction":"해당하는 영어 단어를 입력하세요:","instructionQuiz":"올바른 영어 단어를 선택하세요:","placeholder":"단어를 입력하세요...","correctAnswer":"정답:","correct":"✓ 정답!","incorrect":"✗ 정답:","quizToggle":"객관식"},"pronunciation":{"instruction":"다음 문장을 듣고 따라 하세요:","listen":"듣기","ready":"준비","recording":"녹음 중...","recorded":"녹음 완료","processing":"처리 중...","analyze":"분석","feedback":"피드백","tips":"팁","tryAgain":"다시 시도!","yourRecording":"당신의 녹음","microphoneError":"마이크 오류! 마이크 접근 권한을 확인하세요.","wordsCrushToggle":"숨겨진 단어 모드","wordsCrush":{"title":"Words Crush: 숨겨진 단어","instruction":"누락된 글자를 채워서 단어를 완성하세요","playAudio":"오디오 재생","checkAnswer":"답안 확인","hint":"힌트","reset":"재설정","correct":"🎉 정답!","tryAgain":"다시 시도!","correctWord":"정답 단어","meaning":"의미"}},"dateFilter":{"enable":"생성 날짜로 필터","allDates":"모든 날짜","info":"{date}의 어휘 {count}개 표시"}};
const grammar = {"title":"문법","description":"영어 문법을 학습하고 연습하세요","addLesson":"수업 추가","addNewLesson":"새 수업 추가","editLesson":"수업 편집","deleteLesson":"수업 삭제","confirmDelete":"레슨 \"{title}\"을(를) 삭제하시겠습니까?","search":"문법 수업 검색...","level":"레벨","category":"카테고리","duration":"분","durationLabel":"소요 시간(분)","progress":"진행도","continue":"계속","start":"시작","emptyState":{"title":"수업을 찾을 수 없습니다","description":"필터를 변경하거나 새 수업을 추가해 보세요."},"levels":{"beginner":"초급","intermediate":"중급","advanced":"고급"},"manager":{"title":"문법 관리자","manageGrammar":"문법 관리","addNew":"새 문법 규칙 추가","editGrammar":"문법 규칙 편집","existingRules":"문법 규칙","category":"카테고리","level":"레벨","formula":"문법 공식","description":"설명","examples":"예시","titlePlaceholder":"예: 현재완료 시제","formulaPlaceholder":"예: 주어 + have/has + 과거분사","descriptionPlaceholder":"해당 문법 규칙의 사용 방법과 시기를 설명하세요...","examplePlaceholder":"예: I have studied English for 5 years.","selectCategory":"카테고리 선택","selectLevel":"레벨 선택","addExample":"예시 추가","removeExample":"예시 제거","noRulesYet":"아직 추가된 문법 규칙이 없습니다","createdAt":"생성됨","lastModified":"마지막 수정","confirmDelete":"이 문법 규칙을 삭제하시겠습니까?","ruleAdded":"문법 규칙이 성공적으로 추가되었습니다","ruleUpdated":"문법 규칙이 성공적으로 업데이트되었습니다","ruleDeleted":"문법 규칙이 성공적으로 삭제되었습니다","globalMode":"전체","perDateMode":"날짜별","perDateDescription":"날짜 {date}의 문법 규칙 관리","noDateSelected":"날짜별 모드에서 날짜가 선택되지 않았습니다","showVocabulary":"어휘 보기","vocabularyForDate":"{date}의 어휘","noVocabularyFound":"이 날짜의 어휘가 없습니다"},"categories":{"tenses":"시제","conditionals":"조건문","passive":"수동태","modals":"조동사","articles":"관사","prepositions":"전치사","conjunctions":"접속사","other":"기타"},"selectCategory":"카테고리 선택","selectLevel":"레벨 선택","titlePlaceholder":"수업 제목을 입력하세요...","descriptionPlaceholder":"수업에 대한 간단한 설명을 입력하세요...","lessonContent":"수업 내용","theory":"이론","theoryPlaceholder":"수업의 이론 내용을 입력하세요...","structure":"구조","structurePlaceholder":"문법 구조를 입력하세요...","examples":"예시","examplePlaceholder":"예시 {index}","translationPlaceholder":"번역 {index}","addExample":"예시 추가","usageRules":"사용 규칙","ruleTitlePlaceholder":"규칙 제목 {index}","ruleDescriptionPlaceholder":"규칙 설명 {index}","addRule":"규칙 추가","commonMistakes":"흔한 실수","wrongSentencePlaceholder":"잘못된 문장 {index}","correctSentencePlaceholder":"올바른 문장 {index}","explanationPlaceholder":"설명 {index}","addMistake":"흔한 실수 추가","markdownSupported":"기본 Markdown 서식이 지원됩니다.","practice":{"title":"문법 연습","subtitle":"연습할 연습 유형을 선택하세요","chooseExercise":"연습 유형 선택","chooseDescription":"연습을 시작할 연습 유형을 선택하세요","score":"점수","question":"문제","checkAnswer":"답안 확인","next":"다음","finish":"완료","explanation":"설명","reading":{"passage":"지문","readingTime":"읽기 시간","questions":"문제","showHighlights":"하이라이트 표시"},"exercises":{"checkAnswer":"답안 확인","next":"다음","multiple-choice":{"title":"객관식","description":"여러 선택지 중에서 정답을 선택하세요"},"fill-blank":{"title":"빈칸 채우기","description":"올바른 단어로 문장을 완성하세요"},"pronunciation":{"title":"발음","description":"말하기와 발음을 연습하세요"},"reading":{"title":"독해","description":"지문을 읽고 문제에 답하세요","passage":"지문","listen":"듣기","readingTime":"읽기 시간","questions":"문제","true":"참","false":"거짓","yourAnswer":"당신의 답","correctAnswer":"정답","correct":"정답","incorrect":"오답","accuracy":"정확도","showHighlights":"하이라이트 표시","hideHighlights":"하이라이트 숨기기"},"listening":{"title":"듣기","description":"오디오를 듣고 문제에 답하세요","instruction":"오디오를 듣고 문제에 답하세요:","speed":"속도","playsLeft":"남은 재생 횟수","loading":"로딩 중...","questions":"문제","audioUrl":"오디오 URL","audioUrlPlaceholder":"오디오 파일 URL 또는 YouTube URL을 입력하세요...","maxPlays":"최대 재생 횟수","allowNotes":"메모 허용","transcript":"대본","transcriptPlaceholder":"오디오 대본을 입력하세요...","question":"문제","multipleChoice":"객관식","fillBlank":"빈칸 채우기","ordering":"순서 맞추기","addQuestion":"문제 추가","correctAnswerPlaceholder":"정답을 입력하세요...","notesAllowed":"메모 허용됨","takeNotes":"메모하기","notesPlaceholder":"여기에 메모를 작성하세요...","correct":"정답","incorrect":"오답","accuracy":"정확도","showTranscript":"대본 표시","correctAnswer":"정답","audioUrlHint":"직접 오디오 URL 또는 YouTube 비디오 URL을 입력하세요","youtubeDetected":"YouTube URL이 감지되었습니다","youtubeNote":"이 YouTube 비디오에서 오디오를 추출하여 듣기 연습에 사용됩니다"},"writing":{"title":"쓰기","description":"에세이를 쓰고 피드백을 받으세요","instruction":"다음 주제에 대한 단락을 작성하세요:","essay":"에세이","email":"이메일","letter":"편지","paragraph":"단락","requirements":"요구 사항","minWords":"최소 단어 수","timeLimit":"제한 시간","yourResponse":"당신의 답안","words":"단어","timeRemaining":"남은 시간","paragraphPlaceholder":"여기에 단락을 입력하세요...","essayPlaceholder":"여기에 에세이를 작성하세요...","emailPlaceholder":"여기에 이메일을 작성하세요...","letterPlaceholder":"여기에 편지를 작성하세요...","tips":"쓰기 팁","showTips":"팁 보기","hideTips":"팁 숨기기","tip1":"다양한 문장 구조를 사용하세요","tip2":"문법과 맞춤법을 확인하세요","tip3":"아이디어를 연결하는 연결어를 사용하세요","tip4":"서론, 본론, 결론이 있는지 확인하세요","tip5":"주제에 적합한 어휘를 사용하세요","saveDraft":"초안 저장","clear":"지우기","confirmClear":"모든 내용을 지우시겠습니까?","submit":"제출","analyzing":"분석 중...","feedback":"피드백","overallScore":"종합 점수","grammar":"문법","vocabulary":"어휘","coherence":"일관성","taskResponse":"과제 응답","strengths":"강점","improvements":"개선이 필요한 부분","corrections":"구체적인 수정 사항","original":"원본","corrected":"수정됨","explanation":"설명"}},"fillBlank":{"instruction":"적절한 단어로 빈칸을 채우세요:","clear":"모두 지우기"},"pronunciation":{"instruction":"다음 문장을 듣고 따라 하세요:","listen":"듣기","ready":"준비","recording":"녹음 중...","recorded":"녹음 완료","processing":"처리 중...","analyze":"분석","feedback":"피드백","tips":"팁","tryAgain":"다시 시도","yourRecording":"당신의 녹음","microphoneError":"마이크 오류! 마이크 접근 권한을 확인하세요."},"settings":{"title":"연습 설정","difficulty":"난이도","autoPlay":"오디오 자동 재생","autoplayAudio":"오디오 자동 재생","showExplanations":"설명 표시","timeLimit":"제한 시간 (분)","questionCount":"문제 수","close":"닫기","save":"설정 저장","levels":{"easy":"쉬움","medium":"보통","hard":"어려움"}},"exerciseManager":{"title":"연습 관리자","addNew":"새 연습 추가","existing":"기존 연습","exerciseType":"연습 유형","typePlaceholder":"연습 유형을 입력하세요...","titlePlaceholder":"연습 제목을 입력하세요...","description":"설명","descriptionPlaceholder":"연습 설명을 입력하세요...","difficulty":"난이도","duration":"소요 시간","durationPlaceholder":"예: 10-15분","add":"연습 추가","manageQuestions":"문제 관리"},"questionManager":{"title":"문제 관리자","addNew":"새 문제 추가","editQuestion":"문제 편집","addQuestion":"문제 추가","existingQuestions":"기존 문제","noQuestions":"아직 문제가 없습니다","addFirstQuestion":"첫 번째 문제를 추가하세요","question":"문제","questionPlaceholder":"문제를 입력하세요...","options":"선택지","optionPlaceholder":"선택지를 입력하세요...","correctAnswer":"정답","explanation":"설명","explanationPlaceholder":"설명을 입력하세요...","taskType":"쓰기 유형","prompt":"프롬프트","promptPlaceholder":"쓰기 프롬프트를 입력하세요...","requirements":"요구 사항","addRequirement":"요구 사항 추가","requirementPlaceholder":"요구 사항을 입력하세요...","minWords":"최소 단어 수","timeLimit":"제한 시간 (분)","selectCorrectAnswer":"정답 선택"},"progress":{"question":"문제","of":"/","score":"점수","timeRemaining":"남은 시간"},"results":{"title":"연습 결과","score":"당신의 점수","correct":"정답","total":"총개","accuracy":"정확도","timeSpent":"소요 시간","tryAgain":"다시 시도","backToMenu":"메뉴로 돌아가기","reviewAnswers":"답안 검토"},"common":{"submit":"제출","next":"다음","previous":"이전","finish":"완료","check":"답안 확인","checkAnswer":"답안 확인","showAnswer":"답안 보기","explanation":"설명","hint":"힌트","loading":"로딩 중...","noAnswer":"답안이 제공되지 않음","correct":"정답!","incorrect":"오답","skip":"건너뛰기","retry":"다시 시도"}}};
const categories = {"technology":"기술","business":"비즈니스","travel":"여행","food":"음식","health":"건강","education":"교육","sports":"스포츠","entertainment":"엔터테인먼트","science":"과학","art":"예술","music":"음악","literature":"문학","politics":"정치","environment":"환경","fashion":"패션","finance":"금융"};
const dashboard = {"title":"대시보드","description":"학습 진행 상황 개요","welcomeMessage":"영어 학습 여정에 오신 것을 환영합니다!","todaysProgress":"오늘의 진행률","currentLevel":"현재 레벨","quickActions":"빠른 작업","recentActivity":"최근 활동","stats":{"vocabularyLearned":"학습한 어휘","grammarLessons":"문법 수업","currentStreak":"현재 연속 기록","totalTime":"총 시간","days":"일","hours":"시간"},"flashcardStats":{"title":"플래시카드 연습","noData":"연습 세션이 아직 없습니다","startPracticing":"연습을 시작해서 통계를 확인하세요!","sessions":"세션","streak":"연속 기록","days":"일","accuracy":"정확도","bestScore":"최고 점수","totalTime":"총 연습 시간","cardsStudied":"학습한 카드","favoriteMode":"선호하는 모드","weeklyProgress":"이번 주"},"actions":{"addVocabulary":"어휘 추가","practiceFlashcard":"플래시카드 연습","takeQuiz":"퀴즈 풀기","learnGrammar":"문법 학습"},"activity":{"added":"'{word}'을(를) {category}에 추가했습니다","updated":"{category}에서 '{word}'을(를) 업데이트했습니다","justNow":"방금","noActivity":"최근 활동이 없습니다","addFirstVocab":"첫 번째 어휘를 추가하여 시작하세요!"}};
const app$1 = {"title":"영어 학습 앱","titleShort":"영어 앱"};
const time = {"today":"오늘","yesterday":"어제","ago":{"justNow":"방금 전","minutesAgo":"{minutes}분 전","hoursAgo":"{hours}시간 전","daysAgo":"{days}일 전","yesterday":"어제"}};
const practice = {"controls":{"next":"다음","complete":"완료","difficult":"어려움","easy":"쉬움","exit":"나가기"},"timer":{"startPractice":"연습 시작","timeLimit":"문제당 제한 시간: {seconds}초","timeUp":"시간 종료!","timeUpMessage":"이 문제의 시간이 다 되었습니다. 다시 시도하거나 건너뛰세요.","tryAgain":"다시 시도","skip":"건너뛰기"},"exitWarning":{"title":"연습 종료 경고","message":"현재 연습 세션 중입니다. 지금 나가면 진행 상황과 점수를 잃게 됩니다. 정말 나가시겠습니까?","continue":"연습 계속","exit":"연습 종료"}};
const quiz = {"progress":{"question":"문제"},"setup":{"title":"퀴즈 설정","description":"퀴즈 설정을 사용자 정의하세요","type":"퀴즈 유형","level":"난이도","questionCount":"문제 수","timeLimit":"제한 시간 (분)","start":"퀴즈 시작","allLevels":"모든 난이도","unlimited":"무제한"},"types":{"vocabulary":"어휘","grammar":"문법","mixed":"혼합"},"navigation":{"previous":"이전","next":"다음","finish":"완료"},"results":{"completed":"퀴즈 완료!","yourResults":"당신의 결과","score":"점수","correct":"정답","accuracy":"정확도","passed":"합격","failed":"불합격","above":"이상","below":"이하","reviewAnswers":"답안 검토","correctAnswer":"정답","yourAnswer":"당신의 답","noAnswer":"답 없음","explanation":"설명","restartQuiz":"퀴즈 다시 시작"}};
const korean = {"inputHelper":{"title":"한국어 입력 도우미","preview":"미리보기","placeholder":"아래에서 글자를 클릭하거나 입력하세요...","consonants":"자음","vowels":"모음","commonSyllables":"자주 쓰이는 글자","openHelper":"한국어 입력 도우미 열기"},"pronunciationHelper":{"title":"한국어 발음 도우미","preview":"발음 미리보기","placeholder":"아래에서 한국어 발음을 클릭하세요...","consonantSounds":"자음 소리","vowelSounds":"모음 소리","commonPatterns":"자주 쓰이는 패턴","specialChars":"특수 문자","openHelper":"한국어 발음 도우미 열기"},"wordPlaceholder":"한국어 단어를 입력하거나 + 버튼을 클릭하세요","pronunciationPlaceholder":"안-녕-하-세-요"};
const voice = {"selector":{"title":"음성 선택"},"gender":{"female":"여성","male":"남성"},"types":{"female_sweet":"달콤한 여성","female_clear":"명확한 여성","female_professional":"전문적인 여성","male_strong":"강한 남성","male_gentle":"부드러운 남성","male_deep":"깊은 남성","korean_female":"한국어 여성","korean_male":"한국어 남성"},"info":{"name":"음성 이름","language":"언어","gender":"성별"},"test":"음성 테스트","testing":"테스트 중...","testText":"안녕하세요! 이것은 음성 테스트입니다.","testTextKorean":"안녕하세요! 한국어 음성 테스트입니다. 자연스럽게 들리나요?","settings":{"title":"음성 설정","rate":"속도","pitch":"음조","volume":"음량"}};
const ko = {
  common,
  autoGenerator,
  vocabulary,
  flashcard,
  grammar,
  categories,
  dashboard,
  app: app$1,
  time,
  practice,
  quiz,
  korean,
  voice,
};

function getInitialLocale() {
  try {
    const savedLocale = localStorage.getItem("locale");
    return savedLocale === "en" || savedLocale === "vi" || savedLocale === "ko" ? savedLocale : "vi";
  } catch (error) {
    console.warn("localStorage not available, using default locale:", error);
    return "vi";
  }
}
const i18n = createI18n({
  legacy: false,
  locale: getInitialLocale(),
  fallbackLocale: "en",
  globalInjection: true,
  missingWarn: false,
  fallbackWarn: false,
  silentTranslationWarn: true,
  silentFallbackWarn: true,
  messages: {
    en,
    vi,
    ko
  }
});
function setLocale(locale) {
  if (typeof i18n.global.locale === "object" && "value" in i18n.global.locale) {
    i18n.global.locale.value = locale;
  } else {
    i18n.global.locale = locale;
  }
  try {
    localStorage.setItem("locale", locale);
  } catch (error) {
    console.warn("Could not save locale to localStorage:", error);
  }
  document.querySelector("html")?.setAttribute("lang", locale);
}
function getLocale() {
  const locale = typeof i18n.global.locale === "object" && "value" in i18n.global.locale ? i18n.global.locale.value : i18n.global.locale;
  return locale;
}
function toggleLocale() {
  const currentLocale = getLocale();
  const order = ["en", "vi", "ko"];
  const idx = order.indexOf(currentLocale);
  const newLocale = order[(idx + 1) % order.length];
  setLocale(newLocale);
  return newLocale;
}

const app = createApp(_sfc_main$1t);
const pinia = createPinia();
app.use(pinia);
app.use(router);
app.use(i18n);
const options = {
  transition: "Vue-Toastification__bounce",
  maxToasts: 5,
  newestOnTop: true,
  filterBeforeCreate: (toast, toasts) => {
    if (toasts.filter((t) => t.content === toast.content).length !== 0) {
      return false;
    }
    return toast;
  },
  bodyClassName: ["font-sans", "text-sm"],
  toastClassName: ["custom-toast"],
  closeButtonClassName: "dark:text-white dark:hover:text-gray-200"
};
app.use(src_default, options);
const themeStore = useThemeStore();
themeStore.initTheme();
app.mount("#app");

const _imports_0 = "/web-english/assets/logo.svg";

const _hoisted_1$1f = { class: "w-full px-4 sm:px-6 lg:px-8 overflow-visible" };
const _hoisted_2$1c = { class: "flex items-center justify-between h-16 overflow-visible" };
const _hoisted_3$1a = { class: "flex items-center space-x-2 sm:space-x-4" };
const _hoisted_4$16 = ["title"];
const _hoisted_5$13 = ["title", "onKeydown"];
const _hoisted_6$10 = ["aria-label"];
const _hoisted_7$Z = ["aria-label"];
const _hoisted_8$Y = { class: "hidden xl:flex items-center space-x-4 overflow-visible" };
const _hoisted_9$X = { class: "flex space-x-1 relative overflow-visible" };
const _hoisted_10$W = { class: "relative group overflow-visible" };
const _hoisted_11$W = { class: "absolute top-full left-0 w-56 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 ease-out transform translate-y-2 group-hover:translate-y-0 z-[9999] pointer-events-none group-hover:pointer-events-auto pt-1" };
const _hoisted_12$U = { class: "bg-white dark:bg-[#0a0a0a] border border-gray-200 dark:border-dark-bg-mute rounded-lg shadow-lg dark:shadow-black/20 py-2" };
const _hoisted_13$U = { class: "flex items-center space-x-2" };
const _hoisted_14$T = { class: "flex items-center space-x-2" };
const _hoisted_15$N = { class: "flex items-center space-x-2" };
const _hoisted_16$M = { class: "flex items-center space-x-2" };
const _hoisted_17$L = { class: "xl:hidden flex items-center space-x-2" };
const _hoisted_18$J = ["aria-expanded"];
const _hoisted_19$J = {
  key: 0,
  class: "h-6 w-6",
  fill: "none",
  viewBox: "0 0 24 24",
  stroke: "currentColor"
};
const _hoisted_20$I = {
  key: 1,
  class: "h-6 w-6",
  fill: "none",
  viewBox: "0 0 24 24",
  stroke: "currentColor"
};
const _hoisted_21$I = { class: "px-2 pt-2 pb-3 space-y-1" };
const _hoisted_22$G = { class: "space-y-1" };
const _hoisted_23$G = ["aria-expanded", "onKeydown"];
const _hoisted_24$E = { class: "ml-4 space-y-1" };
const _hoisted_25$E = { class: "flex items-center space-x-2" };
const _hoisted_26$C = { class: "flex items-center space-x-2" };
const _hoisted_27$B = { class: "flex items-center space-x-2" };
const _hoisted_28$z = { class: "flex items-center space-x-2" };
const _hoisted_29$x = { class: "absolute bottom-0 left-0 right-0 h-1 bg-gray-200/20 dark:bg-white/10" };
const appearStepMs = 120;
const hideStepMs = 80;
const cyclePauseMs = 1200;
const _sfc_main$1g = /* @__PURE__ */ defineComponent({
  __name: "AppHeader",
  setup(__props) {
    const ThemeToggle = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => ThemeToggle$1),true              ?void 0:void 0))
    );
    const LanguageSwitcher$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => LanguageSwitcher),true              ?void 0:void 0))
    );
    const { t } = useI18n();
    const route = useRoute();
    const router = useRouter();
    const isMobileMenuOpen = ref(false);
    const isScrolled = ref(false);
    const scrollProgress = ref(0);
    const isSmallScreen = ref(false);
    const isHiding = ref(false);
    const animationCycleKey = ref(0);
    let cycleTimer = null;
    const scrollProgressPercentage = ref(0);
    let hasAnimated = false;
    let lastScrollY = 0;
    const enhancedScroll = () => {
      const scrollY = window.scrollY;
      const header = document.querySelector("header");
      if (!header) return;
      const documentHeight = document.documentElement.scrollHeight - window.innerHeight;
      scrollProgressPercentage.value = documentHeight > 0 ? Math.min(scrollY / documentHeight * 100, 100) : 0;
      if (scrollY === 0) {
        isScrolled.value = false;
        header.style.transform = "translateY(0)";
        header.style.opacity = "1";
        header.style.boxShadow = "none";
        hasAnimated = false;
        lastScrollY = 0;
        return;
      }
      const scrollingDown = scrollY > lastScrollY;
      if (scrollingDown && !hasAnimated && scrollY > 50) {
        hasAnimated = true;
        isScrolled.value = true;
        header.style.transform = "translateY(-64px)";
        header.style.opacity = "0.8";
        window.setTimeout(() => {
          header.style.transform = "translateY(0)";
          header.style.opacity = "1";
        }, 170);
        const progress = Math.min(scrollY / 100, 1);
        const shadowIntensity = Math.min(progress * 0.3, 0.2);
        header.style.boxShadow = `0 ${4 + progress * 8}px ${8 + progress * 16}px rgba(0, 0, 0, ${shadowIntensity})`;
      }
      lastScrollY = scrollY;
    };
    onMounted(() => {
      window.addEventListener("scroll", enhancedScroll, { passive: true });
      enhancedScroll();
      const media = window.matchMedia("(max-width: 639px)");
      const updateScreen = (e) => {
        isSmallScreen.value = e ? e.matches : media.matches;
      };
      updateScreen(media);
      if (typeof media.addEventListener === "function") {
        media.addEventListener("change", updateScreen);
      } else if (typeof media.addListener === "function") {
        media.addListener(updateScreen);
      }
      window.__headerMedia__ = { media, updateScreen };
      const runCycle = () => {
        isHiding.value = false;
        const wordsCount = isSmallScreen.value ? titleShortChars.value.length : titleFullChars.value.length;
        const appearDuration = appearStepMs * wordsCount + cyclePauseMs;
        cycleTimer = window.setTimeout(() => {
          isHiding.value = true;
          const hideDuration = hideStepMs * wordsCount + cyclePauseMs;
          cycleTimer = window.setTimeout(() => {
            animationCycleKey.value++;
            runCycle();
          }, hideDuration);
        }, appearDuration);
      };
      runCycle();
      window.__headerCycle__ = () => {
        if (cycleTimer) window.clearTimeout(cycleTimer);
      };
    });
    onUnmounted(() => {
      window.removeEventListener("scroll", enhancedScroll);
      const refObj = window.__headerMedia__;
      if (refObj && refObj.media) {
        const { media, updateScreen } = refObj;
        if (typeof media.removeEventListener === "function") {
          media.removeEventListener("change", updateScreen);
        } else if (typeof media.removeListener === "function") {
          media.removeListener(updateScreen);
        }
        delete window.__headerMedia__;
      }
      const stopCycle = window.__headerCycle__;
      if (typeof stopCycle === "function") {
        stopCycle();
        delete window.__headerCycle__;
      }
    });
    const toggleMobileMenu = () => {
      isMobileMenuOpen.value = !isMobileMenuOpen.value;
    };
    const closeMobileMenu = () => {
      isMobileMenuOpen.value = false;
    };
    const isMobileVocabOpen = ref(false);
    const toggleMobileVocabSubmenu = () => {
      isMobileVocabOpen.value = !isMobileVocabOpen.value;
    };
    watch(isMobileMenuOpen, (open) => {
      if (open) {
        isMobileVocabOpen.value = false;
      }
    });
    const handleLogoClick = async () => {
      try {
        if (route.path === "/dashboard") {
          window.scrollTo({ top: 0, behavior: "smooth" });
        } else {
          if (isMobileMenuOpen.value) closeMobileMenu();
          await router.push("/dashboard");
          window.scrollTo({ top: 0, behavior: "smooth" });
        }
      } catch (e) {
      }
    };
    const fullTitle = computed(() => t("app.title", "English Learning App"));
    const shortTitle = computed(() => t("app.titleShort", "English App"));
    const titleFullChars = computed(() => Array.from(fullTitle.value));
    const titleShortChars = computed(() => Array.from(shortTitle.value));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("header", {
        class: normalizeClass([
          "backdrop-blur-md fixed top-0 left-0 right-0 z-50 transition-all duration-500 ease-out",
          isScrolled.value ? "bg-white/95 dark:bg-black/95 shadow-xl shadow-black/10 dark:shadow-white/10 border-b border-gray-200/10 dark:border-gray-700/10" : "bg-transparent shadow-none border-transparent"
        ]),
        style: normalizeStyle({
          position: "fixed",
          top: 0,
          left: "0px",
          right: "0px",
          width: "100vw",
          maxWidth: "100vw",
          minWidth: "100vw",
          opacity: Math.max(0.9, 1 - scrollProgress.value * 0.1),
          backdropFilter: isScrolled.value ? "blur(12px) saturate(180%)" : "blur(0px)",
          WebkitBackdropFilter: isScrolled.value ? "blur(12px) saturate(180%)" : "blur(0px)",
          margin: 0,
          padding: 0,
          boxSizing: "border-box",
          overflow: "visible"
        })
      }, [
        createBaseVNode("div", _hoisted_1$1f, [
          createBaseVNode("div", _hoisted_2$1c, [
            createBaseVNode("div", _hoisted_3$1a, [
              createBaseVNode("img", {
                alt: "Vue logo",
                src: _imports_0,
                class: "header-logo h-6 w-6 sm:h-8 sm:w-8 cursor-pointer select-none",
                onClick: handleLogoClick,
                title: unref(t)("common.dashboard", "Dashboard")
              }, null, 8, _hoisted_4$16),
              createBaseVNode("h1", {
                class: "text-lg sm:text-xl font-bold text-gray-900 dark:text-white truncate cursor-pointer",
                onClick: handleLogoClick,
                title: unref(t)("common.dashboard", "Dashboard"),
                role: "button",
                tabindex: "0",
                onKeydown: [
                  withKeys(withModifiers(handleLogoClick, ["prevent"]), ["enter"]),
                  withKeys(withModifiers(handleLogoClick, ["prevent"]), ["space"])
                ]
              }, [
                !isSmallScreen.value ? (openBlock(), createElementBlock("span", {
                  class: "logo-words",
                  "aria-label": fullTitle.value,
                  key: `full-${animationCycleKey.value}`
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(titleFullChars.value, (char, index) => {
                    return openBlock(), createElementBlock(Fragment, null, [
                      char === " " ? (openBlock(), createElementBlock("span", {
                        key: `full-${index}-space`,
                        class: normalizeClass(["logo-char", "logo-space", isHiding.value ? "logo-char-hide" : ""]),
                        style: normalizeStyle({ animationDelay: `${index * (isHiding.value ? hideStepMs : appearStepMs)}ms` })
                      }, " ", 6)) : (openBlock(), createElementBlock("span", {
                        key: `full-${index}-${char}`,
                        class: normalizeClass(["logo-char", isHiding.value ? "logo-char-hide" : ""]),
                        style: normalizeStyle({ animationDelay: `${index * (isHiding.value ? hideStepMs : appearStepMs)}ms` })
                      }, toDisplayString$1(char), 7))
                    ], 64);
                  }), 256))
                ], 8, _hoisted_6$10)) : (openBlock(), createElementBlock("span", {
                  class: "logo-words",
                  "aria-label": shortTitle.value,
                  key: `short-${animationCycleKey.value}`
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(titleShortChars.value, (char, index) => {
                    return openBlock(), createElementBlock(Fragment, null, [
                      char === " " ? (openBlock(), createElementBlock("span", {
                        key: `short-${index}-space`,
                        class: normalizeClass(["logo-char", "logo-space", isHiding.value ? "logo-char-hide" : ""]),
                        style: normalizeStyle({ animationDelay: `${index * (isHiding.value ? hideStepMs : appearStepMs)}ms` })
                      }, " ", 6)) : (openBlock(), createElementBlock("span", {
                        key: `short-${index}-${char}`,
                        class: normalizeClass(["logo-char", isHiding.value ? "logo-char-hide" : ""]),
                        style: normalizeStyle({ animationDelay: `${index * (isHiding.value ? hideStepMs : appearStepMs)}ms` })
                      }, toDisplayString$1(char), 7))
                    ], 64);
                  }), 256))
                ], 8, _hoisted_7$Z))
              ], 40, _hoisted_5$13)
            ]),
            createBaseVNode("div", _hoisted_8$Y, [
              createBaseVNode("nav", _hoisted_9$X, [
                createVNode(unref(RouterLink), {
                  to: "/dashboard",
                  class: normalizeClass([
                    "text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-all duration-200 ease-out hover:bg-gray-50 dark:hover:bg-dark-bg-mute focus:outline-none",
                    unref(route).path === "/dashboard" ? "bg-gray-300 dark:bg-dark-bg-mute text-black dark:text-white font-bold" : ""
                  ])
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString$1(unref(t)("common.dashboard", "Dashboard")), 1)
                  ]),
                  _: 1
                }, 8, ["class"]),
                createBaseVNode("div", _hoisted_10$W, [
                  createBaseVNode("div", {
                    class: normalizeClass([
                      "text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-all duration-200 ease-out hover:bg-gray-50 dark:hover:bg-dark-bg-mute focus:outline-none flex items-center space-x-1 select-none cursor-default",
                      unref(route).path.startsWith("/vocabulary") ? "bg-gray-300 dark:bg-dark-bg-mute text-black dark:text-white font-bold" : ""
                    ]),
                    "aria-haspopup": "true",
                    "aria-expanded": "false"
                  }, [
                    createBaseVNode("span", null, toDisplayString$1(unref(t)("common.vocabulary", "Vocabulary")), 1),
                    _cache[0] || (_cache[0] = createBaseVNode("svg", {
                      class: "w-4 h-4 transition-transform duration-200 group-hover:rotate-180",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z",
                        "clip-rule": "evenodd"
                      })
                    ], -1))
                  ], 2),
                  createBaseVNode("div", _hoisted_11$W, [
                    createBaseVNode("div", _hoisted_12$U, [
                      createVNode(unref(RouterLink), {
                        to: "/vocabulary",
                        class: normalizeClass([
                          "block px-4 py-2 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-50 dark:hover:bg-dark-bg-mute transition-colors duration-150",
                          unref(route).path === "/vocabulary" ? "bg-gray-100 dark:bg-gray-custom text-black dark:text-white font-medium" : ""
                        ])
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_13$U, [
                            _cache[1] || (_cache[1] = createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", { d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" })
                            ], -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.manageWords", "Manage Words")), 1)
                          ])
                        ]),
                        _: 1
                      }, 8, ["class"]),
                      createVNode(unref(RouterLink), {
                        to: "/vocabulary/questions",
                        class: normalizeClass([
                          "block px-4 py-2 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-50 dark:hover:bg-dark-bg-mute transition-colors duration-150",
                          unref(route).path === "/vocabulary/questions" ? "bg-gray-100 dark:bg-gray-custom text-black dark:text-white font-medium" : ""
                        ])
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_14$T, [
                            _cache[2] || (_cache[2] = createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", {
                                "fill-rule": "evenodd",
                                d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z",
                                "clip-rule": "evenodd"
                              })
                            ], -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.manageQuestions", "Manage Questions")), 1)
                          ])
                        ]),
                        _: 1
                      }, 8, ["class"]),
                      createVNode(unref(RouterLink), {
                        to: "/vocabulary/examples",
                        class: normalizeClass([
                          "block px-4 py-2 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-50 dark:hover:bg-dark-bg-mute transition-colors duration-150",
                          unref(route).path === "/vocabulary/examples" ? "bg-gray-100 dark:bg-gray-custom text-black dark:text-white font-medium" : ""
                        ])
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_15$N, [
                            _cache[3] || (_cache[3] = createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", {
                                "fill-rule": "evenodd",
                                d: "M4 4a2 2 0 012-2h8a2 2 0 012 2v12a1 1 0 110 2h-3a1 1 0 01-1-1v-2a1 1 0 00-1-1H9a1 1 0 00-1 1v2a1 1 0 01-1 1H4a1 1 0 110-2V4zm3 1h2v2H7V5zm2 4H7v2h2V9zm2-4h2v2h-2V5zm2 4h-2v2h2V9z",
                                "clip-rule": "evenodd"
                              })
                            ], -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.manageExamples", "Manage Examples")), 1)
                          ])
                        ]),
                        _: 1
                      }, 8, ["class"]),
                      _cache[5] || (_cache[5] = createBaseVNode("div", { class: "border-t border-gray-200 dark:border-dark-bg-mute my-1" }, null, -1)),
                      createVNode(unref(RouterLink), {
                        to: "/vocabulary/generator",
                        class: normalizeClass([
                          "block px-4 py-2 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-50 dark:hover:bg-dark-bg-mute transition-colors duration-150",
                          unref(route).path === "/vocabulary/generator" ? "bg-gray-100 dark:bg-gray-custom text-black dark:text-white font-medium" : ""
                        ])
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_16$M, [
                            _cache[4] || (_cache[4] = createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", {
                                "fill-rule": "evenodd",
                                d: "M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z",
                                "clip-rule": "evenodd"
                              })
                            ], -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.autoGenerator", "Auto Generator")), 1)
                          ])
                        ]),
                        _: 1
                      }, 8, ["class"])
                    ])
                  ])
                ]),
                createVNode(unref(RouterLink), {
                  to: "/grammar",
                  class: normalizeClass([
                    "text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-all duration-200 ease-out hover:bg-gray-50 dark:hover:bg-dark-bg-mute focus:outline-none",
                    unref(route).path === "/grammar" ? "bg-gray-300 dark:bg-dark-bg-mute text-black dark:text-white font-bold" : ""
                  ])
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString$1(unref(t)("common.grammar", "Grammar")), 1)
                  ]),
                  _: 1
                }, 8, ["class"]),
                createVNode(unref(RouterLink), {
                  to: "/practice/flashcard",
                  class: normalizeClass([
                    "text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors focus:outline-none",
                    unref(route).path === "/practice/flashcard" ? "bg-gray-300 dark:bg-dark-bg-mute text-black dark:text-white font-bold" : ""
                  ])
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString$1(unref(t)("common.practice", "Practice")), 1)
                  ]),
                  _: 1
                }, 8, ["class"])
              ]),
              createVNode(unref(LanguageSwitcher$1)),
              createVNode(unref(ThemeToggle))
            ]),
            createBaseVNode("div", _hoisted_17$L, [
              createVNode(unref(LanguageSwitcher$1)),
              createVNode(unref(ThemeToggle)),
              createBaseVNode("button", {
                onClick: toggleMobileMenu,
                class: "inline-flex items-center justify-center p-2 rounded-md text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-blue-500 transition-all duration-200 ease-out transform hover:scale-105 active:scale-95",
                "aria-expanded": isMobileMenuOpen.value,
                "aria-label": "Toggle navigation menu"
              }, [
                !isMobileMenuOpen.value ? (openBlock(), createElementBlock("svg", _hoisted_19$J, _cache[6] || (_cache[6] = [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M4 6h16M4 12h16M4 18h16"
                  }, null, -1)
                ]))) : (openBlock(), createElementBlock("svg", _hoisted_20$I, _cache[7] || (_cache[7] = [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M6 18L18 6M6 6l12 12"
                  }, null, -1)
                ])))
              ], 8, _hoisted_18$J)
            ])
          ]),
          withDirectives(createBaseVNode("div", {
            class: normalizeClass(["xl:hidden border-t border-gray-200 dark:border-gray-700 bg-white dark:bg-black transition-all duration-300 ease-out transform", isMobileMenuOpen.value ? "opacity-100 translate-y-0" : "opacity-0 -translate-y-2 pointer-events-none"])
          }, [
            createBaseVNode("nav", _hoisted_21$I, [
              createVNode(unref(RouterLink), {
                to: "/dashboard",
                onClick: closeMobileMenu,
                class: normalizeClass([
                  "block px-3 py-2 rounded-md text-base font-medium text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-gray-800 transition-all duration-200 ease-out transform hover:translate-x-1 hover:scale-105 focus:outline-none",
                  unref(route).path === "/dashboard" ? "bg-gray-300 dark:bg-gray-700 text-black dark:text-white font-bold" : ""
                ])
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(unref(t)("common.dashboard", "Dashboard")), 1)
                ]),
                _: 1
              }, 8, ["class"]),
              createBaseVNode("div", _hoisted_22$G, [
                createBaseVNode("div", {
                  class: normalizeClass([
                    "px-3 py-2 rounded-md text-base font-medium text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors focus:outline-none select-none flex items-center justify-between",
                    unref(route).path.startsWith("/vocabulary") ? "bg-gray-300 dark:bg-dark-bg-mute text-black dark:text-white font-bold" : ""
                  ]),
                  "aria-haspopup": "true",
                  "aria-expanded": isMobileVocabOpen.value,
                  role: "button",
                  tabindex: "0",
                  onClick: toggleMobileVocabSubmenu,
                  onKeydown: [
                    withKeys(withModifiers(toggleMobileVocabSubmenu, ["prevent"]), ["enter"]),
                    withKeys(withModifiers(toggleMobileVocabSubmenu, ["prevent"]), ["space"])
                  ]
                }, [
                  createBaseVNode("span", null, toDisplayString$1(unref(t)("common.vocabulary", "Vocabulary")), 1),
                  (openBlock(), createElementBlock("svg", {
                    class: normalizeClass(["w-4 h-4 ml-2 transform transition-transform duration-200", isMobileVocabOpen.value ? "rotate-180" : "rotate-0"]),
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, _cache[8] || (_cache[8] = [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z",
                      "clip-rule": "evenodd"
                    }, null, -1)
                  ]), 2))
                ], 42, _hoisted_23$G),
                withDirectives(createBaseVNode("div", _hoisted_24$E, [
                  createVNode(unref(RouterLink), {
                    to: "/vocabulary",
                    onClick: closeMobileMenu,
                    class: "block px-3 py-2 rounded-md text-sm text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors focus:outline-none"
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", _hoisted_25$E, [
                        _cache[9] || (_cache[9] = createBaseVNode("svg", {
                          class: "w-3 h-3",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", { d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" })
                        ], -1)),
                        createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.manageWords", "Manage Words")), 1)
                      ])
                    ]),
                    _: 1
                  }),
                  createVNode(unref(RouterLink), {
                    to: "/vocabulary/questions",
                    onClick: closeMobileMenu,
                    class: "block px-3 py-2 rounded-md text-sm text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors focus:outline-none"
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", _hoisted_26$C, [
                        _cache[10] || (_cache[10] = createBaseVNode("svg", {
                          class: "w-3 h-3",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z",
                            "clip-rule": "evenodd"
                          })
                        ], -1)),
                        createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.manageQuestions", "Manage Questions")), 1)
                      ])
                    ]),
                    _: 1
                  }),
                  createVNode(unref(RouterLink), {
                    to: "/vocabulary/examples",
                    onClick: closeMobileMenu,
                    class: "block px-3 py-2 rounded-md text-sm text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors focus:outline-none"
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", _hoisted_27$B, [
                        _cache[11] || (_cache[11] = createBaseVNode("svg", {
                          class: "w-3 h-3",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M4 4a2 2 0 012-2h8a2 2 0 012 2v12a1 1 0 110 2h-3a1 1 0 01-1-1v-2a1 1 0 00-1-1H9a1 1 0 00-1 1v2a1 1 0 01-1 1H4a1 1 0 110-2V4zm3 1h2v2H7V5zm2 4H7v2h2V9zm2-4h2v2h-2V5zm2 4h-2v2h2V9z",
                            "clip-rule": "evenodd"
                          })
                        ], -1)),
                        createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.manageExamples", "Manage Examples")), 1)
                      ])
                    ]),
                    _: 1
                  }),
                  createVNode(unref(RouterLink), {
                    to: "/vocabulary/generator",
                    onClick: closeMobileMenu,
                    class: "block px-3 py-2 rounded-md text-sm text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors focus:outline-none"
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", _hoisted_28$z, [
                        _cache[12] || (_cache[12] = createBaseVNode("svg", {
                          class: "w-3 h-3",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z",
                            "clip-rule": "evenodd"
                          })
                        ], -1)),
                        createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.autoGenerator", "Auto Generator")), 1)
                      ])
                    ]),
                    _: 1
                  })
                ], 512), [
                  [vShow, isMobileVocabOpen.value]
                ])
              ]),
              createVNode(unref(RouterLink), {
                to: "/grammar",
                onClick: closeMobileMenu,
                class: normalizeClass([
                  "block px-3 py-2 rounded-md text-base font-medium text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors focus:outline-none",
                  unref(route).path === "/grammar" ? "bg-gray-300 dark:bg-dark-bg-mute text-black dark:text-white font-bold" : ""
                ])
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(unref(t)("common.grammar", "Grammar")), 1)
                ]),
                _: 1
              }, 8, ["class"]),
              createVNode(unref(RouterLink), {
                to: "/practice/flashcard",
                onClick: closeMobileMenu,
                class: normalizeClass([
                  "block px-3 py-2 rounded-md text-base font-medium text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors focus:outline-none",
                  unref(route).path === "/practice/flashcard" ? "bg-gray-300 dark:bg-dark-bg-mute text-black dark:text-white font-bold" : ""
                ])
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(unref(t)("common.practice", "Practice")), 1)
                ]),
                _: 1
              }, 8, ["class"])
            ])
          ], 2), [
            [vShow, isMobileMenuOpen.value]
          ])
        ]),
        createBaseVNode("div", _hoisted_29$x, [
          createBaseVNode("div", {
            class: "h-full bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 dark:from-blue-400 dark:via-purple-400 dark:to-pink-400 transition-all duration-150 ease-out",
            style: normalizeStyle({ width: `${scrollProgressPercentage.value}%` })
          }, null, 4)
        ])
      ], 6);
    };
  }
});

const AppHeader = /* @__PURE__ */ _export_sfc(_sfc_main$1g, [["__scopeId", "data-v-d44f8080"]]);

const AppHeader$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: AppHeader
}, Symbol.toStringTag, { value: 'Module' }));

const useScrollStore = defineStore("scroll", () => {
  const scrollY = ref(0);
  const showBackToTop = ref(false);
  const isScrolling = ref(false);
  const SCROLL_THRESHOLD = 300;
  let scrollTimer = null;
  const handleScroll = () => {
    scrollY.value = window.scrollY;
    showBackToTop.value = scrollY.value > SCROLL_THRESHOLD;
    isScrolling.value = true;
    if (scrollTimer) {
      clearTimeout(scrollTimer);
    }
    scrollTimer = setTimeout(() => {
      isScrolling.value = false;
    }, 150);
  };
  const scrollToTop = () => {
    window.scrollTo({
      top: 0,
      behavior: "smooth"
    });
  };
  const initScrollListener = () => {
    window.addEventListener("scroll", handleScroll, { passive: true });
    handleScroll();
  };
  const removeScrollListener = () => {
    window.removeEventListener("scroll", handleScroll);
    if (scrollTimer) {
      clearTimeout(scrollTimer);
      scrollTimer = null;
    }
  };
  const scrollPercentage = () => {
    const documentHeight = document.documentElement.scrollHeight - window.innerHeight;
    return documentHeight > 0 ? Math.min(scrollY.value / documentHeight * 100, 100) : 0;
  };
  const isNearTop = () => scrollY.value < 100;
  const isNearBottom = () => {
    const documentHeight = document.documentElement.scrollHeight;
    const viewportHeight = window.innerHeight;
    return scrollY.value + viewportHeight >= documentHeight - 100;
  };
  return {
    // State
    scrollY,
    showBackToTop,
    isScrolling,
    // Actions
    scrollToTop,
    initScrollListener,
    removeScrollListener,
    // Getters
    scrollPercentage,
    isNearTop,
    isNearBottom
  };
});

const _hoisted_1$1e = { class: "fixed bottom-6 z-50 left-1/2 -translate-x-[calc(100%+1rem)] sm:left-1/2 sm:-translate-x-[calc(100%+4px)] lg:left-6 lg:translate-x-0" };
const _hoisted_2$1b = { class: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-900 dark:bg-dark-bg rounded shadow-lg whitespace-nowrap z-10 pointer-events-none" };
const _hoisted_3$19 = ["aria-label"];
const _hoisted_4$15 = {
  key: 0,
  class: "absolute inset-0 w-full h-full -rotate-90",
  viewBox: "0 0 100 100"
};
const _hoisted_5$12 = ["stroke-dasharray", "stroke-dashoffset"];
const _sfc_main$1f = /* @__PURE__ */ defineComponent({
  __name: "BackToTop",
  props: {
    showProgress: { type: Boolean, default: false }
  },
  setup(__props) {
    const { t } = useI18n();
    const scrollStore = useScrollStore();
    const modalStore = useModalStore();
    const showTooltip = ref(false);
    const showBackToTop = computed(() => {
      return scrollStore.showBackToTop && !modalStore.shouldHideBackToTop;
    });
    const scrollPercentage = computed(() => scrollStore.scrollPercentage());
    const circumference = computed(() => 2 * Math.PI * 45);
    const handleScrollToTop = () => {
      showTooltip.value = false;
      scrollStore.scrollToTop();
    };
    const displayPercent = computed(() => Math.round(scrollPercentage.value));
    const tooltipText = computed(() => {
      const key = "common.backToTopTooltip";
      const translated = t(key, { percent: displayPercent.value });
      const isMissing = translated === key || translated.includes("{percent}");
      return isMissing ? `Back to Top (${displayPercent.value}%)` : translated;
    });
    onMounted(() => {
      scrollStore.initScrollListener();
    });
    onUnmounted(() => {
      scrollStore.removeScrollListener();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        name: "fade-scale",
        "enter-active-class": "fade-scale-enter-active",
        "enter-from-class": "fade-scale-enter-from",
        "leave-active-class": "fade-scale-leave-active",
        "leave-to-class": "fade-scale-leave-to"
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", _hoisted_1$1e, [
            createVNode(Transition, {
              name: "fade",
              "enter-active-class": "transition-opacity duration-200",
              "enter-from-class": "opacity-0",
              "leave-active-class": "transition-opacity duration-200",
              "leave-to-class": "opacity-0"
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", _hoisted_2$1b, [
                  createTextVNode(toDisplayString$1(tooltipText.value) + " ", 1),
                  _cache[2] || (_cache[2] = createBaseVNode("div", { class: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900 dark:border-t-dark-bg" }, null, -1))
                ], 512), [
                  [vShow, showTooltip.value]
                ])
              ]),
              _: 1
            }),
            createBaseVNode("button", {
              onClick: handleScrollToTop,
              onMouseenter: _cache[0] || (_cache[0] = ($event) => showTooltip.value = true),
              onMouseleave: _cache[1] || (_cache[1] = ($event) => showTooltip.value = false),
              class: "group w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white rounded-full shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-300 flex items-center justify-center",
              "aria-label": unref(t)("common.backToTop")
            }, [
              _cache[4] || (_cache[4] = createBaseVNode("svg", {
                class: "w-6 h-6 sm:w-7 sm:h-7 md:w-8 md:h-8 transform group-hover:-translate-y-0.5 transition-transform duration-200",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24",
                xmlns: "http://www.w3.org/2000/svg"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M5 10l7-7m0 0l7 7m-7-7v18"
                })
              ], -1)),
              _ctx.showProgress ? (openBlock(), createElementBlock("svg", _hoisted_4$15, [
                _cache[3] || (_cache[3] = createBaseVNode("circle", {
                  cx: "50",
                  cy: "50",
                  r: "45",
                  fill: "none",
                  stroke: "currentColor",
                  "stroke-width": "2",
                  opacity: "0.3"
                }, null, -1)),
                createBaseVNode("circle", {
                  cx: "50",
                  cy: "50",
                  r: "45",
                  fill: "none",
                  stroke: "currentColor",
                  "stroke-width": "2",
                  "stroke-dasharray": circumference.value,
                  "stroke-dashoffset": circumference.value - scrollPercentage.value / 100 * circumference.value,
                  class: "transition-all duration-300"
                }, null, 8, _hoisted_5$12)
              ])) : createCommentVNode("", true)
            ], 40, _hoisted_3$19)
          ], 512), [
            [vShow, showBackToTop.value]
          ])
        ]),
        _: 1
      });
    };
  }
});

const BackToTop = /* @__PURE__ */ _export_sfc(_sfc_main$1f, [["__scopeId", "data-v-c3ec54c8"]]);

const BackToTop$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: BackToTop
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1e = /* @__PURE__ */ defineComponent({
  __name: "LazyLoadComponent",
  props: {
    animationType: { default: "fade-up" },
    threshold: { default: 0.99 },
    rootMargin: { default: "0px" }
  },
  setup(__props) {
    const props = __props;
    const elementRef = ref();
    const isVisible = ref(false);
    let observer = null;
    let isFullyVisible = false;
    onMounted(() => {
      if (elementRef.value) {
        observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              const ratio = entry.intersectionRatio;
              const showThreshold = props.threshold;
              const hideThreshold = Math.max(0, props.threshold - 0.1);
              if (ratio >= showThreshold) {
                if (!isFullyVisible) {
                  isFullyVisible = true;
                  isVisible.value = true;
                }
              } else if (ratio <= hideThreshold) {
                if (isFullyVisible) {
                  isFullyVisible = false;
                  isVisible.value = false;
                }
              }
            });
          },
          {
            threshold: [0, 0.25, 0.5, 0.75, 0.9, 0.99, 1],
            // Theo dõi nhiều ngưỡng để phát hiện chính xác
            rootMargin: props.rootMargin
          }
        );
        observer.observe(elementRef.value);
      }
    });
    onUnmounted(() => {
      if (observer && elementRef.value) {
        observer.unobserve(elementRef.value);
        observer.disconnect();
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "elementRef",
        ref: elementRef,
        class: normalizeClass([
          "lazy-wrapper",
          _ctx.animationType,
          { "is-visible": isVisible.value, "is-hidden": !isVisible.value }
        ])
      }, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 2);
    };
  }
});

const LazyLoadComponent = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["__scopeId", "data-v-e3e20eb0"]]);

const LazyLoadComponent$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: LazyLoadComponent
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$1d = { class: "relative bg-white/70 dark:bg-[#0a0a0a]/70 backdrop-blur-xl shadow-lg border-b border-white/20 dark:border-white/10 overflow-hidden" };
const _hoisted_2$1a = { class: "max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8 relative" };
const _hoisted_3$18 = { class: "flex items-center space-x-4 mb-4" };
const _hoisted_4$14 = { class: "flex-1" };
const _hoisted_5$11 = { class: "text-3xl sm:text-4xl lg:text-5xl font-black bg-gradient-to-r from-blue-600 via-purple-600 to-pink-600 dark:from-blue-400 dark:via-purple-400 dark:to-pink-400 bg-clip-text text-transparent animate-fade-in-up" };
const _hoisted_6$$ = { class: "flex items-center mt-2 space-x-2" };
const _hoisted_7$Y = { class: "text-sm sm:text-base text-gray-600 dark:text-gray-300 font-medium" };
const _sfc_main$1d = /* @__PURE__ */ defineComponent({
  __name: "DashboardHeader",
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1d, [
        _cache[3] || (_cache[3] = createStaticVNode('<div class="absolute inset-0 bg-gradient-to-r from-blue-400/10 via-purple-500/10 to-pink-500/10 dark:from-blue-500/20 dark:via-purple-500/20 dark:to-pink-500/20"></div><div class="absolute top-0 left-0 w-full h-full"><div class="absolute top-0 left-1/4 w-2 h-2 bg-blue-400 dark:bg-blue-300 rounded-full animate-ping opacity-60"></div><div class="absolute top-4 right-1/3 w-1 h-1 bg-purple-400 dark:bg-purple-300 rounded-full animate-pulse"></div><div class="absolute bottom-2 left-1/2 w-1.5 h-1.5 bg-pink-400 dark:bg-pink-300 rounded-full animate-bounce"></div></div>', 2)),
        createBaseVNode("div", _hoisted_2$1a, [
          createBaseVNode("div", _hoisted_3$18, [
            _cache[1] || (_cache[1] = createStaticVNode('<div class="relative"><div class="w-12 h-12 bg-gradient-to-br from-blue-500 to-purple-600 rounded-2xl flex items-center justify-center shadow-lg transform hover:rotate-12 transition-transform duration-300"><svg class="w-6 h-6 text-white animate-pulse" fill="currentColor" viewBox="0 0 20 20"><path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div><div class="absolute -top-1 -right-1 w-4 h-4 bg-gradient-to-br from-yellow-400 to-orange-500 rounded-full animate-bounce"></div></div>', 1)),
            createBaseVNode("div", _hoisted_4$14, [
              createBaseVNode("h1", _hoisted_5$11, toDisplayString$1(unref(t)("dashboard.title", "Dashboard")), 1),
              createBaseVNode("div", _hoisted_6$$, [
                _cache[0] || (_cache[0] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                  createBaseVNode("div", { class: "w-2 h-2 bg-gradient-to-r from-green-400 to-blue-500 rounded-full" })
                ], -1)),
                createBaseVNode("p", _hoisted_7$Y, toDisplayString$1(unref(t)("dashboard.description", "Here is a summary of your learning progress.")), 1)
              ])
            ])
          ]),
          _cache[2] || (_cache[2] = createStaticVNode('<div class="relative"><div class="h-1 bg-gray-200 dark:bg-white/10 rounded-full overflow-hidden"><div class="h-full bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 rounded-full animate-progress-slide"></div></div><div class="absolute -top-1 left-0 w-3 h-3 bg-gradient-to-br from-blue-400 to-blue-600 rounded-full animate-bounce-slow"></div></div><div class="absolute inset-0 pointer-events-none"><div class="absolute top-1/4 left-1/6 w-1 h-1 bg-yellow-400 rounded-full animate-float"></div><div class="absolute top-3/4 right-1/4 w-0.5 h-0.5 bg-green-400 rounded-full animate-float-delay"></div><div class="absolute top-1/2 right-1/6 w-1.5 h-1.5 bg-blue-400 rounded-full animate-float-slow"></div></div>', 2))
        ])
      ]);
    };
  }
});

const DashboardHeader = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$1d
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$1c = { class: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6 mb-8" };
const _hoisted_2$19 = {
  class: "group relative bg-white/70 dark:bg-[#0a0a0a]/70 backdrop-blur-lg overflow-hidden shadow-lg hover:shadow-2xl rounded-2xl border border-white/30 dark:border-white/10 transition-all duration-500 hover:scale-105 hover:-translate-y-3 animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_3$17 = { class: "relative p-6" };
const _hoisted_4$13 = { class: "space-y-2" };
const _hoisted_5$10 = { class: "text-sm font-semibold text-blue-600 dark:text-blue-400 uppercase tracking-wide" };
const _hoisted_6$_ = { class: "text-3xl font-bold text-gray-900 dark:text-white counter-animate" };
const _hoisted_7$X = {
  class: "group relative bg-white/70 dark:bg-[#0a0a0a]/70 backdrop-blur-lg overflow-hidden shadow-lg hover:shadow-2xl rounded-2xl border border-white/30 dark:border-white/10 transition-all duration-500 hover:scale-105 hover:-translate-y-3 animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_8$X = { class: "relative p-6" };
const _hoisted_9$W = { class: "space-y-2" };
const _hoisted_10$V = { class: "text-sm font-semibold text-green-600 dark:text-green-400 uppercase tracking-wide" };
const _hoisted_11$V = { class: "text-3xl font-bold text-gray-900 dark:text-white counter-animate" };
const _hoisted_12$T = {
  class: "group relative bg-white/70 dark:bg-[#0a0a0a]/70 backdrop-blur-lg overflow-hidden shadow-lg hover:shadow-2xl rounded-2xl border border-white/30 dark:border-white/10 transition-all duration-500 hover:scale-105 hover:-translate-y-3 animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_13$T = { class: "relative p-6" };
const _hoisted_14$S = { class: "space-y-2" };
const _hoisted_15$M = { class: "text-sm font-semibold text-orange-600 dark:text-orange-400 uppercase tracking-wide" };
const _hoisted_16$L = { class: "text-3xl font-bold text-gray-900 dark:text-white counter-animate" };
const _hoisted_17$K = { class: "text-lg font-medium" };
const _hoisted_18$I = {
  class: "group relative bg-white/70 dark:bg-[#0a0a0a]/70 backdrop-blur-lg overflow-hidden shadow-lg hover:shadow-2xl rounded-2xl border border-white/30 dark:border-white/10 transition-all duration-500 hover:scale-105 hover:-translate-y-3 animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_19$I = { class: "relative p-6" };
const _hoisted_20$H = { class: "space-y-2" };
const _hoisted_21$H = { class: "text-sm font-semibold text-purple-600 dark:text-purple-400 uppercase tracking-wide" };
const _hoisted_22$F = { class: "text-3xl font-bold text-gray-900 dark:text-white counter-animate" };
const _hoisted_23$F = { class: "text-lg font-medium" };
const _sfc_main$1c = /* @__PURE__ */ defineComponent({
  __name: "DashboardStats",
  props: {
    stats: {}
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1c, [
        createBaseVNode("div", _hoisted_2$19, [
          _cache[2] || (_cache[2] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-br from-blue-500/10 to-blue-600/20 dark:from-blue-400/20 dark:to-blue-500/30" }, null, -1)),
          createBaseVNode("div", _hoisted_3$17, [
            _cache[1] || (_cache[1] = createStaticVNode('<div class="flex items-center justify-between mb-4"><div class="flex-shrink-0"><div class="w-12 h-12 bg-gradient-to-br from-blue-500 to-blue-600 rounded-2xl flex items-center justify-center shadow-lg transform group-hover:rotate-12 group-hover:scale-110 transition-all duration-300"><svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20"><path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div></div><div class="opacity-0 group-hover:opacity-100 transition-opacity duration-300"><div class="w-8 h-8 bg-blue-100 dark:bg-blue-900/30 rounded-full flex items-center justify-center"><svg class="w-4 h-4 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path></svg></div></div></div>', 1)),
            createBaseVNode("div", _hoisted_4$13, [
              createBaseVNode("dt", _hoisted_5$10, toDisplayString$1(unref(t)("dashboard.stats.vocabularyLearned", "Vocabulary Learned")), 1),
              createBaseVNode("dd", _hoisted_6$_, toDisplayString$1(_ctx.stats.vocabularyLearned), 1),
              _cache[0] || (_cache[0] = createBaseVNode("div", { class: "w-full bg-blue-100 dark:bg-blue-900/30 rounded-full h-2" }, [
                createBaseVNode("div", {
                  class: "bg-gradient-to-r from-blue-500 to-blue-600 h-2 rounded-full animate-progress-slide",
                  style: { "width": "75%" }
                })
              ], -1))
            ])
          ]),
          _cache[3] || (_cache[3] = createBaseVNode("div", { class: "absolute top-4 right-4 w-2 h-2 bg-blue-400 rounded-full animate-ping" }, null, -1))
        ]),
        createBaseVNode("div", _hoisted_7$X, [
          _cache[6] || (_cache[6] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-br from-green-500/10 to-green-600/20 dark:from-green-400/20 dark:to-green-500/30" }, null, -1)),
          createBaseVNode("div", _hoisted_8$X, [
            _cache[5] || (_cache[5] = createStaticVNode('<div class="flex items-center justify-between mb-4"><div class="flex-shrink-0"><div class="w-12 h-12 bg-gradient-to-br from-green-500 to-green-600 rounded-2xl flex items-center justify-center shadow-lg transform group-hover:rotate-12 group-hover:scale-110 transition-all duration-300"><svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20"><path d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg></div></div><div class="opacity-0 group-hover:opacity-100 transition-opacity duration-300"><div class="w-8 h-8 bg-green-100 dark:bg-green-900/30 rounded-full flex items-center justify-center"><svg class="w-4 h-4 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg></div></div></div>', 1)),
            createBaseVNode("div", _hoisted_9$W, [
              createBaseVNode("dt", _hoisted_10$V, toDisplayString$1(unref(t)("dashboard.stats.grammarLessons", "Grammar Lessons")), 1),
              createBaseVNode("dd", _hoisted_11$V, toDisplayString$1(_ctx.stats.grammarLessons), 1),
              _cache[4] || (_cache[4] = createBaseVNode("div", { class: "w-full bg-green-100 dark:bg-green-900/30 rounded-full h-2" }, [
                createBaseVNode("div", {
                  class: "bg-gradient-to-r from-green-500 to-green-600 h-2 rounded-full animate-progress-slide",
                  style: { "width": "60%" }
                })
              ], -1))
            ])
          ]),
          _cache[7] || (_cache[7] = createBaseVNode("div", { class: "absolute top-4 right-4 w-2 h-2 bg-green-400 rounded-full animate-ping" }, null, -1))
        ]),
        createBaseVNode("div", _hoisted_12$T, [
          _cache[10] || (_cache[10] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-br from-yellow-500/10 to-orange-600/20 dark:from-yellow-400/20 dark:to-orange-500/30" }, null, -1)),
          createBaseVNode("div", _hoisted_13$T, [
            _cache[9] || (_cache[9] = createStaticVNode('<div class="flex items-center justify-between mb-4"><div class="flex-shrink-0"><div class="w-12 h-12 bg-gradient-to-br from-yellow-500 to-orange-600 rounded-2xl flex items-center justify-center shadow-lg transform group-hover:rotate-12 group-hover:scale-110 transition-all duration-300"><svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20"><path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3z"></path></svg></div></div><div class="opacity-0 group-hover:opacity-100 transition-opacity duration-300"><div class="w-8 h-8 bg-orange-100 dark:bg-orange-900/30 rounded-full flex items-center justify-center"><svg class="w-4 h-4 text-orange-600 dark:text-orange-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975 0 0120 13a7.975 7.975 0 01-2.343 5.657z"></path></svg></div></div></div>', 1)),
            createBaseVNode("div", _hoisted_14$S, [
              createBaseVNode("dt", _hoisted_15$M, toDisplayString$1(unref(t)("dashboard.stats.currentStreak", "Current Streak")), 1),
              createBaseVNode("dd", _hoisted_16$L, [
                createTextVNode(toDisplayString$1(_ctx.stats.currentStreak) + " ", 1),
                createBaseVNode("span", _hoisted_17$K, toDisplayString$1(unref(t)("dashboard.stats.days", "days")), 1)
              ]),
              _cache[8] || (_cache[8] = createBaseVNode("div", { class: "w-full bg-orange-100 dark:bg-orange-900/30 rounded-full h-2" }, [
                createBaseVNode("div", {
                  class: "bg-gradient-to-r from-yellow-500 to-orange-600 h-2 rounded-full animate-progress-slide",
                  style: { "width": "85%" }
                })
              ], -1))
            ])
          ]),
          _cache[11] || (_cache[11] = createBaseVNode("div", { class: "absolute top-4 right-4 w-2 h-2 bg-orange-400 rounded-full animate-ping" }, null, -1))
        ]),
        createBaseVNode("div", _hoisted_18$I, [
          _cache[14] || (_cache[14] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-br from-purple-500/10 to-purple-600/20 dark:from-purple-400/20 dark:to-purple-500/30" }, null, -1)),
          createBaseVNode("div", _hoisted_19$I, [
            _cache[13] || (_cache[13] = createStaticVNode('<div class="flex items-center justify-between mb-4"><div class="flex-shrink-0"><div class="w-12 h-12 bg-gradient-to-br from-purple-500 to-purple-600 rounded-2xl flex items-center justify-center shadow-lg transform group-hover:rotate-12 group-hover:scale-110 transition-all duration-300"><svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2C5.03 2 1 6.03 1 11s4.03 9 9 9 9-4.03 9-9-4.03-9-9-9zm0 16c-3.86 0-7-3.14-7-7s3.14-7 7-7 7 3.14 7 7-3.14 7-7 7zm.5-13H9v6l5.25 3.15.75-1.23-4.5-2.67z"></path></svg></div></div><div class="opacity-0 group-hover:opacity-100 transition-opacity duration-300"><div class="w-8 h-8 bg-purple-100 dark:bg-purple-900/30 rounded-full flex items-center justify-center"><svg class="w-4 h-4 text-purple-600 dark:text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div></div></div>', 1)),
            createBaseVNode("div", _hoisted_20$H, [
              createBaseVNode("dt", _hoisted_21$H, toDisplayString$1(unref(t)("dashboard.stats.totalTime", "Total Time")), 1),
              createBaseVNode("dd", _hoisted_22$F, [
                createTextVNode(toDisplayString$1(_ctx.stats.totalTime) + " ", 1),
                createBaseVNode("span", _hoisted_23$F, toDisplayString$1(unref(t)("dashboard.stats.hours", "hours")), 1)
              ]),
              _cache[12] || (_cache[12] = createBaseVNode("div", { class: "w-full bg-purple-100 dark:bg-purple-900/30 rounded-full h-2" }, [
                createBaseVNode("div", {
                  class: "bg-gradient-to-r from-purple-500 to-purple-600 h-2 rounded-full animate-progress-slide",
                  style: { "width": "90%" }
                })
              ], -1))
            ])
          ]),
          _cache[15] || (_cache[15] = createBaseVNode("div", { class: "absolute top-4 right-4 w-2 h-2 bg-purple-400 rounded-full animate-ping" }, null, -1))
        ])
      ]);
    };
  }
});

const DashboardStats = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$1c
}, Symbol.toStringTag, { value: 'Module' }));

function useFlashcardDashboardStats() {
  const practiceHistory = ref([]);
  const isLoading = ref(true);
  const loadPracticeHistory = () => {
    try {
      const saved = localStorage.getItem("flashcard-practice-history");
      if (saved) {
        const parsed = JSON.parse(saved);
        practiceHistory.value = parsed;
      }
    } catch (error) {
      console.error("Error loading flashcard practice history:", error);
    } finally {
      isLoading.value = false;
    }
  };
  const getStreakDays = () => {
    if (practiceHistory.value.length === 0) return 0;
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const practiceDates = [...new Set(
      practiceHistory.value.map((item) => {
        const date = new Date(item.date);
        date.setHours(0, 0, 0, 0);
        return date.getTime();
      })
    )].sort((a, b) => b - a);
    if (practiceDates.length === 0) return 0;
    const mostRecentDate = new Date(practiceDates[0]);
    const daysDiff = Math.floor((today.getTime() - mostRecentDate.getTime()) / (1e3 * 60 * 60 * 24));
    if (daysDiff > 1) return 0;
    let streak = 0;
    let expectedDate = today.getTime();
    for (const practiceDate of practiceDates) {
      const date = new Date(practiceDate);
      if (date.getTime() === expectedDate) {
        streak++;
        expectedDate -= 24 * 60 * 60 * 1e3;
      } else if (date.getTime() === expectedDate + 24 * 60 * 60 * 1e3 && streak === 0) {
        streak++;
        expectedDate -= 24 * 60 * 60 * 1e3;
      } else {
        break;
      }
    }
    return streak;
  };
  const getWeeklyProgress = () => {
    const now = /* @__PURE__ */ new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
    const thisWeekSessions = practiceHistory.value.filter((item) => {
      const itemDate = new Date(item.date);
      return itemDate >= weekAgo && itemDate <= now;
    });
    const weeklyProgress = Math.min(Math.round(thisWeekSessions.length / 7 * 100), 100);
    return {
      sessionsThisWeek: thisWeekSessions.length,
      weeklyProgress
    };
  };
  const getSessionsThisMonth = () => {
    const now = /* @__PURE__ */ new Date();
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1e3);
    return practiceHistory.value.filter((item) => {
      const itemDate = new Date(item.date);
      return itemDate >= monthAgo && itemDate <= now;
    }).length;
  };
  const getFavoriteMode = () => {
    if (practiceHistory.value.length === 0) return "";
    const modeCount = practiceHistory.value.reduce((acc, item) => {
      acc[item.mode] = (acc[item.mode] || 0) + 1;
      return acc;
    }, {});
    return Object.entries(modeCount).sort(([, a], [, b]) => b - a)[0]?.[0] || "";
  };
  const stats = computed(() => {
    if (isLoading.value || practiceHistory.value.length === 0) {
      return {
        totalSessions: 0,
        totalPracticeTime: 0,
        averageAccuracy: 0,
        bestScore: 0,
        favoriteMode: "",
        totalCardsStudied: 0,
        streakDays: 0,
        weeklyProgress: 0,
        sessionsThisWeek: 0,
        sessionsThisMonth: 0
      };
    }
    const totalSessions = practiceHistory.value.length;
    const totalPracticeTime = practiceHistory.value.reduce((sum, item) => sum + item.duration, 0);
    const averageAccuracy = Math.round(
      practiceHistory.value.reduce((sum, item) => sum + item.accuracy, 0) / totalSessions
    );
    const bestScore = Math.max(...practiceHistory.value.map((item) => item.score));
    const totalCardsStudied = practiceHistory.value.reduce((sum, item) => sum + item.totalCards, 0);
    const favoriteMode = getFavoriteMode();
    const streakDays = getStreakDays();
    const { sessionsThisWeek, weeklyProgress } = getWeeklyProgress();
    const sessionsThisMonth = getSessionsThisMonth();
    return {
      totalSessions,
      totalPracticeTime: Math.round(totalPracticeTime / 60),
      // Convert to minutes
      averageAccuracy,
      bestScore,
      favoriteMode,
      totalCardsStudied,
      streakDays,
      weeklyProgress,
      sessionsThisWeek,
      sessionsThisMonth
    };
  });
  const getFormattedStats = computed(() => {
    const currentStats = stats.value;
    return {
      ...currentStats,
      totalPracticeTimeFormatted: formatDuration(currentStats.totalPracticeTime),
      favoriteModeFormatted: formatMode(currentStats.favoriteMode),
      accuracyLevel: getAccuracyLevel(currentStats.averageAccuracy),
      streakLevel: getStreakLevel(currentStats.streakDays),
      progressLevel: getProgressLevel(currentStats.weeklyProgress)
    };
  });
  const formatDuration = (minutes) => {
    if (minutes < 60) {
      return `${minutes}m`;
    }
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;
    return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;
  };
  const formatMode = (mode) => {
    const modeNames = {
      "flashcard": "Flashcard",
      "quiz": "Quiz",
      "typing": "Typing",
      "listening": "Listening",
      "image": "Image",
      "pictionary": "Pictionary",
      "pronunciation": "Pronunciation",
      "bubble-shooter": "Bubble Shooter",
      "snake-game": "Snake Hunt"
    };
    return modeNames[mode] || mode;
  };
  const getAccuracyLevel = (accuracy) => {
    if (accuracy >= 90) return { level: "Excellent", color: "text-green-600 dark:text-green-400" };
    if (accuracy >= 80) return { level: "Good", color: "text-blue-600 dark:text-blue-400" };
    if (accuracy >= 70) return { level: "Fair", color: "text-yellow-600 dark:text-yellow-400" };
    if (accuracy >= 60) return { level: "Average", color: "text-orange-600 dark:text-orange-400" };
    return { level: "Needs Work", color: "text-red-600 dark:text-red-400" };
  };
  const getStreakLevel = (days) => {
    if (days >= 30) return { level: "Amazing", color: "text-purple-600 dark:text-purple-400" };
    if (days >= 14) return { level: "Great", color: "text-green-600 dark:text-green-400" };
    if (days >= 7) return { level: "Good", color: "text-blue-600 dark:text-blue-400" };
    if (days >= 3) return { level: "Building", color: "text-yellow-600 dark:text-yellow-400" };
    if (days >= 1) return { level: "Started", color: "text-orange-600 dark:text-orange-400" };
    return { level: "None", color: "text-gray-600 dark:text-gray-400" };
  };
  const getProgressLevel = (progress) => {
    if (progress >= 90) return { level: "Outstanding", color: "text-green-600 dark:text-green-400" };
    if (progress >= 70) return { level: "Strong", color: "text-blue-600 dark:text-blue-400" };
    if (progress >= 50) return { level: "Moderate", color: "text-yellow-600 dark:text-yellow-400" };
    if (progress >= 30) return { level: "Light", color: "text-orange-600 dark:text-orange-400" };
    return { level: "Minimal", color: "text-red-600 dark:text-red-400" };
  };
  const refreshStats = () => {
    loadPracticeHistory();
  };
  onMounted(() => {
    loadPracticeHistory();
  });
  return {
    stats,
    getFormattedStats,
    isLoading,
    refreshStats
  };
}

const _hoisted_1$1b = ["width", "height"];
const _hoisted_2$18 = ["id"];
const _hoisted_3$16 = ["id"];
const _hoisted_4$12 = ["id"];
const _hoisted_5$$ = ["cx", "cy", "r", "stroke", "stroke-width"];
const _hoisted_6$Z = ["cx", "cy", "r", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset"];
const _hoisted_7$W = ["cx", "cy", "r", "stroke-dashoffset"];
const _hoisted_8$W = { class: "flex flex-col items-center justify-center text-center space-y-1 transform transition-all duration-300 group-hover:scale-105" };
const _hoisted_9$V = {
  key: 0,
  class: "flex-shrink-0 mb-1 relative"
};
const _hoisted_10$U = { class: "flex flex-col items-center justify-center" };
const _hoisted_11$U = {
  key: 0,
  class: "absolute inset-0 pointer-events-none overflow-hidden rounded-full"
};
const __default__$3 = {
  name: "CircularProgress"
};
const _sfc_main$1b = /* @__PURE__ */ defineComponent({
  ...__default__$3,
  props: {
    value: {},
    max: {},
    size: { default: 120 },
    strokeWidth: { default: 8 },
    progressColor: { default: "#3b82f6" },
    progressColorSecondary: { default: "#60a5fa" },
    progressColorThertiary: { default: "#93c5fd" },
    backgroundColor: { default: "#e5e7eb" },
    label: {},
    unit: { default: "" },
    showIcon: { type: Boolean, default: false },
    valueClass: { default: "text-xl font-bold" },
    showShimmer: { type: Boolean, default: false },
    glowEffect: { type: Boolean, default: false },
    animationDelay: { default: 0 }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "bd8d57e4": _ctx.animationDelay + "ms"
    }));
    const props = __props;
    const animatedValue = ref(0);
    const animatedProgress = ref(0);
    const isAnimating = ref(false);
    const radius = computed(() => (props.size - props.strokeWidth) / 2);
    const circumference = computed(() => 2 * Math.PI * radius.value);
    const percentage = computed(() => Math.min(props.value / props.max * 100, 100));
    const strokeDashoffset = computed(
      () => circumference.value - animatedProgress.value / 100 * circumference.value
    );
    const displayValue = computed(() => {
      if (props.unit === "%") {
        return Math.round(animatedProgress.value);
      }
      return Math.round(animatedValue.value);
    });
    const animateValue = (from, to, duration = 1500) => {
      const startTime = Date.now();
      const update = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easeOutCubic = 1 - Math.pow(1 - progress, 3);
        animatedValue.value = from + (to - from) * easeOutCubic;
        animatedProgress.value = from + (percentage.value - from) * easeOutCubic;
        if (progress < 1) {
          requestAnimationFrame(update);
        } else {
          isAnimating.value = false;
        }
      };
      isAnimating.value = true;
      requestAnimationFrame(update);
    };
    const circularProgressRef = ref();
    ref(false);
    const startAnimation = () => {
      setTimeout(() => {
        animateValue(0, props.value);
      }, props.animationDelay);
    };
    onMounted(() => {
      startAnimation();
      if (!circularProgressRef.value) return;
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting && !isAnimating.value) {
              animatedValue.value = 0;
              animatedProgress.value = 0;
              startAnimation();
            }
          });
        },
        {
          threshold: 0.3,
          // Trigger when 30% visible
          rootMargin: "0px 0px -20px 0px"
        }
      );
      observer.observe(circularProgressRef.value);
      return () => observer.disconnect();
    });
    const iconSize = computed(() => {
      if (props.size >= 140) return "w-6 h-6";
      if (props.size >= 100) return "w-5 h-5";
      return "w-4 h-4";
    });
    const gradientId = computed(() => Math.random().toString(36).substr(2, 9));
    const shimmerOffset = computed(() => circumference.value);
    const progressColorTertiary = computed(() => props.progressColorThertiary);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "circularProgressRef",
        ref: circularProgressRef,
        class: "relative group cursor-pointer rounded-full overflow-hidden",
        style: normalizeStyle([{ "display": "inline-block", "background": "transparent !important", "box-shadow": "none !important" }, { width: _ctx.size + "px", height: _ctx.size + "px", clipPath: "circle(50% at 50% 50%)" }])
      }, [
        createBaseVNode("div", {
          class: "absolute inset-0 rounded-full overflow-hidden pointer-events-none opacity-0 group-hover:opacity-30 transition-all duration-700 blur-xl animate-pulse",
          style: normalizeStyle({
            background: `radial-gradient(circle, ${_ctx.progressColor}20, transparent 70%)`,
            transform: "scale(1.2)"
          })
        }, null, 4),
        (openBlock(), createElementBlock("svg", {
          width: _ctx.size,
          height: _ctx.size,
          class: "transform -rotate-90 transition-all duration-500 group-hover:scale-105 relative z-10",
          style: { "display": "block", "background": "transparent !important" }
        }, [
          createBaseVNode("defs", null, [
            createBaseVNode("linearGradient", {
              id: `progressGradient-${gradientId.value}`,
              x1: "0%",
              y1: "0%",
              x2: "100%",
              y2: "100%"
            }, [
              createBaseVNode("stop", {
                offset: "0%",
                style: normalizeStyle({ stopColor: _ctx.progressColor, stopOpacity: 1 })
              }, null, 4),
              createBaseVNode("stop", {
                offset: "50%",
                style: normalizeStyle({ stopColor: _ctx.progressColorSecondary, stopOpacity: 0.9 })
              }, null, 4),
              createBaseVNode("stop", {
                offset: "100%",
                style: normalizeStyle({ stopColor: progressColorTertiary.value, stopOpacity: 1 })
              }, null, 4)
            ], 8, _hoisted_2$18),
            createBaseVNode("linearGradient", {
              id: `backgroundGradient-${gradientId.value}`,
              x1: "0%",
              y1: "0%",
              x2: "100%",
              y2: "100%"
            }, [
              createBaseVNode("stop", {
                offset: "0%",
                style: normalizeStyle({ stopColor: _ctx.backgroundColor, stopOpacity: 0.1 })
              }, null, 4),
              createBaseVNode("stop", {
                offset: "100%",
                style: normalizeStyle({ stopColor: _ctx.backgroundColor, stopOpacity: 0.3 })
              }, null, 4)
            ], 8, _hoisted_3$16),
            createBaseVNode("filter", {
              id: `glow-${gradientId.value}`
            }, _cache[0] || (_cache[0] = [
              createBaseVNode("feGaussianBlur", {
                stdDeviation: "3",
                result: "coloredBlur"
              }, null, -1),
              createBaseVNode("feMerge", null, [
                createBaseVNode("feMergeNode", { in: "coloredBlur" }),
                createBaseVNode("feMergeNode", { in: "SourceGraphic" })
              ], -1)
            ]), 8, _hoisted_4$12)
          ]),
          createBaseVNode("circle", {
            cx: _ctx.size / 2,
            cy: _ctx.size / 2,
            r: radius.value,
            stroke: `url(#backgroundGradient-${gradientId.value})`,
            "stroke-width": _ctx.strokeWidth,
            fill: "transparent",
            class: "opacity-40"
          }, null, 8, _hoisted_5$$),
          createBaseVNode("circle", {
            cx: _ctx.size / 2,
            cy: _ctx.size / 2,
            r: radius.value,
            stroke: `url(#progressGradient-${gradientId.value})`,
            "stroke-width": _ctx.strokeWidth + 1,
            fill: "transparent",
            "stroke-dasharray": circumference.value,
            "stroke-dashoffset": strokeDashoffset.value,
            "stroke-linecap": "round",
            class: "transition-all duration-1500 ease-out transform-gpu",
            style: normalizeStyle({
              filter: _ctx.glowEffect ? `url(#glow-${gradientId.value})` : "none",
              animation: "progressShine 3s infinite linear"
            })
          }, null, 12, _hoisted_6$Z),
          _ctx.showShimmer ? (openBlock(), createElementBlock("circle", {
            key: 0,
            cx: _ctx.size / 2,
            cy: _ctx.size / 2,
            r: radius.value,
            stroke: "rgba(255, 255, 255, 0.6)",
            "stroke-width": 1,
            fill: "transparent",
            "stroke-dasharray": "20 80",
            "stroke-dashoffset": shimmerOffset.value,
            "stroke-linecap": "round",
            class: "animate-spin",
            style: { "animation-duration": "4s" },
            opacity: "0.8"
          }, null, 8, _hoisted_7$W)) : createCommentVNode("", true)
        ], 8, _hoisted_1$1b)),
        createBaseVNode("div", {
          class: "pointer-events-none absolute inset-0 flex items-center justify-center",
          style: normalizeStyle({
            width: _ctx.size + "px",
            height: _ctx.size + "px"
          })
        }, [
          createBaseVNode("div", _hoisted_8$W, [
            _ctx.showIcon ? (openBlock(), createElementBlock("div", _hoisted_9$V, [
              createBaseVNode("div", {
                class: normalizeClass(["transition-all duration-300 group-hover:text-white", iconSize.value]),
                style: normalizeStyle({
                  color: _ctx.progressColor,
                  filter: `drop-shadow(0 0 8px ${_ctx.progressColor}40)`,
                  textShadow: `0 0 10px ${_ctx.progressColor}60`
                })
              }, [
                renderSlot(_ctx.$slots, "icon", {}, void 0, true)
              ], 6)
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_10$U, [
              createBaseVNode("div", {
                class: normalizeClass(["font-bold tracking-tight transition-all duration-300 group-hover:scale-110", _ctx.valueClass]),
                style: normalizeStyle({
                  color: "white",
                  textShadow: `0 0 15px ${_ctx.progressColor}50, 0 2px 4px rgba(0,0,0,0.3)`,
                  letterSpacing: "-0.02em"
                })
              }, toDisplayString$1(displayValue.value) + toDisplayString$1(_ctx.unit), 7),
              _ctx.label ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "text-xs font-semibold uppercase tracking-wider transition-all duration-300 group-hover:text-white mt-1",
                style: normalizeStyle({
                  color: `${_ctx.progressColor}dd`,
                  textShadow: `0 0 8px ${_ctx.progressColor}40`,
                  letterSpacing: "0.05em"
                })
              }, toDisplayString$1(_ctx.label), 5)) : createCommentVNode("", true)
            ])
          ])
        ], 4),
        _ctx.showShimmer ? (openBlock(), createElementBlock("div", _hoisted_11$U, [
          (openBlock(), createElementBlock(Fragment, null, renderList(3, (i) => {
            return createBaseVNode("div", {
              key: i,
              class: "absolute w-1 h-1 rounded-full animate-pulse",
              style: normalizeStyle({
                background: `radial-gradient(circle, ${_ctx.progressColor}, transparent)`,
                top: Math.random() * 80 + 10 + "%",
                left: Math.random() * 80 + 10 + "%",
                animationDelay: i * 0.5 + "s",
                animationDuration: "2s"
              })
            }, null, 4);
          }), 64))
        ])) : createCommentVNode("", true)
      ], 4);
    };
  }
});

const CircularProgress$2 = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["__scopeId", "data-v-621c8743"]]);

const _hoisted_1$1a = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-105 hover:-translate-y-2 h-full min-h-[420px] flex flex-col" };
const _hoisted_2$17 = { class: "px-6 py-8 sm:p-8 flex-1 flex flex-col" };
const _hoisted_3$15 = { class: "flex items-center mb-6" };
const _hoisted_4$11 = { class: "text-lg sm:text-xl md:text-2xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 dark:from-purple-400 dark:to-pink-400 bg-clip-text text-transparent" };
const _hoisted_5$_ = {
  key: 0,
  class: "flex-1 flex items-center justify-center"
};
const _hoisted_6$Y = {
  key: 1,
  class: "flex-1 flex flex-col items-center justify-center text-center space-y-4"
};
const _hoisted_7$V = { class: "text-sm font-medium text-gray-600 dark:text-gray-300" };
const _hoisted_8$V = { class: "text-xs text-gray-500 dark:text-gray-400 mt-1" };
const _hoisted_9$U = {
  key: 2,
  class: "space-y-6 flex-1"
};
const _hoisted_10$T = {
  class: "grid grid-cols-2 lg:grid-cols-4 place-items-center justify-center gap-8 lg:gap-6",
  style: { "background": "transparent !important" }
};
const _hoisted_11$T = {
  class: "flex flex-col items-center text-center",
  style: { "background": "transparent !important" }
};
const _hoisted_12$S = { style: { "background": "transparent !important" } };
const _hoisted_13$S = {
  class: "flex flex-col items-center text-center",
  style: { "background": "transparent !important" }
};
const _hoisted_14$R = {
  class: "flex flex-col items-center text-center",
  style: { "background": "transparent !important" }
};
const _hoisted_15$L = { class: "grid grid-cols-1 sm:grid-cols-2 gap-4" };
const _hoisted_16$K = {
  class: "bg-white/50 dark:bg-[#0a0a0a]/30 rounded-xl p-4 group/stat hover:bg-white/70 dark:hover:bg-[#0a0a0a]/50 transition-all duration-300",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_17$J = { class: "flex items-center justify-between mb-2" };
const _hoisted_18$H = { class: "text-xs font-semibold text-blue-600 dark:text-blue-400 uppercase tracking-wide" };
const _hoisted_19$H = { class: "text-2xl font-bold text-gray-900 dark:text-white counter-animate" };
const _hoisted_20$G = {
  class: "bg-white/50 dark:bg-[#0a0a0a]/30 rounded-xl p-4 group/stat hover:bg-white/70 dark:hover:bg-[#0a0a0a]/50 transition-all duration-300",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_21$G = { class: "flex items-center justify-between mb-2" };
const _hoisted_22$E = { class: "text-xs font-semibold text-pink-600 dark:text-pink-400 uppercase tracking-wide" };
const _hoisted_23$E = { class: "text-2xl font-bold text-gray-900 dark:text-white counter-animate" };
const _hoisted_24$D = { class: "space-y-3" };
const _hoisted_25$D = {
  class: "group/activity flex items-center space-x-4 p-3 rounded-xl hover:bg-white/50 dark:hover:bg-[#0a0a0a]/20 transition-all duration-300",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_26$B = { class: "flex-1 min-w-0" };
const _hoisted_27$A = { class: "text-xs sm:text-sm font-semibold text-gray-900 dark:text-white" };
const _hoisted_28$y = { class: "text-xs text-purple-600 dark:text-purple-400 font-medium" };
const _hoisted_29$w = {
  key: 0,
  class: "group/activity flex items-center space-x-4 p-3 rounded-xl hover:bg-white/50 dark:hover:bg-[#0a0a0a]/20 transition-all duration-300",
  style: { "animation-delay": "0.8s" }
};
const _hoisted_30$v = { class: "flex-1 min-w-0" };
const _hoisted_31$u = { class: "text-xs sm:text-sm font-semibold text-gray-900 dark:text-white" };
const _hoisted_32$r = { class: "text-xs text-yellow-600 dark:text-yellow-400 font-medium" };
const _sfc_main$1a = /* @__PURE__ */ defineComponent({
  __name: "FlashcardStats",
  setup(__props) {
    const { t } = useI18n();
    const { stats, getFormattedStats: formattedStats, isLoading } = useFlashcardDashboardStats();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1a, [
        createBaseVNode("div", _hoisted_2$17, [
          createBaseVNode("div", _hoisted_3$15, [
            _cache[0] || (_cache[0] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
              createBaseVNode("div", { class: "w-3 h-3 bg-gradient-to-r from-purple-400 to-pink-500 rounded-full mr-3" })
            ], -1)),
            createBaseVNode("h3", _hoisted_4$11, toDisplayString$1(unref(t)("dashboard.flashcardStats.title", "Flashcard Practice")), 1)
          ]),
          unref(isLoading) ? (openBlock(), createElementBlock("div", _hoisted_5$_, _cache[1] || (_cache[1] = [
            createBaseVNode("div", { class: "animate-spin rounded-full h-8 w-8 border-b-2 border-purple-500" }, null, -1)
          ]))) : unref(stats).totalSessions === 0 ? (openBlock(), createElementBlock("div", _hoisted_6$Y, [
            _cache[2] || (_cache[2] = createBaseVNode("div", { class: "w-16 h-16 bg-gradient-to-br from-purple-100 to-pink-100 dark:bg-gradient-to-br dark:from-purple-900/30 dark:to-pink-900/30 rounded-full flex items-center justify-center" }, [
              createBaseVNode("svg", {
                class: "w-8 h-8 text-purple-500 dark:text-purple-400",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"
                })
              ])
            ], -1)),
            createBaseVNode("div", null, [
              createBaseVNode("p", _hoisted_7$V, toDisplayString$1(unref(t)("dashboard.flashcardStats.noData", "No practice sessions yet")), 1),
              createBaseVNode("p", _hoisted_8$V, toDisplayString$1(unref(t)("dashboard.flashcardStats.startPracticing", "Start practicing to see your stats!")), 1)
            ])
          ])) : (openBlock(), createElementBlock("div", _hoisted_9$U, [
            createBaseVNode("div", _hoisted_10$T, [
              createBaseVNode("div", _hoisted_11$T, [
                createVNode(CircularProgress$2, {
                  value: unref(stats).totalSessions,
                  max: Math.max(unref(stats).totalSessions + 10, 50),
                  size: 110,
                  "stroke-width": 7,
                  "progress-color": "#8b5cf6",
                  "progress-color-secondary": "#a855f7",
                  "progress-color-tertiary": "#c084fc",
                  "background-color": "#1e1b4b",
                  label: unref(t)("dashboard.flashcardStats.sessions", "Sessions"),
                  "show-icon": "",
                  "show-shimmer": true,
                  "glow-effect": true,
                  "value-class": "text-lg sm:text-xl font-bold",
                  "animation-delay": 100
                }, {
                  icon: withCtx(() => _cache[3] || (_cache[3] = [
                    createBaseVNode("svg", {
                      class: "w-5 h-5",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", { d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" })
                    ], -1)
                  ])),
                  _: 1
                }, 8, ["value", "max", "label"])
              ]),
              createBaseVNode("div", _hoisted_12$S, [
                createVNode(CircularProgress$2, {
                  value: unref(stats).streakDays,
                  max: Math.max(unref(stats).streakDays + 5, 30),
                  size: 110,
                  "stroke-width": 7,
                  "progress-color": "#f97316",
                  "progress-color-secondary": "#fb923c",
                  "progress-color-tertiary": "#fdba74",
                  "background-color": "#7c2d12",
                  label: unref(t)("dashboard.flashcardStats.streak", "Streak"),
                  unit: unref(t)("dashboard.flashcardStats.days", "days"),
                  "show-icon": "",
                  "show-shimmer": true,
                  "glow-effect": true,
                  "value-class": "text-lg sm:text-xl font-bold",
                  "animation-delay": 200
                }, {
                  icon: withCtx(() => _cache[4] || (_cache[4] = [
                    createBaseVNode("svg", {
                      class: "w-5 h-5",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", { d: "M17.657 18.657A8 8 0 716.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975 0 0120 13a7.975 7.975 0 01-2.343 5.657z" })
                    ], -1)
                  ])),
                  _: 1
                }, 8, ["value", "max", "label", "unit"])
              ]),
              createBaseVNode("div", _hoisted_13$S, [
                createVNode(CircularProgress$2, {
                  value: unref(stats).averageAccuracy,
                  max: 100,
                  size: 110,
                  "stroke-width": 7,
                  "progress-color": "#10b981",
                  "progress-color-secondary": "#34d399",
                  "progress-color-tertiary": "#6ee7b7",
                  "background-color": "#064e3b",
                  label: unref(t)("dashboard.flashcardStats.accuracy", "Accuracy"),
                  unit: "%",
                  "show-icon": "",
                  "show-shimmer": true,
                  "glow-effect": true,
                  "value-class": "text-lg sm:text-xl font-bold",
                  "animation-delay": 300
                }, {
                  icon: withCtx(() => _cache[5] || (_cache[5] = [
                    createBaseVNode("svg", {
                      class: "w-5 h-5",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
                      })
                    ], -1)
                  ])),
                  _: 1
                }, 8, ["value", "label"]),
                createBaseVNode("p", {
                  class: normalizeClass(["text-xs font-medium mt-1", unref(formattedStats).accuracyLevel.color])
                }, toDisplayString$1(unref(formattedStats).accuracyLevel.level), 3)
              ]),
              createBaseVNode("div", _hoisted_14$R, [
                createVNode(CircularProgress$2, {
                  value: unref(stats).sessionsThisWeek,
                  max: 7,
                  size: 110,
                  "stroke-width": 7,
                  "progress-color": "#3b82f6",
                  "progress-color-secondary": "#60a5fa",
                  "progress-color-tertiary": "#93c5fd",
                  "background-color": "#1e3a8a",
                  label: unref(t)("dashboard.flashcardStats.weeklyProgress", "This Week"),
                  "show-icon": "",
                  "show-shimmer": true,
                  "glow-effect": true,
                  "value-class": "text-lg sm:text-xl font-bold",
                  "animation-delay": 400
                }, {
                  icon: withCtx(() => _cache[6] || (_cache[6] = [
                    createBaseVNode("svg", {
                      class: "w-5 h-5",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"
                      })
                    ], -1)
                  ])),
                  _: 1
                }, 8, ["value", "label"]),
                createBaseVNode("p", {
                  class: normalizeClass(["text-xs font-medium mt-1", unref(formattedStats).progressLevel.color])
                }, toDisplayString$1(unref(stats).sessionsThisWeek) + "/7 " + toDisplayString$1(unref(t)("dashboard.flashcardStats.sessions", "sessions")), 3)
              ])
            ]),
            createBaseVNode("div", _hoisted_15$L, [
              createBaseVNode("div", _hoisted_16$K, [
                createBaseVNode("div", _hoisted_17$J, [
                  createBaseVNode("span", _hoisted_18$H, toDisplayString$1(unref(t)("dashboard.flashcardStats.bestScore", "Best Score")), 1),
                  _cache[7] || (_cache[7] = createBaseVNode("div", { class: "w-6 h-6 bg-blue-100 dark:bg-blue-900/50 rounded-lg flex items-center justify-center group-hover/stat:scale-110 transition-transform duration-300" }, [
                    createBaseVNode("svg", {
                      class: "w-3 h-3 text-blue-600 dark:text-blue-400",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" })
                    ])
                  ], -1))
                ]),
                createBaseVNode("p", _hoisted_19$H, toDisplayString$1(unref(stats).bestScore), 1)
              ]),
              createBaseVNode("div", _hoisted_20$G, [
                createBaseVNode("div", _hoisted_21$G, [
                  createBaseVNode("span", _hoisted_22$E, toDisplayString$1(unref(t)("dashboard.flashcardStats.cardsStudied", "Cards Studied")), 1),
                  _cache[8] || (_cache[8] = createBaseVNode("div", { class: "w-6 h-6 bg-pink-100 dark:bg-pink-900/50 rounded-lg flex items-center justify-center group-hover/stat:scale-110 transition-transform duration-300" }, [
                    createBaseVNode("svg", {
                      class: "w-3 h-3 text-pink-600 dark:text-pink-400",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", { d: "M7 3a1 1 0 000 2h6a1 1 0 100-2H7zM4 7a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zM2 11a2 2 0 012-2h12a2 2 0 012 2v4a2 2 0 01-2 2H4a2 2 0 01-2-2v-4z" })
                    ])
                  ], -1))
                ]),
                createBaseVNode("p", _hoisted_23$E, toDisplayString$1(unref(stats).totalCardsStudied.toLocaleString()), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_24$D, [
              createBaseVNode("div", _hoisted_25$D, [
                _cache[9] || (_cache[9] = createBaseVNode("div", { class: "flex-shrink-0" }, [
                  createBaseVNode("div", { class: "w-8 h-8 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-lg flex items-center justify-center transform group-hover/activity:rotate-12 group-hover/activity:scale-110 transition-all duration-300" }, [
                    createBaseVNode("svg", {
                      class: "w-4 h-4 text-white",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                      })
                    ])
                  ])
                ], -1)),
                createBaseVNode("div", _hoisted_26$B, [
                  createBaseVNode("p", _hoisted_27$A, toDisplayString$1(unref(t)("dashboard.flashcardStats.totalTime", "Total Practice Time")), 1),
                  createBaseVNode("p", _hoisted_28$y, toDisplayString$1(unref(formattedStats).totalPracticeTimeFormatted), 1)
                ])
              ]),
              unref(stats).favoriteMode ? (openBlock(), createElementBlock("div", _hoisted_29$w, [
                _cache[10] || (_cache[10] = createBaseVNode("div", { class: "flex-shrink-0" }, [
                  createBaseVNode("div", { class: "w-8 h-8 bg-gradient-to-br from-yellow-500 to-orange-500 rounded-lg flex items-center justify-center transform group-hover/activity:rotate-12 group-hover/activity:scale-110 transition-all duration-300" }, [
                    createBaseVNode("svg", {
                      class: "w-4 h-4 text-white",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" })
                    ])
                  ])
                ], -1)),
                createBaseVNode("div", _hoisted_30$v, [
                  createBaseVNode("p", _hoisted_31$u, toDisplayString$1(unref(t)("dashboard.flashcardStats.favoriteMode", "Favorite Mode")), 1),
                  createBaseVNode("p", _hoisted_32$r, toDisplayString$1(unref(formattedStats).favoriteModeFormatted), 1)
                ])
              ])) : createCommentVNode("", true)
            ])
          ]))
        ])
      ]);
    };
  }
});

const FlashcardStats = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["__scopeId", "data-v-4522b048"]]);

const FlashcardStats$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: FlashcardStats
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$19 = { class: "flex flex-col items-center p-4" };
const _hoisted_2$16 = { class: "text-center mb-4 text-base font-medium" };
const _hoisted_3$14 = { class: "flex space-x-4" };
const _sfc_main$19 = /* @__PURE__ */ defineComponent({
  __name: "ConfirmToast",
  props: {
    message: {},
    confirmText: {},
    cancelText: {},
    onConfirm: { type: Function },
    onCancel: { type: Function }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$19, [
        createBaseVNode("p", _hoisted_2$16, toDisplayString$1(_ctx.message), 1),
        createBaseVNode("div", _hoisted_3$14, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = //@ts-ignore
            (...args) => _ctx.onConfirm && _ctx.onConfirm(...args)),
            class: "px-4 py-2 text-sm font-semibold text-white bg-green-600 border border-transparent rounded-md shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors"
          }, toDisplayString$1(_ctx.confirmText), 1),
          createBaseVNode("button", {
            onClick: _cache[1] || (_cache[1] = //@ts-ignore
            (...args) => _ctx.onCancel && _ctx.onCancel(...args)),
            class: "px-4 py-2 text-sm font-semibold text-white bg-red-600 border border-transparent rounded-md shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors"
          }, toDisplayString$1(_ctx.cancelText), 1)
        ])
      ]);
    };
  }
});

const ConfirmToast = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$19
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$18 = { class: "bg-white dark:bg-[#0a0a0a] shadow rounded-lg border border-gray-200 dark:border-dark-bg-mute overflow-hidden" };
const _hoisted_2$15 = ["aria-expanded"];
const _hoisted_3$13 = { class: "flex items-center space-x-3 flex-1 min-w-0" };
const _hoisted_4$10 = {
  key: 0,
  class: "flex-shrink-0"
};
const _hoisted_5$Z = {
  class: "w-5 h-5 xs:w-6 xs:h-6 text-blue-500 dark:text-blue-400",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_6$X = ["d"];
const _hoisted_7$U = { class: "flex-1 min-w-0" };
const _hoisted_8$U = { class: "text-sm xs:text-base sm:text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_9$T = {
  key: 0,
  class: "text-xs xs:text-sm text-gray-600 dark:text-white/70 mt-1"
};
const _hoisted_10$S = { class: "flex items-center justify-end space-x-3 mt-4 md:mt-0 md:ml-3" };
const _hoisted_11$S = {
  key: 0,
  class: "flex items-center space-x-3 mr-auto"
};
const _hoisted_12$R = { class: "text-xs sm:text-sm text-gray-600 dark:text-gray-400 truncate max-w-48 sm:max-w-64" };
const _hoisted_13$R = { class: "accordion-content" };
const _hoisted_14$Q = { class: "px-3 py-3 xs:px-4 xs:py-4 sm:px-5 sm:py-5" };
const _sfc_main$18 = /* @__PURE__ */ defineComponent({
  __name: "BaseAccordion",
  props: {
    title: {},
    description: {},
    icon: {},
    defaultOpen: { type: Boolean, default: true },
    persistKey: { default: void 0 },
    statusText: { default: void 0 },
    statusColor: { default: void 0 },
    showStatusWhenClosed: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const getInitialState = () => {
      if (props.persistKey && typeof localStorage !== "undefined") {
        try {
          const stored = localStorage.getItem(`accordion-${props.persistKey}`);
          return stored !== null ? JSON.parse(stored) : props.defaultOpen;
        } catch {
          return props.defaultOpen;
        }
      }
      return props.defaultOpen;
    };
    const isOpen = ref(getInitialState());
    const iconPaths = computed(() => {
      const iconMap = {
        "vocabulary": "M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z",
        "filter": "M3 3a1 1 0 011-1h12a1 1 0 011 1v3a1 1 0 01-.293.707L12 11.414V15a1 1 0 01-.293.707l-2 2A1 1 0 018 17v-5.586L3.293 6.707A1 1 0 013 6V3z",
        "settings": "M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z"
      };
      return iconMap[props.icon || ""] || null;
    });
    const toggle = () => {
      isOpen.value = !isOpen.value;
      if (props.persistKey && typeof localStorage !== "undefined") {
        try {
          localStorage.setItem(`accordion-${props.persistKey}`, JSON.stringify(isOpen.value));
        } catch {
        }
      }
    };
    const enter = (el) => {
      const element = el;
      element.style.height = "0";
      element.style.overflow = "hidden";
    };
    const afterEnter = (el) => {
      const element = el;
      element.style.height = "auto";
      element.style.overflow = "visible";
    };
    const leave = (el) => {
      const element = el;
      element.style.height = element.offsetHeight + "px";
      element.style.overflow = "hidden";
      element.offsetHeight;
      element.style.height = "0";
    };
    const afterLeave = (el) => {
      const element = el;
      element.style.height = "auto";
      element.style.overflow = "visible";
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$18, [
        createBaseVNode("button", {
          onClick: toggle,
          "aria-expanded": isOpen.value ? "true" : "false",
          class: "w-full flex flex-col md:flex-row md:items-center px-3 py-3 xs:px-4 xs:py-3 sm:px-5 sm:py-4 text-left bg-gray-50 dark:bg-[#0f0f0f] hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors border-b border-gray-200 dark:border-dark-bg-mute focus:outline-none focus:ring-2 focus:ring-blue-500"
        }, [
          createBaseVNode("div", _hoisted_3$13, [
            _ctx.icon && iconPaths.value ? (openBlock(), createElementBlock("div", _hoisted_4$10, [
              (openBlock(), createElementBlock("svg", _hoisted_5$Z, [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: iconPaths.value,
                  "clip-rule": "evenodd"
                }, null, 8, _hoisted_6$X)
              ]))
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_7$U, [
              createBaseVNode("h3", _hoisted_8$U, toDisplayString$1(_ctx.title), 1),
              _ctx.description ? (openBlock(), createElementBlock("p", _hoisted_9$T, toDisplayString$1(_ctx.description), 1)) : createCommentVNode("", true)
            ])
          ]),
          createBaseVNode("div", _hoisted_10$S, [
            _ctx.statusText && _ctx.showStatusWhenClosed && !isOpen.value ? (openBlock(), createElementBlock("div", _hoisted_11$S, [
              _ctx.statusColor ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(["h-2 w-2 rounded-full", _ctx.statusColor])
              }, null, 2)) : createCommentVNode("", true),
              createBaseVNode("span", _hoisted_12$R, toDisplayString$1(_ctx.statusText), 1)
            ])) : createCommentVNode("", true),
            (openBlock(), createElementBlock("svg", {
              class: normalizeClass(["w-5 h-5 text-gray-500 dark:text-white/60 transition-transform duration-200 flex-shrink-0", { "rotate-180": isOpen.value }]),
              fill: "none",
              stroke: "currentColor",
              viewBox: "0 0 24 24"
            }, _cache[0] || (_cache[0] = [
              createBaseVNode("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M19 9l-7 7-7-7"
              }, null, -1)
            ]), 2))
          ])
        ], 8, _hoisted_2$15),
        createVNode(Transition, {
          name: "accordion",
          onEnter: enter,
          onAfterEnter: afterEnter,
          onLeave: leave,
          onAfterLeave: afterLeave
        }, {
          default: withCtx(() => [
            withDirectives(createBaseVNode("div", _hoisted_13$R, [
              createBaseVNode("div", _hoisted_14$Q, [
                renderSlot(_ctx.$slots, "default", {}, void 0, true)
              ])
            ], 512), [
              [vShow, isOpen.value]
            ])
          ]),
          _: 3
        })
      ]);
    };
  }
});

const BaseAccordion = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["__scopeId", "data-v-f39e0c05"]]);

const BaseAccordion$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: BaseAccordion
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$17 = { class: "p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_2$14 = { class: "flex items-center justify-between mb-3 sm:mb-4" };
const _hoisted_3$12 = { class: "flex items-center space-x-2 sm:space-x-3" };
const _hoisted_4$$ = { class: "text-xs sm:text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_5$Y = { class: "text-xs text-gray-500 dark:text-gray-400 hidden sm:block" };
const _hoisted_6$W = {
  key: 0,
  class: "flex items-center justify-between pt-3 sm:pt-4 border-t border-gray-200 dark:border-gray-700 mb-3 sm:mb-4"
};
const _hoisted_7$T = { class: "flex items-center space-x-2 sm:space-x-3" };
const _hoisted_8$T = { class: "text-xs sm:text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_9$S = { class: "text-xs text-gray-500 dark:text-gray-400 hidden sm:block" };
const _hoisted_10$R = {
  key: 1,
  class: "flex items-center justify-between pt-3 sm:pt-4 border-t border-gray-200 dark:border-gray-700"
};
const _hoisted_11$R = { class: "flex items-center space-x-2 sm:space-x-3" };
const _hoisted_12$Q = { class: "text-xs sm:text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_13$Q = { class: "text-xs text-gray-500 dark:text-gray-400 hidden sm:block" };
const _sfc_main$17 = /* @__PURE__ */ defineComponent({
  __name: "GroupingToggle",
  props: {
    modelValue: { type: Boolean },
    hoverEnabled: { type: Boolean },
    moveMode: { type: Boolean }
  },
  emits: ["update:modelValue", "update:hoverEnabled", "update:moveMode"],
  setup(__props, { emit: __emit }) {
    const BaseAccordion = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => BaseAccordion$1),true              ?void 0:void 0));
    const emit = __emit;
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(BaseAccordion), {
        title: unref(t)("vocabulary.grouping.accordionTitle", "Group by Date Settings"),
        description: unref(t)("vocabulary.grouping.accordionDescription", "Configure how vocabulary is grouped and displayed"),
        icon: "vocabulary",
        "default-open": true,
        "persist-key": "vocabulary-grouping",
        class: "mb-4 sm:mb-6"
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$17, [
            createBaseVNode("div", _hoisted_2$14, [
              createBaseVNode("div", _hoisted_3$12, [
                _cache[3] || (_cache[3] = createBaseVNode("svg", {
                  class: "w-4 h-4 sm:w-5 sm:h-5 text-gray-500 dark:text-gray-400",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z",
                    "clip-rule": "evenodd"
                  })
                ], -1)),
                createBaseVNode("div", null, [
                  createBaseVNode("h3", _hoisted_4$$, toDisplayString$1(unref(t)("vocabulary.grouping.title", "Group by Date")), 1),
                  createBaseVNode("p", _hoisted_5$Y, toDisplayString$1(unref(t)("vocabulary.grouping.description", "Group vocabulary words by creation date")), 1)
                ])
              ]),
              createBaseVNode("button", {
                onClick: _cache[0] || (_cache[0] = ($event) => emit("update:modelValue", !_ctx.modelValue)),
                class: normalizeClass([
                  "relative inline-flex items-center rounded-full transition-colors",
                  "h-5 w-9 sm:h-6 sm:w-11",
                  _ctx.modelValue ? "bg-blue-600" : "bg-gray-200 dark:bg-gray-600"
                ])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass([
                    "inline-block transform rounded-full bg-white transition-transform",
                    "h-3 w-3 sm:h-4 sm:w-4",
                    _ctx.modelValue ? "translate-x-5 sm:translate-x-6" : "translate-x-1"
                  ])
                }, null, 2)
              ], 2)
            ]),
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_6$W, [
              createBaseVNode("div", _hoisted_7$T, [
                _cache[4] || (_cache[4] = createBaseVNode("svg", {
                  class: "w-4 h-4 sm:w-5 sm:h-5 text-gray-500 dark:text-gray-400",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z",
                    "clip-rule": "evenodd"
                  })
                ], -1)),
                createBaseVNode("div", null, [
                  createBaseVNode("h3", _hoisted_8$T, toDisplayString$1(unref(t)("vocabulary.grouping.hoverToExpand", "Hover to Expand")), 1),
                  createBaseVNode("p", _hoisted_9$S, toDisplayString$1(unref(t)("vocabulary.grouping.hoverDescription", "Expand date groups on hover instead of click")), 1)
                ])
              ]),
              createBaseVNode("button", {
                onClick: _cache[1] || (_cache[1] = ($event) => emit("update:hoverEnabled", !_ctx.hoverEnabled)),
                class: normalizeClass([
                  "relative inline-flex items-center rounded-full transition-colors",
                  "h-5 w-9 sm:h-6 sm:w-11",
                  _ctx.hoverEnabled ? "bg-blue-600" : "bg-gray-200 dark:bg-gray-600"
                ])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass([
                    "inline-block transform rounded-full bg-white transition-transform",
                    "h-3 w-3 sm:h-4 sm:w-4",
                    _ctx.hoverEnabled ? "translate-x-5 sm:translate-x-6" : "translate-x-1"
                  ])
                }, null, 2)
              ], 2)
            ])) : createCommentVNode("", true),
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_10$R, [
              createBaseVNode("div", _hoisted_11$R, [
                _cache[5] || (_cache[5] = createBaseVNode("svg", {
                  class: "w-4 h-4 sm:w-5 sm:h-5 text-gray-500 dark:text-gray-400",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z",
                    "clip-rule": "evenodd"
                  })
                ], -1)),
                createBaseVNode("div", null, [
                  createBaseVNode("h3", _hoisted_12$Q, toDisplayString$1(unref(t)("vocabulary.moveMode.title", "Move Mode")), 1),
                  createBaseVNode("p", _hoisted_13$Q, toDisplayString$1(_ctx.moveMode ? unref(t)("vocabulary.moveMode.active", "Active - Click arrows to move words") : unref(t)("vocabulary.moveMode.inactive", "Inactive - Enable to show move arrows")), 1)
                ])
              ]),
              createBaseVNode("button", {
                onClick: _cache[2] || (_cache[2] = ($event) => emit("update:moveMode", !_ctx.moveMode)),
                class: normalizeClass([
                  "relative inline-flex items-center rounded-full transition-colors",
                  "h-5 w-9 sm:h-6 sm:w-11",
                  _ctx.moveMode ? "bg-blue-600" : "bg-gray-200 dark:bg-gray-600"
                ])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass([
                    "inline-block transform rounded-full bg-white transition-transform",
                    "h-3 w-3 sm:h-4 sm:w-4",
                    _ctx.moveMode ? "translate-x-5 sm:translate-x-6" : "translate-x-1"
                  ])
                }, null, 2)
              ], 2)
            ])) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }, 8, ["title", "description"]);
    };
  }
});

const GroupingToggle = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$17
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$16 = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg shadow border border-gray-200 dark:border-gray-700 p-4 sm:p-5 mb-6" };
const _hoisted_2$13 = { class: "flex flex-col md:flex-row md:items-center md:justify-between gap-3 sm:gap-4" };
const _hoisted_3$11 = { class: "flex items-center space-x-4 sm:space-x-4" };
const _hoisted_4$_ = { class: "flex flex-col space-y-0.5 sm:space-y-1" };
const _hoisted_5$X = { class: "text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_6$V = { class: "text-xs text-gray-500 dark:text-gray-400" };
const _sfc_main$16 = /* @__PURE__ */ defineComponent({
  __name: "TopicManagerPanel",
  emits: ["open"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$16, [
        createBaseVNode("div", _hoisted_2$13, [
          createBaseVNode("div", _hoisted_3$11, [
            _cache[1] || (_cache[1] = createBaseVNode("svg", {
              class: "w-5 h-5 text-gray-500 dark:text-gray-400",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z",
                "clip-rule": "evenodd"
              })
            ], -1)),
            createBaseVNode("div", _hoisted_4$_, [
              createBaseVNode("h3", _hoisted_5$X, toDisplayString$1(unref(t)("vocabulary.topicManager.title", "Topic Manager")), 1),
              createBaseVNode("p", _hoisted_6$V, toDisplayString$1(unref(t)("vocabulary.topicManager.builtInTopicsDescription", "Manage built-in topics and categories")), 1)
            ])
          ]),
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => emit("open")),
            class: "px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white text-sm font-medium rounded-lg transition-colors flex items-center space-x-2 self-start md:self-auto mt-3 sm:mt-3 md:mt-0 w-full md:w-auto"
          }, [
            _cache[2] || (_cache[2] = createBaseVNode("svg", {
              class: "h-4 w-4",
              fill: "none",
              stroke: "currentColor",
              viewBox: "0 0 24 24"
            }, [
              createBaseVNode("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M12 6v6m0 0v6m0-6h6m-6 0H6"
              })
            ], -1)),
            createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.topicManager.manageTopics", "Manage Topics")), 1)
          ])
        ])
      ]);
    };
  }
});

const TopicManagerPanel = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$16
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$15 = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-[#0f0f0f] mb-6 overflow-hidden" };
const _hoisted_2$12 = { class: "bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0f0f0f] dark:to-[#0a0a0a] px-3 xs:px-4 sm:px-6 py-3 xs:py-4 border-b border-gray-200 dark:border-[#0f0f0f]" };
const _hoisted_3$10 = { class: "block sm:hidden" };
const _hoisted_4$Z = { class: "flex items-center justify-between mb-3" };
const _hoisted_5$W = { class: "flex items-center space-x-2" };
const _hoisted_6$U = { class: "text-base xs:text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_7$S = { class: "flex items-center justify-between" };
const _hoisted_8$S = { class: "text-xs xs:text-sm text-gray-500 dark:text-gray-400 flex-1 pr-2" };
const _hoisted_9$R = { class: "text-xs font-medium text-gray-600 dark:text-gray-400 flex-shrink-0" };
const _hoisted_10$Q = { class: "hidden sm:block" };
const _hoisted_11$Q = { class: "flex items-center justify-between" };
const _hoisted_12$P = { class: "flex items-center space-x-3" };
const _hoisted_13$P = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_14$P = { class: "text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_15$K = { class: "flex items-center space-x-3" };
const _hoisted_16$J = { class: "text-sm font-medium text-gray-600 dark:text-gray-400" };
const _hoisted_17$I = { class: "p-3 xs:p-4 sm:p-6" };
const _hoisted_18$G = { class: "grid grid-cols-1 lg:grid-cols-3 gap-6 xs:gap-8 sm:gap-10" };
const _hoisted_19$G = { class: "lg:col-span-2 space-y-4 xs:space-y-6" };
const _hoisted_20$F = {
  key: 0,
  class: "bg-green-50 dark:bg-green-900/10 border border-green-200 dark:border-green-800 rounded-lg p-3 xs:p-4"
};
const _hoisted_21$F = { class: "text-xs xs:text-sm font-medium text-green-800 dark:text-green-400 mb-2 xs:mb-3" };
const _hoisted_22$D = ["disabled"];
const _hoisted_23$D = {
  key: 0,
  class: "animate-spin h-3 xs:h-4 w-3 xs:w-4",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _hoisted_24$C = {
  key: 1,
  class: "h-3 xs:h-4 w-3 xs:w-4",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_25$C = {
  key: 1,
  class: "bg-blue-50 dark:bg-blue-900/10 border border-blue-200 dark:border-blue-800 rounded-lg p-3 xs:p-4"
};
const _hoisted_26$A = { class: "text-xs xs:text-sm font-medium text-blue-800 dark:text-blue-400 mb-2 xs:mb-3" };
const _hoisted_27$z = { class: "mb-3 xs:mb-4" };
const _hoisted_28$x = { class: "block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1.5 xs:mb-2" };
const _hoisted_29$v = ["value"];
const _hoisted_30$u = { value: "local" };
const _hoisted_31$t = { value: "google-drive" };
const _hoisted_32$q = { class: "space-y-1.5 xs:space-y-2" };
const _hoisted_33$q = { class: "bg-purple-50 dark:bg-purple-900/10 border border-purple-200 dark:border-purple-800 rounded-lg p-3 xs:p-4" };
const _hoisted_34$n = { class: "text-xs xs:text-sm font-medium text-purple-800 dark:text-purple-400 mb-2 xs:mb-3" };
const _hoisted_35$n = { class: "space-y-2 xs:space-y-2.5" };
const _hoisted_36$m = { class: "relative" };
const _hoisted_37$l = { class: "space-y-3 xs:space-y-4" };
const _hoisted_38$l = { class: "bg-gray-50 dark:bg-[#0f0f0f] border border-gray-200 dark:border-[#0f0f0f] rounded-lg p-3 xs:p-4" };
const _hoisted_39$j = { class: "text-xs xs:text-sm font-medium text-gray-800 dark:text-gray-200 mb-2 xs:mb-3" };
const _hoisted_40$j = { class: "space-y-2 xs:space-y-3" };
const _hoisted_41$i = { class: "flex items-center space-x-1.5 xs:space-x-2" };
const _hoisted_42$g = { class: "text-xs xs:text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_43$f = { class: "flex items-center space-x-1.5 xs:space-x-2 text-xs xs:text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_44$e = { class: "truncate" };
const _hoisted_45$d = {
  key: 0,
  class: "bg-indigo-50 dark:bg-indigo-900/10 border border-indigo-200 dark:border-indigo-800 rounded-lg p-3 xs:p-4"
};
const _hoisted_46$d = { class: "text-xs xs:text-sm font-medium text-indigo-800 dark:text-indigo-400 mb-2 xs:mb-3" };
const _hoisted_47$d = { class: "text-xs xs:text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_48$d = { class: "mb-1.5 xs:mb-2" };
const _hoisted_49$c = { class: "font-medium" };
const _hoisted_50$b = {
  key: 0,
  class: "text-xs text-green-600 dark:text-green-400"
};
const _hoisted_51$a = {
  key: 1,
  class: "space-y-1"
};
const _hoisted_52$a = { class: "text-xs text-green-600 dark:text-green-400" };
const _hoisted_53$a = {
  key: 0,
  class: "text-xs text-gray-600 dark:text-gray-400"
};
const _hoisted_54$a = { class: "font-medium" };
const _hoisted_55$a = {
  key: 1,
  class: "text-xs text-yellow-600 dark:text-yellow-400"
};
const AUTO_SAVE_KEY = "vocabulary-auto-save-enabled";
const STORAGE_TYPE_KEY = "vocabulary-storage-type";
const HAS_AUTO_SAVE_FILE_KEY = "vocabulary-has-auto-save-file";
const HAS_GOOGLE_DRIVE_FILE_KEY = "vocabulary-has-google-drive-file";
const IS_GOOGLE_SIGNED_IN_KEY = "vocabulary-is-google-signed-in";
const AUTO_SAVE_FILE_PATH_KEY = "vocabulary-auto-save-file-path";
const _sfc_main$15 = /* @__PURE__ */ defineComponent({
  __name: "SaveControlPanel",
  props: {
    autoSaveEnabled: { type: Boolean },
    isSaving: { type: Boolean },
    hasAutoSaveFile: { type: Boolean },
    hasGoogleDriveFile: { type: Boolean },
    isGoogleSignedIn: { type: Boolean },
    googleUserEmail: {},
    lastSaveTime: {},
    saveStatusColor: {},
    saveStatusText: {},
    autoSaveFilePath: {},
    storageType: {}
  },
  emits: [
    "update:autoSaveEnabled",
    "update:storageType",
    "update:hasAutoSaveFile",
    "update:hasGoogleDriveFile",
    "update:isGoogleSignedIn",
    "update:autoSaveFilePath",
    "manual-save",
    "setup-auto-save",
    "reset-auto-save",
    "import-file",
    "google-sign-in",
    "google-sign-out",
    "setup-google-drive",
    "sync-from-google-drive"
  ],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const fileInputRef = ref(null);
    const loadAutoSaveEnabled = () => {
      try {
        const saved = localStorage.getItem(AUTO_SAVE_KEY);
        return saved !== null ? JSON.parse(saved) : null;
      } catch (error) {
        console.warn("Failed to load auto save setting from localStorage:", error);
        return null;
      }
    };
    const saveAutoSaveEnabled = (enabled) => {
      try {
        localStorage.setItem(AUTO_SAVE_KEY, JSON.stringify(enabled));
      } catch (error) {
        console.warn("Failed to save auto save setting to localStorage:", error);
      }
    };
    const loadStorageType = () => {
      try {
        const saved = localStorage.getItem(STORAGE_TYPE_KEY);
        if (saved && (saved === "local" || saved === "google-drive")) {
          return saved;
        }
        return null;
      } catch (error) {
        console.warn("Failed to load storage type from localStorage:", error);
        return null;
      }
    };
    const saveStorageType = (type) => {
      try {
        localStorage.setItem(STORAGE_TYPE_KEY, type);
      } catch (error) {
        console.warn("Failed to save storage type to localStorage:", error);
      }
    };
    const loadHasAutoSaveFile = () => {
      try {
        const saved = localStorage.getItem(HAS_AUTO_SAVE_FILE_KEY);
        return saved !== null ? JSON.parse(saved) : null;
      } catch (error) {
        console.warn("Failed to load auto save file state from localStorage:", error);
        return null;
      }
    };
    const saveHasAutoSaveFile = (hasFile) => {
      try {
        localStorage.setItem(HAS_AUTO_SAVE_FILE_KEY, JSON.stringify(hasFile));
      } catch (error) {
        console.warn("Failed to save auto save file state to localStorage:", error);
      }
    };
    const loadHasGoogleDriveFile = () => {
      try {
        const saved = localStorage.getItem(HAS_GOOGLE_DRIVE_FILE_KEY);
        return saved !== null ? JSON.parse(saved) : null;
      } catch (error) {
        console.warn("Failed to load Google Drive file state from localStorage:", error);
        return null;
      }
    };
    const saveHasGoogleDriveFile = (hasFile) => {
      try {
        localStorage.setItem(HAS_GOOGLE_DRIVE_FILE_KEY, JSON.stringify(hasFile));
      } catch (error) {
        console.warn("Failed to save Google Drive file state to localStorage:", error);
      }
    };
    const loadIsGoogleSignedIn = () => {
      try {
        const saved = localStorage.getItem(IS_GOOGLE_SIGNED_IN_KEY);
        return saved !== null ? JSON.parse(saved) : null;
      } catch (error) {
        console.warn("Failed to load Google sign-in state from localStorage:", error);
        return null;
      }
    };
    const saveIsGoogleSignedIn = (isSignedIn) => {
      try {
        localStorage.setItem(IS_GOOGLE_SIGNED_IN_KEY, JSON.stringify(isSignedIn));
      } catch (error) {
        console.warn("Failed to save Google sign-in state to localStorage:", error);
      }
    };
    const loadAutoSaveFilePath = () => {
      try {
        return localStorage.getItem(AUTO_SAVE_FILE_PATH_KEY);
      } catch (error) {
        console.warn("Failed to load auto save file path from localStorage:", error);
        return null;
      }
    };
    const saveAutoSaveFilePath = (filePath) => {
      try {
        localStorage.setItem(AUTO_SAVE_FILE_PATH_KEY, filePath);
      } catch (error) {
        console.warn("Failed to save auto save file path to localStorage:", error);
      }
    };
    watch(
      () => props.autoSaveEnabled,
      (newValue) => {
        saveAutoSaveEnabled(newValue);
      }
    );
    watch(
      () => props.storageType,
      (newValue) => {
        saveStorageType(newValue);
      }
    );
    watch(
      () => props.hasAutoSaveFile,
      (newValue) => {
        saveHasAutoSaveFile(newValue);
      }
    );
    watch(
      () => props.hasGoogleDriveFile,
      (newValue) => {
        saveHasGoogleDriveFile(newValue);
      }
    );
    watch(
      () => props.isGoogleSignedIn,
      (newValue) => {
        saveIsGoogleSignedIn(newValue);
      }
    );
    watch(
      () => props.autoSaveFilePath,
      (newValue) => {
        if (newValue) {
          saveAutoSaveFilePath(newValue);
        }
      }
    );
    onMounted(() => {
      const savedAutoSave = loadAutoSaveEnabled();
      const savedStorageType = loadStorageType();
      const savedHasAutoSaveFile = loadHasAutoSaveFile();
      const savedHasGoogleDriveFile = loadHasGoogleDriveFile();
      const savedIsGoogleSignedIn = loadIsGoogleSignedIn();
      const savedAutoSaveFilePath = loadAutoSaveFilePath();
      if (savedAutoSave !== null && savedAutoSave !== props.autoSaveEnabled) {
        emit("update:autoSaveEnabled", savedAutoSave);
      }
      if (savedStorageType !== null && savedStorageType !== props.storageType) {
        emit("update:storageType", savedStorageType);
      }
      if (savedHasAutoSaveFile !== null && savedHasAutoSaveFile !== props.hasAutoSaveFile) {
        emit("update:hasAutoSaveFile", savedHasAutoSaveFile);
      }
      if (savedHasGoogleDriveFile !== null && savedHasGoogleDriveFile !== props.hasGoogleDriveFile) {
        emit("update:hasGoogleDriveFile", savedHasGoogleDriveFile);
      }
      if (savedIsGoogleSignedIn !== null && savedIsGoogleSignedIn !== props.isGoogleSignedIn) {
        emit("update:isGoogleSignedIn", savedIsGoogleSignedIn);
      }
      if (savedAutoSaveFilePath !== null && savedAutoSaveFilePath !== props.autoSaveFilePath) {
        emit("update:autoSaveFilePath", savedAutoSaveFilePath);
      }
    });
    const formattedLastSave = computed(() => {
      const notSaved = t("vocabulary.save.notSaved", "Not saved");
      if (!props.lastSaveTime) {
        return notSaved;
      }
      const result = t("vocabulary.save.lastSave", { time: props.lastSaveTime }, "Last save: {time}");
      if (result && result.includes("{time}")) {
        return result.replace("{time}", props.lastSaveTime);
      }
      return result || `Last save: ${props.lastSaveTime}`;
    });
    const handleStorageTypeChange = (event) => {
      const target = event.target;
      emit("update:storageType", target.value);
    };
    const openFilePicker = () => {
      fileInputRef.value?.click();
    };
    const handleFileSelected = (event) => {
      const target = event.target;
      if (target.files && target.files.length > 0) {
        emit("import-file", target.files[0]);
        target.value = "";
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1$15, [
          createBaseVNode("div", _hoisted_2$12, [
            createBaseVNode("div", _hoisted_3$10, [
              createBaseVNode("div", _hoisted_4$Z, [
                createBaseVNode("div", _hoisted_5$W, [
                  _cache[8] || (_cache[8] = createBaseVNode("div", { class: "p-1.5 bg-blue-100 dark:bg-blue-900/20 rounded-lg" }, [
                    createBaseVNode("svg", {
                      class: "h-4 w-4 text-blue-600 dark:text-blue-400",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3-3m0 0l-3 3m3-3v12"
                      })
                    ])
                  ], -1)),
                  createBaseVNode("div", null, [
                    createBaseVNode("h3", _hoisted_6$U, toDisplayString$1(unref(t)("vocabulary.save.title", "Save & Sync")), 1)
                  ])
                ]),
                createBaseVNode("button", {
                  onClick: _cache[0] || (_cache[0] = ($event) => emit("update:autoSaveEnabled", !_ctx.autoSaveEnabled)),
                  class: normalizeClass([
                    "relative inline-flex h-5 w-9 items-center rounded-full transition-colors duration-200 flex-shrink-0",
                    _ctx.autoSaveEnabled ? "bg-blue-600" : "bg-gray-200 dark:bg-gray-600"
                  ])
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass([
                      "inline-block h-3 w-3 transform rounded-full bg-white transition-transform duration-200",
                      _ctx.autoSaveEnabled ? "translate-x-5" : "translate-x-1"
                    ])
                  }, null, 2)
                ], 2)
              ]),
              createBaseVNode("div", _hoisted_7$S, [
                createBaseVNode("p", _hoisted_8$S, toDisplayString$1(unref(t)("vocabulary.save.subtitle", "Manage your vocabulary data storage")), 1),
                createBaseVNode("span", _hoisted_9$R, toDisplayString$1(_ctx.autoSaveEnabled ? unref(t)("vocabulary.save.auto", "Auto") : unref(t)("vocabulary.save.manual", "Manual")), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_10$Q, [
              createBaseVNode("div", _hoisted_11$Q, [
                createBaseVNode("div", _hoisted_12$P, [
                  _cache[9] || (_cache[9] = createBaseVNode("div", { class: "p-2 bg-blue-100 dark:bg-blue-900/20 rounded-lg" }, [
                    createBaseVNode("svg", {
                      class: "h-5 w-5 text-blue-600 dark:text-blue-400",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3-3m0 0l-3 3m3-3v12"
                      })
                    ])
                  ], -1)),
                  createBaseVNode("div", null, [
                    createBaseVNode("h3", _hoisted_13$P, toDisplayString$1(unref(t)("vocabulary.save.title", "Save & Sync")), 1),
                    createBaseVNode("p", _hoisted_14$P, toDisplayString$1(unref(t)("vocabulary.save.subtitle", "Manage your vocabulary data storage")), 1)
                  ])
                ]),
                createBaseVNode("div", _hoisted_15$K, [
                  createBaseVNode("button", {
                    onClick: _cache[1] || (_cache[1] = ($event) => emit("update:autoSaveEnabled", !_ctx.autoSaveEnabled)),
                    class: normalizeClass([
                      "relative inline-flex h-6 w-11 items-center rounded-full transition-colors duration-200 flex-shrink-0",
                      _ctx.autoSaveEnabled ? "bg-blue-600" : "bg-gray-200 dark:bg-gray-600"
                    ])
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass([
                        "inline-block h-4 w-4 transform rounded-full bg-white transition-transform duration-200",
                        _ctx.autoSaveEnabled ? "translate-x-6" : "translate-x-1"
                      ])
                    }, null, 2)
                  ], 2),
                  createBaseVNode("span", _hoisted_16$J, toDisplayString$1(_ctx.autoSaveEnabled ? unref(t)("vocabulary.save.auto", "Auto") : unref(t)("vocabulary.save.manual", "Manual")), 1)
                ])
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_17$I, [
          createBaseVNode("div", _hoisted_18$G, [
            createBaseVNode("div", _hoisted_19$G, [
              !_ctx.autoSaveEnabled ? (openBlock(), createElementBlock("div", _hoisted_20$F, [
                createBaseVNode("h4", _hoisted_21$F, toDisplayString$1(unref(t)("vocabulary.save.manualMode", "Manual Save Mode")), 1),
                createBaseVNode("button", {
                  onClick: _cache[2] || (_cache[2] = ($event) => emit("manual-save")),
                  disabled: _ctx.isSaving,
                  class: "w-full px-3 xs:px-4 py-2 xs:py-2.5 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 text-white text-sm xs:text-base font-medium rounded-lg transition-all duration-200 flex items-center justify-center space-x-2 hover:shadow-md"
                }, [
                  _ctx.isSaving ? (openBlock(), createElementBlock("svg", _hoisted_23$D, _cache[10] || (_cache[10] = [
                    createBaseVNode("circle", {
                      class: "opacity-25",
                      cx: "12",
                      cy: "12",
                      r: "10",
                      stroke: "currentColor",
                      "stroke-width": "4"
                    }, null, -1),
                    createBaseVNode("path", {
                      class: "opacity-75",
                      fill: "currentColor",
                      d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    }, null, -1)
                  ]))) : (openBlock(), createElementBlock("svg", _hoisted_24$C, _cache[11] || (_cache[11] = [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3-3m0 0l-3 3m3-3v12"
                    }, null, -1)
                  ]))),
                  createBaseVNode("span", null, toDisplayString$1(_ctx.isSaving ? unref(t)("common.saving", "Saving...") : unref(t)("vocabulary.save.saveNow", "Save Now")), 1)
                ], 8, _hoisted_22$D)
              ])) : createCommentVNode("", true),
              _ctx.autoSaveEnabled ? (openBlock(), createElementBlock("div", _hoisted_25$C, [
                createBaseVNode("h4", _hoisted_26$A, toDisplayString$1(unref(t)("vocabulary.save.autoMode", "Auto Save Configuration")), 1),
                createBaseVNode("div", _hoisted_27$z, [
                  createBaseVNode("label", _hoisted_28$x, toDisplayString$1(unref(t)("vocabulary.save.storageType", "Storage Type")), 1),
                  createBaseVNode("select", {
                    value: _ctx.storageType,
                    onChange: handleStorageTypeChange,
                    class: "w-full px-2.5 xs:px-3 py-1.5 xs:py-2 text-xs xs:text-sm border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-colors"
                  }, [
                    createBaseVNode("option", _hoisted_30$u, toDisplayString$1(unref(t)("vocabulary.save.localStorage", "Local File")), 1),
                    createBaseVNode("option", _hoisted_31$t, toDisplayString$1(unref(t)("vocabulary.save.googleDrive", "Google Drive")), 1)
                  ], 40, _hoisted_29$v)
                ]),
                createBaseVNode("div", _hoisted_32$q, [
                  _ctx.storageType === "local" && !_ctx.hasAutoSaveFile ? (openBlock(), createElementBlock("button", {
                    key: 0,
                    onClick: _cache[3] || (_cache[3] = ($event) => emit("setup-auto-save")),
                    class: "w-full px-3 xs:px-4 py-2 xs:py-2.5 bg-orange-600 hover:bg-orange-700 text-white text-sm xs:text-base font-medium rounded-lg transition-all duration-200 flex items-center justify-center space-x-1.5 xs:space-x-2 hover:shadow-md"
                  }, [
                    _cache[12] || (_cache[12] = createBaseVNode("svg", {
                      class: "h-3 xs:h-4 w-3 xs:w-4",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M12 6v6m0 0v6m0-6h6m-6 0H6"
                      })
                    ], -1)),
                    createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.save.chooseAutoFile", "Choose Auto File")), 1)
                  ])) : createCommentVNode("", true),
                  _ctx.storageType === "google-drive" && !_ctx.isGoogleSignedIn ? (openBlock(), createElementBlock("button", {
                    key: 1,
                    onClick: _cache[4] || (_cache[4] = ($event) => emit("google-sign-in")),
                    class: "w-full px-3 xs:px-4 py-2 xs:py-2.5 bg-red-600 hover:bg-red-700 text-white text-sm xs:text-base font-medium rounded-lg transition-all duration-200 flex items-center justify-center space-x-1.5 xs:space-x-2 hover:shadow-md"
                  }, [
                    _cache[13] || (_cache[13] = createBaseVNode("svg", {
                      class: "h-3 xs:h-4 w-3 xs:w-4",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013 3v1"
                      })
                    ], -1)),
                    createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.save.signInGoogle", "Sign in Google")), 1)
                  ])) : createCommentVNode("", true),
                  _ctx.storageType === "google-drive" && _ctx.isGoogleSignedIn && !_ctx.hasGoogleDriveFile ? (openBlock(), createElementBlock("button", {
                    key: 2,
                    onClick: _cache[5] || (_cache[5] = ($event) => emit("setup-google-drive")),
                    class: "w-full px-3 xs:px-4 py-2 xs:py-2.5 bg-blue-600 hover:bg-blue-700 text-white text-sm xs:text-base font-medium rounded-lg transition-all duration-200 flex items-center justify-center space-x-1.5 xs:space-x-2 hover:shadow-md"
                  }, [
                    _cache[14] || (_cache[14] = createBaseVNode("svg", {
                      class: "h-3 xs:h-4 w-3 xs:w-4",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
                      })
                    ], -1)),
                    createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.save.setupDrive", "Setup Google Drive")), 1)
                  ])) : createCommentVNode("", true),
                  _ctx.storageType === "google-drive" && _ctx.isGoogleSignedIn && _ctx.hasGoogleDriveFile ? (openBlock(), createElementBlock("button", {
                    key: 3,
                    onClick: _cache[6] || (_cache[6] = ($event) => emit("sync-from-google-drive")),
                    class: "w-full px-3 xs:px-4 py-2 xs:py-2.5 bg-green-600 hover:bg-green-700 text-white text-sm xs:text-base font-medium rounded-lg transition-all duration-200 flex items-center justify-center space-x-1.5 xs:space-x-2 hover:shadow-md"
                  }, [
                    _cache[15] || (_cache[15] = createBaseVNode("svg", {
                      class: "h-3 xs:h-4 w-3 xs:w-4",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                      })
                    ], -1)),
                    createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.save.syncFromDrive", "Sync from Drive")), 1)
                  ])) : createCommentVNode("", true),
                  _ctx.storageType === "local" && _ctx.hasAutoSaveFile || _ctx.storageType === "google-drive" && _ctx.isGoogleSignedIn ? (openBlock(), createElementBlock("button", {
                    key: 4,
                    onClick: _cache[7] || (_cache[7] = ($event) => _ctx.storageType === "local" ? emit("reset-auto-save") : emit("google-sign-out")),
                    class: "w-full px-3 xs:px-4 py-2 xs:py-2.5 bg-gray-500 hover:bg-gray-600 text-white text-sm xs:text-base font-medium rounded-lg transition-all duration-200 flex items-center justify-center space-x-1.5 xs:space-x-2 hover:shadow-md"
                  }, [
                    _cache[16] || (_cache[16] = createBaseVNode("svg", {
                      class: "h-3 xs:h-4 w-3 xs:w-4",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                      })
                    ], -1)),
                    createBaseVNode("span", null, toDisplayString$1(_ctx.storageType === "local" ? unref(t)("vocabulary.save.changeAutoFile", "Change Auto File") : unref(t)("vocabulary.save.signOutGoogle", "Sign Out Google")), 1)
                  ])) : createCommentVNode("", true)
                ])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_33$q, [
                createBaseVNode("h4", _hoisted_34$n, toDisplayString$1(unref(t)("vocabulary.save.importExport", "Import & Export")), 1),
                createBaseVNode("div", _hoisted_35$n, [
                  createBaseVNode("div", _hoisted_36$m, [
                    createBaseVNode("input", {
                      ref_key: "fileInputRef",
                      ref: fileInputRef,
                      type: "file",
                      accept: ".json",
                      onChange: handleFileSelected,
                      class: "hidden"
                    }, null, 544),
                    createBaseVNode("button", {
                      onClick: openFilePicker,
                      class: "w-full px-3 xs:px-4 py-2 xs:py-2.5 bg-purple-600 hover:bg-purple-700 text-white text-sm xs:text-base font-medium rounded-lg transition-all duration-200 flex items-center justify-center space-x-1.5 xs:space-x-2 hover:shadow-md"
                    }, [
                      _cache[17] || (_cache[17] = createBaseVNode("svg", {
                        class: "h-3 xs:h-4 w-3 xs:w-4",
                        fill: "none",
                        stroke: "currentColor",
                        viewBox: "0 0 24 24"
                      }, [
                        createBaseVNode("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10"
                        })
                      ], -1)),
                      createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.save.importFromComputer", "Import from Computer")), 1)
                    ])
                  ])
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_37$l, [
              createBaseVNode("div", _hoisted_38$l, [
                createBaseVNode("h4", _hoisted_39$j, toDisplayString$1(unref(t)("vocabulary.save.status", "Save Status")), 1),
                createBaseVNode("div", _hoisted_40$j, [
                  createBaseVNode("div", _hoisted_41$i, [
                    createBaseVNode("div", {
                      class: normalizeClass(["h-2.5 xs:h-3 w-2.5 xs:w-3 rounded-full", _ctx.saveStatusColor])
                    }, null, 2),
                    createBaseVNode("span", _hoisted_42$g, toDisplayString$1(_ctx.saveStatusText), 1)
                  ]),
                  createBaseVNode("div", _hoisted_43$f, [
                    _cache[18] || (_cache[18] = createBaseVNode("svg", {
                      class: "h-3 xs:h-4 w-3 xs:w-4 flex-shrink-0",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                      })
                    ], -1)),
                    createBaseVNode("span", _hoisted_44$e, toDisplayString$1(formattedLastSave.value), 1)
                  ])
                ])
              ]),
              _ctx.autoSaveEnabled ? (openBlock(), createElementBlock("div", _hoisted_45$d, [
                createBaseVNode("h4", _hoisted_46$d, toDisplayString$1(unref(t)("vocabulary.save.storageInfo", "Storage Information")), 1),
                createBaseVNode("div", _hoisted_47$d, [
                  createBaseVNode("p", _hoisted_48$d, [
                    createBaseVNode("span", _hoisted_49$c, toDisplayString$1(unref(t)("vocabulary.save.type", "Type")) + ":", 1),
                    createTextVNode(" " + toDisplayString$1(_ctx.storageType === "local" ? unref(t)("vocabulary.save.localStorage", "Local File") : unref(t)("vocabulary.save.googleDrive", "Google Drive")), 1)
                  ]),
                  _ctx.storageType === "local" && _ctx.hasAutoSaveFile ? (openBlock(), createElementBlock("p", _hoisted_50$b, " ✓ " + toDisplayString$1(unref(t)("vocabulary.save.fileConfigured", "Auto-save file configured")), 1)) : createCommentVNode("", true),
                  _ctx.storageType === "google-drive" && _ctx.isGoogleSignedIn ? (openBlock(), createElementBlock("div", _hoisted_51$a, [
                    createBaseVNode("p", _hoisted_52$a, " ✓ " + toDisplayString$1(unref(t)("vocabulary.save.googleConnected", "Google Drive connected")), 1),
                    _ctx.googleUserEmail ? (openBlock(), createElementBlock("p", _hoisted_53$a, [
                      createBaseVNode("span", _hoisted_54$a, toDisplayString$1(unref(t)("vocabulary.save.account", "Account")) + ":", 1),
                      createTextVNode(" " + toDisplayString$1(_ctx.googleUserEmail), 1)
                    ])) : (openBlock(), createElementBlock("p", _hoisted_55$a, " ⚠️ Email not loaded - Sign out and sign in again "))
                  ])) : createCommentVNode("", true)
                ])
              ])) : createCommentVNode("", true)
            ])
          ])
        ])
      ]);
    };
  }
});

const SaveControlPanel = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$15
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$14 = { class: "flex flex-col md:flex-row md:justify-between md:items-center gap-3 md:gap-0" };
const _hoisted_2$11 = { class: "text-3xl font-bold text-gray-900 dark:text-white" };
const _hoisted_3$$ = { class: "mt-2 text-sm text-gray-600 dark:text-white/80" };
const _sfc_main$14 = /* @__PURE__ */ defineComponent({
  __name: "VocabularyHeader",
  emits: ["add-vocabulary"],
  setup(__props) {
    const BaseAccordion = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => BaseAccordion$1),true              ?void 0:void 0));
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(BaseAccordion), {
        title: unref(t)("vocabulary.header.accordionTitle", "Vocabulary Manager"),
        description: unref(t)("vocabulary.header.accordionDescription", "Add and manage your vocabulary words"),
        icon: "vocabulary",
        "default-open": true,
        "persist-key": "vocabulary-header",
        "data-vocabulary-header": ""
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$14, [
            createBaseVNode("div", null, [
              createBaseVNode("h1", _hoisted_2$11, toDisplayString$1(unref(t)("vocabulary.title", "Vocabulary")), 1),
              createBaseVNode("p", _hoisted_3$$, toDisplayString$1(unref(t)("vocabulary.description", "Manage and learn English vocabulary")), 1)
            ]),
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("add-vocabulary")),
              "data-original-add-button": "",
              class: "bg-blue-500 hover:bg-blue-600 text-white font-medium w-full md:w-auto py-1.5 px-3 xs:py-2 xs:px-4 rounded-lg transition-colors"
            }, [
              _cache[1] || (_cache[1] = createBaseVNode("svg", {
                class: "w-4 h-4 xs:w-5 xs:h-5 inline mr-1 xs:mr-2",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                  "clip-rule": "evenodd"
                })
              ], -1)),
              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.addNew", "Add New Word")), 1)
            ])
          ])
        ]),
        _: 1
      }, 8, ["title", "description"]);
    };
  }
});

const VocabularyHeader = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$14
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$13 = { class: "p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_2$10 = { class: "grid grid-cols-1 xs:grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-2 xs:gap-3 sm:gap-4 lg:gap-6" };
const _hoisted_3$_ = { class: "col-span-1 xs:col-span-1 sm:col-span-2 md:col-span-2" };
const _hoisted_4$Y = { class: "block text-xs sm:text-sm font-medium text-gray-700 dark:text-white mb-1 xs:mb-1.5 sm:mb-2" };
const _hoisted_5$V = { class: "group relative" };
const _hoisted_6$T = { class: "rounded-md p-[1px] bg-gradient-to-r from-blue-500 via-emerald-500 to-purple-500 transition duration-300 group-focus-within:brightness-110" };
const _hoisted_7$R = { class: "relative rounded-md bg-white dark:bg-[#0a0a0a]" };
const _hoisted_8$R = ["value", "placeholder"];
const _hoisted_9$Q = { class: "block text-xs sm:text-sm font-medium text-gray-700 dark:text-white mb-1 xs:mb-1.5 sm:mb-2" };
const _hoisted_10$P = { class: "group relative" };
const _hoisted_11$P = { class: "rounded-md p-[1px] bg-gradient-to-r from-blue-500 via-emerald-500 to-purple-500 transition duration-300 group-focus-within:brightness-110" };
const _hoisted_12$O = { class: "relative rounded-md bg-white dark:bg-[#0a0a0a]" };
const _hoisted_13$O = ["aria-expanded"];
const _hoisted_14$O = { class: "truncate text-left" };
const _hoisted_15$J = { class: "p-2 border-b border-gray-200 dark:border-blue-900/30 bg-white dark:bg-[#0a0a0a]" };
const _hoisted_16$I = ["placeholder"];
const _hoisted_17$H = ["onClick"];
const _hoisted_18$F = { class: "col-span-1" };
const _hoisted_19$F = { class: "block text-xs sm:text-sm font-medium text-gray-700 dark:text-white mb-1 xs:mb-1.5 sm:mb-2" };
const _hoisted_20$E = { class: "rounded-md p-[1px] bg-gradient-to-r from-blue-500 via-emerald-500 to-purple-500 transition duration-300 group-focus-within:brightness-110" };
const _hoisted_21$E = { class: "relative rounded-md bg-white dark:bg-[#0a0a0a]" };
const _hoisted_22$C = ["aria-expanded"];
const _hoisted_23$C = { class: "truncate text-left" };
const _hoisted_24$B = { class: "max-h-80 overflow-y-auto py-1 divide-y divide-blue-50 dark:divide-blue-900/20" };
const _hoisted_25$B = { class: "mt-2 xs:mt-3 sm:mt-4" };
const _hoisted_26$z = ["aria-pressed", "title"];
const _hoisted_27$y = { class: "leading-none" };
const _sfc_main$13 = /* @__PURE__ */ defineComponent({
  __name: "VocabularyFilters",
  props: {
    searchQuery: {},
    selectedCategory: {},
    selectedLevel: {},
    categories: {},
    showFavoritesOnly: { type: Boolean }
  },
  emits: ["update:searchQuery", "update:selectedCategory", "update:selectedLevel", "update:showFavoritesOnly"],
  setup(__props, { emit: __emit }) {
    const BaseAccordion = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => BaseAccordion$1),true              ?void 0:void 0));
    const { t, locale } = useI18n();
    const props = __props;
    const emit = __emit;
    const getTopicDisplayName = (category) => {
      return getTopicName(category, t, { value: locale.value });
    };
    const isCategoryOpen = ref(false);
    const categoryDropdownRef = ref(null);
    const categoryTriggerRef = ref(null);
    const categoryMenuRef = ref(null);
    const categoryMenuListRef = ref(null);
    const categorySearchInputRef = ref(null);
    const categorySearch = ref("");
    const menuStyles = ref({});
    const selectedCategoryLabel = computed(() => {
      if (!props.selectedCategory) return t("common.all", "All");
      return getTopicDisplayName(props.selectedCategory);
    });
    const isLevelOpen = ref(false);
    const levelDropdownRef = ref(null);
    const levelTriggerRef = ref(null);
    const levelMenuRef = ref(null);
    const levelMenuStyles = ref({});
    const selectedLevelLabel = computed(() => {
      switch (props.selectedLevel) {
        case "beginner":
          return t("vocabulary.levels.beginner", "Beginner");
        case "intermediate":
          return t("vocabulary.levels.intermediate", "Intermediate");
        case "advanced":
          return t("vocabulary.levels.advanced", "Advanced");
        default:
          return t("common.all", "All");
      }
    });
    const filteredCategories = computed(() => {
      const q = categorySearch.value.trim().toLowerCase();
      if (!q) return props.categories;
      return props.categories.filter((c) => {
        const name = getTopicDisplayName(c).toLowerCase();
        return name.includes(q) || c.toLowerCase().includes(q);
      });
    });
    const updateMenuPosition = () => {
      const trigger = categoryTriggerRef.value;
      if (!trigger) return;
      const rect = trigger.getBoundingClientRect();
      const top = rect.bottom;
      const left = rect.left;
      const width = rect.width;
      const margin = 8;
      const maxLeft = window.innerWidth - margin - width;
      const safeLeft = Math.max(margin, Math.min(left, maxLeft));
      menuStyles.value = {
        top: `${top}px`,
        left: `${safeLeft}px`,
        width: `${width}px`
      };
    };
    const toggleCategoryDropdown = async () => {
      isCategoryOpen.value = !isCategoryOpen.value;
      if (isCategoryOpen.value) {
        categorySearch.value = "";
        await nextTick();
        updateMenuPosition();
        addListScrollGuards();
        categorySearchInputRef.value?.focus();
      } else {
        removeListScrollGuards();
      }
    };
    const selectCategory = (value) => {
      emit("update:selectedCategory", value);
      isCategoryOpen.value = false;
      removeListScrollGuards();
    };
    const updateLevelMenuPosition = () => {
      const trigger = levelTriggerRef.value;
      if (!trigger) return;
      const rect = trigger.getBoundingClientRect();
      const top = rect.bottom;
      const left = rect.left;
      const width = rect.width;
      const margin = 8;
      const maxLeft = window.innerWidth - margin - width;
      const safeLeft = Math.max(margin, Math.min(left, maxLeft));
      levelMenuStyles.value = {
        top: `${top}px`,
        left: `${safeLeft}px`,
        width: `${width}px`
      };
    };
    const toggleLevelDropdown = async () => {
      isLevelOpen.value = !isLevelOpen.value;
      if (isLevelOpen.value) {
        await nextTick();
        updateLevelMenuPosition();
      }
    };
    const selectLevel = (value) => {
      emit("update:selectedLevel", value);
      isLevelOpen.value = false;
    };
    const handleClickOutside = (e) => {
      const target = e.target;
      const catWrapper = categoryDropdownRef.value;
      const catMenu = categoryMenuRef.value;
      const clickedInsideCatWrapper = catWrapper ? catWrapper.contains(target) : false;
      const clickedInsideCatMenu = catMenu ? catMenu.contains(target) : false;
      if (!clickedInsideCatWrapper && !clickedInsideCatMenu) {
        if (isCategoryOpen.value) {
          isCategoryOpen.value = false;
          removeListScrollGuards();
        }
      }
      const lvlWrapper = levelDropdownRef.value;
      const lvlMenu = levelMenuRef.value;
      const clickedInsideLvlWrapper = lvlWrapper ? lvlWrapper.contains(target) : false;
      const clickedInsideLvlMenu = lvlMenu ? lvlMenu.contains(target) : false;
      if (!clickedInsideLvlWrapper && !clickedInsideLvlMenu) {
        if (isLevelOpen.value) {
          isLevelOpen.value = false;
        }
      }
    };
    const handleViewportChange = () => {
      if (isCategoryOpen.value) updateMenuPosition();
      if (isLevelOpen.value) updateLevelMenuPosition();
    };
    const handleScrollClose = (e) => {
      if (isCategoryOpen.value) {
        const menu = categoryMenuRef.value;
        const wrapper = categoryDropdownRef.value;
        const target = e?.target || null;
        if (menu && target && menu.contains(target)) return;
        if (wrapper && target && wrapper.contains(target)) return;
        isCategoryOpen.value = false;
      }
      if (isLevelOpen.value) {
        const lvlMenu = levelMenuRef.value;
        const lvlWrapper = levelDropdownRef.value;
        const target = e?.target || null;
        if (lvlMenu && target && lvlMenu.contains(target)) return;
        if (lvlWrapper && target && lvlWrapper.contains(target)) return;
        isLevelOpen.value = false;
      }
    };
    const handleScrollStart = (e) => {
      const t2 = e.target;
      const catMenu = categoryMenuRef.value;
      const lvlMenu = levelMenuRef.value;
      const catWrapper = categoryDropdownRef.value;
      const lvlWrapper = levelDropdownRef.value;
      if (catMenu && t2 && catMenu.contains(t2) || lvlMenu && t2 && lvlMenu.contains(t2)) return;
      if (catWrapper && t2 && catWrapper.contains(t2) || lvlWrapper && t2 && lvlWrapper.contains(t2)) return;
      if (isCategoryOpen.value) isCategoryOpen.value = false;
      if (isLevelOpen.value) isLevelOpen.value = false;
    };
    const handleKeydownForScroll = (e) => {
      const keys = ["PageUp", "PageDown", "Home", "End", " ", "ArrowDown", "ArrowUp"];
      if (!keys.includes(e.key)) return;
      if (isCategoryOpen.value) {
        const menu = categoryMenuRef.value;
        const wrapper = categoryDropdownRef.value;
        const target = e.target;
        if (menu && target && menu.contains(target)) return;
        if (wrapper && target && wrapper.contains(target)) return;
        isCategoryOpen.value = false;
      }
      if (isLevelOpen.value) {
        const menu = levelMenuRef.value;
        const wrapper = levelDropdownRef.value;
        const target = e.target;
        if (menu && target && menu.contains(target)) return;
        if (wrapper && target && wrapper.contains(target)) return;
        isLevelOpen.value = false;
      }
    };
    onMounted(() => {
      window.addEventListener("click", handleClickOutside, { passive: true });
      window.addEventListener("scroll", handleScrollClose, true);
      window.addEventListener("wheel", handleScrollStart, { passive: false, capture: true });
      window.addEventListener("touchstart", handleScrollStart, { passive: true, capture: true });
      window.addEventListener("touchmove", handleScrollStart, { passive: false, capture: true });
      window.addEventListener("pointerdown", handleScrollStart, { capture: true });
      window.addEventListener("mousedown", handleScrollStart, { capture: true });
      window.addEventListener("keydown", handleKeydownForScroll);
      window.addEventListener("resize", handleViewportChange);
    });
    onBeforeUnmount(() => {
      window.removeEventListener("click", handleClickOutside);
      window.removeEventListener("scroll", handleScrollClose, true);
      window.removeEventListener("wheel", handleScrollStart, true);
      window.removeEventListener("touchstart", handleScrollStart, true);
      window.removeEventListener("touchmove", handleScrollStart, true);
      window.removeEventListener("pointerdown", handleScrollStart, true);
      window.removeEventListener("mousedown", handleScrollStart, true);
      window.removeEventListener("keydown", handleKeydownForScroll);
      window.removeEventListener("resize", handleViewportChange);
      removeListScrollGuards();
    });
    const handleSearchInput = (event) => {
      const target = event.target;
      emit("update:searchQuery", target.value);
    };
    const handleFavoritesClick = () => {
      emit("update:showFavoritesOnly", !props.showFavoritesOnly);
    };
    const touchStartY = ref(0);
    const onMenuWheel = (e) => {
      const el = categoryMenuListRef.value;
      if (!el) return;
      const delta = e.deltaY;
      const atTop = el.scrollTop <= 0;
      const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 1;
      if (delta < 0 && atTop || delta > 0 && atBottom) {
        e.preventDefault();
      }
      e.stopPropagation();
    };
    const onMenuTouchStart = (e) => {
      touchStartY.value = e.touches[0]?.clientY ?? 0;
    };
    const onMenuTouchMove = (e) => {
      const el = categoryMenuListRef.value;
      if (!el) return;
      const y = e.touches[0]?.clientY ?? 0;
      const delta = touchStartY.value - y;
      const atTop = el.scrollTop <= 0;
      const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 1;
      if (delta < 0 && atTop || delta > 0 && atBottom) {
        e.preventDefault();
      }
      e.stopPropagation();
    };
    const addListScrollGuards = () => {
      const el = categoryMenuListRef.value;
      if (!el) return;
      el.addEventListener("wheel", onMenuWheel, { passive: false });
      el.addEventListener("touchstart", onMenuTouchStart, { passive: true });
      el.addEventListener("touchmove", onMenuTouchMove, { passive: false });
    };
    const removeListScrollGuards = () => {
      const el = categoryMenuListRef.value;
      if (!el) return;
      el.removeEventListener("wheel", onMenuWheel);
      el.removeEventListener("touchstart", onMenuTouchStart);
      el.removeEventListener("touchmove", onMenuTouchMove);
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(BaseAccordion), {
        title: unref(t)("vocabulary.filters.accordionTitle", "Search & Filter"),
        description: unref(t)("vocabulary.filters.accordionDescription", "Search and filter vocabulary words"),
        icon: "filter",
        "default-open": true,
        "persist-key": "vocabulary-filters"
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$13, [
            createBaseVNode("div", _hoisted_2$10, [
              createBaseVNode("div", _hoisted_3$_, [
                createBaseVNode("label", _hoisted_4$Y, toDisplayString$1(unref(t)("common.search", "Search")), 1),
                createBaseVNode("div", _hoisted_5$V, [
                  createBaseVNode("div", _hoisted_6$T, [
                    createBaseVNode("div", _hoisted_7$R, [
                      _cache[6] || (_cache[6] = createBaseVNode("span", { class: "pointer-events-none absolute inset-y-0 left-2.5 flex items-center" }, [
                        createBaseVNode("svg", {
                          class: "h-3.5 w-3.5 sm:h-4 sm:w-4 text-blue-500 dark:text-blue-400",
                          viewBox: "0 0 24 24",
                          fill: "none",
                          stroke: "currentColor",
                          "stroke-width": "2",
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "aria-hidden": "true"
                        }, [
                          createBaseVNode("circle", {
                            cx: "11",
                            cy: "11",
                            r: "8"
                          }),
                          createBaseVNode("line", {
                            x1: "21",
                            y1: "21",
                            x2: "16.65",
                            y2: "16.65"
                          })
                        ])
                      ], -1)),
                      createBaseVNode("input", {
                        value: _ctx.searchQuery,
                        onInput: handleSearchInput,
                        type: "text",
                        placeholder: unref(t)("vocabulary.searchPlaceholder", "Search vocabulary..."),
                        class: "w-full pl-8 pr-3 py-1.5 xs:pl-9 xs:pr-3 xs:py-2 sm:pl-9 sm:pr-3 sm:py-2 text-xs sm:text-sm rounded-md bg-transparent text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-blue-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      }, null, 40, _hoisted_8$R)
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", {
                class: "col-span-1",
                ref_key: "categoryDropdownRef",
                ref: categoryDropdownRef
              }, [
                createBaseVNode("label", _hoisted_9$Q, toDisplayString$1(unref(t)("vocabulary.category", "Category")), 1),
                createBaseVNode("div", _hoisted_10$P, [
                  createBaseVNode("div", _hoisted_11$P, [
                    createBaseVNode("div", _hoisted_12$O, [
                      createBaseVNode("button", {
                        type: "button",
                        onClick: toggleCategoryDropdown,
                        "aria-expanded": isCategoryOpen.value ? "true" : "false",
                        ref_key: "categoryTriggerRef",
                        ref: categoryTriggerRef,
                        class: "w-full inline-flex items-center justify-between px-2 py-1.5 xs:px-2.5 xs:py-2 sm:px-3 sm:py-2 text-xs sm:text-sm rounded-md bg-transparent text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      }, [
                        createBaseVNode("span", _hoisted_14$O, toDisplayString$1(selectedCategoryLabel.value), 1),
                        _cache[7] || (_cache[7] = createBaseVNode("svg", {
                          class: "ml-2 h-3.5 w-3.5 sm:h-4 sm:w-4 text-blue-500 dark:text-blue-400 flex-shrink-0",
                          viewBox: "0 0 20 20",
                          fill: "currentColor"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.24 4.5a.75.75 0 01-1.08 0l-4.24-4.5a.75.75 0 01.02-1.06z",
                            "clip-rule": "evenodd"
                          })
                        ], -1))
                      ], 8, _hoisted_13$O)
                    ])
                  ])
                ]),
                (openBlock(), createBlock(Teleport, { to: "body" }, [
                  isCategoryOpen.value ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: "fixed z-[9999] rounded-md border border-gray-300 dark:border-blue-900/30 bg-white dark:bg-[#0a0a0a] shadow-xl ring-1 ring-blue-100/50 dark:ring-blue-900/30 overflow-hidden",
                    style: normalizeStyle(menuStyles.value),
                    ref_key: "categoryMenuRef",
                    ref: categoryMenuRef
                  }, [
                    createBaseVNode("div", _hoisted_15$J, [
                      withDirectives(createBaseVNode("input", {
                        ref_key: "categorySearchInputRef",
                        ref: categorySearchInputRef,
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => categorySearch.value = $event),
                        type: "text",
                        placeholder: unref(t)("common.search", "Search"),
                        class: "w-full px-2 py-1.5 text-xs sm:text-sm border border-gray-300 dark:border-blue-900/30 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-blue-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      }, null, 8, _hoisted_16$I), [
                        [vModelText, categorySearch.value]
                      ])
                    ]),
                    createBaseVNode("ul", {
                      class: "max-h-80 overflow-y-auto divide-y divide-blue-50 dark:divide-blue-900/20",
                      ref_key: "categoryMenuListRef",
                      ref: categoryMenuListRef
                    }, [
                      createBaseVNode("li", null, [
                        createBaseVNode("button", {
                          type: "button",
                          onClick: _cache[1] || (_cache[1] = ($event) => selectCategory("")),
                          class: "w-full text-left px-3 py-2 text-xs sm:text-sm hover:bg-blue-50 dark:hover:bg-blue-800/30 text-gray-700 dark:text-white"
                        }, toDisplayString$1(unref(t)("common.all", "All")), 1)
                      ]),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(filteredCategories.value, (category) => {
                        return openBlock(), createElementBlock("li", { key: category }, [
                          createBaseVNode("button", {
                            type: "button",
                            onClick: ($event) => selectCategory(category),
                            class: "w-full text-left px-3 py-2 text-xs sm:text-sm hover:bg-blue-50 dark:hover:bg-blue-800/30 text-gray-700 dark:text-white"
                          }, toDisplayString$1(getTopicDisplayName(category)), 9, _hoisted_17$H)
                        ]);
                      }), 128))
                    ], 512)
                  ], 4)) : createCommentVNode("", true)
                ]))
              ], 512),
              createBaseVNode("div", _hoisted_18$F, [
                createBaseVNode("label", _hoisted_19$F, toDisplayString$1(unref(t)("vocabulary.level", "Level")), 1),
                createBaseVNode("div", {
                  class: "group relative",
                  ref_key: "levelDropdownRef",
                  ref: levelDropdownRef
                }, [
                  createBaseVNode("div", _hoisted_20$E, [
                    createBaseVNode("div", _hoisted_21$E, [
                      createBaseVNode("button", {
                        type: "button",
                        onClick: toggleLevelDropdown,
                        "aria-expanded": isLevelOpen.value ? "true" : "false",
                        ref_key: "levelTriggerRef",
                        ref: levelTriggerRef,
                        class: "w-full inline-flex items-center justify-between px-2 py-1.5 xs:px-2.5 xs:py-2 sm:px-3 sm:py-2 text-xs sm:text-sm rounded-md bg-transparent text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      }, [
                        createBaseVNode("span", _hoisted_23$C, toDisplayString$1(selectedLevelLabel.value), 1),
                        _cache[8] || (_cache[8] = createBaseVNode("svg", {
                          class: "ml-2 h-3.5 w-3.5 sm:h-4 sm:w-4 text-blue-500 dark:text-blue-400 flex-shrink-0",
                          viewBox: "0 0 20 20",
                          fill: "currentColor"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.24 4.5a.75.75 0 01-1.08 0l-4.24-4.5a.75.75 0 01.02-1.06z",
                            "clip-rule": "evenodd"
                          })
                        ], -1))
                      ], 8, _hoisted_22$C),
                      (openBlock(), createBlock(Teleport, { to: "body" }, [
                        isLevelOpen.value ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          ref_key: "levelMenuRef",
                          ref: levelMenuRef,
                          class: "fixed z-[10000] rounded-md border border-blue-200 dark:border-blue-900/30 bg-white dark:bg-[#0a0a0a] shadow-xl ring-1 ring-blue-100/50 dark:ring-blue-900/30 overflow-hidden",
                          style: normalizeStyle(levelMenuStyles.value)
                        }, [
                          createBaseVNode("ul", _hoisted_24$B, [
                            createBaseVNode("li", null, [
                              createBaseVNode("button", {
                                type: "button",
                                onClick: _cache[2] || (_cache[2] = ($event) => selectLevel("")),
                                class: "w-full text-left px-3 py-2 text-xs sm:text-sm hover:bg-blue-50 dark:hover:bg-blue-800/30 text-gray-700 dark:text-white"
                              }, toDisplayString$1(unref(t)("common.all", "All")), 1)
                            ]),
                            createBaseVNode("li", null, [
                              createBaseVNode("button", {
                                type: "button",
                                onClick: _cache[3] || (_cache[3] = ($event) => selectLevel("beginner")),
                                class: "w-full text-left px-3 py-2 text-xs sm:text-sm hover:bg-blue-50 dark:hover:bg-blue-800/30 text-gray-700 dark:text-white"
                              }, toDisplayString$1(unref(t)("vocabulary.levels.beginner", "Beginner")), 1)
                            ]),
                            createBaseVNode("li", null, [
                              createBaseVNode("button", {
                                type: "button",
                                onClick: _cache[4] || (_cache[4] = ($event) => selectLevel("intermediate")),
                                class: "w-full text-left px-3 py-2 text-xs sm:text-sm hover:bg-blue-50 dark:hover:bg-blue-800/30 text-gray-700 dark:text-white"
                              }, toDisplayString$1(unref(t)("vocabulary.levels.intermediate", "Intermediate")), 1)
                            ]),
                            createBaseVNode("li", null, [
                              createBaseVNode("button", {
                                type: "button",
                                onClick: _cache[5] || (_cache[5] = ($event) => selectLevel("advanced")),
                                class: "w-full text-left px-3 py-2 text-xs sm:text-sm hover:bg-blue-50 dark:hover:bg-blue-800/30 text-gray-700 dark:text-white"
                              }, toDisplayString$1(unref(t)("vocabulary.levels.advanced", "Advanced")), 1)
                            ])
                          ])
                        ], 4)) : createCommentVNode("", true)
                      ]))
                    ])
                  ])
                ], 512)
              ]),
              createBaseVNode("div", _hoisted_25$B, [
                createBaseVNode("button", {
                  type: "button",
                  "aria-pressed": _ctx.showFavoritesOnly ? "true" : "false",
                  title: unref(t)("vocabulary.showFavoritesOnly", "Show favorites only"),
                  onClick: handleFavoritesClick,
                  class: normalizeClass(["inline-flex items-center select-none rounded-full border px-3 py-1.5 xs:px-3 xs:py-1.5 sm:px-3.5 sm:py-2 text-xs sm:text-sm transition-all duration-150", [
                    _ctx.showFavoritesOnly ? "bg-rose-500 border-rose-600 text-white shadow hover:bg-rose-600" : "bg-white border-blue-500 text-blue-600 hover:bg-blue-50 dark:bg-[#0a0a0a] dark:border-blue-400 dark:text-blue-300 dark:hover:bg-blue-900/30"
                  ]])
                }, [
                  _cache[9] || (_cache[9] = createBaseVNode("svg", {
                    class: "w-4 h-4 sm:w-4.5 sm:h-4.5 mr-1.5",
                    viewBox: "0 0 24 24",
                    fill: "currentColor",
                    "aria-hidden": "true"
                  }, [
                    createBaseVNode("path", { d: "M12 21.35l-1.45-1.32C6.4 16.36 4 14.28 4 11.5 4 9.5 5.5 8 7.5 8c1.04 0 2.04.5 2.65 1.32.61-.82 1.61-1.32 2.65-1.32C15.5 8 17 9.5 17 11.5c0 2.78-2.4 4.86-6.55 8.54L12 21.35z" })
                  ], -1)),
                  createBaseVNode("span", _hoisted_27$y, toDisplayString$1(unref(t)("vocabulary.showFavoritesOnly", "Show favorites only")), 1)
                ], 10, _hoisted_26$z)
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["title", "description"]);
    };
  }
});

const VocabularyFilters = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$13
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$12 = { class: "px-3 py-3 sm:px-4 sm:py-4 md:px-6 md:py-4 border-b border-gray-200 dark:border-gray-700" };
const _hoisted_2$$ = { class: "flex items-center justify-between" };
const _hoisted_3$Z = { class: "text-base sm:text-lg font-semibold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent" };
const _hoisted_4$X = ["aria-label"];
const _hoisted_5$U = { class: "text-sm font-semibold mb-2" };
const _hoisted_6$S = {
  key: 0,
  class: "text-sm text-gray-600 dark:text-white/70"
};
const _hoisted_7$Q = {
  key: 1,
  class: "max-h-64 overflow-y-auto space-y-2 pr-1"
};
const _hoisted_8$Q = { class: "text-xs font-medium text-gray-700 mb-1 dark:text-white/80" };
const _hoisted_9$P = { class: "font-semibold" };
const _hoisted_10$O = { class: "text-xs pl-0 space-y-0.5" };
const _hoisted_11$O = ["onClick"];
const _hoisted_12$N = { class: "min-w-0 pr-2" };
const _hoisted_13$N = { class: "font-medium" };
const _hoisted_14$N = { class: "truncate" };
const _hoisted_15$I = { class: "text-gray-500 whitespace-nowrap" };
const _hoisted_16$H = { key: 0 };
const _hoisted_17$G = {
  key: 0,
  class: "bg-white dark:bg-[#0a0a0a] px-4 py-3 border-t border-gray-200 dark:border-gray-700 sm:px-6"
};
const _hoisted_18$E = { class: "flex items-center justify-between" };
const _hoisted_19$E = { class: "flex-1 flex justify-between sm:hidden" };
const _hoisted_20$D = ["disabled"];
const _hoisted_21$D = ["disabled"];
const _hoisted_22$B = { class: "hidden sm:flex-1 sm:flex sm:items-center sm:justify-between" };
const _hoisted_23$B = { class: "text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_24$A = { class: "relative z-0 inline-flex rounded-md shadow-sm -space-x-px" };
const _hoisted_25$A = ["disabled"];
const _hoisted_26$y = { class: "sr-only" };
const _hoisted_27$x = ["onClick", "disabled"];
const _hoisted_28$w = ["disabled"];
const _hoisted_29$u = { class: "sr-only" };
const _hoisted_30$t = {
  key: 1,
  class: "divide-y divide-gray-200 dark:divide-gray-700"
};
const _hoisted_31$s = {
  key: 2,
  class: "bg-white dark:bg-[#0a0a0a] px-4 py-3 border-t border-gray-200 dark:border-gray-700 sm:px-6"
};
const _hoisted_32$p = { class: "flex items-center justify-between" };
const _hoisted_33$p = { class: "flex-1 flex justify-between sm:hidden" };
const _hoisted_34$m = ["disabled"];
const _hoisted_35$m = ["disabled"];
const _hoisted_36$l = { class: "hidden sm:flex-1 sm:flex sm:items-center sm:justify-between" };
const _hoisted_37$k = { class: "text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_38$k = { class: "relative z-0 inline-flex rounded-md shadow-sm -space-x-px" };
const _hoisted_39$i = ["disabled"];
const _hoisted_40$i = { class: "sr-only" };
const _hoisted_41$h = ["onClick"];
const _hoisted_42$f = ["disabled"];
const _hoisted_43$e = { class: "sr-only" };
const ACCORDION_STATE_STORAGE_KEY = "vocabulary-accordion-state";
const PENDING_OPEN_KEY$1 = "open-date-topic-pending";
const dateGroupsPerPage = 7;
const _sfc_main$12 = /* @__PURE__ */ defineComponent({
  __name: "VocabularyList",
  props: {
    paginatedWords: {},
    currentPage: {},
    totalPages: {},
    totalCount: {},
    startIndex: {},
    endIndex: {},
    visiblePages: {},
    useGrouping: { type: Boolean },
    allWords: {},
    dateGroupPages: {},
    itemsPerPageGrouped: {},
    hoverToExpandEnabled: { type: Boolean },
    globalMoveMode: { type: Boolean },
    recentlyAddedCategory: {}
  },
  emits: ["play-audio", "edit-word", "delete-word", "toggle-favorite", "view-details", "previous-page", "next-page", "go-to-page", "date-group-previous", "date-group-next", "date-group-go-to-page", "accordion-toggle", "open-note-dialog", "open-add-vocabulary-dialog", "open-grammar-manager", "move-vocabulary", "batch-move-category"],
  setup(__props, { emit: __emit }) {
    const { t, locale } = useI18n();
    const toast = useToast();
    const showMissingTooltip = ref(false);
    let missingTooltipHideTimer = null;
    const handleMissingTooltipEnter = () => {
      if (missingTooltipHideTimer) {
        clearTimeout(missingTooltipHideTimer);
        missingTooltipHideTimer = null;
      }
      showMissingTooltip.value = true;
    };
    const handleMissingTooltipLeave = () => {
      missingTooltipHideTimer = setTimeout(() => {
        showMissingTooltip.value = false;
        missingTooltipHideTimer = null;
      }, 120);
    };
    const VocabularyCard = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => VocabularyCard$1),true              ?void 0:void 0))
    );
    const DateGroupAccordion = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => DateGroupAccordion$1),true              ?void 0:void 0))
    );
    const accordionState = ref({});
    const getStoredAccordionState = () => {
      try {
        const stored = localStorage.getItem(ACCORDION_STATE_STORAGE_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch (error) {
        console.warn("Failed to load accordion state from localStorage:", error);
        return {};
      }
    };
    const setStoredAccordionState = (state) => {
      try {
        localStorage.setItem(ACCORDION_STATE_STORAGE_KEY, JSON.stringify(state));
      } catch (error) {
        console.warn("Failed to save accordion state to localStorage:", error);
      }
    };
    onMounted(() => {
      accordionState.value = getStoredAccordionState();
    });
    const props = __props;
    const missingImagesByDate = computed(() => {
      const source = props.useGrouping ? props.allWords || [] : props.paginatedWords || [];
      if (!Array.isArray(source) || source.length === 0) return [];
      const normalizeDate = (d) => {
        if (!d) return "Unknown";
        const dt = new Date(d);
        return isNaN(dt.getTime()) ? "Unknown" : dt.toISOString().slice(0, 10);
      };
      const map = /* @__PURE__ */ new Map();
      for (const w of source) {
        const img = (w.image ?? "").trim();
        if (img) continue;
        const dateKey = normalizeDate(w.createdAt);
        const catKey = w.category || "uncategorized";
        const displayName = w.categoryName || getTopicName(catKey, t, locale, w);
        if (!map.has(dateKey)) map.set(dateKey, /* @__PURE__ */ new Map());
        const catMap = map.get(dateKey);
        const prev = catMap.get(catKey) || { name: displayName, count: 0 };
        prev.count += 1;
        if (!prev.name && displayName) {
          prev.name = displayName;
        }
        catMap.set(catKey, prev);
      }
      const result = [];
      for (const [date, catMap] of map.entries()) {
        const categories = Array.from(catMap.entries()).map(([key, value]) => ({ key, name: value.name, count: value.count }));
        result.push({ date, categories });
      }
      result.sort((a, b) => {
        if (a.date === "Unknown") return 1;
        if (b.date === "Unknown") return -1;
        return new Date(b.date).getTime() - new Date(a.date).getTime();
      });
      return result;
    });
    const dateGroupCurrentPage = ref(1);
    const groupedWords = computed(() => {
      if (!props.useGrouping) return [];
      const wordsToGroup = props.allWords || props.paginatedWords;
      let allGroups = groupVocabulariesByDateAndTopic(wordsToGroup, locale.value, t);
      if (props.recentlyAddedCategory) {
        allGroups = allGroups.map((group) => {
          if (!group.topics) return group;
          const recentCategoryIndex = group.topics.findIndex(
            (topic) => topic.topic === props.recentlyAddedCategory
          );
          if (recentCategoryIndex > -1) {
            const sortedTopics = [...group.topics];
            const [recentCategory] = sortedTopics.splice(recentCategoryIndex, 1);
            sortedTopics.unshift(recentCategory);
            return {
              ...group,
              topics: sortedTopics
            };
          }
          return group;
        });
      }
      if (props.dateGroupPages && props.itemsPerPageGrouped) {
        return allGroups.map((group) => {
          const currentPage = props.dateGroupPages[group.date] || 1;
          const itemsPerPage = props.itemsPerPageGrouped;
          const totalTopics = group.topics ? group.topics.length : 0;
          const startIndex = (currentPage - 1) * itemsPerPage;
          const endIndex = startIndex + itemsPerPage;
          return {
            ...group,
            topics: group.topics ? group.topics.slice(startIndex, endIndex) : [],
            currentPage,
            totalPages: Math.ceil(totalTopics / itemsPerPage),
            topicsTotal: totalTopics,
            totalItems: group.vocabularies.length
            // giữ lại số lượng từ vựng gốc
          };
        });
      }
      return allGroups;
    });
    const paginatedDateGroups = computed(() => {
      if (!props.useGrouping) return [];
      const allGroups = groupedWords.value;
      const startIndex = (dateGroupCurrentPage.value - 1) * dateGroupsPerPage;
      const endIndex = startIndex + dateGroupsPerPage;
      return allGroups.slice(startIndex, endIndex);
    });
    const dateGroupPaginationInfo = computed(() => {
      const totalGroups = groupedWords.value.length;
      const totalPages = Math.ceil(totalGroups / dateGroupsPerPage);
      const startIndex = (dateGroupCurrentPage.value - 1) * dateGroupsPerPage + 1;
      const endIndex = Math.min(startIndex + dateGroupsPerPage - 1, totalGroups);
      return {
        totalGroups,
        totalPages,
        currentPage: dateGroupCurrentPage.value,
        startIndex,
        endIndex,
        hasNext: dateGroupCurrentPage.value < totalPages,
        hasPrevious: dateGroupCurrentPage.value > 1
      };
    });
    const goToDateGroupPage = (page) => {
      if (page >= 1 && page <= dateGroupPaginationInfo.value.totalPages) {
        dateGroupCurrentPage.value = page;
      }
    };
    const nextDateGroupPage = () => {
      if (dateGroupPaginationInfo.value.hasNext) {
        dateGroupCurrentPage.value++;
      }
    };
    const previousDateGroupPage = () => {
      if (dateGroupPaginationInfo.value.hasPrevious) {
        dateGroupCurrentPage.value--;
      }
    };
    const visibleDateGroupPages = computed(() => {
      const totalPages = dateGroupPaginationInfo.value.totalPages;
      const currentPage = dateGroupCurrentPage.value;
      if (totalPages <= 0) return [];
      const pages = [];
      const maxVisible = 5;
      let start = Math.max(1, currentPage - Math.floor(maxVisible / 2));
      let end = Math.min(totalPages, start + maxVisible - 1);
      start = Math.max(1, end - maxVisible + 1);
      for (let i = start; i <= end; i++) {
        pages.push(i);
      }
      return pages;
    });
    const handleAccordionToggle = (date, expanded) => {
      accordionState.value[date] = expanded;
      setStoredAccordionState(accordionState.value);
      console.log(`Accordion for ${date} toggled to:`, expanded);
    };
    const handleNoteSaved = (date, note, markedWords) => {
      toast.success(t("vocabulary.notes.saveSuccess", "Notes saved successfully"), {
        timeout: 2e3
      });
      const autoSaveEnabled = localStorage.getItem("vocabulary-auto-save-enabled");
      if (autoSaveEnabled === "true") {
        toast.info(t("vocabulary.notes.autoSaveNotice", "Notes will be included in auto-save"), {
          timeout: 3e3
        });
      }
      console.log(`Note saved for ${date} with ${markedWords.length} marked words`);
    };
    const handleVocabularyListMouseLeave = () => {
      if (props.hoverToExpandEnabled) {
        window.dispatchEvent(new CustomEvent("vocabulary-list-mouse-leave"));
      }
    };
    const handleVocabularyListMouseEnter = () => {
      if (props.hoverToExpandEnabled) {
        window.dispatchEvent(new CustomEvent("vocabulary-list-mouse-enter"));
      }
    };
    const emit = __emit;
    const handleMoveVocabulary = (data) => {
      const sourceDate = groupedWords.value.find(
        (group) => group.vocabularies.some((word) => word.id === data.word.id)
      )?.date;
      emit("move-vocabulary", {
        ...data,
        sourceDate
      });
    };
    const handleRequestAvailableDates = (data) => {
      const availableDates = groupedWords.value.filter((group) => {
        const hasSameTopic = group.vocabularies.some((word) => word.category === data.topic);
        return hasSameTopic && group.date !== data.currentDate;
      }).map((group) => ({
        date: group.date,
        count: group.vocabularies.filter((word) => word.category === data.topic).length
      })).filter((item) => item.count > 0).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
      nextTick(() => {
        const event = new CustomEvent("available-dates-response", {
          detail: {
            topic: data.topic,
            currentDate: data.currentDate,
            availableDates
          }
        });
        window.dispatchEvent(event);
      });
    };
    const handleNavigateToDateTopic = (payload) => {
      const allGroups = groupedWords.value;
      const targetIndex = allGroups.findIndex((g) => g.date === payload.date);
      if (targetIndex === -1) return;
      const targetPage = Math.floor(targetIndex / dateGroupsPerPage) + 1;
      const dispatchOpenEvent = () => {
        const ev = new CustomEvent("open-date-topic", {
          detail: { date: payload.date, topic: payload.topic }
        });
        window.dispatchEvent(ev);
      };
      if (dateGroupCurrentPage.value !== targetPage) {
        try {
          sessionStorage.setItem(PENDING_OPEN_KEY$1, JSON.stringify({ date: payload.date, topic: payload.topic }));
        } catch {
        }
        dateGroupCurrentPage.value = targetPage;
        nextTick(() => {
          requestAnimationFrame(() => {
            setTimeout(() => {
              dispatchOpenEvent();
            }, 50);
          });
        });
      } else {
        nextTick(() => {
          dispatchOpenEvent();
        });
      }
    };
    const handleMissingNavigate = (date, topicKey) => {
      handleNavigateToDateTopic({ date, topic: topicKey });
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-[#0a0a0a] shadow rounded-lg overflow-hidden border border-gray-200 dark:border-gray-700",
        onMouseleave: handleVocabularyListMouseLeave,
        onMouseenter: handleVocabularyListMouseEnter
      }, [
        createBaseVNode("div", _hoisted_1$12, [
          createBaseVNode("div", _hoisted_2$$, [
            createBaseVNode("h3", _hoisted_3$Z, toDisplayString$1(unref(t)("vocabulary.vocabularyList", "Vocabulary List")) + " (" + toDisplayString$1(_ctx.totalCount) + ") ", 1),
            createBaseVNode("div", {
              class: "relative ml-2 select-none",
              "aria-hidden": "false",
              onMouseenter: handleMissingTooltipEnter,
              onMouseleave: handleMissingTooltipLeave
            }, [
              createBaseVNode("button", {
                type: "button",
                class: "inline-flex items-center justify-center w-6 h-6 sm:w-7 sm:h-7 rounded-full border border-blue-200 text-blue-600 bg-blue-50 hover:bg-blue-100 dark:text-blue-300 dark:bg-dark-bg-soft dark:border-dark-bg-mute dark:hover:bg-dark-bg-mute transition",
                "aria-label": unref(t)("vocabulary.imageInfo.aria", "Show dates/categories missing images")
              }, _cache[20] || (_cache[20] = [
                createBaseVNode("svg", {
                  viewBox: "0 0 24 24",
                  fill: "currentColor",
                  class: "w-4 h-4 sm:w-5 sm:h-5"
                }, [
                  createBaseVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm.75 15h-1.5v-6h1.5v6zm0-8h-1.5V7h1.5v2z" })
                ], -1)
              ]), 8, _hoisted_4$X),
              showMissingTooltip.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "transition-opacity duration-150 absolute right-0 mt-2 w-72 sm:w-80 rounded-lg shadow-xl ring-1 ring-black/5 bg-white text-gray-800 p-3 z-30 border border-gray-200 dark:bg-[#0a0a0a] dark:text-white dark:border dark:border-dark-bg-mute",
                onMouseenter: handleMissingTooltipEnter,
                onMouseleave: handleMissingTooltipLeave
              }, [
                _cache[21] || (_cache[21] = createBaseVNode("div", {
                  class: "absolute -top-[2px] right-7 w-4 h-[4px] bg-white dark:bg-[#0a0a0a] pointer-events-none z-10",
                  "aria-hidden": "true"
                }, null, -1)),
                _cache[22] || (_cache[22] = createBaseVNode("div", {
                  class: "absolute -top-1.5 right-[29.5px] w-3 h-3 rotate-45 bg-white pointer-events-none z-20 dark:bg-[#0a0a0a] border-t border-l border-gray-200 dark:border-[#0f0f0f]",
                  "aria-hidden": "true"
                }, null, -1)),
                createBaseVNode("div", _hoisted_5$U, toDisplayString$1(unref(t)("vocabulary.imageInfo.title", "Missing images by date")), 1),
                missingImagesByDate.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_6$S, toDisplayString$1(unref(t)("vocabulary.imageInfo.none", "All categories have images for the current list")), 1)) : (openBlock(), createElementBlock("div", _hoisted_7$Q, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(missingImagesByDate.value, (item) => {
                    return openBlock(), createElementBlock("div", {
                      key: item.date,
                      class: "border border-gray-200 rounded-md p-2 dark:border-dark-bg-mute"
                    }, [
                      createBaseVNode("div", _hoisted_8$Q, [
                        createTextVNode(toDisplayString$1(unref(t)("vocabulary.imageInfo.date", "Date")) + ": ", 1),
                        createBaseVNode("span", _hoisted_9$P, toDisplayString$1(item.date), 1)
                      ]),
                      createBaseVNode("ul", _hoisted_10$O, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(item.categories, (cat) => {
                          return openBlock(), createElementBlock("li", {
                            key: cat.key,
                            class: "flex items-center justify-between rounded px-2 py-1 cursor-pointer hover:bg-gray-custom dark:hover:bg-gray-custom",
                            onClick: ($event) => handleMissingNavigate(item.date, cat.key)
                          }, [
                            createBaseVNode("div", _hoisted_12$N, [
                              createBaseVNode("span", _hoisted_13$N, toDisplayString$1(unref(t)("vocabulary.imageInfo.category", "Category")) + ":", 1),
                              createBaseVNode("span", _hoisted_14$N, toDisplayString$1(cat.name), 1)
                            ]),
                            createBaseVNode("span", _hoisted_15$I, toDisplayString$1(unref(t)("vocabulary.imageInfo.missingCount", { count: cat.count }) || `${cat.count} without image`), 1)
                          ], 8, _hoisted_11$O);
                        }), 128))
                      ])
                    ]);
                  }), 128))
                ]))
              ], 32)) : createCommentVNode("", true)
            ], 32)
          ])
        ]),
        _ctx.useGrouping && groupedWords.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_16$H, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(paginatedDateGroups.value, (group) => {
            return openBlock(), createBlock(unref(DateGroupAccordion), {
              key: group.date,
              group,
              "default-expanded": false,
              "accordion-state": accordionState.value,
              "hover-to-expand-enabled": _ctx.hoverToExpandEnabled,
              "global-move-mode": _ctx.globalMoveMode,
              onPlayAudio: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("play-audio", $event)),
              onEditWord: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("edit-word", $event)),
              onDeleteWord: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("delete-word", $event)),
              onToggleFavorite: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("toggle-favorite", $event)),
              onViewDetails: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("view-details", $event)),
              onDateGroupPrevious: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("date-group-previous", $event)),
              onDateGroupNext: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("date-group-next", $event)),
              onAccordionToggle: handleAccordionToggle,
              onNoteSaved: handleNoteSaved,
              onOpenNoteDialog: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("open-note-dialog", $event.date, $event.words)),
              onOpenAddVocabularyDialog: _cache[8] || (_cache[8] = ($event) => _ctx.$emit("open-add-vocabulary-dialog", $event)),
              onOpenGrammarManager: _cache[9] || (_cache[9] = ($event) => _ctx.$emit("open-grammar-manager", $event)),
              onMoveVocabulary: handleMoveVocabulary,
              onRequestAvailableDates: handleRequestAvailableDates,
              onNavigateToDateTopic: handleNavigateToDateTopic,
              onBatchMoveCategory: _cache[10] || (_cache[10] = ($event) => _ctx.$emit("batch-move-category", $event))
            }, null, 8, ["group", "accordion-state", "hover-to-expand-enabled", "global-move-mode"]);
          }), 128)),
          dateGroupPaginationInfo.value.totalPages > 1 ? (openBlock(), createElementBlock("div", _hoisted_17$G, [
            createBaseVNode("div", _hoisted_18$E, [
              createBaseVNode("div", _hoisted_19$E, [
                createBaseVNode("button", {
                  onClick: previousDateGroupPage,
                  disabled: !dateGroupPaginationInfo.value.hasPrevious,
                  class: "relative inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_20$D),
                createBaseVNode("button", {
                  onClick: nextDateGroupPage,
                  disabled: !dateGroupPaginationInfo.value.hasNext,
                  class: "ml-3 relative inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_21$D)
              ]),
              createBaseVNode("div", _hoisted_22$B, [
                createBaseVNode("div", null, [
                  createBaseVNode("p", _hoisted_23$B, toDisplayString$1(unref(t)("vocabulary.showingDateGroups", {
                    start: dateGroupPaginationInfo.value.startIndex,
                    end: dateGroupPaginationInfo.value.endIndex,
                    total: dateGroupPaginationInfo.value.totalGroups
                  }, `Showing ${dateGroupPaginationInfo.value.startIndex} to ${dateGroupPaginationInfo.value.endIndex} of ${dateGroupPaginationInfo.value.totalGroups} date groups`)), 1)
                ]),
                createBaseVNode("div", null, [
                  createBaseVNode("nav", _hoisted_24$A, [
                    createBaseVNode("button", {
                      onClick: previousDateGroupPage,
                      disabled: !dateGroupPaginationInfo.value.hasPrevious,
                      class: "relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, [
                      createBaseVNode("span", _hoisted_26$y, toDisplayString$1(unref(t)("common.previous", "Previous")), 1),
                      _cache[23] || (_cache[23] = createBaseVNode("svg", {
                        class: "h-5 w-5",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                          "clip-rule": "evenodd"
                        })
                      ], -1))
                    ], 8, _hoisted_25$A),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(visibleDateGroupPages.value, (page) => {
                      return openBlock(), createElementBlock("button", {
                        key: page,
                        onClick: ($event) => page > 0 ? goToDateGroupPage(page) : null,
                        disabled: page === -1,
                        class: normalizeClass([
                          page === dateGroupPaginationInfo.value.currentPage ? "z-10 bg-blue-50 dark:bg-blue-900 border-blue-500 dark:border-blue-400 text-blue-600 dark:text-blue-300" : page === -1 ? "bg-white dark:bg-[#0a0a0a] border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-400 cursor-default" : "bg-white dark:bg-[#0a0a0a] border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600",
                          "relative inline-flex items-center px-4 py-2 border text-sm font-medium"
                        ])
                      }, toDisplayString$1(page === -1 ? "..." : page), 11, _hoisted_27$x);
                    }), 128)),
                    createBaseVNode("button", {
                      onClick: nextDateGroupPage,
                      disabled: !dateGroupPaginationInfo.value.hasNext,
                      class: "relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, [
                      createBaseVNode("span", _hoisted_29$u, toDisplayString$1(unref(t)("common.next", "Next")), 1),
                      _cache[24] || (_cache[24] = createBaseVNode("svg", {
                        class: "h-5 w-5",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                          "clip-rule": "evenodd"
                        })
                      ], -1))
                    ], 8, _hoisted_28$w)
                  ])
                ])
              ])
            ])
          ])) : createCommentVNode("", true)
        ])) : (openBlock(), createElementBlock("div", _hoisted_30$t, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.paginatedWords, (word) => {
            return openBlock(), createBlock(unref(VocabularyCard), {
              key: word.id,
              word,
              onPlayAudio: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("play-audio", $event)),
              onEditWord: _cache[12] || (_cache[12] = ($event) => _ctx.$emit("edit-word", $event)),
              onDeleteWord: _cache[13] || (_cache[13] = ($event) => _ctx.$emit("delete-word", $event)),
              onToggleFavorite: _cache[14] || (_cache[14] = ($event) => _ctx.$emit("toggle-favorite", $event)),
              onViewDetails: _cache[15] || (_cache[15] = ($event) => _ctx.$emit("view-details", $event))
            }, null, 8, ["word"]);
          }), 128))
        ])),
        !_ctx.useGrouping ? (openBlock(), createElementBlock("div", _hoisted_31$s, [
          createBaseVNode("div", _hoisted_32$p, [
            createBaseVNode("div", _hoisted_33$p, [
              createBaseVNode("button", {
                onClick: _cache[16] || (_cache[16] = ($event) => _ctx.$emit("previous-page")),
                disabled: _ctx.currentPage === 1,
                class: "relative inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600"
              }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_34$m),
              createBaseVNode("button", {
                onClick: _cache[17] || (_cache[17] = ($event) => _ctx.$emit("next-page")),
                disabled: _ctx.currentPage === _ctx.totalPages,
                class: "ml-3 relative inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600"
              }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_35$m)
            ]),
            createBaseVNode("div", _hoisted_36$l, [
              createBaseVNode("div", null, [
                createBaseVNode("p", _hoisted_37$k, toDisplayString$1(unref(t)("vocabulary.showingResults", { start: _ctx.startIndex, end: _ctx.endIndex, total: _ctx.totalCount }, `Showing ${_ctx.startIndex} to ${_ctx.endIndex} of ${_ctx.totalCount} results`)), 1)
              ]),
              createBaseVNode("div", null, [
                createBaseVNode("nav", _hoisted_38$k, [
                  createBaseVNode("button", {
                    onClick: _cache[18] || (_cache[18] = ($event) => _ctx.$emit("previous-page")),
                    disabled: _ctx.currentPage === 1,
                    class: "relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                  }, [
                    createBaseVNode("span", _hoisted_40$i, toDisplayString$1(unref(t)("common.previous", "Previous")), 1),
                    _cache[25] || (_cache[25] = createBaseVNode("svg", {
                      class: "h-5 w-5",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                        "clip-rule": "evenodd"
                      })
                    ], -1))
                  ], 8, _hoisted_39$i),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.visiblePages, (page) => {
                    return openBlock(), createElementBlock("button", {
                      key: page,
                      onClick: ($event) => _ctx.$emit("go-to-page", page),
                      class: normalizeClass([page === _ctx.currentPage ? "bg-blue-50 dark:bg-blue-900 border-blue-500 dark:border-blue-400 text-blue-600 dark:text-blue-300" : "bg-white dark:bg-[#0a0a0a] border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600", "relative inline-flex items-center px-4 py-2 border text-sm font-medium"])
                    }, toDisplayString$1(page), 11, _hoisted_41$h);
                  }), 128)),
                  createBaseVNode("button", {
                    onClick: _cache[19] || (_cache[19] = ($event) => _ctx.$emit("next-page")),
                    disabled: _ctx.currentPage === _ctx.totalPages,
                    class: "relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                  }, [
                    createBaseVNode("span", _hoisted_43$e, toDisplayString$1(unref(t)("common.next", "Next")), 1),
                    _cache[26] || (_cache[26] = createBaseVNode("svg", {
                      class: "h-5 w-5",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l4 4a1 1 0 01-1.414 0z",
                        "clip-rule": "evenodd"
                      })
                    ], -1))
                  ], 8, _hoisted_42$f)
                ])
              ])
            ])
          ])
        ])) : createCommentVNode("", true)
      ], 32);
    };
  }
});

const VocabularyList = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$12
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$11 = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$_ = { class: "w-full max-h-[90vh] flex flex-col max-w-full sm:max-w-lg md:max-w-2xl lg:max-w-4xl" };
const _hoisted_3$Y = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$W = { class: "flex items-center justify-between" };
const _hoisted_5$T = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$R = { class: "grid grid-cols-1 md:grid-cols-2 gap-6" };
const _hoisted_7$P = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_8$P = {
  for: "word",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_9$O = { class: "relative" };
const _hoisted_10$N = ["placeholder"];
const _hoisted_11$N = ["title", "aria-label"];
const _hoisted_12$M = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_13$M = {
  for: "pronunciation",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_14$M = { class: "relative" };
const _hoisted_15$H = ["placeholder"];
const _hoisted_16$G = ["title", "aria-label"];
const _hoisted_17$F = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_18$D = {
  for: "partOfSpeech",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_19$D = { value: "" };
const _hoisted_20$C = { value: "noun" };
const _hoisted_21$C = { value: "verb" };
const _hoisted_22$A = { value: "adjective" };
const _hoisted_23$A = { value: "adverb" };
const _hoisted_24$z = { value: "preposition" };
const _hoisted_25$z = { value: "conjunction" };
const _hoisted_26$x = { value: "interjection" };
const _hoisted_27$w = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_28$v = {
  for: "category",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_29$t = { class: "relative" };
const _hoisted_30$s = ["title"];
const _hoisted_31$r = { class: "relative" };
const _hoisted_32$o = ["placeholder", "value"];
const _hoisted_33$o = { class: "absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none" };
const _hoisted_34$l = ["placeholder"];
const _hoisted_35$l = { class: "max-h-40 overflow-y-auto" };
const _hoisted_36$k = {
  key: 0,
  class: "px-3 py-2 text-sm text-gray-500 dark:text-gray-400"
};
const _hoisted_37$j = ["onClick"];
const _hoisted_38$j = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_39$h = {
  for: "level",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_40$h = { value: "" };
const _hoisted_41$g = { value: "beginner" };
const _hoisted_42$e = { value: "intermediate" };
const _hoisted_43$d = { value: "advanced" };
const _hoisted_44$d = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_45$c = {
  for: "meaning",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_46$c = ["placeholder"];
const _hoisted_47$c = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_48$c = {
  for: "example",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_49$b = ["placeholder"];
const _hoisted_50$a = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.8s" }
};
const _hoisted_51$9 = {
  for: "synonyms",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_52$9 = ["placeholder"];
const _hoisted_53$9 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.9s" }
};
const _hoisted_54$9 = {
  for: "antonyms",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_55$9 = ["placeholder"];
const _hoisted_56$9 = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "1.0s" }
};
const _hoisted_57$9 = {
  for: "imageUrl",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_58$9 = ["placeholder"];
const _hoisted_59$8 = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "1.1s" }
};
const _hoisted_60$8 = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "1.2s" }
};
const _hoisted_61$7 = { class: "flex items-center p-3 bg-gray-50 dark:bg-[#0a0a0a] rounded-lg border border-gray-200 dark:border-gray-700 hover:bg-gray-100 dark:hover:bg-gray-800 transition-all duration-300" };
const _hoisted_62$7 = {
  for: "favorite",
  class: "ml-3 block text-sm text-gray-700 dark:text-white cursor-pointer hover:text-blue-600 dark:hover:text-blue-400 transition-colors duration-300"
};
const _hoisted_63$5 = { class: "px-6 py-4 border-t border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_64$5 = { class: "flex justify-end space-x-3" };
const _hoisted_65$5 = ["disabled"];
const _hoisted_66$5 = {
  key: 0,
  class: "animate-spin h-4 w-4",
  fill: "none",
  viewBox: "0 0 24 24"
};
const SEARCH_FREQUENCY_KEY = "vocabulary-category-search-frequency";
const _sfc_main$11 = /* @__PURE__ */ defineComponent({
  __name: "VocabularyFormDialog",
  props: {
    modelValue: { type: Boolean },
    vocabulary: { default: null },
    targetDate: { default: null }
  },
  emits: ["update:modelValue", "vocabulary-saved"],
  setup(__props, { emit: __emit }) {
    const ImageUpload$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ImageUpload),true              ?void 0:void 0));
    const TopicManager = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => TopicManager$1),true              ?void 0:void 0));
    const IpaPickerModal$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => IpaPickerModal),true              ?void 0:void 0));
    const KoreanInputHelper$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => KoreanInputHelper),true              ?void 0:void 0));
    const KoreanPronunciationHelper = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => KoreanPronunciationHelper$1),true              ?void 0:void 0));
    const props = __props;
    const emit = __emit;
    const { t, locale } = useI18n();
    const toast = useToast();
    const vocabularyStore = useVocabularyStore();
    const isSubmitting = ref(false);
    const refreshTrigger = ref(0);
    const showTopicManager = ref(false);
    const showKoreanInputHelper = ref(false);
    const showKoreanPronunciationHelper = ref(false);
    const categorySearchQuery = ref("");
    const showCategoryDropdown = ref(false);
    const categorySearchInput = ref(null);
    const dropdownElement = ref(null);
    const modalContentRef = ref(null);
    const categorySearchFrequency = ref({});
    const searchFrequencyTimeout = ref(null);
    const loadSearchFrequency = () => {
      try {
        const stored = localStorage.getItem(SEARCH_FREQUENCY_KEY);
        if (stored) {
          categorySearchFrequency.value = JSON.parse(stored);
        }
      } catch (error) {
        console.warn("Failed to load search frequency:", error);
        categorySearchFrequency.value = {};
      }
    };
    const saveSearchFrequency = () => {
      try {
        localStorage.setItem(SEARCH_FREQUENCY_KEY, JSON.stringify(categorySearchFrequency.value));
      } catch (error) {
        console.warn("Failed to save search frequency:", error);
      }
    };
    const updateSearchFrequency = (categoryKey) => {
      if (!categoryKey) return;
      categorySearchFrequency.value[categoryKey] = (categorySearchFrequency.value[categoryKey] || 0) + 1;
      saveSearchFrequency();
      console.log("Updated search frequency for:", categoryKey, "new count:", categorySearchFrequency.value[categoryKey]);
    };
    const categoryKeys = computed(() => {
      refreshTrigger.value;
      const categories = vocabularyStore.getCategories.value;
      console.log("Category keys computed with refreshTrigger:", refreshTrigger.value, "Categories:", categories);
      return categories;
    });
    const form = reactive({
      word: "",
      pronunciation: "",
      partOfSpeech: "",
      meaning: "",
      example: "",
      category: "",
      level: "",
      synonyms: "",
      antonyms: "",
      notes: "",
      favorite: false,
      image: null
    });
    const showIpaPicker = ref(false);
    const openIpaPicker = () => {
      showIpaPicker.value = true;
    };
    const onIpaApply = (value) => {
      form.pronunciation = value;
    };
    const openKoreanInputHelper = () => {
      showKoreanInputHelper.value = true;
    };
    const onKoreanInputConfirmed = (value) => {
      form.word = value;
    };
    const openKoreanPronunciationHelper = () => {
      showKoreanPronunciationHelper.value = true;
    };
    const onKoreanPronunciationConfirmed = (value) => {
      form.pronunciation = value;
    };
    const isEditing = computed(() => !!props.vocabulary);
    const categoryUsage = computed(() => vocabularyStore.getCategoryUsage.value);
    const isKoreanLocale = computed(() => locale.value === "ko");
    const filteredCategoryKeys = computed(() => {
      let filtered;
      if (!categorySearchQuery.value.trim()) {
        filtered = [...categoryKeys.value];
      } else {
        const query = categorySearchQuery.value.toLowerCase();
        filtered = categoryKeys.value.filter(
          (key) => getTopicDisplayName(key).toLowerCase().includes(query)
        );
        if (query.length >= 2) {
          filtered.forEach((key) => {
            if (getTopicDisplayName(key).toLowerCase().includes(query)) {
              if (searchFrequencyTimeout.value) {
                clearTimeout(searchFrequencyTimeout.value);
              }
              searchFrequencyTimeout.value = setTimeout(() => {
                updateSearchFrequency(key);
              }, 1e3);
            }
          });
        }
      }
      return filtered.sort((a, b) => {
        const freqA = categorySearchFrequency.value[a] || 0;
        const freqB = categorySearchFrequency.value[b] || 0;
        if (freqA !== freqB) {
          return freqB - freqA;
        }
        return getTopicDisplayName(a).localeCompare(getTopicDisplayName(b));
      });
    });
    const simpleDropdownStyle = computed(() => {
      if (!showCategoryDropdown.value) {
        return { display: "none" };
      }
      const inputElement = document.getElementById("category");
      if (!inputElement) {
        return {
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          width: "400px",
          maxWidth: "90vw"
        };
      }
      const rect = inputElement.getBoundingClientRect();
      return {
        top: rect.bottom + 4 + "px",
        left: rect.left + "px",
        width: Math.max(rect.width, 300) + "px",
        maxWidth: "500px"
      };
    });
    const validateWord = () => {
      if (!form.word.trim()) {
        toast.error(t("vocabulary.validation.wordRequired", "Word is required"));
        return false;
      } else if (form.word.trim().length > 100) {
        toast.error(t("vocabulary.validation.wordTooLong", "Word is too long"));
        return false;
      }
      return true;
    };
    const validateMeaning = () => {
      if (!form.meaning.trim()) {
        toast.error(t("vocabulary.validation.meaningRequired", "Meaning is required"));
        return false;
      } else if (form.meaning.trim().length > 500) {
        toast.error(t("vocabulary.validation.meaningTooLong", "Meaning is too long"));
        return false;
      }
      return true;
    };
    const validatePartOfSpeech = () => {
      if (!form.partOfSpeech) {
        toast.error(t("vocabulary.validation.partOfSpeechRequired", "Part of speech is required"));
        return false;
      }
      return true;
    };
    const validateCategory = () => {
      if (!form.category) {
        toast.error(t("vocabulary.validation.categoryRequired", "Category is required"));
        return false;
      }
      return true;
    };
    const validateLevel = () => {
      if (!form.level) {
        toast.error(t("vocabulary.validation.levelRequired", "Level is required"));
        return false;
      }
      return true;
    };
    const validateExample = () => {
      if (form.example.length > 500) {
        toast.error(t("vocabulary.validation.exampleTooLong", "Example is too long"));
        return false;
      }
      return true;
    };
    const validateNotes = () => {
      if (form.notes.length > 500) {
        toast.error(t("vocabulary.validation.notesTooLong", "Notes are too long"));
        return false;
      }
      return true;
    };
    const validatePronunciation = () => {
      if (form.pronunciation.length > 100) {
        toast.error(t("vocabulary.validation.pronunciationTooLong", "Pronunciation is too long"));
        return false;
      }
      return true;
    };
    const validateSynonyms = () => {
      if (form.synonyms && form.synonyms.trim()) {
        const synonyms = form.synonyms.split(",").map((s) => s.trim()).filter((s) => s);
        if (synonyms.length === 0) {
          toast.error(t("vocabulary.validation.synonymsInvalid", "Synonyms are invalid"));
          return false;
        }
      }
      return true;
    };
    const validateAntonyms = () => {
      if (form.antonyms && form.antonyms.trim()) {
        const antonyms = form.antonyms.split(",").map((s) => s.trim()).filter((s) => s);
        if (antonyms.length === 0) {
          toast.error(t("vocabulary.validation.antonymsInvalid", "Antonyms are invalid"));
          return false;
        }
      }
      return true;
    };
    const resetForm = () => {
      form.word = "";
      form.pronunciation = "";
      form.partOfSpeech = "";
      form.meaning = "";
      form.example = "";
      form.category = "";
      form.level = "";
      form.synonyms = "";
      form.antonyms = "";
      form.notes = "";
      form.favorite = false;
    };
    const handleScroll = () => {
      if (showCategoryDropdown.value) {
        showCategoryDropdown.value = false;
        categorySearchQuery.value = "";
        console.log("Scroll detected, dropdown closed");
      }
    };
    onMounted(() => {
      loadSearchFrequency();
      console.log("Loaded category search frequency:", categorySearchFrequency.value);
      nextTick(() => {
        if (modalContentRef.value) {
          modalContentRef.value.addEventListener("scroll", handleScroll, { passive: true });
          console.log("Added scroll listener to modal content");
        }
      });
    });
    onUnmounted(() => {
      if (modalContentRef.value) {
        modalContentRef.value.removeEventListener("scroll", handleScroll);
        modalContentRef.value.removeEventListener("scroll", handleScroll);
        console.log("Removed scroll listeners from modal content");
      }
    });
    watch(() => props.modelValue, (isOpen) => {
      if (!isOpen) {
        showCategoryDropdown.value = false;
        categorySearchQuery.value = "";
        document.body.style.overflow = "";
        console.log("Modal closed, dropdown closed, body scroll enabled");
      } else {
        document.body.style.overflow = "hidden";
        nextTick(() => {
          setTimeout(() => {
            if (modalContentRef.value) {
              modalContentRef.value.addEventListener("scroll", handleScroll, { passive: true });
              console.log("Added scroll listener to modal content on modal open");
            }
          }, 100);
        });
        console.log("Modal opened, body scroll disabled");
      }
    });
    watch(
      () => props.vocabulary,
      (newVocabulary) => {
        if (newVocabulary) {
          form.word = newVocabulary.word;
          form.pronunciation = newVocabulary.pronunciation || "";
          form.partOfSpeech = newVocabulary.partOfSpeech;
          form.meaning = newVocabulary.meaning;
          form.example = newVocabulary.example || "";
          form.category = newVocabulary.category;
          form.level = newVocabulary.level;
          form.synonyms = newVocabulary.synonyms?.join(", ") || "";
          form.antonyms = newVocabulary.antonyms?.join(", ") || "";
          form.notes = newVocabulary.notes || "";
          form.favorite = !!newVocabulary.favorite;
          form.image = newVocabulary.image || null;
        } else {
          resetForm();
        }
      },
      { immediate: true }
    );
    const handleKeydown = (event) => {
      if (event.key === "Escape") {
        closeDialog();
      }
    };
    watch(() => props.modelValue, (newValue) => {
      if (newValue) {
        window.dispatchEvent(new CustomEvent("vocabulary-edit-word"));
        if (!props.vocabulary) {
          resetForm();
        }
        document.body.style.overflow = "hidden";
        document.addEventListener("keydown", handleKeydown);
      } else {
        document.body.style.overflow = "";
        document.removeEventListener("keydown", handleKeydown);
      }
    });
    const getTopicDisplayName = (category) => {
      return getTopicName(category, t, locale);
    };
    const toggleCategoryDropdown = () => {
      console.log("Toggle category dropdown clicked");
      showCategoryDropdown.value = !showCategoryDropdown.value;
      if (showCategoryDropdown.value) {
        categorySearchQuery.value = "";
        nextTick(() => {
          categorySearchInput.value?.focus();
        });
      }
    };
    const closeCategoryDropdown = () => {
      showCategoryDropdown.value = false;
      categorySearchQuery.value = "";
    };
    const openTopicManager = () => {
      if (showCategoryDropdown.value) {
        closeCategoryDropdown();
      }
      showTopicManager.value = true;
    };
    const selectCategory = (key) => {
      form.category = key;
      showCategoryDropdown.value = false;
      categorySearchQuery.value = "";
      updateSearchFrequency(key);
      console.log("Category selected:", getTopicDisplayName(key));
    };
    const onTopicAdded = (newTopic) => {
      console.log("Topic added, refreshing categories:", newTopic.key);
      setTimeout(() => {
        vocabularyStore.refreshCustomTopics();
        refreshTrigger.value++;
        form.category = newTopic.key;
        console.log("Categories refreshed, new topic selected:", newTopic.key);
      }, 150);
    };
    const onTopicUpdated = () => {
      refreshTrigger.value++;
      vocabularyStore.refreshCustomTopics();
      console.log("Topic updated, refreshing categories");
    };
    const onTopicDeleted = (deletedTopicId) => {
      refreshTrigger.value++;
      vocabularyStore.refreshCustomTopics();
      if (form.category === deletedTopicId) {
        form.category = "";
      }
      console.log("Topic deleted, refreshing categories:", deletedTopicId);
    };
    const handleTopicsUpdated = () => {
      setTimeout(() => {
        refreshTrigger.value++;
        vocabularyStore.refreshCustomTopics();
        console.log("Topics updated, refreshing categories in form dialog");
      }, 100);
    };
    const handleClickOutside = (event) => {
      if (!showCategoryDropdown.value) return;
      const target = event.target;
      const dropdownContainer = target.closest(".relative");
      const dropdownMenu = target.closest('[class*="z-[99999]"]');
      if (dropdownContainer || dropdownMenu) {
        return;
      }
      closeCategoryDropdown();
    };
    onMounted(() => {
      window.addEventListener("topics-updated", handleTopicsUpdated);
      document.addEventListener("click", handleClickOutside);
    });
    onUnmounted(() => {
      document.body.style.overflow = "";
      document.body.classList.remove("modal-open");
      document.removeEventListener("keydown", handleKeydown);
      window.removeEventListener("topics-updated", handleTopicsUpdated);
      document.removeEventListener("click", handleClickOutside);
    });
    const closeDialog = () => {
      window.dispatchEvent(new CustomEvent("vocabulary-modal-closed"));
      emit("update:modelValue", false);
    };
    const submitForm = async () => {
      if (isSubmitting.value) return;
      if (!validateWord()) return;
      if (!validatePronunciation()) return;
      if (!validatePartOfSpeech()) return;
      if (!validateCategory()) return;
      if (!validateLevel()) return;
      if (!validateMeaning()) return;
      if (!validateExample()) return;
      if (!validateSynonyms()) return;
      if (!validateAntonyms()) return;
      if (!validateNotes()) return;
      isSubmitting.value = true;
      try {
        await new Promise((resolve) => setTimeout(resolve, 500));
        const vocabularyData = {
          word: form.word.trim(),
          pronunciation: form.pronunciation.trim(),
          partOfSpeech: form.partOfSpeech,
          meaning: form.meaning.trim(),
          example: form.example.trim(),
          category: form.category,
          level: form.level,
          synonyms: form.synonyms ? form.synonyms.split(",").map((s) => s.trim()).filter((s) => s) : [],
          antonyms: form.antonyms ? form.antonyms.split(",").map((s) => s.trim()).filter((s) => s) : [],
          notes: form.notes.trim(),
          favorite: form.favorite,
          image: form.image
        };
        if (isEditing.value && props.vocabulary) {
          vocabularyStore.updateVocabulary(props.vocabulary.id, vocabularyData);
          console.log("Vocabulary updated:", props.vocabulary.id, vocabularyData);
          toast.success(t("vocabulary.validation.updateSuccess", "Vocabulary updated successfully!"));
        } else {
          if (props.targetDate) {
            const now = /* @__PURE__ */ new Date();
            const [year, month, day] = props.targetDate.split("-");
            const targetDateObj = new Date(parseInt(year), parseInt(month) - 1, parseInt(day), now.getHours(), now.getMinutes(), now.getSeconds(), now.getMilliseconds());
            vocabularyData.createdAt = targetDateObj.toISOString();
            vocabularyData.updatedAt = targetDateObj.toISOString();
          }
          const newVocabulary = vocabularyStore.addVocabulary(vocabularyData);
          console.log("Vocabulary added:", newVocabulary);
          toast.success(t("vocabulary.validation.saveSuccess", "Vocabulary added successfully!"));
        }
        emit("vocabulary-saved", { category: vocabularyData.category });
        setTimeout(() => {
          closeDialog();
        }, 500);
      } catch (error) {
        console.error("Error saving vocabulary:", error);
        toast.error(t("vocabulary.validation.saveError", "Error saving vocabulary"));
      } finally {
        isSubmitting.value = false;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$11, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$_, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 flex flex-col h-full overflow-hidden transform",
                      onClick: _cache[18] || (_cache[18] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$Y, [
                        createBaseVNode("div", _hoisted_4$W, [
                          createBaseVNode("h2", _hoisted_5$T, [
                            _cache[23] || (_cache[23] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(isEditing.value ? unref(t)("vocabulary.editVocabulary", "Edit Vocabulary") : unref(t)("vocabulary.addVocabulary", "Add Vocabulary")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: closeDialog,
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[24] || (_cache[24] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", {
                        ref_key: "modalContentRef",
                        ref: modalContentRef,
                        class: "px-6 py-4 flex-1 overflow-y-auto min-h-0"
                      }, [
                        createBaseVNode("form", {
                          onSubmit: withModifiers(submitForm, ["prevent"]),
                          class: "space-y-6"
                        }, [
                          createBaseVNode("div", _hoisted_6$R, [
                            createBaseVNode("div", _hoisted_7$P, [
                              createBaseVNode("label", _hoisted_8$P, [
                                _cache[25] || (_cache[25] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.word", "Word")) + " ", 1),
                                _cache[26] || (_cache[26] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              createBaseVNode("div", _hoisted_9$O, [
                                withDirectives(createBaseVNode("input", {
                                  id: "word",
                                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => form.word = $event),
                                  type: "text",
                                  required: "",
                                  class: normalizeClass([
                                    "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 hover:border-blue-400 dark:hover:border-blue-500 transform hover:scale-[1.02]",
                                    isKoreanLocale.value ? "pr-12" : ""
                                  ]),
                                  placeholder: isKoreanLocale.value ? unref(t)("korean.wordPlaceholder", "Enter Korean word or click + for help") : unref(t)("vocabulary.wordPlaceholder", "Enter English word"),
                                  onBlur: validateWord
                                }, null, 42, _hoisted_10$N), [
                                  [vModelText, form.word]
                                ]),
                                isKoreanLocale.value ? (openBlock(), createElementBlock("button", {
                                  key: 0,
                                  type: "button",
                                  onClick: openKoreanInputHelper,
                                  class: "absolute right-2 top-1/2 -translate-y-1/2 w-7 h-7 bg-blue-500 hover:bg-blue-600 text-white rounded-full flex items-center justify-center text-sm font-bold transition-all duration-300 hover:scale-110 z-[5] shadow-lg keep-center-hover",
                                  title: unref(t)("korean.inputHelper.openHelper", "Open Korean Input Helper"),
                                  "aria-label": unref(t)("korean.inputHelper.openHelper", "Open Korean Input Helper")
                                }, " + ", 8, _hoisted_11$N)) : createCommentVNode("", true)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_12$M, [
                              createBaseVNode("label", _hoisted_13$M, [
                                _cache[27] || (_cache[27] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.pronunciation.label", "Pronunciation")), 1)
                              ]),
                              createBaseVNode("div", _hoisted_14$M, [
                                withDirectives(createBaseVNode("input", {
                                  id: "pronunciation",
                                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => form.pronunciation = $event),
                                  type: "text",
                                  class: "w-full pr-12 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-300 hover:border-green-400 dark:hover:border-green-500 transform hover:scale-[1.02]",
                                  placeholder: isKoreanLocale.value ? unref(t)("korean.pronunciationPlaceholder", "an-nyeong-ha-se-yo") : "/ˈeksəmpl/",
                                  onBlur: validatePronunciation
                                }, null, 40, _hoisted_15$H), [
                                  [vModelText, form.pronunciation]
                                ]),
                                createBaseVNode("button", {
                                  type: "button",
                                  onClick: _cache[2] || (_cache[2] = ($event) => isKoreanLocale.value ? openKoreanPronunciationHelper() : openIpaPicker()),
                                  class: "absolute right-2 top-1/2 -translate-y-1/2 w-7 h-7 bg-green-500 hover:bg-green-600 text-white rounded-full flex items-center justify-center text-sm font-bold transition-all duration-300 hover:scale-110 z-[5] shadow-lg keep-center-hover",
                                  title: isKoreanLocale.value ? unref(t)("korean.pronunciationHelper.openHelper", "Open Korean Pronunciation Helper") : unref(t)("vocabulary.pronunciation.openIpaPicker", "Open IPA Picker"),
                                  "aria-label": isKoreanLocale.value ? unref(t)("korean.pronunciationHelper.openHelper", "Open Korean Pronunciation Helper") : unref(t)("vocabulary.pronunciation.openIpaPicker", "Open IPA Picker")
                                }, " + ", 8, _hoisted_16$G)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_17$F, [
                              createBaseVNode("label", _hoisted_18$D, [
                                _cache[28] || (_cache[28] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.wordType", "Word Type")) + " ", 1),
                                _cache[29] || (_cache[29] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              withDirectives(createBaseVNode("select", {
                                id: "partOfSpeech",
                                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => form.partOfSpeech = $event),
                                required: "",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-300 hover:border-purple-400 dark:hover:border-purple-500 transform hover:scale-[1.02] cursor-pointer",
                                onChange: validatePartOfSpeech
                              }, [
                                createBaseVNode("option", _hoisted_19$D, toDisplayString$1(unref(t)("vocabulary.selectWordType", "Select word type")), 1),
                                createBaseVNode("option", _hoisted_20$C, toDisplayString$1(unref(t)("vocabulary.wordTypes.noun", "Noun")), 1),
                                createBaseVNode("option", _hoisted_21$C, toDisplayString$1(unref(t)("vocabulary.wordTypes.verb", "Verb")), 1),
                                createBaseVNode("option", _hoisted_22$A, toDisplayString$1(unref(t)("vocabulary.wordTypes.adjective", "Adjective")), 1),
                                createBaseVNode("option", _hoisted_23$A, toDisplayString$1(unref(t)("vocabulary.wordTypes.adverb", "Adverb")), 1),
                                createBaseVNode("option", _hoisted_24$z, toDisplayString$1(unref(t)("vocabulary.wordTypes.preposition", "Preposition")), 1),
                                createBaseVNode("option", _hoisted_25$z, toDisplayString$1(unref(t)("vocabulary.wordTypes.conjunction", "Conjunction")), 1),
                                createBaseVNode("option", _hoisted_26$x, toDisplayString$1(unref(t)("vocabulary.wordTypes.interjection", "Interjection")), 1)
                              ], 544), [
                                [vModelSelect, form.partOfSpeech]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_27$w, [
                              createBaseVNode("label", _hoisted_28$v, [
                                _cache[30] || (_cache[30] = createBaseVNode("span", { class: "w-1 h-4 bg-orange-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.category", "Category")) + " ", 1),
                                _cache[31] || (_cache[31] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              createBaseVNode("div", _hoisted_29$t, [
                                createBaseVNode("button", {
                                  type: "button",
                                  onClick: _cache[4] || (_cache[4] = ($event) => openTopicManager()),
                                  class: "absolute left-2 top-1/2 transform -translate-y-1/2 w-6 h-6 bg-blue-500 hover:bg-blue-600 text-white rounded-full flex items-center justify-center text-sm font-bold transition-all duration-300 hover:scale-110 hover:rotate-90 z-[10000] shadow-lg keep-center-hover-rotate",
                                  title: unref(t)("vocabulary.addCategory", "Add Category")
                                }, " + ", 8, _hoisted_30$s),
                                createBaseVNode("div", _hoisted_31$r, [
                                  createBaseVNode("input", {
                                    id: "category",
                                    type: "text",
                                    required: "",
                                    readonly: "",
                                    onClick: toggleCategoryDropdown,
                                    class: "w-full pl-10 pr-10 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all duration-300 hover:border-orange-400 dark:hover:border-orange-500 transform hover:scale-[1.02] cursor-pointer",
                                    placeholder: unref(t)("vocabulary.selectCategory", "Select category"),
                                    value: form.category ? getTopicDisplayName(form.category) : ""
                                  }, null, 8, _hoisted_32$o),
                                  createBaseVNode("div", _hoisted_33$o, [
                                    (openBlock(), createElementBlock("svg", {
                                      class: normalizeClass(["w-4 h-4 text-gray-400 transition-transform duration-200", { "rotate-180": showCategoryDropdown.value }]),
                                      fill: "none",
                                      stroke: "currentColor",
                                      viewBox: "0 0 24 24"
                                    }, _cache[32] || (_cache[32] = [
                                      createBaseVNode("path", {
                                        "stroke-linecap": "round",
                                        "stroke-linejoin": "round",
                                        "stroke-width": "2",
                                        d: "M19 9l-7 7-7-7"
                                      }, null, -1)
                                    ]), 2))
                                  ]),
                                  (openBlock(), createBlock(Teleport, { to: "body" }, [
                                    createVNode(Transition, {
                                      "enter-active-class": "transition duration-200 ease-out",
                                      "enter-from-class": "transform scale-95 opacity-0",
                                      "enter-to-class": "transform scale-100 opacity-100",
                                      "leave-active-class": "transition duration-75 ease-in",
                                      "leave-from-class": "transform scale-100 opacity-100",
                                      "leave-to-class": "transform scale-95 opacity-0"
                                    }, {
                                      default: withCtx(() => [
                                        showCategoryDropdown.value ? (openBlock(), createElementBlock("div", {
                                          key: 0,
                                          ref_key: "dropdownElement",
                                          ref: dropdownElement,
                                          style: normalizeStyle(simpleDropdownStyle.value),
                                          class: "fixed z-[9999] bg-white dark:bg-[#0a0a0a] border border-gray-300 dark:border-gray-600 rounded-lg shadow-xl max-h-60 overflow-hidden"
                                        }, [
                                          createBaseVNode("div", {
                                            class: "p-2 border-b border-gray-200 dark:border-gray-600",
                                            onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                                            }, ["stop"]))
                                          }, [
                                            withDirectives(createBaseVNode("input", {
                                              ref_key: "categorySearchInput",
                                              ref: categorySearchInput,
                                              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => categorySearchQuery.value = $event),
                                              type: "text",
                                              class: "w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent",
                                              placeholder: unref(t)("vocabulary.searchCategory", "Search categories..."),
                                              onKeydown: [
                                                _cache[6] || (_cache[6] = withKeys(withModifiers(() => {
                                                }, ["prevent"]), ["enter"])),
                                                withKeys(closeCategoryDropdown, ["escape"])
                                              ],
                                              onClick: _cache[7] || (_cache[7] = withModifiers(() => {
                                              }, ["stop"])),
                                              onFocus: _cache[8] || (_cache[8] = withModifiers(() => {
                                              }, ["stop"]))
                                            }, null, 40, _hoisted_34$l), [
                                              [vModelText, categorySearchQuery.value]
                                            ])
                                          ]),
                                          createBaseVNode("div", _hoisted_35$l, [
                                            filteredCategoryKeys.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_36$k, toDisplayString$1(unref(t)("vocabulary.noCategories", "No categories found")), 1)) : createCommentVNode("", true),
                                            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredCategoryKeys.value, (key) => {
                                              return openBlock(), createElementBlock("div", {
                                                key,
                                                class: normalizeClass(["px-3 py-2 text-sm cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-custom transition-colors duration-150", { "bg-orange-50 dark:bg-orange-900/20 text-orange-700 dark:text-orange-300": form.category === key }]),
                                                onClick: ($event) => selectCategory(key)
                                              }, toDisplayString$1(getTopicDisplayName(key)), 11, _hoisted_37$j);
                                            }), 128))
                                          ])
                                        ], 4)) : createCommentVNode("", true)
                                      ]),
                                      _: 1
                                    })
                                  ]))
                                ])
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_38$j, [
                              createBaseVNode("label", _hoisted_39$h, [
                                _cache[33] || (_cache[33] = createBaseVNode("span", { class: "w-1 h-4 bg-red-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.level", "Level")) + " ", 1),
                                _cache[34] || (_cache[34] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              withDirectives(createBaseVNode("select", {
                                id: "level",
                                "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => form.level = $event),
                                required: "",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all duration-300 hover:border-red-400 dark:hover:border-red-500 transform hover:scale-[1.02] cursor-pointer",
                                onChange: validateLevel
                              }, [
                                createBaseVNode("option", _hoisted_40$h, toDisplayString$1(unref(t)("vocabulary.selectLevel", "Select level")), 1),
                                createBaseVNode("option", _hoisted_41$g, toDisplayString$1(unref(t)("vocabulary.levels.beginner", "Beginner")), 1),
                                createBaseVNode("option", _hoisted_42$e, toDisplayString$1(unref(t)("vocabulary.levels.intermediate", "Intermediate")), 1),
                                createBaseVNode("option", _hoisted_43$d, toDisplayString$1(unref(t)("vocabulary.levels.advanced", "Advanced")), 1)
                              ], 544), [
                                [vModelSelect, form.level]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_44$d, [
                              createBaseVNode("label", _hoisted_45$c, [
                                _cache[35] || (_cache[35] = createBaseVNode("span", { class: "w-1 h-4 bg-indigo-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.meaning", "Meaning")) + " ", 1),
                                _cache[36] || (_cache[36] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              withDirectives(createBaseVNode("textarea", {
                                id: "meaning",
                                "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => form.meaning = $event),
                                required: "",
                                rows: "3",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent resize-none transition-all duration-300 hover:border-indigo-400 dark:hover:border-indigo-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("vocabulary.meaningPlaceholder", "Enter meaning in Vietnamese"),
                                onBlur: validateMeaning
                              }, null, 40, _hoisted_46$c), [
                                [vModelText, form.meaning]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_47$c, [
                              createBaseVNode("label", _hoisted_48$c, [
                                _cache[37] || (_cache[37] = createBaseVNode("span", { class: "w-1 h-4 bg-teal-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.example", "Example")), 1)
                              ]),
                              withDirectives(createBaseVNode("textarea", {
                                id: "example",
                                "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => form.example = $event),
                                rows: "2",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all duration-300 hover:border-teal-400 dark:hover:border-teal-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("vocabulary.examplePlaceholder", "Enter example sentence"),
                                onBlur: validateExample
                              }, null, 40, _hoisted_49$b), [
                                [vModelText, form.example]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_50$a, [
                              createBaseVNode("label", _hoisted_51$9, [
                                _cache[38] || (_cache[38] = createBaseVNode("span", { class: "w-1 h-4 bg-pink-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.synonyms", "Synonyms")), 1)
                              ]),
                              withDirectives(createBaseVNode("input", {
                                id: "synonyms",
                                "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => form.synonyms = $event),
                                type: "text",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-transparent transition-all duration-300 hover:border-pink-400 dark:hover:border-pink-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("vocabulary.separateByComma", "Separate by comma"),
                                onBlur: validateSynonyms
                              }, null, 40, _hoisted_52$9), [
                                [vModelText, form.synonyms]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_53$9, [
                              createBaseVNode("label", _hoisted_54$9, [
                                _cache[39] || (_cache[39] = createBaseVNode("span", { class: "w-1 h-4 bg-yellow-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.antonyms", "Antonyms")), 1)
                              ]),
                              withDirectives(createBaseVNode("input", {
                                id: "antonyms",
                                "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => form.antonyms = $event),
                                type: "text",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent transition-all duration-300 hover:border-yellow-400 dark:hover:border-yellow-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("vocabulary.separateByComma", "Separate by comma"),
                                onBlur: validateAntonyms
                              }, null, 40, _hoisted_55$9), [
                                [vModelText, form.antonyms]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_56$9, [
                              createBaseVNode("label", _hoisted_57$9, [
                                _cache[40] || (_cache[40] = createBaseVNode("span", { class: "w-1 h-4 bg-cyan-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.imageUrl", "Image URL")), 1)
                              ]),
                              withDirectives(createBaseVNode("textarea", {
                                id: "imageUrl",
                                "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => form.image = $event),
                                rows: "3",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent resize-none transition-all duration-300 hover:border-cyan-400 dark:hover:border-cyan-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("vocabulary.imageUrlPlaceholder", "Enter image URL (optional)")
                              }, null, 8, _hoisted_58$9), [
                                [vModelText, form.image]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_59$8, [
                              createVNode(unref(ImageUpload$1), {
                                modelValue: form.image,
                                "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => form.image = $event)
                              }, null, 8, ["modelValue"])
                            ]),
                            createBaseVNode("div", _hoisted_60$8, [
                              createBaseVNode("div", _hoisted_61$7, [
                                withDirectives(createBaseVNode("input", {
                                  id: "favorite",
                                  "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => form.favorite = $event),
                                  type: "checkbox",
                                  class: "h-5 w-5 text-blue-600 focus:ring-blue-500 border-gray-300 dark:border-gray-600 rounded transition-all duration-300 hover:scale-110 cursor-pointer"
                                }, null, 512), [
                                  [vModelCheckbox, form.favorite]
                                ]),
                                createBaseVNode("label", _hoisted_62$7, toDisplayString$1(unref(t)("vocabulary.isFavorite", "Mark as favorite")), 1)
                              ])
                            ])
                          ])
                        ], 32)
                      ], 512),
                      createBaseVNode("div", _hoisted_63$5, [
                        createBaseVNode("div", _hoisted_64$5, [
                          createBaseVNode("button", {
                            type: "button",
                            onClick: closeDialog,
                            class: "px-6 py-2 text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium"
                          }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                          createBaseVNode("button", {
                            onClick: submitForm,
                            disabled: isSubmitting.value,
                            class: "px-6 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg hover:from-blue-600 hover:to-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 flex items-center space-x-2 transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium disabled:cursor-not-allowed"
                          }, [
                            isSubmitting.value ? (openBlock(), createElementBlock("svg", _hoisted_66$5, _cache[41] || (_cache[41] = [
                              createBaseVNode("circle", {
                                class: "opacity-25",
                                cx: "12",
                                cy: "12",
                                r: "10",
                                stroke: "currentColor",
                                "stroke-width": "4"
                              }, null, -1),
                              createBaseVNode("path", {
                                class: "opacity-75",
                                fill: "currentColor",
                                d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                              }, null, -1)
                            ]))) : createCommentVNode("", true),
                            createBaseVNode("span", null, toDisplayString$1(isSubmitting.value ? unref(t)("common.saving", "Saving...") : isEditing.value ? unref(t)("common.update", "Update") : unref(t)("vocabulary.saveVocabulary", "Save Vocabulary")), 1)
                          ], 8, _hoisted_65$5)
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        }),
        createVNode(unref(IpaPickerModal$1), {
          modelValue: showIpaPicker.value,
          "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => showIpaPicker.value = $event),
          "initial-value": form.pronunciation,
          onApply: onIpaApply
        }, null, 8, ["modelValue", "initial-value"]),
        showTopicManager.value ? (openBlock(), createBlock(unref(TopicManager), {
          key: 0,
          modelValue: showTopicManager.value,
          "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => showTopicManager.value = $event),
          "vocabulary-usage": categoryUsage.value,
          onTopicAdded,
          onTopicUpdated,
          onTopicDeleted
        }, null, 8, ["modelValue", "vocabulary-usage"])) : createCommentVNode("", true),
        showKoreanInputHelper.value ? (openBlock(), createBlock(unref(KoreanInputHelper$1), {
          key: 1,
          modelValue: showKoreanInputHelper.value,
          "onUpdate:modelValue": _cache[21] || (_cache[21] = ($event) => showKoreanInputHelper.value = $event),
          "initial-value": form.word,
          onInputConfirmed: onKoreanInputConfirmed
        }, null, 8, ["modelValue", "initial-value"])) : createCommentVNode("", true),
        showKoreanPronunciationHelper.value ? (openBlock(), createBlock(unref(KoreanPronunciationHelper), {
          key: 2,
          modelValue: showKoreanPronunciationHelper.value,
          "onUpdate:modelValue": _cache[22] || (_cache[22] = ($event) => showKoreanPronunciationHelper.value = $event),
          "initial-value": form.pronunciation,
          onPronunciationConfirmed: onKoreanPronunciationConfirmed
        }, null, 8, ["modelValue", "initial-value"])) : createCommentVNode("", true)
      ]);
    };
  }
});

const VocabularyFormDialog = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["__scopeId", "data-v-c4851cdd"]]);

const VocabularyFormDialog$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: VocabularyFormDialog
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$10 = { class: "flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-600 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] rounded-t-lg" };
const _hoisted_2$Z = { class: "text-lg font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_3$X = {
  key: 0,
  class: "p-6 overflow-y-auto flex-1"
};
const _hoisted_4$V = {
  class: "mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_5$S = { class: "flex items-center space-x-4 mb-2" };
const _hoisted_6$Q = { class: "text-3xl font-bold text-gray-900 dark:text-white" };
const _hoisted_7$O = ["title"];
const _hoisted_8$O = ["title"];
const _hoisted_9$N = {
  class: "w-6 h-6",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_10$M = {
  key: 0,
  d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"
};
const _hoisted_11$M = {
  key: 1,
  d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2"
};
const _hoisted_12$L = { class: "text-lg text-gray-600 dark:text-gray-300 mb-1" };
const _hoisted_13$L = { class: "flex items-center space-x-3" };
const _hoisted_14$L = { class: "px-3 py-1 text-sm bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-full transition-all duration-300 hover:scale-105" };
const _hoisted_15$G = { class: "px-3 py-1 text-sm bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 rounded-full transition-all duration-300 hover:scale-105" };
const _hoisted_16$F = {
  key: 0,
  class: "mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_17$E = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-3 flex items-center" };
const _hoisted_18$C = { class: "flex justify-center" };
const _hoisted_19$C = { class: "max-w-md w-full" };
const _hoisted_20$B = { class: "relative rounded-lg overflow-hidden border-2 border-gray-200 dark:border-gray-600 shadow-lg" };
const _hoisted_21$B = ["src", "alt"];
const _hoisted_22$z = { class: "absolute inset-0 bg-black bg-opacity-0 hover:bg-opacity-10 transition-all duration-200 flex items-center justify-center opacity-0 hover:opacity-100" };
const _hoisted_23$z = { class: "bg-white dark:bg-gray-800 bg-opacity-90 dark:bg-opacity-90 px-3 py-1 rounded-full" };
const _hoisted_24$y = { class: "text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_25$y = {
  class: "mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_26$w = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-2 flex items-center" };
const _hoisted_27$v = { class: "text-gray-700 dark:text-gray-300 text-lg" };
const _hoisted_28$u = {
  key: 1,
  class: "mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_29$s = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-2 flex items-center" };
const _hoisted_30$r = { class: "bg-gray-50 dark:bg-gray-800 rounded-lg p-4" };
const _hoisted_31$q = { class: "flex items-start space-x-3" };
const _hoisted_32$n = { class: "flex-1" };
const _hoisted_33$n = { class: "text-gray-700 dark:text-gray-300 italic text-lg" };
const _hoisted_34$k = ["title"];
const _hoisted_35$k = {
  key: 2,
  class: "mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_36$j = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-2 flex items-center" };
const _hoisted_37$i = { class: "flex flex-wrap gap-2" };
const _hoisted_38$i = {
  key: 3,
  class: "mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_39$g = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-2 flex items-center" };
const _hoisted_40$g = { class: "flex flex-wrap gap-2" };
const _hoisted_41$f = {
  key: 4,
  class: "mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_42$d = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-2 flex items-center" };
const _hoisted_43$c = { class: "bg-yellow-50 dark:bg-yellow-900/10 border-l-4 border-yellow-400 dark:border-yellow-500 p-4" };
const _hoisted_44$c = { class: "text-gray-700 dark:text-gray-300" };
const _hoisted_45$b = {
  class: "border-t border-gray-200 dark:border-gray-600 pt-4 animate-fade-in-up",
  style: { "animation-delay": "0.8s" }
};
const _hoisted_46$b = { class: "grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_47$b = {
  key: 0,
  class: "flex items-center space-x-2"
};
const _hoisted_48$b = {
  key: 1,
  class: "flex items-center space-x-2"
};
const _hoisted_49$a = { class: "flex items-center justify-end space-x-3 p-6 border-t border-gray-200 dark:border-gray-600 bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] rounded-b-lg" };
const _sfc_main$10 = /* @__PURE__ */ defineComponent({
  __name: "VocabularyDetailDialog",
  props: {
    modelValue: { type: Boolean },
    vocabulary: {}
  },
  emits: ["update:modelValue", "edit-vocabulary", "toggle-favorite"],
  setup(__props, { emit: __emit }) {
    const { t, locale } = useI18n();
    const modalStore = useModalStore();
    const props = __props;
    const emit = __emit;
    const { playAudio: playVoiceAudio } = useVoiceStore();
    const playAudio = (text) => {
      playVoiceAudio(text);
    };
    watch(() => props.modelValue, (newValue) => {
      modalStore.showVocabularyDetail = newValue;
    });
    const closeDialog = () => {
      window.dispatchEvent(new CustomEvent("vocabulary-modal-closed"));
      emit("update:modelValue", false);
    };
    const editVocabulary = () => {
      if (props.vocabulary) {
        emit("edit-vocabulary", props.vocabulary);
        closeDialog();
      }
    };
    const toggleFavorite = () => {
      if (props.vocabulary) {
        emit("toggle-favorite", props.vocabulary);
      }
    };
    const handleImageError = (event) => {
      const img = event.target;
      console.warn(`Failed to load image for vocabulary: ${props.vocabulary?.word}`, img.src);
      const imageSection = img.closest(".mb-6");
      if (imageSection) {
        imageSection.style.display = "none";
      }
    };
    const getLevelColor = (level) => {
      switch (level) {
        case "beginner":
          return "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200";
        case "intermediate":
          return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200";
        case "advanced":
          return "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200";
        default:
          return "bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200";
      }
    };
    const handleKeydown = (event) => {
      if (event.key === "Escape") {
        closeDialog();
      }
    };
    watch(() => props.modelValue, (newValue) => {
      if (newValue) {
        window.dispatchEvent(new CustomEvent("vocabulary-view-details"));
        document.body.style.overflow = "hidden";
        document.addEventListener("keydown", handleKeydown);
      } else {
        document.body.style.overflow = "";
        document.removeEventListener("keydown", handleKeydown);
      }
    }, { immediate: true });
    onUnmounted(() => {
      document.body.style.overflow = "";
      document.removeEventListener("keydown", handleKeydown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.modelValue ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 backdrop-blur-sm",
              onKeyup: withKeys(closeDialog, ["esc"])
            }, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: "bg-white dark:bg-[#0a0a0a] rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[90vh] border border-gray-200 dark:border-gray-700 transform overflow-hidden flex flex-col",
                    onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("div", _hoisted_1$10, [
                      createBaseVNode("h3", _hoisted_2$Z, [
                        _cache[3] || (_cache[3] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                        createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.details.title", "Vocabulary Details")), 1)
                      ]),
                      createBaseVNode("button", {
                        onClick: closeDialog,
                        class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                      }, _cache[4] || (_cache[4] = [
                        createBaseVNode("svg", {
                          class: "w-6 h-6",
                          fill: "none",
                          stroke: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          createBaseVNode("path", {
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            "stroke-width": "2",
                            d: "M6 18L18 6M6 6l12 12"
                          })
                        ], -1)
                      ]))
                    ]),
                    _ctx.vocabulary ? (openBlock(), createElementBlock("div", _hoisted_3$X, [
                      createBaseVNode("div", _hoisted_4$V, [
                        createBaseVNode("div", _hoisted_5$S, [
                          createBaseVNode("h1", _hoisted_6$Q, toDisplayString$1(_ctx.vocabulary.word), 1),
                          createBaseVNode("button", {
                            onClick: _cache[0] || (_cache[0] = ($event) => playAudio(_ctx.vocabulary.word)),
                            class: "flex items-center justify-center w-10 h-10 bg-blue-500 hover:bg-blue-600 text-white rounded-full transition-all duration-300 hover:scale-110 hover:shadow-lg transform hover:-translate-y-0.5",
                            title: unref(t)("vocabulary.details.playAudio", "Play Audio")
                          }, _cache[5] || (_cache[5] = [
                            createBaseVNode("svg", {
                              class: "w-5 h-5",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", {
                                "fill-rule": "evenodd",
                                d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.816L4.846 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.846l3.537-3.816a1 1 0 011.617.816zM16 8a2 2 0 11-4 0 2 2 0 014 0zM14 8a2 2 0 012-2v4a2 2 0 01-2-2z",
                                "clip-rule": "evenodd"
                              })
                            ], -1)
                          ]), 8, _hoisted_7$O),
                          createBaseVNode("button", {
                            onClick: toggleFavorite,
                            class: normalizeClass(["flex items-center justify-center w-10 h-10 rounded-full transition-all duration-300 hover:scale-110 transform hover:-translate-y-0.5", _ctx.vocabulary.favorite ? "text-yellow-500 hover:text-yellow-600" : "text-gray-400 hover:text-yellow-500"]),
                            title: _ctx.vocabulary.favorite ? unref(t)("vocabulary.details.removeFavorite", "Remove from favorites") : unref(t)("vocabulary.details.addFavorite", "Add to favorites")
                          }, [
                            (openBlock(), createElementBlock("svg", _hoisted_9$N, [
                              _ctx.vocabulary.favorite ? (openBlock(), createElementBlock("path", _hoisted_10$M)) : (openBlock(), createElementBlock("path", _hoisted_11$M))
                            ]))
                          ], 10, _hoisted_8$O)
                        ]),
                        createBaseVNode("p", _hoisted_12$L, toDisplayString$1(_ctx.vocabulary.pronunciation), 1),
                        createBaseVNode("div", _hoisted_13$L, [
                          createBaseVNode("span", {
                            class: normalizeClass([getLevelColor(_ctx.vocabulary.level), "px-3 py-1 text-sm font-medium rounded-full transition-all duration-300 hover:scale-105"])
                          }, toDisplayString$1(unref(t)(`vocabulary.levels.${_ctx.vocabulary.level}`, _ctx.vocabulary.level)), 3),
                          createBaseVNode("span", _hoisted_14$L, toDisplayString$1(unref(getTopicName)(_ctx.vocabulary.category)), 1),
                          createBaseVNode("span", _hoisted_15$G, toDisplayString$1(unref(t)(`vocabulary.wordTypes.${_ctx.vocabulary.partOfSpeech}`, _ctx.vocabulary.partOfSpeech)), 1)
                        ])
                      ]),
                      _ctx.vocabulary.image ? (openBlock(), createElementBlock("div", _hoisted_16$F, [
                        createBaseVNode("h3", _hoisted_17$E, [
                          _cache[6] || (_cache[6] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.image.title", "Image")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_18$C, [
                          createBaseVNode("div", _hoisted_19$C, [
                            createBaseVNode("div", _hoisted_20$B, [
                              createBaseVNode("img", {
                                src: _ctx.vocabulary.image,
                                alt: `${unref(t)("vocabulary.image.preview")} - ${_ctx.vocabulary.word}`,
                                class: "w-full h-auto max-h-80 object-cover transition-all duration-300 hover:scale-105",
                                onError: handleImageError
                              }, null, 40, _hoisted_21$B),
                              createBaseVNode("div", _hoisted_22$z, [
                                createBaseVNode("div", _hoisted_23$z, [
                                  createBaseVNode("span", _hoisted_24$y, toDisplayString$1(_ctx.vocabulary.word), 1)
                                ])
                              ])
                            ])
                          ])
                        ])
                      ])) : createCommentVNode("", true),
                      createBaseVNode("div", _hoisted_25$y, [
                        createBaseVNode("h3", _hoisted_26$w, [
                          _cache[7] || (_cache[7] = createBaseVNode("span", { class: "w-1 h-4 bg-indigo-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.meaning", "Meaning")), 1)
                        ]),
                        createBaseVNode("p", _hoisted_27$v, toDisplayString$1(_ctx.vocabulary.meaning), 1)
                      ]),
                      _ctx.vocabulary.example ? (openBlock(), createElementBlock("div", _hoisted_28$u, [
                        createBaseVNode("h3", _hoisted_29$s, [
                          _cache[8] || (_cache[8] = createBaseVNode("span", { class: "w-1 h-4 bg-teal-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.example", "Example")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_30$r, [
                          createBaseVNode("div", _hoisted_31$q, [
                            createBaseVNode("div", _hoisted_32$n, [
                              createBaseVNode("p", _hoisted_33$n, ' "' + toDisplayString$1(_ctx.vocabulary.example) + '" ', 1)
                            ]),
                            createBaseVNode("button", {
                              onClick: _cache[1] || (_cache[1] = ($event) => playAudio(_ctx.vocabulary.example)),
                              class: "flex items-center justify-center w-8 h-8 bg-green-500 hover:bg-green-600 text-white rounded-full transition-all duration-300 hover:scale-110 transform hover:-translate-y-0.5 flex-shrink-0",
                              title: unref(t)("vocabulary.details.playExample")
                            }, _cache[9] || (_cache[9] = [
                              createBaseVNode("svg", {
                                class: "w-4 h-4",
                                fill: "currentColor",
                                viewBox: "0 0 20 20"
                              }, [
                                createBaseVNode("path", {
                                  "fill-rule": "evenodd",
                                  d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.816L4.846 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.846l3.537-3.816a1 1 0 011.617.816zM16 8a2 2 0 11-4 0 2 2 0 014 0zM14 8a2 2 0 012-2v4a2 2 0 01-2-2z",
                                  "clip-rule": "evenodd"
                                })
                              ], -1)
                            ]), 8, _hoisted_34$k)
                          ])
                        ])
                      ])) : createCommentVNode("", true),
                      _ctx.vocabulary.synonyms && _ctx.vocabulary.synonyms.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_35$k, [
                        createBaseVNode("h3", _hoisted_36$j, [
                          _cache[10] || (_cache[10] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.synonyms", "Synonyms")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_37$i, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.vocabulary.synonyms, (synonym) => {
                            return openBlock(), createElementBlock("span", {
                              key: synonym,
                              class: "px-3 py-1 bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300 rounded-full text-sm transition-all duration-300 hover:scale-105 hover:shadow-md"
                            }, toDisplayString$1(synonym), 1);
                          }), 128))
                        ])
                      ])) : createCommentVNode("", true),
                      _ctx.vocabulary.antonyms && _ctx.vocabulary.antonyms.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_38$i, [
                        createBaseVNode("h3", _hoisted_39$g, [
                          _cache[11] || (_cache[11] = createBaseVNode("span", { class: "w-1 h-4 bg-red-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.antonyms", "Antonyms")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_40$g, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.vocabulary.antonyms, (antonym) => {
                            return openBlock(), createElementBlock("span", {
                              key: antonym,
                              class: "px-3 py-1 bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-300 rounded-full text-sm transition-all duration-300 hover:scale-105 hover:shadow-md"
                            }, toDisplayString$1(antonym), 1);
                          }), 128))
                        ])
                      ])) : createCommentVNode("", true),
                      _ctx.vocabulary.notes ? (openBlock(), createElementBlock("div", _hoisted_41$f, [
                        createBaseVNode("h3", _hoisted_42$d, [
                          _cache[12] || (_cache[12] = createBaseVNode("span", { class: "w-1 h-4 bg-yellow-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.note", "Notes")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_43$c, [
                          createBaseVNode("p", _hoisted_44$c, toDisplayString$1(_ctx.vocabulary.notes), 1)
                        ])
                      ])) : createCommentVNode("", true),
                      createBaseVNode("div", _hoisted_45$b, [
                        createBaseVNode("div", _hoisted_46$b, [
                          _ctx.vocabulary.createdAt ? (openBlock(), createElementBlock("div", _hoisted_47$b, [
                            _cache[13] || (_cache[13] = createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", {
                                "fill-rule": "evenodd",
                                d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z",
                                "clip-rule": "evenodd"
                              })
                            ], -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.createdAt", "Created")) + ": " + toDisplayString$1(unref(getRelativeTime)(_ctx.vocabulary.createdAt, unref(t))), 1)
                          ])) : createCommentVNode("", true),
                          _ctx.vocabulary.updatedAt && _ctx.vocabulary.updatedAt !== _ctx.vocabulary.createdAt ? (openBlock(), createElementBlock("div", _hoisted_48$b, [
                            _cache[14] || (_cache[14] = createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", { d: "M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" })
                            ], -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.updatedAt", "Updated")) + ": " + toDisplayString$1(unref(getRelativeTime)(_ctx.vocabulary.updatedAt, unref(t))), 1)
                          ])) : createCommentVNode("", true)
                        ])
                      ])
                    ])) : createCommentVNode("", true),
                    createBaseVNode("div", _hoisted_49$a, [
                      createBaseVNode("button", {
                        onClick: editVocabulary,
                        class: "px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg transform hover:-translate-y-0.5 active:scale-95"
                      }, toDisplayString$1(unref(t)("common.edit", "Edit")), 1),
                      createBaseVNode("button", {
                        onClick: closeDialog,
                        class: "px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg transform hover:-translate-y-0.5 active:scale-95"
                      }, toDisplayString$1(unref(t)("common.close", "Close")), 1)
                    ])
                  ])
                ]),
                _: 1
              })
            ], 32)) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const VocabularyDetailDialog = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["__scopeId", "data-v-c3ed5305"]]);

const VocabularyDetailDialog$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: VocabularyDetailDialog
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$$ = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$Y = { class: "w-full max-h-[90vh] flex flex-col max-w-[95vw] sm:max-w-lg md:max-w-xl lg:max-w-2xl" };
const _hoisted_3$W = { class: "px-3 sm:px-6 py-3 sm:py-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-green-50 to-emerald-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$U = { class: "flex items-center justify-between" };
const _hoisted_5$R = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-1 sm:space-x-2 flex-1 min-w-0" };
const _hoisted_6$P = { class: "truncate" };
const _hoisted_7$N = { class: "px-3 sm:px-6 py-3 sm:py-4 flex-1 overflow-y-auto min-h-0 custom-scrollbar" };
const _hoisted_8$N = { class: "space-y-6" };
const _hoisted_9$M = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_10$L = { class: "text-sm text-gray-600 dark:text-gray-400 p-3 bg-green-50 dark:bg-[#0a0a0a] rounded-lg border border-green-200 dark:border-gray-700" };
const _hoisted_11$L = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_12$K = {
  for: "note-content",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_13$K = ["placeholder"];
const _hoisted_14$K = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_15$F = { class: "text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_16$E = { class: "ml-2 px-2 py-1 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 rounded-full text-xs font-semibold" };
const _hoisted_17$D = { class: "max-h-60 overflow-y-auto border border-gray-200 dark:border-gray-700 rounded-lg p-3 bg-white dark:bg-[#0a0a0a] custom-scrollbar" };
const _hoisted_18$B = {
  key: 0,
  class: "p-4 text-center text-gray-500 dark:text-gray-400"
};
const _hoisted_19$B = {
  key: 1,
  class: "space-y-2"
};
const _hoisted_20$A = { class: "flex-1 min-w-0" };
const _hoisted_21$A = { class: "flex items-center space-x-1 sm:space-x-2 mb-1" };
const _hoisted_22$y = { class: "font-medium text-gray-900 dark:text-white truncate" };
const _hoisted_23$y = { class: "text-xs sm:text-sm text-gray-500 dark:text-gray-400 font-mono truncate" };
const _hoisted_24$x = { class: "text-sm text-gray-600 dark:text-gray-300 truncate" };
const _hoisted_25$x = { class: "text-xs px-1 sm:px-2 py-1 bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-300 rounded-full whitespace-nowrap" };
const _hoisted_26$v = { class: "flex items-center space-x-1 sm:space-x-2 flex-shrink-0" };
const _hoisted_27$u = ["onClick", "title"];
const _hoisted_28$t = ["onClick"];
const _hoisted_29$r = {
  class: "w-4 h-4",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_30$q = {
  key: 0,
  "fill-rule": "evenodd",
  d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
  "clip-rule": "evenodd"
};
const _hoisted_31$p = {
  key: 1,
  d: "M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"
};
const _hoisted_32$m = { class: "px-6 py-4 border-t border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-gray-50 to-green-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_33$m = { class: "flex justify-end space-x-3" };
const NOTE_STORAGE_KEY = "vocabulary-notes";
const MARKED_WORDS_STORAGE_KEY = "vocabulary-marked-words";
const _sfc_main$$ = /* @__PURE__ */ defineComponent({
  __name: "VocabularyNoteDialog",
  props: {
    modelValue: { type: Boolean },
    date: {},
    todayWords: {}
  },
  emits: ["update:modelValue", "save-note"],
  setup(__props, { emit: __emit }) {
    const { t, locale } = useI18n();
    useToast();
    const { playAudio } = useVoiceStore();
    const props = __props;
    const emit = __emit;
    const noteContent = ref("");
    const markedWords = ref([]);
    const formattedDate = computed(() => {
      const today = /* @__PURE__ */ new Date();
      const todayKey = getDateKey(today.toISOString());
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayKey = getDateKey(yesterday.toISOString());
      if (props.date === todayKey) {
        return t("vocabulary.notes.today", "Today");
      } else if (props.date === yesterdayKey) {
        return t("vocabulary.notes.yesterday", "Yesterday");
      } else {
        return formatDate(props.date, locale.value);
      }
    });
    const loadNote = () => {
      try {
        const notesData = localStorage.getItem(NOTE_STORAGE_KEY);
        if (notesData) {
          const notes = JSON.parse(notesData);
          if (notes[props.date]) {
            noteContent.value = notes[props.date];
          } else {
            noteContent.value = "";
          }
        }
      } catch (error) {
        console.warn("Failed to load notes from localStorage:", error);
      }
    };
    const loadMarkedWords = () => {
      try {
        const markedData = localStorage.getItem(MARKED_WORDS_STORAGE_KEY);
        if (markedData) {
          const marked = JSON.parse(markedData);
          if (marked[props.date]) {
            markedWords.value = marked[props.date];
          } else {
            markedWords.value = [];
          }
        }
      } catch (error) {
        console.warn("Failed to load marked words from localStorage:", error);
      }
    };
    const saveNoteToStorage = (note) => {
      try {
        const notesData = localStorage.getItem(NOTE_STORAGE_KEY);
        const notes = notesData ? JSON.parse(notesData) : {};
        notes[props.date] = note;
        localStorage.setItem(NOTE_STORAGE_KEY, JSON.stringify(notes));
      } catch (error) {
        console.warn("Failed to save note to localStorage:", error);
      }
    };
    const saveMarkedWordsToStorage = (wordIds) => {
      try {
        const markedData = localStorage.getItem(MARKED_WORDS_STORAGE_KEY);
        const marked = markedData ? JSON.parse(markedData) : {};
        marked[props.date] = wordIds;
        localStorage.setItem(MARKED_WORDS_STORAGE_KEY, JSON.stringify(marked));
      } catch (error) {
        console.warn("Failed to save marked words to localStorage:", error);
      }
    };
    const toggleWordMarked = (wordId) => {
      const index = markedWords.value.indexOf(wordId);
      if (index === -1) {
        markedWords.value.push(wordId);
      } else {
        markedWords.value.splice(index, 1);
      }
    };
    const speakWord = async (word) => {
      try {
        await playAudio(word);
      } catch (error) {
        console.warn("Failed to play word pronunciation:", error);
      }
    };
    const saveNote = () => {
      saveNoteToStorage(noteContent.value);
      saveMarkedWordsToStorage(markedWords.value);
      emit("save-note", noteContent.value, markedWords.value);
      const event = new CustomEvent("vocabulary-notes-updated", {
        detail: {
          date: props.date,
          note: noteContent.value,
          markedWords: markedWords.value
        }
      });
      window.dispatchEvent(event);
      close();
    };
    const close = () => {
      emit("update:modelValue", false);
    };
    watch(
      () => props.modelValue,
      (newValue) => {
        if (newValue) {
          loadNote();
          loadMarkedWords();
        }
      }
    );
    onMounted(() => {
      if (props.modelValue) {
        loadNote();
        loadMarkedWords();
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$$, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$Y, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 flex flex-col h-full overflow-hidden transform",
                      onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$W, [
                        createBaseVNode("div", _hoisted_4$U, [
                          createBaseVNode("h2", _hoisted_5$R, [
                            _cache[2] || (_cache[2] = createBaseVNode("span", { class: "w-2 h-2 bg-green-500 rounded-full animate-pulse flex-shrink-0" }, null, -1)),
                            _cache[3] || (_cache[3] = createBaseVNode("svg", {
                              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6 text-green-500 flex-shrink-0",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
                            ], -1)),
                            createBaseVNode("span", _hoisted_6$P, toDisplayString$1(unref(t)("vocabulary.notes.title", "Vocabulary Notes")) + " - " + toDisplayString$1(formattedDate.value), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: close,
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[4] || (_cache[4] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_7$N, [
                        createBaseVNode("div", _hoisted_8$N, [
                          createBaseVNode("div", _hoisted_9$M, [
                            createBaseVNode("p", _hoisted_10$L, toDisplayString$1(unref(t)("vocabulary.notes.description", "Manage notes for vocabulary words learned today")), 1)
                          ]),
                          createBaseVNode("div", _hoisted_11$L, [
                            createBaseVNode("label", _hoisted_12$K, [
                              _cache[5] || (_cache[5] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.notes.noteLabel", "Notes for vocabulary")), 1)
                            ]),
                            withDirectives(createBaseVNode("textarea", {
                              id: "note-content",
                              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => noteContent.value = $event),
                              rows: "6",
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-300 hover:border-green-400 dark:hover:border-green-500 transform hover:scale-[1.02]",
                              placeholder: unref(t)("vocabulary.notes.placeholder", "Write your notes about this vocabulary learning session...")
                            }, null, 8, _hoisted_13$K), [
                              [vModelText, noteContent.value]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_14$K, [
                            createBaseVNode("h4", _hoisted_15$F, [
                              _cache[6] || (_cache[6] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.notes.wordsLearned", "Words in this group")) + " ", 1),
                              createBaseVNode("span", _hoisted_16$E, toDisplayString$1(_ctx.todayWords.length), 1)
                            ]),
                            createBaseVNode("div", _hoisted_17$D, [
                              _ctx.todayWords.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_18$B, [
                                _cache[7] || (_cache[7] = createBaseVNode("svg", {
                                  class: "w-12 h-12 mx-auto mb-3 text-gray-300 dark:text-gray-600",
                                  fill: "none",
                                  stroke: "currentColor",
                                  viewBox: "0 0 24 24"
                                }, [
                                  createBaseVNode("path", {
                                    "stroke-linecap": "round",
                                    "stroke-linejoin": "round",
                                    "stroke-width": "1",
                                    d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                                  })
                                ], -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.notes.noWordsLearned", "No vocabulary words in this group")), 1)
                              ])) : (openBlock(), createElementBlock("div", _hoisted_19$B, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.todayWords, (word, index) => {
                                  return openBlock(), createElementBlock("div", {
                                    key: word.id,
                                    class: "flex items-center space-x-2 sm:space-x-3 p-2 sm:p-3 rounded-lg hover:bg-white dark:hover:bg-[#0f0f0f] transition-all duration-300 border border-transparent hover:border-green-200 cursor-pointer hover:shadow-md hover:scale-[1.02] animate-fade-in-up",
                                    style: normalizeStyle(`animation-delay: ${0.4 + index * 0.1}s`)
                                  }, [
                                    createBaseVNode("div", _hoisted_20$A, [
                                      createBaseVNode("div", _hoisted_21$A, [
                                        createBaseVNode("span", _hoisted_22$y, toDisplayString$1(word.word), 1),
                                        createBaseVNode("span", _hoisted_23$y, toDisplayString$1(word.pronunciation), 1)
                                      ]),
                                      createBaseVNode("div", _hoisted_24$x, toDisplayString$1(word.meaning), 1)
                                    ]),
                                    createBaseVNode("div", _hoisted_25$x, toDisplayString$1(word.level), 1),
                                    createBaseVNode("div", _hoisted_26$v, [
                                      createBaseVNode("button", {
                                        onClick: ($event) => speakWord(word.word),
                                        class: "p-1 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-300 hover:scale-110 bg-blue-100 dark:bg-blue-900 text-blue-600 dark:text-blue-400 hover:bg-blue-200 dark:hover:bg-blue-800",
                                        title: `Play pronunciation: ${word.word}`
                                      }, _cache[8] || (_cache[8] = [
                                        createBaseVNode("svg", {
                                          class: "w-4 h-4",
                                          fill: "currentColor",
                                          viewBox: "0 0 20 20"
                                        }, [
                                          createBaseVNode("path", {
                                            "fill-rule": "evenodd",
                                            d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.776L4.146 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.146l4.237-3.776zM12.828 7.172a1 1 0 011.414 0 4 4 0 010 5.656 1 1 0 01-1.414-1.414 2 2 0 000-2.828 1 1 0 010-1.414z",
                                            "clip-rule": "evenodd"
                                          }),
                                          createBaseVNode("path", {
                                            "fill-rule": "evenodd",
                                            d: "M15.536 4.464a1 1 0 011.414 0 8 8 0 010 11.314 1 1 0 11-1.414-1.414 6 6 0 000-8.486 1 1 0 010-1.414z",
                                            "clip-rule": "evenodd"
                                          })
                                        ], -1)
                                      ]), 8, _hoisted_27$u),
                                      createBaseVNode("button", {
                                        onClick: ($event) => toggleWordMarked(word.id),
                                        class: normalizeClass(["p-1 rounded-full focus:outline-none focus:ring-2 focus:ring-green-500 transition-all duration-300 hover:scale-110", markedWords.value.includes(word.id) ? "bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-400" : "bg-gray-100 dark:bg-gray-600 text-gray-500 dark:text-gray-400"])
                                      }, [
                                        (openBlock(), createElementBlock("svg", _hoisted_29$r, [
                                          markedWords.value.includes(word.id) ? (openBlock(), createElementBlock("path", _hoisted_30$q)) : (openBlock(), createElementBlock("path", _hoisted_31$p))
                                        ]))
                                      ], 10, _hoisted_28$t)
                                    ])
                                  ], 4);
                                }), 128))
                              ]))
                            ])
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_32$m, [
                        createBaseVNode("div", _hoisted_33$m, [
                          createBaseVNode("button", {
                            onClick: close,
                            class: "px-4 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg text-sm font-medium text-gray-700 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-all duration-300 hover:scale-105 hover:shadow-md transform hover:-translate-y-0.5"
                          }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                          createBaseVNode("button", {
                            onClick: saveNote,
                            class: "px-4 py-2 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-all duration-300 hover:scale-105 hover:shadow-lg transform hover:-translate-y-0.5 flex items-center space-x-2"
                          }, [
                            _cache[9] || (_cache[9] = createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M5 13l4 4L19 7"
                              })
                            ], -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("common.save", "Save")), 1)
                          ])
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const VocabularyNoteDialog = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["__scopeId", "data-v-6c613da1"]]);

const VocabularyNoteDialog$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: VocabularyNoteDialog
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$_ = {
  key: 0,
  class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$X = { class: "w-full max-w-4xl" };
const _hoisted_3$V = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$T = { class: "flex items-center justify-between" };
const _hoisted_5$Q = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$O = { class: "flex items-center space-x-4" };
const _hoisted_7$M = { class: "flex items-center space-x-3" };
const _hoisted_8$M = { class: "text-sm font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_9$L = { class: "relative inline-flex items-center cursor-pointer" };
const _hoisted_10$K = { class: "text-sm font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_11$K = {
  key: 0,
  class: "mt-3 p-2 bg-blue-50 dark:bg-gray-custom rounded-lg"
};
const _hoisted_12$J = { class: "flex items-center justify-between" };
const _hoisted_13$J = { class: "text-sm text-blue-700 dark:text-blue-300 flex items-center" };
const _hoisted_14$J = {
  key: 0,
  class: "relative"
};
const _hoisted_15$E = { class: "bg-green-200 dark:bg-green-800 text-green-800 dark:text-green-200 px-2 py-0.5 rounded-full text-xs font-bold" };
const _hoisted_16$D = {
  key: 0,
  class: "absolute right-0 top-full mt-2 w-80 bg-white dark:bg-[#0a0a0a] border border-gray-200 dark:border-gray-700 rounded-lg shadow-xl z-50 max-h-64 overflow-y-auto"
};
const _hoisted_17$C = { class: "p-3 border-b border-gray-200 dark:border-gray-700" };
const _hoisted_18$A = { class: "text-sm font-semibold text-gray-900 dark:text-white flex items-center" };
const _hoisted_19$A = {
  key: 0,
  class: "p-4 text-center text-gray-500 dark:text-gray-400 text-sm"
};
const _hoisted_20$z = {
  key: 1,
  class: "divide-y divide-gray-200 dark:divide-gray-700"
};
const _hoisted_21$z = { class: "flex items-start justify-between" };
const _hoisted_22$x = { class: "flex-1 min-w-0" };
const _hoisted_23$x = { class: "text-sm font-medium text-gray-900 dark:text-white truncate" };
const _hoisted_24$w = { class: "text-xs text-gray-600 dark:text-gray-300 mt-1 line-clamp-2" };
const _hoisted_25$w = { class: "flex items-center space-x-2 mt-2" };
const _hoisted_26$u = { class: "inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200" };
const _hoisted_27$t = { class: "inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-purple-100 dark:bg-purple-900/30 text-purple-800 dark:text-purple-200" };
const _hoisted_28$s = { class: "px-6 py-4 max-h-[70vh] overflow-y-auto" };
const _hoisted_29$q = {
  class: "mb-6 p-4 bg-gray-50 dark:bg-dark-bg-mute rounded-lg border border-gray-200 dark:border-dark-bg-mute animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_30$p = { class: "text-md font-medium text-gray-900 dark:text-white mb-4 flex items-center" };
const _hoisted_31$o = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_32$l = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_33$l = ["placeholder"];
const _hoisted_34$j = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_35$j = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_36$i = { value: "" };
const _hoisted_37$h = { value: "tenses" };
const _hoisted_38$h = { value: "conditionals" };
const _hoisted_39$f = { value: "passive" };
const _hoisted_40$f = { value: "modals" };
const _hoisted_41$e = { value: "articles" };
const _hoisted_42$c = { value: "prepositions" };
const _hoisted_43$b = { value: "conjunctions" };
const _hoisted_44$b = { value: "other" };
const _hoisted_45$a = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_46$a = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_47$a = { value: "" };
const _hoisted_48$a = { value: "beginner" };
const _hoisted_49$9 = { value: "intermediate" };
const _hoisted_50$9 = { value: "advanced" };
const _hoisted_51$8 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_52$8 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_53$8 = { class: "space-y-2" };
const _hoisted_54$8 = ["placeholder"];
const _hoisted_55$8 = {
  key: 0,
  class: "p-2 bg-yellow-50 dark:bg-[#0a0a0a] border border-yellow-200 dark:border-yellow-600 rounded text-sm"
};
const _hoisted_56$8 = { class: "text-yellow-700 dark:text-yellow-400 font-medium mb-1" };
const _hoisted_57$8 = ["innerHTML"];
const _hoisted_58$8 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_59$7 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_60$7 = { class: "space-y-2" };
const _hoisted_61$6 = ["placeholder"];
const _hoisted_62$6 = {
  key: 0,
  class: "p-2 bg-teal-50 dark:bg-[#0a0a0a] border border-teal-200 dark:border-teal-600 rounded text-sm"
};
const _hoisted_63$4 = { class: "text-teal-700 dark:text-teal-400 font-medium mb-1" };
const _hoisted_64$4 = ["innerHTML"];
const _hoisted_65$4 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_66$4 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_67$4 = { class: "space-y-2" };
const _hoisted_68$4 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_69$4 = ["onClick"];
const _hoisted_70$4 = {
  class: "flex justify-end space-x-3 pt-4 animate-fade-in-up",
  style: { "animation-delay": "0.8s" }
};
const _hoisted_71$4 = {
  type: "submit",
  class: "px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-all duration-300 transform hover:scale-105 hover:shadow-lg"
};
const _hoisted_72$4 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.9s" }
};
const _hoisted_73$4 = { class: "flex items-center justify-between mb-4" };
const _hoisted_74$4 = { class: "text-md font-medium text-gray-900 dark:text-white flex items-center" };
const _hoisted_75$3 = { value: "" };
const _hoisted_76$3 = { value: "tenses" };
const _hoisted_77$3 = { value: "conditionals" };
const _hoisted_78$2 = { value: "passive" };
const _hoisted_79$2 = { value: "modals" };
const _hoisted_80$2 = { value: "articles" };
const _hoisted_81$2 = { value: "prepositions" };
const _hoisted_82$2 = { value: "conjunctions" };
const _hoisted_83$2 = { value: "other" };
const _hoisted_84$2 = {
  key: 0,
  class: "space-y-4 max-h-96 overflow-y-auto scrollbar-custom"
};
const _hoisted_85$2 = { class: "flex items-start justify-between" };
const _hoisted_86$1 = { class: "flex-1" };
const _hoisted_87$1 = { class: "flex items-center space-x-2 mb-2" };
const _hoisted_88$1 = { class: "font-medium text-gray-900 dark:text-white" };
const _hoisted_89$1 = { class: "px-2 py-1 text-xs bg-blue-100 dark:bg-blue-900/50 text-blue-800 dark:text-blue-300 rounded-full" };
const _hoisted_90$1 = { class: "px-2 py-1 text-xs bg-green-100 dark:bg-green-900/50 text-green-800 dark:text-green-300 rounded-full" };
const _hoisted_91$1 = { class: "mb-2" };
const _hoisted_92$1 = { class: "text-sm font-medium text-gray-700 dark:text-gray-300 mb-1" };
const _hoisted_93$1 = ["innerHTML"];
const _hoisted_94$1 = {
  key: 0,
  class: "mb-2"
};
const _hoisted_95$1 = ["innerHTML"];
const _hoisted_96$1 = {
  key: 1,
  class: "mb-2"
};
const _hoisted_97$1 = { class: "text-sm font-medium text-gray-700 dark:text-gray-300 mb-1" };
const _hoisted_98$1 = { class: "text-sm text-gray-600 dark:text-gray-400 space-y-2" };
const _hoisted_99$1 = { class: "flex items-start flex-1" };
const _hoisted_100 = { class: "flex-1" };
const _hoisted_101 = ["onClick", "disabled", "title"];
const _hoisted_102 = {
  key: 0,
  class: "w-4 h-4",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_103 = {
  key: 1,
  class: "w-4 h-4",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_104 = { class: "text-xs text-gray-500 dark:text-gray-400" };
const _hoisted_105 = { class: "flex items-center space-x-2 ml-4" };
const _hoisted_106 = ["onClick", "title"];
const _hoisted_107 = ["onClick", "title"];
const _hoisted_108 = {
  key: 1,
  class: "text-center py-8 animate-fade-in-up",
  style: { "animation-delay": "1.0s" }
};
const _hoisted_109 = { class: "text-gray-500 dark:text-gray-400" };
const _hoisted_110 = { class: "px-6 py-4 border-t border-gray-200 dark:border-gray-700 bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_111 = { class: "flex justify-end" };
const _sfc_main$_ = /* @__PURE__ */ defineComponent({
  __name: "GrammarManagerModal",
  props: {
    modelValue: { type: Boolean },
    selectedDate: { default: null }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const ConfirmToast$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ConfirmToast),true              ?void 0:void 0));
    const { t } = useI18n();
    const toast = useToast();
    const { allVocabularies } = useVocabularyStore();
    const isPlayingAudio = ref(null);
    const props = __props;
    const emit = __emit;
    const grammarRules = ref([]);
    const isEditing = ref(false);
    const editingId = ref(null);
    const filterCategory = ref("");
    const perDateMode = ref(false);
    const showVocabularyDropdown = ref(false);
    const formData = ref({
      title: "",
      category: "",
      level: "",
      formula: "",
      description: "",
      examples: [""]
    });
    const filteredGrammarRules = computed(() => {
      let filtered = grammarRules.value;
      if (perDateMode.value) {
        filtered = filtered.filter((rule) => rule.dateGroup === props.selectedDate);
      } else {
        filtered = filtered.filter((rule) => !rule.dateGroup);
      }
      if (filterCategory.value) {
        filtered = filtered.filter((rule) => rule.category === filterCategory.value);
      }
      return filtered;
    });
    const vocabulariesForSelectedDate = computed(() => {
      if (!props.selectedDate) return [];
      return allVocabularies.value.filter((vocab) => {
        const vocabDateKey = getDateKey(vocab.createdAt);
        return vocabDateKey === props.selectedDate;
      });
    });
    const renderHtmlContent = (content) => {
      if (!content) return "";
      return content.replace(/<\/br>/gi, "<br>").replace(/<br\s*\/?>/gi, "<br>").replace(/\n/g, "<br>");
    };
    const formulaPreview = computed(() => renderHtmlContent(formData.value.formula));
    const descriptionPreview = computed(() => renderHtmlContent(formData.value.description));
    const playExampleAudio = async (example) => {
      if (isPlayingAudio.value === example) return;
      try {
        isPlayingAudio.value = example;
        if ("speechSynthesis" in window) {
          return new Promise((resolve, reject) => {
            const utterance = new SpeechSynthesisUtterance(example);
            const savedSettings = localStorage.getItem("voice-settings");
            let voiceSettings = {
              rate: 0.8,
              pitch: 1,
              volume: 1
            };
            if (savedSettings) {
              try {
                const settings = JSON.parse(savedSettings);
                const currentVoiceType2 = localStorage.getItem("current-voice-type") || "female-sweet";
                if (settings[currentVoiceType2]) {
                  voiceSettings = settings[currentVoiceType2];
                }
              } catch (e) {
                console.warn("Failed to parse voice settings");
              }
            }
            utterance.lang = "en-US";
            utterance.rate = Math.max(0.1, Math.min(10, voiceSettings.rate));
            utterance.pitch = Math.max(0, Math.min(2, voiceSettings.pitch));
            utterance.volume = Math.max(0, Math.min(1, voiceSettings.volume));
            const voices = speechSynthesis.getVoices();
            const currentVoiceType = localStorage.getItem("current-voice-type") || "female-sweet";
            let targetVoice = null;
            if (currentVoiceType.includes("female")) {
              targetVoice = voices.find(
                (voice) => voice.lang.includes("en") && voice.name.toLowerCase().includes("female")
              ) || voices.find(
                (voice) => voice.lang.includes("en") && !voice.name.toLowerCase().includes("male")
              );
            } else {
              targetVoice = voices.find(
                (voice) => voice.lang.includes("en") && voice.name.toLowerCase().includes("male")
              );
            }
            if (!targetVoice) {
              targetVoice = voices.find((voice) => voice.lang.includes("en"));
            }
            if (targetVoice) {
              utterance.voice = targetVoice;
            }
            utterance.onend = () => resolve(void 0);
            utterance.onerror = (event) => reject(event.error);
            speechSynthesis.speak(utterance);
          });
        } else {
          console.warn("Speech synthesis not supported");
        }
      } catch (error) {
        console.error("Error playing audio:", error);
      } finally {
        isPlayingAudio.value = null;
      }
    };
    const closeModal = () => {
      resetForm();
      emit("update:modelValue", false);
    };
    const resetForm = () => {
      formData.value = {
        title: "",
        category: "",
        level: "",
        formula: "",
        description: "",
        examples: [""]
      };
      isEditing.value = false;
      editingId.value = null;
    };
    const addExample = () => {
      formData.value.examples.push("");
    };
    const removeExample = (index) => {
      if (formData.value.examples.length > 1) {
        formData.value.examples.splice(index, 1);
      }
    };
    const submitForm = () => {
      const now = /* @__PURE__ */ new Date();
      let ruleId = "";
      if (isEditing.value) {
        const index = grammarRules.value.findIndex((rule) => rule.id === editingId.value);
        if (index !== -1) {
          grammarRules.value[index] = {
            ...grammarRules.value[index],
            title: formData.value.title,
            category: formData.value.category,
            level: formData.value.level,
            formula: formData.value.formula,
            description: formData.value.description,
            examples: formData.value.examples.filter((ex) => ex.trim()),
            updatedAt: now
          };
          ruleId = editingId.value || "";
        }
      } else {
        const newRule = {
          id: Date.now().toString(),
          title: formData.value.title,
          category: formData.value.category,
          level: formData.value.level,
          formula: formData.value.formula,
          description: formData.value.description,
          examples: formData.value.examples.filter((ex) => ex.trim()),
          createdAt: now,
          updatedAt: now,
          dateGroup: perDateMode.value ? props.selectedDate || void 0 : void 0
        };
        grammarRules.value.push(newRule);
        ruleId = newRule.id;
      }
      saveToLocalStorage();
      const event = new CustomEvent("grammar-rules-updated", {
        detail: {
          action: isEditing.value ? "updated" : "added",
          ruleId,
          dateGroup: perDateMode.value ? props.selectedDate || void 0 : void 0
        }
      });
      window.dispatchEvent(event);
      resetForm();
    };
    const editGrammar = (rule) => {
      formData.value = {
        title: rule.title,
        category: rule.category,
        level: rule.level,
        formula: rule.formula,
        description: rule.description || "",
        examples: rule.examples.length > 0 ? [...rule.examples] : [""]
      };
      isEditing.value = true;
      editingId.value = rule.id;
    };
    const deleteGrammar = (id) => {
      const rule = grammarRules.value.find((r) => r.id === id);
      if (!rule) return;
      const toastId = toast({
        component: ConfirmToast$1,
        props: {
          message: t("grammar.manager.confirmDelete", "Are you sure you want to delete this grammar rule?"),
          confirmText: t("common.delete", "Delete"),
          cancelText: t("common.cancel", "Cancel"),
          onConfirm: () => {
            grammarRules.value = grammarRules.value.filter((rule2) => rule2.id !== id);
            saveToLocalStorage();
            const event = new CustomEvent("grammar-rules-updated", {
              detail: {
                action: "deleted",
                ruleId: id,
                dateGroup: rule.dateGroup
              }
            });
            window.dispatchEvent(event);
            toast.success(t("grammar.manager.ruleDeleted", "Grammar rule deleted successfully"));
            toast.dismiss(toastId);
          },
          onCancel: () => {
            toast.dismiss(toastId);
          }
        }
      }, {
        timeout: false,
        closeOnClick: false,
        closeButton: false,
        draggable: false
      });
    };
    const formatDate = (date) => {
      return new Date(date).toLocaleDateString();
    };
    const saveToLocalStorage = () => {
      localStorage.setItem("grammar-rules", JSON.stringify(grammarRules.value));
    };
    const saveToggleState = () => {
      localStorage.setItem("grammar-manager-per-date-mode", JSON.stringify(perDateMode.value));
    };
    const loadToggleState = () => {
      const stored = localStorage.getItem("grammar-manager-per-date-mode");
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          perDateMode.value = typeof parsed === "boolean" ? parsed : false;
        } catch (error) {
          console.error("Error loading toggle state:", error);
          perDateMode.value = false;
        }
      }
    };
    const loadFromLocalStorage = () => {
      const stored = localStorage.getItem("grammar-rules");
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          grammarRules.value = parsed.map((rule) => ({
            ...rule,
            createdAt: new Date(rule.createdAt),
            updatedAt: new Date(rule.updatedAt)
          }));
        } catch (error) {
          console.error("Error loading grammar rules:", error);
        }
      }
    };
    const handleVocabularyImport = () => {
      console.log("Vocabulary import detected, refreshing grammar rules");
      loadFromLocalStorage();
    };
    onMounted(() => {
      loadFromLocalStorage();
      loadToggleState();
      window.addEventListener("vocabularyImportComplete", handleVocabularyImport);
    });
    onUnmounted(() => {
      window.removeEventListener("vocabularyImportComplete", handleVocabularyImport);
      unlockBodyScroll();
    });
    const lockBodyScroll = () => {
      document.body.style.overflow = "hidden";
    };
    const unlockBodyScroll = () => {
      document.body.style.overflow = "";
    };
    watch(() => props.modelValue, (newValue) => {
      if (newValue) {
        loadFromLocalStorage();
        lockBodyScroll();
      } else {
        resetForm();
        unlockBodyScroll();
      }
    });
    watch(perDateMode, (newValue) => {
      resetForm();
      filterCategory.value = "";
      saveToggleState();
      if (newValue && !props.selectedDate) {
        console.warn("Per-date mode enabled but no date selected");
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            props.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$_, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$X, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 transform overflow-hidden",
                      onClick: _cache[8] || (_cache[8] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$V, [
                        createBaseVNode("div", _hoisted_4$T, [
                          createBaseVNode("h3", _hoisted_5$Q, [
                            _cache[9] || (_cache[9] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("grammar.manager.title", "Grammar Manager")), 1)
                          ]),
                          createBaseVNode("div", _hoisted_6$O, [
                            createBaseVNode("div", _hoisted_7$M, [
                              createBaseVNode("span", _hoisted_8$M, toDisplayString$1(unref(t)("grammar.manager.globalMode", "Global")), 1),
                              createBaseVNode("label", _hoisted_9$L, [
                                withDirectives(createBaseVNode("input", {
                                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => perDateMode.value = $event),
                                  type: "checkbox",
                                  class: "sr-only peer"
                                }, null, 512), [
                                  [vModelCheckbox, perDateMode.value]
                                ]),
                                _cache[10] || (_cache[10] = createBaseVNode("div", { class: "w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600" }, null, -1))
                              ]),
                              createBaseVNode("span", _hoisted_10$K, toDisplayString$1(unref(t)("grammar.manager.perDateMode", "Per Date")), 1)
                            ]),
                            createBaseVNode("button", {
                              onClick: closeModal,
                              class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                            }, _cache[11] || (_cache[11] = [
                              createBaseVNode("svg", {
                                class: "w-6 h-6",
                                fill: "none",
                                stroke: "currentColor",
                                viewBox: "0 0 24 24"
                              }, [
                                createBaseVNode("path", {
                                  "stroke-linecap": "round",
                                  "stroke-linejoin": "round",
                                  "stroke-width": "2",
                                  d: "M6 18L18 6M6 6l12 12"
                                })
                              ], -1)
                            ]))
                          ])
                        ]),
                        perDateMode.value ? (openBlock(), createElementBlock("div", _hoisted_11$K, [
                          createBaseVNode("div", _hoisted_12$J, [
                            createBaseVNode("p", _hoisted_13$J, [
                              _cache[12] || (_cache[12] = createBaseVNode("svg", {
                                class: "w-4 h-4 mr-2",
                                fill: "none",
                                stroke: "currentColor",
                                viewBox: "0 0 24 24"
                              }, [
                                createBaseVNode("path", {
                                  "stroke-linecap": "round",
                                  "stroke-linejoin": "round",
                                  "stroke-width": "2",
                                  d: "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                                })
                              ], -1)),
                              createTextVNode(" " + toDisplayString$1(_ctx.selectedDate ? unref(t)("grammar.manager.perDateDescription", { date: _ctx.selectedDate }) || `Managing grammar rules for date: ${_ctx.selectedDate}` : unref(t)("grammar.manager.noDateSelected") || "No date selected for per-date mode"), 1)
                            ]),
                            _ctx.selectedDate ? (openBlock(), createElementBlock("div", _hoisted_14$J, [
                              createBaseVNode("button", {
                                onClick: _cache[1] || (_cache[1] = ($event) => showVocabularyDropdown.value = !showVocabularyDropdown.value),
                                class: "flex items-center space-x-2 px-3 py-1.5 bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-200 rounded-md hover:bg-green-200 dark:hover:bg-green-900/50 transition-all duration-200 text-sm font-medium"
                              }, [
                                _cache[14] || (_cache[14] = createBaseVNode("svg", {
                                  class: "w-4 h-4",
                                  fill: "none",
                                  stroke: "currentColor",
                                  viewBox: "0 0 24 24"
                                }, [
                                  createBaseVNode("path", {
                                    "stroke-linecap": "round",
                                    "stroke-linejoin": "round",
                                    "stroke-width": "2",
                                    d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                                  })
                                ], -1)),
                                createBaseVNode("span", null, toDisplayString$1(unref(t)("grammar.manager.showVocabulary", "Show Vocabulary")), 1),
                                createBaseVNode("span", _hoisted_15$E, toDisplayString$1(vocabulariesForSelectedDate.value.length), 1),
                                (openBlock(), createElementBlock("svg", {
                                  class: normalizeClass(["w-4 h-4 transition-transform duration-200", { "rotate-180": showVocabularyDropdown.value }]),
                                  fill: "none",
                                  stroke: "currentColor",
                                  viewBox: "0 0 24 24"
                                }, _cache[13] || (_cache[13] = [
                                  createBaseVNode("path", {
                                    "stroke-linecap": "round",
                                    "stroke-linejoin": "round",
                                    "stroke-width": "2",
                                    d: "M19 9l-7 7-7-7"
                                  }, null, -1)
                                ]), 2))
                              ]),
                              createVNode(Transition, {
                                "enter-active-class": "transition-all duration-300 ease-out",
                                "enter-from-class": "opacity-0 scale-95 translate-y-2",
                                "enter-to-class": "opacity-100 scale-100 translate-y-0",
                                "leave-active-class": "transition-all duration-200 ease-in",
                                "leave-from-class": "opacity-100 scale-100 translate-y-0",
                                "leave-to-class": "opacity-0 scale-95 translate-y-2"
                              }, {
                                default: withCtx(() => [
                                  showVocabularyDropdown.value ? (openBlock(), createElementBlock("div", _hoisted_16$D, [
                                    createBaseVNode("div", _hoisted_17$C, [
                                      createBaseVNode("h4", _hoisted_18$A, [
                                        _cache[15] || (_cache[15] = createBaseVNode("svg", {
                                          class: "w-4 h-4 mr-2 text-green-500",
                                          fill: "none",
                                          stroke: "currentColor",
                                          viewBox: "0 0 24 24"
                                        }, [
                                          createBaseVNode("path", {
                                            "stroke-linecap": "round",
                                            "stroke-linejoin": "round",
                                            "stroke-width": "2",
                                            d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                                          })
                                        ], -1)),
                                        createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.vocabularyForDate", { date: _ctx.selectedDate }) || `Vocabulary for ${_ctx.selectedDate}`), 1)
                                      ])
                                    ]),
                                    vocabulariesForSelectedDate.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_19$A, toDisplayString$1(unref(t)("grammar.manager.noVocabularyFound", "No vocabulary found for this date")), 1)) : (openBlock(), createElementBlock("div", _hoisted_20$z, [
                                      (openBlock(true), createElementBlock(Fragment, null, renderList(vocabulariesForSelectedDate.value, (vocab) => {
                                        return openBlock(), createElementBlock("div", {
                                          key: vocab.id,
                                          class: "p-3 hover:bg-gray-50 dark:hover:bg-gray-custom cursor-pointer transition-colors duration-150"
                                        }, [
                                          createBaseVNode("div", _hoisted_21$z, [
                                            createBaseVNode("div", _hoisted_22$x, [
                                              createBaseVNode("h5", _hoisted_23$x, toDisplayString$1(vocab.word), 1),
                                              createBaseVNode("p", _hoisted_24$w, toDisplayString$1(vocab.meaning), 1),
                                              createBaseVNode("div", _hoisted_25$w, [
                                                createBaseVNode("span", _hoisted_26$u, toDisplayString$1(unref(getTopicName)(vocab.category)), 1),
                                                createBaseVNode("span", _hoisted_27$t, toDisplayString$1(vocab.level), 1)
                                              ])
                                            ])
                                          ])
                                        ]);
                                      }), 128))
                                    ]))
                                  ])) : createCommentVNode("", true)
                                ]),
                                _: 1
                              })
                            ])) : createCommentVNode("", true)
                          ])
                        ])) : createCommentVNode("", true)
                      ]),
                      createBaseVNode("div", _hoisted_28$s, [
                        createBaseVNode("div", _hoisted_29$q, [
                          createBaseVNode("h4", _hoisted_30$p, [
                            _cache[16] || (_cache[16] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                            createTextVNode(" " + toDisplayString$1(isEditing.value ? unref(t)("grammar.manager.editGrammar", "Edit Grammar Rule") : unref(t)("grammar.manager.addNew", "Add New Grammar Rule")), 1)
                          ]),
                          createBaseVNode("form", {
                            onSubmit: withModifiers(submitForm, ["prevent"]),
                            class: "space-y-4"
                          }, [
                            createBaseVNode("div", _hoisted_31$o, [
                              createBaseVNode("label", _hoisted_32$l, [
                                _cache[17] || (_cache[17] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.title", "Title")) + " ", 1),
                                _cache[18] || (_cache[18] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => formData.value.title = $event),
                                type: "text",
                                required: "",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-300 hover:border-green-400 dark:hover:border-green-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("grammar.manager.titlePlaceholder", "e.g., Present Perfect Tense")
                              }, null, 8, _hoisted_33$l), [
                                [vModelText, formData.value.title]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_34$j, [
                              createBaseVNode("label", _hoisted_35$j, [
                                _cache[19] || (_cache[19] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.category", "Category")) + " ", 1),
                                _cache[20] || (_cache[20] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              withDirectives(createBaseVNode("select", {
                                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => formData.value.category = $event),
                                required: "",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-300 hover:border-purple-400 dark:hover:border-purple-500 transform hover:scale-[1.02] cursor-pointer"
                              }, [
                                createBaseVNode("option", _hoisted_36$i, toDisplayString$1(unref(t)("grammar.manager.selectCategory", "Select Category")), 1),
                                createBaseVNode("option", _hoisted_37$h, toDisplayString$1(unref(t)("grammar.categories.tenses", "Tenses")), 1),
                                createBaseVNode("option", _hoisted_38$h, toDisplayString$1(unref(t)("grammar.categories.conditionals", "Conditionals")), 1),
                                createBaseVNode("option", _hoisted_39$f, toDisplayString$1(unref(t)("grammar.categories.passive", "Passive Voice")), 1),
                                createBaseVNode("option", _hoisted_40$f, toDisplayString$1(unref(t)("grammar.categories.modals", "Modal Verbs")), 1),
                                createBaseVNode("option", _hoisted_41$e, toDisplayString$1(unref(t)("grammar.categories.articles", "Articles")), 1),
                                createBaseVNode("option", _hoisted_42$c, toDisplayString$1(unref(t)("grammar.categories.prepositions", "Prepositions")), 1),
                                createBaseVNode("option", _hoisted_43$b, toDisplayString$1(unref(t)("grammar.categories.conjunctions", "Conjunctions")), 1),
                                createBaseVNode("option", _hoisted_44$b, toDisplayString$1(unref(t)("grammar.categories.other", "Other")), 1)
                              ], 512), [
                                [vModelSelect, formData.value.category]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_45$a, [
                              createBaseVNode("label", _hoisted_46$a, [
                                _cache[21] || (_cache[21] = createBaseVNode("span", { class: "w-1 h-4 bg-orange-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.level", "Level")) + " ", 1),
                                _cache[22] || (_cache[22] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              withDirectives(createBaseVNode("select", {
                                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => formData.value.level = $event),
                                required: "",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all duration-300 hover:border-orange-400 dark:hover:border-orange-500 transform hover:scale-[1.02] cursor-pointer"
                              }, [
                                createBaseVNode("option", _hoisted_47$a, toDisplayString$1(unref(t)("grammar.manager.selectLevel", "Select Level")), 1),
                                createBaseVNode("option", _hoisted_48$a, toDisplayString$1(unref(t)("grammar.levels.beginner", "Beginner")), 1),
                                createBaseVNode("option", _hoisted_49$9, toDisplayString$1(unref(t)("grammar.levels.intermediate", "Intermediate")), 1),
                                createBaseVNode("option", _hoisted_50$9, toDisplayString$1(unref(t)("grammar.levels.advanced", "Advanced")), 1)
                              ], 512), [
                                [vModelSelect, formData.value.level]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_51$8, [
                              createBaseVNode("label", _hoisted_52$8, [
                                _cache[23] || (_cache[23] = createBaseVNode("span", { class: "w-1 h-4 bg-yellow-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.formula", "Grammar Formula")) + " ", 1),
                                _cache[24] || (_cache[24] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              createBaseVNode("div", _hoisted_53$8, [
                                withDirectives(createBaseVNode("textarea", {
                                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => formData.value.formula = $event),
                                  required: "",
                                  rows: "3",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent transition-all duration-300 hover:border-yellow-400 dark:hover:border-yellow-500 transform hover:scale-[1.02] resize-none",
                                  placeholder: unref(t)("grammar.manager.formulaPlaceholder", "e.g., Subject + have/has + past participle + <br> or </br> for line break")
                                }, null, 8, _hoisted_54$8), [
                                  [vModelText, formData.value.formula]
                                ]),
                                formData.value.formula.trim() ? (openBlock(), createElementBlock("div", _hoisted_55$8, [
                                  createBaseVNode("div", _hoisted_56$8, toDisplayString$1(unref(t)("grammar.manager.preview", "Preview")) + ":", 1),
                                  createBaseVNode("div", {
                                    class: "text-gray-900 dark:text-white",
                                    innerHTML: formulaPreview.value
                                  }, null, 8, _hoisted_57$8)
                                ])) : createCommentVNode("", true)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_58$8, [
                              createBaseVNode("label", _hoisted_59$7, [
                                _cache[25] || (_cache[25] = createBaseVNode("span", { class: "w-1 h-4 bg-teal-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.description", "Description")), 1)
                              ]),
                              createBaseVNode("div", _hoisted_60$7, [
                                withDirectives(createBaseVNode("textarea", {
                                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => formData.value.description = $event),
                                  rows: "3",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all duration-300 hover:border-teal-400 dark:hover:border-teal-500 transform hover:scale-[1.02] resize-none",
                                  placeholder: unref(t)("grammar.manager.descriptionPlaceholder", "Explain when and how to use this grammar rule + <br> or </br> for line break")
                                }, null, 8, _hoisted_61$6), [
                                  [vModelText, formData.value.description]
                                ]),
                                formData.value.description.trim() ? (openBlock(), createElementBlock("div", _hoisted_62$6, [
                                  createBaseVNode("div", _hoisted_63$4, toDisplayString$1(unref(t)("grammar.manager.preview", "Preview")) + ":", 1),
                                  createBaseVNode("div", {
                                    class: "text-gray-900 dark:text-white",
                                    innerHTML: descriptionPreview.value
                                  }, null, 8, _hoisted_64$4)
                                ])) : createCommentVNode("", true)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_65$4, [
                              createBaseVNode("label", _hoisted_66$4, [
                                _cache[26] || (_cache[26] = createBaseVNode("span", { class: "w-1 h-4 bg-pink-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.examples", "Examples")), 1)
                              ]),
                              createBaseVNode("div", _hoisted_67$4, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(formData.value.examples, (example, index) => {
                                  return openBlock(), createElementBlock("div", {
                                    key: index,
                                    class: "flex items-center space-x-2"
                                  }, [
                                    withDirectives(createBaseVNode("input", {
                                      "onUpdate:modelValue": ($event) => formData.value.examples[index] = $event,
                                      type: "text",
                                      class: "flex-1 px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-transparent transition-all duration-300 hover:border-pink-400 dark:hover:border-pink-500 transform hover:scale-[1.02]",
                                      placeholder: unref(t)("grammar.manager.examplePlaceholder", "e.g., I have finished my homework.")
                                    }, null, 8, _hoisted_68$4), [
                                      [vModelText, formData.value.examples[index]]
                                    ]),
                                    createBaseVNode("button", {
                                      type: "button",
                                      onClick: ($event) => removeExample(index),
                                      class: "text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-50 dark:hover:bg-red-900/20 transition-all duration-300 hover:scale-110"
                                    }, _cache[27] || (_cache[27] = [
                                      createBaseVNode("svg", {
                                        class: "w-4 h-4",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M6 18L18 6M6 6l12 12"
                                        })
                                      ], -1)
                                    ]), 8, _hoisted_69$4)
                                  ]);
                                }), 128)),
                                createBaseVNode("button", {
                                  type: "button",
                                  onClick: addExample,
                                  class: "text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 text-sm font-medium transition-all duration-300 hover:scale-105"
                                }, " + " + toDisplayString$1(unref(t)("grammar.manager.addExample", "Add Example")), 1)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_70$4, [
                              createBaseVNode("button", {
                                type: "button",
                                onClick: resetForm,
                                class: "px-4 py-2 text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 rounded-lg transition-all duration-300 transform hover:scale-105 hover:shadow-md"
                              }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                              createBaseVNode("button", _hoisted_71$4, toDisplayString$1(isEditing.value ? unref(t)("common.update", "Update") : unref(t)("common.add", "Add")), 1)
                            ])
                          ], 32)
                        ]),
                        createBaseVNode("div", _hoisted_72$4, [
                          createBaseVNode("div", _hoisted_73$4, [
                            createBaseVNode("h4", _hoisted_74$4, [
                              _cache[28] || (_cache[28] = createBaseVNode("span", { class: "w-1 h-4 bg-indigo-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.existingRules", "Grammar Rules")), 1)
                            ]),
                            withDirectives(createBaseVNode("select", {
                              "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => filterCategory.value = $event),
                              class: "px-3 py-1 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition-all duration-300 hover:border-indigo-400 dark:hover:border-indigo-500 cursor-pointer"
                            }, [
                              createBaseVNode("option", _hoisted_75$3, toDisplayString$1(unref(t)("common.all", "All Categories")), 1),
                              createBaseVNode("option", _hoisted_76$3, toDisplayString$1(unref(t)("grammar.categories.tenses", "Tenses")), 1),
                              createBaseVNode("option", _hoisted_77$3, toDisplayString$1(unref(t)("grammar.categories.conditionals", "Conditionals")), 1),
                              createBaseVNode("option", _hoisted_78$2, toDisplayString$1(unref(t)("grammar.categories.passive", "Passive Voice")), 1),
                              createBaseVNode("option", _hoisted_79$2, toDisplayString$1(unref(t)("grammar.categories.modals", "Modal Verbs")), 1),
                              createBaseVNode("option", _hoisted_80$2, toDisplayString$1(unref(t)("grammar.categories.articles", "Articles")), 1),
                              createBaseVNode("option", _hoisted_81$2, toDisplayString$1(unref(t)("grammar.categories.prepositions", "Prepositions")), 1),
                              createBaseVNode("option", _hoisted_82$2, toDisplayString$1(unref(t)("grammar.categories.conjunctions", "Conjunctions")), 1),
                              createBaseVNode("option", _hoisted_83$2, toDisplayString$1(unref(t)("grammar.categories.other", "Other")), 1)
                            ], 512), [
                              [vModelSelect, filterCategory.value]
                            ])
                          ]),
                          filteredGrammarRules.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_84$2, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredGrammarRules.value, (rule, index) => {
                              return openBlock(), createElementBlock("div", {
                                key: rule.id,
                                class: "p-4 border border-gray-200 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-mute animate-fade-in-up transition-all duration-300 hover:shadow-lg hover:scale-[1.02]",
                                style: normalizeStyle(`animation-delay: ${1 + index * 0.1}s`)
                              }, [
                                createBaseVNode("div", _hoisted_85$2, [
                                  createBaseVNode("div", _hoisted_86$1, [
                                    createBaseVNode("div", _hoisted_87$1, [
                                      createBaseVNode("h5", _hoisted_88$1, toDisplayString$1(rule.title), 1),
                                      createBaseVNode("span", _hoisted_89$1, toDisplayString$1(unref(t)(`grammar.categories.${rule.category}`, rule.category)), 1),
                                      createBaseVNode("span", _hoisted_90$1, toDisplayString$1(unref(t)(`grammar.levels.${rule.level}`, rule.level)), 1)
                                    ]),
                                    createBaseVNode("div", _hoisted_91$1, [
                                      createBaseVNode("p", _hoisted_92$1, toDisplayString$1(unref(t)("grammar.manager.formula", "Formula")) + ": ", 1),
                                      createBaseVNode("div", {
                                        class: "text-sm text-gray-600 dark:text-gray-400 font-mono bg-gray-50 dark:bg-[#0a0a0a] p-2 rounded",
                                        innerHTML: renderHtmlContent(rule.formula)
                                      }, null, 8, _hoisted_93$1)
                                    ]),
                                    rule.description ? (openBlock(), createElementBlock("div", _hoisted_94$1, [
                                      createBaseVNode("div", {
                                        class: "text-sm text-gray-600 dark:text-gray-400",
                                        innerHTML: renderHtmlContent(rule.description)
                                      }, null, 8, _hoisted_95$1)
                                    ])) : createCommentVNode("", true),
                                    rule.examples && rule.examples.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_96$1, [
                                      createBaseVNode("p", _hoisted_97$1, toDisplayString$1(unref(t)("grammar.manager.examples", "Examples")) + ": ", 1),
                                      createBaseVNode("ul", _hoisted_98$1, [
                                        (openBlock(true), createElementBlock(Fragment, null, renderList(rule.examples, (example) => {
                                          return openBlock(), createElementBlock("li", {
                                            key: example,
                                            class: "flex items-start justify-between"
                                          }, [
                                            createBaseVNode("div", _hoisted_99$1, [
                                              _cache[29] || (_cache[29] = createBaseVNode("span", { class: "text-gray-400 mr-2 mt-0.5" }, "•", -1)),
                                              createBaseVNode("span", _hoisted_100, toDisplayString$1(example), 1)
                                            ]),
                                            createBaseVNode("button", {
                                              onClick: ($event) => playExampleAudio(example),
                                              disabled: isPlayingAudio.value === example,
                                              class: normalizeClass(["ml-2 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-[#0a0a0a] transition-colors duration-200 flex-shrink-0", {
                                                "text-blue-500 dark:text-blue-400": isPlayingAudio.value !== example,
                                                "text-orange-500 dark:text-orange-400 animate-pulse": isPlayingAudio.value === example
                                              }]),
                                              title: unref(t)("grammar.examples.playAudio", "Play example audio")
                                            }, [
                                              isPlayingAudio.value !== example ? (openBlock(), createElementBlock("svg", _hoisted_102, _cache[30] || (_cache[30] = [
                                                createBaseVNode("path", {
                                                  "stroke-linecap": "round",
                                                  "stroke-linejoin": "round",
                                                  "stroke-width": "2",
                                                  d: "M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M6 10l4-4v12l-4-4H3a1 1 0 01-1-1v-2a1 1 0 011-1h3z"
                                                }, null, -1)
                                              ]))) : (openBlock(), createElementBlock("svg", _hoisted_103, _cache[31] || (_cache[31] = [
                                                createBaseVNode("path", {
                                                  "stroke-linecap": "round",
                                                  "stroke-linejoin": "round",
                                                  "stroke-width": "2",
                                                  d: "M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"
                                                }, null, -1)
                                              ])))
                                            ], 10, _hoisted_101)
                                          ]);
                                        }), 128))
                                      ])
                                    ])) : createCommentVNode("", true),
                                    createBaseVNode("p", _hoisted_104, toDisplayString$1(unref(t)("grammar.manager.createdAt", "Created")) + ": " + toDisplayString$1(formatDate(rule.createdAt)), 1)
                                  ]),
                                  createBaseVNode("div", _hoisted_105, [
                                    createBaseVNode("button", {
                                      onClick: ($event) => editGrammar(rule),
                                      class: "text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 p-1 rounded-full hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-all duration-300 hover:scale-110",
                                      title: unref(t)("common.edit", "Edit")
                                    }, _cache[32] || (_cache[32] = [
                                      createBaseVNode("svg", {
                                        class: "w-4 h-4",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                                        })
                                      ], -1)
                                    ]), 8, _hoisted_106),
                                    createBaseVNode("button", {
                                      onClick: ($event) => deleteGrammar(rule.id),
                                      class: "text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300 p-1 rounded-full hover:bg-red-50 dark:hover:bg-red-900/20 transition-all duration-300 hover:scale-110",
                                      title: unref(t)("common.delete", "Delete")
                                    }, _cache[33] || (_cache[33] = [
                                      createBaseVNode("svg", {
                                        class: "w-4 h-4",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M19 7l-.867 12.142A2 2 0 0016.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                                        })
                                      ], -1)
                                    ]), 8, _hoisted_107)
                                  ])
                                ])
                              ], 4);
                            }), 128))
                          ])) : (openBlock(), createElementBlock("div", _hoisted_108, [
                            _cache[34] || (_cache[34] = createBaseVNode("svg", {
                              class: "w-12 h-12 text-gray-400 mx-auto mb-4",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                              })
                            ], -1)),
                            createBaseVNode("p", _hoisted_109, toDisplayString$1(unref(t)("grammar.manager.noRules", "No grammar rules found")), 1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_110, [
                        createBaseVNode("div", _hoisted_111, [
                          createBaseVNode("button", {
                            onClick: closeModal,
                            class: "px-4 py-2 bg-gray-100 dark:bg-dark-bg-mute hover:bg-gray-200 dark:hover:bg-dark-bg-soft text-gray-700 dark:text-gray-300 rounded-lg transition-all duration-300 transform hover:scale-105 hover:shadow-md"
                          }, toDisplayString$1(unref(t)("common.close", "Close")), 1)
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const GrammarManagerModal = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["__scopeId", "data-v-cbcef1c1"]]);

const GrammarManagerModal$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: GrammarManagerModal
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$Z = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$W = { class: "w-full max-w-md mx-4" };
const _hoisted_3$U = { class: "bg-white dark:bg-[#0a0a0a] p-4 border-b border-gray-200 dark:border-white/10" };
const _hoisted_4$S = { class: "flex items-center justify-between" };
const _hoisted_5$P = { class: "flex items-center space-x-2" };
const _hoisted_6$N = { class: "text-lg font-medium text-gray-900 dark:text-white" };
const _hoisted_7$L = { class: "p-4" };
const _hoisted_8$L = {
  key: 0,
  class: "mb-4"
};
const _hoisted_9$K = {
  key: 0,
  class: "mb-4"
};
const _hoisted_10$J = { class: "text-sm text-gray-500 dark:text-white/60 mb-1" };
const _hoisted_11$J = { class: "mb-2" };
const _hoisted_12$I = { class: "text-lg font-medium text-gray-900 dark:text-white" };
const _hoisted_13$I = { class: "text-sm text-gray-600 dark:text-white/70 bg-gray-50 dark:bg-black/20 px-3 py-2 rounded-md" };
const _hoisted_14$I = { class: "font-medium" };
const _hoisted_15$D = { key: 1 };
const _hoisted_16$C = { class: "text-sm text-gray-500 dark:text-white/60 mb-1" };
const _hoisted_17$B = { class: "mb-1" };
const _hoisted_18$z = { class: "text-lg font-medium text-gray-900 dark:text-white" };
const _hoisted_19$z = { class: "text-gray-500 dark:text-white/60 ml-2" };
const _hoisted_20$y = { class: "text-sm text-gray-500 dark:text-white/60" };
const _hoisted_21$y = { class: "mb-4" };
const _hoisted_22$w = { class: "flex items-center justify-between" };
const _hoisted_23$w = {
  for: "filterByTopic",
  class: "text-sm font-medium text-gray-700 dark:text-white"
};
const _hoisted_24$v = { class: "relative inline-flex items-center cursor-pointer" };
const _hoisted_25$v = {
  key: 0,
  class: "text-xs text-gray-500 dark:text-white/60 mt-1"
};
const _hoisted_26$t = { class: "font-medium" };
const _hoisted_27$s = { class: "mb-4" };
const _hoisted_28$r = {
  for: "targetDate",
  class: "block text-sm font-medium text-gray-700 dark:text-white mb-2"
};
const _hoisted_29$p = { value: "" };
const _hoisted_30$o = ["value"];
const _hoisted_31$n = {
  key: 0,
  class: "text-sm text-gray-500 dark:text-white/60 mt-2"
};
const _hoisted_32$k = { class: "px-4 py-4 bg-white dark:bg-[#0a0a0a] border-t border-gray-200 dark:border-white/10 flex justify-end space-x-3" };
const _hoisted_33$k = ["disabled"];
const _sfc_main$Z = /* @__PURE__ */ defineComponent({
  __name: "MoveModal",
  props: {
    showModal: { type: Boolean },
    wordToMove: {},
    availableDateGroups: {},
    sourceDate: {},
    allVocabularies: {}
  },
  emits: ["close", "confirm-move"],
  setup(__props, { emit: __emit }) {
    const { t, locale } = useI18n();
    const props = __props;
    const emit = __emit;
    const selectedTargetDate = ref("");
    const getStoredFilterState = () => {
      try {
        const stored = localStorage.getItem("vocabulary-move-filter-by-topic");
        return stored ? JSON.parse(stored) : false;
      } catch (error) {
        console.warn("Failed to parse stored filter state:", error);
        return false;
      }
    };
    const setStoredFilterState = (value) => {
      try {
        localStorage.setItem("vocabulary-move-filter-by-topic", JSON.stringify(value));
      } catch (error) {
        console.warn("Failed to store filter state:", error);
      }
    };
    const filterBySameTopic = ref(getStoredFilterState());
    watch(filterBySameTopic, (newValue) => {
      setStoredFilterState(newValue);
    });
    const filteredDateGroups = computed(() => {
      console.log("Filter state:", {
        filterBySameTopic: filterBySameTopic.value,
        hasWordToMove: !!props.wordToMove,
        hasAllVocabularies: !!props.allVocabularies,
        allVocabulariesLength: props.allVocabularies?.length
      });
      if (!filterBySameTopic.value || !props.wordToMove || !props.allVocabularies) {
        return props.availableDateGroups;
      }
      const currentCategory = props.wordToMove.categoryName || props.wordToMove.category;
      console.log("Current category:", currentCategory);
      console.log("Word to move:", props.wordToMove);
      if (!currentCategory) {
        return props.availableDateGroups;
      }
      console.log("Sample vocabularies:", props.allVocabularies.slice(0, 3));
      const filtered = props.availableDateGroups.filter((dateGroup) => {
        const groupDate = new Date(dateGroup.date);
        const groupDateStr = groupDate.toISOString().split("T")[0];
        const hasMatch = props.allVocabularies.some((vocab) => {
          if (vocab.category !== currentCategory) return false;
          const vocabDateStr = vocab.createdAt ? new Date(vocab.createdAt).toISOString().split("T")[0] : null;
          const vocabUpdateDateStr = vocab.updatedAt ? new Date(vocab.updatedAt).toISOString().split("T")[0] : null;
          const matches = vocabDateStr === groupDateStr || vocabUpdateDateStr === groupDateStr;
          if (matches) {
            console.log("Found match:", {
              vocab: vocab.word,
              category: vocab.category,
              vocabDate: vocabDateStr,
              groupDate: groupDateStr
            });
          }
          return matches;
        });
        return hasMatch;
      });
      console.log("Filtered result:", filtered.length, "groups");
      return filtered;
    });
    const formatDateForDisplay = (dateStr) => {
      const date = new Date(dateStr);
      return date.toLocaleDateString(locale.value, {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    };
    const closeModal = () => {
      selectedTargetDate.value = "";
      emit("close");
    };
    const confirmMove = () => {
      if (props.wordToMove && selectedTargetDate.value) {
        emit("confirm-move", {
          word: props.wordToMove,
          targetDate: selectedTargetDate.value
        });
        closeModal();
      }
    };
    watch(() => props.showModal, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        document.body.classList.remove("modal-open");
        selectedTargetDate.value = "";
      }
    });
    onUnmounted(() => {
      document.body.classList.remove("modal-open");
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.showModal ? (openBlock(), createElementBlock("div", _hoisted_1$Z, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$W, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-white/10 overflow-hidden transform",
                      onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$U, [
                        createBaseVNode("div", _hoisted_4$S, [
                          createBaseVNode("div", _hoisted_5$P, [
                            _cache[3] || (_cache[3] = createBaseVNode("div", { class: "w-2 h-2 bg-green-500 rounded-full" }, null, -1)),
                            createBaseVNode("h3", _hoisted_6$N, toDisplayString$1(unref(t)("vocabulary.moveVocabulary", "Move Vocabulary")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: closeModal,
                            class: "text-gray-400 dark:text-white/60 hover:text-gray-600 dark:hover:text-white transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-black/20"
                          }, _cache[4] || (_cache[4] = [
                            createBaseVNode("svg", {
                              class: "w-5 h-5",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", {
                                "fill-rule": "evenodd",
                                d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                                "clip-rule": "evenodd"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_7$L, [
                        _ctx.wordToMove ? (openBlock(), createElementBlock("div", _hoisted_8$L, [
                          _ctx.wordToMove.isBatchMove ? (openBlock(), createElementBlock("div", _hoisted_9$K, [
                            createBaseVNode("p", _hoisted_10$J, toDisplayString$1(unref(t)("vocabulary.movingCategory", "Moving all words in category")) + ": ", 1),
                            createBaseVNode("div", _hoisted_11$J, [
                              createBaseVNode("span", _hoisted_12$I, toDisplayString$1(unref(getTopicName)(_ctx.wordToMove.categoryName || _ctx.wordToMove.category, unref(t), unref(locale), _ctx.wordToMove)), 1)
                            ]),
                            createBaseVNode("p", _hoisted_13$I, [
                              createBaseVNode("span", _hoisted_14$I, toDisplayString$1(_ctx.wordToMove.batchWords?.length || 0), 1),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.wordsWillBeMoved", "words will be moved to the selected date")), 1)
                            ])
                          ])) : (openBlock(), createElementBlock("div", _hoisted_15$D, [
                            createBaseVNode("p", _hoisted_16$C, toDisplayString$1(unref(t)("vocabulary.movingWord", "Moving word")) + ": ", 1),
                            createBaseVNode("div", _hoisted_17$B, [
                              createBaseVNode("span", _hoisted_18$z, toDisplayString$1(_ctx.wordToMove.word), 1),
                              createBaseVNode("span", _hoisted_19$z, "- " + toDisplayString$1(_ctx.wordToMove.meaning), 1)
                            ]),
                            createBaseVNode("p", _hoisted_20$y, " Topic: " + toDisplayString$1(unref(getTopicName)(_ctx.wordToMove.category, unref(t), unref(locale), _ctx.wordToMove)), 1)
                          ]))
                        ])) : createCommentVNode("", true),
                        createBaseVNode("div", _hoisted_21$y, [
                          createBaseVNode("div", _hoisted_22$w, [
                            createBaseVNode("label", _hoisted_23$w, toDisplayString$1(unref(t)("vocabulary.filterBySameTopic", "Filter by same topic")), 1),
                            createBaseVNode("label", _hoisted_24$v, [
                              withDirectives(createBaseVNode("input", {
                                id: "filterByTopic",
                                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => filterBySameTopic.value = $event),
                                type: "checkbox",
                                class: "sr-only peer"
                              }, null, 512), [
                                [vModelCheckbox, filterBySameTopic.value]
                              ]),
                              _cache[5] || (_cache[5] = createBaseVNode("div", { class: "w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-1 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-[#0a0a0a] peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-white/20 peer-checked:bg-blue-600" }, null, -1))
                            ])
                          ]),
                          filterBySameTopic.value ? (openBlock(), createElementBlock("p", _hoisted_25$v, [
                            createTextVNode(toDisplayString$1(unref(t)("vocabulary.showingDatesWithSameTopic", "Showing only dates with same topic")) + ": ", 1),
                            createBaseVNode("span", _hoisted_26$t, toDisplayString$1(unref(getTopicName)(_ctx.wordToMove?.categoryName || _ctx.wordToMove?.category || "", unref(t), unref(locale), _ctx.wordToMove)), 1)
                          ])) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("div", _hoisted_27$s, [
                          createBaseVNode("label", _hoisted_28$r, toDisplayString$1(unref(t)("vocabulary.selectTargetDateGroup", "Select target date group")) + ": ", 1),
                          withDirectives(createBaseVNode("select", {
                            id: "targetDate",
                            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedTargetDate.value = $event),
                            class: "w-full px-3 py-2 border border-gray-300 dark:border-white/20 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white"
                          }, [
                            createBaseVNode("option", _hoisted_29$p, toDisplayString$1(unref(t)("vocabulary.selectDate", "Select a date")), 1),
                            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredDateGroups.value, (dateGroup) => {
                              return openBlock(), createElementBlock("option", {
                                key: dateGroup.date,
                                value: dateGroup.date
                              }, toDisplayString$1(formatDateForDisplay(dateGroup.date)) + " (" + toDisplayString$1(dateGroup.count) + " words) ", 9, _hoisted_30$o);
                            }), 128))
                          ], 512), [
                            [vModelSelect, selectedTargetDate.value]
                          ]),
                          filteredDateGroups.value.length === 0 ? (openBlock(), createElementBlock("p", _hoisted_31$n, toDisplayString$1(unref(t)("vocabulary.noMatchingDates", "No dates found with this topic. Try disabling the filter.")), 1)) : createCommentVNode("", true)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_32$k, [
                        createBaseVNode("button", {
                          onClick: closeModal,
                          class: "px-4 py-2 text-sm font-medium text-gray-700 dark:text-white bg-gray-100 dark:bg-black/40 rounded-md hover:bg-gray-200 dark:hover:bg-black/60 transition-all duration-200 hover:scale-105 hover:shadow-md active:scale-95"
                        }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                        createBaseVNode("button", {
                          onClick: confirmMove,
                          disabled: !selectedTargetDate.value,
                          class: "px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 hover:scale-105 hover:shadow-md hover:-translate-y-0.5 active:scale-95"
                        }, toDisplayString$1(_ctx.wordToMove?.isBatchMove ? unref(t)("vocabulary.moveAll", "Move All") : unref(t)("vocabulary.moveWord", "Move Word")), 9, _hoisted_33$k)
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const MoveModal = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["__scopeId", "data-v-98e3af71"]]);

const MoveModal$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: MoveModal
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$Y = { class: "flex flex-col sm:flex-row sm:items-center space-y-2 sm:space-y-0 sm:space-x-3 md:space-x-4 lg:space-x-4" };
const _hoisted_2$V = { class: "text-sm md:text-sm lg:text-base font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_3$T = { class: "flex items-center space-x-2" };
const _hoisted_4$R = { class: "text-sm md:text-base lg:text-lg" };
const _hoisted_5$O = { class: "truncate" };
const _hoisted_6$M = { class: "overflow-y-auto max-h-60" };
const _hoisted_7$K = ["onClick"];
const _hoisted_8$K = { class: "flex items-center space-x-2 min-w-0 flex-1" };
const _hoisted_9$J = { class: "text-sm md:text-base lg:text-lg flex-shrink-0" };
const _hoisted_10$I = { class: "truncate flex-1" };
const _hoisted_11$I = { class: "flex items-center space-x-1 flex-shrink-0" };
const _hoisted_12$H = {
  key: 0,
  class: "inline-block w-4 h-4 md:w-4 md:h-4 lg:w-5 lg:h-5 text-blue-600 dark:text-blue-400 flex-shrink-0",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_13$H = ["onClick"];
const _hoisted_14$H = {
  key: 0,
  class: "absolute z-[9999] bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 dark:bg-gray-700 text-white text-xs rounded-lg shadow-lg whitespace-nowrap"
};
const _hoisted_15$C = ["disabled"];
const _hoisted_16$B = {
  key: 0,
  class: "w-4 h-4 md:w-4 md:h-4 lg:w-5 lg:h-5",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_17$A = {
  key: 1,
  class: "w-4 h-4 md:w-4 md:h-4 lg:w-5 lg:h-5 animate-spin",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _sfc_main$Y = /* @__PURE__ */ defineComponent({
  __name: "VoiceSelector",
  props: {
    showVoiceInfo: { type: Boolean, default: true }
  },
  setup(__props) {
    const VoiceSettingsModal = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VoiceSettingsModal$1),true              ?void 0:void 0));
    const { t } = useI18n();
    const {
      voiceSettings,
      currentVoiceType,
      setVoiceType,
      updateVoiceSettings,
      resetVoiceSettings,
      playAudio,
      getVoiceTypeOptions,
      getCurrentVoiceInfo,
      loadVoices
    } = useVoiceStore();
    const isTesting = ref(false);
    const showTooltip = ref(false);
    const showDropdown = ref(false);
    const dropdownButton = ref(null);
    const dropdownMenu = ref(null);
    const dropdownContainer = ref(null);
    const showSettingsModal = ref(false);
    const selectedVoiceForSettings = ref(null);
    const voiceOptions = computed(() => getVoiceTypeOptions());
    const currentVoiceInfo = computed(() => getCurrentVoiceInfo());
    const currentVoiceOption = computed(() => {
      return voiceOptions.value.find((option) => option.value === currentVoiceType.value);
    });
    const dropdownStyle = computed(() => {
      if (!showDropdown.value || !dropdownButton.value) {
        return { display: "none" };
      }
      const buttonRect = dropdownButton.value.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const dropdownWidth = buttonRect.width;
      let leftPosition = buttonRect.left;
      if (leftPosition + dropdownWidth > viewportWidth) {
        leftPosition = viewportWidth - dropdownWidth - 8;
      }
      if (leftPosition < 8) {
        leftPosition = 8;
      }
      return {
        position: "fixed",
        top: `${buttonRect.bottom + 4}px`,
        left: `${leftPosition}px`,
        width: `${buttonRect.width}px`,
        maxWidth: `${viewportWidth - 16}px`,
        // Ensure it never exceeds viewport width
        zIndex: "9999"
      };
    });
    const handleVoiceChange = (voiceType) => {
      setVoiceType(voiceType);
    };
    const selectVoiceOption = (option) => {
      handleVoiceChange(option.value);
      showDropdown.value = false;
    };
    const testVoice = async () => {
      if (isTesting.value) return;
      isTesting.value = true;
      try {
        let testText = t("voice.testText", "Hello, this is a test of the selected voice.");
        if (currentVoiceType.value === "korean-female" || currentVoiceType.value === "korean-male") {
          testText = t("voice.testTextKorean", "안녕하세요! 이것은 음성 테스트입니다.");
        }
        console.log("Testing voice:", currentVoiceType.value, "with text:", testText);
        await playAudio(testText);
      } catch (error) {
        console.error("Error testing voice:", error);
      } finally {
        isTesting.value = false;
      }
    };
    const openVoiceSettings = (option) => {
      selectedVoiceForSettings.value = option;
      showSettingsModal.value = true;
      showDropdown.value = false;
    };
    const handleSaveVoiceSettings = (payload) => {
      updateVoiceSettings(payload.voiceType, payload.settings);
      showSettingsModal.value = false;
    };
    const handleResetVoiceSettings = (voiceType) => {
      resetVoiceSettings(voiceType);
      const option = voiceOptions.value.find((o) => o.value === voiceType);
      if (option) {
        selectedVoiceForSettings.value = option;
      }
    };
    const handleClickOutside = (event) => {
      if (showDropdown.value) {
        const target = event.target;
        if (dropdownButton.value && !dropdownButton.value.contains(target) && dropdownMenu.value && !dropdownMenu.value.contains(target)) {
          showDropdown.value = false;
        }
      }
    };
    const updateDropdownPosition = () => {
      if (showDropdown.value && dropdownButton.value) {
        const buttonRect = dropdownButton.value.getBoundingClientRect();
        const dropdown = dropdownMenu.value;
        if (dropdown) {
          dropdown.style.top = `${buttonRect.bottom + 4}px`;
          dropdown.style.left = `${buttonRect.left}px`;
          dropdown.style.minWidth = `${buttonRect.width}px`;
        }
      }
    };
    let scrollTimeout = null;
    const handleScroll = () => {
      if (showDropdown.value) {
        if (scrollTimeout) {
          cancelAnimationFrame(scrollTimeout);
        }
        scrollTimeout = requestAnimationFrame(updateDropdownPosition);
      }
    };
    const handleResize = () => {
      if (showDropdown.value) {
        showDropdown.value = false;
      }
    };
    onMounted(() => {
      loadVoices();
      document.addEventListener("click", handleClickOutside);
      window.addEventListener("scroll", handleScroll, true);
      window.addEventListener("resize", handleResize);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleClickOutside);
      window.removeEventListener("scroll", handleScroll, true);
      window.removeEventListener("resize", handleResize);
      if (scrollTimeout) {
        cancelAnimationFrame(scrollTimeout);
      }
    });
    watch(currentVoiceType, (newType) => {
      console.log("VoiceSelector: Voice type changed to:", newType);
    }, { immediate: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$Y, [
        createBaseVNode("span", _hoisted_2$V, toDisplayString$1(unref(t)("voice.selector.title", "Voice")), 1),
        createBaseVNode("div", {
          class: "relative w-full sm:w-auto",
          onClick: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"])),
          ref_key: "dropdownContainer",
          ref: dropdownContainer
        }, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => showDropdown.value = !showDropdown.value),
            ref_key: "dropdownButton",
            ref: dropdownButton,
            class: "flex w-full min-w-[240px] sm:min-w-[260px] md:min-w-[280px] lg:min-w-[300px] items-center justify-between px-3 py-2 md:px-3 md:py-2 lg:px-4 lg:py-2.5 bg-white dark:bg-[#0f0f0f] border border-gray-300 dark:border-gray-700 rounded-lg text-sm md:text-sm lg:text-base font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-[#0a0a0a] transition-colors"
          }, [
            createBaseVNode("div", _hoisted_3$T, [
              createBaseVNode("span", _hoisted_4$R, toDisplayString$1(currentVoiceOption.value?.icon), 1),
              createBaseVNode("span", _hoisted_5$O, toDisplayString$1(currentVoiceOption.value?.label), 1)
            ]),
            (openBlock(), createElementBlock("svg", {
              class: normalizeClass(["w-4 h-4 md:w-4 md:h-4 lg:w-5 lg:h-5 flex-shrink-0", { "rotate-180": showDropdown.value }]),
              fill: "none",
              stroke: "currentColor",
              viewBox: "0 0 24 24"
            }, _cache[5] || (_cache[5] = [
              createBaseVNode("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M19 9l-7 7-7-7"
              }, null, -1)
            ]), 2))
          ], 512)
        ], 512),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          showDropdown.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            ref_key: "dropdownMenu",
            ref: dropdownMenu,
            style: normalizeStyle(dropdownStyle.value),
            class: "bg-white dark:bg-[#0f0f0f] border border-gray-300 dark:border-gray-700 rounded-lg shadow-lg max-h-60 overflow-hidden z-[9998] min-w-[240px] sm:min-w-[260px] md:min-w-[280px] lg:min-w-[300px]"
          }, [
            createBaseVNode("div", _hoisted_6$M, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(voiceOptions.value, (option) => {
                return openBlock(), createElementBlock("div", {
                  key: option.value,
                  onClick: ($event) => selectVoiceOption(option),
                  class: normalizeClass([
                    "flex items-center justify-between gap-2 px-3 py-2 md:px-3 md:py-2 lg:px-4 lg:py-2.5 text-left text-sm md:text-sm lg:text-base transition-colors cursor-pointer",
                    unref(currentVoiceType) === option.value ? "bg-blue-50 dark:bg-[#2d3436] text-blue-600 dark:text-blue-400" : "text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800"
                  ])
                }, [
                  createBaseVNode("div", _hoisted_8$K, [
                    createBaseVNode("span", _hoisted_9$J, toDisplayString$1(option.icon), 1),
                    createBaseVNode("span", _hoisted_10$I, toDisplayString$1(option.label), 1)
                  ]),
                  createBaseVNode("div", _hoisted_11$I, [
                    unref(currentVoiceType) === option.value ? (openBlock(), createElementBlock("svg", _hoisted_12$H, _cache[6] || (_cache[6] = [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                        "clip-rule": "evenodd"
                      }, null, -1)
                    ]))) : createCommentVNode("", true),
                    createBaseVNode("button", {
                      onClick: withModifiers(($event) => openVoiceSettings(option), ["stop"]),
                      class: "inline-block p-1 md:p-1 lg:p-1.5 rounded-full hover:bg-gray-200 dark:hover:bg-gray-500 flex-shrink-0"
                    }, _cache[7] || (_cache[7] = [
                      createBaseVNode("svg", {
                        class: "inline-block w-3 h-3 sm:w-4 sm:h-4 md:w-4 md:h-4 lg:w-4 lg:h-4 text-gray-500 dark:text-gray-400",
                        fill: "none",
                        stroke: "currentColor",
                        viewBox: "0 0 24 24"
                      }, [
                        createBaseVNode("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"
                        }),
                        createBaseVNode("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                        })
                      ], -1)
                    ]), 8, _hoisted_13$H)
                  ])
                ], 10, _hoisted_7$K);
              }), 128))
            ])
          ], 4)) : createCommentVNode("", true)
        ])),
        _ctx.showVoiceInfo && currentVoiceInfo.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "relative",
          onMouseenter: _cache[2] || (_cache[2] = ($event) => showTooltip.value = true),
          onMouseleave: _cache[3] || (_cache[3] = ($event) => showTooltip.value = false)
        }, [
          _cache[9] || (_cache[9] = createBaseVNode("button", { class: "p-2 text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 transition-colors" }, [
            createBaseVNode("svg", {
              class: "w-4 h-4",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z",
                "clip-rule": "evenodd"
              })
            ])
          ], -1)),
          showTooltip.value ? (openBlock(), createElementBlock("div", _hoisted_14$H, [
            createBaseVNode("div", null, toDisplayString$1(unref(t)("voice.info.name")) + ": " + toDisplayString$1(currentVoiceInfo.value.name), 1),
            createBaseVNode("div", null, toDisplayString$1(unref(t)("voice.info.language")) + ": " + toDisplayString$1(currentVoiceInfo.value.lang), 1),
            createBaseVNode("div", null, toDisplayString$1(unref(t)("voice.info.gender")) + ": " + toDisplayString$1(unref(t)(`voice.gender.${currentVoiceInfo.value.gender}`)), 1),
            _cache[8] || (_cache[8] = createBaseVNode("div", { class: "absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-gray-900 dark:border-t-gray-700" }, null, -1))
          ])) : createCommentVNode("", true)
        ], 32)) : createCommentVNode("", true),
        createBaseVNode("button", {
          onClick: testVoice,
          disabled: isTesting.value,
          class: "flex items-center space-x-1 px-3 py-2 md:px-3 md:py-2 lg:px-4 lg:py-2.5 text-sm md:text-sm lg:text-base bg-blue-500 hover:bg-blue-600 disabled:bg-gray-400 text-white rounded-lg transition-colors w-full sm:w-auto"
        }, [
          !isTesting.value ? (openBlock(), createElementBlock("svg", _hoisted_16$B, _cache[10] || (_cache[10] = [
            createBaseVNode("path", {
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              "stroke-width": "2",
              d: "M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 14.142M9 9a3 3 0 000 6v-6z"
            }, null, -1)
          ]))) : (openBlock(), createElementBlock("svg", _hoisted_17$A, _cache[11] || (_cache[11] = [
            createBaseVNode("circle", {
              class: "opacity-25",
              cx: "12",
              cy: "12",
              r: "10",
              stroke: "currentColor",
              "stroke-width": "4"
            }, null, -1),
            createBaseVNode("path", {
              class: "opacity-75",
              fill: "currentColor",
              d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            }, null, -1)
          ]))),
          createBaseVNode("span", null, toDisplayString$1(isTesting.value ? unref(t)("voice.testing", "Testing...") : unref(t)("voice.test", "Test Voice")), 1)
        ], 8, _hoisted_15$C),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          showSettingsModal.value && selectedVoiceForSettings.value ? (openBlock(), createBlock(unref(VoiceSettingsModal), {
            key: 0,
            show: showSettingsModal.value,
            "voice-type": selectedVoiceForSettings.value.value,
            "voice-name": selectedVoiceForSettings.value.label,
            "initial-settings": unref(voiceSettings)[selectedVoiceForSettings.value.value],
            onClose: _cache[4] || (_cache[4] = ($event) => showSettingsModal.value = false),
            onSave: handleSaveVoiceSettings,
            onReset: handleResetVoiceSettings
          }, null, 8, ["show", "voice-type", "voice-name", "initial-settings"])) : createCommentVNode("", true)
        ]))
      ]);
    };
  }
});

const VoiceSelector = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$Y
}, Symbol.toStringTag, { value: 'Module' }));

function useTopicCRUD(emit) {
  const customTopics = ref([]);
  const editingTopic = ref(null);
  const topicToDelete = ref(null);
  const newTopic = ref({
    key: "",
    vi: "",
    en: "",
    ko: ""
  });
  const canSaveTopic = computed(() => {
    return newTopic.value.vi?.trim() && newTopic.value.en?.trim() && newTopic.value.ko?.trim();
  });
  const showDeleteModal = computed(() => {
    console.log("showDeleteModal computed - topicToDelete:", topicToDelete.value);
    return !!topicToDelete.value;
  });
  const generateTopicKey = (vi, en) => {
    const sourceName = vi.trim() || en.trim();
    if (!sourceName) return "";
    let key = sourceName.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "");
    let counter = 1;
    let originalKey = key;
    while (isKeyTaken(key)) {
      key = `${originalKey}_${counter}`;
      counter++;
    }
    return key;
  };
  const isKeyTaken = (key) => {
    const builtInKeys = [
      "technology",
      "business",
      "travel",
      "food",
      "health",
      "education",
      "sports",
      "entertainment",
      "science",
      "art",
      "music",
      "literature",
      "politics",
      "environment",
      "fashion",
      "finance"
    ];
    if (builtInKeys.includes(key)) return true;
    const existingKeys = customTopics.value.filter((topic) => editingTopic.value ? topic.key !== editingTopic.value.key : true).map((topic) => topic.key);
    return existingKeys.includes(key);
  };
  const loadCustomTopics = () => {
    try {
      const saved = localStorage.getItem("customTopics");
      console.log("Loading custom topics from localStorage:", saved);
      if (saved) {
        const parsed = JSON.parse(saved);
        console.log("Parsed custom topics:", parsed);
        if (Array.isArray(parsed)) {
          customTopics.value = parsed;
          console.log("Custom topics loaded successfully:", customTopics.value);
        } else {
          console.log("Invalid data format, resetting to empty array");
          customTopics.value = [];
          localStorage.removeItem("customTopics");
        }
      } else {
        console.log("No custom topics found in localStorage");
        customTopics.value = [];
      }
      console.log("Final custom topics loaded:", customTopics.value);
    } catch (error) {
      console.error("Error loading custom topics:", error);
      customTopics.value = [];
      localStorage.removeItem("customTopics");
    }
  };
  const saveCustomTopics = () => {
    try {
      console.log("Saving custom topics to localStorage:", customTopics.value);
      localStorage.setItem("customTopics", JSON.stringify(customTopics.value));
      console.log("Custom topics saved successfully");
    } catch (error) {
      console.error("Error saving custom topics:", error);
    }
  };
  const notifyTopicsUpdated = () => {
    window.dispatchEvent(new CustomEvent("topics-updated"));
    console.log("Topics updated, dispatching topics-updated event");
  };
  const saveTopic = () => {
    if (!canSaveTopic.value) return;
    const generatedKey = editingTopic.value ? editingTopic.value.key : generateTopicKey(newTopic.value.vi, newTopic.value.en);
    const topic = {
      key: generatedKey,
      vi: newTopic.value.vi.trim(),
      en: newTopic.value.en.trim(),
      ko: newTopic.value.ko.trim()
    };
    if (editingTopic.value) {
      const index = customTopics.value.findIndex((t) => t.key === editingTopic.value.key);
      if (index !== -1) {
        const oldKey = customTopics.value[index].key;
        customTopics.value[index] = topic;
        saveCustomTopics();
        emit("topic-updated", oldKey, topic);
        notifyTopicsUpdated();
      }
      editingTopic.value = null;
    } else {
      customTopics.value.unshift(topic);
      saveCustomTopics();
      emit("topic-added", topic);
      notifyTopicsUpdated();
    }
    newTopic.value = { key: "", vi: "", en: "", ko: "" };
  };
  const editTopic = (topic) => {
    editingTopic.value = { ...topic };
    newTopic.value = { ...topic };
  };
  const cancelEdit = () => {
    editingTopic.value = null;
    newTopic.value = { key: "", vi: "", en: "", ko: "" };
  };
  const confirmDeleteTopic = (topic) => {
    console.log("Confirming delete for topic:", topic);
    topicToDelete.value = topic;
    console.log("topicToDelete set to:", topicToDelete.value);
  };
  const deleteTopic = () => {
    if (!topicToDelete.value) {
      console.log("No topic to delete");
      return;
    }
    console.log("Attempting to delete topic:", topicToDelete.value);
    console.log("Current custom topics:", customTopics.value);
    const index = customTopics.value.findIndex((t) => t.key === topicToDelete.value.key);
    console.log("Found index:", index);
    if (index !== -1) {
      const key = customTopics.value[index].key;
      console.log("Deleting topic with key:", key);
      const updatedTopics = [...customTopics.value];
      updatedTopics.splice(index, 1);
      customTopics.value = updatedTopics;
      console.log("Topics after deletion:", customTopics.value);
      saveCustomTopics();
      emit("topic-deleted", key);
      notifyTopicsUpdated();
      console.log("Topic deleted successfully");
    } else {
      console.log("Topic not found in custom topics");
    }
    topicToDelete.value = null;
  };
  const reloadCustomTopics = () => {
    console.log("Force reloading custom topics");
    loadCustomTopics();
    customTopics.value = [...customTopics.value];
  };
  const clearAllCustomTopics = () => {
    console.log("Clearing all custom topics");
    customTopics.value = [];
    localStorage.removeItem("customTopics");
    console.log("All custom topics cleared");
  };
  const testDeleteModal = () => {
    console.log("Testing delete modal");
    topicToDelete.value = {
      key: "test",
      vi: "Test Topic",
      en: "Test Topic",
      ko: "테스트 토픽"
    };
    console.log("Test topic set:", topicToDelete.value);
  };
  const resetForm = () => {
    editingTopic.value = null;
    newTopic.value = { key: "", vi: "", en: "", ko: "" };
    topicToDelete.value = null;
  };
  return {
    // State
    customTopics,
    editingTopic,
    topicToDelete,
    newTopic,
    // Computed
    canSaveTopic,
    showDeleteModal,
    // Methods
    loadCustomTopics,
    saveCustomTopics,
    saveTopic,
    editTopic,
    cancelEdit,
    confirmDeleteTopic,
    deleteTopic,
    reloadCustomTopics,
    clearAllCustomTopics,
    testDeleteModal,
    resetForm,
    generateTopicKey,
    isKeyTaken,
    notifyTopicsUpdated
  };
}

function useTopicSearch(customTopics, builtInTopics) {
  const searchQuery = ref("");
  const filteredCustomTopics = computed(() => {
    if (!searchQuery.value.trim()) {
      return customTopics.value;
    }
    const query = searchQuery.value.toLowerCase().trim();
    return customTopics.value.filter(
      (topic) => (topic.key || "").toLowerCase().includes(query) || (topic.vi || "").toLowerCase().includes(query) || (topic.en || "").toLowerCase().includes(query) || (topic.ko || "").toLowerCase().includes(query)
    );
  });
  const filteredBuiltInTopics = computed(() => {
    if (!searchQuery.value.trim()) {
      return builtInTopics.value;
    }
    const query = searchQuery.value.toLowerCase().trim();
    return builtInTopics.value.filter(
      (topic) => (topic.key || "").toLowerCase().includes(query) || (topic.vi || "").toLowerCase().includes(query) || (topic.en || "").toLowerCase().includes(query) || (topic.ko || "").toLowerCase().includes(query)
    );
  });
  const resetSearch = () => {
    searchQuery.value = "";
  };
  return {
    // State
    searchQuery,
    // Computed
    filteredCustomTopics,
    filteredBuiltInTopics,
    // Methods
    resetSearch
  };
}

function useTopicPagination(filteredCustomTopics, filteredBuiltInTopics, searchQuery) {
  const ITEMS_PER_PAGE = 3;
  const currentCustomPage = ref(1);
  const currentBuiltInPage = ref(1);
  const totalCustomPages = computed(() => {
    return Math.ceil(filteredCustomTopics.value.length / ITEMS_PER_PAGE);
  });
  const paginatedCustomTopics = computed(() => {
    const start = (currentCustomPage.value - 1) * ITEMS_PER_PAGE;
    const end = start + ITEMS_PER_PAGE;
    return filteredCustomTopics.value.slice(start, end);
  });
  const totalBuiltInPages = computed(() => {
    return Math.ceil(filteredBuiltInTopics.value.length / ITEMS_PER_PAGE);
  });
  const paginatedBuiltInTopics = computed(() => {
    const start = (currentBuiltInPage.value - 1) * ITEMS_PER_PAGE;
    const end = start + ITEMS_PER_PAGE;
    return filteredBuiltInTopics.value.slice(start, end);
  });
  const visibleCustomPages = computed(() => {
    const total = totalCustomPages.value;
    const current = currentCustomPage.value;
    const maxVisible = 3;
    if (total <= maxVisible) {
      return Array.from({ length: total }, (_, i) => i + 1);
    }
    let start = Math.max(1, current - Math.floor(maxVisible / 2));
    let end = Math.min(total, start + maxVisible - 1);
    if (end - start + 1 < maxVisible) {
      start = Math.max(1, end - maxVisible + 1);
    }
    return Array.from({ length: end - start + 1 }, (_, i) => start + i);
  });
  const visibleBuiltInPages = computed(() => {
    const total = totalBuiltInPages.value;
    const current = currentBuiltInPage.value;
    const maxVisible = 3;
    if (total <= maxVisible) {
      return Array.from({ length: total }, (_, i) => i + 1);
    }
    let start = Math.max(1, current - Math.floor(maxVisible / 2));
    let end = Math.min(total, start + maxVisible - 1);
    if (end - start + 1 < maxVisible) {
      start = Math.max(1, end - maxVisible + 1);
    }
    return Array.from({ length: end - start + 1 }, (_, i) => start + i);
  });
  const goToCustomPage = (page) => {
    if (page >= 1 && page <= totalCustomPages.value) {
      currentCustomPage.value = page;
    }
  };
  const goToBuiltInPage = (page) => {
    if (page >= 1 && page <= totalBuiltInPages.value) {
      currentBuiltInPage.value = page;
    }
  };
  const nextCustomPage = () => {
    if (currentCustomPage.value < totalCustomPages.value) {
      currentCustomPage.value++;
    }
  };
  const prevCustomPage = () => {
    if (currentCustomPage.value > 1) {
      currentCustomPage.value--;
    }
  };
  const nextBuiltInPage = () => {
    if (currentBuiltInPage.value < totalBuiltInPages.value) {
      currentBuiltInPage.value++;
    }
  };
  const prevBuiltInPage = () => {
    if (currentBuiltInPage.value > 1) {
      currentBuiltInPage.value--;
    }
  };
  const resetPagination = () => {
    currentCustomPage.value = 1;
    currentBuiltInPage.value = 1;
  };
  watch(searchQuery, () => {
    resetPagination();
  });
  return {
    // Constants
    ITEMS_PER_PAGE,
    // State
    currentCustomPage,
    currentBuiltInPage,
    // Computed
    totalCustomPages,
    totalBuiltInPages,
    paginatedCustomTopics,
    paginatedBuiltInTopics,
    visibleCustomPages,
    visibleBuiltInPages,
    // Methods
    goToCustomPage,
    goToBuiltInPage,
    nextCustomPage,
    prevCustomPage,
    nextBuiltInPage,
    prevBuiltInPage,
    resetPagination
  };
}

function useTopicModal(modelValue, emit, resetForm, resetSearch, resetPagination, loadCustomTopics) {
  const closeDialog = () => {
    emit("update:modelValue", false);
  };
  const lockBodyScroll = () => {
    document.body.style.overflow = "hidden";
  };
  const unlockBodyScroll = () => {
    document.body.style.overflow = "";
  };
  watch(() => modelValue.value, (newValue) => {
    if (newValue) {
      lockBodyScroll();
      loadCustomTopics();
    } else {
      unlockBodyScroll();
      resetForm();
      resetSearch();
      resetPagination();
    }
  }, { immediate: true });
  onMounted(() => {
    if (modelValue.value) {
      loadCustomTopics();
      lockBodyScroll();
    }
  });
  onUnmounted(() => {
    unlockBodyScroll();
  });
  return {
    // Methods
    closeDialog,
    lockBodyScroll,
    unlockBodyScroll
  };
}

function useBuiltInTopics() {
  const builtInTopics = computed(() => {
    return [
      { key: "technology", vi: "Công nghệ", en: "Technology", ko: "기술" },
      { key: "business", vi: "Kinh doanh", en: "Business", ko: "비즈니스" },
      { key: "travel", vi: "Du lịch", en: "Travel", ko: "여행" },
      { key: "food", vi: "Ẩm thực", en: "Food", ko: "음식" },
      { key: "health", vi: "Sức khỏe", en: "Health", ko: "건강" },
      { key: "education", vi: "Giáo dục", en: "Education", ko: "교육" },
      { key: "sports", vi: "Thể thao", en: "Sports", ko: "스포츠" },
      { key: "entertainment", vi: "Giải trí", en: "Entertainment", ko: "엔터테인먼트" },
      { key: "science", vi: "Khoa học", en: "Science", ko: "과학" },
      { key: "art", vi: "Nghệ thuật", en: "Art", ko: "예술" },
      { key: "music", vi: "Âm nhạc", en: "Music", ko: "음악" },
      { key: "literature", vi: "Văn học", en: "Literature", ko: "문학" },
      { key: "politics", vi: "Chính trị", en: "Politics", ko: "정치" },
      { key: "environment", vi: "Môi trường", en: "Environment", ko: "환경" },
      { key: "fashion", vi: "Thời trang", en: "Fashion", ko: "패션" },
      { key: "finance", vi: "Tài chính", en: "Finance", ko: "금융" }
    ];
  });
  const builtInTopicKeys = computed(() => {
    return builtInTopics.value.map((topic) => topic.key);
  });
  const isBuiltInTopic = (key) => {
    return builtInTopicKeys.value.includes(key);
  };
  const getBuiltInTopic = (key) => {
    return builtInTopics.value.find((topic) => topic.key === key);
  };
  return {
    // Computed
    builtInTopics,
    builtInTopicKeys,
    // Methods
    isBuiltInTopic,
    getBuiltInTopic
  };
}

const _hoisted_1$X = {
  key: 0,
  class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$U = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl w-full max-w-full sm:max-w-lg md:max-w-2xl lg:max-w-4xl max-h-[90vh] flex flex-col overflow-hidden" };
const _hoisted_3$S = { class: "flex-shrink-0 flex flex-row items-center justify-between p-4 sm:p-6 md:p-6 lg:p-8 border-b border-gray-200 dark:border-gray-700 space-x-4 sm:space-x-6 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$Q = { class: "flex-1 min-w-0" };
const _hoisted_5$N = { class: "text-base sm:text-lg md:text-2xl lg:text-2xl font-semibold text-gray-900 dark:text-white mb-0 flex items-center space-x-2" };
const _hoisted_6$L = { class: "sticky top-0 z-10 bg-white dark:bg-[#0a0a0a] border-b border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_7$J = { class: "px-4 py-3 border-b border-gray-100 dark:border-dark-bg-mute" };
const _hoisted_8$J = { class: "relative" };
const _hoisted_9$I = ["placeholder"];
const _hoisted_10$H = { class: "px-4 py-3 bg-gray-50 dark:bg-[#0a0a0a]" };
const _hoisted_11$H = { class: "flex items-center gap-2 mb-2" };
const _hoisted_12$G = { class: "text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_13$G = { class: "flex flex-wrap gap-2" };
const _hoisted_14$G = { class: "flex-1 min-w-[200px]" };
const _hoisted_15$B = ["placeholder"];
const _hoisted_16$A = { class: "flex-1 min-w-[200px]" };
const _hoisted_17$z = ["placeholder"];
const _hoisted_18$y = { class: "flex-1 min-w-[200px]" };
const _hoisted_19$y = ["placeholder"];
const _hoisted_20$x = { class: "flex gap-2" };
const _hoisted_21$x = ["disabled"];
const _hoisted_22$v = { class: "flex-1 p-4 sm:p-6 md:p-6 lg:p-8 overflow-y-auto min-h-0" };
const _hoisted_23$v = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_24$u = { class: "text-base sm:text-lg md:text-base lg:text-lg font-medium text-gray-900 dark:text-white mb-3 sm:mb-4 md:mb-3 lg:mb-4 flex items-center" };
const _hoisted_25$u = {
  key: 0,
  class: "text-center py-6 sm:py-8 md:py-6 lg:py-8 text-sm md:text-sm lg:text-base text-gray-500 dark:text-gray-400"
};
const _hoisted_26$s = {
  key: 1,
  class: "space-y-3 sm:space-y-4 md:space-y-3 lg:space-y-4"
};
const _hoisted_27$r = { class: "flex-1" };
const _hoisted_28$q = { class: "flex items-center gap-4 sm:gap-4 mb-2" };
const _hoisted_29$o = { class: "px-2 py-1 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 text-xs font-medium rounded" };
const _hoisted_30$n = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_31$m = { class: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4 text-sm" };
const _hoisted_32$j = { class: "flex gap-3 sm:gap-4 ml-4" };
const _hoisted_33$j = ["onClick", "title"];
const _hoisted_34$i = ["onClick", "disabled", "title"];
const _hoisted_35$i = {
  key: 0,
  class: "flex justify-center mt-6"
};
const _hoisted_36$h = { class: "flex items-center space-x-1" };
const _hoisted_37$g = ["disabled"];
const _hoisted_38$g = ["onClick"];
const _hoisted_39$e = ["disabled"];
const _hoisted_40$e = {
  class: "mt-6 animate-fade-in-up",
  style: { "animation-delay": "0.8s" }
};
const _hoisted_41$d = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4 flex items-center" };
const _hoisted_42$b = { class: "text-sm text-gray-600 dark:text-gray-400 mb-4" };
const _hoisted_43$a = { class: "grid grid-cols-1 md:grid-cols-2 gap-3 sm:gap-4" };
const _hoisted_44$a = { class: "flex-1" };
const _hoisted_45$9 = { class: "flex items-center gap-3 mb-1" };
const _hoisted_46$9 = { class: "px-2 py-1 bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 text-xs font-medium rounded" };
const _hoisted_47$9 = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_48$9 = { class: "grid grid-cols-1 gap-1 text-sm" };
const _hoisted_49$8 = { class: "ml-4" };
const _hoisted_50$8 = { class: "px-2 py-1 bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300 text-xs font-medium rounded" };
const _hoisted_51$7 = {
  key: 0,
  class: "flex justify-center mt-6"
};
const _hoisted_52$7 = { class: "flex items-center space-x-1" };
const _hoisted_53$7 = ["disabled"];
const _hoisted_54$7 = ["onClick"];
const _hoisted_55$7 = ["disabled"];
const _hoisted_56$7 = { class: "flex-shrink-0 flex justify-end p-4 sm:p-6 border-t border-gray-200 dark:border-dark-bg-mute bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_57$7 = { class: "p-6" };
const _hoisted_58$7 = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4 flex items-center" };
const _hoisted_59$6 = { class: "text-gray-600 dark:text-gray-300 mb-6" };
const _hoisted_60$6 = { class: "flex gap-3 justify-end" };
const _sfc_main$X = /* @__PURE__ */ defineComponent({
  __name: "TopicManager",
  props: {
    modelValue: { type: Boolean },
    vocabularyUsage: { default: () => ({}) }
  },
  emits: ["update:modelValue", "topic-added", "topic-updated", "topic-deleted"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const modelValueRef = toRef(props, "modelValue");
    const topicCRUD = useTopicCRUD(emit);
    const { builtInTopics } = useBuiltInTopics();
    const topicSearch = useTopicSearch(topicCRUD.customTopics, builtInTopics);
    const topicPagination = useTopicPagination(
      topicSearch.filteredCustomTopics,
      topicSearch.filteredBuiltInTopics,
      topicSearch.searchQuery
    );
    const topicModal = useTopicModal(
      modelValueRef,
      emit,
      topicCRUD.resetForm,
      topicSearch.resetSearch,
      topicPagination.resetPagination,
      topicCRUD.loadCustomTopics
    );
    const {
      customTopics,
      editingTopic,
      topicToDelete,
      newTopic,
      canSaveTopic,
      showDeleteModal,
      saveTopic,
      editTopic,
      cancelEdit,
      confirmDeleteTopic,
      deleteTopic} = topicCRUD;
    const { searchQuery, filteredCustomTopics, filteredBuiltInTopics } = topicSearch;
    const {
      ITEMS_PER_PAGE,
      currentCustomPage,
      currentBuiltInPage,
      totalCustomPages,
      totalBuiltInPages,
      paginatedCustomTopics,
      paginatedBuiltInTopics,
      visibleCustomPages,
      visibleBuiltInPages
    } = topicPagination;
    const { closeDialog } = topicModal;
    const getTopicUsageCount = (key) => {
      return props.vocabularyUsage[key] || 0;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$X, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$U, [
                    createBaseVNode("div", _hoisted_3$S, [
                      createBaseVNode("div", _hoisted_4$Q, [
                        createBaseVNode("h2", _hoisted_5$N, [
                          _cache[16] || (_cache[16] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                          createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.topicManager.title", "Topic Manager")), 1)
                        ])
                      ]),
                      createBaseVNode("button", {
                        onClick: _cache[0] || (_cache[0] = //@ts-ignore
                        (...args) => unref(closeDialog) && unref(closeDialog)(...args)),
                        class: "flex-shrink-0 inline-flex items-center justify-center w-8 h-8 sm:w-9 sm:h-9 rounded-full bg-gray-50 hover:bg-gray-100 text-gray-600 hover:text-gray-800 dark:bg-dark-bg-soft dark:text-white/70 dark:hover:text-white dark:hover:bg-dark-bg-mute transition-all duration-300 hover:scale-110 hover:rotate-90 hover:dark:bg-gray-800"
                      }, _cache[17] || (_cache[17] = [
                        createBaseVNode("svg", {
                          class: "w-5 h-5 sm:w-6 sm:h-6",
                          fill: "none",
                          stroke: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          createBaseVNode("path", {
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            "stroke-width": "2",
                            d: "M6 18L18 6M6 6l12 12"
                          })
                        ], -1)
                      ]))
                    ]),
                    createBaseVNode("div", _hoisted_6$L, [
                      createBaseVNode("div", _hoisted_7$J, [
                        createBaseVNode("div", _hoisted_8$J, [
                          withDirectives(createBaseVNode("input", {
                            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(searchQuery) ? searchQuery.value = $event : null),
                            type: "text",
                            placeholder: unref(t)("vocabulary.topicManager.searchPlaceholder", "Search topics by name..."),
                            class: "w-full px-4 py-2.5 pl-10 border-2 animated-search-border rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white text-sm focus:ring-2 focus:ring-blue-500/50 transition-all duration-300 shadow-sm"
                          }, null, 8, _hoisted_9$I), [
                            [vModelText, unref(searchQuery)]
                          ]),
                          _cache[18] || (_cache[18] = createBaseVNode("div", { class: "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none" }, [
                            createBaseVNode("svg", {
                              class: "w-4 h-4 text-gray-400 dark:text-gray-500",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                              })
                            ])
                          ], -1))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_10$H, [
                        createBaseVNode("div", _hoisted_11$H, [
                          _cache[19] || (_cache[19] = createBaseVNode("span", { class: "w-1 h-3 bg-blue-500 rounded" }, null, -1)),
                          createBaseVNode("h3", _hoisted_12$G, toDisplayString$1(unref(editingTopic) ? unref(t)("vocabulary.topicManager.editTopic", "Edit Topic") : unref(t)("vocabulary.topicManager.addNewTopic", "Add New Topic")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_13$G, [
                          createBaseVNode("div", _hoisted_14$G, [
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(newTopic).vi = $event),
                              type: "text",
                              placeholder: unref(t)("vocabulary.topicManager.vietnameseNamePlaceholder", "Tên tiếng Việt"),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white text-sm focus:ring-1 focus:ring-purple-500 focus:border-transparent transition-all duration-300"
                            }, null, 8, _hoisted_15$B), [
                              [vModelText, unref(newTopic).vi]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_16$A, [
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(newTopic).en = $event),
                              type: "text",
                              placeholder: unref(t)("vocabulary.topicManager.englishNamePlaceholder", "English name"),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white text-sm focus:ring-1 focus:ring-orange-500 focus:border-transparent transition-all duration-300"
                            }, null, 8, _hoisted_17$z), [
                              [vModelText, unref(newTopic).en]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_18$y, [
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(newTopic).ko = $event),
                              type: "text",
                              placeholder: unref(t)("vocabulary.topicManager.koreanNamePlaceholder", "한국어 이름"),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white text-sm focus:ring-1 focus:ring-green-500 focus:border-transparent transition-all duration-300"
                            }, null, 8, _hoisted_19$y), [
                              [vModelText, unref(newTopic).ko]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_20$x, [
                            createBaseVNode("button", {
                              onClick: _cache[5] || (_cache[5] = //@ts-ignore
                              (...args) => unref(saveTopic) && unref(saveTopic)(...args)),
                              disabled: !unref(canSaveTopic),
                              class: "px-4 py-2 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 disabled:from-gray-400 disabled:to-gray-500 text-white text-sm rounded-md transition-all duration-300 disabled:cursor-not-allowed font-medium"
                            }, toDisplayString$1(unref(editingTopic) ? unref(t)("common.update", "Update") : unref(t)("common.add", "Add")), 9, _hoisted_21$x),
                            unref(editingTopic) ? (openBlock(), createElementBlock("button", {
                              key: 0,
                              onClick: _cache[6] || (_cache[6] = //@ts-ignore
                              (...args) => unref(cancelEdit) && unref(cancelEdit)(...args)),
                              class: "px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white text-sm rounded-md transition-all duration-300 font-medium"
                            }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1)) : createCommentVNode("", true)
                          ])
                        ])
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_22$v, [
                      createBaseVNode("div", _hoisted_23$v, [
                        createBaseVNode("h3", _hoisted_24$u, [
                          _cache[20] || (_cache[20] = createBaseVNode("span", { class: "w-1 h-4 bg-indigo-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.topicManager.existingTopics", "Custom Topics")), 1)
                        ]),
                        unref(customTopics).length === 0 ? (openBlock(), createElementBlock("div", _hoisted_25$u, toDisplayString$1(unref(t)("vocabulary.topicManager.noCustomTopics", "No custom topics created yet")), 1)) : (openBlock(), createElementBlock("div", _hoisted_26$s, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(paginatedCustomTopics), (topic, index) => {
                            return openBlock(), createElementBlock("div", {
                              key: topic.key,
                              class: "flex items-center justify-between p-3 sm:p-4 md:p-3 lg:p-4 bg-gray-50 dark:bg-[#0a0a0a] rounded-lg border border-gray-200 dark:border-gray-700 hover:bg-gray-100 dark:hover:bg-gray-800 transition-all duration-300 hover:scale-[1.02] animate-fade-in-up",
                              style: normalizeStyle({ animationDelay: `${0.7 + index * 0.1}s` })
                            }, [
                              createBaseVNode("div", _hoisted_27$r, [
                                createBaseVNode("div", _hoisted_28$q, [
                                  createBaseVNode("span", _hoisted_29$o, toDisplayString$1(topic.key), 1),
                                  createBaseVNode("span", _hoisted_30$n, " (" + toDisplayString$1(getTopicUsageCount(topic.key)) + " " + toDisplayString$1(unref(t)("vocabulary.words", "words")) + ") ", 1)
                                ]),
                                createBaseVNode("div", _hoisted_31$m, [
                                  createBaseVNode("div", null, [
                                    _cache[21] || (_cache[21] = createBaseVNode("span", { class: "font-medium" }, "VI:", -1)),
                                    createTextVNode(" " + toDisplayString$1(topic.vi), 1)
                                  ]),
                                  createBaseVNode("div", null, [
                                    _cache[22] || (_cache[22] = createBaseVNode("span", { class: "font-medium" }, "EN:", -1)),
                                    createTextVNode(" " + toDisplayString$1(topic.en), 1)
                                  ]),
                                  createBaseVNode("div", null, [
                                    _cache[23] || (_cache[23] = createBaseVNode("span", { class: "font-medium" }, "KO:", -1)),
                                    createTextVNode(" " + toDisplayString$1(topic.ko), 1)
                                  ])
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_32$j, [
                                createBaseVNode("button", {
                                  onClick: ($event) => unref(editTopic)(topic),
                                  class: "p-2 text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-200 hover:bg-blue-50 dark:hover:bg-blue-900 rounded-lg transition-all duration-300 hover:scale-110",
                                  title: unref(t)("common.edit", "Edit")
                                }, _cache[24] || (_cache[24] = [
                                  createBaseVNode("svg", {
                                    class: "w-4 h-4",
                                    fill: "none",
                                    stroke: "currentColor",
                                    viewBox: "0 0 24 24"
                                  }, [
                                    createBaseVNode("path", {
                                      "stroke-linecap": "round",
                                      "stroke-linejoin": "round",
                                      "stroke-width": "2",
                                      d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                                    })
                                  ], -1)
                                ]), 8, _hoisted_33$j),
                                createBaseVNode("button", {
                                  onClick: ($event) => unref(confirmDeleteTopic)(topic),
                                  disabled: getTopicUsageCount(topic.key) > 0,
                                  class: "p-2 text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-200 hover:bg-red-50 dark:hover:bg-red-900 rounded-lg transition-all duration-300 hover:scale-110 disabled:text-gray-400 disabled:cursor-not-allowed",
                                  title: getTopicUsageCount(topic.key) > 0 ? unref(t)("vocabulary.topicManager.cannotDeleteInUse", "Cannot delete topic in use") : unref(t)("common.delete", "Delete")
                                }, _cache[25] || (_cache[25] = [
                                  createBaseVNode("svg", {
                                    class: "w-4 h-4",
                                    fill: "none",
                                    stroke: "currentColor",
                                    viewBox: "0 0 24 24"
                                  }, [
                                    createBaseVNode("path", {
                                      "stroke-linecap": "round",
                                      "stroke-linejoin": "round",
                                      "stroke-width": "2",
                                      d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                                    })
                                  ], -1)
                                ]), 8, _hoisted_34$i)
                              ])
                            ], 4);
                          }), 128)),
                          unref(filteredCustomTopics).length > unref(ITEMS_PER_PAGE) ? (openBlock(), createElementBlock("div", _hoisted_35$i, [
                            createBaseVNode("div", _hoisted_36$h, [
                              createBaseVNode("button", {
                                onClick: _cache[7] || (_cache[7] = ($event) => currentCustomPage.value--),
                                disabled: unref(currentCustomPage) === 1,
                                class: "px-3 py-2 rounded-lg bg-gray-100 dark:bg-dark-bg-mute text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-dark-bg-soft disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300"
                              }, " ‹ ", 8, _hoisted_37$g),
                              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(visibleCustomPages), (page) => {
                                return openBlock(), createElementBlock("button", {
                                  key: page,
                                  onClick: ($event) => currentCustomPage.value = page,
                                  class: normalizeClass([
                                    "px-3 py-2 rounded-lg text-sm transition-all duration-300",
                                    unref(currentCustomPage) === page ? "bg-blue-500 text-white shadow-md" : "bg-gray-100 dark:bg-dark-bg-mute text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-dark-bg-soft"
                                  ])
                                }, toDisplayString$1(page), 11, _hoisted_38$g);
                              }), 128)),
                              createBaseVNode("button", {
                                onClick: _cache[8] || (_cache[8] = ($event) => currentCustomPage.value++),
                                disabled: unref(currentCustomPage) === unref(totalCustomPages),
                                class: "px-3 py-2 rounded-lg bg-gray-100 dark:bg-dark-bg-mute text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-dark-bg-soft disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300"
                              }, " › ", 8, _hoisted_39$e)
                            ])
                          ])) : createCommentVNode("", true)
                        ]))
                      ]),
                      createBaseVNode("div", _hoisted_40$e, [
                        createBaseVNode("h3", _hoisted_41$d, [
                          _cache[26] || (_cache[26] = createBaseVNode("span", { class: "w-1 h-4 bg-teal-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.topicManager.builtInTopics", "Built-in Topics")), 1)
                        ]),
                        createBaseVNode("p", _hoisted_42$b, toDisplayString$1(unref(t)("vocabulary.topicManager.builtInTopicsDescription", "These are system-provided topics that cannot be modified")), 1),
                        createBaseVNode("div", _hoisted_43$a, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(paginatedBuiltInTopics), (topic, index) => {
                            return openBlock(), createElementBlock("div", {
                              key: topic.key,
                              class: "flex items-center justify-between p-3 sm:p-4 bg-gray-50 dark:bg-[#0a0a0a] rounded-lg border border-gray-200 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-800 transition-all duration-300 hover:scale-[1.02] animate-fade-in-up",
                              style: normalizeStyle({ animationDelay: `${0.9 + index * 0.05}s` })
                            }, [
                              createBaseVNode("div", _hoisted_44$a, [
                                createBaseVNode("div", _hoisted_45$9, [
                                  createBaseVNode("span", _hoisted_46$9, toDisplayString$1(topic.key), 1),
                                  createBaseVNode("span", _hoisted_47$9, " (" + toDisplayString$1(getTopicUsageCount(topic.key)) + " " + toDisplayString$1(unref(t)("vocabulary.words", "words")) + ") ", 1)
                                ]),
                                createBaseVNode("div", _hoisted_48$9, [
                                  createBaseVNode("div", null, [
                                    _cache[27] || (_cache[27] = createBaseVNode("span", { class: "font-medium" }, "VI:", -1)),
                                    createTextVNode(" " + toDisplayString$1(topic.vi), 1)
                                  ]),
                                  createBaseVNode("div", null, [
                                    _cache[28] || (_cache[28] = createBaseVNode("span", { class: "font-medium" }, "EN:", -1)),
                                    createTextVNode(" " + toDisplayString$1(topic.en), 1)
                                  ]),
                                  createBaseVNode("div", null, [
                                    _cache[29] || (_cache[29] = createBaseVNode("span", { class: "font-medium" }, "KO:", -1)),
                                    createTextVNode(" " + toDisplayString$1(topic.ko), 1)
                                  ])
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_49$8, [
                                createBaseVNode("span", _hoisted_50$8, toDisplayString$1(unref(t)("vocabulary.topicManager.builtIn", "Built-in")), 1)
                              ])
                            ], 4);
                          }), 128))
                        ]),
                        unref(filteredBuiltInTopics).length > unref(ITEMS_PER_PAGE) ? (openBlock(), createElementBlock("div", _hoisted_51$7, [
                          createBaseVNode("div", _hoisted_52$7, [
                            createBaseVNode("button", {
                              onClick: _cache[9] || (_cache[9] = ($event) => currentBuiltInPage.value--),
                              disabled: unref(currentBuiltInPage) === 1,
                              class: "px-3 py-2 rounded-lg bg-gray-100 dark:bg-dark-bg-mute text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-dark-bg-soft disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300"
                            }, " ‹ ", 8, _hoisted_53$7),
                            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(visibleBuiltInPages), (page) => {
                              return openBlock(), createElementBlock("button", {
                                key: page,
                                onClick: ($event) => currentBuiltInPage.value = page,
                                class: normalizeClass([
                                  "px-3 py-2 rounded-lg text-sm transition-all duration-300",
                                  unref(currentBuiltInPage) === page ? "bg-blue-500 text-white shadow-md" : "bg-gray-100 dark:bg-dark-bg-mute text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-dark-bg-soft"
                                ])
                              }, toDisplayString$1(page), 11, _hoisted_54$7);
                            }), 128)),
                            createBaseVNode("button", {
                              onClick: _cache[10] || (_cache[10] = ($event) => currentBuiltInPage.value++),
                              disabled: unref(currentBuiltInPage) === unref(totalBuiltInPages),
                              class: "px-3 py-2 rounded-lg bg-gray-100 dark:bg-dark-bg-mute text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-dark-bg-soft disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300"
                            }, " › ", 8, _hoisted_55$7)
                          ])
                        ])) : createCommentVNode("", true)
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_56$7, [
                      createBaseVNode("button", {
                        onClick: _cache[11] || (_cache[11] = //@ts-ignore
                        (...args) => unref(closeDialog) && unref(closeDialog)(...args)),
                        class: "px-6 py-2.5 sm:px-8 sm:py-3 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium text-sm sm:text-base animate-fade-in-up focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2",
                        style: { "animation-delay": "0.1s" }
                      }, toDisplayString$1(unref(t)("common.finish", "Finish")), 1)
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        }),
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-300 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-200 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            unref(showDeleteModal) ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-[9999] backdrop-blur-sm",
              onClick: _cache[15] || (_cache[15] = withModifiers(($event) => topicToDelete.value = null, ["self"]))
            }, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-300 ease-out",
                "enter-from-class": "opacity-0 scale-95 translate-y-4",
                "enter-to-class": "opacity-100 scale-100 translate-y-0",
                "leave-active-class": "transition-all duration-200 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0",
                "leave-to-class": "opacity-0 scale-95 translate-y-4"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl max-w-md w-full",
                    onClick: _cache[14] || (_cache[14] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("div", _hoisted_57$7, [
                      createBaseVNode("h3", _hoisted_58$7, [
                        _cache[30] || (_cache[30] = createBaseVNode("span", { class: "w-2 h-2 bg-red-500 rounded-full mr-2 animate-pulse" }, null, -1)),
                        createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.topicManager.confirmDeleteTitle", "Confirm Delete")), 1)
                      ]),
                      createBaseVNode("p", _hoisted_59$6, toDisplayString$1(unref(t)("vocabulary.topicManager.confirmDeleteMessage", { topic: unref(topicToDelete)?.vi || unref(topicToDelete)?.en || "this topic" }, `Are you sure you want to delete "${unref(topicToDelete)?.vi || unref(topicToDelete)?.en || "this topic"}"?`)), 1),
                      createBaseVNode("div", _hoisted_60$6, [
                        createBaseVNode("button", {
                          onClick: _cache[12] || (_cache[12] = ($event) => topicToDelete.value = null),
                          class: "px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium"
                        }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                        createBaseVNode("button", {
                          onClick: _cache[13] || (_cache[13] = //@ts-ignore
                          (...args) => unref(deleteTopic) && unref(deleteTopic)(...args)),
                          class: "px-4 py-2 bg-gradient-to-r from-red-600 to-red-700 hover:from-red-700 hover:to-red-800 text-white rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium"
                        }, toDisplayString$1(unref(t)("common.delete", "Delete")), 1)
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const TopicManager = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["__scopeId", "data-v-429bd37b"]]);

const TopicManager$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: TopicManager
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$W = { class: "bg-white/60 dark:bg-[#0a0a0a]/60 backdrop-blur-sm rounded-xl border border-white/20 dark:border-white/10 p-3 sm:p-4 md:p-5" };
const _hoisted_2$T = { class: "flex items-center mb-3 sm:mb-4" };
const _hoisted_3$R = { class: "text-sm sm:text-base font-semibold bg-gradient-to-r from-red-600 to-red-600 dark:from-red-400 dark:to-red-400 bg-clip-text text-transparent" };
const _hoisted_4$P = { class: "flex flex-col space-y-3" };
const _hoisted_5$M = { class: "text-xs sm:text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_6$K = { class: "flex flex-col sm:flex-row gap-2" };
const _hoisted_7$I = {
  key: 0,
  class: "fixed inset-0 z-[9999] flex items-center justify-center p-4",
  "aria-labelledby": "modal-title",
  role: "dialog",
  "aria-modal": "true"
};
const _hoisted_8$I = { class: "relative bg-white dark:bg-[#0a0a0a] rounded-lg shadow-xl w-full max-w-lg mx-auto border border-gray-200 dark:border-dark-bg-mute overflow-hidden p-6" };
const _hoisted_9$H = { class: "sm:flex sm:items-start" };
const _hoisted_10$G = { class: "mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left" };
const _hoisted_11$G = {
  class: "text-lg leading-6 font-medium text-gray-900 dark:text-white",
  id: "modal-title"
};
const _hoisted_12$F = { class: "mt-2" };
const _hoisted_13$F = { class: "text-sm text-gray-500 dark:text-gray-300" };
const _hoisted_14$F = { class: "mt-3 p-3 bg-red-50 dark:bg-red-900/20 rounded-md border border-red-200 dark:border-red-800" };
const _hoisted_15$A = { class: "text-sm text-red-800 dark:text-red-300 font-medium" };
const _hoisted_16$z = { class: "mt-5 sm:mt-4 sm:flex sm:flex-row-reverse" };
const _hoisted_17$y = {
  key: 0,
  class: "fixed inset-0 z-[9999] flex items-center justify-center p-4",
  "aria-labelledby": "clear-local-store-modal-title",
  role: "dialog",
  "aria-modal": "true"
};
const _hoisted_18$x = { class: "relative bg-white dark:bg-[#0a0a0a] rounded-lg shadow-xl w-full max-w-lg mx-auto border border-gray-200 dark:border-dark-bg-mute overflow-hidden p-6" };
const _hoisted_19$x = { class: "sm:flex sm:items-start" };
const _hoisted_20$w = { class: "mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left" };
const _hoisted_21$w = {
  class: "text-lg leading-6 font-medium text-gray-900 dark:text-white",
  id: "clear-local-store-modal-title"
};
const _hoisted_22$u = { class: "mt-2" };
const _hoisted_23$u = { class: "text-sm text-gray-500 dark:text-gray-300" };
const _hoisted_24$t = { class: "text-sm text-orange-600 dark:text-orange-400 mt-2 font-medium" };
const _hoisted_25$t = { class: "mt-3 p-3 bg-orange-50 dark:bg-orange-900/20 rounded-md border border-orange-200 dark:border-orange-800" };
const _hoisted_26$r = { class: "text-sm text-orange-800 dark:text-orange-300 font-medium" };
const _hoisted_27$q = { class: "mt-5 sm:mt-4 sm:flex sm:flex-row-reverse" };
const _sfc_main$W = /* @__PURE__ */ defineComponent({
  __name: "DeleteAllVocabulariesPanel",
  props: {
    totalCount: {},
    autoSaveEnabled: { type: Boolean },
    useGrouping: { type: Boolean }
  },
  emits: ["vocabularies-deleted", "local-store-cleared"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const { t } = useI18n();
    const toast = useToast();
    const vocabularyStore = useVocabularyStore();
    const themeStore = useThemeStore();
    const voiceStore = useVoiceStore();
    const showDeleteAllModal = ref(false);
    const showClearLocalStoreModal = ref(false);
    watch(showDeleteAllModal, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        document.body.classList.remove("modal-open");
      }
    });
    watch(showClearLocalStoreModal, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        document.body.classList.remove("modal-open");
      }
    });
    const confirmDeleteAll = () => {
      try {
        vocabularyStore.clearAllVocabularies();
        showDeleteAllModal.value = false;
        toast.success(
          t("vocabulary.deleteAll.success", "All vocabulary words have been deleted successfully"),
          { timeout: 3e3 }
        );
        emit("vocabularies-deleted");
        console.log("All vocabularies deleted successfully");
      } catch (error) {
        console.error("Error deleting all vocabularies:", error);
        toast.error(
          t("vocabulary.deleteAll.error", "Failed to delete all vocabularies. Please try again."),
          { timeout: 5e3 }
        );
      }
    };
    const confirmClearLocalStore = () => {
      try {
        vocabularyStore.clearAllVocabularies();
        localStorage.clear();
        sessionStorage.clear();
        if ("indexedDB" in window) {
          try {
            indexedDB.deleteDatabase("vocabulary-db");
            indexedDB.deleteDatabase("practice-sessions-db");
            indexedDB.deleteDatabase("user-settings-db");
            console.log("IndexedDB databases deleted");
          } catch (dbError) {
            console.log("IndexedDB not available or error deleting:", dbError);
          }
        }
        document.cookie.split(";").forEach(function(c) {
          document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + (/* @__PURE__ */ new Date()).toUTCString() + ";path=/");
        });
        if ("caches" in window) {
          caches.keys().then(function(names) {
            for (let name of names) {
              caches.delete(name);
            }
          });
        }
        if ("cacheStorage" in window) {
          caches.keys().then(function(names) {
            for (let name of names) {
              caches.delete(name);
            }
          });
        }
        if ("serviceWorker" in navigator) {
          navigator.serviceWorker.getRegistrations().then(function(registrations) {
            for (let registration of registrations) {
              registration.unregister();
            }
          });
        }
        themeStore.setTheme(false);
        const voiceTypes = ["female-sweet", "female-clear", "female-professional", "male-strong", "male-gentle", "male-deep", "korean-female", "korean-male"];
        voiceTypes.forEach((type) => voiceStore.resetVoiceSettings(type));
        const commonKeys = [
          "vocabulary-data",
          "practice-sessions",
          "user-settings",
          "theme",
          "voice-settings",
          "accordion-state",
          "hover-expand-enabled",
          "auto-save-enabled",
          "move-mode-enabled",
          "grouping-enabled",
          "last-save-time",
          "save-status",
          "google-drive-token",
          "google-drive-refresh-token",
          "google-drive-file-id",
          "auto-save-file-path",
          "vocabulary-notes",
          "grammar-rules",
          "user-preferences",
          "app-settings",
          "vocabulary-filters",
          "search-history",
          "recent-searches",
          "favorite-words",
          "learning-progress",
          "daily-targets",
          "study-sessions",
          "vocabulary-categories",
          "topic-groups",
          "date-grouping",
          "pagination-settings",
          "sort-preferences",
          "display-options",
          "accessibility-settings",
          "performance-settings",
          "debug-settings",
          "error-logs",
          "analytics-data",
          "user-activity",
          "session-data",
          "cache-data",
          "temp-data",
          "backup-data",
          "sync-data",
          "offline-data",
          "pending-changes",
          "auto-save-queue",
          "undo-redo-stack",
          "clipboard-data",
          "drag-drop-state",
          "modal-state",
          "tooltip-state",
          "notification-state",
          "loading-state",
          "error-state",
          "success-state",
          "warning-state",
          "info-state"
        ];
        commonKeys.forEach((key) => {
          try {
            localStorage.removeItem(key);
            sessionStorage.removeItem(key);
          } catch (e) {
            console.log(`Error removing key ${key}:`, e);
          }
        });
        let localStorageLength = localStorage.length;
        while (localStorageLength > 0) {
          try {
            const key = localStorage.key(0);
            if (key) {
              localStorage.removeItem(key);
            }
            localStorageLength = localStorage.length;
          } catch (e) {
            console.log("Error removing dynamic localStorage key:", e);
            break;
          }
        }
        let sessionStorageLength = sessionStorage.length;
        while (sessionStorageLength > 0) {
          try {
            const key = sessionStorage.key(0);
            if (key) {
              sessionStorage.removeItem(key);
            }
            sessionStorageLength = sessionStorage.length;
          } catch (e) {
            console.log("Error removing dynamic sessionStorage key:", e);
            break;
          }
        }
        try {
          localStorage.clear();
          sessionStorage.clear();
        } catch (e) {
          console.log("Error in final clear:", e);
        }
        if ("gc" in window) {
          try {
            window.gc();
          } catch (e) {
            console.log("Garbage collection not available");
          }
        }
        showClearLocalStoreModal.value = false;
        toast.success(
          t("vocabulary.deleteAll.clearLocalStoreSuccess", "All local store data has been cleared successfully"),
          { timeout: 3e3 }
        );
        emit("local-store-cleared");
        console.log("Local store data cleared successfully - 100% complete");
        setTimeout(() => {
          const remainingLocalStorage = localStorage.length;
          const remainingSessionStorage = sessionStorage.length;
          if (remainingLocalStorage > 0 || remainingSessionStorage > 0) {
            console.log(`Warning: ${remainingLocalStorage} localStorage items and ${remainingSessionStorage} sessionStorage items remain`);
            try {
              localStorage.clear();
              sessionStorage.clear();
            } catch (e) {
              console.log("Final clear attempt failed:", e);
            }
          }
          console.log("Reloading page to ensure complete reset...");
          window.location.reload();
        }, 1500);
      } catch (error) {
        console.error("Error clearing local store data:", error);
        toast.error(
          t("vocabulary.deleteAll.clearLocalStoreError", "Failed to clear local store data. Please try again."),
          { timeout: 5e3 }
        );
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$W, [
        createBaseVNode("div", _hoisted_2$T, [
          _cache[4] || (_cache[4] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
            createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-red-400 to-red-500 rounded-full mr-2.5" })
          ], -1)),
          createBaseVNode("h3", _hoisted_3$R, toDisplayString$1(unref(t)("vocabulary.deleteAll.title", "Delete All Vocabularies")), 1)
        ]),
        createBaseVNode("div", _hoisted_4$P, [
          createBaseVNode("p", _hoisted_5$M, toDisplayString$1(unref(t)("vocabulary.deleteAll.description", "This will permanently delete all vocabulary words from your collection. This action cannot be undone.")), 1),
          createBaseVNode("div", _hoisted_6$K, [
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => showDeleteAllModal.value = true),
              class: "inline-flex items-center justify-center px-2 py-1.5 sm:px-3 sm:py-2 text-xs font-medium text-white bg-red-600 hover:bg-red-700 dark:bg-red-500 dark:hover:bg-red-600 rounded-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 dark:focus:ring-offset-[#0a0a0a] w-fit"
            }, [
              _cache[5] || (_cache[5] = createBaseVNode("svg", {
                class: "w-3 h-3 mr-1.5",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                })
              ], -1)),
              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.deleteAll.button", "Delete All Vocabularies")), 1)
            ]),
            createBaseVNode("button", {
              onClick: _cache[1] || (_cache[1] = ($event) => showClearLocalStoreModal.value = true),
              class: "inline-flex items-center justify-center px-2 py-1.5 sm:px-3 sm:py-2 text-xs font-medium text-white bg-orange-600 hover:bg-orange-700 dark:bg-orange-500 dark:hover:bg-orange-600 rounded-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-offset-2 dark:focus:ring-offset-[#0a0a0a] w-fit"
            }, [
              _cache[6] || (_cache[6] = createBaseVNode("svg", {
                class: "w-3 h-3 mr-1.5",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                })
              ], -1)),
              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.deleteAll.clearLocalStore", "Clear Local Store")), 1)
            ])
          ])
        ]),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          showDeleteAllModal.value ? (openBlock(), createElementBlock("div", _hoisted_7$I, [
            _cache[8] || (_cache[8] = createBaseVNode("div", {
              class: "fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm transition-opacity",
              "aria-hidden": "true"
            }, null, -1)),
            createBaseVNode("div", _hoisted_8$I, [
              createBaseVNode("div", _hoisted_9$H, [
                _cache[7] || (_cache[7] = createBaseVNode("div", { class: "mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100 dark:bg-red-900/30 sm:mx-0 sm:h-10 sm:w-10" }, [
                  createBaseVNode("svg", {
                    class: "h-6 w-6 text-red-600 dark:text-red-400",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    "stroke-width": "1.5",
                    stroke: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      d: "M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z"
                    })
                  ])
                ], -1)),
                createBaseVNode("div", _hoisted_10$G, [
                  createBaseVNode("h3", _hoisted_11$G, toDisplayString$1(unref(t)("vocabulary.deleteAll.confirmTitle", "Delete All Vocabularies")), 1),
                  createBaseVNode("div", _hoisted_12$F, [
                    createBaseVNode("p", _hoisted_13$F, toDisplayString$1(unref(t)("vocabulary.deleteAll.confirmMessage", "Are you sure you want to delete all vocabulary words? This action cannot be undone and will permanently remove all your saved words.")), 1),
                    createBaseVNode("div", _hoisted_14$F, [
                      createBaseVNode("p", _hoisted_15$A, toDisplayString$1(unref(t)("vocabulary.deleteAll.warningCount", { count: _ctx.totalCount }, `You are about to delete ${_ctx.totalCount} vocabulary words.`)), 1)
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_16$z, [
                createBaseVNode("button", {
                  onClick: confirmDeleteAll,
                  type: "button",
                  class: "w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-red-600 text-base font-medium text-white hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 dark:focus:ring-offset-[#0a0a0a] sm:ml-3 sm:w-auto sm:text-sm transition-colors duration-200"
                }, toDisplayString$1(unref(t)("vocabulary.deleteAll.confirm", "Delete All")), 1),
                createBaseVNode("button", {
                  onClick: _cache[2] || (_cache[2] = ($event) => showDeleteAllModal.value = false),
                  type: "button",
                  class: "mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 dark:border-dark-bg-mute shadow-sm px-4 py-2 bg-white dark:bg-dark-bg-soft text-base font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-dark-bg-mute focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:focus:ring-offset-[#0a0a0a] sm:mt-0 sm:w-auto sm:text-sm transition-colors duration-200"
                }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1)
              ])
            ])
          ])) : createCommentVNode("", true)
        ])),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          showClearLocalStoreModal.value ? (openBlock(), createElementBlock("div", _hoisted_17$y, [
            _cache[10] || (_cache[10] = createBaseVNode("div", {
              class: "fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm transition-opacity",
              "aria-hidden": "true"
            }, null, -1)),
            createBaseVNode("div", _hoisted_18$x, [
              createBaseVNode("div", _hoisted_19$x, [
                _cache[9] || (_cache[9] = createBaseVNode("div", { class: "mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-orange-100 dark:bg-orange-900/30 sm:mx-0 sm:h-10 sm:w-10" }, [
                  createBaseVNode("svg", {
                    class: "h-6 w-6 text-orange-600 dark:text-orange-400",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    "stroke-width": "1.5",
                    stroke: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      d: "M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z"
                    })
                  ])
                ], -1)),
                createBaseVNode("div", _hoisted_20$w, [
                  createBaseVNode("h3", _hoisted_21$w, toDisplayString$1(unref(t)("vocabulary.deleteAll.clearLocalStoreTitle", "Clear Local Store Data")), 1),
                  createBaseVNode("div", _hoisted_22$u, [
                    createBaseVNode("p", _hoisted_23$u, toDisplayString$1(unref(t)("vocabulary.deleteAll.clearLocalStoreMessage", "This will clear all data stored in your browser's local storage, including vocabulary words, practice sessions, and user preferences. This action cannot be undone.")), 1),
                    createBaseVNode("p", _hoisted_24$t, toDisplayString$1(unref(t)("vocabulary.deleteAll.pageReloadNotice", "Note: Page will automatically reload after clearing to ensure complete reset.")), 1),
                    createBaseVNode("div", _hoisted_25$t, [
                      createBaseVNode("p", _hoisted_26$r, toDisplayString$1(unref(t)("vocabulary.deleteAll.clearLocalStoreWarning", "Warning: This will remove all locally stored data and reset the application to its initial state.")), 1)
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_27$q, [
                createBaseVNode("button", {
                  onClick: confirmClearLocalStore,
                  type: "button",
                  class: "w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-orange-600 text-base font-medium text-white hover:bg-orange-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500 dark:focus:ring-offset-[#0a0a0a] sm:ml-3 sm:w-auto sm:text-sm transition-colors duration-200"
                }, toDisplayString$1(unref(t)("vocabulary.deleteAll.clearLocalStoreConfirm", "Clear All Data")), 1),
                createBaseVNode("button", {
                  onClick: _cache[3] || (_cache[3] = ($event) => showClearLocalStoreModal.value = false),
                  type: "button",
                  class: "mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 dark:border-dark-bg-mute shadow-sm px-4 py-2 bg-white dark:bg-dark-bg-soft text-base font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-dark-bg-mute focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:focus:ring-offset-[#0a0a0a] sm:mt-0 sm:w-auto sm:text-sm transition-colors duration-200"
                }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1)
              ])
            ])
          ])) : createCommentVNode("", true)
        ]))
      ]);
    };
  }
});

const DeleteAllVocabulariesPanel = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$W
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$V = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$S = { class: "w-full max-h-[90vh] flex flex-col max-w-full sm:max-w-lg md:max-w-2xl lg:max-w-4xl" };
const _hoisted_3$Q = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$O = { class: "flex items-center justify-between" };
const _hoisted_5$L = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$J = { class: "px-6 py-4 flex-1 overflow-y-auto min-h-0" };
const _hoisted_7$H = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_8$H = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_9$G = { value: "" };
const _hoisted_10$F = ["value"];
const _hoisted_11$F = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_12$E = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_13$E = { value: "" };
const _hoisted_14$E = { value: "multiple-choice" };
const _hoisted_15$z = { value: "fill-blank" };
const _hoisted_16$y = { value: "true-false" };
const _hoisted_17$x = { value: "short-answer" };
const _hoisted_18$w = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_19$w = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_20$v = ["placeholder"];
const _hoisted_21$v = {
  key: 0,
  class: "space-y-4 animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_22$t = { class: "flex items-center justify-between" };
const _hoisted_23$t = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 flex items-center" };
const _hoisted_24$s = { class: "flex items-center" };
const _hoisted_25$s = ["id", "value"];
const _hoisted_26$q = ["for"];
const _hoisted_27$p = ["onUpdate:modelValue", "placeholder"];
const _hoisted_28$p = ["onClick"];
const _hoisted_29$n = {
  key: 1,
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_30$m = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_31$l = ["value"];
const _hoisted_32$i = {
  key: 1,
  class: "mt-2 flex space-x-4"
};
const _hoisted_33$i = { class: "flex items-center" };
const _hoisted_34$h = { class: "ml-2 text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_35$h = { class: "flex items-center" };
const _hoisted_36$g = { class: "ml-2 text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_37$f = ["placeholder"];
const _hoisted_38$f = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_39$d = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_40$d = { value: "" };
const _hoisted_41$c = { value: "easy" };
const _hoisted_42$a = { value: "medium" };
const _hoisted_43$9 = { value: "hard" };
const _hoisted_44$9 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_45$8 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_46$8 = ["placeholder"];
const _hoisted_47$8 = { class: "flex items-center justify-end space-x-3 p-6 border-t border-gray-200 dark:border-gray-700 bg-gradient-to-r from-gray-50 to-white dark:from-[#0a0a0a] dark:to-[#0a0a0a] flex-shrink-0" };
const _hoisted_48$8 = ["disabled"];
const __default__$2 = {};
const _sfc_main$V = /* @__PURE__ */ defineComponent({
  ...__default__$2,
  ...{
    name: "QuestionFormDialog"
  },
  __name: "QuestionFormDialog",
  props: {
    show: { type: Boolean },
    question: {},
    vocabularyList: {}
  },
  emits: ["close", "save"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const formData = ref({
      vocabularyId: "",
      question: "",
      type: "multiple-choice",
      options: void 0,
      correctAnswer: "",
      difficulty: void 0,
      explanation: ""
    });
    const isFormValid = computed(() => {
      if (!formData.value.vocabularyId || !formData.value.question || !formData.value.type) {
        return false;
      }
      if (formData.value.type === "multiple-choice") {
        return formData.value.options?.every((opt) => opt.trim()) && formData.value.correctAnswer !== "" && formData.value.options?.length >= 2;
      }
      return formData.value.correctAnswer !== "";
    });
    const resetForm = () => {
      formData.value = {
        vocabularyId: "",
        question: "",
        type: "multiple-choice",
        options: void 0,
        correctAnswer: "",
        difficulty: void 0,
        explanation: ""
      };
    };
    const loadQuestion = () => {
      if (props.question) {
        formData.value = {
          vocabularyId: props.question.vocabularyId,
          question: props.question.question,
          type: props.question.type,
          options: props.question.options ? [...props.question.options] : ["", "", "", ""],
          correctAnswer: String(props.question.correctAnswer),
          difficulty: props.question.difficulty || "easy",
          explanation: props.question.explanation || ""
        };
      } else {
        resetForm();
      }
    };
    const onTypeChange = () => {
      if (formData.value.type === "multiple-choice") {
        formData.value.options = ["", "", "", ""];
      } else if (formData.value.type === "true-false") {
        formData.value.options = void 0;
        formData.value.correctAnswer = "true";
      } else {
        formData.value.options = void 0;
        formData.value.correctAnswer = "";
      }
    };
    const addOption = () => {
      if (formData.value.options && formData.value.options.length < 6) {
        formData.value.options.push("");
      }
    };
    const removeOption = (index) => {
      if (formData.value.options && formData.value.options.length > 2) {
        formData.value.options.splice(index, 1);
        const currentAnswerIndex = Number(formData.value.correctAnswer);
        if (currentAnswerIndex === index) {
          formData.value.correctAnswer = "";
        } else if (currentAnswerIndex > index) {
          formData.value.correctAnswer = String(currentAnswerIndex - 1);
        }
      }
    };
    const handleSubmit = () => {
      if (!isFormValid.value) return;
      const questionData = {
        vocabularyId: formData.value.vocabularyId,
        question: formData.value.question,
        type: formData.value.type,
        correctAnswer: formData.value.correctAnswer,
        difficulty: formData.value.difficulty,
        explanation: formData.value.explanation,
        options: formData.value.type === "multiple-choice" ? formData.value.options?.filter((opt) => opt.trim()) : void 0
      };
      emit("save", questionData);
    };
    const lockBodyScroll = () => {
      document.body.style.overflow = "hidden";
    };
    const unlockBodyScroll = () => {
      document.body.style.overflow = "";
    };
    watch(() => props.show, (newShow) => {
      if (newShow) {
        loadQuestion();
        lockBodyScroll();
      } else {
        unlockBodyScroll();
      }
    });
    watch(() => props.question, () => {
      if (props.show) {
        loadQuestion();
      }
    });
    onMounted(() => {
      if (props.show) {
        loadQuestion();
        lockBodyScroll();
      }
    });
    onUnmounted(() => {
      unlockBodyScroll();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$V, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$S, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 flex flex-col h-full overflow-hidden transform",
                      onClick: _cache[11] || (_cache[11] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$Q, [
                        createBaseVNode("div", _hoisted_4$O, [
                          createBaseVNode("h2", _hoisted_5$L, [
                            _cache[12] || (_cache[12] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(_ctx.question ? unref(t)("vocabulary.questions.editQuestion", "Edit Question") : unref(t)("vocabulary.questions.addQuestion", "Add New Question")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close")),
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[13] || (_cache[13] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_6$J, [
                        createBaseVNode("form", {
                          onSubmit: withModifiers(handleSubmit, ["prevent"]),
                          class: "space-y-6"
                        }, [
                          createBaseVNode("div", _hoisted_7$H, [
                            createBaseVNode("label", _hoisted_8$H, [
                              _cache[14] || (_cache[14] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.questions.selectVocabulary", "Select Vocabulary Word")) + " ", 1),
                              _cache[15] || (_cache[15] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                            ]),
                            withDirectives(createBaseVNode("select", {
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => formData.value.vocabularyId = $event),
                              required: "",
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 hover:border-blue-400 dark:hover:border-blue-500 transform hover:scale-[1.02]"
                            }, [
                              createBaseVNode("option", _hoisted_9$G, toDisplayString$1(unref(t)("vocabulary.questions.selectVocabularyPlaceholder", "Choose a vocabulary word...")), 1),
                              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.vocabularyList, (vocab) => {
                                return openBlock(), createElementBlock("option", {
                                  key: vocab.id,
                                  value: vocab.id
                                }, toDisplayString$1(vocab.word) + " - " + toDisplayString$1(vocab.meaning), 9, _hoisted_10$F);
                              }), 128))
                            ], 512), [
                              [vModelSelect, formData.value.vocabularyId]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_11$F, [
                            createBaseVNode("label", _hoisted_12$E, [
                              _cache[16] || (_cache[16] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.questions.questionType", "Question Type")) + " ", 1),
                              _cache[17] || (_cache[17] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                            ]),
                            withDirectives(createBaseVNode("select", {
                              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => formData.value.type = $event),
                              required: "",
                              onChange: onTypeChange,
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-300 hover:border-green-400 dark:hover:border-green-500 transform hover:scale-[1.02]"
                            }, [
                              createBaseVNode("option", _hoisted_13$E, toDisplayString$1(unref(t)("vocabulary.questions.selectType", "Select question type...")), 1),
                              createBaseVNode("option", _hoisted_14$E, toDisplayString$1(unref(t)("vocabulary.questions.types.multipleChoice", "Multiple Choice")), 1),
                              createBaseVNode("option", _hoisted_15$z, toDisplayString$1(unref(t)("vocabulary.questions.types.fillBlank", "Fill in the Blank")), 1),
                              createBaseVNode("option", _hoisted_16$y, toDisplayString$1(unref(t)("vocabulary.questions.types.trueFalse", "True/False")), 1),
                              createBaseVNode("option", _hoisted_17$x, toDisplayString$1(unref(t)("vocabulary.questions.types.shortAnswer", "Short Answer")), 1)
                            ], 544), [
                              [vModelSelect, formData.value.type]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_18$w, [
                            createBaseVNode("label", _hoisted_19$w, [
                              _cache[18] || (_cache[18] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.questions.questionText", "Question")) + " ", 1),
                              _cache[19] || (_cache[19] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                            ]),
                            withDirectives(createBaseVNode("textarea", {
                              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => formData.value.question = $event),
                              required: "",
                              rows: "3",
                              placeholder: unref(t)("vocabulary.questions.questionPlaceholder", "Enter your question..."),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-300 hover:border-purple-400 dark:hover:border-purple-500 transform hover:scale-[1.02] resize-none"
                            }, null, 8, _hoisted_20$v), [
                              [vModelText, formData.value.question]
                            ])
                          ]),
                          formData.value.type === "multiple-choice" ? (openBlock(), createElementBlock("div", _hoisted_21$v, [
                            createBaseVNode("div", _hoisted_22$t, [
                              createBaseVNode("label", _hoisted_23$t, [
                                _cache[20] || (_cache[20] = createBaseVNode("span", { class: "w-1 h-4 bg-orange-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.questions.options", "Answer Options")) + " ", 1),
                                _cache[21] || (_cache[21] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              createBaseVNode("button", {
                                type: "button",
                                onClick: addOption,
                                class: "text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 text-sm font-medium transition-all duration-300 hover:scale-105"
                              }, " + " + toDisplayString$1(unref(t)("vocabulary.questions.addOption", "Add Option")), 1)
                            ]),
                            formData.value.options ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(formData.value.options, (option, index) => {
                              return openBlock(), createElementBlock("div", {
                                key: index,
                                class: "flex items-center space-x-3"
                              }, [
                                createBaseVNode("div", _hoisted_24$s, [
                                  withDirectives(createBaseVNode("input", {
                                    id: `option-${index}`,
                                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => formData.value.correctAnswer = $event),
                                    value: index,
                                    type: "radio",
                                    name: "correctAnswer",
                                    class: "w-4 h-4 text-blue-600 focus:ring-blue-500 border-gray-300 dark:border-gray-600"
                                  }, null, 8, _hoisted_25$s), [
                                    [vModelRadio, formData.value.correctAnswer]
                                  ]),
                                  createBaseVNode("label", {
                                    for: `option-${index}`,
                                    class: "ml-2 text-sm text-gray-700 dark:text-gray-300"
                                  }, toDisplayString$1(String.fromCharCode(65 + index)), 9, _hoisted_26$q)
                                ]),
                                withDirectives(createBaseVNode("input", {
                                  "onUpdate:modelValue": ($event) => formData.value.options[index] = $event,
                                  type: "text",
                                  placeholder: `${unref(t)("vocabulary.questions.optionPlaceholder", "Option")} ${String.fromCharCode(65 + index)}`,
                                  class: "flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 hover:border-blue-400 dark:hover:border-blue-500 transform hover:scale-[1.02]"
                                }, null, 8, _hoisted_27$p), [
                                  [vModelText, formData.value.options[index]]
                                ]),
                                formData.value.options && formData.value.options.length > 2 ? (openBlock(), createElementBlock("button", {
                                  key: 0,
                                  type: "button",
                                  onClick: ($event) => removeOption(index),
                                  class: "p-2 text-red-600 dark:text-red-400 hover:bg-red-50/50 dark:hover:bg-red-900/20 rounded-lg transition-all duration-300 hover:scale-110"
                                }, _cache[22] || (_cache[22] = [
                                  createBaseVNode("svg", {
                                    class: "w-4 h-4",
                                    fill: "none",
                                    stroke: "currentColor",
                                    viewBox: "0 0 24 24"
                                  }, [
                                    createBaseVNode("path", {
                                      "stroke-linecap": "round",
                                      "stroke-linejoin": "round",
                                      "stroke-width": "2",
                                      d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                                    })
                                  ], -1)
                                ]), 8, _hoisted_28$p)) : createCommentVNode("", true)
                              ]);
                            }), 128)) : createCommentVNode("", true)
                          ])) : createCommentVNode("", true),
                          formData.value.type && formData.value.type !== "multiple-choice" ? (openBlock(), createElementBlock("div", _hoisted_29$n, [
                            createBaseVNode("label", _hoisted_30$m, [
                              _cache[23] || (_cache[23] = createBaseVNode("span", { class: "w-1 h-4 bg-orange-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.questions.correctAnswer", "Correct Answer")) + " ", 1),
                              _cache[24] || (_cache[24] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                            ]),
                            formData.value.type === "true-false" ? (openBlock(), createElementBlock("input", {
                              key: 0,
                              value: formData.value.correctAnswer === "true" ? unref(t)("vocabulary.questions.true", "True") : unref(t)("vocabulary.questions.false", "False"),
                              type: "text",
                              readonly: "",
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50/50 dark:bg-[#0a0a0a]/50 text-gray-900 dark:text-white"
                            }, null, 8, _hoisted_31$l)) : createCommentVNode("", true),
                            formData.value.type === "true-false" ? (openBlock(), createElementBlock("div", _hoisted_32$i, [
                              createBaseVNode("label", _hoisted_33$i, [
                                withDirectives(createBaseVNode("input", {
                                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => formData.value.correctAnswer = $event),
                                  value: "true",
                                  type: "radio",
                                  name: "trueFalse",
                                  class: "w-4 h-4 text-blue-600 focus:ring-blue-500 border-gray-300 dark:border-gray-600"
                                }, null, 512), [
                                  [vModelRadio, formData.value.correctAnswer]
                                ]),
                                createBaseVNode("span", _hoisted_34$h, toDisplayString$1(unref(t)("vocabulary.questions.true", "True")), 1)
                              ]),
                              createBaseVNode("label", _hoisted_35$h, [
                                withDirectives(createBaseVNode("input", {
                                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => formData.value.correctAnswer = $event),
                                  value: "false",
                                  type: "radio",
                                  name: "trueFalse",
                                  class: "w-4 h-4 text-blue-600 focus:ring-blue-500 border-gray-300 dark:border-gray-600"
                                }, null, 512), [
                                  [vModelRadio, formData.value.correctAnswer]
                                ]),
                                createBaseVNode("span", _hoisted_36$g, toDisplayString$1(unref(t)("vocabulary.questions.false", "False")), 1)
                              ])
                            ])) : withDirectives((openBlock(), createElementBlock("input", {
                              key: 2,
                              "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => formData.value.correctAnswer = $event),
                              type: "text",
                              required: "",
                              placeholder: unref(t)("vocabulary.questions.correctAnswerPlaceholder", "Enter the correct answer..."),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all duration-300 hover:border-orange-400 dark:hover:border-orange-500 transform hover:scale-[1.02]"
                            }, null, 8, _hoisted_37$f)), [
                              [vModelText, formData.value.correctAnswer]
                            ])
                          ])) : createCommentVNode("", true),
                          createBaseVNode("div", _hoisted_38$f, [
                            createBaseVNode("label", _hoisted_39$d, [
                              _cache[25] || (_cache[25] = createBaseVNode("span", { class: "w-1 h-4 bg-yellow-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.questions.difficulty", "Difficulty")), 1)
                            ]),
                            withDirectives(createBaseVNode("select", {
                              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => formData.value.difficulty = $event),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent transition-all duration-300 hover:border-yellow-400 dark:hover:border-yellow-500 transform hover:scale-[1.02]"
                            }, [
                              createBaseVNode("option", _hoisted_40$d, toDisplayString$1(unref(t)("vocabulary.questions.selectDifficulty", "Select difficulty...")), 1),
                              createBaseVNode("option", _hoisted_41$c, toDisplayString$1(unref(t)("common.easy", "Easy")), 1),
                              createBaseVNode("option", _hoisted_42$a, toDisplayString$1(unref(t)("vocabulary.questions.difficulty.medium", "Medium")), 1),
                              createBaseVNode("option", _hoisted_43$9, toDisplayString$1(unref(t)("common.difficult", "Difficult")), 1)
                            ], 512), [
                              [vModelSelect, formData.value.difficulty]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_44$9, [
                            createBaseVNode("label", _hoisted_45$8, [
                              _cache[26] || (_cache[26] = createBaseVNode("span", { class: "w-1 h-4 bg-cyan-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.questions.explanation", "Explanation")), 1)
                            ]),
                            withDirectives(createBaseVNode("textarea", {
                              "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => formData.value.explanation = $event),
                              rows: "3",
                              placeholder: unref(t)("vocabulary.questions.explanationPlaceholder", "Optional explanation for the answer..."),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent transition-all duration-300 hover:border-cyan-400 dark:hover:border-cyan-500 transform hover:scale-[1.02] resize-none"
                            }, null, 8, _hoisted_46$8), [
                              [vModelText, formData.value.explanation]
                            ])
                          ])
                        ], 32)
                      ]),
                      createBaseVNode("div", _hoisted_47$8, [
                        createBaseVNode("button", {
                          onClick: _cache[10] || (_cache[10] = ($event) => _ctx.$emit("close")),
                          type: "button",
                          class: "px-4 py-2 text-gray-700 dark:text-gray-300 bg-white/50 dark:bg-[#0a0a0a]/50 hover:bg-gray-100/50 dark:hover:bg-[#0a0a0a]/70 border border-gray-300 dark:border-gray-600 rounded-lg font-medium transition-all duration-300 hover:scale-105 shadow-md hover:shadow-lg"
                        }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                        createBaseVNode("button", {
                          onClick: handleSubmit,
                          type: "submit",
                          disabled: !isFormValid.value,
                          class: "px-6 py-2 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 disabled:from-gray-400 disabled:to-gray-500 disabled:cursor-not-allowed text-white rounded-lg font-medium transition-all duration-300 hover:scale-105 shadow-lg hover:shadow-xl"
                        }, toDisplayString$1(_ctx.question ? unref(t)("common.update", "Update") : unref(t)("common.add", "Add")), 9, _hoisted_48$8)
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const QuestionFormDialog = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$V
}, Symbol.toStringTag, { value: 'Module' }));

const ExampleFormDialog$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ExampleFormDialog),true              ?void 0:void 0));
function useTopicGroupAccordion(props) {
  const { t } = useI18n();
  useVocabularyStore();
  const audioSystem = useAudioSystem();
  const { getTopicName } = useTopicName();
  const expandedGroups = ref({});
  const expandedVocabExamples = ref({});
  const examplePages = ref({});
  const examplesPerPage = ref(3);
  const currentPage = ref(1);
  const topicsPerPage = ref(3);
  const topicVocabPages = ref({});
  const topicVocabPerPage = ref(3);
  const playVocabularyAudio = (word) => audioSystem.playVocabularySound(word, "en");
  const playExampleAudio = (text) => audioSystem.playVocabularySound(text, "en");
  const loadExpandedState = () => {
    try {
      const saved = localStorage.getItem("vocabulary-examples-expanded-topics");
      if (saved) expandedGroups.value = { ...JSON.parse(saved) };
    } catch (error) {
      console.error("Error loading expanded state:", error);
    }
  };
  const saveExpandedState = () => {
    try {
      localStorage.setItem("vocabulary-examples-expanded-topics", JSON.stringify(expandedGroups.value));
    } catch (error) {
      console.error("Error saving expanded state:", error);
    }
  };
  const loadExpandedVocabExamplesState = () => {
    try {
      const saved = localStorage.getItem("vocabulary-examples-expanded-vocab-grouped");
      if (saved) expandedVocabExamples.value = { ...JSON.parse(saved) };
    } catch (error) {
      console.error("Error loading expanded vocabulary examples state:", error);
    }
  };
  const saveExpandedVocabExamplesState = () => {
    try {
      localStorage.setItem("vocabulary-examples-expanded-vocab-grouped", JSON.stringify(expandedVocabExamples.value));
    } catch (error) {
      console.error("Error saving expanded vocab examples state:", error);
    }
  };
  const loadExamplePagesState = () => {
    try {
      const saved = localStorage.getItem("vocabulary-examples-pages-grouped");
      if (saved) examplePages.value = { ...JSON.parse(saved) };
    } catch (error) {
      console.error("Error loading example pages state:", error);
    }
  };
  const saveExamplePagesState = () => {
    try {
      localStorage.setItem("vocabulary-examples-pages-grouped", JSON.stringify(examplePages.value));
    } catch (error) {
      console.error("Error saving example pages state:", error);
    }
  };
  const loadTopicVocabPagesState = () => {
    try {
      const saved = localStorage.getItem("vocabulary-topic-vocab-pages");
      if (saved) topicVocabPages.value = { ...JSON.parse(saved) };
    } catch (error) {
      console.error("Error loading topic vocab pages state:", error);
    }
  };
  const saveTopicVocabPagesState = () => {
    try {
      localStorage.setItem("vocabulary-topic-vocab-pages", JSON.stringify(topicVocabPages.value));
    } catch (error) {
      console.error("Error saving topic vocab pages state:", error);
    }
  };
  const allGroupedVocabulary = computed(() => {
    const groups = {};
    props.vocabularyList.forEach((vocab) => {
      const topicKey = vocab.category || "uncategorized";
      if (!groups[topicKey]) groups[topicKey] = [];
      groups[topicKey].push(vocab);
    });
    Object.keys(groups).forEach((key) => {
      groups[key].sort((a, b) => a.word.localeCompare(b.word));
    });
    return groups;
  });
  const groupedVocabulary = computed(() => {
    const allGroups = allGroupedVocabulary.value;
    const topicKeys = Object.keys(allGroups).sort((a, b) => a.localeCompare(b));
    const start = (currentPage.value - 1) * topicsPerPage.value;
    const end = start + topicsPerPage.value;
    const paginatedTopics = topicKeys.slice(start, end);
    const paginatedGroups = {};
    paginatedTopics.forEach((topicKey) => {
      paginatedGroups[topicKey] = allGroups[topicKey];
    });
    return paginatedGroups;
  });
  const paginationInfo = computed(() => {
    const totalTopics = Object.keys(allGroupedVocabulary.value).length;
    const totalPages = Math.ceil(totalTopics / topicsPerPage.value);
    const startIndex = (currentPage.value - 1) * topicsPerPage.value + 1;
    const endIndex = Math.min(currentPage.value * topicsPerPage.value, totalTopics);
    return {
      totalTopics,
      totalPages,
      currentPage: currentPage.value,
      startIndex,
      endIndex,
      hasNext: currentPage.value < totalPages,
      hasPrevious: currentPage.value > 1
    };
  });
  const visiblePages = computed(() => {
    const pages = [];
    const maxVisible = 5;
    const totalP = paginationInfo.value.totalPages;
    if (totalP <= maxVisible) {
      for (let i = 1; i <= totalP; i++) pages.push(i);
    } else {
      const start = Math.max(1, currentPage.value - Math.floor(maxVisible / 2));
      const end = Math.min(totalP, start + maxVisible - 1);
      for (let i = start; i <= end; i++) pages.push(i);
    }
    return pages;
  });
  const getVocabExamples = (vocabId) => props.examples.filter((e) => e.vocabularyId === vocabId);
  const getPaginatedVocabExamples = (vocabId) => {
    const allExamples = getVocabExamples(vocabId);
    const totalPages = Math.max(1, Math.ceil(allExamples.length / examplesPerPage.value));
    const current = Math.min(examplePages.value[vocabId] || 1, totalPages);
    const start = (current - 1) * examplesPerPage.value;
    return allExamples.slice(start, start + examplesPerPage.value);
  };
  const getPaginatedTopicVocabs = (topicKey) => {
    const group = allGroupedVocabulary.value[topicKey] || [];
    const current = topicVocabPages.value[topicKey] || 1;
    const start = (current - 1) * topicVocabPerPage.value;
    return group.slice(start, start + topicVocabPerPage.value);
  };
  const getTopicVocabPagesCount = (topicKey) => {
    const total = (allGroupedVocabulary.value[topicKey] || []).length;
    return Math.max(1, Math.ceil(total / topicVocabPerPage.value));
  };
  const getTopicVocabPaginationInfo = (topicKey) => {
    const totalVocab = (allGroupedVocabulary.value[topicKey] || []).length;
    const totalPages = Math.max(1, Math.ceil(totalVocab / topicVocabPerPage.value));
    const current = Math.min(topicVocabPages.value[topicKey] || 1, totalPages);
    const start = totalVocab === 0 ? 0 : (current - 1) * topicVocabPerPage.value + 1;
    const end = Math.min(current * topicVocabPerPage.value, totalVocab);
    return { totalVocab, totalPages, currentPage: current, start, end, hasNext: current < totalPages, hasPrevious: current > 1 };
  };
  const getVocabExamplePages = (vocabId) => Math.ceil(getVocabExamples(vocabId).length / examplesPerPage.value);
  const getExamplePaginationInfo = (vocabId) => {
    const totalExamples = getVocabExamples(vocabId).length;
    const totalPages = getVocabExamplePages(vocabId);
    const safeTotalPages = Math.max(1, totalPages);
    const current = Math.min(examplePages.value[vocabId] || 1, safeTotalPages);
    const start = (current - 1) * examplesPerPage.value + 1;
    const end = Math.min(current * examplesPerPage.value, totalExamples);
    return { totalExamples, totalPages, currentPage: current, start, end, hasNext: current < totalPages, hasPrevious: current > 1 };
  };
  const getVocabExampleCount = (vocabId) => props.examples.filter((e) => e.vocabularyId === vocabId).length;
  const getTotalExamplesForTopic = (group) => group.reduce((total, vocab) => total + getVocabExampleCount(vocab.id), 0);
  const getTopicVisiblePages = (topicKey) => {
    const pages = [];
    const maxVisible = 5;
    const totalP = getTopicVocabPagesCount(topicKey);
    const current = topicVocabPages.value[topicKey] || 1;
    if (totalP <= maxVisible) {
      for (let i = 1; i <= totalP; i++) pages.push(i);
    } else {
      const start = Math.max(1, current - Math.floor(maxVisible / 2));
      const end = Math.min(totalP, start + maxVisible - 1);
      for (let i = start; i <= end; i++) pages.push(i);
    }
    return pages;
  };
  const goToTopicVocabPage = (topicKey, page) => {
    const totalPages = getTopicVocabPagesCount(topicKey);
    if (page >= 1 && page <= totalPages) {
      topicVocabPages.value[topicKey] = page;
      saveTopicVocabPagesState();
    }
  };
  const previousTopicVocabPage = (topicKey) => {
    const current = topicVocabPages.value[topicKey] || 1;
    if (current > 1) goToTopicVocabPage(topicKey, current - 1);
  };
  const nextTopicVocabPage = (topicKey) => {
    const current = topicVocabPages.value[topicKey] || 1;
    const totalPages = getTopicVocabPagesCount(topicKey);
    if (current < totalPages) goToTopicVocabPage(topicKey, current + 1);
  };
  const goToExamplePage = (vocabId, page) => {
    const totalPages = getVocabExamplePages(vocabId);
    if (page >= 1 && page <= totalPages) {
      examplePages.value[vocabId] = page;
      saveExamplePagesState();
    }
  };
  const previousExamplePage = (vocabId) => {
    const current = examplePages.value[vocabId] || 1;
    if (current > 1) goToExamplePage(vocabId, current - 1);
  };
  const nextExamplePage = (vocabId) => {
    const current = examplePages.value[vocabId] || 1;
    const totalPages = getVocabExamplePages(vocabId);
    if (current < totalPages) goToExamplePage(vocabId, current + 1);
  };
  const goToPage = (page) => {
    if (page >= 1 && page <= paginationInfo.value.totalPages) currentPage.value = page;
  };
  const previousPage = () => {
    if (paginationInfo.value.hasPrevious) currentPage.value--;
  };
  const nextPage = () => {
    if (paginationInfo.value.hasNext) currentPage.value++;
  };
  const toggleGroup = (topicKey) => {
    expandedGroups.value[topicKey] = !expandedGroups.value[topicKey];
    saveExpandedState();
  };
  const toggleVocabExamples = (vocabId) => {
    expandedVocabExamples.value[vocabId] = !expandedVocabExamples.value[vocabId];
    saveExpandedVocabExamplesState();
  };
  const getTypeLabel = (type) => {
    const labels = {
      "sentence": t("vocabulary.examples.types.sentence", "Sentence"),
      "dialogue": t("vocabulary.examples.types.dialogue", "Dialogue"),
      "phrase": t("vocabulary.examples.types.phrase", "Phrase"),
      "context": t("vocabulary.examples.types.context", "Context")
    };
    return labels[type] || type;
  };
  const getTypeColorClass = (type) => {
    const classes = {
      "sentence": "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300",
      "dialogue": "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300",
      "phrase": "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300",
      "context": "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-300"
    };
    return classes[type] || "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300";
  };
  const getDifficultyLabel = (difficulty) => {
    const labels = {
      "easy": t("common.easy", "Easy"),
      "medium": t("vocabulary.examples.difficulty.medium", "Medium"),
      "hard": t("common.difficult", "Difficult")
    };
    return labels[difficulty] || difficulty;
  };
  const getDifficultyColorClass = (difficulty) => {
    const classes = {
      "easy": "text-green-600 dark:text-green-400",
      "medium": "text-yellow-600 dark:text-yellow-400",
      "hard": "text-red-600 dark:text-red-400"
    };
    return classes[difficulty] || "text-gray-600 dark:text-gray-400";
  };
  const enter = (el) => {
    const element = el;
    element.style.height = "0";
    element.style.overflow = "hidden";
  };
  const afterEnter = (el) => {
    const element = el;
    element.style.height = "auto";
    element.style.overflow = "visible";
  };
  const leave = (el) => {
    const element = el;
    element.style.height = element.scrollHeight + "px";
    element.style.overflow = "hidden";
    element.offsetHeight;
    element.style.height = "0";
  };
  const afterLeave = (el) => {
    const element = el;
    element.style.height = "auto";
    element.style.overflow = "visible";
  };
  const vocabExamplesEnter = (el) => {
    const element = el;
    element.style.height = "0";
    element.style.overflow = "hidden";
  };
  const vocabExamplesAfterEnter = (el) => {
    const element = el;
    element.style.height = "auto";
    element.style.overflow = "visible";
  };
  const vocabExamplesLeave = (el) => {
    const element = el;
    element.style.height = element.scrollHeight + "px";
    element.style.overflow = "hidden";
    element.offsetHeight;
    element.style.height = "0";
  };
  const vocabExamplesAfterLeave = (el) => {
    const element = el;
    element.style.height = "auto";
    element.style.overflow = "visible";
  };
  const deleteExample = (example, emit) => {
    emit("delete-example", example);
  };
  const initializeExpandedVocabExamplesState = () => {
    let examplesChanged = false, pagesChanged = false;
    Object.values(groupedVocabulary.value).forEach((group) => {
      group.forEach((vocab) => {
        if (expandedVocabExamples.value[vocab.id] === void 0) {
          expandedVocabExamples.value[vocab.id] = true;
          examplesChanged = true;
        }
        if (examplePages.value[vocab.id] === void 0) {
          examplePages.value[vocab.id] = 1;
          pagesChanged = true;
        }
      });
    });
    if (examplesChanged) saveExpandedVocabExamplesState();
    if (pagesChanged) saveExamplePagesState();
  };
  const initializeTopicVocabPagesState = () => {
    let changed = false;
    Object.keys(groupedVocabulary.value).forEach((topicKey) => {
      if (topicVocabPages.value[topicKey] === void 0) {
        topicVocabPages.value[topicKey] = 1;
        changed = true;
      }
    });
    if (changed) saveTopicVocabPagesState();
  };
  const initializeExpandedState = () => {
    const topicKeys = Object.keys(groupedVocabulary.value);
    let changed = false;
    topicKeys.forEach((key) => {
      if (expandedGroups.value[key] === void 0) {
        expandedGroups.value[key] = true;
        changed = true;
      }
    });
    if (changed) saveExpandedState();
  };
  const cleanupOldTopicStates = () => {
    try {
      const currentTopicKeys = new Set(Object.keys(allGroupedVocabulary.value));
      const expandedKeys = Object.keys(expandedGroups.value);
      let expandedChanged = false;
      expandedKeys.forEach((topicKey) => {
        if (!currentTopicKeys.has(topicKey)) {
          delete expandedGroups.value[topicKey];
          expandedChanged = true;
        }
      });
      const topicPageKeys = Object.keys(topicVocabPages.value);
      let topicPagesChanged = false;
      topicPageKeys.forEach((topicKey) => {
        if (!currentTopicKeys.has(topicKey)) {
          delete topicVocabPages.value[topicKey];
          topicPagesChanged = true;
        }
      });
      Object.keys(allGroupedVocabulary.value).forEach((topicKey) => {
        const totalPages = getTopicVocabPagesCount(topicKey);
        const current = topicVocabPages.value[topicKey] || 1;
        if (current > totalPages) {
          topicVocabPages.value[topicKey] = totalPages;
          topicPagesChanged = true;
        }
      });
      if (expandedChanged) saveExpandedState();
      if (topicPagesChanged) saveTopicVocabPagesState();
    } catch (error) {
      console.error("Error cleaning up old topic states:", error);
    }
  };
  const cleanupOldVocabularyStates = () => {
    try {
      const currentVocabIds = new Set(props.vocabularyList.map((v) => v.id));
      const expandedKeys = Object.keys(expandedVocabExamples.value);
      let expandedChanged = false;
      expandedKeys.forEach((vocabId) => {
        if (!currentVocabIds.has(vocabId)) {
          delete expandedVocabExamples.value[vocabId];
          expandedChanged = true;
        }
      });
      const pagesKeys = Object.keys(examplePages.value);
      let pagesChanged = false;
      pagesKeys.forEach((vocabId) => {
        if (!currentVocabIds.has(vocabId)) {
          delete examplePages.value[vocabId];
          pagesChanged = true;
        }
      });
      if (expandedChanged) saveExpandedVocabExamplesState();
      if (pagesChanged) saveExamplePagesState();
    } catch (error) {
      console.error("Error cleaning up old vocabulary states:", error);
    }
  };
  watch(() => groupedVocabulary.value, () => {
    initializeExpandedState();
    initializeExpandedVocabExamplesState();
    initializeTopicVocabPagesState();
  });
  watch(() => allGroupedVocabulary.value, () => cleanupOldTopicStates(), { deep: true });
  watch(() => props.vocabularyList, () => cleanupOldVocabularyStates(), { deep: true });
  watch(() => expandedGroups.value, () => saveExpandedState(), { deep: true });
  watch(() => expandedVocabExamples.value, () => saveExpandedVocabExamplesState(), { deep: true });
  watch(() => examplePages.value, () => saveExamplePagesState(), { deep: true });
  watch(() => topicVocabPages.value, () => saveTopicVocabPagesState(), { deep: true });
  onMounted(() => {
    loadExpandedState();
    loadExpandedVocabExamplesState();
    loadExamplePagesState();
    loadTopicVocabPagesState();
    initializeExpandedState();
    initializeExpandedVocabExamplesState();
    initializeTopicVocabPagesState();
    setTimeout(() => {
      cleanupOldTopicStates();
      cleanupOldVocabularyStates();
    }, 100);
  });
  return {
    // External dependencies
    ExampleFormDialog: ExampleFormDialog$1,
    getTopicName,
    t,
    // State
    expandedGroups,
    expandedVocabExamples,
    examplePages,
    examplesPerPage,
    currentPage,
    topicsPerPage,
    topicVocabPages,
    topicVocabPerPage,
    // Computed
    allGroupedVocabulary,
    groupedVocabulary,
    paginationInfo,
    visiblePages,
    // Audio
    playVocabularyAudio,
    playExampleAudio,
    // Data helpers
    getVocabExamples,
    getPaginatedVocabExamples,
    getPaginatedTopicVocabs,
    getTopicVocabPagesCount,
    getTopicVocabPaginationInfo,
    getVocabExamplePages,
    getExamplePaginationInfo,
    getVocabExampleCount,
    getTotalExamplesForTopic,
    getTopicVisiblePages,
    // Navigation
    goToTopicVocabPage,
    previousTopicVocabPage,
    nextTopicVocabPage,
    goToExamplePage,
    previousExamplePage,
    nextExamplePage,
    goToPage,
    previousPage,
    nextPage,
    // Toggle
    toggleGroup,
    toggleVocabExamples,
    // Styling
    getTypeLabel,
    getTypeColorClass,
    getDifficultyLabel,
    getDifficultyColorClass,
    // Animation
    enter,
    afterEnter,
    leave,
    afterLeave,
    vocabExamplesEnter,
    vocabExamplesAfterEnter,
    vocabExamplesLeave,
    vocabExamplesAfterLeave,
    // Actions
    deleteExample
  };
}

const _hoisted_1$U = { class: "space-y-4" };
const _hoisted_2$R = ["onClick"];
const _hoisted_3$P = { class: "flex items-center space-x-3" };
const _hoisted_4$N = { class: "text-lg font-bold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent" };
const _hoisted_5$K = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_6$I = { class: "flex items-center space-x-2" };
const _hoisted_7$G = { class: "text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_8$G = {
  key: 0,
  class: "accordion-content border-t border-gray-200/50 dark:border-gray-700/50"
};
const _hoisted_9$F = { class: "p-4 space-y-4" };
const _hoisted_10$E = ["onClick"];
const _hoisted_11$E = { class: "flex items-center space-x-3" };
const _hoisted_12$D = { class: "flex items-center space-x-2" };
const _hoisted_13$D = { class: "text-base font-bold text-gray-900 dark:text-white" };
const _hoisted_14$D = ["onClick", "title"];
const _hoisted_15$y = ["onClick", "title"];
const _hoisted_16$x = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_17$w = { class: "flex items-center space-x-2 mt-1" };
const _hoisted_18$v = { class: "inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800 dark:bg-blue-900/20 dark:text-blue-300" };
const _hoisted_19$v = { class: "text-xs text-gray-500 dark:text-gray-400" };
const _hoisted_20$u = ["onClick"];
const _hoisted_21$u = { class: "text-sm" };
const _hoisted_22$s = {
  key: 0,
  class: "vocab-examples-accordion-content space-y-2"
};
const _hoisted_23$s = {
  key: 0,
  class: "text-center py-3 text-gray-500 dark:text-gray-400"
};
const _hoisted_24$r = { class: "text-xs" };
const _hoisted_25$r = { class: "flex items-start justify-between" };
const _hoisted_26$p = { class: "flex-1" };
const _hoisted_27$o = { class: "flex items-center space-x-2 mb-2" };
const _hoisted_28$o = { class: "mb-2" };
const _hoisted_29$m = { class: "flex items-center justify-between" };
const _hoisted_30$l = { class: "text-gray-900 dark:text-white font-medium text-sm" };
const _hoisted_31$k = ["onClick", "title"];
const _hoisted_32$h = { class: "text-gray-700 dark:text-gray-300 mt-1 text-sm" };
const _hoisted_33$h = {
  key: 0,
  class: "text-gray-600 dark:text-gray-400 text-xs mt-1 italic"
};
const _hoisted_34$g = {
  key: 0,
  class: "flex flex-wrap gap-1"
};
const _hoisted_35$g = { class: "flex items-center gap-1.5 ml-3" };
const _hoisted_36$f = ["onClick"];
const _hoisted_37$e = ["onClick"];
const _hoisted_38$e = {
  key: 1,
  class: "border-t border-white/20 dark:border-white/10 px-3 py-2 mt-3"
};
const _hoisted_39$c = { class: "flex items-center justify-between" };
const _hoisted_40$c = { class: "flex sm:hidden items-center gap-2" };
const _hoisted_41$b = ["onClick", "disabled"];
const _hoisted_42$9 = { class: "text-xs text-slate-600 dark:text-slate-400" };
const _hoisted_43$8 = ["onClick", "disabled"];
const _hoisted_44$8 = { class: "hidden sm:flex items-center gap-2" };
const _hoisted_45$7 = ["onClick", "disabled"];
const _hoisted_46$7 = { class: "flex gap-1" };
const _hoisted_47$7 = ["onClick"];
const _hoisted_48$7 = ["onClick", "disabled"];
const _hoisted_49$7 = { class: "text-xs text-slate-500 dark:text-slate-400" };
const _hoisted_50$7 = {
  key: 0,
  class: "border-t border-white/20 dark:border-white/10 px-3 py-2"
};
const _hoisted_51$6 = { class: "flex items-center justify-between" };
const _hoisted_52$6 = { class: "flex sm:hidden items-center gap-2" };
const _hoisted_53$6 = ["onClick", "disabled"];
const _hoisted_54$6 = { class: "text-xs text-slate-600 dark:text-slate-400" };
const _hoisted_55$6 = ["onClick", "disabled"];
const _hoisted_56$6 = { class: "hidden sm:flex items-center gap-2" };
const _hoisted_57$6 = ["onClick", "disabled"];
const _hoisted_58$6 = { class: "flex gap-1" };
const _hoisted_59$5 = ["onClick"];
const _hoisted_60$5 = ["onClick", "disabled"];
const _hoisted_61$5 = { class: "text-xs text-slate-500 dark:text-slate-400" };
const _hoisted_62$5 = {
  key: 0,
  class: "mt-6 group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-4"
};
const _hoisted_63$3 = { class: "flex items-center justify-between" };
const _hoisted_64$3 = { class: "flex-1 flex justify-between sm:hidden" };
const _hoisted_65$3 = ["disabled"];
const _hoisted_66$3 = ["disabled"];
const _hoisted_67$3 = { class: "hidden sm:flex-1 sm:flex sm:items-center sm:justify-between" };
const _hoisted_68$3 = { class: "text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_69$3 = { class: "relative z-0 inline-flex rounded-md shadow-sm -space-x-px" };
const _hoisted_70$3 = ["disabled"];
const _hoisted_71$3 = { class: "sr-only" };
const _hoisted_72$3 = ["onClick"];
const _hoisted_73$3 = ["disabled"];
const _hoisted_74$3 = { class: "sr-only" };
const __default__$1 = {
  name: "TopicGroupAccordion"
};
const _sfc_main$U = /* @__PURE__ */ defineComponent({
  ...__default__$1,
  props: {
    vocabularyList: {},
    examples: {}
  },
  emits: ["add-example", "edit-example", "delete-example"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const {
      getTopicName,
      t,
      expandedGroups,
      expandedVocabExamples,
      currentPage,
      groupedVocabulary,
      paginationInfo,
      visiblePages,
      playVocabularyAudio,
      playExampleAudio,
      getVocabExamples,
      getPaginatedVocabExamples,
      getPaginatedTopicVocabs,
      getTopicVocabPagesCount,
      getTopicVocabPaginationInfo,
      getVocabExamplePages,
      getExamplePaginationInfo,
      getVocabExampleCount,
      getTotalExamplesForTopic,
      getTopicVisiblePages,
      goToTopicVocabPage,
      previousTopicVocabPage,
      nextTopicVocabPage,
      goToExamplePage,
      previousExamplePage,
      nextExamplePage,
      goToPage,
      previousPage,
      nextPage,
      toggleGroup,
      toggleVocabExamples,
      getTypeLabel,
      getTypeColorClass,
      getDifficultyLabel,
      getDifficultyColorClass,
      enter,
      afterEnter,
      leave,
      afterLeave,
      vocabExamplesEnter,
      vocabExamplesAfterEnter,
      vocabExamplesLeave,
      vocabExamplesAfterLeave,
      deleteExample
    } = useTopicGroupAccordion(props);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$U, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(groupedVocabulary), (group, topicKey) => {
          return openBlock(), createElementBlock("div", {
            key: topicKey,
            class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.002]"
          }, [
            createBaseVNode("div", {
              onClick: ($event) => unref(toggleGroup)(topicKey),
              class: "flex items-center justify-between p-4 cursor-pointer hover:bg-white/20 dark:hover:bg-[#0a0a0a]/20 rounded-t-2xl transition-all duration-300"
            }, [
              createBaseVNode("div", _hoisted_3$P, [
                _cache[4] || (_cache[4] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                  createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full" })
                ], -1)),
                createBaseVNode("div", null, [
                  createBaseVNode("h3", _hoisted_4$N, toDisplayString$1(unref(getTopicName)(topicKey)), 1),
                  createBaseVNode("p", _hoisted_5$K, toDisplayString$1(group.length) + " " + toDisplayString$1(group.length === 1 ? unref(t)("vocabulary.word", "word") : unref(t)("vocabulary.words", "words")), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_6$I, [
                createBaseVNode("span", _hoisted_7$G, toDisplayString$1(unref(getTotalExamplesForTopic)(group)) + " " + toDisplayString$1(unref(t)("vocabulary.examples.examples", "examples")), 1),
                (openBlock(), createElementBlock("svg", {
                  class: normalizeClass(["w-5 h-5 text-gray-500 dark:text-gray-400 transition-transform duration-300", { "rotate-180": unref(expandedGroups)[topicKey] }]),
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, _cache[5] || (_cache[5] = [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M19 9l-7 7-7-7"
                  }, null, -1)
                ]), 2))
              ])
            ], 8, _hoisted_2$R),
            createVNode(Transition, {
              name: "accordion",
              onEnter: unref(enter),
              onAfterEnter: unref(afterEnter),
              onLeave: unref(leave),
              onAfterLeave: unref(afterLeave)
            }, {
              default: withCtx(() => [
                unref(expandedGroups)[topicKey] ? (openBlock(), createElementBlock("div", _hoisted_8$G, [
                  createBaseVNode("div", _hoisted_9$F, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(getPaginatedTopicVocabs)(topicKey), (vocab) => {
                      return openBlock(), createElementBlock("div", {
                        key: vocab.id,
                        class: "bg-white/60 dark:bg-[#0a0a0a]/60 backdrop-blur-sm rounded-xl border border-white/20 dark:border-white/10 p-4 hover:shadow-lg transition-all duration-300"
                      }, [
                        createBaseVNode("div", {
                          onClick: ($event) => unref(toggleVocabExamples)(vocab.id),
                          class: "flex items-center justify-between mb-3 pb-2 border-b border-gray-200/30 dark:border-gray-700/30 cursor-pointer"
                        }, [
                          createBaseVNode("div", _hoisted_11$E, [
                            _cache[8] || (_cache[8] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                              createBaseVNode("div", { class: "w-2 h-2 bg-gradient-to-r from-green-400 to-blue-500 rounded-full" })
                            ], -1)),
                            createBaseVNode("div", null, [
                              createBaseVNode("div", _hoisted_12$D, [
                                createBaseVNode("h4", _hoisted_13$D, toDisplayString$1(vocab.word), 1),
                                createBaseVNode("button", {
                                  onClick: withModifiers(($event) => unref(playVocabularyAudio)(vocab.word), ["stop"]),
                                  class: "p-1 text-blue-600 hover:text-blue-700 hover:bg-blue-50/50 dark:text-blue-400 dark:hover:text-blue-300 dark:hover:bg-blue-900/20 rounded transition-all duration-300 group",
                                  title: unref(t)("vocabulary.examples.playPronunciation", "Play pronunciation")
                                }, _cache[6] || (_cache[6] = [
                                  createBaseVNode("svg", {
                                    class: "w-3.5 h-3.5 group-hover:scale-110 transition-transform duration-200",
                                    fill: "none",
                                    stroke: "currentColor",
                                    viewBox: "0 0 24 24"
                                  }, [
                                    createBaseVNode("path", {
                                      "stroke-linecap": "round",
                                      "stroke-linejoin": "round",
                                      "stroke-width": "2",
                                      d: "M15.536 8.464a5 5 0 010 7.072m2.464-9.536a9 9 0 010 12.728M9 9l3-3v6l-3-3H4a1 1 0 01-1-1V10a1 1 0 011-1h5z"
                                    })
                                  ], -1)
                                ]), 8, _hoisted_14$D),
                                createBaseVNode("button", {
                                  onClick: withModifiers(($event) => unref(toggleVocabExamples)(vocab.id), ["stop"]),
                                  class: "p-1 text-gray-600 hover:text-gray-700 hover:bg-gray-50/50 dark:text-gray-400 dark:hover:text-gray-300 dark:hover:bg-[#0a0a0a]/20 rounded transition-all duration-300 group",
                                  title: unref(expandedVocabExamples)[vocab.id] ? unref(t)("vocabulary.examples.hideExamples", "Hide examples") : unref(t)("vocabulary.examples.showExamples", "Show examples")
                                }, [
                                  (openBlock(), createElementBlock("svg", {
                                    class: normalizeClass(["w-3.5 h-3.5 group-hover:scale-110 transition-all duration-200", { "rotate-180": unref(expandedVocabExamples)[vocab.id] }]),
                                    fill: "none",
                                    stroke: "currentColor",
                                    viewBox: "0 0 24 24"
                                  }, _cache[7] || (_cache[7] = [
                                    createBaseVNode("path", {
                                      "stroke-linecap": "round",
                                      "stroke-linejoin": "round",
                                      "stroke-width": "2",
                                      d: "M19 9l-7 7-7-7"
                                    }, null, -1)
                                  ]), 2))
                                ], 8, _hoisted_15$y)
                              ]),
                              createBaseVNode("p", _hoisted_16$x, toDisplayString$1(vocab.meaning), 1),
                              createBaseVNode("div", _hoisted_17$w, [
                                createBaseVNode("span", _hoisted_18$v, toDisplayString$1(vocab.partOfSpeech), 1),
                                createBaseVNode("span", _hoisted_19$v, toDisplayString$1(unref(getVocabExampleCount)(vocab.id)) + " " + toDisplayString$1(unref(getVocabExampleCount)(vocab.id) === 1 ? "example" : "examples"), 1)
                              ])
                            ])
                          ]),
                          createBaseVNode("button", {
                            onClick: withModifiers(($event) => _ctx.$emit("add-example", vocab), ["stop"]),
                            class: "px-3 py-1.5 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 text-white rounded-lg font-medium transition-all duration-300 shadow-lg hover:shadow-xl flex items-center space-x-1.5"
                          }, [
                            _cache[9] || (_cache[9] = createBaseVNode("svg", {
                              class: "w-3.5 h-3.5",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M12 4v16m8-8H4"
                              })
                            ], -1)),
                            createBaseVNode("span", _hoisted_21$u, toDisplayString$1(unref(t)("vocabulary.examples.addExample", "Add Example")), 1)
                          ], 8, _hoisted_20$u)
                        ], 8, _hoisted_10$E),
                        createVNode(Transition, {
                          name: "vocab-examples-accordion",
                          onEnter: unref(vocabExamplesEnter),
                          onAfterEnter: unref(vocabExamplesAfterEnter),
                          onLeave: unref(vocabExamplesLeave),
                          onAfterLeave: unref(vocabExamplesAfterLeave)
                        }, {
                          default: withCtx(() => [
                            unref(expandedVocabExamples)[vocab.id] ? (openBlock(), createElementBlock("div", _hoisted_22$s, [
                              unref(getVocabExamples)(vocab.id).length === 0 ? (openBlock(), createElementBlock("div", _hoisted_23$s, [
                                _cache[10] || (_cache[10] = createBaseVNode("svg", {
                                  class: "mx-auto h-6 w-6 text-gray-400 mb-1",
                                  fill: "none",
                                  stroke: "currentColor",
                                  viewBox: "0 0 24 24"
                                }, [
                                  createBaseVNode("path", {
                                    "stroke-linecap": "round",
                                    "stroke-linejoin": "round",
                                    "stroke-width": "2",
                                    d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                                  })
                                ], -1)),
                                createBaseVNode("p", _hoisted_24$r, toDisplayString$1(unref(t)("vocabulary.examples.noExamplesForWord", "No examples yet")), 1)
                              ])) : createCommentVNode("", true),
                              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(getPaginatedVocabExamples)(vocab.id), (example) => {
                                return openBlock(), createElementBlock("div", {
                                  key: example.id,
                                  class: "bg-white/40 dark:bg-[#0a0a0a]/40 backdrop-blur-sm rounded-lg border border-white/20 dark:border-white/10 p-3 hover:shadow-md transition-all duration-300"
                                }, [
                                  createBaseVNode("div", _hoisted_25$r, [
                                    createBaseVNode("div", _hoisted_26$p, [
                                      createBaseVNode("div", _hoisted_27$o, [
                                        createBaseVNode("span", {
                                          class: normalizeClass(["inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium", unref(getTypeColorClass)(example.type)])
                                        }, toDisplayString$1(unref(getTypeLabel)(example.type)), 3),
                                        example.difficulty ? (openBlock(), createElementBlock("span", {
                                          key: 0,
                                          class: normalizeClass(["text-sm", unref(getDifficultyColorClass)(example.difficulty)])
                                        }, toDisplayString$1(unref(getDifficultyLabel)(example.difficulty)), 3)) : createCommentVNode("", true)
                                      ]),
                                      createBaseVNode("div", _hoisted_28$o, [
                                        createBaseVNode("div", _hoisted_29$m, [
                                          createBaseVNode("p", _hoisted_30$l, toDisplayString$1(example.title), 1),
                                          createBaseVNode("button", {
                                            onClick: ($event) => unref(playExampleAudio)(example.content),
                                            class: "p-1 text-green-600 hover:text-green-700 hover:bg-green-50/50 dark:text-green-400 dark:hover:text-green-300 dark:hover:bg-green-900/20 rounded transition-all duration-300 group",
                                            title: unref(t)("vocabulary.examples.playExample", "Play example")
                                          }, _cache[11] || (_cache[11] = [
                                            createBaseVNode("svg", {
                                              class: "w-3 h-3 group-hover:scale-110 transition-transform duration-200",
                                              fill: "none",
                                              stroke: "currentColor",
                                              viewBox: "0 0 24 24"
                                            }, [
                                              createBaseVNode("path", {
                                                "stroke-linecap": "round",
                                                "stroke-linejoin": "round",
                                                "stroke-width": "2",
                                                d: "M15.536 8.464a5 5 0 010 7.072m2.464-9.536a9 9 0 010 12.728M9 9l3-3v6l-3-3H4a1 1 0 01-1-1V10a1 1 0 011-1h5z"
                                              })
                                            ], -1)
                                          ]), 8, _hoisted_31$k)
                                        ]),
                                        createBaseVNode("p", _hoisted_32$h, toDisplayString$1(example.content), 1),
                                        example.translation ? (openBlock(), createElementBlock("p", _hoisted_33$h, toDisplayString$1(example.translation), 1)) : createCommentVNode("", true)
                                      ]),
                                      example.tags && example.tags.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_34$g, [
                                        (openBlock(true), createElementBlock(Fragment, null, renderList(example.tags, (tag) => {
                                          return openBlock(), createElementBlock("span", {
                                            key: tag,
                                            class: "inline-flex items-center px-1.5 py-0.5 rounded text-xs bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300"
                                          }, toDisplayString$1(tag), 1);
                                        }), 128))
                                      ])) : createCommentVNode("", true)
                                    ]),
                                    createBaseVNode("div", _hoisted_35$g, [
                                      createBaseVNode("button", {
                                        onClick: ($event) => _ctx.$emit("edit-example", example),
                                        class: "px-2 py-1.5 text-blue-600 hover:text-blue-700 hover:bg-blue-50/50 dark:text-blue-400 dark:hover:text-blue-300 dark:hover:bg-blue-900/20 rounded-md transition-all duration-300 text-sm"
                                      }, toDisplayString$1(unref(t)("common.edit", "Edit")), 9, _hoisted_36$f),
                                      createBaseVNode("button", {
                                        onClick: ($event) => unref(deleteExample)(example, emit),
                                        class: "px-2 py-1.5 text-red-600 hover:text-red-700 hover:bg-red-50/50 dark:text-red-400 dark:hover:text-red-300 dark:hover:bg-red-900/20 rounded-md transition-all duration-300 text-sm"
                                      }, toDisplayString$1(unref(t)("common.delete", "Delete")), 9, _hoisted_37$e)
                                    ])
                                  ])
                                ]);
                              }), 128)),
                              unref(getVocabExamplePages)(vocab.id) > 1 ? (openBlock(), createElementBlock("div", _hoisted_38$e, [
                                createBaseVNode("div", _hoisted_39$c, [
                                  createBaseVNode("div", _hoisted_40$c, [
                                    createBaseVNode("button", {
                                      onClick: ($event) => unref(previousExamplePage)(vocab.id),
                                      disabled: !unref(getExamplePaginationInfo)(vocab.id).hasPrevious,
                                      class: "px-2 py-1 text-xs bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                    }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_41$b),
                                    createBaseVNode("span", _hoisted_42$9, toDisplayString$1(unref(getExamplePaginationInfo)(vocab.id).currentPage) + " / " + toDisplayString$1(unref(getExamplePaginationInfo)(vocab.id).totalPages), 1),
                                    createBaseVNode("button", {
                                      onClick: ($event) => unref(nextExamplePage)(vocab.id),
                                      disabled: !unref(getExamplePaginationInfo)(vocab.id).hasNext,
                                      class: "px-2 py-1 text-xs bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                    }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_43$8)
                                  ]),
                                  createBaseVNode("div", _hoisted_44$8, [
                                    createBaseVNode("button", {
                                      onClick: ($event) => unref(previousExamplePage)(vocab.id),
                                      disabled: !unref(getExamplePaginationInfo)(vocab.id).hasPrevious,
                                      class: "px-3 py-1.5 text-sm bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                    }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_45$7),
                                    createBaseVNode("div", _hoisted_46$7, [
                                      (openBlock(true), createElementBlock(Fragment, null, renderList(Math.min(unref(getExamplePaginationInfo)(vocab.id).totalPages, 5), (page) => {
                                        return openBlock(), createElementBlock("button", {
                                          key: page,
                                          onClick: ($event) => unref(goToExamplePage)(vocab.id, page),
                                          class: normalizeClass([
                                            "px-3 py-1.5 text-sm rounded transition-colors",
                                            unref(getExamplePaginationInfo)(vocab.id).currentPage === page ? "bg-blue-600 text-white" : "bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600"
                                          ])
                                        }, toDisplayString$1(page), 11, _hoisted_47$7);
                                      }), 128))
                                    ]),
                                    createBaseVNode("button", {
                                      onClick: ($event) => unref(nextExamplePage)(vocab.id),
                                      disabled: !unref(getExamplePaginationInfo)(vocab.id).hasNext,
                                      class: "px-3 py-1.5 text-sm bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                    }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_48$7)
                                  ]),
                                  createBaseVNode("div", _hoisted_49$7, toDisplayString$1(unref(t)("vocabulary.examples.showingExamples", { start: unref(getExamplePaginationInfo)(vocab.id).start, end: unref(getExamplePaginationInfo)(vocab.id).end, total: unref(getExamplePaginationInfo)(vocab.id).totalExamples }, "Showing {start} to {end} of {total} examples")), 1)
                                ])
                              ])) : createCommentVNode("", true)
                            ])) : createCommentVNode("", true)
                          ]),
                          _: 2
                        }, 1032, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])
                      ]);
                    }), 128)),
                    unref(getTopicVocabPagesCount)(topicKey) > 1 ? (openBlock(), createElementBlock("div", _hoisted_50$7, [
                      createBaseVNode("div", _hoisted_51$6, [
                        createBaseVNode("div", _hoisted_52$6, [
                          createBaseVNode("button", {
                            onClick: ($event) => unref(previousTopicVocabPage)(topicKey),
                            disabled: !unref(getTopicVocabPaginationInfo)(topicKey).hasPrevious,
                            class: "px-2 py-1 text-xs bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                          }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_53$6),
                          createBaseVNode("span", _hoisted_54$6, toDisplayString$1(unref(getTopicVocabPaginationInfo)(topicKey).currentPage) + " / " + toDisplayString$1(unref(getTopicVocabPaginationInfo)(topicKey).totalPages), 1),
                          createBaseVNode("button", {
                            onClick: ($event) => unref(nextTopicVocabPage)(topicKey),
                            disabled: !unref(getTopicVocabPaginationInfo)(topicKey).hasNext,
                            class: "px-2 py-1 text-xs bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                          }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_55$6)
                        ]),
                        createBaseVNode("div", _hoisted_56$6, [
                          createBaseVNode("button", {
                            onClick: ($event) => unref(previousTopicVocabPage)(topicKey),
                            disabled: !unref(getTopicVocabPaginationInfo)(topicKey).hasPrevious,
                            class: "px-3 py-1.5 text-sm bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                          }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_57$6),
                          createBaseVNode("div", _hoisted_58$6, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(getTopicVisiblePages)(topicKey), (page) => {
                              return openBlock(), createElementBlock("button", {
                                key: page,
                                onClick: ($event) => unref(goToTopicVocabPage)(topicKey, page),
                                class: normalizeClass([
                                  "px-3 py-1.5 text-sm rounded transition-colors",
                                  unref(getTopicVocabPaginationInfo)(topicKey).currentPage === page ? "bg-blue-600 text-white" : "bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600"
                                ])
                              }, toDisplayString$1(page), 11, _hoisted_59$5);
                            }), 128))
                          ]),
                          createBaseVNode("button", {
                            onClick: ($event) => unref(nextTopicVocabPage)(topicKey),
                            disabled: !unref(getTopicVocabPaginationInfo)(topicKey).hasNext,
                            class: "px-3 py-1.5 text-sm bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                          }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_60$5)
                        ]),
                        createBaseVNode("div", _hoisted_61$5, toDisplayString$1(unref(t)("vocabulary.examples.showingVocabulary", { start: unref(getTopicVocabPaginationInfo)(topicKey).start, end: unref(getTopicVocabPaginationInfo)(topicKey).end, total: unref(getTopicVocabPaginationInfo)(topicKey).totalVocab }, "Showing {start} to {end} of {total} words")), 1)
                      ])
                    ])) : createCommentVNode("", true)
                  ])
                ])) : createCommentVNode("", true)
              ]),
              _: 2
            }, 1032, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])
          ]);
        }), 128)),
        unref(paginationInfo).totalPages > 1 ? (openBlock(), createElementBlock("div", _hoisted_62$5, [
          createBaseVNode("div", _hoisted_63$3, [
            createBaseVNode("div", _hoisted_64$3, [
              createBaseVNode("button", {
                onClick: _cache[0] || (_cache[0] = //@ts-ignore
                (...args) => unref(previousPage) && unref(previousPage)(...args)),
                disabled: !unref(paginationInfo).hasPrevious,
                class: "relative inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
              }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_65$3),
              createBaseVNode("button", {
                onClick: _cache[1] || (_cache[1] = //@ts-ignore
                (...args) => unref(nextPage) && unref(nextPage)(...args)),
                disabled: !unref(paginationInfo).hasNext,
                class: "ml-3 relative inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
              }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_66$3)
            ]),
            createBaseVNode("div", _hoisted_67$3, [
              createBaseVNode("div", null, [
                createBaseVNode("p", _hoisted_68$3, toDisplayString$1(unref(t)("vocabulary.examples.showingTopics", {
                  start: unref(paginationInfo).startIndex,
                  end: unref(paginationInfo).endIndex,
                  total: unref(paginationInfo).totalTopics
                }, `Showing ${unref(paginationInfo).startIndex} to ${unref(paginationInfo).endIndex} of ${unref(paginationInfo).totalTopics} topics`)), 1)
              ]),
              createBaseVNode("nav", _hoisted_69$3, [
                createBaseVNode("button", {
                  onClick: _cache[2] || (_cache[2] = //@ts-ignore
                  (...args) => unref(previousPage) && unref(previousPage)(...args)),
                  disabled: !unref(paginationInfo).hasPrevious,
                  class: "relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                }, [
                  createBaseVNode("span", _hoisted_71$3, toDisplayString$1(unref(t)("common.previous", "Previous")), 1),
                  _cache[12] || (_cache[12] = createBaseVNode("svg", {
                    class: "h-5 w-5",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                      "clip-rule": "evenodd"
                    })
                  ], -1))
                ], 8, _hoisted_70$3),
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(visiblePages), (page) => {
                  return openBlock(), createElementBlock("button", {
                    key: page,
                    onClick: ($event) => unref(goToPage)(page),
                    class: normalizeClass([
                      page === unref(currentPage) ? "z-10 bg-blue-50 dark:bg-blue-900 border-blue-500 dark:border-blue-400 text-blue-600 dark:text-blue-300" : "bg-white dark:bg-[#0a0a0a] border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600",
                      "relative inline-flex items-center px-4 py-2 border text-sm font-medium"
                    ])
                  }, toDisplayString$1(page), 11, _hoisted_72$3);
                }), 128)),
                createBaseVNode("button", {
                  onClick: _cache[3] || (_cache[3] = //@ts-ignore
                  (...args) => unref(nextPage) && unref(nextPage)(...args)),
                  disabled: !unref(paginationInfo).hasNext,
                  class: "relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                }, [
                  createBaseVNode("span", _hoisted_74$3, toDisplayString$1(unref(t)("common.next", "Next")), 1),
                  _cache[13] || (_cache[13] = createBaseVNode("svg", {
                    class: "h-5 w-5",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                      "clip-rule": "evenodd"
                    })
                  ], -1))
                ], 8, _hoisted_73$3)
              ])
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const TopicGroupAccordion = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["__scopeId", "data-v-8a43d51e"]]);

const TopicGroupAccordion$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: TopicGroupAccordion
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$T = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$Q = { class: "w-full max-h-[90vh] flex flex-col max-w-full sm:max-w-lg md:max-w-2xl lg:max-w-4xl" };
const _hoisted_3$O = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-green-50 to-emerald-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$M = { class: "flex items-center justify-between" };
const _hoisted_5$J = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$H = {
  key: 0,
  class: "mt-2 flex items-center space-x-2 text-sm text-gray-600 dark:text-gray-300"
};
const _hoisted_7$F = { class: "font-medium text-green-600 dark:text-green-400" };
const _hoisted_8$F = { class: "font-semibold" };
const _hoisted_9$E = { class: "px-6 py-4 flex-1 overflow-y-auto min-h-0" };
const _hoisted_10$D = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_11$D = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_12$C = { value: "" };
const _hoisted_13$C = { value: "sentence" };
const _hoisted_14$C = { value: "dialogue" };
const _hoisted_15$x = { value: "phrase" };
const _hoisted_16$w = { value: "context" };
const _hoisted_17$v = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_18$u = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_19$u = ["placeholder"];
const _hoisted_20$t = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_21$t = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_22$r = ["placeholder"];
const _hoisted_23$r = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_24$q = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_25$q = ["placeholder"];
const _hoisted_26$o = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_27$n = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_28$n = ["placeholder"];
const _hoisted_29$l = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_30$k = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_31$j = { value: "" };
const _hoisted_32$g = { value: "easy" };
const _hoisted_33$g = { value: "medium" };
const _hoisted_34$f = { value: "hard" };
const _hoisted_35$f = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.8s" }
};
const _hoisted_36$e = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_37$d = { class: "space-y-3" };
const _hoisted_38$d = ["placeholder", "onKeydown"];
const _hoisted_39$b = {
  key: 0,
  class: "flex flex-wrap gap-2"
};
const _hoisted_40$b = ["onClick"];
const _hoisted_41$a = { class: "flex items-center justify-end space-x-3 p-6 border-t border-gray-200 dark:border-gray-700 bg-gradient-to-r from-gray-50 to-white dark:from-[#0a0a0a] dark:to-[#0a0a0a] flex-shrink-0" };
const _hoisted_42$8 = ["disabled"];
const __default__ = {};
const _sfc_main$T = /* @__PURE__ */ defineComponent({
  ...__default__,
  ...{
    name: "ExampleFormDialog"
  },
  __name: "ExampleFormDialog",
  props: {
    show: { type: Boolean },
    example: {},
    vocabularyId: {},
    vocabularyList: {}
  },
  emits: ["close", "save"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const formData = ref({
      vocabularyId: "",
      title: "",
      content: "",
      translation: "",
      context: "",
      type: "sentence",
      difficulty: "easy",
      tags: []
    });
    const tagInput = ref("");
    const selectedVocab = computed(() => {
      return props.vocabularyList.find((v) => v.id === formData.value.vocabularyId);
    });
    const isFormValid = computed(() => {
      return formData.value.vocabularyId && formData.value.title.trim() && formData.value.content.trim() && formData.value.type;
    });
    const resetForm = () => {
      formData.value = {
        vocabularyId: props.vocabularyId || "",
        title: "",
        content: "",
        translation: "",
        context: "",
        type: "sentence",
        difficulty: "easy",
        tags: []
      };
      tagInput.value = "";
    };
    const loadExample = () => {
      if (props.example) {
        formData.value = {
          ...props.example,
          tags: props.example.tags ? [...props.example.tags] : []
        };
      } else {
        resetForm();
        if (props.vocabularyId) {
          formData.value.vocabularyId = props.vocabularyId;
        }
      }
    };
    const addTagFromInput = () => {
      if (tagInput.value.trim()) {
        const newTags = tagInput.value.split(",").map((tag) => tag.trim()).filter((tag) => tag && !formData.value.tags?.includes(tag));
        if (newTags.length > 0) {
          formData.value.tags = [...formData.value.tags || [], ...newTags];
          tagInput.value = "";
        }
      }
    };
    const removeTag = (index) => {
      if (formData.value.tags) {
        formData.value.tags.splice(index, 1);
      }
    };
    const handleSubmit = () => {
      if (!isFormValid.value) return;
      const exampleData = {
        ...formData.value,
        tags: formData.value.tags?.filter((tag) => tag.trim()) || []
      };
      emit("save", exampleData);
    };
    const lockBodyScroll = () => {
      document.body.style.overflow = "hidden";
    };
    const unlockBodyScroll = () => {
      document.body.style.overflow = "";
    };
    watch(() => props.show, (newShow) => {
      if (newShow) {
        loadExample();
        lockBodyScroll();
      } else {
        unlockBodyScroll();
      }
    });
    watch(() => props.example, () => {
      if (props.show) {
        loadExample();
      }
    });
    watch(() => props.vocabularyId, () => {
      if (props.show && !props.example) {
        formData.value.vocabularyId = props.vocabularyId || "";
      }
    });
    onMounted(() => {
      if (props.show) {
        loadExample();
        lockBodyScroll();
      }
    });
    onUnmounted(() => {
      unlockBodyScroll();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$T, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$Q, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 flex flex-col h-full overflow-hidden transform",
                      onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$O, [
                        createBaseVNode("div", _hoisted_4$M, [
                          createBaseVNode("div", null, [
                            createBaseVNode("h2", _hoisted_5$J, [
                              _cache[10] || (_cache[10] = createBaseVNode("span", { class: "w-2 h-2 bg-green-500 rounded-full animate-pulse" }, null, -1)),
                              createBaseVNode("span", null, toDisplayString$1(_ctx.example ? unref(t)("vocabulary.examples.editExample", "Edit Example") : unref(t)("vocabulary.examples.addExample", "Add New Example")), 1)
                            ]),
                            selectedVocab.value ? (openBlock(), createElementBlock("div", _hoisted_6$H, [
                              createBaseVNode("span", _hoisted_7$F, toDisplayString$1(unref(t)("common.vocabulary", "Vocabulary")) + ":", 1),
                              createBaseVNode("span", _hoisted_8$F, toDisplayString$1(selectedVocab.value.word), 1),
                              _cache[11] || (_cache[11] = createBaseVNode("span", { class: "text-gray-400" }, "•", -1)),
                              createBaseVNode("span", null, toDisplayString$1(selectedVocab.value.meaning), 1)
                            ])) : createCommentVNode("", true)
                          ]),
                          createBaseVNode("button", {
                            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close")),
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[12] || (_cache[12] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_9$E, [
                        createBaseVNode("form", {
                          onSubmit: withModifiers(handleSubmit, ["prevent"]),
                          class: "space-y-6"
                        }, [
                          createBaseVNode("div", _hoisted_10$D, [
                            createBaseVNode("label", _hoisted_11$D, [
                              _cache[13] || (_cache[13] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.examples.exampleType", "Example Type")) + " ", 1),
                              _cache[14] || (_cache[14] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                            ]),
                            withDirectives(createBaseVNode("select", {
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => formData.value.type = $event),
                              required: "",
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 hover:border-blue-400 dark:hover:border-blue-500 transform hover:scale-[1.02]"
                            }, [
                              createBaseVNode("option", _hoisted_12$C, toDisplayString$1(unref(t)("vocabulary.examples.selectType", "Select example type...")), 1),
                              createBaseVNode("option", _hoisted_13$C, toDisplayString$1(unref(t)("vocabulary.examples.types.sentence", "Sentence")), 1),
                              createBaseVNode("option", _hoisted_14$C, toDisplayString$1(unref(t)("vocabulary.examples.types.dialogue", "Dialogue")), 1),
                              createBaseVNode("option", _hoisted_15$x, toDisplayString$1(unref(t)("vocabulary.examples.types.phrase", "Phrase")), 1),
                              createBaseVNode("option", _hoisted_16$w, toDisplayString$1(unref(t)("vocabulary.examples.types.context", "Context")), 1)
                            ], 512), [
                              [vModelSelect, formData.value.type]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_17$v, [
                            createBaseVNode("label", _hoisted_18$u, [
                              _cache[15] || (_cache[15] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("common.title", "Title")) + " ", 1),
                              _cache[16] || (_cache[16] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                            ]),
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => formData.value.title = $event),
                              type: "text",
                              required: "",
                              placeholder: unref(t)("vocabulary.examples.titlePlaceholder", "Brief title for this example..."),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-300 hover:border-purple-400 dark:hover:border-purple-500 transform hover:scale-[1.02]"
                            }, null, 8, _hoisted_19$u), [
                              [vModelText, formData.value.title]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_20$t, [
                            createBaseVNode("label", _hoisted_21$t, [
                              _cache[17] || (_cache[17] = createBaseVNode("span", { class: "w-1 h-4 bg-orange-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.examples.content", "Example Content")) + " ", 1),
                              _cache[18] || (_cache[18] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                            ]),
                            withDirectives(createBaseVNode("textarea", {
                              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => formData.value.content = $event),
                              required: "",
                              rows: "4",
                              placeholder: unref(t)("vocabulary.examples.contentPlaceholder", "Enter the example sentence or dialogue..."),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all duration-300 hover:border-orange-400 dark:hover:border-orange-500 transform hover:scale-[1.02] resize-none"
                            }, null, 8, _hoisted_22$r), [
                              [vModelText, formData.value.content]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_23$r, [
                            createBaseVNode("label", _hoisted_24$q, [
                              _cache[19] || (_cache[19] = createBaseVNode("span", { class: "w-1 h-4 bg-yellow-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.examples.translation", "Translation")), 1)
                            ]),
                            withDirectives(createBaseVNode("textarea", {
                              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => formData.value.translation = $event),
                              rows: "2",
                              placeholder: unref(t)("vocabulary.examples.translationPlaceholder", "Optional translation in your native language..."),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent transition-all duration-300 hover:border-yellow-400 dark:hover:border-yellow-500 transform hover:scale-[1.02] resize-none"
                            }, null, 8, _hoisted_25$q), [
                              [vModelText, formData.value.translation]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_26$o, [
                            createBaseVNode("label", _hoisted_27$n, [
                              _cache[20] || (_cache[20] = createBaseVNode("span", { class: "w-1 h-4 bg-cyan-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.examples.context", "Context")), 1)
                            ]),
                            withDirectives(createBaseVNode("textarea", {
                              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => formData.value.context = $event),
                              rows: "2",
                              placeholder: unref(t)("vocabulary.examples.contextPlaceholder", "Optional context or situation where this example is used..."),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent transition-all duration-300 hover:border-cyan-400 dark:hover:border-cyan-500 transform hover:scale-[1.02] resize-none"
                            }, null, 8, _hoisted_28$n), [
                              [vModelText, formData.value.context]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_29$l, [
                            createBaseVNode("label", _hoisted_30$k, [
                              _cache[21] || (_cache[21] = createBaseVNode("span", { class: "w-1 h-4 bg-pink-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.examples.difficulty", "Difficulty")), 1)
                            ]),
                            withDirectives(createBaseVNode("select", {
                              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => formData.value.difficulty = $event),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-transparent transition-all duration-300 hover:border-pink-400 dark:hover:border-pink-500 transform hover:scale-[1.02]"
                            }, [
                              createBaseVNode("option", _hoisted_31$j, toDisplayString$1(unref(t)("vocabulary.examples.selectDifficulty", "Select difficulty...")), 1),
                              createBaseVNode("option", _hoisted_32$g, toDisplayString$1(unref(t)("common.easy", "Easy")), 1),
                              createBaseVNode("option", _hoisted_33$g, toDisplayString$1(unref(t)("vocabulary.examples.difficulty.medium", "Medium")), 1),
                              createBaseVNode("option", _hoisted_34$f, toDisplayString$1(unref(t)("common.difficult", "Difficult")), 1)
                            ], 512), [
                              [vModelSelect, formData.value.difficulty]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_35$f, [
                            createBaseVNode("label", _hoisted_36$e, [
                              _cache[22] || (_cache[22] = createBaseVNode("span", { class: "w-1 h-4 bg-indigo-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.examples.tags", "Tags")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_37$d, [
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => tagInput.value = $event),
                                type: "text",
                                placeholder: unref(t)("vocabulary.examples.tagsPlaceholder", "Enter tags separated by commas..."),
                                onKeydown: withKeys(withModifiers(addTagFromInput, ["prevent"]), ["enter"]),
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition-all duration-300 hover:border-indigo-400 dark:hover:border-indigo-500 transform hover:scale-[1.02]"
                              }, null, 40, _hoisted_38$d), [
                                [vModelText, tagInput.value]
                              ]),
                              formData.value.tags && formData.value.tags.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_39$b, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(formData.value.tags, (tag, index) => {
                                  return openBlock(), createElementBlock("span", {
                                    key: index,
                                    class: "inline-flex items-center px-3 py-1 rounded-full text-sm bg-green-100/50 text-green-800 dark:bg-green-900/20 dark:text-green-300 backdrop-blur-sm"
                                  }, [
                                    createTextVNode(toDisplayString$1(tag) + " ", 1),
                                    createBaseVNode("button", {
                                      type: "button",
                                      onClick: ($event) => removeTag(index),
                                      class: "ml-2 text-green-600 dark:text-green-400 hover:text-green-800 dark:hover:text-green-200 transition-all duration-300 hover:scale-110"
                                    }, _cache[23] || (_cache[23] = [
                                      createBaseVNode("svg", {
                                        class: "w-3 h-3",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M6 18L18 6M6 6l12 12"
                                        })
                                      ], -1)
                                    ]), 8, _hoisted_40$b)
                                  ]);
                                }), 128))
                              ])) : createCommentVNode("", true)
                            ])
                          ])
                        ], 32)
                      ]),
                      createBaseVNode("div", _hoisted_41$a, [
                        createBaseVNode("button", {
                          onClick: _cache[8] || (_cache[8] = ($event) => _ctx.$emit("close")),
                          type: "button",
                          class: "px-4 py-2 text-gray-700 dark:text-gray-300 bg-white/50 dark:bg-[#0a0a0a]/50 hover:bg-gray-100/50 dark:hover:bg-[#0a0a0a]/70 border border-gray-300 dark:border-gray-600 rounded-lg font-medium transition-all duration-300 hover:scale-105 shadow-md hover:shadow-lg"
                        }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                        createBaseVNode("button", {
                          onClick: handleSubmit,
                          type: "submit",
                          disabled: !isFormValid.value,
                          class: "px-6 py-2 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 disabled:from-gray-400 disabled:to-gray-500 disabled:cursor-not-allowed text-white rounded-lg font-medium transition-all duration-300 hover:scale-105 shadow-lg hover:shadow-xl"
                        }, toDisplayString$1(_ctx.example ? unref(t)("common.update", "Update") : unref(t)("common.add", "Add")), 9, _hoisted_42$8)
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const ExampleFormDialog = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$T
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$S = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-3 sm:pt-6" };
const _hoisted_2$P = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_3$N = { class: "flex justify-between items-center" };
const _hoisted_4$L = { class: "flex items-center mb-1" };
const _hoisted_5$I = { class: "text-2xl sm:text-3xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 dark:from-blue-400 dark:to-indigo-400 bg-clip-text text-transparent" };
const _hoisted_6$G = { class: "mt-1 text-sm text-gray-700 dark:text-white/70" };
const _sfc_main$S = /* @__PURE__ */ defineComponent({
  __name: "GrammarHeader",
  emits: ["add-lesson"],
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$S, [
        createBaseVNode("div", _hoisted_2$P, [
          createBaseVNode("div", _hoisted_3$N, [
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_4$L, [
                _cache[1] || (_cache[1] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                  createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-indigo-500 rounded-full mr-2.5" })
                ], -1)),
                createBaseVNode("h1", _hoisted_5$I, toDisplayString$1(unref(t)("grammar.title", "Grammar")), 1)
              ]),
              createBaseVNode("p", _hoisted_6$G, toDisplayString$1(unref(t)("grammar.description", "Master English grammar with structured lessons and practice")), 1)
            ]),
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("add-lesson")),
              class: "bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition-colors shadow"
            }, [
              _cache[2] || (_cache[2] = createBaseVNode("svg", {
                class: "w-5 h-5 inline mr-2",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                  "clip-rule": "evenodd"
                })
              ], -1)),
              createTextVNode(" " + toDisplayString$1(unref(t)("grammar.addLesson", "Add Lesson")), 1)
            ])
          ])
        ])
      ]);
    };
  }
});

const GrammarHeader = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$S
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$R = { class: "bg-white dark:bg-[#0a0a0a] shadow rounded-lg p-6 mb-6" };
const _hoisted_2$O = { class: "grid grid-cols-1 md:grid-cols-3 gap-4" };
const _hoisted_3$M = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_4$K = ["value", "placeholder"];
const _hoisted_5$H = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_6$F = ["value"];
const _hoisted_7$E = { value: "" };
const _hoisted_8$E = { value: "beginner" };
const _hoisted_9$D = { value: "intermediate" };
const _hoisted_10$C = { value: "advanced" };
const _hoisted_11$C = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_12$B = ["value"];
const _hoisted_13$B = { value: "" };
const _hoisted_14$B = ["value"];
const _sfc_main$R = /* @__PURE__ */ defineComponent({
  __name: "GrammarFilters",
  props: {
    searchQuery: {},
    selectedLevel: {},
    selectedCategory: {},
    categories: {}
  },
  emits: ["update:searchQuery", "update:selectedLevel", "update:selectedCategory"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const emit = __emit;
    const handleSearchInput = (event) => {
      const target = event.target;
      emit("update:searchQuery", target.value);
    };
    const handleLevelChange = (event) => {
      const target = event.target;
      emit("update:selectedLevel", target.value);
    };
    const handleCategoryChange = (event) => {
      const target = event.target;
      emit("update:selectedCategory", target.value);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$R, [
        createBaseVNode("div", _hoisted_2$O, [
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_3$M, toDisplayString$1(unref(t)("common.search", "Search")), 1),
            createBaseVNode("input", {
              value: _ctx.searchQuery,
              onInput: handleSearchInput,
              type: "text",
              placeholder: unref(t)("grammar.search", "Search grammar..."),
              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400"
            }, null, 40, _hoisted_4$K)
          ]),
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_5$H, toDisplayString$1(unref(t)("grammar.level", "Level")), 1),
            createBaseVNode("select", {
              value: _ctx.selectedLevel,
              onChange: handleLevelChange,
              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400"
            }, [
              createBaseVNode("option", _hoisted_7$E, toDisplayString$1(unref(t)("common.all", "All")), 1),
              createBaseVNode("option", _hoisted_8$E, toDisplayString$1(unref(t)("grammar.levels.beginner", "Beginner")), 1),
              createBaseVNode("option", _hoisted_9$D, toDisplayString$1(unref(t)("grammar.levels.intermediate", "Intermediate")), 1),
              createBaseVNode("option", _hoisted_10$C, toDisplayString$1(unref(t)("grammar.levels.advanced", "Advanced")), 1)
            ], 40, _hoisted_6$F)
          ]),
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_11$C, toDisplayString$1(unref(t)("grammar.category", "Category")), 1),
            createBaseVNode("select", {
              value: _ctx.selectedCategory,
              onChange: handleCategoryChange,
              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400"
            }, [
              createBaseVNode("option", _hoisted_13$B, toDisplayString$1(unref(t)("common.all", "All")), 1),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.categories, (category) => {
                return openBlock(), createElementBlock("option", {
                  key: category,
                  value: category
                }, toDisplayString$1(category), 9, _hoisted_14$B);
              }), 128))
            ], 40, _hoisted_12$B)
          ])
        ])
      ]);
    };
  }
});

const GrammarFilters = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$R
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$Q = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg shadow-md overflow-hidden hover:shadow-lg transition-shadow border border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_2$N = { class: "h-48 bg-gradient-to-br from-blue-400 to-blue-600 flex items-center justify-center" };
const _hoisted_3$L = { class: "text-center text-white" };
const _hoisted_4$J = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_5$G = { class: "p-6" };
const _hoisted_6$E = { class: "flex items-center justify-between mb-3" };
const _hoisted_7$D = { class: "text-sm text-gray-500 dark:text-white/70" };
const _hoisted_8$D = { class: "text-gray-600 dark:text-white/80 text-sm mb-4 line-clamp-3" };
const _hoisted_9$C = { class: "flex items-center justify-between mb-4" };
const _hoisted_10$B = { class: "text-xs text-gray-500 dark:text-white/60" };
const _hoisted_11$B = { class: "flex items-center" };
const _hoisted_12$A = { class: "text-sm text-gray-600 dark:text-white/80" };
const _hoisted_13$A = { class: "mb-4" };
const _hoisted_14$A = { class: "flex justify-between text-sm text-gray-600 dark:text-white/80 mb-1" };
const _hoisted_15$w = { class: "w-full bg-gray-200 dark:bg-dark-bg-mute rounded-full h-2" };
const _hoisted_16$v = { class: "flex space-x-2" };
const _sfc_main$Q = /* @__PURE__ */ defineComponent({
  __name: "GrammarCard",
  props: {
    lesson: {}
  },
  emits: ["view-lesson", "practice-lesson", "edit-lesson", "delete-lesson"],
  setup(__props) {
    const { t } = useI18n();
    const getLevelColor = (level) => {
      switch (level) {
        case "beginner":
          return "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300";
        case "intermediate":
          return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300";
        case "advanced":
          return "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300";
        default:
          return "bg-gray-100 text-gray-800 dark:bg-dark-bg-mute dark:text-white/80";
      }
    };
    const getLevelText = (level) => {
      const fallbackMap = {
        beginner: "Beginner",
        intermediate: "Intermediate",
        advanced: "Advanced"
      };
      return t(`grammar.levels.${level}`, fallbackMap[level] || "Level");
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$Q, [
        createBaseVNode("div", _hoisted_2$N, [
          createBaseVNode("div", _hoisted_3$L, [
            _cache[4] || (_cache[4] = createBaseVNode("svg", {
              class: "w-16 h-16 mx-auto mb-2",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", { d: "M9 4.804A7.968 7.968 0 005.5 4c-1.255 0-2.443.29-3.5.804v10A7.969 7.969 0 015.5 14c1.669 0 3.218.51 4.5 1.385A7.962 7.962 0 0114.5 14c1.255 0 2.443.29 3.5.804v-10A7.968 7.968 0 0014.5 4c-1.255 0-2.443.29-3.5.804V12a1 1 0 11-2 0V4.804z" })
            ], -1)),
            createBaseVNode("h3", _hoisted_4$J, toDisplayString$1(_ctx.lesson.title), 1)
          ])
        ]),
        createBaseVNode("div", _hoisted_5$G, [
          createBaseVNode("div", _hoisted_6$E, [
            createBaseVNode("span", {
              class: normalizeClass([getLevelColor(_ctx.lesson.level), "px-2 py-1 text-xs font-medium rounded-full"])
            }, toDisplayString$1(getLevelText(_ctx.lesson.level)), 3),
            createBaseVNode("span", _hoisted_7$D, toDisplayString$1(_ctx.lesson.duration) + " " + toDisplayString$1(unref(t)("grammar.duration", "mins")), 1)
          ]),
          createBaseVNode("p", _hoisted_8$D, toDisplayString$1(_ctx.lesson.description), 1),
          createBaseVNode("div", _hoisted_9$C, [
            createBaseVNode("span", _hoisted_10$B, toDisplayString$1(_ctx.lesson.category), 1),
            createBaseVNode("div", _hoisted_11$B, [
              _cache[5] || (_cache[5] = createBaseVNode("svg", {
                class: "w-4 h-4 text-yellow-400 mr-1",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" })
              ], -1)),
              createBaseVNode("span", _hoisted_12$A, toDisplayString$1(_ctx.lesson.rating), 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_13$A, [
            createBaseVNode("div", _hoisted_14$A, [
              createBaseVNode("span", null, toDisplayString$1(unref(t)("grammar.progress", "Progress")), 1),
              createBaseVNode("span", null, toDisplayString$1(_ctx.lesson.progress) + "%", 1)
            ]),
            createBaseVNode("div", _hoisted_15$w, [
              createBaseVNode("div", {
                class: "bg-blue-500 h-2 rounded-full transition-all duration-300",
                style: normalizeStyle({ width: _ctx.lesson.progress + "%" })
              }, null, 4)
            ])
          ]),
          createBaseVNode("div", _hoisted_16$v, [
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("view-lesson", _ctx.lesson)),
              class: "flex-1 bg-blue-500 hover:bg-blue-600 text-white text-sm font-medium py-2 px-4 rounded-md transition-colors"
            }, toDisplayString$1(_ctx.lesson.progress > 0 ? unref(t)("grammar.continue", "Continue") : unref(t)("grammar.start", "Start")), 1),
            createBaseVNode("button", {
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("practice-lesson", _ctx.lesson)),
              class: "bg-green-500 hover:bg-green-600 text-white text-sm font-medium py-2 px-3 rounded-md transition-colors"
            }, _cache[6] || (_cache[6] = [
              createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z",
                  "clip-rule": "evenodd"
                })
              ], -1)
            ])),
            createBaseVNode("button", {
              onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("edit-lesson", _ctx.lesson)),
              class: "text-gray-500 dark:text-white/70 hover:text-gray-700 dark:hover:text-white p-2"
            }, _cache[7] || (_cache[7] = [
              createBaseVNode("svg", {
                class: "w-5 h-5",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
              ], -1)
            ])),
            createBaseVNode("button", {
              onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("delete-lesson", _ctx.lesson)),
              class: "text-red-500 hover:text-red-700 p-2"
            }, _cache[8] || (_cache[8] = [
              createBaseVNode("svg", {
                class: "w-5 h-5",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M9 2a1 1 0 000 2h2a1 1 0 100-2H9z",
                  "clip-rule": "evenodd"
                }),
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",
                  "clip-rule": "evenodd"
                })
              ], -1)
            ]))
          ])
        ])
      ]);
    };
  }
});

const GrammarCard = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$Q
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$P = { class: "text-center py-12" };
const _hoisted_2$M = { class: "mt-2 text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_3$K = { class: "mt-1 text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_4$I = { class: "mt-6" };
const _sfc_main$P = /* @__PURE__ */ defineComponent({
  __name: "GrammarEmptyState",
  emits: ["add-lesson"],
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$P, [
        _cache[2] || (_cache[2] = createBaseVNode("svg", {
          class: "mx-auto h-12 w-12 text-gray-400 dark:text-gray-500",
          fill: "none",
          viewBox: "0 0 24 24",
          stroke: "currentColor"
        }, [
          createBaseVNode("path", {
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            "stroke-width": "2",
            d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
          })
        ], -1)),
        createBaseVNode("h3", _hoisted_2$M, toDisplayString$1(unref(t)("grammar.emptyState.title", "No lessons yet")), 1),
        createBaseVNode("p", _hoisted_3$K, toDisplayString$1(unref(t)("grammar.emptyState.description", "Create your first grammar lesson to get started")), 1),
        createBaseVNode("div", _hoisted_4$I, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("add-lesson")),
            class: "inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700"
          }, [
            _cache[1] || (_cache[1] = createBaseVNode("svg", {
              class: "-ml-1 mr-2 h-5 w-5",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                "clip-rule": "evenodd"
              })
            ], -1)),
            createTextVNode(" " + toDisplayString$1(unref(t)("grammar.addNewLesson", "Add New Lesson")), 1)
          ])
        ])
      ]);
    };
  }
});

const GrammarEmptyState = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$P
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$O = {
  key: 0,
  class: "fixed inset-0 z-50 overflow-hidden",
  "aria-labelledby": "modal-title",
  role: "dialog",
  "aria-modal": "true"
};
const _hoisted_2$L = { class: "flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0" };
const _hoisted_3$J = { class: "inline-block align-bottom bg-white dark:bg-[#0a0a0a] rounded-xl text-left overflow-hidden shadow-2xl transform transition-all sm:my-8 sm:align-middle sm:max-w-4xl sm:w-full border border-gray-200 dark:border-gray-700" };
const _hoisted_4$H = { class: "bg-white dark:bg-[#0a0a0a] px-4 pt-5 pb-4 sm:p-6 sm:pb-4" };
const _hoisted_5$F = { class: "flex items-center justify-between pb-4 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] -mx-4 -mt-5 px-4 pt-5 sm:-mx-6 sm:-mt-6 sm:px-6 sm:pt-6" };
const _hoisted_6$D = { class: "text-lg leading-6 font-medium text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_7$C = {
  class: "bg-white dark:bg-[#0f0f0f] shadow-lg rounded-xl p-6 border border-gray-200 dark:border-gray-700 animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_8$C = { class: "text-lg font-medium text-gray-900 dark:text-white mb-6 flex items-center" };
const _hoisted_9$B = { class: "grid grid-cols-1 md:grid-cols-2 gap-6" };
const _hoisted_10$A = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_11$A = {
  for: "title",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_12$z = ["placeholder"];
const _hoisted_13$z = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_14$z = {
  for: "category",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_15$v = { value: "" };
const _hoisted_16$u = ["value"];
const _hoisted_17$u = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_18$t = {
  for: "level",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_19$t = { value: "" };
const _hoisted_20$s = { value: "beginner" };
const _hoisted_21$s = { value: "intermediate" };
const _hoisted_22$q = { value: "advanced" };
const _hoisted_23$q = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_24$p = {
  for: "duration",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_25$p = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_26$n = {
  for: "description",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_27$m = ["placeholder"];
const _hoisted_28$m = {
  class: "bg-white dark:bg-[#0f0f0f] shadow-lg rounded-xl p-6 border border-gray-200 dark:border-gray-700 animate-fade-in-up",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_29$k = { class: "text-lg font-medium text-gray-900 dark:text-white mb-6 flex items-center" };
const _hoisted_30$j = { class: "space-y-6" };
const _hoisted_31$i = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.8s" }
};
const _hoisted_32$f = {
  for: "theory",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_33$f = ["placeholder"];
const _hoisted_34$e = { class: "mt-1 text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_35$e = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.9s" }
};
const _hoisted_36$d = {
  for: "structure",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_37$c = ["placeholder"];
const _hoisted_38$c = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "1.0s" }
};
const _hoisted_39$a = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_40$a = { class: "space-y-2" };
const _hoisted_41$9 = { class: "flex-1" };
const _hoisted_42$7 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_43$7 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_44$7 = ["onClick", "disabled"];
const _hoisted_45$6 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "1.2s" }
};
const _hoisted_46$6 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_47$6 = { class: "space-y-2" };
const _hoisted_48$6 = { class: "flex-1" };
const _hoisted_49$6 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_50$6 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_51$5 = ["onClick"];
const _hoisted_52$5 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "1.4s" }
};
const _hoisted_53$5 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_54$5 = { class: "space-y-2" };
const _hoisted_55$5 = { class: "flex-1" };
const _hoisted_56$5 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_57$5 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_58$5 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_59$4 = ["onClick"];
const _hoisted_60$4 = { class: "bg-gray-50 dark:bg-[#0f0f0f] px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_61$4 = ["disabled"];
const _hoisted_62$4 = {
  key: 0,
  class: "animate-spin h-4 w-4 mr-2",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _sfc_main$O = /* @__PURE__ */ defineComponent({
  __name: "GrammarFormDialog",
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    editId: {
      type: String,
      default: ""
    }
  },
  emits: ["update:modelValue", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      const translated = params ? t(key, params) : t(key);
      const text = typeof translated === "string" ? translated : String(translated);
      if (text === key) {
        if (params) {
          return fallback.replace("{{index}}", String(params.index ?? ""));
        }
        return fallback;
      }
      return text;
    };
    const grammarStore = useGrammarStore();
    const isSubmitting = ref(false);
    const isEdit = computed(() => !!props.editId);
    watch(() => props.modelValue, (isOpen) => {
      if (isOpen) {
        document.body.style.overflow = "hidden";
      } else {
        document.body.style.overflow = "";
      }
    });
    onUnmounted(() => {
      document.body.style.overflow = "";
    });
    const categories = ref([
      "Tenses",
      "Conditionals",
      "Passive Voice",
      "Modal Verbs",
      "Reported Speech",
      "Articles",
      "Prepositions",
      "Adjectives & Adverbs",
      "Phrasal Verbs",
      "Gerunds & Infinitives"
    ]);
    const form = ref({
      title: "",
      description: "",
      level: "",
      category: "",
      duration: 30,
      theory: "",
      structure: "",
      examples: [
        { text: "", translation: "" }
      ],
      usageRules: [
        { title: "", description: "" }
      ],
      commonMistakes: [
        { wrong: "", correct: "", explanation: "" }
      ]
    });
    const resetForm = () => {
      form.value = {
        title: "",
        description: "",
        level: "",
        category: "",
        duration: 30,
        theory: "",
        structure: "",
        examples: [{ text: "", translation: "" }],
        usageRules: [{ title: "", description: "" }],
        commonMistakes: [{ wrong: "", correct: "", explanation: "" }]
      };
    };
    watch(() => props.editId, (newId) => {
      if (newId) {
        const lesson = grammarStore.getLesson(newId);
        if (lesson) {
          form.value = {
            title: lesson.title,
            description: lesson.description,
            level: lesson.level,
            category: lesson.category,
            duration: lesson.duration,
            theory: lesson.theory,
            structure: lesson.structure || "",
            examples: lesson.examples.map((ex) => ({
              text: ex.text,
              translation: ex.translation
            })),
            usageRules: lesson.usageRules?.map((rule) => ({
              title: rule.title,
              description: rule.description
            })) || [{ title: "", description: "" }],
            commonMistakes: lesson.commonMistakes?.map((mistake) => ({
              wrong: mistake.wrong,
              correct: mistake.correct,
              explanation: mistake.explanation
            })) || [{ wrong: "", correct: "", explanation: "" }]
          };
        }
      } else {
        resetForm();
      }
    }, { immediate: true });
    const addExample = () => {
      form.value.examples.push({ text: "", translation: "" });
    };
    const removeExample = (index) => {
      if (form.value.examples.length > 1) {
        form.value.examples.splice(index, 1);
      }
    };
    const addRule = () => {
      form.value.usageRules.push({ title: "", description: "" });
    };
    const removeRule = (index) => {
      form.value.usageRules.splice(index, 1);
    };
    const addMistake = () => {
      form.value.commonMistakes.push({ wrong: "", correct: "", explanation: "" });
    };
    const removeMistake = (index) => {
      form.value.commonMistakes.splice(index, 1);
    };
    const closeDialog = () => {
      emit("update:modelValue", false);
    };
    const submitForm = () => {
      isSubmitting.value = true;
      const filteredUsageRules = form.value.usageRules.filter((rule) => rule.title.trim() !== "" || rule.description.trim() !== "");
      const filteredMistakes = form.value.commonMistakes.filter((mistake) => mistake.wrong.trim() !== "" || mistake.correct.trim() !== "" || mistake.explanation.trim() !== "");
      const rules = filteredUsageRules.map((rule, index) => ({
        id: index + 1,
        title: rule.title,
        description: rule.description
      }));
      const examples = form.value.examples.map((example, index) => ({
        id: index + 1,
        text: example.text,
        translation: example.translation
      }));
      const commonMistakes = filteredMistakes.map((mistake, index) => ({
        id: index + 1,
        wrong: mistake.wrong,
        correct: mistake.correct,
        explanation: mistake.explanation
      }));
      const lessonData = {
        id: isEdit.value ? props.editId : Date.now().toString(),
        title: form.value.title,
        description: form.value.description,
        level: form.value.level,
        category: form.value.category,
        duration: form.value.duration,
        rating: isEdit.value ? grammarStore.getLesson(props.editId)?.rating || 5 : 5,
        progress: isEdit.value ? grammarStore.getLesson(props.editId)?.progress || 0 : 0,
        exercises: Math.floor(form.value.duration / 5),
        theory: form.value.theory,
        structure: form.value.structure,
        examples,
        rules,
        usageRules: filteredUsageRules,
        commonMistakes
      };
      if (isEdit.value) {
        grammarStore.updateLesson(props.editId, lessonData);
      } else {
        grammarStore.addLesson(lessonData);
      }
      setTimeout(() => {
        isSubmitting.value = false;
        emit("saved", lessonData);
        emit("update:modelValue", false);
        resetForm();
      }, 500);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            __props.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$O, [
              createBaseVNode("div", _hoisted_2$L, [
                _cache[36] || (_cache[36] = createBaseVNode("div", { class: "fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity backdrop-blur-sm" }, null, -1)),
                createVNode(Transition, {
                  "enter-active-class": "transition-all duration-500 ease-out",
                  "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                  "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                  "leave-active-class": "transition-all duration-300 ease-in",
                  "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                  "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_3$J, [
                      createBaseVNode("div", _hoisted_4$H, [
                        createBaseVNode("div", _hoisted_5$F, [
                          createBaseVNode("h3", _hoisted_6$D, [
                            _cache[7] || (_cache[7] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(isEdit.value ? unref(t)("grammar.editLesson", "Edit Lesson") : unref(t)("grammar.addNewLesson", "Add New Lesson")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: closeDialog,
                            class: "text-gray-400 hover:text-gray-500 dark:hover:text-gray-300 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[8] || (_cache[8] = [
                            createBaseVNode("svg", {
                              class: "h-6 w-6",
                              fill: "none",
                              viewBox: "0 0 24 24",
                              stroke: "currentColor"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ]),
                        createBaseVNode("form", {
                          onSubmit: withModifiers(submitForm, ["prevent"]),
                          class: "space-y-6 mt-4 max-h-[calc(100vh-200px)] overflow-y-auto px-2"
                        }, [
                          createBaseVNode("div", _hoisted_7$C, [
                            createBaseVNode("h3", _hoisted_8$C, [
                              _cache[9] || (_cache[9] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("common.title")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_9$B, [
                              createBaseVNode("div", _hoisted_10$A, [
                                createBaseVNode("label", _hoisted_11$A, [
                                  _cache[10] || (_cache[10] = createBaseVNode("span", { class: "w-1 h-3 bg-blue-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("common.title", "Title")) + " ", 1),
                                  _cache[11] || (_cache[11] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                withDirectives(createBaseVNode("input", {
                                  id: "title",
                                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => form.value.title = $event),
                                  type: "text",
                                  required: "",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 hover:border-blue-400 dark:hover:border-blue-500 transform hover:scale-[1.02]",
                                  placeholder: unref(t)("grammar.titlePlaceholder", "Enter lesson title")
                                }, null, 8, _hoisted_12$z), [
                                  [vModelText, form.value.title]
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_13$z, [
                                createBaseVNode("label", _hoisted_14$z, [
                                  _cache[12] || (_cache[12] = createBaseVNode("span", { class: "w-1 h-3 bg-green-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.category", "Category")) + " ", 1),
                                  _cache[13] || (_cache[13] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                withDirectives(createBaseVNode("select", {
                                  id: "category",
                                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => form.value.category = $event),
                                  required: "",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-300 hover:border-green-400 dark:hover:border-green-500 transform hover:scale-[1.02] cursor-pointer"
                                }, [
                                  createBaseVNode("option", _hoisted_15$v, toDisplayString$1(unref(t)("grammar.selectCategory", "Select category")), 1),
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(categories.value, (category) => {
                                    return openBlock(), createElementBlock("option", {
                                      key: category,
                                      value: category
                                    }, toDisplayString$1(category), 9, _hoisted_16$u);
                                  }), 128))
                                ], 512), [
                                  [vModelSelect, form.value.category]
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_17$u, [
                                createBaseVNode("label", _hoisted_18$t, [
                                  _cache[14] || (_cache[14] = createBaseVNode("span", { class: "w-1 h-3 bg-purple-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.level", "Level")) + " ", 1),
                                  _cache[15] || (_cache[15] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                withDirectives(createBaseVNode("select", {
                                  id: "level",
                                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => form.value.level = $event),
                                  required: "",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-300 hover:border-purple-400 dark:hover:border-purple-500 transform hover:scale-[1.02] cursor-pointer"
                                }, [
                                  createBaseVNode("option", _hoisted_19$t, toDisplayString$1(unref(t)("grammar.selectLevel", "Select level")), 1),
                                  createBaseVNode("option", _hoisted_20$s, toDisplayString$1(unref(t)("grammar.levels.beginner", "Beginner")), 1),
                                  createBaseVNode("option", _hoisted_21$s, toDisplayString$1(unref(t)("grammar.levels.intermediate", "Intermediate")), 1),
                                  createBaseVNode("option", _hoisted_22$q, toDisplayString$1(unref(t)("grammar.levels.advanced", "Advanced")), 1)
                                ], 512), [
                                  [vModelSelect, form.value.level]
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_23$q, [
                                createBaseVNode("label", _hoisted_24$p, [
                                  _cache[16] || (_cache[16] = createBaseVNode("span", { class: "w-1 h-3 bg-orange-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.durationLabel", "Duration (minutes)")) + " ", 1),
                                  _cache[17] || (_cache[17] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                withDirectives(createBaseVNode("input", {
                                  id: "duration",
                                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => form.value.duration = $event),
                                  type: "number",
                                  min: "1",
                                  required: "",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all duration-300 hover:border-orange-400 dark:hover:border-orange-500 transform hover:scale-[1.02]",
                                  placeholder: "30"
                                }, null, 512), [
                                  [
                                    vModelText,
                                    form.value.duration,
                                    void 0,
                                    { number: true }
                                  ]
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_25$p, [
                                createBaseVNode("label", _hoisted_26$n, [
                                  _cache[18] || (_cache[18] = createBaseVNode("span", { class: "w-1 h-3 bg-indigo-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.description", "Description")) + " ", 1),
                                  _cache[19] || (_cache[19] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                withDirectives(createBaseVNode("textarea", {
                                  id: "description",
                                  "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => form.value.description = $event),
                                  rows: "3",
                                  required: "",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition-all duration-300 hover:border-indigo-400 dark:hover:border-indigo-500 transform hover:scale-[1.02] resize-none",
                                  placeholder: unref(t)("grammar.descriptionPlaceholder", "Enter a brief description")
                                }, null, 8, _hoisted_27$m), [
                                  [vModelText, form.value.description]
                                ])
                              ])
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_28$m, [
                            createBaseVNode("h3", _hoisted_29$k, [
                              _cache[20] || (_cache[20] = createBaseVNode("span", { class: "w-1 h-4 bg-teal-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("grammar.lessonContent", "Lesson Content")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_30$j, [
                              createBaseVNode("div", _hoisted_31$i, [
                                createBaseVNode("label", _hoisted_32$f, [
                                  _cache[21] || (_cache[21] = createBaseVNode("span", { class: "w-1 h-3 bg-teal-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.theory", "Theory")) + " ", 1),
                                  _cache[22] || (_cache[22] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                withDirectives(createBaseVNode("textarea", {
                                  id: "theory",
                                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => form.value.theory = $event),
                                  rows: "6",
                                  required: "",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all duration-300 hover:border-teal-400 dark:hover:border-teal-500 transform hover:scale-[1.02] resize-none",
                                  placeholder: unref(t)("grammar.theoryPlaceholder", "Enter grammar theory")
                                }, null, 8, _hoisted_33$f), [
                                  [vModelText, form.value.theory]
                                ]),
                                createBaseVNode("p", _hoisted_34$e, toDisplayString$1(unref(t)("grammar.markdownSupported", "Markdown is supported")), 1)
                              ]),
                              createBaseVNode("div", _hoisted_35$e, [
                                createBaseVNode("label", _hoisted_36$d, [
                                  _cache[23] || (_cache[23] = createBaseVNode("span", { class: "w-1 h-3 bg-pink-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.structure", "Structure")) + " ", 1),
                                  _cache[24] || (_cache[24] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                withDirectives(createBaseVNode("textarea", {
                                  id: "structure",
                                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => form.value.structure = $event),
                                  rows: "4",
                                  required: "",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-transparent transition-all duration-300 hover:border-pink-400 dark:hover:border-pink-500 transform hover:scale-[1.02] resize-none",
                                  placeholder: unref(t)("grammar.structurePlaceholder", "Enter structure")
                                }, null, 8, _hoisted_37$c), [
                                  [vModelText, form.value.structure]
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_38$c, [
                                createBaseVNode("label", _hoisted_39$a, [
                                  _cache[25] || (_cache[25] = createBaseVNode("span", { class: "w-1 h-3 bg-yellow-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.examples", "Examples")) + " ", 1),
                                  _cache[26] || (_cache[26] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                createBaseVNode("div", _hoisted_40$a, [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(form.value.examples, (example, index) => {
                                    return openBlock(), createElementBlock("div", {
                                      key: index,
                                      class: "flex items-start space-x-2 animate-fade-in-up",
                                      style: normalizeStyle({ animationDelay: `${1.1 + index * 0.1}s` })
                                    }, [
                                      createBaseVNode("div", _hoisted_41$9, [
                                        withDirectives(createBaseVNode("input", {
                                          "onUpdate:modelValue": ($event) => example.text = $event,
                                          type: "text",
                                          class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent transition-all duration-300 hover:border-yellow-400 dark:hover:border-yellow-500 transform hover:scale-[1.02]",
                                          placeholder: tf("grammar.examplePlaceholder", "Example {{index}}", { index: index + 1 })
                                        }, null, 8, _hoisted_42$7), [
                                          [vModelText, example.text]
                                        ]),
                                        withDirectives(createBaseVNode("input", {
                                          "onUpdate:modelValue": ($event) => example.translation = $event,
                                          type: "text",
                                          class: "w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent transition-all duration-300 hover:border-yellow-400 dark:hover:border-yellow-500 transform hover:scale-[1.02]",
                                          placeholder: tf("grammar.translationPlaceholder", "Translation {{index}}", { index: index + 1 })
                                        }, null, 8, _hoisted_43$7), [
                                          [vModelText, example.translation]
                                        ])
                                      ]),
                                      createBaseVNode("button", {
                                        type: "button",
                                        onClick: ($event) => removeExample(index),
                                        class: "mt-2 text-red-500 hover:text-red-700 transition-all duration-300 hover:scale-110 p-1 rounded-full hover:bg-red-50 dark:hover:bg-red-900",
                                        disabled: form.value.examples.length <= 1
                                      }, _cache[27] || (_cache[27] = [
                                        createBaseVNode("svg", {
                                          class: "w-5 h-5",
                                          fill: "currentColor",
                                          viewBox: "0 0 20 20"
                                        }, [
                                          createBaseVNode("path", {
                                            "fill-rule": "evenodd",
                                            d: "M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z",
                                            "clip-rule": "evenodd"
                                          })
                                        ], -1)
                                      ]), 8, _hoisted_44$7)
                                    ], 4);
                                  }), 128))
                                ]),
                                createBaseVNode("button", {
                                  type: "button",
                                  onClick: addExample,
                                  class: "mt-2 inline-flex items-center text-sm text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 transition-all duration-300 hover:scale-105"
                                }, [
                                  _cache[28] || (_cache[28] = createBaseVNode("svg", {
                                    class: "w-4 h-4 mr-1",
                                    fill: "currentColor",
                                    viewBox: "0 0 20 20"
                                  }, [
                                    createBaseVNode("path", {
                                      "fill-rule": "evenodd",
                                      d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                                      "clip-rule": "evenodd"
                                    })
                                  ], -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.addExample", "Add example")), 1)
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_45$6, [
                                createBaseVNode("label", _hoisted_46$6, [
                                  _cache[29] || (_cache[29] = createBaseVNode("span", { class: "w-1 h-3 bg-cyan-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.usageRules", "Usage Rules")), 1)
                                ]),
                                createBaseVNode("div", _hoisted_47$6, [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(form.value.usageRules, (rule, index) => {
                                    return openBlock(), createElementBlock("div", {
                                      key: index,
                                      class: "flex items-start space-x-2 animate-fade-in-up",
                                      style: normalizeStyle({ animationDelay: `${1.3 + index * 0.1}s` })
                                    }, [
                                      createBaseVNode("div", _hoisted_48$6, [
                                        withDirectives(createBaseVNode("input", {
                                          "onUpdate:modelValue": ($event) => rule.title = $event,
                                          type: "text",
                                          class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent transition-all duration-300 hover:border-cyan-400 dark:hover:border-cyan-500 transform hover:scale-[1.02]",
                                          placeholder: tf("grammar.ruleTitlePlaceholder", "Rule {{index}} title", { index: index + 1 })
                                        }, null, 8, _hoisted_49$6), [
                                          [vModelText, rule.title]
                                        ]),
                                        withDirectives(createBaseVNode("textarea", {
                                          "onUpdate:modelValue": ($event) => rule.description = $event,
                                          rows: "2",
                                          class: "w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent transition-all duration-300 hover:border-cyan-400 dark:hover:border-cyan-500 transform hover:scale-[1.02] resize-none",
                                          placeholder: tf("grammar.ruleDescriptionPlaceholder", "Rule {{index}} description", { index: index + 1 })
                                        }, null, 8, _hoisted_50$6), [
                                          [vModelText, rule.description]
                                        ])
                                      ]),
                                      createBaseVNode("button", {
                                        type: "button",
                                        onClick: ($event) => removeRule(index),
                                        class: "mt-2 text-red-500 hover:text-red-700 transition-all duration-300 hover:scale-110 p-1 rounded-full hover:bg-red-50 dark:hover:bg-red-900"
                                      }, _cache[30] || (_cache[30] = [
                                        createBaseVNode("svg", {
                                          class: "w-5 h-5",
                                          fill: "currentColor",
                                          viewBox: "0 0 20 20"
                                        }, [
                                          createBaseVNode("path", {
                                            "fill-rule": "evenodd",
                                            d: "M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z",
                                            "clip-rule": "evenodd"
                                          })
                                        ], -1)
                                      ]), 8, _hoisted_51$5)
                                    ], 4);
                                  }), 128))
                                ]),
                                createBaseVNode("button", {
                                  type: "button",
                                  onClick: addRule,
                                  class: "mt-2 inline-flex items-center text-sm text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 transition-all duration-300 hover:scale-105"
                                }, [
                                  _cache[31] || (_cache[31] = createBaseVNode("svg", {
                                    class: "w-4 h-4 mr-1",
                                    fill: "currentColor",
                                    viewBox: "0 0 20 20"
                                  }, [
                                    createBaseVNode("path", {
                                      "fill-rule": "evenodd",
                                      d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                                      "clip-rule": "evenodd"
                                    })
                                  ], -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.addRule", "Add rule")), 1)
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_52$5, [
                                createBaseVNode("label", _hoisted_53$5, [
                                  _cache[32] || (_cache[32] = createBaseVNode("span", { class: "w-1 h-3 bg-red-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.commonMistakes", "Common Mistakes")), 1)
                                ]),
                                createBaseVNode("div", _hoisted_54$5, [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(form.value.commonMistakes, (mistake, index) => {
                                    return openBlock(), createElementBlock("div", {
                                      key: index,
                                      class: "flex items-start space-x-2 animate-fade-in-up",
                                      style: normalizeStyle({ animationDelay: `${1.5 + index * 0.1}s` })
                                    }, [
                                      createBaseVNode("div", _hoisted_55$5, [
                                        withDirectives(createBaseVNode("input", {
                                          "onUpdate:modelValue": ($event) => mistake.wrong = $event,
                                          type: "text",
                                          class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all duration-300 hover:border-red-400 dark:hover:border-red-500 transform hover:scale-[1.02]",
                                          placeholder: tf("grammar.wrongSentencePlaceholder", "Wrong sentence {{index}}", { index: index + 1 })
                                        }, null, 8, _hoisted_56$5), [
                                          [vModelText, mistake.wrong]
                                        ]),
                                        withDirectives(createBaseVNode("input", {
                                          "onUpdate:modelValue": ($event) => mistake.correct = $event,
                                          type: "text",
                                          class: "w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all duration-300 hover:border-red-400 dark:hover:border-red-500 transform hover:scale-[1.02]",
                                          placeholder: tf("grammar.correctSentencePlaceholder", "Correct sentence {{index}}", { index: index + 1 })
                                        }, null, 8, _hoisted_57$5), [
                                          [vModelText, mistake.correct]
                                        ]),
                                        withDirectives(createBaseVNode("textarea", {
                                          "onUpdate:modelValue": ($event) => mistake.explanation = $event,
                                          rows: "2",
                                          class: "w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all duration-300 hover:border-red-400 dark:hover:border-red-500 transform hover:scale-[1.02] resize-none",
                                          placeholder: tf("grammar.explanationPlaceholder", "Explanation {{index}}", { index: index + 1 })
                                        }, null, 8, _hoisted_58$5), [
                                          [vModelText, mistake.explanation]
                                        ])
                                      ]),
                                      createBaseVNode("button", {
                                        type: "button",
                                        onClick: ($event) => removeMistake(index),
                                        class: "mt-2 text-red-500 hover:text-red-700 transition-all duration-300 hover:scale-110 p-1 rounded-full hover:bg-red-50 dark:hover:bg-red-900"
                                      }, _cache[33] || (_cache[33] = [
                                        createBaseVNode("svg", {
                                          class: "w-5 h-5",
                                          fill: "currentColor",
                                          viewBox: "0 0 20 20"
                                        }, [
                                          createBaseVNode("path", {
                                            "fill-rule": "evenodd",
                                            d: "M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z",
                                            "clip-rule": "evenodd"
                                          })
                                        ], -1)
                                      ]), 8, _hoisted_59$4)
                                    ], 4);
                                  }), 128))
                                ]),
                                createBaseVNode("button", {
                                  type: "button",
                                  onClick: addMistake,
                                  class: "mt-2 inline-flex items-center text-sm text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 transition-all duration-300 hover:scale-105"
                                }, [
                                  _cache[34] || (_cache[34] = createBaseVNode("svg", {
                                    class: "w-4 h-4 mr-1",
                                    fill: "currentColor",
                                    viewBox: "0 0 20 20"
                                  }, [
                                    createBaseVNode("path", {
                                      "fill-rule": "evenodd",
                                      d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                                      "clip-rule": "evenodd"
                                    })
                                  ], -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.addMistake", "Add mistake")), 1)
                                ])
                              ])
                            ])
                          ])
                        ], 32)
                      ]),
                      createBaseVNode("div", _hoisted_60$4, [
                        createBaseVNode("button", {
                          type: "button",
                          onClick: submitForm,
                          disabled: isSubmitting.value,
                          class: "w-full inline-flex justify-center rounded-lg border border-transparent shadow-sm px-4 py-2 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-base font-medium text-white focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:ml-3 sm:w-auto sm:text-sm transition-all duration-300 hover:scale-105 hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                        }, [
                          isSubmitting.value ? (openBlock(), createElementBlock("svg", _hoisted_62$4, _cache[35] || (_cache[35] = [
                            createBaseVNode("circle", {
                              class: "opacity-25",
                              cx: "12",
                              cy: "12",
                              r: "10",
                              stroke: "currentColor",
                              "stroke-width": "4"
                            }, null, -1),
                            createBaseVNode("path", {
                              class: "opacity-75",
                              fill: "currentColor",
                              d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                            }, null, -1)
                          ]))) : createCommentVNode("", true),
                          createTextVNode(" " + toDisplayString$1(isSubmitting.value ? unref(t)("common.saving", "Saving...") : isEdit.value ? unref(t)("common.update", "Update") : unref(t)("common.save", "Save")), 1)
                        ], 8, _hoisted_61$4),
                        createBaseVNode("button", {
                          type: "button",
                          onClick: closeDialog,
                          class: "mt-3 w-full inline-flex justify-center rounded-lg border border-gray-300 dark:border-gray-600 shadow-sm px-4 py-2 bg-white dark:bg-[#0a0a0a] text-base font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:mt-0 sm:ml-3 sm:w-auto sm:text-sm transition-all duration-300 hover:scale-105 hover:shadow-lg"
                        }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1)
                      ])
                    ])
                  ]),
                  _: 1
                })
              ])
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const GrammarFormDialog = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["__scopeId", "data-v-6c037500"]]);

const GrammarFormDialog$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: GrammarFormDialog
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$N = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-white/10 p-6" };
const _hoisted_2$K = { class: "mb-6" };
const _hoisted_3$I = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_4$G = {
  key: 0,
  class: "mb-4"
};
const _hoisted_5$E = { class: "space-y-3 mb-8" };
const _hoisted_6$C = ["onClick"];
const _hoisted_7$B = { class: "flex items-center space-x-3" };
const _hoisted_8$B = { class: "text-gray-900 dark:text-white" };
const _hoisted_9$A = { class: "ml-auto" };
const _hoisted_10$z = {
  key: 0,
  class: "w-5 h-5 text-green-600 dark:text-green-400",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_11$z = {
  key: 1,
  class: "w-5 h-5 text-red-600 dark:text-red-400",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_12$y = {
  key: 0,
  class: "mb-6 p-4 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700 rounded-lg"
};
const _hoisted_13$y = { class: "font-medium text-yellow-800 dark:text-yellow-200 mb-2" };
const _hoisted_14$y = { class: "text-yellow-700 dark:text-yellow-300 text-sm" };
const _hoisted_15$u = { class: "flex justify-between items-center" };
const _hoisted_16$t = { class: "flex items-center space-x-4" };
const _hoisted_17$t = {
  key: 1,
  class: "text-sm text-blue-600 dark:text-blue-400"
};
const _hoisted_18$s = { class: "flex space-x-4" };
const _hoisted_19$s = ["disabled"];
const _sfc_main$N = /* @__PURE__ */ defineComponent({
  __name: "MultipleChoiceExercise",
  props: {
    question: {},
    questionIndex: {},
    totalQuestions: {}
  },
  emits: ["answer", "next", "complete"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      const translated = params ? t(key, params) : t(key);
      const text = typeof translated === "string" ? translated : String(translated);
      if (text === key) return fallback;
      return text;
    };
    const { playAudio } = useVoiceStore();
    const props = __props;
    const emit = __emit;
    const selectedOption = ref(null);
    const showAnswer = ref(false);
    const showHint = ref(false);
    const correctAnswerIndex = computed(() => {
      return props.question.options.findIndex((option) => option === props.question.correctAnswer);
    });
    const selectOption = (index) => {
      if (!showAnswer.value) {
        selectedOption.value = index;
      }
    };
    const checkAnswer = () => {
      if (selectedOption.value === null) return;
      showAnswer.value = true;
      const isCorrect = selectedOption.value === correctAnswerIndex.value;
      const userAnswer = props.question.options[selectedOption.value];
      emit("answer", {
        isCorrect,
        userAnswer,
        correctAnswer: props.question.correctAnswer
      });
    };
    const nextQuestion = () => {
      if (props.questionIndex === props.totalQuestions - 1) {
        emit("complete");
      } else {
        selectedOption.value = null;
        showAnswer.value = false;
        showHint.value = false;
        emit("next");
      }
    };
    const playQuestionAudio = async () => {
      if (props.question.audio) {
        try {
          await playAudio(props.question.question);
        } catch (error) {
          console.error("Error playing audio:", error);
        }
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$N, [
        createBaseVNode("div", _hoisted_2$K, [
          createBaseVNode("h3", _hoisted_3$I, toDisplayString$1(_ctx.question.question), 1),
          _ctx.question.audio ? (openBlock(), createElementBlock("div", _hoisted_4$G, [
            createBaseVNode("button", {
              onClick: playQuestionAudio,
              class: "flex items-center space-x-2 px-4 py-2 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-lg hover:bg-blue-200 dark:hover:bg-blue-900/50 transition-colors"
            }, [
              _cache[1] || (_cache[1] = createBaseVNode("svg", {
                class: "w-5 h-5",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M15.536 8.464a5 5 0 010 7.072m-2.036-5.036a2.5 2.5 0 010 3.536M6 10h4l4.5-4.5v9L10 10H6V8z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.playAudio", "Play audio")), 1)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_5$E, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.question.options, (option, index) => {
            return openBlock(), createElementBlock("div", {
              key: index,
              onClick: ($event) => selectOption(index),
              class: normalizeClass([
                "p-4 rounded-lg border-2 cursor-pointer transition-all duration-200",
                selectedOption.value === index ? "border-blue-500 bg-blue-50 dark:bg-blue-900/30" : "border-gray-200 dark:border-white/10 hover:border-gray-300 dark:hover:border-white/20 bg-gray-50 dark:bg-[#0a0a0a]/50",
                showAnswer.value && index === correctAnswerIndex.value ? "border-green-500 bg-green-50 dark:bg-green-900/30" : "",
                showAnswer.value && selectedOption.value === index && selectedOption.value !== correctAnswerIndex.value ? "border-red-500 bg-red-50 dark:bg-red-900/30" : ""
              ])
            }, [
              createBaseVNode("div", _hoisted_7$B, [
                createBaseVNode("div", {
                  class: normalizeClass([
                    "w-6 h-6 rounded-full border-2 flex items-center justify-center text-sm font-medium",
                    selectedOption.value === index ? "border-blue-500 bg-blue-500 text-white" : "border-gray-300 dark:border-white/10 text-gray-500 dark:text-white/60",
                    showAnswer.value && index === correctAnswerIndex.value ? "border-green-500 bg-green-500 text-white" : "",
                    showAnswer.value && selectedOption.value === index && selectedOption.value !== correctAnswerIndex.value ? "border-red-500 bg-red-500 text-white" : ""
                  ])
                }, toDisplayString$1(String.fromCharCode(65 + index)), 3),
                createBaseVNode("span", _hoisted_8$B, toDisplayString$1(option), 1),
                createBaseVNode("div", _hoisted_9$A, [
                  showAnswer.value && index === correctAnswerIndex.value ? (openBlock(), createElementBlock("svg", _hoisted_10$z, _cache[2] || (_cache[2] = [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M5 13l4 4L19 7"
                    }, null, -1)
                  ]))) : showAnswer.value && selectedOption.value === index && selectedOption.value !== correctAnswerIndex.value ? (openBlock(), createElementBlock("svg", _hoisted_11$z, _cache[3] || (_cache[3] = [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M6 18L18 6M6 6l12 12"
                    }, null, -1)
                  ]))) : createCommentVNode("", true)
                ])
              ])
            ], 10, _hoisted_6$C);
          }), 128))
        ]),
        showAnswer.value && _ctx.question.explanation ? (openBlock(), createElementBlock("div", _hoisted_12$y, [
          createBaseVNode("h4", _hoisted_13$y, toDisplayString$1(tf("grammar.practice.explanation", "Explanation")), 1),
          createBaseVNode("p", _hoisted_14$y, toDisplayString$1(_ctx.question.explanation), 1)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_15$u, [
          createBaseVNode("div", _hoisted_16$t, [
            !showAnswer.value && _ctx.question.hint ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: _cache[0] || (_cache[0] = ($event) => showHint.value = !showHint.value),
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-gray-600 dark:text-white/60 hover:text-gray-800 dark:hover:text-white/80 transition-colors"
            }, [
              _cache[4] || (_cache[4] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.hint", "Hint")), 1)
            ])) : createCommentVNode("", true),
            showHint.value && _ctx.question.hint ? (openBlock(), createElementBlock("div", _hoisted_17$t, " 💡 " + toDisplayString$1(_ctx.question.hint), 1)) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_18$s, [
            !showAnswer.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: checkAnswer,
              disabled: selectedOption.value === null,
              class: "px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            }, toDisplayString$1(tf("grammar.practice.checkAnswer", "Check answer")), 9, _hoisted_19$s)) : (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: nextQuestion,
              class: "px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            }, toDisplayString$1(_ctx.questionIndex === _ctx.totalQuestions - 1 ? tf("grammar.practice.finish", "Finish") : tf("grammar.practice.next", "Next")), 1))
          ])
        ])
      ]);
    };
  }
});

const MultipleChoiceExercise = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$N
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$M = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-white/10 p-6" };
const _hoisted_2$J = { class: "mb-6" };
const _hoisted_3$H = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_4$F = { class: "bg-gray-50 dark:bg-[#0a0a0a]/50 rounded-lg p-4 mb-4" };
const _hoisted_5$D = { class: "text-lg leading-relaxed text-gray-900 dark:text-white" };
const _hoisted_6$B = { key: 0 };
const _hoisted_7$A = ["onUpdate:modelValue", "placeholder", "disabled"];
const _hoisted_8$A = {
  key: 0,
  class: "mb-4"
};
const _hoisted_9$z = { class: "text-sm font-medium text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_10$y = { class: "flex flex-wrap gap-2" };
const _hoisted_11$y = ["onClick", "disabled"];
const _hoisted_12$x = {
  key: 1,
  class: "mb-4"
};
const _hoisted_13$x = {
  key: 0,
  class: "mb-6 space-y-4"
};
const _hoisted_14$x = { class: "p-4 bg-green-50 dark:bg-green-900/30 border border-green-200 dark:border-green-700 rounded-lg" };
const _hoisted_15$t = { class: "font-medium text-green-800 dark:text-green-200 mb-2" };
const _hoisted_16$s = { class: "text-lg leading-relaxed text-green-700 dark:text-green-300" };
const _hoisted_17$s = { key: 0 };
const _hoisted_18$r = {
  key: 1,
  class: "inline-block mx-1 px-2 py-1 bg-green-100 dark:bg-green-800 rounded border font-medium"
};
const _hoisted_19$r = {
  key: 0,
  class: "p-4 bg-red-50 dark:bg-red-900/30 border border-red-200 dark:border-red-700 rounded-lg"
};
const _hoisted_20$r = { class: "font-medium text-red-800 dark:text-red-200 mb-2" };
const _hoisted_21$r = { class: "text-lg leading-relaxed text-red-700 dark:text-red-300" };
const _hoisted_22$p = { key: 0 };
const _hoisted_23$p = {
  key: 1,
  class: "mb-6 p-4 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700 rounded-lg"
};
const _hoisted_24$o = { class: "font-medium text-yellow-800 dark:text-yellow-200 mb-2" };
const _hoisted_25$o = { class: "text-yellow-700 dark:text-yellow-300 text-sm" };
const _hoisted_26$m = { class: "flex justify-between items-center" };
const _hoisted_27$l = { class: "flex items-center space-x-4" };
const _hoisted_28$l = {
  key: 1,
  class: "text-sm text-blue-600 dark:text-blue-400"
};
const _hoisted_29$j = { class: "flex space-x-4" };
const _hoisted_30$i = ["disabled"];
const _sfc_main$M = /* @__PURE__ */ defineComponent({
  __name: "FillBlankExercise",
  props: {
    question: {},
    questionIndex: {},
    totalQuestions: {}
  },
  emits: ["answer", "next", "complete"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      try {
        const translated = t(key, params);
        return typeof translated === "string" && translated !== key ? translated : fallback;
      } catch {
        return fallback;
      }
    };
    const { playAudio } = useVoiceStore();
    const props = __props;
    const emit = __emit;
    const userAnswers = ref([]);
    const showAnswer = ref(false);
    const showHint = ref(false);
    const focusedBlankIndex = ref(null);
    const sentenceParts = computed(() => {
      if (!props.question?.sentence) return [];
      const parts = [];
      const regex = /___+/g;
      let lastIndex = 0;
      let match;
      let blankIndex = 0;
      while ((match = regex.exec(props.question.sentence)) !== null) {
        if (match.index > lastIndex) {
          parts.push({
            type: "text",
            content: props.question.sentence.slice(lastIndex, match.index)
          });
        }
        parts.push({
          type: "blank",
          index: blankIndex++
        });
        lastIndex = regex.lastIndex;
      }
      if (lastIndex < props.question.sentence.length) {
        parts.push({
          type: "text",
          content: props.question.sentence.slice(lastIndex)
        });
      }
      return parts;
    });
    const hasAllAnswers = computed(() => {
      if (!props.question?.correctAnswers) return false;
      return userAnswers.value.length === props.question.correctAnswers.length && userAnswers.value.every((answer) => answer && answer.trim() !== "");
    });
    const hasIncorrectAnswers = computed(() => {
      if (!props.question?.correctAnswers) return false;
      return userAnswers.value.some(
        (answer, index) => answer.toLowerCase().trim() !== props.question.correctAnswers[index].toLowerCase().trim()
      );
    });
    const correctCount = computed(() => {
      if (!props.question?.correctAnswers) return 0;
      return userAnswers.value.filter(
        (answer, index) => answer.toLowerCase().trim() === props.question.correctAnswers[index].toLowerCase().trim()
      ).length;
    });
    const isBlankPart = (part) => {
      return part.type === "blank";
    };
    const isAnswerCorrect = (index) => {
      if (!showAnswer.value || !userAnswers.value[index] || !props.question?.correctAnswers?.[index]) return false;
      return userAnswers.value[index].toLowerCase().trim() === props.question.correctAnswers[index].toLowerCase().trim();
    };
    const insertWord = (word) => {
      if (focusedBlankIndex.value !== null) {
        userAnswers.value[focusedBlankIndex.value] = word;
      } else {
        const emptyIndex = userAnswers.value.findIndex((answer) => !answer || answer.trim() === "");
        if (emptyIndex !== -1) {
          userAnswers.value[emptyIndex] = word;
        }
      }
    };
    const clearAnswers = () => {
      userAnswers.value = [];
    };
    const checkAnswer = () => {
      if (!hasAllAnswers.value || !props.question?.correctAnswers) return;
      showAnswer.value = true;
      const isCorrect = correctCount.value === props.question.correctAnswers.length;
      emit("answer", {
        isCorrect,
        userAnswer: [...userAnswers.value],
        correctAnswer: [...props.question.correctAnswers]
      });
    };
    const nextQuestion = () => {
      if (props.questionIndex === props.totalQuestions - 1) {
        emit("complete");
      } else {
        userAnswers.value = [];
        showAnswer.value = false;
        showHint.value = false;
        focusedBlankIndex.value = null;
        emit("next");
      }
    };
    const playSentenceAudio = async () => {
      try {
        let completeSentence = props.question.sentence;
        props.question.correctAnswers.forEach((answer, index) => {
          completeSentence = completeSentence.replace(/___+/, answer);
        });
        await playAudio(completeSentence);
      } catch (error) {
        console.error("Error playing audio:", error);
      }
    };
    watch(() => props.question, (newQuestion) => {
      if (newQuestion && newQuestion.correctAnswers && newQuestion.correctAnswers.length > 0) {
        userAnswers.value = new Array(newQuestion.correctAnswers.length).fill("");
      }
    }, { immediate: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$M, [
        createBaseVNode("div", _hoisted_2$J, [
          createBaseVNode("h3", _hoisted_3$H, toDisplayString$1(tf("grammar.practice.fillBlank.instruction", "Fill in the blanks")), 1),
          createBaseVNode("div", _hoisted_4$F, [
            createBaseVNode("div", _hoisted_5$D, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(sentenceParts.value, (part, index) => {
                return openBlock(), createElementBlock("span", { key: index }, [
                  part.type === "text" ? (openBlock(), createElementBlock("span", _hoisted_6$B, toDisplayString$1(part.content), 1)) : part.type === "blank" ? withDirectives((openBlock(), createElementBlock("input", {
                    key: 1,
                    "onUpdate:modelValue": ($event) => userAnswers.value[part.index] = $event,
                    class: normalizeClass([
                      "inline-block mx-1 px-3 py-1 border-b-2 bg-transparent text-center min-w-20 focus:outline-none transition-colors",
                      showAnswer.value ? isAnswerCorrect(part.index) ? "border-green-500 text-green-600 dark:text-green-400" : "border-red-500 text-red-600 dark:text-red-400" : "border-blue-500 focus:border-blue-600"
                    ]),
                    placeholder: `(${part.index + 1})`,
                    disabled: showAnswer.value
                  }, null, 10, _hoisted_7$A)), [
                    [vModelText, userAnswers.value[part.index]]
                  ]) : createCommentVNode("", true)
                ]);
              }), 128))
            ])
          ]),
          _ctx.question.wordBank && _ctx.question.wordBank.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_8$A, [
            createBaseVNode("h4", _hoisted_9$z, toDisplayString$1(tf("grammar.practice.fillBlank.wordBank", "Word bank")), 1),
            createBaseVNode("div", _hoisted_10$y, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.question.wordBank, (word) => {
                return openBlock(), createElementBlock("button", {
                  key: word,
                  onClick: ($event) => insertWord(word),
                  disabled: showAnswer.value,
                  class: "px-3 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-lg hover:bg-blue-200 dark:hover:bg-blue-900/50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                }, toDisplayString$1(word), 9, _hoisted_11$y);
              }), 128))
            ])
          ])) : createCommentVNode("", true),
          _ctx.question.audio ? (openBlock(), createElementBlock("div", _hoisted_12$x, [
            createBaseVNode("button", {
              onClick: playSentenceAudio,
              class: "flex items-center space-x-2 px-4 py-2 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-lg hover:bg-blue-200 dark:hover:bg-blue-900/50 transition-colors"
            }, [
              _cache[1] || (_cache[1] = createBaseVNode("svg", {
                class: "w-5 h-5",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M15.536 8.464a5 5 0 010 7.072m-2.036-5.036a2.5 2.5 0 010 3.536M6 10h4l4.5-4.5v9L10 10H6V8z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.playAudio", "Play audio")), 1)
            ])
          ])) : createCommentVNode("", true)
        ]),
        showAnswer.value ? (openBlock(), createElementBlock("div", _hoisted_13$x, [
          createBaseVNode("div", _hoisted_14$x, [
            createBaseVNode("h4", _hoisted_15$t, toDisplayString$1(tf("grammar.practice.correctAnswers", "Correct answers")), 1),
            createBaseVNode("div", _hoisted_16$s, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(sentenceParts.value, (part, index) => {
                return openBlock(), createElementBlock("span", {
                  key: `correct-${index}`
                }, [
                  part.type === "text" ? (openBlock(), createElementBlock("span", _hoisted_17$s, toDisplayString$1(part.content), 1)) : part.type === "blank" ? (openBlock(), createElementBlock("span", _hoisted_18$r, toDisplayString$1(_ctx.question.correctAnswers[part.index]), 1)) : createCommentVNode("", true)
                ]);
              }), 128))
            ])
          ]),
          hasIncorrectAnswers.value ? (openBlock(), createElementBlock("div", _hoisted_19$r, [
            createBaseVNode("h4", _hoisted_20$r, toDisplayString$1(tf("grammar.practice.yourAnswers", "Your answers")), 1),
            createBaseVNode("div", _hoisted_21$r, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(sentenceParts.value, (part, index) => {
                return openBlock(), createElementBlock("span", {
                  key: `user-${index}`
                }, [
                  part.type === "text" ? (openBlock(), createElementBlock("span", _hoisted_22$p, toDisplayString$1(part.content), 1)) : isBlankPart(part) ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass([
                      "inline-block mx-1 px-2 py-1 rounded border font-medium",
                      isAnswerCorrect(part.index) ? "bg-green-100 dark:bg-green-800 text-green-700 dark:text-green-300" : "bg-red-100 dark:bg-red-800 text-red-700 dark:text-red-300"
                    ])
                  }, toDisplayString$1(userAnswers.value[part.index] || "(empty)"), 3)) : createCommentVNode("", true)
                ]);
              }), 128))
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        showAnswer.value && _ctx.question.explanation ? (openBlock(), createElementBlock("div", _hoisted_23$p, [
          createBaseVNode("h4", _hoisted_24$o, toDisplayString$1(tf("grammar.practice.explanation", "Explanation")), 1),
          createBaseVNode("p", _hoisted_25$o, toDisplayString$1(_ctx.question.explanation), 1)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_26$m, [
          createBaseVNode("div", _hoisted_27$l, [
            !showAnswer.value && _ctx.question.hint ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: _cache[0] || (_cache[0] = ($event) => showHint.value = !showHint.value),
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-gray-600 dark:text-white/60 hover:text-gray-800 dark:hover:text-white transition-colors"
            }, [
              _cache[2] || (_cache[2] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.hint", "Hint")), 1)
            ])) : createCommentVNode("", true),
            showHint.value && _ctx.question.hint ? (openBlock(), createElementBlock("div", _hoisted_28$l, " 💡 " + toDisplayString$1(_ctx.question.hint), 1)) : createCommentVNode("", true),
            !showAnswer.value ? (openBlock(), createElementBlock("button", {
              key: 2,
              onClick: clearAnswers,
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-gray-600 dark:text-white/60 hover:text-gray-800 dark:hover:text-white transition-colors"
            }, [
              _cache[3] || (_cache[3] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.clear", "Clear")), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_29$j, [
            !showAnswer.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: checkAnswer,
              disabled: !hasAllAnswers.value,
              class: "px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 dark:disabled:bg-white/20 disabled:cursor-not-allowed transition-colors"
            }, toDisplayString$1(tf("grammar.practice.checkAnswer", "Check answer")), 9, _hoisted_30$i)) : (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: nextQuestion,
              class: "px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            }, toDisplayString$1(_ctx.questionIndex === _ctx.totalQuestions - 1 ? tf("grammar.practice.finish", "Finish") : tf("grammar.practice.next", "Next")), 1))
          ])
        ])
      ]);
    };
  }
});

const FillBlankExercise = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$M
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$L = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-white/10 p-6" };
const _hoisted_2$I = { class: "mb-6" };
const _hoisted_3$G = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_4$E = { class: "bg-gray-50 dark:bg-[#0a0a0a]/50 rounded-lg p-4 mb-4" };
const _hoisted_5$C = { class: "text-center" };
const _hoisted_6$A = { class: "text-2xl font-bold text-gray-900 dark:text-white mb-2" };
const _hoisted_7$z = {
  key: 0,
  class: "text-lg text-blue-600 dark:text-blue-400 mb-4"
};
const _hoisted_8$z = { class: "text-center" };
const _hoisted_9$y = { class: "mb-6" };
const _hoisted_10$x = { class: "text-center" };
const _hoisted_11$x = ["disabled"];
const _hoisted_12$w = {
  key: 0,
  class: "w-10 h-10 text-gray-600 dark:text-white/60",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_13$w = {
  key: 1,
  class: "w-10 h-10 text-red-600",
  fill: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_14$w = {
  key: 2,
  class: "w-10 h-10 text-blue-600 animate-spin",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _hoisted_15$s = { class: "text-sm text-gray-600 dark:text-white/60 mb-2" };
const _hoisted_16$r = {
  key: 0,
  class: "text-lg font-mono text-blue-600 dark:text-blue-400"
};
const _hoisted_17$r = {
  key: 0,
  class: "mb-6"
};
const _hoisted_18$q = { class: "bg-blue-50 dark:bg-blue-900/30 rounded-lg p-4" };
const _hoisted_19$q = { class: "flex items-center justify-between" };
const _hoisted_20$q = { class: "flex items-center space-x-3" };
const _hoisted_21$q = { class: "text-blue-700 dark:text-blue-300 font-medium" };
const _hoisted_22$o = {
  key: 1,
  class: "mb-6"
};
const _hoisted_23$o = { class: "flex items-center justify-between mb-3" };
const _hoisted_24$n = { class: "w-full bg-gray-200 dark:bg-white/10 rounded-full h-3 mb-3" };
const _hoisted_25$n = {
  key: 2,
  class: "mb-6"
};
const _hoisted_26$l = {
  key: 0,
  class: "mt-3 p-4 bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded-lg"
};
const _hoisted_27$k = { class: "space-y-2" };
const _hoisted_28$k = { class: "flex justify-between items-center" };
const _hoisted_29$i = { class: "flex space-x-4" };
const _hoisted_30$h = { class: "flex space-x-4" };
const _hoisted_31$h = ["disabled"];
const _sfc_main$L = /* @__PURE__ */ defineComponent({
  __name: "PronunciationExercise",
  props: {
    question: {},
    questionIndex: {},
    totalQuestions: {}
  },
  emits: ["answer", "next", "complete"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      try {
        const translated = t(key, params);
        return typeof translated === "string" && translated !== key ? translated : fallback;
      } catch {
        return fallback;
      }
    };
    const { playAudio } = useVoiceStore();
    const props = __props;
    const emit = __emit;
    const isMounted = ref(true);
    const isRecording = ref(false);
    const isProcessing = ref(false);
    const recordedAudio = ref(null);
    const recordingDuration = ref(0);
    const pronunciationScore = ref(null);
    const showTips = ref(false);
    const mediaRecorder = ref(null);
    const audioChunks = ref([]);
    const recordingTimer = ref(null);
    const recordingStatus = computed(() => {
      if (isProcessing.value) return tf("grammar.practice.pronunciation.processing", "Processing...");
      if (isRecording.value) return tf("grammar.practice.pronunciation.recording", "Recording...");
      if (recordedAudio.value) return tf("grammar.practice.pronunciation.recorded", "Recorded");
      return tf("grammar.practice.pronunciation.ready", "Ready to record");
    });
    const toggleRecording = async () => {
      if (!isRecording.value) {
        await startRecording();
      } else {
        stopRecording();
      }
    };
    const startRecording = async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder.value = new MediaRecorder(stream);
        audioChunks.value = [];
        recordingDuration.value = 0;
        mediaRecorder.value.ondataavailable = (event) => {
          audioChunks.value.push(event.data);
        };
        mediaRecorder.value.onstop = () => {
          const audioBlob = new Blob(audioChunks.value, { type: "audio/wav" });
          recordedAudio.value = audioBlob;
          stream.getTracks().forEach((track) => track.stop());
        };
        mediaRecorder.value.start();
        isRecording.value = true;
        recordingTimer.value = setInterval(() => {
          recordingDuration.value += 1;
          if (recordingDuration.value >= 10) {
            stopRecording();
          }
        }, 1e3);
      } catch (error) {
        console.error("Error accessing microphone:", error);
        alert(tf("grammar.practice.pronunciation.microphoneError", "Unable to access microphone. Please check your browser permissions and try again."));
      }
    };
    const stopRecording = () => {
      if (mediaRecorder.value && mediaRecorder.value.state !== "inactive") {
        mediaRecorder.value.stop();
      }
      isRecording.value = false;
      if (recordingTimer.value) {
        clearInterval(recordingTimer.value);
        recordingTimer.value = null;
      }
    };
    const playTargetAudio = async () => {
      try {
        await playAudio(props.question.targetText);
      } catch (error) {
        console.error("Error playing target audio:", error);
      }
    };
    const playRecordedAudio = () => {
      if (recordedAudio.value) {
        const audio = new Audio(URL.createObjectURL(recordedAudio.value));
        audio.play();
      }
    };
    const clearRecording = () => {
      recordedAudio.value = null;
      recordingDuration.value = 0;
      pronunciationScore.value = null;
    };
    const analyzePronunciation = async () => {
      if (!recordedAudio.value) return;
      isProcessing.value = true;
      try {
        await new Promise((resolve) => setTimeout(resolve, 2e3));
        const mockScore = Math.floor(Math.random() * 40) + 60;
        pronunciationScore.value = mockScore;
        emit("answer", {
          isCorrect: mockScore >= 70,
          score: mockScore,
          targetText: props.question.targetText
        });
      } catch (error) {
        console.error("Error analyzing pronunciation:", error);
      } finally {
        isProcessing.value = false;
      }
    };
    const getFeedbackMessage = () => {
      if (pronunciationScore.value === null) return "";
      if (pronunciationScore.value >= 90) {
        return tf("grammar.practice.pronunciation.excellent", "Excellent pronunciation!");
      } else if (pronunciationScore.value >= 80) {
        return tf("grammar.practice.pronunciation.good", "Good pronunciation!");
      } else if (pronunciationScore.value >= 70) {
        return tf("grammar.practice.pronunciation.fair", "Fair pronunciation. Keep practicing!");
      } else {
        return tf("grammar.practice.pronunciation.needsImprovement", "Needs improvement. Try again!");
      }
    };
    const resetExercise = () => {
      clearRecording();
      showTips.value = false;
    };
    const nextQuestion = () => {
      if (props.questionIndex === props.totalQuestions - 1) {
        emit("complete");
      } else {
        resetExercise();
        emit("next");
      }
    };
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    };
    onUnmounted(() => {
      isMounted.value = false;
      if (recordingTimer.value) {
        clearInterval(recordingTimer.value);
        recordingTimer.value = null;
      }
      if (mediaRecorder.value && mediaRecorder.value.state !== "inactive") {
        try {
          mediaRecorder.value.stop();
        } catch (error) {
          console.warn("Error stopping media recorder:", error);
        }
      }
      mediaRecorder.value = null;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$L, [
        createBaseVNode("div", _hoisted_2$I, [
          createBaseVNode("h3", _hoisted_3$G, toDisplayString$1(tf("grammar.practice.pronunciation.instruction", "Pronounce the following correctly")), 1),
          createBaseVNode("div", _hoisted_4$E, [
            createBaseVNode("div", _hoisted_5$C, [
              createBaseVNode("div", _hoisted_6$A, toDisplayString$1(_ctx.question.targetText), 1),
              _ctx.question.phonetic ? (openBlock(), createElementBlock("div", _hoisted_7$z, toDisplayString$1(_ctx.question.phonetic), 1)) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_8$z, [
              createBaseVNode("button", {
                onClick: playTargetAudio,
                class: "inline-flex items-center space-x-2 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
              }, [
                _cache[1] || (_cache[1] = createBaseVNode("svg", {
                  class: "w-5 h-5",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M15.536 8.464a5 5 0 010 7.072m-2.036-5.036a2.5 2.5 0 010 3.536M6 10h4l4.5-4.5v9L10 10H6V8z"
                  })
                ], -1)),
                createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.pronunciation.listen", "Listen")), 1)
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_9$y, [
          createBaseVNode("div", _hoisted_10$x, [
            createBaseVNode("button", {
              onClick: toggleRecording,
              disabled: isProcessing.value,
              class: normalizeClass([
                "w-24 h-24 rounded-full border-4 flex items-center justify-center transition-all duration-200 mb-4",
                isRecording.value ? "border-red-500 bg-red-100 dark:bg-red-900/30 animate-pulse" : "border-gray-300 dark:border-white/10 bg-gray-100 dark:bg-[#0a0a0a] hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/30",
                isProcessing.value ? "opacity-50 cursor-not-allowed" : "cursor-pointer"
              ])
            }, [
              !isRecording.value && !isProcessing.value ? (openBlock(), createElementBlock("svg", _hoisted_12$w, _cache[2] || (_cache[2] = [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"
                }, null, -1)
              ]))) : isRecording.value ? (openBlock(), createElementBlock("svg", _hoisted_13$w, _cache[3] || (_cache[3] = [
                createBaseVNode("rect", {
                  x: "6",
                  y: "6",
                  width: "12",
                  height: "12",
                  rx: "2"
                }, null, -1)
              ]))) : (openBlock(), createElementBlock("svg", _hoisted_14$w, _cache[4] || (_cache[4] = [
                createBaseVNode("circle", {
                  class: "opacity-25",
                  cx: "12",
                  cy: "12",
                  r: "10",
                  stroke: "currentColor",
                  "stroke-width": "4"
                }, null, -1),
                createBaseVNode("path", {
                  class: "opacity-75",
                  fill: "currentColor",
                  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                }, null, -1)
              ])))
            ], 10, _hoisted_11$x),
            createBaseVNode("div", _hoisted_15$s, toDisplayString$1(recordingStatus.value), 1),
            isRecording.value || recordingDuration.value > 0 ? (openBlock(), createElementBlock("div", _hoisted_16$r, toDisplayString$1(formatTime(recordingDuration.value)), 1)) : createCommentVNode("", true)
          ])
        ]),
        recordedAudio.value && !isRecording.value ? (openBlock(), createElementBlock("div", _hoisted_17$r, [
          createBaseVNode("div", _hoisted_18$q, [
            createBaseVNode("div", _hoisted_19$q, [
              createBaseVNode("div", _hoisted_20$q, [
                createBaseVNode("button", {
                  onClick: playRecordedAudio,
                  class: "p-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
                }, _cache[5] || (_cache[5] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M14.828 14.828a4 4 0 01-5.656 0M9 10h1m4 0h1m-6 4h8m2-10V9a2 2 0 01-2 2H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2z"
                    })
                  ], -1)
                ])),
                createBaseVNode("span", _hoisted_21$q, toDisplayString$1(tf("grammar.practice.pronunciation.yourRecording", "Your recording")), 1)
              ]),
              createBaseVNode("button", {
                onClick: clearRecording,
                class: "p-2 text-gray-500 dark:text-white/60 hover:text-red-600 dark:hover:text-red-400 transition-colors"
              }, _cache[6] || (_cache[6] = [
                createBaseVNode("svg", {
                  class: "w-5 h-5",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                  })
                ], -1)
              ]))
            ])
          ])
        ])) : createCommentVNode("", true),
        pronunciationScore.value !== null ? (openBlock(), createElementBlock("div", _hoisted_22$o, [
          createBaseVNode("div", {
            class: normalizeClass([
              "p-4 rounded-lg border",
              pronunciationScore.value >= 80 ? "bg-green-50 dark:bg-green-900/30 border-green-200 dark:border-green-700" : pronunciationScore.value >= 60 ? "bg-yellow-50 dark:bg-yellow-900/30 border-yellow-200 dark:border-yellow-700" : "bg-red-50 dark:bg-red-900/30 border-red-200 dark:border-red-700"
            ])
          }, [
            createBaseVNode("div", _hoisted_23$o, [
              createBaseVNode("h4", {
                class: normalizeClass([
                  "font-medium",
                  pronunciationScore.value >= 80 ? "text-green-800 dark:text-green-200" : pronunciationScore.value >= 60 ? "text-yellow-800 dark:text-yellow-200" : "text-red-800 dark:text-red-200"
                ])
              }, toDisplayString$1(unref(t)("grammar.practice.pronunciation.feedback")), 3),
              createBaseVNode("div", {
                class: normalizeClass([
                  "text-2xl font-bold",
                  pronunciationScore.value >= 80 ? "text-green-600 dark:text-green-400" : pronunciationScore.value >= 60 ? "text-yellow-600 dark:text-yellow-400" : "text-red-600 dark:text-red-400"
                ])
              }, toDisplayString$1(pronunciationScore.value) + "% ", 3)
            ]),
            createBaseVNode("div", _hoisted_24$n, [
              createBaseVNode("div", {
                class: normalizeClass([
                  "h-3 rounded-full transition-all duration-500",
                  pronunciationScore.value >= 80 ? "bg-green-600" : pronunciationScore.value >= 60 ? "bg-yellow-600" : "bg-red-600"
                ]),
                style: normalizeStyle({ width: `${pronunciationScore.value}%` })
              }, null, 6)
            ]),
            createBaseVNode("p", {
              class: normalizeClass([
                "text-sm",
                pronunciationScore.value >= 80 ? "text-green-700 dark:text-green-300" : pronunciationScore.value >= 60 ? "text-yellow-700 dark:text-yellow-300" : "text-red-700 dark:text-red-300"
              ])
            }, toDisplayString$1(getFeedbackMessage()), 3)
          ], 2)
        ])) : createCommentVNode("", true),
        _ctx.question.tips && _ctx.question.tips.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_25$n, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => showTips.value = !showTips.value),
            class: "flex items-center space-x-2 text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 transition-colors"
          }, [
            _cache[7] || (_cache[7] = createBaseVNode("svg", {
              class: "w-5 h-5",
              fill: "none",
              stroke: "currentColor",
              viewBox: "0 0 24 24"
            }, [
              createBaseVNode("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
              })
            ], -1)),
            createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.pronunciation.tips", "Tips")), 1)
          ]),
          showTips.value ? (openBlock(), createElementBlock("div", _hoisted_26$l, [
            createBaseVNode("ul", _hoisted_27$k, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.question.tips, (tip) => {
                return openBlock(), createElementBlock("li", {
                  key: tip,
                  class: "text-sm text-blue-700 dark:text-blue-300 flex items-start space-x-2"
                }, [
                  _cache[8] || (_cache[8] = createBaseVNode("span", { class: "text-blue-500 mt-1" }, "•", -1)),
                  createBaseVNode("span", null, toDisplayString$1(tip), 1)
                ]);
              }), 128))
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_28$k, [
          createBaseVNode("div", _hoisted_29$i, [
            pronunciationScore.value !== null && pronunciationScore.value < 80 ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: resetExercise,
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 transition-colors"
            }, [
              _cache[9] || (_cache[9] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.pronunciation.tryAgain", "Try again")), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_30$h, [
            pronunciationScore.value === null ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: analyzePronunciation,
              disabled: !recordedAudio.value,
              class: "px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            }, toDisplayString$1(tf("grammar.practice.pronunciation.analyze", "Analyze pronunciation")), 9, _hoisted_31$h)) : (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: nextQuestion,
              class: "px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            }, toDisplayString$1(_ctx.questionIndex === _ctx.totalQuestions - 1 ? tf("grammar.practice.finish", "Finish") : tf("grammar.practice.next", "Next")), 1))
          ])
        ])
      ]);
    };
  }
});

const PronunciationExercise = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$L
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$K = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-white/10 p-6" };
const _hoisted_2$H = { class: "mb-8" };
const _hoisted_3$F = { class: "flex items-center justify-between mb-4" };
const _hoisted_4$D = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_5$B = { class: "flex items-center space-x-4" };
const _hoisted_6$z = { class: "text-sm text-gray-500 dark:text-white/60" };
const _hoisted_7$y = { class: "bg-gray-50 dark:bg-[#0a0a0a]/50 rounded-lg p-6 max-h-96 overflow-y-auto" };
const _hoisted_8$y = { class: "prose dark:prose-invert max-w-none" };
const _hoisted_9$x = ["innerHTML"];
const _hoisted_10$w = { class: "space-y-6" };
const _hoisted_11$w = { class: "text-lg font-semibold text-gray-900 dark:text-white border-b border-gray-200 dark:border-white/10 pb-2" };
const _hoisted_12$v = { class: "space-y-6" };
const _hoisted_13$v = { class: "mb-4" };
const _hoisted_14$v = { class: "font-medium text-gray-900 dark:text-white mb-2" };
const _hoisted_15$r = {
  key: 0,
  class: "space-y-2"
};
const _hoisted_16$q = ["name", "value", "onUpdate:modelValue", "disabled"];
const _hoisted_17$q = { class: "text-gray-900 dark:text-white" };
const _hoisted_18$p = { class: "ml-auto" };
const _hoisted_19$p = {
  key: 0,
  class: "w-5 h-5 text-green-600 dark:text-green-400",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_20$p = {
  key: 1,
  class: "w-5 h-5 text-red-600 dark:text-red-400",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_21$p = {
  key: 1,
  class: "space-y-2"
};
const _hoisted_22$n = ["name", "value", "onUpdate:modelValue", "disabled"];
const _hoisted_23$n = { class: "text-gray-900 dark:text-white" };
const _hoisted_24$m = {
  key: 2,
  class: "space-y-2"
};
const _hoisted_25$m = ["onUpdate:modelValue", "disabled", "placeholder"];
const _hoisted_26$k = {
  key: 0,
  class: "text-sm text-green-600 dark:text-green-400"
};
const _hoisted_27$j = {
  key: 0,
  class: "mt-4 p-3 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700 rounded-lg"
};
const _hoisted_28$j = { class: "text-sm text-yellow-800 dark:text-yellow-200" };
const _hoisted_29$h = {
  key: 0,
  class: "mt-8 p-4 bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded-lg"
};
const _hoisted_30$g = { class: "grid grid-cols-3 gap-4 text-center" };
const _hoisted_31$g = { class: "text-2xl font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_32$e = { class: "text-sm text-gray-600 dark:text-white/60" };
const _hoisted_33$e = { class: "text-2xl font-bold text-red-600 dark:text-red-400" };
const _hoisted_34$d = { class: "text-sm text-gray-600 dark:text-white/60" };
const _hoisted_35$d = { class: "text-2xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_36$c = { class: "text-sm text-gray-600 dark:text-white/60" };
const _hoisted_37$b = { class: "flex justify-between items-center mt-8" };
const _hoisted_38$b = { class: "flex space-x-4" };
const _hoisted_39$9 = { class: "flex items-center space-x-2 text-sm text-gray-600 dark:text-white/60" };
const _hoisted_40$9 = { class: "flex space-x-4" };
const _hoisted_41$8 = ["disabled"];
const _sfc_main$K = /* @__PURE__ */ defineComponent({
  __name: "ReadingExercise",
  props: {
    question: {},
    questionIndex: {},
    totalQuestions: {}
  },
  emits: ["answer", "next", "complete"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      try {
        const translated = t(key, params);
        return typeof translated === "string" && translated !== key ? translated : fallback;
      } catch {
        return fallback;
      }
    };
    const { playAudio } = useVoiceStore();
    const props = __props;
    const emit = __emit;
    const userAnswers = ref([]);
    const showAnswers = ref(false);
    const showHighlights = ref(false);
    const readingTime = ref(0);
    const timer = ref(null);
    const formattedPassage = computed(() => {
      let passage = props.question.passage;
      if (showHighlights.value && props.question.keywords) {
        props.question.keywords.forEach((keyword) => {
          const regex = new RegExp(`\\b${keyword}\\b`, "gi");
          passage = passage.replace(regex, `<mark class="bg-yellow-200 dark:bg-yellow-700 px-1 rounded">${keyword}</mark>`);
        });
      }
      return passage;
    });
    const hasAllAnswers = computed(() => {
      if (!props.question?.questions) return false;
      return userAnswers.value.length === props.question.questions.length && userAnswers.value.every((answer) => answer !== null && answer !== void 0 && answer !== "");
    });
    const correctAnswers = computed(() => {
      if (!props.question?.questions) return 0;
      return props.question.questions.filter((q, index) => {
        if (q.type === "short-answer") {
          return isShortAnswerCorrect(index);
        }
        return userAnswers.value[index] === q.correctAnswer;
      }).length;
    });
    const incorrectAnswers = computed(() => {
      if (!props.question?.questions) return 0;
      return props.question.questions.length - correctAnswers.value;
    });
    const accuracy = computed(() => {
      return props.question.questions.length > 0 ? Math.round(correctAnswers.value / props.question.questions.length * 100) : 0;
    });
    const isShortAnswerCorrect = (index) => {
      const userAnswer = userAnswers.value[index];
      const correctAnswer = props.question.questions[index].correctAnswer;
      if (!userAnswer || !correctAnswer) return false;
      return userAnswer.toLowerCase().trim() === correctAnswer.toLowerCase().trim();
    };
    const toggleHighlights = () => {
      showHighlights.value = !showHighlights.value;
    };
    const checkAnswers = () => {
      if (!hasAllAnswers.value) return;
      showAnswers.value = true;
      stopTimer();
      const isCorrect = correctAnswers.value === props.question.questions.length;
      emit("answer", {
        isCorrect,
        correctAnswers: correctAnswers.value,
        totalQuestions: props.question.questions.length
      });
    };
    const nextQuestion = () => {
      if (props.questionIndex === props.totalQuestions - 1) {
        emit("complete");
      } else {
        resetExercise();
        emit("next");
      }
    };
    const playPassageAudio = async () => {
      try {
        await playAudio(props.question.passage);
      } catch (error) {
        console.error("Error playing passage audio:", error);
      }
    };
    const resetExercise = () => {
      userAnswers.value = [];
      showAnswers.value = false;
      showHighlights.value = false;
      readingTime.value = 0;
      startTimer();
    };
    const startTimer = () => {
      timer.value = setInterval(() => {
        readingTime.value += 1;
      }, 1e3);
    };
    const stopTimer = () => {
      if (timer.value) {
        clearInterval(timer.value);
        timer.value = null;
      }
    };
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    };
    onMounted(() => {
      if (props.question?.questions && Array.isArray(props.question.questions)) {
        userAnswers.value = new Array(props.question.questions.length).fill(null);
      } else {
        userAnswers.value = [];
      }
      startTimer();
    });
    onUnmounted(() => {
      stopTimer();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$K, [
        createBaseVNode("div", _hoisted_2$H, [
          createBaseVNode("div", _hoisted_3$F, [
            createBaseVNode("h3", _hoisted_4$D, toDisplayString$1(_ctx.question.title || tf("grammar.practice.reading.passage", "Reading passage")), 1),
            createBaseVNode("div", _hoisted_5$B, [
              _ctx.question.audio ? (openBlock(), createElementBlock("button", {
                key: 0,
                onClick: playPassageAudio,
                class: "flex items-center space-x-2 px-3 py-2 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-lg hover:bg-blue-200 dark:hover:bg-blue-900/50 transition-colors"
              }, [
                _cache[0] || (_cache[0] = createBaseVNode("svg", {
                  class: "w-4 h-4",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M15.536 8.464a5 5 0 010 7.072m-2.036-5.036a2.5 2.5 0 010 3.536M6 10h4l4.5-4.5v9L10 10H6V8z"
                  })
                ], -1)),
                createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.reading.listen", "Listen")), 1)
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_6$z, toDisplayString$1(tf("grammar.practice.reading.readingTime", "Reading time")) + ": " + toDisplayString$1(formatTime(readingTime.value)), 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_7$y, [
            createBaseVNode("div", _hoisted_8$y, [
              createBaseVNode("div", {
                innerHTML: formattedPassage.value,
                class: "text-gray-800 dark:text-gray-200 leading-relaxed text-justify"
              }, null, 8, _hoisted_9$x)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_10$w, [
          createBaseVNode("h4", _hoisted_11$w, toDisplayString$1(tf("grammar.practice.reading.questions", "Questions")), 1),
          createBaseVNode("div", _hoisted_12$v, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.question.questions, (q, index) => {
              return openBlock(), createElementBlock("div", {
                key: index,
                class: "border border-gray-200 dark:border-white/10 rounded-lg p-4"
              }, [
                createBaseVNode("div", _hoisted_13$v, [
                  createBaseVNode("h5", _hoisted_14$v, toDisplayString$1(index + 1) + ". " + toDisplayString$1(q.question), 1),
                  q.type === "multiple-choice" ? (openBlock(), createElementBlock("div", _hoisted_15$r, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(q.options, (option, optionIndex) => {
                      return openBlock(), createElementBlock("label", {
                        key: optionIndex,
                        class: normalizeClass([
                          "flex items-start space-x-3 p-3 rounded-lg cursor-pointer transition-all",
                          userAnswers.value[index] === optionIndex ? "bg-blue-50 dark:bg-blue-900/30 border border-blue-300 dark:border-blue-600" : "bg-gray-50 dark:bg-[#0a0a0a]/50 hover:bg-gray-100 dark:hover:bg-[#0a0a0a]/70 border border-transparent",
                          showAnswers.value && optionIndex === q.correctAnswer ? "bg-green-50 dark:bg-green-900/30 border border-green-300 dark:border-green-600" : "",
                          showAnswers.value && userAnswers.value[index] === optionIndex && optionIndex !== q.correctAnswer ? "bg-red-50 dark:bg-red-900/30 border border-red-300 dark:border-red-600" : ""
                        ])
                      }, [
                        withDirectives(createBaseVNode("input", {
                          type: "radio",
                          name: `question-${index}`,
                          value: optionIndex,
                          "onUpdate:modelValue": ($event) => userAnswers.value[index] = $event,
                          disabled: showAnswers.value,
                          class: "mt-1"
                        }, null, 8, _hoisted_16$q), [
                          [vModelRadio, userAnswers.value[index]]
                        ]),
                        createBaseVNode("span", _hoisted_17$q, toDisplayString$1(option), 1),
                        createBaseVNode("div", _hoisted_18$p, [
                          showAnswers.value && optionIndex === q.correctAnswer ? (openBlock(), createElementBlock("svg", _hoisted_19$p, _cache[1] || (_cache[1] = [
                            createBaseVNode("path", {
                              "stroke-linecap": "round",
                              "stroke-linejoin": "round",
                              "stroke-width": "2",
                              d: "M5 13l4 4L19 7"
                            }, null, -1)
                          ]))) : showAnswers.value && userAnswers.value[index] === optionIndex && optionIndex !== q.correctAnswer ? (openBlock(), createElementBlock("svg", _hoisted_20$p, _cache[2] || (_cache[2] = [
                            createBaseVNode("path", {
                              "stroke-linecap": "round",
                              "stroke-linejoin": "round",
                              "stroke-width": "2",
                              d: "M6 18L18 6M6 6l12 12"
                            }, null, -1)
                          ]))) : createCommentVNode("", true)
                        ])
                      ], 2);
                    }), 128))
                  ])) : q.type === "true-false" ? (openBlock(), createElementBlock("div", _hoisted_21$p, [
                    (openBlock(), createElementBlock(Fragment, null, renderList(["true", "false"], (option) => {
                      return createBaseVNode("label", {
                        key: option,
                        class: normalizeClass([
                          "flex items-center space-x-3 p-3 rounded-lg cursor-pointer transition-all",
                          userAnswers.value[index] === option ? "bg-blue-50 dark:bg-blue-900/30 border border-blue-300 dark:border-blue-600" : "bg-gray-50 dark:bg-gray-700/50 hover:bg-gray-100 dark:hover:bg-gray-700 border border-transparent",
                          showAnswers.value && option === q.correctAnswer ? "bg-green-50 dark:bg-green-900/30 border border-green-300 dark:border-green-600" : "",
                          showAnswers.value && userAnswers.value[index] === option && option !== q.correctAnswer ? "bg-red-50 dark:bg-red-900/30 border border-red-300 dark:border-red-600" : ""
                        ])
                      }, [
                        withDirectives(createBaseVNode("input", {
                          type: "radio",
                          name: `question-${index}`,
                          value: option,
                          "onUpdate:modelValue": ($event) => userAnswers.value[index] = $event,
                          disabled: showAnswers.value
                        }, null, 8, _hoisted_22$n), [
                          [vModelRadio, userAnswers.value[index]]
                        ]),
                        createBaseVNode("span", _hoisted_23$n, toDisplayString$1(option === "true" ? tf("grammar.practice.reading.true", "True") : tf("grammar.practice.reading.false", "False")), 1)
                      ], 2);
                    }), 64))
                  ])) : q.type === "short-answer" ? (openBlock(), createElementBlock("div", _hoisted_24$m, [
                    withDirectives(createBaseVNode("input", {
                      "onUpdate:modelValue": ($event) => userAnswers.value[index] = $event,
                      disabled: showAnswers.value,
                      placeholder: tf("grammar.practice.reading.yourAnswer", "Your answer"),
                      class: normalizeClass([
                        "w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                        showAnswers.value ? isShortAnswerCorrect(index) ? "border-green-500 bg-green-50 dark:bg-green-900/30" : "border-red-500 bg-red-50 dark:bg-red-900/30" : "border-gray-300 dark:border-white/10 bg-white dark:bg-[#0a0a0a]",
                        "text-gray-900 dark:text-white"
                      ])
                    }, null, 10, _hoisted_25$m), [
                      [vModelText, userAnswers.value[index]]
                    ]),
                    showAnswers.value && !isShortAnswerCorrect(index) ? (openBlock(), createElementBlock("div", _hoisted_26$k, toDisplayString$1(tf("grammar.practice.reading.correctAnswer", "Correct answer")) + ": " + toDisplayString$1(q.correctAnswer), 1)) : createCommentVNode("", true)
                  ])) : createCommentVNode("", true)
                ]),
                showAnswers.value && q.explanation ? (openBlock(), createElementBlock("div", _hoisted_27$j, [
                  createBaseVNode("p", _hoisted_28$j, [
                    createBaseVNode("strong", null, toDisplayString$1(tf("grammar.practice.explanation", "Explanation")) + ":", 1),
                    createTextVNode(" " + toDisplayString$1(q.explanation), 1)
                  ])
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])
        ]),
        showAnswers.value ? (openBlock(), createElementBlock("div", _hoisted_29$h, [
          createBaseVNode("div", _hoisted_30$g, [
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_31$g, toDisplayString$1(correctAnswers.value), 1),
              createBaseVNode("div", _hoisted_32$e, toDisplayString$1(tf("grammar.practice.reading.correct", "Correct")), 1)
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_33$e, toDisplayString$1(incorrectAnswers.value), 1),
              createBaseVNode("div", _hoisted_34$d, toDisplayString$1(tf("grammar.practice.reading.incorrect", "Incorrect")), 1)
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_35$d, toDisplayString$1(accuracy.value) + "%", 1),
              createBaseVNode("div", _hoisted_36$c, toDisplayString$1(tf("grammar.practice.reading.accuracy", "Accuracy")), 1)
            ])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_37$b, [
          createBaseVNode("div", _hoisted_38$b, [
            createBaseVNode("button", {
              onClick: toggleHighlights,
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-gray-600 dark:text-white/60 hover:text-gray-800 dark:hover:text-white transition-colors"
            }, [
              _cache[3] || (_cache[3] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M7 20l4-16m2 16l4-16M6 9h14M4 15h14"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(showHighlights.value ? tf("grammar.practice.reading.hideHighlights", "Hide highlights") : tf("grammar.practice.reading.showHighlights", "Show highlights")), 1)
            ]),
            createBaseVNode("div", _hoisted_39$9, [
              _cache[4] || (_cache[4] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(formatTime(readingTime.value)), 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_40$9, [
            !showAnswers.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: checkAnswers,
              disabled: !hasAllAnswers.value,
              class: "px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            }, toDisplayString$1(tf("grammar.practice.checkAnswer", "Check answer")), 9, _hoisted_41$8)) : (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: nextQuestion,
              class: "px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            }, toDisplayString$1(_ctx.questionIndex === _ctx.totalQuestions - 1 ? tf("grammar.practice.finish", "Finish") : tf("grammar.practice.next", "Next")), 1))
          ])
        ])
      ]);
    };
  }
});

const ReadingExercise = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$K
}, Symbol.toStringTag, { value: 'Module' }));

/*!
  * vue-draggable-next v2.2.0
  * (c) 2023 Anish George
  * @license MIT
  */

/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var version = "1.14.0";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}

var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};

function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}

function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}

function matches(
/**HTMLElement*/
el,
/**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));

  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }

  return false;
}

function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}

function closest(
/**HTMLElement*/
el,
/**String*/
selector,
/**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;

    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }

      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }

  return null;
}

var R_SPACE = /\s+/g;

function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}

function css(el, prop, val) {
  var style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

function matrix(el, selfOnly) {
  var appliedTransforms = '';

  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */

    } while (!selfOnly && (el = el.parentNode));
  }

  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}

function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;

    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }

    return list;
  }

  return [];
}

function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;

  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */


function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;

  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }

  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */

      } while (container = container.parentNode);
    }
  }

  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;

    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */


function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;

    {
      visible = elSideVal >= parentSideVal;
    }

    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }

  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */


function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
      i = 0,
      children = el.children;

  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }

      currentChild++;
    }

    i++;
  }

  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */


function lastChild(el, selector) {
  var last = el.lastElementChild;

  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }

  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */


function index(el, selector) {
  var index = 0;

  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */


  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }

  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */


function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();

  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }

  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */


function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }

  return -1;
}

function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;

  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);

      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */

  } while (elem = elem.parentNode);

  return getWindowScrollingElement();
}

function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }

  return dst;
}

function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}

var _throttleTimeout;

function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;

      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }

      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}

function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}

function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}

function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;

  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}

var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });

        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);

          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }

        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;

      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }

      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);

        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }

        target.toRect = toRect;

        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate


        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;

          if (!time) {
            time = _this.options.animation;
          }

          _this.animate(target, animatingRect, toRect, time);
        }

        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);

      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }

      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}

function repaint(target) {
  return target.offsetWidth;
}

function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }

    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;

    this.eventCanceled = false;

    evt.cancel = function () {
      _this.eventCanceled = true;
    };

    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined


      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });

    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);

      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;

      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }

  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));

  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }

  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }

  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];

var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, _excluded);

  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};

function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}

var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)
_silent = false,
    savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return; // false when <= IE11

  if (IE11OrLess) {
    return false;
  }

  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }

  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }

  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }

  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},

/**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable)) return;
    var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

      if (value == null && (pull || sameGroup)) {
        // Default pull value
        // Default pull and put value if same group
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }

  var group = {};
  var originalGroup = options.group;

  if (!originalGroup || _typeof(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }

  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


if (documentExists) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}

var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;

    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

    if (nearest) {
      // Create imitation event
      var event = {};

      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }

      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;

      nearest[expando]._onDragOver(event);
    }
  }
};

var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */


function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }

  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }

  _prepareGroup(options); // Bind all private methods


  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode


  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events


  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }

  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }

  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}

Sortable.prototype =
/** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;

    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;

    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


    if (dragEl) {
      return;
    }

    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable


    if (originalTarget.isContentEditable) {
      return;
    } // Safari ignores further event handling after mousedown


    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }

    target = closest(target, options.draggable, el, false);

    if (target && target.animated) {
      return;
    }

    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent


    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });

        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);

        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });

      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`


    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  /** Event */
  evt,
  /** Touch */
  touch,
  /** HTMLElement */
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;

    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';

      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          _this._onDrop();

          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove


        _this._disableDelayedDragEvents();

        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend


        _this._triggerDragStart(evt, touch); // Drag start event


        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item


        toggleClass(dragEl, options.chosenClass, true);
      }; // Disable "draggable"


      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }

      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag


        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;

    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);

    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  /** Event */
  evt,
  /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;

    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }

    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {

    awaitingDragStarted = false;

    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });

      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }

      var options = this.options; // Apply effect

      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;

      _hideGhostForTarget();

      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;

      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }

      dragEl.parentNode[expando]._isOutsideThisEl(target);

      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });

            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }

          target = parent; // store last element
        }
        /* jshint boss:true */
        while (parent = parent.parentNode);
      }

      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }

        this._onDragStart(evt, true);
      }

      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }

        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }

      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;

        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }

        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }

        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }

      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  /**Event*/
  evt,
  /**boolean*/
  fallback) {
    var _this = this;

    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });

    if (Sortable.eventCanceled) {
      this._onDrop();

      return;
    }

    pluginEvent('setupClone', this);

    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';

      this._hideClone();

      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround


    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;

      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }

      _this._hideClone();

      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);

      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }

      on(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }

    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;

    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(
  /**Event*/
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;

    if (_silent) return;

    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state


    function capture() {
      dragOverEvent('dragOverAnimationCapture');

      _this.captureAnimationState();

      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)


    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }

        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }

        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation


        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }

        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });

        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element


      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback


      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


        !insertion && nearestEmptyInsertDetectEvent(evt);
      }

      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted


    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);

      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }

    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }

    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;

    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }

    ignoreNextClick = false;

    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;

      if (revert) {
        parentEl = rootEl; // actualization

        capture();

        this._hideClone();

        dragOverEvent('revert');

        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }

        return completed(true);
      }

      var elLastChild = lastChild(el, options.draggable);

      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // if there is a last element, it is the target


        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }

        if (target) {
          targetRect = getRect(target);
        }

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);

        if (firstChild === dragEl) {
          return completed(false);
        }

        target = firstChild;
        targetRect = getRect(target);

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }

        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;

        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);

          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert


        if (direction === 0 || sibling === target) {
          return completed(false);
        }

        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;

        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }

          _silent = true;
          setTimeout(_unsilent, 30);
          capture();

          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)


          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }

          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }

          changed();
          return completed(true);
        }
      }

      if (el.contains(dragEl)) {
        return completed(false);
      }
    }

    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  /**Event*/
  evt) {
    var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);

    if (Sortable.eventCanceled) {
      this._nulling();

      return;
    }

    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);

    _cancelNextTick(this.cloneId);

    _cancelNextTick(this._dragStartId); // Unbind events


    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }

    this._offMoveEvents();

    this._offUpEvents();

    if (Safari) {
      css(document.body, 'user-select', '');
    }

    css(dragEl, 'transform', '');

    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }

      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }

      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }

        _disableDraggable(dragEl);

        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }

        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });

        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event


            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another


            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }

          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }

        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }

          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting


          this.save();
        }
      }
    }

    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);

        break;

      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);

          _globalDragOver(evt);
        }

        break;

      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },

  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;

    for (; i < n; i++) {
      el = children[i];

      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }

    return order;
  },

  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];

      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },

  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },

  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },

  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;

    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);

      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }

      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },

  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);

    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes


    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });

    this._onDrop();

    this._disableDelayedDragEvents();

    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');

      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }

      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();

      return;
    }

    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }

      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }

      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};

function _globalDragOver(
/**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }

  evt.cancelable && evt.preventDefault();
}

function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }

  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);

  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }

  return retVal;
}

function _disableDraggable(el) {
  el.draggable = false;
}

function _unsilent() {
  _silent = false;
}

function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}

function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;

  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }

      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }

  invert = invert || invertSwap;

  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }

  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */


function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */


function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;

  while (i--) {
    sum += str.charCodeAt(i);
  }

  return sum.toString(36);
}

function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;

  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}

function _nextTick(fn) {
  return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:


if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils


Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */


Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }

    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */


Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export


Sortable.version = version;

var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;

function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }

  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;

      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;

      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }

      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;

      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);

        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }

            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }

        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}

function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}

function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}

var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;

    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }

  var layersOut = 0;
  var currentParent = scrollEl;

  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;

    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }

    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }

    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);

      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }

          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }

    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();

  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};

function Revert() {}

Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();

    if (putSortable) {
      putSortable.captureAnimationState();
    }

    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }

    this.sortable.animateAll();

    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};

_extends(Revert, {
  pluginName: 'revertOnSpill'
});

function Remove() {}

Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};

_extends(Remove, {
  pluginName: 'removeOnSpill'
});

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

function getConsole() {
    if (typeof window !== 'undefined') {
        return window.console;
    }
    return global.console;
}
const console$1 = getConsole();
function cached(fn) {
    const cache = Object.create(null);
    return function cachedFn(str) {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
}
const regex = /-(\w)/g;
const camelize = cached((str) => str.replace(regex, (_, c) => (c ? c.toUpperCase() : '')));
function removeNode(node) {
    if (node.parentElement !== null) {
        node.parentElement.removeChild(node);
    }
}
function insertNodeAt(fatherNode, node, position) {
    const refNode = position === 0
        ? fatherNode.children[0]
        : fatherNode.children[position - 1].nextSibling;
    fatherNode.insertBefore(node, refNode);
}

function computeVmIndex(vnodes, element) {
    return Object.values(vnodes).indexOf(element);
}
function computeIndexes(slots, children, isTransition, footerOffset) {
    if (!slots) {
        return [];
    }
    const elmFromNodes = Object.values(slots);
    const footerIndex = children.length - footerOffset;
    const rawIndexes = [...children].map((elt, idx) => idx >= footerIndex ? elmFromNodes.length : elmFromNodes.indexOf(elt));
    return rawIndexes;
}
function emit(evtName, evtData) {
    //@ts-ignore
    this.$nextTick(() => this.$emit(evtName.toLowerCase(), evtData));
}
function delegateAndEmit(evtName) {
    //@ts-ignore
    return evtData => {
        //@ts-ignore
        if (this.realList !== null) {
            //@ts-ignore
            this['onDrag' + evtName](evtData);
        }
        //@ts-ignore
        emit.call(this, evtName, evtData);
    };
}
function isTransitionName(name) {
    return ['transition-group', 'TransitionGroup'].includes(name);
}
function isTransition(slots) {
    if (!slots || slots.length !== 1) {
        return false;
    }
    // @ts-ignore
    const [{ type }] = slots;
    if (!type) {
        return false;
    }
    //@ts-ignore
    return isTransitionName(type.name);
}
function getComponentAttributes($attrs, componentData) {
    if (!componentData) {
        return $attrs;
    }
    return { ...componentData.props, ...componentData.attrs };
}
const eventsListened = ['Start', 'Add', 'Remove', 'Update', 'End'];
const eventsToEmit = ['Choose', 'Unchoose', 'Sort', 'Filter', 'Clone'];
const readonlyProperties = ['Move', ...eventsListened, ...eventsToEmit].map(evt => 'on' + evt);
// @ts-ignore
let draggingElement = null;
const props = {
    options: Object,
    list: {
        type: Array,
        required: false,
        default: null,
    },
    noTransitionOnDrag: {
        type: Boolean,
        default: false,
    },
    clone: {
        type: Function,
        default: (original) => {
            return original;
        },
    },
    tag: {
        type: String,
        default: 'div',
    },
    move: {
        type: Function,
        default: null,
    },
    componentData: {
        type: Object,
        required: false,
        default: null,
    },
    component: {
        type: String,
        default: null,
    },
    modelValue: {
        type: Array,
        required: false,
        default: null,
    },
};
const VueDraggableNext = defineComponent({
    name: 'VueDraggableNext',
    inheritAttrs: false,
    emits: [
        'update:modelValue',
        'move',
        'change',
        ...eventsListened.map(s => s.toLowerCase()),
        ...eventsToEmit.map(s => s.toLowerCase()),
    ],
    props,
    data() {
        return {
            transitionMode: false,
            noneFunctionalComponentMode: false,
            headerOffset: 0,
            footerOffset: 0,
            _sortable: {},
            visibleIndexes: [],
            context: {},
        };
    },
    render() {
        const slots = this.$slots.default ? this.$slots.default() : null;
        const attrs = getComponentAttributes(this.$attrs, this.componentData);
        if (!slots)
            return h(this.getTag(), attrs, []);
        this.transitionMode = isTransition(slots);
        return h(this.getTag(), attrs, slots);
    },
    created() {
        if (this.list !== null && this.modelValue !== null) {
            console$1.error('list props are mutually exclusive! Please set one.');
        }
    },
    mounted() {
        const optionsAdded = {};
        eventsListened.forEach(elt => {
            optionsAdded['on' + elt] = delegateAndEmit.call(this, elt);
        });
        eventsToEmit.forEach(elt => {
            optionsAdded['on' + elt] = emit.bind(this, elt);
        });
        const attributes = Object.keys(this.$attrs).reduce((res, key) => {
            res[camelize(key)] = this.$attrs[key];
            return res;
        }, {});
        const options = Object.assign({}, attributes, optionsAdded, {
            onMove: (evt, originalEvent) => {
                return this.onDragMove(evt, originalEvent);
            },
        });
        !('draggable' in options) && (options.draggable = '>*');
        const targetDomElement = this.$el.nodeType === 1 ? this.$el : this.$el.parentElement;
        this._sortable = new Sortable(targetDomElement, options);
        targetDomElement.__draggable_component__ = this;
        this.computeIndexes();
    },
    beforeUnmount() {
        try {
            if (this._sortable !== undefined)
                this._sortable.destroy();
        }
        catch (error) { }
    },
    computed: {
        realList() {
            return this.list ? this.list : this.modelValue;
        },
    },
    watch: {
        $attrs: {
            handler(newOptionValue) {
                this.updateOptions(newOptionValue);
            },
            deep: true,
        },
        realList() {
            this.computeIndexes();
        },
    },
    methods: {
        getTag() {
            return this.component ? resolveComponent(this.component) : this.tag;
        },
        updateOptions(newOptionValue) {
            for (var property in newOptionValue) {
                const value = camelize(property);
                if (readonlyProperties.indexOf(value) === -1) {
                    this._sortable.option(value, newOptionValue[property]);
                }
            }
        },
        getChildrenNodes() {
            return this.$el.children;
        },
        computeIndexes() {
            this.$nextTick(() => {
                this.visibleIndexes = computeIndexes(this.getChildrenNodes(), this.$el.children, this.transitionMode, this.footerOffset);
            });
        },
        getUnderlyingVm(htmlElt) {
            const index = computeVmIndex(this.getChildrenNodes() || [], htmlElt);
            if (index === -1) {
                //Edge case during move callback: related element might be
                //an element different from collection
                return null;
            }
            //@ts-ignore
            const element = this.realList[index];
            return { index, element };
        },
        emitChanges(evt) {
            this.$nextTick(() => {
                this.$emit('change', evt);
            });
        },
        alterList(onList) {
            if (this.list) {
                onList(this.list);
                return;
            }
            const newList = [...this.modelValue];
            onList(newList);
            this.$emit('update:modelValue', newList);
        },
        spliceList() {
            const spliceList = (list) => list.splice(...arguments);
            this.alterList(spliceList);
        },
        updatePosition(oldIndex, newIndex) {
            const updatePosition = (list) => list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);
            this.alterList(updatePosition);
        },
        getVmIndex(domIndex) {
            const indexes = this.visibleIndexes;
            const numberIndexes = indexes.length;
            return domIndex > numberIndexes - 1 ? numberIndexes : indexes[domIndex];
        },
        getComponent() {
            return this.$slots.default
                ? //@ts-ignore
                    this.$slots.default()[0].componentInstance
                : null;
        },
        resetTransitionData(index) {
            if (!this.noTransitionOnDrag || !this.transitionMode) {
                return;
            }
            var nodes = this.getChildrenNodes();
            nodes[index].data = null;
            const transitionContainer = this.getComponent();
            transitionContainer.children = [];
            transitionContainer.kept = undefined;
        },
        onDragStart(evt) {
            this.computeIndexes();
            this.context = this.getUnderlyingVm(evt.item);
            if (!this.context)
                return;
            evt.item._underlying_vm_ = this.clone(this.context.element);
            draggingElement = evt.item;
        },
        onDragAdd(evt) {
            const element = evt.item._underlying_vm_;
            if (element === undefined) {
                return;
            }
            removeNode(evt.item);
            const newIndex = this.getVmIndex(evt.newIndex);
            //@ts-ignore
            this.spliceList(newIndex, 0, element);
            this.computeIndexes();
            const added = { element, newIndex };
            this.emitChanges({ added });
        },
        onDragRemove(evt) {
            insertNodeAt(this.$el, evt.item, evt.oldIndex);
            if (evt.pullMode === 'clone') {
                removeNode(evt.clone);
                return;
            }
            if (!this.context)
                return;
            const oldIndex = this.context.index;
            //@ts-ignore
            this.spliceList(oldIndex, 1);
            const removed = { element: this.context.element, oldIndex };
            this.resetTransitionData(oldIndex);
            this.emitChanges({ removed });
        },
        onDragUpdate(evt) {
            removeNode(evt.item);
            insertNodeAt(evt.from, evt.item, evt.oldIndex);
            //@ts-ignore
            const oldIndex = this.context.index;
            const newIndex = this.getVmIndex(evt.newIndex);
            this.updatePosition(oldIndex, newIndex);
            //@ts-ignore
            const moved = { element: this.context.element, oldIndex, newIndex };
            this.emitChanges({ moved });
        },
        updateProperty(evt, propertyName) {
            evt.hasOwnProperty(propertyName) &&
                (evt[propertyName] += this.headerOffset);
        },
        onDragMove(evt, originalEvent) {
            const onMove = this.move;
            if (!onMove || !this.realList) {
                return true;
            }
            const relatedContext = this.getRelatedContextFromMoveEvent(evt);
            const draggedContext = this.context;
            const futureIndex = this.computeFutureIndex(relatedContext, evt);
            Object.assign(draggedContext, { futureIndex });
            const sendEvt = Object.assign({}, evt, {
                relatedContext,
                draggedContext,
            });
            return onMove(sendEvt, originalEvent);
        },
        onDragEnd() {
            this.computeIndexes();
            draggingElement = null;
        },
        getTrargetedComponent(htmElement) {
            return htmElement.__draggable_component__;
        },
        getRelatedContextFromMoveEvent({ to, related }) {
            const component = this.getTrargetedComponent(to);
            if (!component) {
                return { component };
            }
            const list = component.realList;
            const context = { list, component };
            if (to !== related && list && component.getUnderlyingVm) {
                const destination = component.getUnderlyingVm(related);
                if (destination) {
                    return Object.assign(destination, context);
                }
            }
            return context;
        },
        computeFutureIndex(relatedContext, evt) {
            const domChildren = [...evt.to.children].filter(el => el.style['display'] !== 'none');
            if (domChildren.length === 0)
                return 0;
            const currentDOMIndex = domChildren.indexOf(evt.related);
            const currentIndex = relatedContext.component.getVmIndex(currentDOMIndex);
            const draggedInList = domChildren.indexOf(draggingElement) !== -1;
            return draggedInList || !evt.willInsertAfter
                ? currentIndex
                : currentIndex + 1;
        },
    },
});

const _hoisted_1$J = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-white/10 p-6" };
const _hoisted_2$G = { class: "mb-8" };
const _hoisted_3$E = { class: "text-center" };
const _hoisted_4$C = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_5$A = { class: "bg-gray-50 dark:bg-[#0a0a0a]/50 rounded-lg p-6 mb-4" };
const _hoisted_6$y = { class: "flex items-center justify-center space-x-6 mb-4" };
const _hoisted_7$x = ["disabled"];
const _hoisted_8$x = {
  key: 0,
  class: "w-8 h-8 ml-1",
  fill: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_9$w = {
  key: 1,
  class: "w-8 h-8",
  fill: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_10$v = ["disabled"];
const _hoisted_11$v = { class: "mb-4" };
const _hoisted_12$u = { class: "flex justify-between text-xs text-gray-500 dark:text-white/60 mt-1" };
const _hoisted_13$u = { class: "flex items-center justify-center space-x-4 text-sm text-gray-600 dark:text-white/60" };
const _hoisted_14$u = { class: "flex items-center space-x-1" };
const _hoisted_15$q = {
  key: 0,
  class: "flex items-center space-x-1"
};
const _hoisted_16$p = {
  key: 0,
  class: "text-gray-500 dark:text-white/60"
};
const _hoisted_17$p = {
  key: 0,
  class: "mb-6"
};
const _hoisted_18$o = { class: "block text-sm font-medium text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_19$o = ["placeholder"];
const _hoisted_20$o = { class: "space-y-6" };
const _hoisted_21$o = { class: "text-lg font-semibold text-gray-900 dark:text-white border-b border-gray-200 dark:border-white/10 pb-2" };
const _hoisted_22$m = { class: "space-y-6" };
const _hoisted_23$m = { class: "mb-4" };
const _hoisted_24$l = { class: "font-medium text-gray-900 dark:text-white mb-2" };
const _hoisted_25$l = {
  key: 0,
  class: "space-y-2"
};
const _hoisted_26$j = ["name", "value", "onUpdate:modelValue", "disabled"];
const _hoisted_27$i = { class: "text-gray-900 dark:text-white" };
const _hoisted_28$i = { class: "ml-auto" };
const _hoisted_29$g = {
  key: 0,
  class: "w-5 h-5 text-green-600 dark:text-green-400",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_30$f = {
  key: 1,
  class: "w-5 h-5 text-red-600 dark:text-red-400",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_31$f = {
  key: 1,
  class: "space-y-2"
};
const _hoisted_32$d = ["onUpdate:modelValue", "disabled", "placeholder"];
const _hoisted_33$d = {
  key: 0,
  class: "text-sm text-green-600 dark:text-green-400"
};
const _hoisted_34$c = {
  key: 2,
  class: "space-y-2"
};
const _hoisted_35$c = { class: "text-sm text-gray-600 dark:text-white/60 mb-2" };
const _hoisted_36$b = { class: "flex items-center space-x-3" };
const _hoisted_37$a = { class: "w-6 h-6 bg-blue-600 text-white rounded-full flex items-center justify-center text-sm font-medium" };
const _hoisted_38$a = { class: "text-gray-900 dark:text-white" };
const _hoisted_39$8 = {
  key: 0,
  class: "mt-4 p-3 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700 rounded-lg"
};
const _hoisted_40$8 = { class: "text-sm text-yellow-800 dark:text-yellow-200" };
const _hoisted_41$7 = {
  key: 1,
  class: "mt-8 p-4 bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded-lg"
};
const _hoisted_42$6 = { class: "grid grid-cols-3 gap-4 text-center" };
const _hoisted_43$6 = { class: "text-2xl font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_44$6 = { class: "text-sm text-gray-600 dark:text-white/60" };
const _hoisted_45$5 = { class: "text-2xl font-bold text-red-600 dark:text-red-400" };
const _hoisted_46$5 = { class: "text-sm text-gray-600 dark:text-white/60" };
const _hoisted_47$5 = { class: "text-2xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_48$5 = { class: "text-sm text-gray-600 dark:text-white/60" };
const _hoisted_49$5 = { class: "flex justify-between items-center mt-8" };
const _hoisted_50$5 = { class: "flex space-x-4" };
const _hoisted_51$4 = { class: "flex space-x-4" };
const _hoisted_52$4 = ["disabled"];
const _hoisted_53$4 = {
  key: 2,
  class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
};
const _hoisted_54$4 = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-white/10 p-6 max-w-2xl w-full mx-4 max-h-96 overflow-y-auto" };
const _hoisted_55$4 = { class: "flex items-center justify-between mb-4" };
const _hoisted_56$4 = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_57$4 = { class: "prose dark:prose-invert max-w-none" };
const _hoisted_58$4 = { class: "text-gray-800 dark:text-gray-200 leading-relaxed" };
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  __name: "ListeningExercise",
  props: {
    question: {},
    questionIndex: {},
    totalQuestions: {},
    difficulty: {}
  },
  emits: ["answer", "next", "complete"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      try {
        const translated = t(key, params);
        return typeof translated === "string" && translated !== key ? translated : fallback;
      } catch {
        return fallback;
      }
    };
    const { playAudio } = useVoiceStore();
    let youtubePlayer = null;
    const isYouTubeAudio = ref(false);
    ref("");
    const props = __props;
    const emit = __emit;
    const userAnswers = ref([]);
    const userNotes = ref("");
    const showAnswers = ref(false);
    const showTranscript = ref(false);
    const audioLoaded = ref(false);
    const isPlaying = ref(false);
    const currentTime = ref(0);
    const duration = ref(0);
    const progress = ref(0);
    const playsRemaining = ref(3);
    const audio = ref(null);
    const progressBar = ref(null);
    const youtubePlayerReady = ref(false);
    const hasAllAnswers = computed(() => {
      if (!props.question?.questions) return false;
      return userAnswers.value.length === props.question.questions.length && userAnswers.value.every((answer) => answer !== null && answer !== void 0 && answer !== "");
    });
    const correctAnswers = computed(() => {
      if (!props.question?.questions) return 0;
      return props.question.questions.filter((q, index) => {
        return isAnswerCorrect(index);
      }).length;
    });
    const incorrectAnswers = computed(() => {
      return props.question.questions.length - correctAnswers.value;
    });
    const accuracy = computed(() => {
      return props.question.questions.length > 0 ? Math.round(correctAnswers.value / props.question.questions.length * 100) : 0;
    });
    const playbackSpeed = computed(() => {
      console.log("DEBUG - Question difficulty:", props.question.difficulty);
      console.log("DEBUG - Global difficulty:", props.difficulty);
      console.log("DEBUG - Explicit playbackSpeed:", props.question.playbackSpeed);
      if (props.question.playbackSpeed) {
        console.log("DEBUG - Using explicit playbackSpeed:", props.question.playbackSpeed);
        return props.question.playbackSpeed;
      }
      const difficulty = props.question.difficulty || props.difficulty;
      console.log("DEBUG - Final difficulty used:", difficulty);
      let speed;
      switch (difficulty) {
        case "easy":
          speed = 0.75;
          break;
        case "medium":
          speed = 1;
          break;
        case "hard":
          speed = 3.25;
          break;
        default:
          speed = 1;
      }
      console.log("DEBUG - Computed playback speed:", speed);
      return speed;
    });
    const isAnswerCorrect = (index) => {
      const userAnswer = userAnswers.value[index];
      const correctAnswer = props.question.questions[index].correctAnswer;
      const questionType = props.question.questions[index].type;
      if (questionType === "fill-blank") {
        return userAnswer?.toLowerCase().trim() === correctAnswer?.toLowerCase().trim();
      } else if (questionType === "ordering") {
        return JSON.stringify(userAnswer) === JSON.stringify(correctAnswer);
      }
      return userAnswer === correctAnswer;
    };
    const togglePlayback = () => {
      if (playsRemaining.value <= 0) return;
      if (isYouTubeAudio.value) {
        if (!youtubePlayerReady.value || !youtubePlayer || !youtubePlayer.playVideo || !youtubePlayer.pauseVideo) {
          console.warn("YouTube player not ready yet");
          return;
        }
        if (isPlaying.value) {
          youtubePlayer.pauseVideo();
        } else {
          youtubePlayer.playVideo();
          if (playsRemaining.value > 0) {
            playsRemaining.value--;
          }
        }
        return;
      }
      if (!audio.value) return;
      if (isPlaying.value) {
        audio.value.pause();
      } else {
        audio.value.play();
        if (playsRemaining.value > 0) {
          playsRemaining.value--;
        }
      }
    };
    const restartAudio = () => {
      if (isYouTubeAudio.value) {
        if (youtubePlayer && youtubePlayer.seekTo) {
          youtubePlayer.seekTo(0);
          currentTime.value = 0;
          progress.value = 0;
        }
      } else {
        if (!audio.value) return;
        audio.value.currentTime = 0;
        currentTime.value = 0;
        progress.value = 0;
      }
    };
    const updatePlaybackSpeed = () => {
      console.log("DEBUG - updatePlaybackSpeed called!");
      console.log("DEBUG - Current playbackSpeed.value:", playbackSpeed.value);
      console.log("DEBUG - isYouTubeAudio.value:", isYouTubeAudio.value);
      console.log("DEBUG - audio.value exists:", !!audio.value);
      if (isYouTubeAudio.value) {
        if (youtubePlayer && youtubePlayer.setPlaybackRate) {
          console.log("DEBUG - Setting YouTube playback rate to:", playbackSpeed.value);
          youtubePlayer.setPlaybackRate(parseFloat(playbackSpeed.value.toString()));
        } else {
          console.log("DEBUG - YouTube player not ready for setPlaybackRate");
        }
      } else if (audio.value) {
        console.log("DEBUG - Setting audio playback rate to:", playbackSpeed.value);
        console.log("DEBUG - Audio playbackRate BEFORE setting:", audio.value.playbackRate);
        audio.value.playbackRate = parseFloat(playbackSpeed.value.toString());
        console.log("DEBUG - Audio playbackRate AFTER setting:", audio.value.playbackRate);
        setTimeout(() => {
          console.log("DEBUG - Audio playbackRate after 100ms:", audio.value?.playbackRate);
          if (audio.value && audio.value.playbackRate !== parseFloat(playbackSpeed.value.toString())) {
            console.log("DEBUG - Playback rate was reset! Force re-applying...");
            audio.value.playbackRate = parseFloat(playbackSpeed.value.toString());
            console.log("DEBUG - Force-applied playbackRate:", audio.value.playbackRate);
          }
        }, 100);
      } else {
        console.log("DEBUG - No audio element available to set playback rate");
      }
    };
    const seekAudio = (event) => {
      if (!progressBar.value) return;
      const rect = progressBar.value.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const newTime = clickX / rect.width * duration.value;
      if (isYouTubeAudio.value) {
        if (youtubePlayer && youtubePlayer.seekTo) {
          youtubePlayer.seekTo(newTime, true);
          currentTime.value = newTime;
        }
      } else if (audio.value) {
        audio.value.currentTime = newTime;
        currentTime.value = newTime;
      }
    };
    const updateProgress = () => {
      if (audio.value) {
        currentTime.value = audio.value.currentTime;
        progress.value = duration.value > 0 ? currentTime.value / duration.value * 100 : 0;
      }
    };
    const checkAnswers = () => {
      if (!hasAllAnswers.value) return;
      showAnswers.value = true;
      const isCorrect = correctAnswers.value === props.question.questions.length;
      emit("answer", {
        isCorrect,
        correctAnswers: correctAnswers.value,
        totalQuestions: props.question.questions.length
      });
    };
    const nextQuestion = () => {
      if (props.questionIndex === props.totalQuestions - 1) {
        emit("complete");
      } else {
        resetExercise();
        emit("next");
      }
    };
    const resetExercise = () => {
      userAnswers.value = [];
      userNotes.value = "";
      showAnswers.value = false;
      showTranscript.value = false;
      playsRemaining.value = props.question.maxPlays || 3;
      restartAudio();
    };
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    };
    const createYouTubeAudioPlayer = (videoId) => {
      isYouTubeAudio.value = true;
      const playerContainer = document.createElement("div");
      playerContainer.id = `youtube-player-${Date.now()}`;
      playerContainer.style.position = "absolute";
      playerContainer.style.left = "-9999px";
      playerContainer.style.top = "-9999px";
      playerContainer.style.width = "1px";
      playerContainer.style.height = "1px";
      document.body.appendChild(playerContainer);
      if (!window.YT) {
        const script = document.createElement("script");
        script.src = "https://www.youtube.com/iframe_api";
        document.head.appendChild(script);
        window.onYouTubeIframeAPIReady = () => {
          initYouTubePlayer(videoId, playerContainer.id);
        };
      } else {
        initYouTubePlayer(videoId, playerContainer.id);
      }
    };
    const initYouTubePlayer = (videoId, containerId) => {
      youtubePlayer = new window.YT.Player(containerId, {
        height: "1",
        width: "1",
        videoId,
        playerVars: {
          autoplay: 0,
          controls: 0,
          disablekb: 1,
          fs: 0,
          iv_load_policy: 3,
          modestbranding: 1,
          rel: 0,
          showinfo: 0
        },
        events: {
          onReady: (event) => {
            audioLoaded.value = true;
            youtubePlayerReady.value = true;
            duration.value = event.target.getDuration() || 0;
            updatePlaybackSpeed();
          },
          onStateChange: (event) => {
            const state = event.data;
            if (state === window.YT.PlayerState.PLAYING) {
              isPlaying.value = true;
            } else if (state === window.YT.PlayerState.PAUSED || state === window.YT.PlayerState.ENDED) {
              isPlaying.value = false;
              if (state === window.YT.PlayerState.ENDED) {
                currentTime.value = 0;
                progress.value = 0;
              }
            }
          }
        }
      });
      const updateYouTubeProgress = () => {
        if (youtubePlayer && youtubePlayer.getCurrentTime && isPlaying.value) {
          const current = youtubePlayer.getCurrentTime();
          currentTime.value = current;
          if (duration.value > 0) {
            progress.value = current / duration.value * 100;
          }
        }
      };
      setInterval(updateYouTubeProgress, 1e3);
    };
    const initializeAudio = () => {
      let audioUrl = props.question.audioUrl;
      if (audioUrl.startsWith("youtube:")) {
        const videoId = audioUrl.replace("youtube:", "");
        createYouTubeAudioPlayer(videoId);
        return;
      }
      if (audioUrl.includes("youtube.com/watch") || audioUrl.includes("youtu.be/")) {
        let videoId = "";
        if (audioUrl.includes("youtube.com/watch")) {
          const urlParams = new URLSearchParams(audioUrl.split("?")[1]);
          videoId = urlParams.get("v") || "";
        } else if (audioUrl.includes("youtu.be/")) {
          videoId = audioUrl.split("youtu.be/")[1].split("?")[0];
        }
        if (videoId) {
          createYouTubeAudioPlayer(videoId);
          return;
        }
      }
      audio.value = new Audio(audioUrl);
      audio.value.addEventListener("loadedmetadata", () => {
        duration.value = audio.value.duration;
        audioLoaded.value = true;
        updatePlaybackSpeed();
      });
      audio.value.addEventListener("timeupdate", updateProgress);
      audio.value.addEventListener("play", () => {
        isPlaying.value = true;
        updatePlaybackSpeed();
      });
      audio.value.addEventListener("pause", () => {
        isPlaying.value = false;
      });
      audio.value.addEventListener("ended", () => {
        isPlaying.value = false;
        currentTime.value = 0;
        progress.value = 0;
      });
    };
    watch(playbackSpeed, (newSpeed) => {
      updatePlaybackSpeed();
    }, { immediate: false });
    watch(() => props.question, (newQuestion, oldQuestion) => {
      if (newQuestion && oldQuestion && newQuestion.audioUrl !== oldQuestion.audioUrl) {
        if (audio.value) {
          audio.value.pause();
          audio.value = null;
        }
        if (youtubePlayer) {
          youtubePlayer.destroy();
          youtubePlayer = null;
        }
        audioLoaded.value = false;
        isPlaying.value = false;
        currentTime.value = 0;
        duration.value = 0;
        progress.value = 0;
        playsRemaining.value = newQuestion.maxPlays || 3;
        isYouTubeAudio.value = false;
        youtubePlayerReady.value = false;
        initializeAudio();
      }
    }, { deep: true });
    onMounted(() => {
      userAnswers.value = new Array(props.question.questions?.length || 0).fill(null);
      playsRemaining.value = props.question.maxPlays || 3;
      initializeAudio();
    });
    onUnmounted(() => {
      if (audio.value) {
        audio.value.pause();
        audio.value = null;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$J, [
        createBaseVNode("div", _hoisted_2$G, [
          createBaseVNode("div", _hoisted_3$E, [
            createBaseVNode("h3", _hoisted_4$C, toDisplayString$1(tf("grammar.practice.exercises.listening.instruction", "Listen carefully and answer the questions")), 1),
            createBaseVNode("div", _hoisted_5$A, [
              createBaseVNode("div", _hoisted_6$y, [
                createBaseVNode("button", {
                  onClick: togglePlayback,
                  disabled: !audioLoaded.value,
                  class: "w-16 h-16 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white rounded-full flex items-center justify-center transition-colors shadow-lg"
                }, [
                  !isPlaying.value ? (openBlock(), createElementBlock("svg", _hoisted_8$x, _cache[3] || (_cache[3] = [
                    createBaseVNode("path", { d: "M8 5v14l11-7z" }, null, -1)
                  ]))) : (openBlock(), createElementBlock("svg", _hoisted_9$w, _cache[4] || (_cache[4] = [
                    createBaseVNode("rect", {
                      x: "6",
                      y: "4",
                      width: "4",
                      height: "16"
                    }, null, -1),
                    createBaseVNode("rect", {
                      x: "14",
                      y: "4",
                      width: "4",
                      height: "16"
                    }, null, -1)
                  ])))
                ], 8, _hoisted_7$x),
                createBaseVNode("button", {
                  onClick: restartAudio,
                  disabled: !audioLoaded.value,
                  class: "p-3 bg-gray-300 dark:bg-white/10 hover:bg-gray-400 dark:hover:bg-white/15 disabled:bg-gray-200 dark:disabled:bg-white/5 text-gray-700 dark:text-white/80 rounded-full transition-colors"
                }, _cache[5] || (_cache[5] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                    })
                  ], -1)
                ]), 8, _hoisted_10$v)
              ]),
              createBaseVNode("div", _hoisted_11$v, [
                createBaseVNode("div", {
                  class: "w-full bg-gray-200 dark:bg-white/10 rounded-full h-2 cursor-pointer",
                  onClick: seekAudio,
                  ref_key: "progressBar",
                  ref: progressBar
                }, [
                  createBaseVNode("div", {
                    class: "bg-blue-600 h-2 rounded-full transition-all duration-100",
                    style: normalizeStyle({ width: `${progress.value}%` })
                  }, null, 4)
                ], 512),
                createBaseVNode("div", _hoisted_12$u, [
                  createBaseVNode("span", null, toDisplayString$1(formatTime(currentTime.value)), 1),
                  createBaseVNode("span", null, toDisplayString$1(formatTime(duration.value)), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_13$u, [
                createBaseVNode("div", _hoisted_14$u, [
                  _cache[6] || (_cache[6] = createBaseVNode("svg", {
                    class: "w-4 h-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M15.536 8.464a5 5 0 010 7.072m-2.036-5.036a2.5 2.5 0 010 3.536M6 10h4l4.5-4.5v9L10 10H6V8z"
                    })
                  ], -1)),
                  createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.exercises.listening.playsLeft", "Plays left")) + ": " + toDisplayString$1(playsRemaining.value), 1)
                ]),
                _ctx.question.allowNotes ? (openBlock(), createElementBlock("div", _hoisted_15$q, [
                  _cache[7] || (_cache[7] = createBaseVNode("svg", {
                    class: "w-4 h-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                    })
                  ], -1)),
                  createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.exercises.listening.notesAllowed", "Notes are allowed")), 1)
                ])) : createCommentVNode("", true)
              ])
            ]),
            !audioLoaded.value ? (openBlock(), createElementBlock("div", _hoisted_16$p, toDisplayString$1(tf("grammar.practice.exercises.listening.loading", "Loading")) + "... ", 1)) : createCommentVNode("", true)
          ])
        ]),
        _ctx.question.allowNotes ? (openBlock(), createElementBlock("div", _hoisted_17$p, [
          createBaseVNode("label", _hoisted_18$o, toDisplayString$1(tf("grammar.practice.exercises.listening.takeNotes", "Take notes")), 1),
          withDirectives(createBaseVNode("textarea", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => userNotes.value = $event),
            placeholder: tf("grammar.practice.exercises.listening.notesPlaceholder", "Type your notes here..."),
            class: "w-full h-32 px-4 py-2 border border-gray-300 dark:border-white/10 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white resize-none"
          }, null, 8, _hoisted_19$o), [
            [vModelText, userNotes.value]
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_20$o, [
          createBaseVNode("h4", _hoisted_21$o, toDisplayString$1(tf("grammar.practice.exercises.listening.questions", "Questions")), 1),
          createBaseVNode("div", _hoisted_22$m, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.question.questions, (q, index) => {
              return openBlock(), createElementBlock("div", {
                key: index,
                class: "border border-gray-200 dark:border-white/10 rounded-lg p-4"
              }, [
                createBaseVNode("div", _hoisted_23$m, [
                  createBaseVNode("h5", _hoisted_24$l, toDisplayString$1(index + 1) + ". " + toDisplayString$1(q.question), 1),
                  q.type === "multiple-choice" ? (openBlock(), createElementBlock("div", _hoisted_25$l, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(q.options, (option, optionIndex) => {
                      return openBlock(), createElementBlock("label", {
                        key: optionIndex,
                        class: normalizeClass([
                          "flex items-start space-x-3 p-3 rounded-lg cursor-pointer transition-all",
                          userAnswers.value[index] === optionIndex ? "bg-blue-50 dark:bg-blue-900/30 border border-blue-300 dark:border-blue-600" : "bg-gray-50 dark:bg-[#0a0a0a]/50 hover:bg-gray-100 dark:hover:bg-[#0a0a0a]/70 border border-transparent",
                          showAnswers.value && optionIndex === q.correctAnswer ? "bg-green-50 dark:bg-green-900/30 border border-green-300 dark:border-green-600" : "",
                          showAnswers.value && userAnswers.value[index] === optionIndex && optionIndex !== q.correctAnswer ? "bg-red-50 dark:bg-red-900/30 border border-red-300 dark:border-red-600" : ""
                        ])
                      }, [
                        withDirectives(createBaseVNode("input", {
                          type: "radio",
                          name: `question-${index}`,
                          value: optionIndex,
                          "onUpdate:modelValue": ($event) => userAnswers.value[index] = $event,
                          disabled: showAnswers.value,
                          class: "mt-1"
                        }, null, 8, _hoisted_26$j), [
                          [vModelRadio, userAnswers.value[index]]
                        ]),
                        createBaseVNode("span", _hoisted_27$i, toDisplayString$1(option), 1),
                        createBaseVNode("div", _hoisted_28$i, [
                          showAnswers.value && optionIndex === q.correctAnswer ? (openBlock(), createElementBlock("svg", _hoisted_29$g, _cache[8] || (_cache[8] = [
                            createBaseVNode("path", {
                              "stroke-linecap": "round",
                              "stroke-linejoin": "round",
                              "stroke-width": "2",
                              d: "M5 13l4 4L19 7"
                            }, null, -1)
                          ]))) : showAnswers.value && userAnswers.value[index] === optionIndex && optionIndex !== q.correctAnswer ? (openBlock(), createElementBlock("svg", _hoisted_30$f, _cache[9] || (_cache[9] = [
                            createBaseVNode("path", {
                              "stroke-linecap": "round",
                              "stroke-linejoin": "round",
                              "stroke-width": "2",
                              d: "M6 18L18 6M6 6l12 12"
                            }, null, -1)
                          ]))) : createCommentVNode("", true)
                        ])
                      ], 2);
                    }), 128))
                  ])) : q.type === "fill-blank" ? (openBlock(), createElementBlock("div", _hoisted_31$f, [
                    withDirectives(createBaseVNode("input", {
                      "onUpdate:modelValue": ($event) => userAnswers.value[index] = $event,
                      disabled: showAnswers.value,
                      placeholder: tf("grammar.practice.exercises.listening.fillBlank", "Type the missing word/phrase"),
                      class: normalizeClass([
                        "w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                        showAnswers.value ? isAnswerCorrect(index) ? "border-green-500 bg-green-50 dark:bg-green-900/30" : "border-red-500 bg-red-50 dark:bg-red-900/30" : "border-gray-300 dark:border-white/10 bg-white dark:bg-[#0a0a0a]",
                        "text-gray-900 dark:text-white"
                      ])
                    }, null, 10, _hoisted_32$d), [
                      [vModelText, userAnswers.value[index]]
                    ]),
                    showAnswers.value && !isAnswerCorrect(index) ? (openBlock(), createElementBlock("div", _hoisted_33$d, toDisplayString$1(tf("grammar.practice.exercises.listening.correctAnswer", "Correct answer")) + ": " + toDisplayString$1(q.correctAnswer), 1)) : createCommentVNode("", true)
                  ])) : q.type === "ordering" ? (openBlock(), createElementBlock("div", _hoisted_34$c, [
                    createBaseVNode("div", _hoisted_35$c, toDisplayString$1(tf("grammar.practice.exercises.listening.dragToOrder", "Drag to order")), 1),
                    createVNode(unref(VueDraggableNext), {
                      modelValue: userAnswers.value[index],
                      "onUpdate:modelValue": ($event) => userAnswers.value[index] = $event,
                      disabled: showAnswers.value,
                      class: "space-y-2",
                      "item-key": "id"
                    }, {
                      item: withCtx(({ element, index: itemIndex }) => [
                        createBaseVNode("div", {
                          class: normalizeClass([
                            "p-3 bg-gray-50 dark:bg-[#0a0a0a] rounded-lg border cursor-move",
                            showAnswers.value && itemIndex === element.correctPosition ? "border-green-500 bg-green-50 dark:bg-green-900/30" : showAnswers.value && itemIndex !== element.correctPosition ? "border-red-500 bg-red-50 dark:bg-red-900/30" : "border-gray-200 dark:border-white/10"
                          ])
                        }, [
                          createBaseVNode("div", _hoisted_36$b, [
                            createBaseVNode("span", _hoisted_37$a, toDisplayString$1(itemIndex + 1), 1),
                            createBaseVNode("span", _hoisted_38$a, toDisplayString$1(element.text), 1)
                          ])
                        ], 2)
                      ]),
                      _: 2
                    }, 1032, ["modelValue", "onUpdate:modelValue", "disabled"])
                  ])) : createCommentVNode("", true)
                ]),
                showAnswers.value && q.explanation ? (openBlock(), createElementBlock("div", _hoisted_39$8, [
                  createBaseVNode("p", _hoisted_40$8, [
                    createBaseVNode("strong", null, toDisplayString$1(tf("grammar.practice.exercises.explanation", "Explanation")) + ":", 1),
                    createTextVNode(" " + toDisplayString$1(q.explanation), 1)
                  ])
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])
        ]),
        showAnswers.value ? (openBlock(), createElementBlock("div", _hoisted_41$7, [
          createBaseVNode("div", _hoisted_42$6, [
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_43$6, toDisplayString$1(correctAnswers.value), 1),
              createBaseVNode("div", _hoisted_44$6, toDisplayString$1(tf("grammar.practice.exercises.listening.correct", "Correct")), 1)
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_45$5, toDisplayString$1(incorrectAnswers.value), 1),
              createBaseVNode("div", _hoisted_46$5, toDisplayString$1(tf("grammar.practice.exercises.listening.incorrect", "Incorrect")), 1)
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_47$5, toDisplayString$1(accuracy.value) + "%", 1),
              createBaseVNode("div", _hoisted_48$5, toDisplayString$1(tf("grammar.practice.exercises.listening.accuracy", "Accuracy")), 1)
            ])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_49$5, [
          createBaseVNode("div", _hoisted_50$5, [
            _ctx.question.transcript && showAnswers.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: _cache[1] || (_cache[1] = ($event) => showTranscript.value = !showTranscript.value),
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 transition-colors"
            }, [
              _cache[10] || (_cache[10] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(showTranscript.value ? tf("grammar.practice.exercises.listening.hideTranscript", "Hide transcript") : tf("grammar.practice.exercises.listening.showTranscript", "Show transcript")), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_51$4, [
            !showAnswers.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: checkAnswers,
              disabled: !hasAllAnswers.value,
              class: "px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            }, toDisplayString$1(tf("grammar.practice.exercises.checkAnswer", "Check answer")), 9, _hoisted_52$4)) : (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: nextQuestion,
              class: "px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            }, toDisplayString$1(_ctx.questionIndex === _ctx.totalQuestions - 1 ? tf("grammar.practice.exercises.finish", "Finish") : tf("grammar.practice.exercises.next", "Next")), 1))
          ])
        ]),
        showTranscript.value ? (openBlock(), createElementBlock("div", _hoisted_53$4, [
          createBaseVNode("div", _hoisted_54$4, [
            createBaseVNode("div", _hoisted_55$4, [
              createBaseVNode("h3", _hoisted_56$4, toDisplayString$1(tf("grammar.practice.exercises.listening.transcript", "Transcript")), 1),
              createBaseVNode("button", {
                onClick: _cache[2] || (_cache[2] = ($event) => showTranscript.value = false),
                class: "p-2 rounded-lg text-gray-500 dark:text-white/60 hover:text-gray-700 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-white/10 transition-colors"
              }, _cache[11] || (_cache[11] = [
                createBaseVNode("svg", {
                  class: "w-5 h-5",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M6 18L18 6M6 6l12 12"
                  })
                ], -1)
              ]))
            ]),
            createBaseVNode("div", _hoisted_57$4, [
              createBaseVNode("p", _hoisted_58$4, toDisplayString$1(_ctx.question.transcript), 1)
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const ListeningExercise = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$J
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$I = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-white/10 p-6" };
const _hoisted_2$F = { class: "mb-8" };
const _hoisted_3$D = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_4$B = { class: "bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded-lg p-4 mb-6" };
const _hoisted_5$z = { class: "flex items-start space-x-3" };
const _hoisted_6$x = { class: "font-medium text-blue-800 dark:text-blue-200 mb-2" };
const _hoisted_7$w = { class: "text-blue-700 dark:text-blue-300 text-sm" };
const _hoisted_8$w = {
  key: 0,
  class: "mb-6"
};
const _hoisted_9$v = { class: "text-sm font-medium text-gray-700 dark:text-white/70 mb-2" };
const _hoisted_10$u = { class: "space-y-1" };
const _hoisted_11$u = { class: "flex items-center space-x-6 text-sm text-gray-600 dark:text-white/60 mb-4" };
const _hoisted_12$t = {
  key: 0,
  class: "flex items-center space-x-1"
};
const _hoisted_13$t = {
  key: 1,
  class: "flex items-center space-x-1"
};
const _hoisted_14$t = { class: "mb-6" };
const _hoisted_15$p = { class: "flex items-center justify-between mb-4" };
const _hoisted_16$o = { class: "text-lg font-medium text-gray-900 dark:text-white" };
const _hoisted_17$o = { class: "flex items-center space-x-4 text-sm" };
const _hoisted_18$n = { class: "flex items-center space-x-1" };
const _hoisted_19$n = { class: "text-gray-500 dark:text-white/60" };
const _hoisted_20$n = {
  key: 0,
  class: "text-gray-400 dark:text-white/50"
};
const _hoisted_21$n = {
  key: 0,
  class: "flex items-center space-x-1"
};
const _hoisted_22$l = { class: "text-gray-500 dark:text-white/60" };
const _hoisted_23$l = ["disabled", "placeholder"];
const _hoisted_24$k = { class: "mt-4 text-sm text-gray-600 dark:text-white/60" };
const _hoisted_25$k = {
  key: 0,
  class: "mt-2 p-3 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700 rounded-lg"
};
const _hoisted_26$i = { class: "space-y-1" };
const _hoisted_27$h = {
  key: 0,
  class: "mb-6"
};
const _hoisted_28$h = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_29$f = { class: "bg-gradient-to-r from-blue-50 to-purple-50 dark:from-blue-900/30 dark:to-purple-900/30 border border-blue-200 dark:border-blue-700 rounded-lg p-4 mb-4" };
const _hoisted_30$e = { class: "flex items-center justify-between" };
const _hoisted_31$e = { class: "font-medium text-gray-900 dark:text-white" };
const _hoisted_32$c = { class: "text-2xl font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_33$c = { class: "grid grid-cols-2 md:grid-cols-4 gap-4 mt-4" };
const _hoisted_34$b = { class: "text-center" };
const _hoisted_35$b = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_36$a = { class: "text-xs text-gray-600 dark:text-white/60" };
const _hoisted_37$9 = { class: "text-center" };
const _hoisted_38$9 = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_39$7 = { class: "text-xs text-gray-600 dark:text-white/60" };
const _hoisted_40$7 = { class: "text-center" };
const _hoisted_41$6 = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_42$5 = { class: "text-xs text-gray-600 dark:text-white/60" };
const _hoisted_43$5 = { class: "text-center" };
const _hoisted_44$5 = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_45$4 = { class: "text-xs text-gray-600 dark:text-white/60" };
const _hoisted_46$4 = { class: "space-y-4" };
const _hoisted_47$4 = {
  key: 0,
  class: "p-4 bg-green-50 dark:bg-green-900/30 border border-green-200 dark:border-green-700 rounded-lg"
};
const _hoisted_48$4 = { class: "font-medium text-green-800 dark:text-green-200 mb-2" };
const _hoisted_49$4 = { class: "space-y-1" };
const _hoisted_50$4 = {
  key: 1,
  class: "p-4 bg-orange-50 dark:bg-orange-900/30 border border-orange-200 dark:border-orange-700 rounded-lg"
};
const _hoisted_51$3 = { class: "font-medium text-orange-800 dark:text-orange-200 mb-2" };
const _hoisted_52$3 = { class: "space-y-1" };
const _hoisted_53$3 = {
  key: 2,
  class: "p-4 bg-red-50 dark:bg-red-900/30 border border-red-200 dark:border-red-700 rounded-lg"
};
const _hoisted_54$3 = { class: "font-medium text-red-800 dark:text-red-200 mb-2" };
const _hoisted_55$3 = { class: "space-y-2" };
const _hoisted_56$3 = { class: "text-red-700 dark:text-red-300" };
const _hoisted_57$3 = { class: "text-green-700 dark:text-green-300" };
const _hoisted_58$3 = {
  key: 0,
  class: "text-gray-600 dark:text-white/60 text-xs mt-1"
};
const _hoisted_59$3 = { class: "flex justify-between items-center" };
const _hoisted_60$3 = { class: "flex space-x-4" };
const _hoisted_61$3 = { class: "flex space-x-4" };
const _hoisted_62$3 = ["disabled"];
const _sfc_main$I = /* @__PURE__ */ defineComponent({
  __name: "WritingExercise",
  props: {
    question: {},
    questionIndex: {},
    totalQuestions: {}
  },
  emits: ["answer", "next", "complete"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      const translated = params ? t(key, params) : t(key);
      const text = typeof translated === "string" ? translated : String(translated);
      if (text === key) return fallback;
      return text;
    };
    const props = __props;
    const emit = __emit;
    const userText = ref("");
    const wordCount = ref(0);
    const timeRemaining = ref(0);
    const timeExpired = ref(false);
    const isSubmitted = ref(false);
    const isAnalyzing = ref(false);
    const showTips = ref(false);
    const timer = ref(null);
    const feedback = ref(null);
    const canSubmit = computed(() => {
      return userText.value.trim().length > 0 && wordCount.value >= (props.question.minWords || 0) && !timeExpired.value && !isAnalyzing.value;
    });
    const writingTips = computed(() => {
      const tips = [
        tf("grammar.practice.exercises.writing.tip1", "Plan your structure before writing."),
        tf("grammar.practice.exercises.writing.tip2", "Use clear and concise sentences."),
        tf("grammar.practice.exercises.writing.tip3", "Vary vocabulary and sentence patterns."),
        tf("grammar.practice.exercises.writing.tip4", "Check grammar and punctuation."),
        tf("grammar.practice.exercises.writing.tip5", "Review and edit your response.")
      ];
      return tips;
    });
    const updateWordCount = () => {
      wordCount.value = userText.value.trim().split(/\s+/).filter((word) => word.length > 0).length;
    };
    const getPlaceholderText = () => {
      switch (props.question.taskType) {
        case "essay":
          return tf("grammar.practice.exercises.writing.essayPlaceholder", "Write your essay here...");
        case "email":
          return tf("grammar.practice.exercises.writing.emailPlaceholder", "Write your email here...");
        case "letter":
          return tf("grammar.practice.exercises.writing.letterPlaceholder", "Write your letter here...");
        default:
          return tf("grammar.practice.exercises.writing.paragraphPlaceholder", "Write your paragraph here...");
      }
    };
    const startTimer = () => {
      if (props.question.timeLimit) {
        timeRemaining.value = props.question.timeLimit * 60;
        timer.value = setInterval(() => {
          timeRemaining.value--;
          if (timeRemaining.value <= 0) {
            timeExpired.value = true;
            stopTimer();
            if (!isSubmitted.value) {
              submitForReview();
            }
          }
        }, 1e3);
      }
    };
    const stopTimer = () => {
      if (timer.value) {
        clearInterval(timer.value);
        timer.value = null;
      }
    };
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    };
    const saveDraft = () => {
      const draftKey = `writing-draft-${props.question.id}`;
      localStorage.setItem(draftKey, userText.value);
      console.log("Draft saved!");
    };
    const clearText = () => {
      if (confirm(t("grammar.practice.exercises.writing.confirmClear", "Clear all text?"))) {
        userText.value = "";
        wordCount.value = 0;
      }
    };
    const submitForReview = async () => {
      isAnalyzing.value = true;
      stopTimer();
      try {
        await new Promise((resolve) => setTimeout(resolve, 3e3));
        const mockFeedback = {
          overallScore: Math.floor(Math.random() * 30) + 70,
          // 70-100
          grammar: Math.floor(Math.random() * 30) + 70,
          vocabulary: Math.floor(Math.random() * 30) + 70,
          coherence: Math.floor(Math.random() * 30) + 70,
          taskResponse: Math.floor(Math.random() * 30) + 70,
          strengths: [
            "Good use of complex sentence structures",
            "Clear organization of ideas",
            "Appropriate vocabulary for the task"
          ],
          improvements: [
            "Work on paragraph transitions",
            "Use more varied sentence beginnings",
            "Expand on supporting details"
          ],
          corrections: [
            {
              original: "This is very good",
              corrected: "This is excellent",
              explanation: "Use more precise adjectives for better impact"
            }
          ]
        };
        feedback.value = mockFeedback;
        isSubmitted.value = true;
        const score = mockFeedback.overallScore;
        emit("answer", {
          isCorrect: score >= 70,
          score,
          text: userText.value
        });
      } catch (error) {
        console.error("Error analyzing writing:", error);
      } finally {
        isAnalyzing.value = false;
      }
    };
    const nextQuestion = () => {
      if (props.questionIndex === props.totalQuestions - 1) {
        emit("complete");
      } else {
        resetExercise();
        emit("next");
      }
    };
    const resetExercise = () => {
      userText.value = "";
      wordCount.value = 0;
      timeExpired.value = false;
      isSubmitted.value = false;
      isAnalyzing.value = false;
      showTips.value = false;
      feedback.value = null;
      stopTimer();
      startTimer();
    };
    const loadDraft = () => {
      const draftKey = `writing-draft-${props.question.id}`;
      const draft = localStorage.getItem(draftKey);
      if (draft) {
        userText.value = draft;
        updateWordCount();
      }
    };
    onMounted(() => {
      startTimer();
      loadDraft();
    });
    onUnmounted(() => {
      stopTimer();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$I, [
        createBaseVNode("div", _hoisted_2$F, [
          createBaseVNode("h3", _hoisted_3$D, toDisplayString$1(tf("grammar.practice.exercises.writing.instruction", "Follow the writing instructions")), 1),
          createBaseVNode("div", _hoisted_4$B, [
            createBaseVNode("div", _hoisted_5$z, [
              _cache[2] || (_cache[2] = createBaseVNode("div", { class: "w-6 h-6 bg-blue-600 rounded-full flex items-center justify-center flex-shrink-0 mt-1" }, [
                createBaseVNode("svg", {
                  class: "w-4 h-4 text-white",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                  })
                ])
              ], -1)),
              createBaseVNode("div", null, [
                createBaseVNode("h4", _hoisted_6$x, toDisplayString$1(_ctx.question.taskType === "essay" ? tf("grammar.practice.exercises.writing.essay", "Essay") : _ctx.question.taskType === "email" ? tf("grammar.practice.exercises.writing.email", "Email") : _ctx.question.taskType === "letter" ? tf("grammar.practice.exercises.writing.letter", "Letter") : tf("grammar.practice.exercises.writing.paragraph", "Paragraph")), 1),
                createBaseVNode("p", _hoisted_7$w, toDisplayString$1(_ctx.question.prompt), 1)
              ])
            ])
          ]),
          _ctx.question.requirements && _ctx.question.requirements.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_8$w, [
            createBaseVNode("h4", _hoisted_9$v, toDisplayString$1(tf("grammar.practice.exercises.writing.requirements", "Requirements")), 1),
            createBaseVNode("ul", _hoisted_10$u, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.question.requirements, (requirement) => {
                return openBlock(), createElementBlock("li", {
                  key: requirement,
                  class: "flex items-start space-x-2 text-sm text-gray-600 dark:text-white/60"
                }, [
                  _cache[3] || (_cache[3] = createBaseVNode("svg", {
                    class: "w-4 h-4 text-green-600 dark:text-green-400 mt-0.5 flex-shrink-0",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M5 13l4 4L19 7"
                    })
                  ], -1)),
                  createBaseVNode("span", null, toDisplayString$1(requirement), 1)
                ]);
              }), 128))
            ])
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_11$u, [
            _ctx.question.minWords ? (openBlock(), createElementBlock("div", _hoisted_12$t, [
              _cache[4] || (_cache[4] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.exercises.writing.minWords", "Min words")) + ": " + toDisplayString$1(_ctx.question.minWords), 1)
            ])) : createCommentVNode("", true),
            _ctx.question.timeLimit ? (openBlock(), createElementBlock("div", _hoisted_13$t, [
              _cache[5] || (_cache[5] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.exercises.writing.timeLimit", "Time limit")) + ": " + toDisplayString$1(_ctx.question.timeLimit) + " " + toDisplayString$1(tf("common.minutes", "minutes")), 1)
            ])) : createCommentVNode("", true)
          ])
        ]),
        createBaseVNode("div", _hoisted_14$t, [
          createBaseVNode("div", _hoisted_15$p, [
            createBaseVNode("h4", _hoisted_16$o, toDisplayString$1(tf("grammar.practice.exercises.writing.yourResponse", "Your response")), 1),
            createBaseVNode("div", _hoisted_17$o, [
              createBaseVNode("div", _hoisted_18$n, [
                createBaseVNode("span", _hoisted_19$n, toDisplayString$1(tf("grammar.practice.exercises.writing.words", "Words")) + ":", 1),
                createBaseVNode("span", {
                  class: normalizeClass([
                    "font-medium",
                    wordCount.value >= (_ctx.question.minWords || 0) ? "text-green-600 dark:text-green-400" : "text-orange-600 dark:text-orange-400"
                  ])
                }, toDisplayString$1(wordCount.value), 3),
                _ctx.question.minWords ? (openBlock(), createElementBlock("span", _hoisted_20$n, " / " + toDisplayString$1(_ctx.question.minWords), 1)) : createCommentVNode("", true)
              ]),
              _ctx.question.timeLimit ? (openBlock(), createElementBlock("div", _hoisted_21$n, [
                createBaseVNode("span", _hoisted_22$l, toDisplayString$1(tf("grammar.practice.exercises.writing.timeLeft", "Time left")) + ":", 1),
                createBaseVNode("span", {
                  class: normalizeClass([
                    "font-medium font-mono",
                    timeRemaining.value <= 300 ? "text-red-600 dark:text-red-400" : "text-blue-600 dark:text-blue-400"
                  ])
                }, toDisplayString$1(formatTime(timeRemaining.value)), 3)
              ])) : createCommentVNode("", true)
            ])
          ]),
          withDirectives(createBaseVNode("textarea", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => userText.value = $event),
            disabled: timeExpired.value || isSubmitted.value,
            placeholder: getPlaceholderText(),
            class: "w-full h-80 px-4 py-3 border border-gray-300 dark:border-white/10 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white resize-none disabled:bg-gray-100 dark:disabled:bg-white/5 disabled:cursor-not-allowed",
            onInput: updateWordCount
          }, null, 40, _hoisted_23$l), [
            [vModelText, userText.value]
          ]),
          createBaseVNode("div", _hoisted_24$k, [
            createBaseVNode("button", {
              onClick: _cache[1] || (_cache[1] = ($event) => showTips.value = !showTips.value),
              class: "flex items-center space-x-1 hover:text-gray-800 dark:hover:text-white/80 transition-colors"
            }, [
              _cache[6] || (_cache[6] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.exercises.writing.tips", "Tips")), 1)
            ]),
            showTips.value ? (openBlock(), createElementBlock("div", _hoisted_25$k, [
              createBaseVNode("ul", _hoisted_26$i, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(writingTips.value, (tip) => {
                  return openBlock(), createElementBlock("li", {
                    key: tip,
                    class: "text-yellow-800 dark:text-yellow-200"
                  }, " • " + toDisplayString$1(tip), 1);
                }), 128))
              ])
            ])) : createCommentVNode("", true)
          ])
        ]),
        isSubmitted.value && feedback.value ? (openBlock(), createElementBlock("div", _hoisted_27$h, [
          createBaseVNode("h4", _hoisted_28$h, toDisplayString$1(tf("grammar.practice.exercises.writing.feedback", "Feedback")), 1),
          createBaseVNode("div", _hoisted_29$f, [
            createBaseVNode("div", _hoisted_30$e, [
              createBaseVNode("h5", _hoisted_31$e, toDisplayString$1(tf("grammar.practice.exercises.writing.overallScore", "Overall score")), 1),
              createBaseVNode("div", _hoisted_32$c, toDisplayString$1(feedback.value.overallScore) + "/100 ", 1)
            ]),
            createBaseVNode("div", _hoisted_33$c, [
              createBaseVNode("div", _hoisted_34$b, [
                createBaseVNode("div", _hoisted_35$b, toDisplayString$1(feedback.value.grammar), 1),
                createBaseVNode("div", _hoisted_36$a, toDisplayString$1(tf("grammar.practice.exercises.writing.grammar", "Grammar")), 1)
              ]),
              createBaseVNode("div", _hoisted_37$9, [
                createBaseVNode("div", _hoisted_38$9, toDisplayString$1(feedback.value.vocabulary), 1),
                createBaseVNode("div", _hoisted_39$7, toDisplayString$1(tf("grammar.practice.exercises.writing.vocabulary", "Vocabulary")), 1)
              ]),
              createBaseVNode("div", _hoisted_40$7, [
                createBaseVNode("div", _hoisted_41$6, toDisplayString$1(feedback.value.coherence), 1),
                createBaseVNode("div", _hoisted_42$5, toDisplayString$1(tf("grammar.practice.exercises.writing.coherence", "Coherence")), 1)
              ]),
              createBaseVNode("div", _hoisted_43$5, [
                createBaseVNode("div", _hoisted_44$5, toDisplayString$1(feedback.value.taskResponse), 1),
                createBaseVNode("div", _hoisted_45$4, toDisplayString$1(tf("grammar.practice.exercises.writing.taskResponse", "Task response")), 1)
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_46$4, [
            feedback.value.strengths.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_47$4, [
              createBaseVNode("h6", _hoisted_48$4, toDisplayString$1(tf("grammar.practice.exercises.writing.strengths", "Strengths")), 1),
              createBaseVNode("ul", _hoisted_49$4, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(feedback.value.strengths, (strength) => {
                  return openBlock(), createElementBlock("li", {
                    key: strength,
                    class: "text-green-700 dark:text-green-300 text-sm"
                  }, " ✓ " + toDisplayString$1(strength), 1);
                }), 128))
              ])
            ])) : createCommentVNode("", true),
            feedback.value.improvements.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_50$4, [
              createBaseVNode("h6", _hoisted_51$3, toDisplayString$1(tf("grammar.practice.exercises.writing.improvements", "Areas for improvement")), 1),
              createBaseVNode("ul", _hoisted_52$3, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(feedback.value.improvements, (improvement) => {
                  return openBlock(), createElementBlock("li", {
                    key: improvement,
                    class: "text-orange-700 dark:text-orange-300 text-sm"
                  }, " → " + toDisplayString$1(improvement), 1);
                }), 128))
              ])
            ])) : createCommentVNode("", true),
            feedback.value.corrections.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_53$3, [
              createBaseVNode("h6", _hoisted_54$3, toDisplayString$1(tf("grammar.practice.exercises.writing.corrections", "Corrections")), 1),
              createBaseVNode("div", _hoisted_55$3, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(feedback.value.corrections, (correction) => {
                  return openBlock(), createElementBlock("div", {
                    key: correction.original,
                    class: "text-sm"
                  }, [
                    createBaseVNode("div", _hoisted_56$3, " ❌ " + toDisplayString$1(correction.original), 1),
                    createBaseVNode("div", _hoisted_57$3, " ✅ " + toDisplayString$1(correction.corrected), 1),
                    correction.explanation ? (openBlock(), createElementBlock("div", _hoisted_58$3, toDisplayString$1(correction.explanation), 1)) : createCommentVNode("", true)
                  ]);
                }), 128))
              ])
            ])) : createCommentVNode("", true)
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_59$3, [
          createBaseVNode("div", _hoisted_60$3, [
            !isSubmitted.value && userText.value.trim() ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: saveDraft,
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
            }, [
              _cache[7] || (_cache[7] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3-3m0 0l-3 3m3-3v12"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.exercises.writing.saveDraft", "Save draft")), 1)
            ])) : createCommentVNode("", true),
            !isSubmitted.value && userText.value.trim() ? (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: clearText,
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:text-red-700 dark:hover:text-red-300 transition-colors"
            }, [
              _cache[8] || (_cache[8] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.exercises.writing.clear", "Clear")), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_61$3, [
            !isSubmitted.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: submitForReview,
              disabled: !canSubmit.value,
              class: "px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            }, toDisplayString$1(isAnalyzing.value ? tf("grammar.practice.exercises.writing.analyzing", "Analyzing...") : tf("grammar.practice.exercises.writing.submit", "Submit for review")), 9, _hoisted_62$3)) : (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: nextQuestion,
              class: "px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            }, toDisplayString$1(_ctx.questionIndex === _ctx.totalQuestions - 1 ? tf("grammar.practice.finish", "Finish") : tf("grammar.practice.next", "Next")), 1))
          ])
        ])
      ]);
    };
  }
});

const WritingExercise = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$I
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$H = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 dark:bg-black/60 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$E = { class: "w-full max-h-[90vh] flex flex-col max-w-full sm:max-w-lg md:max-w-2xl lg:max-w-4xl" };
const _hoisted_3$C = { class: "px-6 py-4 border-b-0 dark:border-b dark:border-gray-custom flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$A = { class: "flex items-center justify-between" };
const _hoisted_5$y = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$w = { class: "px-6 py-4 flex-1 overflow-y-auto min-h-0" };
const _hoisted_7$v = { class: "space-y-6" };
const _hoisted_8$v = {
  class: "bg-white dark:bg-gray-custom border-0 dark:border dark:border-gray-custom rounded-lg p-4 animate-fade-in-up ring-1 ring-gray-100 dark:ring-0",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_9$u = { class: "text-md font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_10$t = { class: "grid grid-cols-1 md:grid-cols-2 gap-4" };
const _hoisted_11$t = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_12$s = { class: "block text-sm font-medium text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_13$s = ["placeholder"];
const _hoisted_14$s = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_15$o = { class: "block text-sm font-medium text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_16$n = ["placeholder"];
const _hoisted_17$n = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_18$m = { class: "block text-sm font-medium text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_19$m = ["placeholder"];
const _hoisted_20$m = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_21$m = { class: "block text-sm font-medium text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_22$k = { value: "easy" };
const _hoisted_23$k = { value: "medium" };
const _hoisted_24$j = { value: "hard" };
const _hoisted_25$j = { class: "block text-sm font-medium text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_26$h = ["placeholder"];
const _hoisted_27$g = {
  class: "flex justify-end mt-4 animate-fade-in-up",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_28$g = { class: "text-md font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_29$e = { class: "grid grid-cols-1 md:grid-cols-2 gap-4" };
const _hoisted_30$d = { class: "flex items-start justify-between" };
const _hoisted_31$d = { class: "flex-1" };
const _hoisted_32$b = { class: "flex items-center space-x-2 mb-2" };
const _hoisted_33$b = { class: "font-medium text-gray-900 dark:text-white" };
const _hoisted_34$a = { class: "text-sm text-gray-600 dark:text-white/60 mb-2" };
const _hoisted_35$a = { class: "flex items-center space-x-4 text-xs text-gray-500 dark:text-white/60" };
const _hoisted_36$9 = { class: "flex items-center space-x-2 ml-4" };
const _hoisted_37$8 = ["onClick", "title"];
const _hoisted_38$8 = ["onClick", "title"];
const _hoisted_39$6 = ["onClick", "title"];
const _hoisted_40$6 = { class: "px-6 py-4 border-t-0 dark:border-t dark:border-gray-custom flex-shrink-0 bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_41$5 = { class: "flex justify-end space-x-3" };
const _sfc_main$H = /* @__PURE__ */ defineComponent({
  __name: "ExerciseManager",
  props: {
    modelValue: { type: Boolean },
    exerciseTypes: {}
  },
  emits: ["update:modelValue", "add-exercise", "edit-exercise", "delete-exercise", "save-exercises", "open-question-manager"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      const translated = params ? t(key, params) : t(key);
      const text = typeof translated === "string" ? translated : String(translated);
      if (text === key) return fallback;
      return text;
    };
    const newExercise = reactive({
      type: "",
      title: "",
      description: "",
      difficulty: "easy",
      duration: "",
      icon: "BookOpenIcon",
      colorClass: "bg-gray-500"
    });
    const closeModal = () => {
      emit("update:modelValue", false);
    };
    const addExerciseType = () => {
      if (!newExercise.type || !newExercise.title || !newExercise.description) {
        return;
      }
      const exerciseToAdd = {
        ...newExercise,
        icon: getIconForType(newExercise.type),
        colorClass: getColorForType(newExercise.type)
      };
      emit("add-exercise", exerciseToAdd);
      Object.assign(newExercise, {
        type: "",
        title: "",
        description: "",
        difficulty: "easy",
        duration: "",
        icon: "BookOpenIcon",
        colorClass: "bg-gray-500"
      });
    };
    const editExerciseType = (index) => {
      const exercise = props.exerciseTypes[index];
      Object.assign(newExercise, exercise);
      emit("edit-exercise", index, exercise);
    };
    const deleteExerciseType = (index) => {
      if (confirm(t("common.confirmDelete", "Are you sure you want to delete this?"))) {
        emit("delete-exercise", index);
      }
    };
    const saveExerciseTypes = () => {
      emit("save-exercises");
      closeModal();
    };
    const openQuestionManager = (exerciseType) => {
      emit("open-question-manager", exerciseType);
    };
    const getIconForType = (type) => {
      const iconMap = {
        "multiple-choice": "CheckCircleIcon",
        "fill-blank": "PencilIcon",
        "writing": "DocumentTextIcon",
        "listening": "SpeakerWaveIcon",
        "reading": "BookOpenIcon",
        "grammar": "AcademicCapIcon"
      };
      return iconMap[type] || "BookOpenIcon";
    };
    const getColorForType = (type) => {
      const colorMap = {
        "multiple-choice": "bg-gray-500",
        "fill-blank": "bg-green-500",
        "writing": "bg-purple-500",
        "listening": "bg-orange-500",
        "reading": "bg-indigo-500",
        "grammar": "bg-red-500"
      };
      return colorMap[type] || "bg-gray-500";
    };
    watch(() => props.modelValue, (newValue) => {
      if (!newValue) {
        Object.assign(newExercise, {
          type: "",
          title: "",
          description: "",
          difficulty: "easy",
          duration: "",
          icon: "BookOpenIcon",
          colorClass: "bg-gray-500"
        });
      }
    });
    const lockBodyScroll = () => {
      document.body.style.overflow = "hidden";
    };
    const unlockBodyScroll = () => {
      document.body.style.overflow = "";
    };
    watch(() => props.modelValue, (open) => {
      if (open) lockBodyScroll();
      else unlockBodyScroll();
    }, { immediate: true });
    onUnmounted(() => {
      unlockBodyScroll();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        appear: "",
        "enter-active-class": "transition-all duration-500 ease-out",
        "enter-from-class": "opacity-0",
        "enter-to-class": "opacity-100",
        "leave-active-class": "transition-all duration-300 ease-in",
        "leave-from-class": "opacity-100",
        "leave-to-class": "opacity-0"
      }, {
        default: withCtx(() => [
          _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$H, [
            createVNode(Transition, {
              appear: "",
              "enter-active-class": "transition-all duration-500 ease-out",
              "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
              "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
              "leave-active-class": "transition-all duration-300 ease-in",
              "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
              "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
            }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_2$E, [
                  createBaseVNode("div", {
                    class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border-0 dark:border dark:border-gray-custom flex flex-col h-full overflow-hidden transform transform-gpu will-change-transform",
                    onClick: _cache[5] || (_cache[5] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("div", _hoisted_3$C, [
                      createBaseVNode("div", _hoisted_4$A, [
                        createBaseVNode("h3", _hoisted_5$y, [
                          _cache[6] || (_cache[6] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                          createBaseVNode("span", null, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.title", "Exercise Manager")), 1)
                        ]),
                        createBaseVNode("button", {
                          onClick: closeModal,
                          class: "text-gray-400 hover:text-gray-600 dark:text-white/60 dark:hover:text-white transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-white/10",
                          "aria-label": "Close"
                        }, _cache[7] || (_cache[7] = [
                          createBaseVNode("svg", {
                            class: "w-6 h-6",
                            fill: "none",
                            stroke: "currentColor",
                            viewBox: "0 0 24 24"
                          }, [
                            createBaseVNode("path", {
                              "stroke-linecap": "round",
                              "stroke-linejoin": "round",
                              "stroke-width": "2",
                              d: "M6 18L18 6M6 6l12 12"
                            })
                          ], -1)
                        ]))
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_6$w, [
                      createBaseVNode("div", _hoisted_7$v, [
                        createBaseVNode("div", _hoisted_8$v, [
                          createBaseVNode("h4", _hoisted_9$u, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.addNew", "Add new exercise type")), 1),
                          createBaseVNode("div", _hoisted_10$t, [
                            createBaseVNode("div", _hoisted_11$t, [
                              createBaseVNode("label", _hoisted_12$s, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.exerciseType", "Exercise type")), 1),
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => newExercise.type = $event),
                                type: "text",
                                class: "w-full px-3 py-2 border-0 dark:border dark:border-gray-custom rounded-lg bg-white dark:bg-gray-custom text-gray-900 dark:text-white ring-1 ring-gray-200/50 dark:ring-0 shadow-sm dark:shadow-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 dark:hover:border-blue-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("grammar.practice.exerciseManager.typePlaceholder", "e.g. multiple-choice")
                              }, null, 8, _hoisted_13$s), [
                                [vModelText, newExercise.type]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_14$s, [
                              createBaseVNode("label", _hoisted_15$o, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.title", "Title")), 1),
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => newExercise.title = $event),
                                type: "text",
                                class: "w-full px-3 py-2 border-0 dark:border dark:border-gray-custom rounded-lg bg-white dark:bg-gray-custom text-gray-900 dark:text-white ring-1 ring-gray-200/50 dark:ring-0 shadow-sm dark:shadow-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 dark:hover:border-blue-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("grammar.practice.exerciseManager.titlePlaceholder", "Enter exercise title")
                              }, null, 8, _hoisted_16$n), [
                                [vModelText, newExercise.title]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_17$n, [
                              createBaseVNode("label", _hoisted_18$m, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.description", "Description")), 1),
                              withDirectives(createBaseVNode("textarea", {
                                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => newExercise.description = $event),
                                rows: "3",
                                class: "w-full px-3 py-2 border-0 dark:border dark:border-gray-custom rounded-lg bg-white dark:bg-gray-custom text-gray-900 dark:text-white ring-1 ring-gray-200/50 dark:ring-0 shadow-sm dark:shadow-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 dark:hover:border-blue-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("grammar.practice.exerciseManager.descriptionPlaceholder", "Briefly describe this exercise")
                              }, null, 8, _hoisted_19$m), [
                                [vModelText, newExercise.description]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_20$m, [
                              createBaseVNode("label", _hoisted_21$m, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.difficulty", "Difficulty")), 1),
                              withDirectives(createBaseVNode("select", {
                                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => newExercise.difficulty = $event),
                                class: "w-full px-3 py-2 border-0 dark:border dark:border-gray-custom rounded-lg bg-white dark:bg-gray-custom text-gray-900 dark:text-white ring-1 ring-gray-200/50 dark:ring-0 shadow-sm dark:shadow-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 dark:hover:border-blue-500 transform hover:scale-[1.02] cursor-pointer"
                              }, [
                                createBaseVNode("option", _hoisted_22$k, toDisplayString$1(unref(t)("grammar.practice.settings.levels.easy", "Easy")), 1),
                                createBaseVNode("option", _hoisted_23$k, toDisplayString$1(unref(t)("grammar.practice.settings.levels.medium", "Medium")), 1),
                                createBaseVNode("option", _hoisted_24$j, toDisplayString$1(unref(t)("grammar.practice.settings.levels.hard", "Hard")), 1)
                              ], 512), [
                                [vModelSelect, newExercise.difficulty]
                              ])
                            ]),
                            createBaseVNode("div", null, [
                              createBaseVNode("label", _hoisted_25$j, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.duration", "Duration")), 1),
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => newExercise.duration = $event),
                                type: "text",
                                class: "w-full px-3 py-2 border-0 dark:border dark:border-gray-custom rounded-lg bg-white dark:bg-gray-custom text-gray-900 dark:text-white ring-1 ring-gray-200/50 dark:ring-0 shadow-sm dark:shadow-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 dark:hover:border-blue-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("grammar.practice.exerciseManager.durationPlaceholder", "e.g. 10-15 min")
                              }, null, 8, _hoisted_26$h), [
                                [vModelText, newExercise.duration]
                              ])
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_27$g, [
                            createBaseVNode("button", {
                              onClick: addExerciseType,
                              class: "px-5 py-2 text-sm font-medium text-white bg-gradient-to-r from-blue-500 to-blue-600 rounded-lg hover:from-blue-600 hover:to-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-300 hover:scale-105 hover:shadow-lg"
                            }, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.add", "Add")), 1)
                          ])
                        ]),
                        createBaseVNode("div", null, [
                          createBaseVNode("h4", _hoisted_28$g, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.existing", "Existing exercise types")), 1),
                          createBaseVNode("div", _hoisted_29$e, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.exerciseTypes, (exercise, index) => {
                              return openBlock(), createElementBlock("div", {
                                key: exercise.type,
                                class: "bg-white dark:bg-gray-custom border-0 dark:border dark:border-gray-custom rounded-lg p-4 ring-1 ring-gray-100 dark:ring-0"
                              }, [
                                createBaseVNode("div", _hoisted_30$d, [
                                  createBaseVNode("div", _hoisted_31$d, [
                                    createBaseVNode("div", _hoisted_32$b, [
                                      (openBlock(), createBlock(resolveDynamicComponent(exercise.icon), {
                                        class: normalizeClass(["w-5 h-5", exercise.colorClass.replace("bg-", "text-")])
                                      }, null, 8, ["class"])),
                                      createBaseVNode("h5", _hoisted_33$b, toDisplayString$1(tf(`grammar.practice.exercises.${exercise.type}.title`, exercise.title)), 1)
                                    ]),
                                    createBaseVNode("p", _hoisted_34$a, toDisplayString$1(tf(`grammar.practice.exercises.${exercise.type}.description`, exercise.description)), 1),
                                    createBaseVNode("div", _hoisted_35$a, [
                                      createBaseVNode("span", null, toDisplayString$1(exercise.difficulty), 1),
                                      createBaseVNode("span", null, toDisplayString$1(exercise.duration), 1)
                                    ])
                                  ]),
                                  createBaseVNode("div", _hoisted_36$9, [
                                    createBaseVNode("button", {
                                      onClick: ($event) => openQuestionManager(exercise.type),
                                      class: "p-1 rounded text-green-600 dark:text-green-400 hover:bg-green-100 dark:hover:bg-green-900/30 transition-colors",
                                      title: unref(t)("grammar.practice.exerciseManager.manageQuestions", "Manage questions")
                                    }, _cache[8] || (_cache[8] = [
                                      createBaseVNode("svg", {
                                        class: "w-4 h-4",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                                        })
                                      ], -1)
                                    ]), 8, _hoisted_37$8),
                                    createBaseVNode("button", {
                                      onClick: ($event) => editExerciseType(index),
                                      class: "p-1 rounded text-blue-600 dark:text-blue-400 hover:bg-blue-100 dark:hover:bg-blue-900/30 transition-colors",
                                      title: unref(t)("common.edit", "Edit")
                                    }, _cache[9] || (_cache[9] = [
                                      createBaseVNode("svg", {
                                        class: "w-4 h-4",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                                        })
                                      ], -1)
                                    ]), 8, _hoisted_38$8),
                                    createBaseVNode("button", {
                                      onClick: ($event) => deleteExerciseType(index),
                                      class: "p-1 rounded text-red-600 dark:text-red-400 hover:bg-red-100 dark:hover:bg-red-900/30 transition-colors",
                                      title: unref(t)("common.delete", "Delete")
                                    }, _cache[10] || (_cache[10] = [
                                      createBaseVNode("svg", {
                                        class: "w-4 h-4",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                                        })
                                      ], -1)
                                    ]), 8, _hoisted_39$6)
                                  ])
                                ])
                              ]);
                            }), 128))
                          ])
                        ])
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_40$6, [
                      createBaseVNode("div", _hoisted_41$5, [
                        createBaseVNode("button", {
                          onClick: closeModal,
                          class: "px-6 py-2 text-gray-700 dark:text-white/80 bg-gray-100 dark:bg-gray-custom hover:bg-gray-200 dark:hover:bg-white/10 rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium"
                        }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                        createBaseVNode("button", {
                          onClick: saveExerciseTypes,
                          class: "px-6 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg hover:from-blue-600 hover:to-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium"
                        }, toDisplayString$1(unref(t)("common.save", "Save")), 1)
                      ])
                    ])
                  ])
                ])
              ]),
              _: 1
            })
          ])) : createCommentVNode("", true)
        ]),
        _: 1
      });
    };
  }
});

const ExerciseManager = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$H
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$G = { class: "bg-white dark:bg-black shadow border-b border-gray-200 dark:border-gray-800" };
const _hoisted_2$D = { class: "max-w-4xl mx-auto py-3 sm:py-4 md:py-6 px-3 sm:px-4 md:px-6" };
const _hoisted_3$B = { class: "sm:hidden" };
const _hoisted_4$z = { class: "flex items-center justify-between mb-3" };
const _hoisted_5$x = { class: "flex items-center" };
const _hoisted_6$v = { class: "text-xl font-bold text-gray-900 dark:text-transparent bg-clip-text bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 dark:from-blue-400 dark:via-purple-400 dark:to-pink-400" };
const _hoisted_7$u = { class: "text-right" };
const _hoisted_8$u = { class: "text-xs text-gray-500 dark:text-white/60" };
const _hoisted_9$t = { class: "text-sm font-semibo ld text-gray-900 dark:text-white" };
const _hoisted_10$s = { class: "flex items-center justify-between" };
const _hoisted_11$s = { class: "flex items-center space-x-2" };
const _hoisted_12$r = ["title"];
const _hoisted_13$r = ["disabled", "aria-disabled", "title"];
const _hoisted_14$r = { class: "flex items-center space-x-2" };
const _hoisted_15$n = { class: "relative" };
const _hoisted_16$m = ["disabled", "aria-disabled", "title", "aria-label"];
const _hoisted_17$m = { class: "truncate" };
const _hoisted_18$l = {
  key: 0,
  class: "absolute right-0 mt-1 w-44 z-[9999] rounded-md shadow-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-[#0f0f0f] overflow-hidden"
};
const _hoisted_19$l = { class: "py-1 text-xs text-gray-900 dark:text-white" };
const _hoisted_20$l = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_21$l = ["title", "aria-label"];
const _hoisted_22$j = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_23$j = ["title", "aria-label"];
const _hoisted_24$i = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_25$i = ["title", "aria-label"];
const _hoisted_26$g = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_27$f = ["disabled", "aria-disabled", "title"];
const _hoisted_28$f = ["title", "aria-label"];
const _hoisted_29$d = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_30$c = ["disabled", "aria-disabled", "title"];
const _hoisted_31$c = ["title", "aria-label"];
const _hoisted_32$a = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_33$a = ["disabled", "aria-disabled", "title"];
const _hoisted_34$9 = ["title", "aria-label"];
const _hoisted_35$9 = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_36$8 = ["disabled", "aria-disabled", "title"];
const _hoisted_37$7 = ["title", "aria-label"];
const _hoisted_38$7 = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_39$5 = ["title"];
const _hoisted_40$5 = ["title", "aria-label"];
const _hoisted_41$4 = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_42$4 = ["title", "aria-label"];
const _hoisted_43$4 = ["disabled", "title"];
const _hoisted_44$4 = { class: "hidden sm:flex items-center justify-between" };
const _hoisted_45$3 = { class: "flex items-center" };
const _hoisted_46$3 = { class: "text-2xl md:text-3xl font-bold text-gray-900 dark:text-transparent bg-clip-text bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 dark:from-blue-400 dark:via-purple-400 dark:to-pink-400" };
const _hoisted_47$3 = { class: "mt-1 md:mt-2 text-sm md:text-base text-gray-600 dark:text-white/70" };
const _hoisted_48$3 = { class: "flex items-center space-x-3 md:space-x-4" };
const _hoisted_49$3 = ["title"];
const _hoisted_50$3 = { class: "flex items-center space-x-2 md:space-x-3" };
const _hoisted_51$2 = { class: "text-sm md:text-base text-gray-600 dark:text-white/70" };
const _hoisted_52$2 = ["disabled", "title"];
const _hoisted_53$2 = { class: "text-right" };
const _hoisted_54$2 = { class: "text-sm md:text-base text-gray-500 dark:text-white/60" };
const _hoisted_55$2 = { class: "text-lg md:text-xl font-semibold text-gray-900 dark:text-white" };
const _hoisted_56$2 = { class: "flex items-center space-x-2 md:space-x-3" };
const _hoisted_57$2 = { class: "relative" };
const _hoisted_58$2 = ["disabled", "aria-disabled", "title", "aria-label"];
const _hoisted_59$2 = { class: "truncate" };
const _hoisted_60$2 = {
  key: 0,
  class: "absolute right-0 mt-1 w-52 z-[9999] rounded-md shadow-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-[#0f0f0f] overflow-hidden"
};
const _hoisted_61$2 = { class: "py-1 text-sm text-gray-900 dark:text-white" };
const _hoisted_62$2 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_63$2 = ["title", "aria-label"];
const _hoisted_64$2 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_65$2 = ["title", "aria-label"];
const _hoisted_66$2 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_67$2 = ["title", "aria-label"];
const _hoisted_68$2 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_69$2 = ["disabled", "aria-disabled", "title"];
const _hoisted_70$2 = ["title", "aria-label"];
const _hoisted_71$2 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_72$2 = ["disabled", "aria-disabled", "title"];
const _hoisted_73$2 = ["title", "aria-label"];
const _hoisted_74$2 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_75$2 = ["disabled", "aria-disabled", "title"];
const _hoisted_76$2 = ["title", "aria-label"];
const _hoisted_77$2 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_78$1 = ["disabled", "aria-disabled", "title"];
const _hoisted_79$1 = ["title", "aria-label"];
const _hoisted_80$1 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_81$1 = ["title"];
const _hoisted_82$1 = ["title", "aria-label"];
const _hoisted_83$1 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_84$1 = ["title", "aria-label"];
const _hoisted_85$1 = ["disabled", "aria-disabled", "title"];
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "FlashcardHeader",
  props: {
    currentIndex: {},
    totalCards: {},
    practiceMode: {},
    shuffleEnabled: { type: Boolean },
    practiceStarted: { type: Boolean },
    imageQuizEnabled: { type: Boolean },
    listeningQuizEnabled: { type: Boolean },
    typingQuizEnabled: { type: Boolean },
    imageModeAvailable: { type: Boolean },
    pictionaryModeAvailable: { type: Boolean },
    flipTileModeAvailable: { type: Boolean },
    bubbleShooterModeAvailable: { type: Boolean },
    bubbleShooterVietnameseMode: { type: Boolean },
    snakeDoubleBaitEnabled: { type: Boolean },
    pictionaryDefinitionMode: { type: Boolean },
    scrambleWordsEnabled: { type: Boolean },
    wordsCrushEnabled: { type: Boolean },
    useFlipTileHints: { type: Boolean }
  },
  emits: ["go-back", "show-history", "change-practice-mode", "show-settings", "toggle-shuffle", "update:image-quiz-enabled", "update:listening-quiz-enabled", "update:typing-quiz-enabled", "update:bubble-shooter-vietnamese-mode", "update:snake-double-bait-enabled", "update:pictionary-definition-mode", "update:scramble-words-enabled", "update:words-crush-enabled", "update:use-flip-tile-hints"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const imageQuizEnabled = computed(() => props.imageQuizEnabled ?? false);
    const listeningQuizEnabled = computed(() => props.listeningQuizEnabled ?? false);
    const typingQuizEnabled = computed(() => props.typingQuizEnabled ?? false);
    const imageModeAvailable = computed(() => props.imageModeAvailable ?? true);
    const pictionaryModeAvailable = computed(() => props.pictionaryModeAvailable ?? true);
    const flipTileModeAvailable = computed(() => props.flipTileModeAvailable ?? true);
    const bubbleShooterModeAvailable = computed(() => props.bubbleShooterModeAvailable ?? true);
    const bubbleShooterVietnameseMode = computed(() => props.bubbleShooterVietnameseMode ?? false);
    const snakeDoubleBaitEnabled = computed(() => props.snakeDoubleBaitEnabled ?? false);
    const pictionaryDefinitionMode = computed(() => props.pictionaryDefinitionMode ?? false);
    const scrambleWordsEnabled = computed(() => props.scrambleWordsEnabled ?? false);
    const wordsCrushEnabled = computed(() => props.wordsCrushEnabled ?? false);
    const useFlipTileHints = computed(() => props.useFlipTileHints ?? false);
    const { t } = useI18n();
    const emit = __emit;
    const mobileDropdownOpen = ref(false);
    const desktopDropdownOpen = ref(false);
    const closeAll = () => {
      mobileDropdownOpen.value = false;
      desktopDropdownOpen.value = false;
    };
    const toggleMobileDropdown = () => {
      if (props.practiceStarted) return;
      mobileDropdownOpen.value = !mobileDropdownOpen.value;
      if (mobileDropdownOpen.value) desktopDropdownOpen.value = false;
    };
    const toggleDesktopDropdown = () => {
      if (props.practiceStarted) return;
      desktopDropdownOpen.value = !desktopDropdownOpen.value;
      if (desktopDropdownOpen.value) mobileDropdownOpen.value = false;
    };
    const selectMode = (mode) => {
      if (props.practiceStarted) {
        closeAll();
        return;
      }
      if (mode === "image" && !imageModeAvailable.value) {
        closeAll();
        return;
      }
      if (mode === "pictionary" && !pictionaryModeAvailable.value) {
        closeAll();
        return;
      }
      if (mode === "bubble-shooter" && !bubbleShooterModeAvailable.value) {
        closeAll();
        return;
      }
      emit("change-practice-mode", mode);
      closeAll();
    };
    const toggleImageQuizFromDropdown = () => {
      if (props.practiceStarted) return;
      if (!imageModeAvailable.value) return;
      emit("update:image-quiz-enabled", !imageQuizEnabled.value);
    };
    const toggleListeningQuizFromDropdown = () => {
      if (props.practiceStarted) return;
      emit("update:listening-quiz-enabled", !listeningQuizEnabled.value);
    };
    const toggleTypingQuizFromDropdown = () => {
      if (props.practiceStarted) return;
      emit("update:typing-quiz-enabled", !typingQuizEnabled.value);
    };
    const toggleSnakeDoubleBaitFromDropdown = () => {
      if (props.practiceStarted) return;
      emit("update:snake-double-bait-enabled", !snakeDoubleBaitEnabled.value);
    };
    const toggleBubbleShooterVietnameseMode = () => {
      if (props.practiceStarted) return;
      if (!bubbleShooterModeAvailable.value) return;
      emit("update:bubble-shooter-vietnamese-mode", !bubbleShooterVietnameseMode.value);
    };
    const togglePictionaryDefinitionModeFromDropdown = () => {
      if (props.practiceStarted) return;
      if (!pictionaryModeAvailable.value) return;
      emit("update:pictionary-definition-mode", !pictionaryDefinitionMode.value);
    };
    const toggleFlipTileHintsFromDropdown = () => {
      if (props.practiceStarted) return;
      if (!flipTileModeAvailable.value) return;
      emit("update:use-flip-tile-hints", !useFlipTileHints.value);
    };
    const toggleScrambleWordsFromDropdown = () => {
      if (props.practiceStarted) return;
      emit("update:scramble-words-enabled", !scrambleWordsEnabled.value);
    };
    const toggleWordsCrushFromDropdown = () => {
      if (props.practiceStarted) return;
      emit("update:words-crush-enabled", !wordsCrushEnabled.value);
    };
    const onShowSettings = () => {
      if (props.practiceStarted) return;
      closeAll();
      emit("show-settings");
    };
    const onClickOutside = (e) => {
      const target = e.target;
      if (!target.closest(".relative")) {
        closeAll();
      }
    };
    onMounted(() => {
      window.addEventListener("click", onClickOutside, { capture: true });
    });
    onBeforeUnmount(() => {
      window.removeEventListener("click", onClickOutside, { capture: true });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$G, [
        createBaseVNode("div", _hoisted_2$D, [
          createBaseVNode("div", _hoisted_3$B, [
            createBaseVNode("div", _hoisted_4$z, [
              createBaseVNode("div", _hoisted_5$x, [
                createBaseVNode("button", {
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("go-back")),
                  class: "mr-3 text-gray-500 dark:text-white/70 hover:text-gray-700 dark:hover:text-white"
                }, _cache[44] || (_cache[44] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)
                ])),
                createBaseVNode("div", null, [
                  createBaseVNode("h1", _hoisted_6$v, toDisplayString$1(unref(t)("flashcard.modes.flashcard", "Flashcard")), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_7$u, [
                createBaseVNode("p", _hoisted_8$u, toDisplayString$1(unref(t)("flashcard.header.progress", "Progress")), 1),
                createBaseVNode("p", _hoisted_9$t, toDisplayString$1(_ctx.currentIndex + 1) + "/" + toDisplayString$1(_ctx.totalCards), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_10$s, [
              createBaseVNode("div", _hoisted_11$s, [
                createBaseVNode("button", {
                  onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("show-history")),
                  class: "text-gray-500 dark:text-white/70 hover:text-gray-700 dark:hover:text-white",
                  title: unref(t)("flashcard.header.history", "History")
                }, _cache[45] || (_cache[45] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)
                ]), 8, _hoisted_12$r),
                createBaseVNode("button", {
                  onClick: onShowSettings,
                  disabled: _ctx.practiceStarted,
                  "aria-disabled": _ctx.practiceStarted ? "true" : "false",
                  class: normalizeClass(["text-gray-500 dark:text-white/70 hover:text-gray-700 dark:hover:text-white", _ctx.practiceStarted ? "opacity-50 cursor-not-allowed" : ""]),
                  title: _ctx.practiceStarted ? unref(t)("flashcard.settings.disabledDuringPractice", "Settings are disabled during practice") : unref(t)("flashcard.header.settings", "Settings")
                }, _cache[46] || (_cache[46] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)
                ]), 10, _hoisted_13$r)
              ]),
              createBaseVNode("div", _hoisted_14$r, [
                createBaseVNode("div", _hoisted_15$n, [
                  createBaseVNode("button", {
                    type: "button",
                    onClick: toggleMobileDropdown,
                    class: normalizeClass(["relative pl-2 pr-8 py-1 text-xs border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0f0f0f] cursor-pointer text-gray-900 dark:text-white flex items-center min-w-[120px]", _ctx.practiceStarted ? "opacity-50 cursor-not-allowed" : ""]),
                    disabled: _ctx.practiceStarted,
                    "aria-disabled": _ctx.practiceStarted ? "true" : "false",
                    title: _ctx.practiceStarted ? unref(t)("flashcard.modes.change_disabled_during_practice", "Mode change is disabled during practice") : unref(t)("flashcard.header.selectMode", "Select mode"),
                    "aria-label": unref(t)("flashcard.header.selectMode", "Select mode")
                  }, [
                    createBaseVNode("span", _hoisted_17$m, toDisplayString$1(_ctx.practiceMode === "flashcard" ? unref(t)("flashcard.modes.flashcard", "Flashcard") : _ctx.practiceMode === "quiz" ? unref(t)("flashcard.modes.quiz", "Quiz") : _ctx.practiceMode === "typing" ? unref(t)("flashcard.modes.typing", "Typing") : _ctx.practiceMode === "listening" ? unref(t)("flashcard.modes.listening", "Listening") : _ctx.practiceMode === "image" ? unref(t)("flashcard.modes.image", "Image") : _ctx.practiceMode === "pictionary" ? unref(t)("flashcard.modes.pictionary", "Pictionary") : _ctx.practiceMode === "flip-tile" ? unref(t)("flashcard.modes.flipTile", "Flip Tile") : _ctx.practiceMode === "bubble-shooter" ? unref(t)("flashcard.modes.bubbleShooter", "Bubble Shooter") : _ctx.practiceMode === "snake-game" ? unref(t)("flashcard.modes.snakeGame", "Snake Hunt") : unref(t)("flashcard.modes.pronunciation", "Pronunciation")), 1),
                    _cache[47] || (_cache[47] = createBaseVNode("svg", {
                      class: "w-3.5 h-3.5 opacity-80 absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M5.23 7.21a.75.75 0 011.06.02L10 11.17l3.71-3.94a.75.75 0 111.08 1.04l-4.24 4.5a.75.75 0 01-1.08 0L5.21 8.27a.75.75 0 01.02-1.06z",
                        "clip-rule": "evenodd"
                      })
                    ], -1))
                  ], 10, _hoisted_16$m),
                  createVNode(Transition, {
                    name: "fade",
                    appear: ""
                  }, {
                    default: withCtx(() => [
                      mobileDropdownOpen.value && !_ctx.practiceStarted ? (openBlock(), createElementBlock("div", _hoisted_18$l, [
                        createBaseVNode("ul", _hoisted_19$l, [
                          createBaseVNode("li", _hoisted_20$l, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[2] || (_cache[2] = ($event) => selectMode("flashcard"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.flashcard", "Flashcard")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", scrambleWordsEnabled.value ? "bg-green-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[3] || (_cache[3] = withModifiers(($event) => toggleScrambleWordsFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.scrambleWords.toggle", "Scramble Words"),
                              "aria-label": unref(t)("flashcard.scrambleWords.toggle", "Scramble Words")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", scrambleWordsEnabled.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_21$l)
                          ]),
                          createBaseVNode("li", null, [
                            createBaseVNode("button", {
                              class: "w-full text-left px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10",
                              onClick: _cache[4] || (_cache[4] = ($event) => selectMode("quiz"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.quiz", "Quiz")), 1)
                          ]),
                          createBaseVNode("li", _hoisted_22$j, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[5] || (_cache[5] = ($event) => selectMode("typing"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.typing", "Typing")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", typingQuizEnabled.value ? "bg-purple-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[6] || (_cache[6] = withModifiers(($event) => toggleTypingQuizFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.typing.quizToggle", "Multiple Choice"),
                              "aria-label": unref(t)("flashcard.typing.quizToggle", "Multiple Choice")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", typingQuizEnabled.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_23$j)
                          ]),
                          createBaseVNode("li", _hoisted_24$i, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[7] || (_cache[7] = ($event) => selectMode("listening"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.listening", "Listening")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", listeningQuizEnabled.value ? "bg-cyan-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[8] || (_cache[8] = withModifiers(($event) => toggleListeningQuizFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.listening.quizToggle", "Multiple Choice"),
                              "aria-label": unref(t)("flashcard.listening.quizToggle", "Multiple Choice")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", listeningQuizEnabled.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_25$i)
                          ]),
                          createBaseVNode("li", _hoisted_26$g, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !imageModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[9] || (_cache[9] = ($event) => selectMode("image")),
                              disabled: !imageModeAvailable.value,
                              "aria-disabled": !imageModeAvailable.value ? "true" : "false",
                              title: !imageModeAvailable.value ? unref(t)("flashcard.image.unavailable", "Image mode is unavailable for the selected date") : unref(t)("flashcard.modes.image", "Image")
                            }, toDisplayString$1(unref(t)("flashcard.modes.image", "Image")), 11, _hoisted_27$f),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                imageModeAvailable.value ? imageQuizEnabled.value ? "bg-purple-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[10] || (_cache[10] = withModifiers(($event) => imageModeAvailable.value && toggleImageQuizFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.image.quizToggle", "Multiple Choice"),
                              "aria-label": unref(t)("flashcard.image.quizToggle", "Multiple Choice")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", imageQuizEnabled.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_28$f)
                          ]),
                          createBaseVNode("li", _hoisted_29$d, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !pictionaryModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[11] || (_cache[11] = ($event) => selectMode("pictionary")),
                              disabled: !pictionaryModeAvailable.value,
                              "aria-disabled": !pictionaryModeAvailable.value ? "true" : "false",
                              title: !pictionaryModeAvailable.value ? unref(t)("flashcard.pictionary.unavailable", "Pictionary mode is unavailable for the selected date") : unref(t)("flashcard.modes.pictionary", "Pictionary")
                            }, toDisplayString$1(unref(t)("flashcard.modes.pictionary", "Pictionary")), 11, _hoisted_30$c),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                pictionaryModeAvailable.value ? pictionaryDefinitionMode.value ? "bg-teal-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[12] || (_cache[12] = withModifiers(($event) => pictionaryModeAvailable.value && togglePictionaryDefinitionModeFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.pictionary.definitionToggle", "Definition Mode"),
                              "aria-label": unref(t)("flashcard.pictionary.definitionToggle", "Definition Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", pictionaryDefinitionMode.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_31$c)
                          ]),
                          createBaseVNode("li", _hoisted_32$a, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !flipTileModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[13] || (_cache[13] = ($event) => selectMode("flip-tile")),
                              disabled: !flipTileModeAvailable.value,
                              "aria-disabled": !flipTileModeAvailable.value ? "true" : "false",
                              title: !flipTileModeAvailable.value ? unref(t)("flashcard.flipTile.unavailable", "Flip Tile mode is unavailable for the selected date") : unref(t)("flashcard.modes.flipTile", "Flip Tile")
                            }, toDisplayString$1(unref(t)("flashcard.modes.flipTile", "Flip Tile")), 11, _hoisted_33$a),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                flipTileModeAvailable.value ? useFlipTileHints.value ? "bg-teal-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[14] || (_cache[14] = withModifiers(($event) => flipTileModeAvailable.value && toggleFlipTileHintsFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.flipTile.hintsToggle", "Use Definition Hints"),
                              "aria-label": unref(t)("flashcard.flipTile.hintsToggle", "Use Definition Hints")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", useFlipTileHints.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_34$9)
                          ]),
                          createBaseVNode("li", _hoisted_35$9, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !bubbleShooterModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[15] || (_cache[15] = ($event) => selectMode("bubble-shooter")),
                              disabled: !bubbleShooterModeAvailable.value,
                              "aria-disabled": !bubbleShooterModeAvailable.value ? "true" : "false",
                              title: !bubbleShooterModeAvailable.value ? unref(t)("flashcard.bubbleShooter.unavailable", "Bubble Shooter mode is disabled for dates with more than 8 vocabulary words") : unref(t)("flashcard.modes.bubbleShooter", "Bubble Shooter")
                            }, toDisplayString$1(unref(t)("flashcard.modes.bubbleShooter", "Bubble Shooter")), 11, _hoisted_36$8),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                bubbleShooterModeAvailable.value ? bubbleShooterVietnameseMode.value ? "bg-orange-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[16] || (_cache[16] = withModifiers(($event) => bubbleShooterModeAvailable.value && toggleBubbleShooterVietnameseMode(), ["stop"])),
                              title: unref(t)("flashcard.bubbleShooter.vietnameseModeToggle", "Vietnamese First Letter Mode"),
                              "aria-label": unref(t)("flashcard.bubbleShooter.vietnameseModeToggle", "Vietnamese First Letter Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", bubbleShooterVietnameseMode.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_37$7)
                          ]),
                          createBaseVNode("li", _hoisted_38$7, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[17] || (_cache[17] = ($event) => selectMode("snake-game")),
                              title: unref(t)("flashcard.modes.snakeGame", "Snake Hunt")
                            }, toDisplayString$1(unref(t)("flashcard.modes.snakeGame", "Snake Hunt")), 9, _hoisted_39$5),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                snakeDoubleBaitEnabled.value ? "bg-emerald-600" : "bg-gray-200 dark:bg-[#0a0a0a]",
                                _ctx.practiceStarted ? "opacity-50 cursor-not-allowed pointer-events-none" : ""
                              ]]),
                              onClick: _cache[18] || (_cache[18] = withModifiers(($event) => toggleSnakeDoubleBaitFromDropdown(), ["stop"])),
                              title: _ctx.practiceStarted ? unref(t)("flashcard.settings.disabledDuringPractice", "Settings are disabled during practice") : unref(t)("flashcard.snake.doubleBaitToggle", "Double Bait Mode"),
                              "aria-label": unref(t)("flashcard.snake.doubleBaitToggle", "Double Bait Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", snakeDoubleBaitEnabled.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_40$5)
                          ]),
                          createBaseVNode("li", _hoisted_41$4, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[19] || (_cache[19] = ($event) => selectMode("pronunciation"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.pronunciation", "Pronunciation")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", wordsCrushEnabled.value ? "bg-amber-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[20] || (_cache[20] = withModifiers(($event) => toggleWordsCrushFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.pronunciation.wordsCrushToggle", "Hidden Words Mode"),
                              "aria-label": unref(t)("flashcard.pronunciation.wordsCrushToggle", "Hidden Words Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", wordsCrushEnabled.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_42$4)
                          ])
                        ])
                      ])) : createCommentVNode("", true)
                    ]),
                    _: 1
                  })
                ]),
                createBaseVNode("button", {
                  onClick: _cache[21] || (_cache[21] = ($event) => _ctx.$emit("toggle-shuffle")),
                  disabled: _ctx.practiceStarted,
                  class: normalizeClass([
                    "relative inline-flex h-5 w-9 items-center rounded-full transition-colors",
                    _ctx.shuffleEnabled ? "bg-blue-600" : "bg-gray-200 dark:bg-gray-600",
                    _ctx.practiceStarted ? "opacity-50 cursor-not-allowed" : ""
                  ]),
                  title: _ctx.practiceStarted ? unref(t)("flashcard.settings.shuffle_disabled_during_practice", "Shuffle is disabled during practice") : unref(t)("flashcard.settings.shuffle", "Shuffle")
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass([
                      "inline-block h-3 w-3 transform rounded-full bg-white transition-transform",
                      _ctx.shuffleEnabled ? "translate-x-5" : "translate-x-1"
                    ])
                  }, null, 2)
                ], 10, _hoisted_43$4)
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_44$4, [
            createBaseVNode("div", _hoisted_45$3, [
              createBaseVNode("button", {
                onClick: _cache[22] || (_cache[22] = ($event) => _ctx.$emit("go-back")),
                class: "mr-4 text-gray-500 dark:text-white/70 hover:text-gray-700 dark:hover:text-white"
              }, _cache[48] || (_cache[48] = [
                createBaseVNode("svg", {
                  class: "w-6 h-6 md:w-7 md:h-7",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                    "clip-rule": "evenodd"
                  })
                ], -1)
              ])),
              createBaseVNode("div", null, [
                createBaseVNode("h1", _hoisted_46$3, toDisplayString$1(unref(t)("flashcard.modes.flashcard", "Flashcard")), 1),
                createBaseVNode("p", _hoisted_47$3, toDisplayString$1(unref(t)("flashcard.header.description", "Practice vocabulary with flashcards")), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_48$3, [
              createBaseVNode("button", {
                onClick: _cache[23] || (_cache[23] = ($event) => _ctx.$emit("show-history")),
                class: "text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300",
                title: unref(t)("flashcard.header.history", "History")
              }, _cache[49] || (_cache[49] = [
                createBaseVNode("svg", {
                  class: "w-6 h-6 md:w-7 md:h-7",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z",
                    "clip-rule": "evenodd"
                  })
                ], -1)
              ]), 8, _hoisted_49$3),
              createBaseVNode("div", _hoisted_50$3, [
                createBaseVNode("span", _hoisted_51$2, toDisplayString$1(unref(t)("flashcard.settings.shuffle", "Shuffle")), 1),
                createBaseVNode("button", {
                  onClick: _cache[24] || (_cache[24] = ($event) => _ctx.$emit("toggle-shuffle")),
                  disabled: _ctx.practiceStarted,
                  class: normalizeClass([
                    "relative inline-flex items-center rounded-full transition-colors",
                    "h-6 w-11 md:h-7 md:w-12",
                    _ctx.shuffleEnabled ? "bg-blue-600" : "bg-gray-200 dark:bg-gray-600",
                    _ctx.practiceStarted ? "opacity-50 cursor-not-allowed" : ""
                  ]),
                  title: _ctx.practiceStarted ? unref(t)("flashcard.settings.shuffle_disabled_during_practice", "Shuffle is disabled during practice") : unref(t)("flashcard.settings.shuffle", "Shuffle")
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass([
                      "inline-block transform rounded-full bg-white transition-transform",
                      "h-4 w-4 md:h-5 md:w-5",
                      _ctx.shuffleEnabled ? "translate-x-6 md:translate-x-6" : "translate-x-1"
                    ])
                  }, null, 2)
                ], 10, _hoisted_52$2)
              ]),
              createBaseVNode("div", _hoisted_53$2, [
                createBaseVNode("p", _hoisted_54$2, toDisplayString$1(unref(t)("flashcard.header.progress", "Progress")), 1),
                createBaseVNode("p", _hoisted_55$2, toDisplayString$1(_ctx.currentIndex + 1) + " / " + toDisplayString$1(_ctx.totalCards), 1)
              ]),
              createBaseVNode("div", _hoisted_56$2, [
                createBaseVNode("div", _hoisted_57$2, [
                  createBaseVNode("button", {
                    type: "button",
                    onClick: toggleDesktopDropdown,
                    class: normalizeClass(["relative pl-3 pr-10 py-1 md:pl-4 md:pr-12 md:py-2 text-sm md:text-base border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0f0f0f] cursor-pointer text-gray-900 dark:text-white flex items-center min-w-[140px]", _ctx.practiceStarted ? "opacity-50 cursor-not-allowed" : ""]),
                    disabled: _ctx.practiceStarted,
                    "aria-disabled": _ctx.practiceStarted ? "true" : "false",
                    title: _ctx.practiceStarted ? unref(t)("flashcard.modes.change_disabled_during_practice", "Mode change is disabled during practice") : unref(t)("flashcard.header.selectMode", "Select mode"),
                    "aria-label": unref(t)("flashcard.header.selectMode", "Select mode")
                  }, [
                    createBaseVNode("span", _hoisted_59$2, toDisplayString$1(_ctx.practiceMode === "flashcard" ? unref(t)("flashcard.modes.flashcard", "Flashcard") : _ctx.practiceMode === "quiz" ? unref(t)("flashcard.modes.quiz", "Quiz") : _ctx.practiceMode === "typing" ? unref(t)("flashcard.modes.typing", "Typing") : _ctx.practiceMode === "listening" ? unref(t)("flashcard.modes.listening", "Listening") : _ctx.practiceMode === "image" ? unref(t)("flashcard.modes.image", "Image") : _ctx.practiceMode === "pictionary" ? unref(t)("flashcard.modes.pictionary", "Pictionary") : _ctx.practiceMode === "flip-tile" ? unref(t)("flashcard.modes.flipTile", "Flip Tile") : _ctx.practiceMode === "bubble-shooter" ? unref(t)("flashcard.modes.bubbleShooter", "Bubble Shooter") : _ctx.practiceMode === "snake-game" ? unref(t)("flashcard.modes.snakeGame", "Snake Hunt") : unref(t)("flashcard.modes.pronunciation", "Pronunciation")), 1),
                    _cache[50] || (_cache[50] = createBaseVNode("svg", {
                      class: "w-4 h-4 opacity-80 absolute right-2 md:right-3 top-1/2 -translate-y-1/2 pointer-events-none",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M5.23 7.21a.75.75 0 011.06.02L10 11.17l3.71-3.94a.75.75 0 111.08 1.04l-4.24 4.5a.75.75 0 01-1.08 0L5.21 8.27a.75.75 0 01.02-1.06z",
                        "clip-rule": "evenodd"
                      })
                    ], -1))
                  ], 10, _hoisted_58$2),
                  createVNode(Transition, {
                    name: "fade",
                    appear: ""
                  }, {
                    default: withCtx(() => [
                      desktopDropdownOpen.value && !_ctx.practiceStarted ? (openBlock(), createElementBlock("div", _hoisted_60$2, [
                        createBaseVNode("ul", _hoisted_61$2, [
                          createBaseVNode("li", _hoisted_62$2, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[25] || (_cache[25] = ($event) => selectMode("flashcard"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.flashcard", "Flashcard")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", scrambleWordsEnabled.value ? "bg-green-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[26] || (_cache[26] = withModifiers(($event) => toggleScrambleWordsFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.scrambleWords.toggle", "Scramble Words"),
                              "aria-label": unref(t)("flashcard.scrambleWords.toggle", "Scramble Words")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", scrambleWordsEnabled.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_63$2)
                          ]),
                          createBaseVNode("li", null, [
                            createBaseVNode("button", {
                              class: "w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10",
                              onClick: _cache[27] || (_cache[27] = ($event) => selectMode("quiz"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.quiz", "Quiz")), 1)
                          ]),
                          createBaseVNode("li", _hoisted_64$2, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[28] || (_cache[28] = ($event) => selectMode("typing"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.typing", "Typing")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", typingQuizEnabled.value ? "bg-purple-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[29] || (_cache[29] = withModifiers(($event) => toggleTypingQuizFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.typing.quizToggle", "Multiple Choice"),
                              "aria-label": unref(t)("flashcard.typing.quizToggle", "Multiple Choice")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", typingQuizEnabled.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_65$2)
                          ]),
                          createBaseVNode("li", _hoisted_66$2, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[30] || (_cache[30] = ($event) => selectMode("listening"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.listening", "Listening")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", listeningQuizEnabled.value ? "bg-cyan-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[31] || (_cache[31] = withModifiers(($event) => toggleListeningQuizFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.listening.quizToggle", "Multiple Choice"),
                              "aria-label": unref(t)("flashcard.listening.quizToggle", "Multiple Choice")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", listeningQuizEnabled.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_67$2)
                          ]),
                          createBaseVNode("li", _hoisted_68$2, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !imageModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[32] || (_cache[32] = ($event) => selectMode("image")),
                              disabled: !imageModeAvailable.value,
                              "aria-disabled": !imageModeAvailable.value ? "true" : "false",
                              title: !imageModeAvailable.value ? unref(t)("flashcard.image.unavailable", "Image mode is unavailable for the selected date") : unref(t)("flashcard.modes.image", "Image")
                            }, toDisplayString$1(unref(t)("flashcard.modes.image", "Image")), 11, _hoisted_69$2),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                imageModeAvailable.value ? imageQuizEnabled.value ? "bg-purple-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[33] || (_cache[33] = withModifiers(($event) => imageModeAvailable.value && toggleImageQuizFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.image.quizToggle", "Multiple Choice"),
                              "aria-label": unref(t)("flashcard.image.quizToggle", "Multiple Choice")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", imageQuizEnabled.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_70$2)
                          ]),
                          createBaseVNode("li", _hoisted_71$2, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !pictionaryModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[34] || (_cache[34] = ($event) => selectMode("pictionary")),
                              disabled: !pictionaryModeAvailable.value,
                              "aria-disabled": !pictionaryModeAvailable.value ? "true" : "false",
                              title: !pictionaryModeAvailable.value ? unref(t)("flashcard.pictionary.unavailable", "Pictionary mode is unavailable for the selected date") : unref(t)("flashcard.modes.pictionary", "Pictionary")
                            }, toDisplayString$1(unref(t)("flashcard.modes.pictionary", "Pictionary")), 11, _hoisted_72$2),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                pictionaryModeAvailable.value ? pictionaryDefinitionMode.value ? "bg-teal-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[35] || (_cache[35] = withModifiers(($event) => pictionaryModeAvailable.value && togglePictionaryDefinitionModeFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.pictionary.definitionToggle", "Definition Mode"),
                              "aria-label": unref(t)("flashcard.pictionary.definitionToggle", "Definition Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", pictionaryDefinitionMode.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_73$2)
                          ]),
                          createBaseVNode("li", _hoisted_74$2, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !flipTileModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[36] || (_cache[36] = ($event) => selectMode("flip-tile")),
                              disabled: !flipTileModeAvailable.value,
                              "aria-disabled": !flipTileModeAvailable.value ? "true" : "false",
                              title: !flipTileModeAvailable.value ? unref(t)("flashcard.flipTile.unavailable", "Flip Tile mode is unavailable for the selected date") : unref(t)("flashcard.modes.flipTile", "Flip Tile")
                            }, toDisplayString$1(unref(t)("flashcard.modes.flipTile", "Flip Tile")), 11, _hoisted_75$2),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                flipTileModeAvailable.value ? useFlipTileHints.value ? "bg-teal-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[37] || (_cache[37] = withModifiers(($event) => flipTileModeAvailable.value && toggleFlipTileHintsFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.flipTile.hintsToggle", "Use Definition Hints"),
                              "aria-label": unref(t)("flashcard.flipTile.hintsToggle", "Use Definition Hints")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", useFlipTileHints.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_76$2)
                          ]),
                          createBaseVNode("li", _hoisted_77$2, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !bubbleShooterModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[38] || (_cache[38] = ($event) => selectMode("bubble-shooter")),
                              disabled: !bubbleShooterModeAvailable.value,
                              "aria-disabled": !bubbleShooterModeAvailable.value ? "true" : "false",
                              title: !bubbleShooterModeAvailable.value ? unref(t)("flashcard.bubbleShooter.unavailable", "Bubble Shooter mode is disabled for dates with more than 8 vocabulary words") : unref(t)("flashcard.modes.bubbleShooter", "Bubble Shooter")
                            }, toDisplayString$1(unref(t)("flashcard.modes.bubbleShooter", "Bubble Shooter")), 11, _hoisted_78$1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                bubbleShooterModeAvailable.value ? bubbleShooterVietnameseMode.value ? "bg-orange-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[39] || (_cache[39] = withModifiers(($event) => bubbleShooterModeAvailable.value && toggleBubbleShooterVietnameseMode(), ["stop"])),
                              title: unref(t)("flashcard.bubbleShooter.vietnameseModeToggle", "Vietnamese First Letter Mode"),
                              "aria-label": unref(t)("flashcard.bubbleShooter.vietnameseModeToggle", "Vietnamese First Letter Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", bubbleShooterVietnameseMode.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_79$1)
                          ]),
                          createBaseVNode("li", _hoisted_80$1, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[40] || (_cache[40] = ($event) => selectMode("snake-game")),
                              title: unref(t)("flashcard.modes.snakeGame", "Snake Hunt")
                            }, toDisplayString$1(unref(t)("flashcard.modes.snakeGame", "Snake Hunt")), 9, _hoisted_81$1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                snakeDoubleBaitEnabled.value ? "bg-emerald-600" : "bg-gray-200 dark:bg-[#0a0a0a]",
                                _ctx.practiceStarted ? "opacity-50 cursor-not-allowed pointer-events-none" : ""
                              ]]),
                              onClick: _cache[41] || (_cache[41] = withModifiers(($event) => toggleSnakeDoubleBaitFromDropdown(), ["stop"])),
                              title: _ctx.practiceStarted ? unref(t)("flashcard.settings.disabledDuringPractice", "Settings are disabled during practice") : unref(t)("flashcard.snake.doubleBaitToggle", "Double Bait Mode"),
                              "aria-label": unref(t)("flashcard.snake.doubleBaitToggle", "Double Bait Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", snakeDoubleBaitEnabled.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_82$1)
                          ]),
                          createBaseVNode("li", _hoisted_83$1, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[42] || (_cache[42] = ($event) => selectMode("pronunciation"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.pronunciation", "Pronunciation")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", wordsCrushEnabled.value ? "bg-amber-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[43] || (_cache[43] = withModifiers(($event) => toggleWordsCrushFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.pronunciation.wordsCrushToggle", "Hidden Words Mode"),
                              "aria-label": unref(t)("flashcard.pronunciation.wordsCrushToggle", "Hidden Words Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", wordsCrushEnabled.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_84$1)
                          ])
                        ])
                      ])) : createCommentVNode("", true)
                    ]),
                    _: 1
                  })
                ]),
                createBaseVNode("button", {
                  onClick: onShowSettings,
                  disabled: _ctx.practiceStarted,
                  "aria-disabled": _ctx.practiceStarted ? "true" : "false",
                  class: normalizeClass(["text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300", _ctx.practiceStarted ? "opacity-50 cursor-not-allowed" : ""]),
                  title: _ctx.practiceStarted ? unref(t)("flashcard.settings.disabledDuringPractice", "Settings are disabled during practice") : unref(t)("flashcard.header.settings", "Settings")
                }, _cache[51] || (_cache[51] = [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 md:w-7 md:h-7",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)
                ]), 10, _hoisted_85$1)
              ])
            ])
          ])
        ])
      ]);
    };
  }
});

const FlashcardHeader = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$G
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$F = { class: "max-w-4xl mx-auto px-3 sm:px-4 md:px-6 py-2 sm:py-3 md:py-4" };
const _hoisted_2$C = { class: "w-full bg-gray-200 dark:bg-[#0f0f0f] rounded-full h-1.5 sm:h-2 md:h-3" };
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  __name: "FlashcardProgress",
  props: {
    progressPercentage: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$F, [
        createBaseVNode("div", _hoisted_2$C, [
          createBaseVNode("div", {
            class: "bg-blue-500 rounded-full transition-all duration-300 h-1.5 sm:h-2 md:h-3",
            style: normalizeStyle({ width: _ctx.progressPercentage + "%" })
          }, null, 4)
        ])
      ]);
    };
  }
});

const FlashcardProgress = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$F
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$E = { class: "bg-white dark:bg-[#0f0f0f] border-b border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_2$B = { class: "max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-4" };
const _hoisted_3$A = { class: "flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4" };
const _hoisted_4$y = { class: "flex flex-col sm:flex-row items-start sm:items-center gap-4" };
const _hoisted_5$w = { class: "flex items-center gap-2" };
const _hoisted_6$u = { class: "relative" };
const _hoisted_7$t = ["disabled", "aria-disabled", "title"];
const _hoisted_8$t = { class: "truncate" };
const _hoisted_9$s = {
  key: 0,
  class: "absolute bottom-full mb-1 w-full bg-white dark:bg-dark-bg border border-gray-300 dark:border-dark-bg-soft dark:border-2 rounded-md shadow-xl ring-1 ring-black ring-opacity-5 max-h-60 overflow-y-auto origin-bottom",
  style: { "z-index": "99999 !important" }
};
const _hoisted_10$r = ["onClick"];
const _hoisted_11$r = { class: "truncate" };
const _hoisted_12$q = { class: "ml-2 text-xs text-gray-500 dark:text-white/60 flex-shrink-0" };
const _hoisted_13$q = {
  key: 0,
  class: "text-sm text-gray-600 dark:text-white/70"
};
const _hoisted_14$q = { class: "flex items-center gap-1" };
const _sfc_main$E = /* @__PURE__ */ defineComponent({
  __name: "FlashcardDateFilter",
  props: {
    vocabularies: {},
    enabled: { type: Boolean },
    selectedDate: {},
    practiceStarted: { type: Boolean }
  },
  emits: ["update:enabled", "update:selectedDate"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t, locale } = useI18n();
    const isDropdownOpen = ref(false);
    computed(() => true);
    const localSelectedDate = computed({
      get: () => props.selectedDate,
      set: (value) => emit("update:selectedDate", value)
    });
    const availableDates = computed(() => {
      if (!props.vocabularies.length) return [];
      const grouped = groupVocabulariesByDate(props.vocabularies, locale.value);
      return grouped.map((group) => ({
        date: group.date,
        displayDate: group.displayDate,
        count: group.vocabularies.length
      }));
    });
    const toggleDropdown = () => {
      if (props.practiceStarted) return;
      isDropdownOpen.value = !isDropdownOpen.value;
    };
    const selectDate = (date) => {
      if (props.practiceStarted) return;
      localSelectedDate.value = date;
      isDropdownOpen.value = false;
    };
    const getSelectedDateDisplay = () => {
      if (!localSelectedDate.value) {
        return t("flashcard.dateFilter.allDates", "All dates");
      }
      const selectedGroup = availableDates.value.find((g) => g.date === localSelectedDate.value);
      if (!selectedGroup) {
        return t("flashcard.dateFilter.allDates", "All dates");
      }
      return `${selectedGroup.displayDate} (${selectedGroup.count})`;
    };
    const handleClickOutside = (event) => {
      const target = event.target;
      if (!target.closest(".relative")) {
        isDropdownOpen.value = false;
      }
    };
    const getFilterInfo = () => {
      if (!localSelectedDate.value) return "";
      const selectedGroup = availableDates.value.find((g) => g.date === localSelectedDate.value);
      if (!selectedGroup) return "";
      return t(
        "flashcard.dateFilter.info",
        { count: selectedGroup.count, date: selectedGroup.displayDate },
        `Showing ${selectedGroup.count} words from ${selectedGroup.displayDate}`
      );
    };
    watch(availableDates, (newDates) => {
      if (localSelectedDate.value && !newDates.some((d) => d.date === localSelectedDate.value)) {
        localSelectedDate.value = "";
      }
    });
    onMounted(() => {
      document.addEventListener("click", handleClickOutside);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleClickOutside);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$E, [
        createBaseVNode("div", _hoisted_2$B, [
          createBaseVNode("div", _hoisted_3$A, [
            createBaseVNode("div", _hoisted_4$y, [
              createBaseVNode("div", _hoisted_5$w, [
                _cache[2] || (_cache[2] = createBaseVNode("svg", {
                  class: "w-4 h-4 text-gray-500 dark:text-white/60",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z",
                    "clip-rule": "evenodd"
                  })
                ], -1)),
                createBaseVNode("div", _hoisted_6$u, [
                  createBaseVNode("button", {
                    type: "button",
                    onClick: toggleDropdown,
                    disabled: _ctx.practiceStarted,
                    "aria-disabled": _ctx.practiceStarted ? "true" : "false",
                    title: _ctx.practiceStarted ? unref(t)("flashcard.dateFilter.disabledDuringPractice", "Date filter is disabled during practice") : "",
                    class: "px-3 py-1.5 text-sm border border-gray-300 dark:border-dark-bg-soft dark:border-2 rounded-md bg-white dark:bg-dark-bg text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-400 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-between min-w-[200px] sm:min-w-[240px]"
                  }, [
                    createBaseVNode("span", _hoisted_8$t, toDisplayString$1(getSelectedDateDisplay()), 1),
                    (openBlock(), createElementBlock("svg", {
                      class: normalizeClass(["w-4 h-4 ml-2 transition-transform duration-200", { "rotate-180": isDropdownOpen.value }]),
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, _cache[1] || (_cache[1] = [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z",
                        "clip-rule": "evenodd"
                      }, null, -1)
                    ]), 2))
                  ], 8, _hoisted_7$t),
                  createVNode(Transition, {
                    "enter-active-class": "transform transition duration-100 ease-out",
                    "enter-from-class": "scale-95 opacity-0 translate-y-2",
                    "enter-to-class": "scale-100 opacity-100 translate-y-0",
                    "leave-active-class": "transform transition duration-75 ease-in",
                    "leave-from-class": "scale-100 opacity-100 translate-y-0",
                    "leave-to-class": "scale-95 opacity-0 translate-y-2"
                  }, {
                    default: withCtx(() => [
                      isDropdownOpen.value && !_ctx.practiceStarted ? (openBlock(), createElementBlock("div", _hoisted_9$s, [
                        createBaseVNode("button", {
                          type: "button",
                          onClick: _cache[0] || (_cache[0] = ($event) => selectDate("")),
                          class: normalizeClass(["w-full px-3 py-2 text-left text-sm hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors duration-150", {
                            "bg-blue-50 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400": localSelectedDate.value === ""
                          }])
                        }, toDisplayString$1(unref(t)("flashcard.dateFilter.allDates", "All dates")), 3),
                        (openBlock(true), createElementBlock(Fragment, null, renderList(availableDates.value, (group) => {
                          return openBlock(), createElementBlock("button", {
                            key: group.date,
                            type: "button",
                            onClick: ($event) => selectDate(group.date),
                            class: normalizeClass(["w-full px-3 py-2 text-left text-sm hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors duration-150 flex items-center justify-between", {
                              "bg-blue-50 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400": localSelectedDate.value === group.date
                            }])
                          }, [
                            createBaseVNode("span", _hoisted_11$r, toDisplayString$1(group.displayDate), 1),
                            createBaseVNode("span", _hoisted_12$q, " (" + toDisplayString$1(group.count) + ") ", 1)
                          ], 10, _hoisted_10$r);
                        }), 128))
                      ])) : createCommentVNode("", true)
                    ]),
                    _: 1
                  })
                ])
              ])
            ]),
            localSelectedDate.value ? (openBlock(), createElementBlock("div", _hoisted_13$q, [
              createBaseVNode("span", _hoisted_14$q, [
                _cache[3] || (_cache[3] = createBaseVNode("svg", {
                  class: "w-4 h-4",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z",
                    "clip-rule": "evenodd"
                  })
                ], -1)),
                createTextVNode(" " + toDisplayString$1(getFilterInfo()), 1)
              ])
            ])) : createCommentVNode("", true)
          ])
        ])
      ]);
    };
  }
});

const FlashcardDateFilter = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$E
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$D = { class: "perspective-1000" };
const _hoisted_2$A = { class: "flashcard-face flashcard-front absolute inset-0 bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 flex items-center justify-center p-4 sm:p-6 md:p-8" };
const _hoisted_3$z = { class: "text-center" };
const _hoisted_4$x = { class: "mb-3 sm:mb-4 md:mb-5" };
const _hoisted_5$v = { class: "px-2 py-1 sm:px-3 sm:py-1 md:px-4 md:py-2 xl:px-3 xl:py-1 2xl:px-3 2xl:py-1 bg-blue-100 dark:bg-gray-800 text-blue-800 dark:text-blue-300 text-xs sm:text-sm md:text-base xl:text-sm 2xl:text-sm font-medium rounded-full" };
const _hoisted_6$t = { class: "text-xl sm:text-2xl md:text-3xl font-bold text-gray-900 dark:text-white mb-3 sm:mb-4 md:mb-5" };
const _hoisted_7$s = { class: "text-sm sm:text-base md:text-lg text-gray-600 dark:text-gray-300 mb-4 sm:mb-5 md:mb-6" };
const _hoisted_8$s = { class: "text-xs sm:text-sm md:text-base text-gray-500 dark:text-gray-400" };
const _hoisted_9$r = { class: "text-base sm:text-lg md:text-xl xl:text-lg 2xl:text-xl font-bold text-gray-900 dark:text-white mb-2 sm:mb-3 md:mb-4 xl:mb-3 2xl:mb-3" };
const _hoisted_10$q = { class: "text-sm sm:text-base md:text-lg xl:text-base 2xl:text-lg text-gray-600 dark:text-gray-300 mb-4 sm:mb-5 md:mb-6 xl:mb-4 2xl:mb-5" };
const _hoisted_11$q = { class: "mb-4 sm:mb-5 md:mb-6 xl:mb-4 2xl:mb-5" };
const _hoisted_12$p = { class: "flex flex-wrap justify-center items-center gap-1 sm:gap-2 xl:gap-1.5 2xl:gap-2 mb-2 sm:mb-3 md:mb-4 xl:mb-3 2xl:mb-3 min-h-[3rem] xl:min-h-[2.5rem] 2xl:min-h-[3rem] max-w-full px-2 sm:px-0" };
const _hoisted_13$p = ["onClick"];
const _hoisted_14$p = {
  key: 0,
  class: "text-center max-w-full px-2"
};
const _hoisted_15$m = {
  key: 0,
  class: "text-green-600 dark:text-green-400"
};
const _hoisted_16$l = { class: "font-semibold text-sm sm:text-base mb-2" };
const _hoisted_17$l = { class: "bg-green-50 dark:bg-[#0f0f0f] border border-green-200 dark:border-dark-bg-mute rounded-lg p-3 sm:p-4" };
const _hoisted_18$k = { class: "text-green-700 dark:text-green-400 font-medium text-sm sm:text-base" };
const _hoisted_19$k = {
  key: 0,
  class: "text-green-600 dark:text-green-500 text-xs sm:text-sm mt-1 opacity-80"
};
const _hoisted_20$k = {
  key: 1,
  class: "text-red-600 dark:text-red-400"
};
const _hoisted_21$k = { class: "font-semibold text-sm sm:text-base mb-2" };
const _hoisted_22$i = { class: "bg-red-50 dark:bg-[#0f0f0f] border border-red-200 dark:border-dark-bg-mute rounded-lg p-3 sm:p-4" };
const _hoisted_23$i = { class: "text-red-700 dark:text-red-400 font-bold text-base sm:text-lg mb-1" };
const _hoisted_24$h = { class: "text-red-600 dark:text-red-500 text-sm sm:text-base" };
const _hoisted_25$h = {
  key: 0,
  class: "text-red-500 dark:text-red-600 text-xs sm:text-sm mt-1 opacity-80"
};
const _hoisted_26$f = { class: "flex justify-center flex-wrap gap-2 sm:gap-3 md:gap-4 xl:gap-2 2xl:gap-2.5 mb-4 sm:mb-5 md:mb-6 xl:mb-4 2xl:mb-4 px-2 sm:px-4 md:px-6 xl:px-4 2xl:px-6 max-w-full" };
const _hoisted_27$e = ["onClick", "disabled"];
const _hoisted_28$e = { class: "flex flex-wrap justify-center gap-1.5 xs:gap-2 sm:gap-3 md:gap-4 xl:gap-2 2xl:gap-3 px-2 sm:px-4 xl:px-2 2xl:px-4 max-w-full" };
const _hoisted_29$c = ["disabled", "title"];
const _hoisted_30$b = { class: "hidden xs:hidden sm:inline" };
const _hoisted_31$b = ["disabled"];
const _hoisted_32$9 = ["disabled"];
const _hoisted_33$9 = { class: "flashcard-face flashcard-back absolute inset-0 bg-gradient-to-br from-green-400 to-green-600 dark:from-green-700 dark:to-green-900 rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 flex items-center justify-center p-4 sm:p-6 md:p-8" };
const _hoisted_34$8 = { class: "text-center text-white" };
const _hoisted_35$8 = { class: "text-base sm:text-lg md:text-xl font-bold mb-3 sm:mb-4 md:mb-5" };
const _hoisted_36$7 = {
  key: 0,
  class: "text-sm sm:text-base md:text-lg mb-3 sm:mb-4 md:mb-5"
};
const _hoisted_37$6 = {
  key: 1,
  class: "text-xs sm:text-sm md:text-base mb-3 sm:mb-4 md:mb-5 leading-relaxed"
};
const _hoisted_38$6 = { class: "text-xs sm:text-sm md:text-base opacity-75" };
const MAX_SHUFFLE_HISTORY = 3;
const _sfc_main$D = /* @__PURE__ */ defineComponent({
  __name: "FlashcardCard",
  props: {
    currentCard: {},
    isFlipped: { type: Boolean },
    scrambleWordsEnabled: { type: Boolean },
    currentIndex: {},
    totalCards: {}
  },
  emits: ["flip-card", "next-card", "show-results", "scramble-answer"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const props = __props;
    const emit = __emit;
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    const { playAudio } = useVoiceStore();
    let autoAdvanceTimer = null;
    const clearAutoAdvanceTimer = () => {
      if (autoAdvanceTimer) {
        clearTimeout(autoAdvanceTimer);
        autoAdvanceTimer = null;
      }
    };
    const isSmallScreen = ref(false);
    const updateScreenSize = () => {
      if (typeof window !== "undefined") {
        isSmallScreen.value = window.innerWidth < 768;
      }
    };
    if (typeof window !== "undefined") {
      updateScreenSize();
      window.addEventListener("resize", updateScreenSize);
    }
    const assembledWord = ref([]);
    const availableLetters = ref([]);
    const scrambleAnswered = ref(false);
    const scrambleCorrect = ref(false);
    const previousShuffles = ref([]);
    const createAdvancedShuffle = (letters) => {
      const shuffled = [...letters];
      const passes = Math.max(3, Math.floor(letters.length / 2) + 1);
      for (let pass = 0; pass < passes; pass++) {
        const timeSeed = Date.now() + pass * 1e3;
        const randomSeed = Math.random() * 1e4;
        const passEntropy = (timeSeed + randomSeed) % 1;
        for (let i = shuffled.length - 1; i > 0; i--) {
          const baseRandom = Math.random();
          const timeRandom = Date.now() % 997 / 997;
          const passRandom = (pass + 1) / passes;
          const combinedRandom = (baseRandom + timeRandom + passRandom + passEntropy) % 1;
          const j = Math.floor(combinedRandom * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        if (pass % 2 === 0) {
          for (let i = 0; i < shuffled.length - 1; i++) {
            const entropy = (Math.random() + Date.now() % 101 / 100) % 1;
            if (entropy > 0.5) {
              const j = Math.min(i + 1 + Math.floor(Math.random() * 2), shuffled.length - 1);
              [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
          }
        }
      }
      return shuffled;
    };
    const isSimilarToPrevious = (current, previous) => {
      if (previous.length === 0) return false;
      return previous.some((prev) => {
        if (prev.length !== current.length) return false;
        let matches = 0;
        for (let i = 0; i < current.length; i++) {
          if (current[i] === prev[i]) matches++;
        }
        return matches / current.length > 0.6;
      });
    };
    const initializeScrambledLetters = () => {
      if (!props.currentCard || !props.scrambleWordsEnabled) return;
      const word = props.currentCard.word.toLowerCase();
      const letters = word.split("");
      const letterObjects = letters.map((char, index) => ({
        char: char.toUpperCase(),
        used: false,
        originalIndex: index
      }));
      let attempts = 0;
      let shuffledOrder;
      const maxAttempts = 10;
      do {
        shuffledOrder = createAdvancedShuffle(letters.map((char) => char.toUpperCase()));
        attempts++;
      } while (attempts < maxAttempts && isSimilarToPrevious(shuffledOrder, previousShuffles.value));
      previousShuffles.value.push(shuffledOrder);
      if (previousShuffles.value.length > MAX_SHUFFLE_HISTORY) {
        previousShuffles.value.shift();
      }
      const shuffledLetterObjects = [];
      const usedIndices = /* @__PURE__ */ new Set();
      shuffledOrder.forEach((char) => {
        const originalLetterIndex = letterObjects.findIndex(
          (obj, idx) => obj.char === char && !usedIndices.has(idx)
        );
        if (originalLetterIndex !== -1) {
          const originalLetterObj = letterObjects[originalLetterIndex];
          usedIndices.add(originalLetterIndex);
          shuffledLetterObjects.push({
            ...originalLetterObj,
            used: false
          });
        }
      });
      availableLetters.value = shuffledLetterObjects.length === letterObjects.length ? shuffledLetterObjects : letterObjects;
      assembledWord.value = [];
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
      console.log("🎲 New shuffle created:", {
        word: props.currentCard.word,
        original: letters,
        shuffled: shuffledOrder,
        attempts,
        historySize: previousShuffles.value.length
      });
    };
    watch(() => props.currentCard, () => {
      clearAutoAdvanceTimer();
      if (props.scrambleWordsEnabled) {
        initializeScrambledLetters();
      }
    }, { immediate: true });
    watch(() => props.scrambleWordsEnabled, (enabled) => {
      clearAutoAdvanceTimer();
      if (enabled) {
        initializeScrambledLetters();
      } else {
        assembledWord.value = [];
        availableLetters.value = [];
        scrambleAnswered.value = false;
        scrambleCorrect.value = false;
        previousShuffles.value = [];
      }
    });
    const selectLetter = (index) => {
      if (availableLetters.value[index].used) return;
      if (scrambleAnswered.value && scrambleCorrect.value) return;
      assembledWord.value.push(availableLetters.value[index].char);
      availableLetters.value[index].used = true;
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
    };
    const removeLetter = (assembledIndex) => {
      if (scrambleAnswered.value && scrambleCorrect.value) return;
      const removedChar = assembledWord.value[assembledIndex];
      assembledWord.value.splice(assembledIndex, 1);
      const availableIndex = availableLetters.value.findIndex(
        (letter) => letter.char === removedChar && letter.used
      );
      if (availableIndex !== -1) {
        availableLetters.value[availableIndex].used = false;
      }
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
    };
    const clearAssembledWord = () => {
      if (scrambleAnswered.value && scrambleCorrect.value) return;
      availableLetters.value.forEach((letter) => {
        letter.used = false;
      });
      assembledWord.value = [];
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
    };
    const backspaceAssembledWord = () => {
      if (scrambleAnswered.value && scrambleCorrect.value) return;
      if (assembledWord.value.length === 0) return;
      const removedChar = assembledWord.value.pop();
      const availableIndex = availableLetters.value.findIndex(
        (letter) => letter.char === removedChar && letter.used
      );
      if (availableIndex !== -1) {
        availableLetters.value[availableIndex].used = false;
      }
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
    };
    const checkScrambleAnswer = async () => {
      if (assembledWord.value.length !== props.currentCard.word.length) return;
      const userAnswer = assembledWord.value.join("").toLowerCase();
      const correctAnswer = props.currentCard.word.toLowerCase();
      scrambleAnswered.value = true;
      scrambleCorrect.value = userAnswer === correctAnswer;
      clearAutoAdvanceTimer();
      const isLastCard = props.currentIndex !== void 0 && props.totalCards !== void 0 && props.currentIndex + 1 >= props.totalCards;
      console.log("Scramble Check Debug:", {
        currentIndex: props.currentIndex,
        totalCards: props.totalCards,
        isLastCard,
        isSmallScreen: isSmallScreen.value,
        scrambleCorrect: scrambleCorrect.value
      });
      emit("scramble-answer", scrambleCorrect.value);
      if (scrambleCorrect.value) {
        isCorrectAnswer.value = true;
        triggerFirework.value = true;
        triggerSound.value = true;
        try {
          await nextTick();
          await playAudio(props.currentCard.word);
        } catch (error) {
          console.warn("Voice playbook error:", error);
        }
        if (isSmallScreen.value) {
          console.log("Setting timer for correct answer:", isLastCard ? "show-results" : "next-card");
          autoAdvanceTimer = setTimeout(() => {
            console.log("Timer executed, emitting:", isLastCard ? "show-results" : "next-card");
            if (isLastCard) {
              emit("show-results");
            } else {
              emit("next-card");
            }
          }, 2500);
        }
      } else {
        isCorrectAnswer.value = false;
        triggerFirework.value = true;
        triggerSound.value = true;
        if (isSmallScreen.value) {
          console.log("Setting timer for incorrect answer:", isLastCard ? "show-results" : "next-card");
          autoAdvanceTimer = setTimeout(() => {
            console.log("Timer executed for incorrect, emitting:", isLastCard ? "show-results" : "next-card");
            if (isLastCard) {
              emit("show-results");
            } else {
              emit("next-card");
            }
          }, 2500);
        }
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$D, [
        createBaseVNode("div", {
          class: normalizeClass([["flashcard", { "flipped": _ctx.isFlipped }], "relative w-full cursor-pointer h-80 sm:h-96 md:h-[28rem] xl:h-[30rem] 2xl:h-[32rem] select-none"]),
          onClick: _cache[0] || (_cache[0] = ($event) => !_ctx.scrambleWordsEnabled && _ctx.$emit("flip-card")),
          onCopy: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["prevent"])),
          onCut: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["prevent"])),
          onContextmenu: _cache[3] || (_cache[3] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          createBaseVNode("div", _hoisted_2$A, [
            createBaseVNode("div", _hoisted_3$z, [
              createBaseVNode("div", _hoisted_4$x, [
                createBaseVNode("span", _hoisted_5$v, toDisplayString$1(unref(getTopicName)(_ctx.currentCard.category)), 1)
              ]),
              !_ctx.scrambleWordsEnabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("h2", _hoisted_6$t, toDisplayString$1(_ctx.currentCard.word), 1),
                createBaseVNode("p", _hoisted_7$s, toDisplayString$1(_ctx.currentCard.pronunciation), 1),
                createBaseVNode("p", _hoisted_8$s, toDisplayString$1(unref(t)("flashcard.card.flip_to_meaning", "Click to see meaning")), 1)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createBaseVNode("h3", _hoisted_9$r, toDisplayString$1(unref(t)("flashcard.scrambleWords.instruction", "Arrange the letters to form the word")), 1),
                createBaseVNode("p", _hoisted_10$q, toDisplayString$1(_ctx.currentCard.pronunciation), 1),
                createBaseVNode("div", _hoisted_11$q, [
                  createBaseVNode("div", _hoisted_12$p, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(assembledWord.value, (letter, index) => {
                      return openBlock(), createElementBlock("div", {
                        key: `assembled-${index}`,
                        class: "w-8 h-8 sm:w-10 sm:h-10 md:w-12 md:h-12 xl:w-10 xl:h-10 2xl:w-11 2xl:h-11 border-2 border-gray-300 dark:border-dark-bg-mute rounded-lg flex items-center justify-center bg-blue-50 dark:bg-[#0f0f0f] text-lg sm:text-xl md:text-2xl xl:text-xl 2xl:text-2xl font-bold text-gray-900 dark:text-white cursor-pointer hover:bg-blue-100 dark:hover:bg-[#1a1a1a] transition-colors",
                        onClick: ($event) => removeLetter(index)
                      }, toDisplayString$1(letter), 9, _hoisted_13$p);
                    }), 128)),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(Math.max(0, _ctx.currentCard.word.length - assembledWord.value.length), (n) => {
                      return openBlock(), createElementBlock("div", {
                        key: `empty-${n}`,
                        class: "w-8 h-8 sm:w-10 sm:h-10 md:w-12 md:h-12 xl:w-10 xl:h-10 2xl:w-11 2xl:h-11 border-2 border-dashed border-gray-300 dark:border-dark-bg-mute rounded-lg bg-gray-50 dark:bg-[#0f0f0f]"
                      });
                    }), 128))
                  ]),
                  scrambleAnswered.value ? (openBlock(), createElementBlock("div", _hoisted_14$p, [
                    scrambleCorrect.value ? (openBlock(), createElementBlock("div", _hoisted_15$m, [
                      createBaseVNode("p", _hoisted_16$l, " ✅ " + toDisplayString$1(unref(t)("flashcard.scrambleWords.correct", "Correct!")), 1),
                      createBaseVNode("div", _hoisted_17$l, [
                        createBaseVNode("p", _hoisted_18$k, toDisplayString$1(_ctx.currentCard.meaning), 1),
                        _ctx.currentCard.partOfSpeech ? (openBlock(), createElementBlock("p", _hoisted_19$k, toDisplayString$1(unref(t)(`vocabulary.wordTypes.${_ctx.currentCard.partOfSpeech}`, _ctx.currentCard.partOfSpeech)), 1)) : createCommentVNode("", true)
                      ])
                    ])) : (openBlock(), createElementBlock("div", _hoisted_20$k, [
                      createBaseVNode("p", _hoisted_21$k, " ❌ " + toDisplayString$1(unref(t)("flashcard.scrambleWords.incorrect", "Try again!")), 1),
                      createBaseVNode("div", _hoisted_22$i, [
                        createBaseVNode("p", _hoisted_23$i, toDisplayString$1(_ctx.currentCard.word.toUpperCase()), 1),
                        createBaseVNode("p", _hoisted_24$h, toDisplayString$1(_ctx.currentCard.meaning), 1),
                        _ctx.currentCard.partOfSpeech ? (openBlock(), createElementBlock("p", _hoisted_25$h, toDisplayString$1(unref(t)(`vocabulary.wordTypes.${_ctx.currentCard.partOfSpeech}`, _ctx.currentCard.partOfSpeech)), 1)) : createCommentVNode("", true)
                      ])
                    ]))
                  ])) : createCommentVNode("", true)
                ]),
                createBaseVNode("div", _hoisted_26$f, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(availableLetters.value, (letter, index) => {
                    return withDirectives((openBlock(), createElementBlock("button", {
                      key: `scrambled-${index}`,
                      class: "w-8 h-8 sm:w-10 sm:h-10 md:w-12 md:h-12 xl:w-10 xl:h-10 2xl:w-11 2xl:h-11 border-2 border-gray-400 dark:border-dark-bg-soft rounded-lg flex items-center justify-center bg-white dark:bg-[#0f0f0f] hover:bg-gray-100 dark:hover:bg-[#1a1a1a] text-lg sm:text-xl md:text-2xl xl:text-xl 2xl:text-2xl font-bold text-gray-900 dark:text-white cursor-pointer transition-all duration-200 hover:scale-105 active:scale-95",
                      onClick: ($event) => selectLetter(index),
                      disabled: scrambleAnswered.value && scrambleCorrect.value
                    }, toDisplayString$1(letter.char), 9, _hoisted_27$e)), [
                      [vShow, !letter.used]
                    ]);
                  }), 128))
                ]),
                createBaseVNode("div", _hoisted_28$e, [
                  createBaseVNode("button", {
                    onClick: backspaceAssembledWord,
                    class: "px-2 py-1 xs:px-2 xs:py-1.5 sm:px-3 sm:py-2 md:px-4 md:py-2.5 xl:px-3 xl:py-2 2xl:px-4 2xl:py-2.5 bg-orange-500 hover:bg-orange-600 dark:bg-orange-600 dark:hover:bg-orange-700 text-white text-xs sm:text-sm md:text-base xl:text-sm 2xl:text-base font-semibold rounded-md sm:rounded-lg transition-colors flex items-center gap-1 sm:gap-2 xl:gap-1 2xl:gap-2 min-w-0 flex-shrink-0",
                    disabled: assembledWord.value.length === 0 || scrambleAnswered.value && scrambleCorrect.value,
                    title: unref(t)("flashcard.scrambleWords.backspace", "Backspace")
                  }, [
                    _cache[4] || (_cache[4] = createBaseVNode("svg", {
                      class: "w-3 h-3 sm:w-4 sm:h-4 xl:w-3 xl:h-3 2xl:w-4 2xl:h-4",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M6.707 4.879A3 3 0 018.828 4H15a3 3 0 013 3v6a3 3 0 01-3 3H8.828a3 3 0 01-2.12-.879l-4.415-4.414a1 1 0 010-1.414l4.414-4.414zm4 3.707a1 1 0 00-1.414-1.414L8 8.586 6.707 7.293a1 1 0 10-1.414 1.414L6.586 10l-1.293 1.293a1 1 0 101.414 1.414L8 11.414l1.293 1.293a1 1 0 001.414-1.414L9.414 10l1.293-1.293z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)),
                    createBaseVNode("span", _hoisted_30$b, toDisplayString$1(unref(t)("flashcard.scrambleWords.backspace", "Backspace")), 1)
                  ], 8, _hoisted_29$c),
                  createBaseVNode("button", {
                    onClick: clearAssembledWord,
                    class: "px-2 py-1 xs:px-3 xs:py-1.5 sm:px-4 sm:py-2 md:px-5 md:py-2.5 xl:px-4 xl:py-2 2xl:px-5 2xl:py-2.5 bg-gray-500 hover:bg-gray-600 dark:bg-gray-600 dark:hover:bg-gray-700 text-white text-xs sm:text-sm md:text-base xl:text-sm 2xl:text-base font-semibold rounded-md sm:rounded-lg transition-colors min-w-0 flex-shrink-0",
                    disabled: assembledWord.value.length === 0 || scrambleAnswered.value && scrambleCorrect.value
                  }, toDisplayString$1(unref(t)("flashcard.scrambleWords.clear", "Clear")), 9, _hoisted_31$b),
                  createBaseVNode("button", {
                    onClick: checkScrambleAnswer,
                    class: "px-2 py-1 xs:px-3 xs:py-1.5 sm:px-4 sm:py-2 md:px-5 md:py-2.5 xl:px-4 xl:py-2 2xl:px-5 2xl:py-2.5 bg-blue-600 hover:bg-blue-700 text-white text-xs sm:text-sm md:text-base xl:text-sm 2xl:text-base font-semibold rounded-md sm:rounded-lg transition-colors min-w-0 flex-shrink-0",
                    disabled: assembledWord.value.length !== _ctx.currentCard.word.length || scrambleAnswered.value && scrambleCorrect.value
                  }, toDisplayString$1(unref(t)("flashcard.scrambleWords.check", "Check")), 9, _hoisted_32$9)
                ])
              ], 64))
            ])
          ]),
          createBaseVNode("div", _hoisted_33$9, [
            createBaseVNode("div", _hoisted_34$8, [
              createBaseVNode("h3", _hoisted_35$8, toDisplayString$1(_ctx.currentCard.meaning), 1),
              _ctx.currentCard.partOfSpeech ? (openBlock(), createElementBlock("p", _hoisted_36$7, toDisplayString$1(unref(t)(`vocabulary.wordTypes.${_ctx.currentCard.partOfSpeech}`, _ctx.currentCard.partOfSpeech)), 1)) : createCommentVNode("", true),
              _ctx.currentCard.example ? (openBlock(), createElementBlock("p", _hoisted_37$6, toDisplayString$1(_ctx.currentCard.example), 1)) : createCommentVNode("", true),
              createBaseVNode("p", _hoisted_38$6, toDisplayString$1(unref(t)("flashcard.card.flip_back", "Click to flip back")), 1)
            ])
          ])
        ], 34),
        createVNode(unref(FireworkSoundEffect), {
          ref_key: "fireworkEffect",
          ref: fireworkEffect,
          "trigger-firework": triggerFirework.value,
          "trigger-sound": triggerSound.value,
          "is-correct": isCorrectAnswer.value,
          onEffectComplete: resetTriggers
        }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
      ]);
    };
  }
});

const FlashcardCard = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["__scopeId", "data-v-e4d27939"]]);

const FlashcardCard$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: FlashcardCard
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$C = { class: "h-full flex flex-col" };
const _hoisted_2$z = { class: "text-center mb-4" };
const _hoisted_3$y = { class: "px-4 py-2 bg-yellow-100 dark:bg-gray-800 text-yellow-800 dark:text-yellow-300 text-sm font-medium rounded-full" };
const _hoisted_4$w = { class: "text-center mb-4 flex-shrink-0" };
const _hoisted_5$u = { class: "text-xl sm:text-2xl md:text-3xl font-bold text-gray-900 dark:text-white mb-2" };
const _hoisted_6$s = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_7$r = { class: "text-xs sm:text-sm md:text-base text-gray-500 dark:text-gray-400 mt-1" };
const _hoisted_8$r = { class: "flex-1 flex flex-col justify-center min-h-0" };
const _hoisted_9$q = { class: "flex items-center justify-center" };
const _hoisted_10$p = { class: "grid grid-cols-2 gap-3 w-full max-w-lg" };
const _hoisted_11$p = ["onClick", "disabled"];
const _hoisted_12$o = { class: "absolute top-2 left-2 w-6 h-6 rounded-full text-xs font-semibold flex items-center justify-center bg-gray-200 text-gray-700 dark:bg-white/10 dark:text-white/80" };
const _hoisted_13$o = { class: "text-center px-6" };
const _hoisted_14$o = {
  key: 0,
  class: "absolute top-2 right-2 text-green-500"
};
const _hoisted_15$l = {
  key: 1,
  class: "absolute top-2 right-2 text-red-500"
};
const _sfc_main$C = /* @__PURE__ */ defineComponent({
  __name: "FlashcardQuiz",
  props: {
    currentCard: {},
    quizOptions: {},
    selectedAnswer: {},
    quizAnswered: { type: Boolean }
  },
  emits: ["select-answer"],
  setup(__props, { emit: __emit }) {
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const { t } = useI18n();
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const props = __props;
    const emit = __emit;
    const getCorrectAnswer = () => {
      return props.currentCard.meaning.split(" - ")[0].trim();
    };
    const handleSelectAnswer = (answer) => {
      if (props.quizAnswered) return;
      emit("select-answer", answer);
      const correctAnswer = getCorrectAnswer();
      isCorrectAnswer.value = answer === correctAnswer;
      setTimeout(() => {
        triggerFirework.value = true;
        triggerSound.value = true;
      }, 100);
    };
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 p-8 h-96 select-none",
        onCopy: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createBaseVNode("div", _hoisted_1$C, [
          createBaseVNode("div", _hoisted_2$z, [
            createBaseVNode("span", _hoisted_3$y, toDisplayString$1(unref(getTopicName)(_ctx.currentCard.category)), 1)
          ]),
          createBaseVNode("div", _hoisted_4$w, [
            createBaseVNode("h2", _hoisted_5$u, toDisplayString$1(_ctx.currentCard.word), 1),
            createBaseVNode("p", _hoisted_6$s, toDisplayString$1(_ctx.currentCard.pronunciation), 1),
            createBaseVNode("p", _hoisted_7$r, toDisplayString$1(unref(t)("flashcard.quiz.instruction", "Choose the correct meaning:")), 1)
          ]),
          createBaseVNode("div", _hoisted_8$r, [
            createBaseVNode("div", _hoisted_9$q, [
              createBaseVNode("div", _hoisted_10$p, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.quizOptions, (option, index) => {
                  return openBlock(), createElementBlock("button", {
                    key: index,
                    onClick: ($event) => handleSelectAnswer(option),
                    class: normalizeClass([
                      "relative p-4 text-center rounded-lg border-2 transition-all duration-200 font-semibold text-sm min-h-[60px] flex items-center justify-center",
                      _ctx.quizAnswered ? option === getCorrectAnswer() ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300 border-green-300 dark:border-green-700" : option === _ctx.selectedAnswer ? "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-300 border-red-300 dark:border-red-700" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60 hover:shadow-sm hover:scale-[1.01] dark:hover:bg-white/5"
                    ]),
                    disabled: _ctx.quizAnswered
                  }, [
                    createBaseVNode("span", _hoisted_12$o, toDisplayString$1(String.fromCharCode(65 + index)), 1),
                    createBaseVNode("span", _hoisted_13$o, toDisplayString$1(option), 1),
                    _ctx.quizAnswered && option === getCorrectAnswer() ? (openBlock(), createElementBlock("span", _hoisted_14$o, _cache[3] || (_cache[3] = [
                      createBaseVNode("svg", {
                        class: "w-5 h-5",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)
                    ]))) : _ctx.quizAnswered && option === _ctx.selectedAnswer && option !== getCorrectAnswer() ? (openBlock(), createElementBlock("span", _hoisted_15$l, _cache[4] || (_cache[4] = [
                      createBaseVNode("svg", {
                        class: "w-5 h-5",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)
                    ]))) : createCommentVNode("", true)
                  ], 10, _hoisted_11$p);
                }), 128))
              ])
            ])
          ])
        ]),
        createVNode(unref(FireworkSoundEffect), {
          ref_key: "fireworkEffect",
          ref: fireworkEffect,
          "trigger-firework": triggerFirework.value,
          "trigger-sound": triggerSound.value,
          "is-correct": isCorrectAnswer.value,
          onEffectComplete: resetTriggers
        }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
      ], 32);
    };
  }
});

const FlashcardQuiz = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$C
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$B = { class: "h-full flex flex-col" };
const _hoisted_2$y = { class: "text-center mb-6" };
const _hoisted_3$x = { class: "px-4 py-2 bg-purple-100 dark:bg-gray-800 text-purple-800 dark:text-purple-300 text-sm font-medium rounded-full" };
const _hoisted_4$v = { class: "text-center mb-8" };
const _hoisted_5$t = { class: "text-2xl sm:text-3xl md:text-4xl font-bold text-gray-900 dark:text-white mb-4" };
const _hoisted_6$r = {
  key: 0,
  class: "text-base sm:text-lg md:text-xl text-gray-600 dark:text-gray-300"
};
const _hoisted_7$q = {
  key: 1,
  class: "text-base sm:text-lg md:text-xl text-gray-600 dark:text-gray-300"
};
const _hoisted_8$q = { class: "flex-1 flex flex-col justify-center" };
const _hoisted_9$p = {
  key: 0,
  class: "max-w-lg mx-auto w-full"
};
const _hoisted_10$o = { class: "relative" };
const _hoisted_11$o = ["value", "disabled", "placeholder"];
const _hoisted_12$n = {
  key: 0,
  class: "absolute right-3 top-1/2 transform -translate-y-1/2"
};
const _hoisted_13$n = {
  key: 0,
  class: "text-green-500"
};
const _hoisted_14$n = {
  key: 1,
  class: "text-red-500"
};
const _hoisted_15$k = {
  key: 0,
  class: "mt-4 text-center"
};
const _hoisted_16$k = { class: "text-gray-600 dark:text-gray-400 text-sm" };
const _hoisted_17$k = { class: "text-lg sm:text-xl md:text-2xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_18$j = {
  key: 1,
  class: "w-full px-2 sm:px-3 md:px-0"
};
const _hoisted_19$j = { class: "grid grid-cols-1 sm:grid-cols-2 gap-1.5 sm:gap-2 justify-items-stretch w-full" };
const _hoisted_20$j = ["onClick", "disabled"];
const _hoisted_21$j = { class: "inline-flex items-center justify-center w-5 h-5 rounded-full text-xs font-semibold bg-gray-200 text-gray-700 dark:bg-white/10 dark:text-white/80 shrink-0" };
const _hoisted_22$h = { class: "truncate overflow-hidden min-w-0" };
const _hoisted_23$h = {
  key: 0,
  class: "mt-3 sm:mt-4 text-center px-2"
};
const _hoisted_24$g = {
  key: 0,
  class: "text-green-600 dark:text-green-400 font-medium text-sm sm:text-base"
};
const _hoisted_25$g = {
  key: 1,
  class: "text-red-600 dark:text-red-400 font-medium text-sm sm:text-base break-words"
};
const _hoisted_26$e = { class: "font-bold" };
const _hoisted_27$d = { class: "text-center mt-6" };
const _hoisted_28$d = ["disabled"];
const _sfc_main$B = /* @__PURE__ */ defineComponent({
  __name: "FlashcardTyping",
  props: {
    currentCard: {},
    typingAnswer: {},
    typingAnswered: { type: Boolean },
    typingCorrect: { type: Boolean },
    typingQuizEnabled: { type: Boolean },
    typingQuizOptions: {},
    typingQuizSelected: {},
    typingQuizAnswered: { type: Boolean }
  },
  emits: ["update:typingAnswer", "check-answer", "select-typing-quiz-answer"],
  setup(__props, { emit: __emit }) {
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const { t } = useI18n();
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const props = __props;
    const emit = __emit;
    const stripDiacritics = (s) => s.replace(/[ưừứửữự]/g, "w").replace(/[ƯỪỨỬỮỰ]/g, "W").normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/đ/g, "d").replace(/Đ/g, "D");
    const handleInput = (event) => {
      const target = event.target;
      const sanitized = stripDiacritics(target.value);
      if (sanitized !== target.value) {
        target.value = sanitized;
      }
      emit("update:typingAnswer", sanitized);
    };
    const getShortMeaning = (meaning) => {
      return meaning.split(" - ")[0].trim();
    };
    const handleCheckAnswer = () => {
      if (props.typingAnswered) return;
      emit("check-answer");
      setTimeout(() => {
        isCorrectAnswer.value = props.typingAnswer.toLowerCase().trim() === props.currentCard.word.toLowerCase();
        triggerFirework.value = true;
        triggerSound.value = true;
      }, 100);
    };
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    watch(() => props.typingAnswered, (newValue) => {
      if (newValue && !triggerFirework.value) {
        if (typeof props.typingCorrect === "boolean") {
          isCorrectAnswer.value = props.typingCorrect;
        } else {
          isCorrectAnswer.value = props.typingAnswer.toLowerCase().trim() === props.currentCard.word.toLowerCase();
        }
        setTimeout(() => {
          triggerFirework.value = true;
          triggerSound.value = true;
        }, 50);
      }
    });
    const onSelectTypingOption = (opt) => {
      if (!props.typingQuizAnswered) emit("select-typing-quiz-answer", opt);
    };
    const isOptionSelected = (opt) => props.typingQuizSelected === opt;
    const isOptionCorrect = (opt) => opt.trim().toLowerCase() === props.currentCard.word.trim().toLowerCase();
    const typingInput = ref(null);
    const focusTypingInput = async () => {
      await nextTick();
      try {
        typingInput.value?.focus({ preventScroll: true });
      } catch {
        typingInput.value?.focus();
      }
    };
    const ensureTypingFocus = () => {
      if (!props.typingQuizEnabled && !props.typingAnswered) {
        if (document.activeElement !== typingInput.value) {
          focusTypingInput();
        }
      }
    };
    const onTypingBlur = () => {
      ensureTypingFocus();
    };
    onMounted(() => {
      ensureTypingFocus();
    });
    watch(() => props.typingQuizEnabled, (val) => {
      if (!val) ensureTypingFocus();
    });
    watch(() => props.typingAnswered, (answered) => {
      if (!answered) ensureTypingFocus();
    });
    watch(() => props.currentCard, () => {
      ensureTypingFocus();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 p-8 h-96 select-none",
        onCopy: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createBaseVNode("div", _hoisted_1$B, [
          createBaseVNode("div", _hoisted_2$y, [
            createBaseVNode("span", _hoisted_3$x, toDisplayString$1(unref(getTopicName)(_ctx.currentCard.category)), 1)
          ]),
          createBaseVNode("div", _hoisted_4$v, [
            createBaseVNode("h2", _hoisted_5$t, toDisplayString$1(getShortMeaning(_ctx.currentCard.meaning)), 1),
            !_ctx.typingQuizEnabled ? (openBlock(), createElementBlock("p", _hoisted_6$r, toDisplayString$1(unref(t)("flashcard.typing.instruction", "Type the corresponding English word:")), 1)) : (openBlock(), createElementBlock("p", _hoisted_7$q, toDisplayString$1(unref(t)("flashcard.typing.instructionQuiz", "Choose the correct English word:")), 1))
          ]),
          createBaseVNode("div", _hoisted_8$q, [
            !_ctx.typingQuizEnabled ? (openBlock(), createElementBlock("div", _hoisted_9$p, [
              createBaseVNode("div", _hoisted_10$o, [
                createBaseVNode("input", {
                  ref_key: "typingInput",
                  ref: typingInput,
                  value: _ctx.typingAnswer,
                  onInput: handleInput,
                  onKeyup: withKeys(handleCheckAnswer, ["enter"]),
                  type: "text",
                  disabled: _ctx.typingAnswered,
                  class: "w-full p-3 text-center text-xl sm:text-2xl md:text-3xl border-2 border-gray-300 dark:border-gray-600 rounded-xl bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-4 focus:ring-purple-500/20 focus:border-purple-500 transition-all duration-200 disabled:bg-gray-100 dark:disabled:bg-gray-700 select-text",
                  placeholder: unref(t)("flashcard.typing.placeholder", "Type the word..."),
                  inputmode: "text",
                  autocomplete: "off",
                  autocapitalize: "none",
                  spellcheck: "false",
                  onBlur: onTypingBlur
                }, null, 40, _hoisted_11$o),
                _ctx.typingAnswered ? (openBlock(), createElementBlock("div", _hoisted_12$n, [
                  _ctx.typingAnswer.toLowerCase().trim() === _ctx.currentCard.word.toLowerCase() ? (openBlock(), createElementBlock("span", _hoisted_13$n, _cache[3] || (_cache[3] = [
                    createBaseVNode("svg", {
                      class: "w-8 h-8",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)
                  ]))) : (openBlock(), createElementBlock("span", _hoisted_14$n, _cache[4] || (_cache[4] = [
                    createBaseVNode("svg", {
                      class: "w-8 h-8",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)
                  ])))
                ])) : createCommentVNode("", true)
              ]),
              _ctx.typingAnswered && _ctx.typingAnswer.toLowerCase().trim() !== _ctx.currentCard.word.toLowerCase() ? (openBlock(), createElementBlock("div", _hoisted_15$k, [
                createBaseVNode("p", _hoisted_16$k, toDisplayString$1(unref(t)("flashcard.typing.correctAnswer", "Correct answer:")), 1),
                createBaseVNode("p", _hoisted_17$k, toDisplayString$1(_ctx.currentCard.word), 1)
              ])) : createCommentVNode("", true)
            ])) : (openBlock(), createElementBlock("div", _hoisted_18$j, [
              createBaseVNode("div", _hoisted_19$j, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.typingQuizOptions, (opt, idx) => {
                  return openBlock(), createElementBlock("button", {
                    key: idx,
                    onClick: ($event) => onSelectTypingOption(opt),
                    disabled: _ctx.typingQuizAnswered,
                    translate: "no",
                    class: normalizeClass(["notranslate px-3 py-1.5 sm:py-2 rounded-md border text-[13px] sm:text-sm transition-all duration-150 disabled:opacity-70 disabled:cursor-not-allowed text-left flex items-center gap-2 w-full min-w-0", [
                      _ctx.typingQuizAnswered ? isOptionCorrect(opt) ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300 border-green-300 dark:border-green-700" : isOptionSelected(opt) ? "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-300 border-red-300 dark:border-red-700" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60 hover:shadow-sm hover:scale-[1.01] dark:hover:bg-white/5"
                    ]])
                  }, [
                    createBaseVNode("span", _hoisted_21$j, toDisplayString$1(String.fromCharCode(65 + idx)), 1),
                    createBaseVNode("span", _hoisted_22$h, toDisplayString$1(opt), 1)
                  ], 10, _hoisted_20$j);
                }), 128))
              ]),
              _ctx.typingAnswered ? (openBlock(), createElementBlock("div", _hoisted_23$h, [
                _ctx.typingCorrect ? (openBlock(), createElementBlock("p", _hoisted_24$g, toDisplayString$1(unref(t)("flashcard.typing.correct", "✓ Correct!")), 1)) : (openBlock(), createElementBlock("p", _hoisted_25$g, [
                  createTextVNode(toDisplayString$1(unref(t)("flashcard.typing.incorrect", "✗ Correct answer:")) + " ", 1),
                  createBaseVNode("span", _hoisted_26$e, toDisplayString$1(_ctx.currentCard.word), 1)
                ]))
              ])) : createCommentVNode("", true)
            ]))
          ]),
          createBaseVNode("div", _hoisted_27$d, [
            !_ctx.typingAnswered && !_ctx.typingQuizEnabled ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: handleCheckAnswer,
              disabled: !_ctx.typingAnswer.trim(),
              class: "bg-purple-500 hover:bg-purple-600 disabled:bg-gray-300 dark:disabled:bg-gray-700 text-white px-8 py-3 rounded-full font-medium transition-colors"
            }, toDisplayString$1(unref(t)("common.check", "Check")), 9, _hoisted_28$d)) : createCommentVNode("", true)
          ])
        ]),
        createVNode(unref(FireworkSoundEffect), {
          ref_key: "fireworkEffect",
          ref: fireworkEffect,
          "trigger-firework": triggerFirework.value,
          "trigger-sound": triggerSound.value,
          "is-correct": isCorrectAnswer.value,
          onEffectComplete: resetTriggers
        }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
      ], 32);
    };
  }
});

const FlashcardTyping = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$B
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$A = { class: "h-full flex flex-col overflow-hidden" };
const _hoisted_2$x = { class: "mb-4 text-center" };
const _hoisted_3$w = { class: "px-3 py-1 bg-purple-100 dark:bg-dark-bg-mute text-purple-800 dark:text-purple-300 text-sm font-medium rounded-full" };
const _hoisted_4$u = { class: "flex-1 flex items-center justify-center mb-4 min-h-0" };
const _hoisted_5$s = {
  key: 0,
  class: "relative"
};
const _hoisted_6$q = ["src", "alt"];
const _hoisted_7$p = {
  key: 0,
  class: "absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-dark-bg-mute rounded-lg"
};
const _hoisted_8$p = { class: "text-center" };
const _hoisted_9$o = { class: "text-sm text-gray-500 dark:text-white/60 mt-2" };
const _hoisted_10$n = {
  key: 1,
  class: "flex items-center justify-center bg-gray-100 dark:bg-dark-bg-mute rounded-lg p-8 w-full max-w-sm"
};
const _hoisted_11$n = { class: "text-center" };
const _hoisted_12$m = { class: "text-sm text-gray-500 dark:text-white/60 mt-2" };
const _hoisted_13$m = { class: "space-y-3 flex-shrink-0" };
const _hoisted_14$m = { key: 0 };
const _hoisted_15$j = ["disabled", "placeholder"];
const _hoisted_16$j = { key: 1 };
const _hoisted_17$j = { class: "grid grid-cols-1 sm:grid-cols-2 gap-2 justify-items-center sm:justify-items-center justify-center mx-auto max-w-[560px] sm:max-w-[520px]" };
const _hoisted_18$i = ["onClick", "disabled"];
const _hoisted_19$i = { class: "inline-flex items-center justify-center w-5 h-5 rounded-full text-xs font-semibold bg-gray-200 text-gray-700 dark:bg-white/10 dark:text-white/80" };
const _hoisted_20$i = { class: "truncate" };
const _hoisted_21$i = {
  key: 2,
  class: "text-center space-y-2 max-h-32 overflow-y-auto"
};
const _hoisted_22$g = {
  key: 0,
  class: "w-4 h-4 mr-1",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_23$g = {
  key: 1,
  class: "w-4 h-4 mr-1",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_24$f = {
  key: 0,
  class: "text-center"
};
const _hoisted_25$f = { class: "text-sm text-gray-600 dark:text-white/70" };
const _hoisted_26$d = { class: "font-semibold text-gray-900 dark:text-white" };
const _hoisted_27$c = { class: "text-xs text-gray-500 dark:text-white/60 mt-1 line-clamp-2" };
const _hoisted_28$c = {
  key: 1,
  class: "text-center"
};
const _hoisted_29$b = { class: "text-sm text-gray-600 dark:text-white/70 line-clamp-2" };
const _hoisted_30$a = {
  key: 3,
  class: "text-center text-sm text-gray-500 dark:text-white/60"
};
const _hoisted_31$a = {
  key: 4,
  class: "text-center text-sm text-gray-500 dark:text-white/60"
};
const STORAGE_KEY_IMAGE_QUIZ = "flashcard_image_quiz_enabled";
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "FlashcardImage",
  props: {
    currentCard: {},
    imageAnswer: {},
    imageAnswered: { type: Boolean },
    imageCorrect: { type: Boolean },
    imageQuizEnabled: { type: Boolean },
    imageQuizOptions: {},
    imageQuizSelected: {},
    imageQuizAnswered: { type: Boolean }
  },
  emits: ["update:imageAnswer", "checkAnswer", "update:imageQuizEnabled", "select-image-quiz-answer"],
  setup(__props, { emit: __emit }) {
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const userAnswer = ref("");
    const imageError = ref(false);
    const imageTypingInput = ref(null);
    watch(() => props.imageAnswer, (newValue) => {
      userAnswer.value = newValue;
    });
    const stripDiacritics = (s) => s.replace(/[ưừứửữự]/g, "w").replace(/[ƯỪỨỬỮỰ]/g, "W").normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/đ/g, "d").replace(/Đ/g, "D");
    watch(userAnswer, (newValue) => {
      const sanitized = stripDiacritics(newValue);
      if (sanitized !== newValue) {
        userAnswer.value = sanitized;
      }
      emit("update:imageAnswer", sanitized);
    });
    watch(() => props.currentCard, () => {
      imageError.value = false;
    });
    const handleImageError = () => {
      imageError.value = true;
    };
    const checkAnswer = () => {
      if (!props.imageAnswered && userAnswer.value.trim()) {
        emit("checkAnswer");
        setTimeout(() => {
          isCorrectAnswer.value = props.imageCorrect;
          triggerFirework.value = true;
          triggerSound.value = true;
        }, 100);
      }
    };
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    watch(() => props.imageAnswered, (newValue) => {
      if (newValue && !triggerFirework.value) {
        isCorrectAnswer.value = props.imageCorrect;
        setTimeout(() => {
          triggerFirework.value = true;
          triggerSound.value = true;
        }, 50);
      }
    });
    onMounted(() => {
      try {
        const saved = localStorage.getItem(STORAGE_KEY_IMAGE_QUIZ);
        if (saved !== null) {
          const val = saved === "true";
          if (val !== props.imageQuizEnabled) {
            emit("update:imageQuizEnabled", val);
          }
        }
      } catch (e) {
      }
      ensureImageTypingFocus();
    });
    watch(() => props.imageQuizEnabled, (newVal) => {
      try {
        localStorage.setItem(STORAGE_KEY_IMAGE_QUIZ, String(newVal));
      } catch (e) {
      }
      if (!newVal) ensureImageTypingFocus();
    });
    const onSelectImageOption = (opt) => {
      if (!props.imageQuizAnswered) {
        emit("select-image-quiz-answer", opt);
      }
    };
    const isOptionSelected = (opt) => props.imageQuizSelected === opt;
    const isOptionCorrect = (opt) => props.currentCard ? opt.trim().toLowerCase() === props.currentCard.word.trim().toLowerCase() : false;
    const focusImageTypingInput = async () => {
      await nextTick();
      try {
        imageTypingInput.value?.focus({ preventScroll: true });
      } catch {
        imageTypingInput.value?.focus();
      }
    };
    const ensureImageTypingFocus = () => {
      if (!props.imageQuizEnabled && !props.imageAnswered) {
        if (document.activeElement !== imageTypingInput.value) {
          focusImageTypingInput();
        }
      }
    };
    const onImageTypingBlur = () => {
      ensureImageTypingFocus();
    };
    watch(() => props.imageAnswered, (answered) => {
      if (!answered) ensureImageTypingFocus();
    });
    watch(() => props.currentCard, () => {
      ensureImageTypingFocus();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-dark-bg-mute p-6 min-h-96 max-h-[500px] select-none",
        onCopy: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[3] || (_cache[3] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createBaseVNode("div", _hoisted_1$A, [
          createBaseVNode("div", _hoisted_2$x, [
            createBaseVNode("span", _hoisted_3$w, toDisplayString$1(_ctx.currentCard?.category ? unref(getTopicName)(_ctx.currentCard.category) : ""), 1)
          ]),
          createBaseVNode("div", _hoisted_4$u, [
            _ctx.currentCard?.image ? (openBlock(), createElementBlock("div", _hoisted_5$s, [
              createBaseVNode("img", {
                src: _ctx.currentCard.image,
                alt: unref(t)("flashcard.image.imageAlt", "Flashcard image"),
                class: "max-w-full max-h-40 object-contain rounded-lg shadow-md border border-gray-200 dark:border-dark-bg-mute",
                onError: handleImageError
              }, null, 40, _hoisted_6$q),
              imageError.value ? (openBlock(), createElementBlock("div", _hoisted_7$p, [
                createBaseVNode("div", _hoisted_8$p, [
                  _cache[4] || (_cache[4] = createBaseVNode("svg", {
                    class: "mx-auto h-12 w-12 text-gray-400 dark:text-white/50",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    stroke: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 16m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                    })
                  ], -1)),
                  createBaseVNode("p", _hoisted_9$o, toDisplayString$1(unref(t)("flashcard.image.imageError", "Could not load image.")), 1)
                ])
              ])) : createCommentVNode("", true)
            ])) : (openBlock(), createElementBlock("div", _hoisted_10$n, [
              createBaseVNode("div", _hoisted_11$n, [
                _cache[5] || (_cache[5] = createBaseVNode("svg", {
                  class: "mx-auto h-16 w-16 text-gray-400 dark:text-white/50",
                  fill: "none",
                  viewBox: "0 0 24 24",
                  stroke: "currentColor"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 16m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                  })
                ], -1)),
                createBaseVNode("p", _hoisted_12$m, toDisplayString$1(unref(t)("flashcard.image.noImage", "No image available for this card.")), 1)
              ])
            ]))
          ]),
          createBaseVNode("div", _hoisted_13$m, [
            !_ctx.imageQuizEnabled ? (openBlock(), createElementBlock("div", _hoisted_14$m, [
              withDirectives(createBaseVNode("input", {
                ref_key: "imageTypingInput",
                ref: imageTypingInput,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => userAnswer.value = $event),
                onKeyup: withKeys(checkAnswer, ["enter"]),
                type: "text",
                disabled: _ctx.imageAnswered,
                placeholder: unref(t)("flashcard.image.placeholder", "Enter your answer..."),
                class: "w-full px-4 py-3 text-center text-lg border border-gray-300 dark:border-dark-bg-mute rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-white/50 disabled:opacity-50 disabled:cursor-not-allowed select-text",
                inputmode: "text",
                autocapitalize: "none",
                autocomplete: "off",
                spellcheck: "false",
                onBlur: onImageTypingBlur
              }, null, 40, _hoisted_15$j), [
                [vModelText, userAnswer.value]
              ])
            ])) : (openBlock(), createElementBlock("div", _hoisted_16$j, [
              createBaseVNode("div", _hoisted_17$j, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.imageQuizOptions, (opt, idx) => {
                  return openBlock(), createElementBlock("button", {
                    key: idx,
                    onClick: ($event) => onSelectImageOption(opt),
                    disabled: _ctx.imageQuizAnswered,
                    translate: "no",
                    class: normalizeClass(["notranslate px-3 py-2 rounded-md border text-[13px] sm:text-sm transition-all duration-150 disabled:opacity-70 disabled:cursor-not-allowed text-left flex items-center gap-2 w-full max-w-[260px] sm:max-w-[240px]", [
                      _ctx.imageQuizAnswered ? isOptionCorrect(opt) ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300 border-green-300 dark:border-green-700" : isOptionSelected(opt) ? "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-300 border-red-300 dark:border-red-700" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60 hover:shadow-sm hover:scale-[1.01] dark:hover:bg-white/5"
                    ]])
                  }, [
                    createBaseVNode("span", _hoisted_19$i, toDisplayString$1(String.fromCharCode(65 + idx)), 1),
                    createBaseVNode("span", _hoisted_20$i, toDisplayString$1(opt), 1)
                  ], 10, _hoisted_18$i);
                }), 128))
              ])
            ])),
            _ctx.imageAnswered ? (openBlock(), createElementBlock("div", _hoisted_21$i, [
              createBaseVNode("div", {
                class: normalizeClass([
                  "inline-flex items-center px-3 py-1 rounded-full text-sm font-medium",
                  _ctx.imageCorrect ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300" : "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-300"
                ])
              }, [
                _ctx.imageCorrect ? (openBlock(), createElementBlock("svg", _hoisted_22$g, _cache[6] || (_cache[6] = [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                    "clip-rule": "evenodd"
                  }, null, -1)
                ]))) : (openBlock(), createElementBlock("svg", _hoisted_23$g, _cache[7] || (_cache[7] = [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                    "clip-rule": "evenodd"
                  }, null, -1)
                ]))),
                createTextVNode(" " + toDisplayString$1(_ctx.imageCorrect ? unref(t)("common.correct", "Correct") : unref(t)("common.incorrect", "Incorrect")), 1)
              ], 2),
              !_ctx.imageCorrect ? (openBlock(), createElementBlock("div", _hoisted_24$f, [
                createBaseVNode("p", _hoisted_25$f, [
                  createTextVNode(toDisplayString$1(unref(t)("flashcard.image.correctAnswer", "Correct answer")) + ": ", 1),
                  createBaseVNode("span", _hoisted_26$d, toDisplayString$1(_ctx.currentCard?.word), 1)
                ]),
                createBaseVNode("p", _hoisted_27$c, toDisplayString$1(_ctx.currentCard?.meaning), 1)
              ])) : (openBlock(), createElementBlock("div", _hoisted_28$c, [
                createBaseVNode("p", _hoisted_29$b, toDisplayString$1(_ctx.currentCard?.meaning), 1)
              ]))
            ])) : createCommentVNode("", true),
            !_ctx.imageAnswered && !_ctx.imageQuizEnabled ? (openBlock(), createElementBlock("p", _hoisted_30$a, toDisplayString$1(unref(t)("flashcard.image.instruction", "Type the word for the image above and press Enter.")), 1)) : createCommentVNode("", true),
            !_ctx.imageAnswered && _ctx.imageQuizEnabled ? (openBlock(), createElementBlock("p", _hoisted_31$a, toDisplayString$1(unref(t)("flashcard.image.instructionQuiz", "Choose the correct word for the image.")), 1)) : createCommentVNode("", true)
          ])
        ]),
        createVNode(unref(FireworkSoundEffect), {
          ref_key: "fireworkEffect",
          ref: fireworkEffect,
          "trigger-firework": triggerFirework.value,
          "trigger-sound": triggerSound.value,
          "is-correct": isCorrectAnswer.value,
          onEffectComplete: resetTriggers
        }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
      ], 32);
    };
  }
});

const FlashcardImage = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$A
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$z = { class: "flex justify-center items-center gap-2 sm:gap-3 md:gap-4 mt-4 sm:mt-6 md:mt-8" };
const _hoisted_2$w = ["title"];
const _hoisted_3$v = ["disabled", "title"];
const _hoisted_4$t = ["title"];
const _hoisted_5$r = ["title"];
const _hoisted_6$p = ["disabled", "title"];
const _hoisted_7$o = ["disabled"];
const _hoisted_8$o = ["title"];
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  __name: "FlashcardControls",
  props: {
    practiceMode: {},
    currentIndex: {},
    totalCards: {},
    canProceed: { type: Boolean },
    practiceStarted: { type: Boolean },
    scrambleWordsEnabled: { type: Boolean },
    typingAnswer: {},
    typingAnswered: { type: Boolean },
    listeningAnswer: {},
    listeningAnswered: { type: Boolean },
    imageAnswer: {},
    imageAnswered: { type: Boolean }
  },
  emits: ["mark-difficult", "mark-easy", "previous-card", "next-card", "exit-practice"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$z, [
        _ctx.practiceMode === "flashcard" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("mark-difficult")),
            class: "bg-red-500 hover:bg-red-600 text-white p-2 sm:p-3 md:p-4 rounded-full transition-colors",
            title: unref(t)("practice.controls.difficult", "Mark as difficult")
          }, _cache[8] || (_cache[8] = [
            createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                "clip-rule": "evenodd"
              })
            ], -1)
          ]), 8, _hoisted_2$w),
          createBaseVNode("button", {
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("previous-card")),
            disabled: _ctx.currentIndex === 0,
            class: "bg-gray-500 hover:bg-gray-600 disabled:bg-gray-300 dark:disabled:bg-gray-700 text-white p-2 sm:p-3 md:p-4 rounded-full transition-colors",
            title: unref(t)("practice.controls.previous", "Previous")
          }, _cache[9] || (_cache[9] = [
            createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                "clip-rule": "evenodd"
              })
            ], -1)
          ]), 8, _hoisted_3$v),
          createBaseVNode("button", {
            onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("next-card")),
            class: normalizeClass(["bg-blue-500 hover:bg-blue-600 text-white px-3 py-2 sm:px-4 sm:py-2 md:px-6 md:py-3 rounded-full font-medium transition-colors text-xs sm:text-sm md:text-base", _ctx.scrambleWordsEnabled ? "hidden md:inline-flex" : ""])
          }, toDisplayString$1(_ctx.currentIndex === _ctx.totalCards - 1 ? unref(t)("practice.controls.complete", "Complete") : unref(t)("practice.controls.next", "Next")), 3),
          createBaseVNode("button", {
            onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("mark-easy")),
            class: "bg-green-500 hover:bg-green-600 text-white p-2 sm:p-3 md:p-4 rounded-full transition-colors",
            title: unref(t)("practice.controls.easy", "Mark as easy")
          }, _cache[10] || (_cache[10] = [
            createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                "clip-rule": "evenodd"
              })
            ], -1)
          ]), 8, _hoisted_4$t),
          _ctx.practiceStarted ? (openBlock(), createElementBlock("button", {
            key: 0,
            onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("exit-practice")),
            class: "bg-red-600 hover:bg-red-700 text-white p-2 sm:p-3 md:p-4 rounded-full transition-colors ml-2 sm:ml-3 md:ml-4",
            title: unref(t)("practice.controls.exit", "Exit Practice")
          }, _cache[11] || (_cache[11] = [
            createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M3 3a1 1 0 00-1 1v12a1 1 0 102 0V4a1 1 0 00-1-1zm10.293 9.293a1 1 0 001.414 1.414l3-3a1 1 0 000-1.414l-3-3a1 1 0 10-1.414 1.414L14.586 9H7a1 1 0 100 2h7.586l-1.293 1.293z",
                "clip-rule": "evenodd"
              })
            ], -1)
          ]), 8, _hoisted_5$r)) : createCommentVNode("", true)
        ], 64)) : ["quiz", "typing", "listening", "image", "pronunciation", "pictionary", "flip-tile"].includes(_ctx.practiceMode) ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("button", {
            onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("previous-card")),
            disabled: _ctx.currentIndex === 0,
            class: "bg-gray-500 hover:bg-gray-600 disabled:bg-gray-300 dark:disabled:bg-gray-700 text-white p-2 sm:p-3 md:p-4 rounded-full transition-colors",
            title: unref(t)("practice.controls.previous", "Previous")
          }, _cache[12] || (_cache[12] = [
            createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                "clip-rule": "evenodd"
              })
            ], -1)
          ]), 8, _hoisted_6$p),
          createBaseVNode("button", {
            onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("next-card")),
            disabled: !_ctx.canProceed,
            class: normalizeClass(["bg-blue-500 hover:bg-blue-600 disabled:bg-gray-300 dark:disabled:bg-gray-700 text-white px-3 py-2 sm:px-4 sm:py-2 md:px-6 md:py-3 rounded-full font-medium transition-colors text-xs sm:text-sm md:text-base", ["quiz", "typing", "listening", "image", "pictionary", "flip-tile"].includes(_ctx.practiceMode) ? "hidden md:inline-flex" : ""])
          }, toDisplayString$1(_ctx.currentIndex === _ctx.totalCards - 1 ? unref(t)("practice.controls.complete", "Complete") : unref(t)("practice.controls.next", "Next")), 11, _hoisted_7$o),
          _ctx.practiceStarted ? (openBlock(), createElementBlock("button", {
            key: 0,
            onClick: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("exit-practice")),
            class: "bg-red-600 hover:bg-red-700 text-white p-2 sm:p-3 md:p-4 rounded-full transition-colors ml-2 sm:ml-3 md:ml-4",
            title: unref(t)("practice.controls.exit", "Exit Practice")
          }, _cache[13] || (_cache[13] = [
            createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M3 3a1 1 0 00-1 1v12a1 1 0 102 0V4a1 1 0 00-1-1zm10.293 9.293a1 1 0 001.414 1.414l3-3a1 1 0 000-1.414l-3-3a1 1 0 10-1.414 1.414L14.586 9H7a1 1 0 100 2h7.586l-1.293 1.293z",
                "clip-rule": "evenodd"
              })
            ], -1)
          ]), 8, _hoisted_8$o)) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true)
      ]);
    };
  }
});

const FlashcardControls = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$z
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$y = { class: "practice-timer" };
const _hoisted_2$v = {
  key: 0,
  class: "flex items-center justify-center gap-1 sm:gap-2 md:gap-3 mb-3 sm:mb-4 md:mb-5"
};
const _hoisted_3$u = { class: "font-mono font-bold text-sm sm:text-base md:text-lg" };
const _hoisted_4$s = {
  key: 1,
  class: "text-center mb-4 sm:mb-5 md:mb-6"
};
const _hoisted_5$q = { class: "text-xs sm:text-sm md:text-base text-gray-500 dark:text-gray-400 mt-2" };
const _hoisted_6$o = {
  key: 0,
  class: "timeout-modal-overlay",
  style: { "position": "fixed !important", "top": "0 !important", "left": "0 !important", "right": "0 !important", "bottom": "0 !important", "z-index": "99999 !important", "background": "rgba(0,0,0,0.5) !important", "display": "flex !important", "align-items": "center !important", "justify-content": "center !important", "padding": "12px !important" }
};
const _hoisted_7$n = {
  style: { "position": "relative !important", "z-index": "100000 !important" },
  class: "timeout-modal-content flex items-center justify-center z-[9999] p-3 sm:p-4 md:p-6"
};
const _hoisted_8$n = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl p-4 sm:p-6 md:p-8 max-w-xs sm:max-w-sm md:max-w-md mx-auto text-center w-full" };
const _hoisted_9$n = { class: "text-lg sm:text-xl md:text-2xl font-bold text-gray-900 dark:text-white mb-2 sm:mb-3 md:mb-4" };
const _hoisted_10$m = { class: "text-sm sm:text-base md:text-lg text-gray-600 dark:text-gray-300 mb-4 sm:mb-5 md:mb-6 leading-relaxed" };
const _hoisted_11$m = { class: "flex gap-2 sm:gap-3 md:gap-4" };
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "PracticeTimer",
  props: {
    maxTime: { default: 30 },
    autoStart: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false }
  },
  emits: ["start", "timeout", "tick", "restart", "skip"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const timeLimitText = computed(() => {
      const translated = t("practice.timer.timeLimit", { seconds: props.maxTime });
      if (translated === "practice.timer.timeLimit") {
        return `Time limit: ${props.maxTime} seconds`;
      }
      return translated;
    });
    const remainingTime = ref(props.maxTime);
    const isActive = ref(false);
    const hasStarted = ref(false);
    const showTimeoutModal = ref(false);
    let timerId = null;
    computed(() => isActive.value && remainingTime.value > 0);
    const startPractice = () => {
      hasStarted.value = true;
      startTimer();
      emit("start");
    };
    const startTimer = () => {
      if (props.disabled) return;
      isActive.value = true;
      remainingTime.value = props.maxTime;
      timerId = setInterval(() => {
        if (remainingTime.value > 0) {
          remainingTime.value--;
          emit("tick", remainingTime.value);
        } else {
          handleTimeout();
        }
      }, 1e3);
    };
    const stopTimer = () => {
      if (timerId) {
        clearInterval(timerId);
        timerId = null;
      }
    };
    const resetTimer = () => {
      stopTimer();
      remainingTime.value = props.maxTime;
    };
    const handleTimeout = () => {
      stopTimer();
      showTimeoutModal.value = true;
      emit("timeout");
    };
    const restartPractice = () => {
      showTimeoutModal.value = false;
      resetTimer();
      startTimer();
      emit("restart");
    };
    const skipCard = () => {
      showTimeoutModal.value = false;
      stopTimer();
      isActive.value = false;
      emit("skip");
    };
    const nextCard = () => {
      if (hasStarted.value) {
        resetTimer();
        startTimer();
      }
    };
    const resetPractice = () => {
      stopTimer();
      isActive.value = false;
      hasStarted.value = false;
      remainingTime.value = props.maxTime;
      showTimeoutModal.value = false;
    };
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
    };
    const getTimerClass = () => {
      if (remainingTime.value <= 5) return "timer-critical";
      if (remainingTime.value <= 10) return "timer-warning";
      return "timer-normal";
    };
    watch(() => props.disabled, (disabled) => {
      if (disabled) {
        stopTimer();
      }
    });
    watch(() => props.autoStart, (autoStart) => {
      if (autoStart && !hasStarted.value) {
        startPractice();
      }
    });
    watch(showTimeoutModal, (visible) => {
      if (visible) {
        document.body.classList.add("modal-open");
      } else {
        document.body.classList.remove("modal-open");
      }
    });
    onUnmounted(() => {
      stopTimer();
    });
    __expose({
      startTimer,
      stopTimer,
      resetTimer,
      nextCard,
      hasStarted,
      resetPractice
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$y, [
        isActive.value ? (openBlock(), createElementBlock("div", _hoisted_2$v, [
          createBaseVNode("div", {
            class: normalizeClass(["timer-display", getTimerClass()])
          }, [
            _cache[0] || (_cache[0] = createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z",
                "clip-rule": "evenodd"
              })
            ], -1)),
            createBaseVNode("span", _hoisted_3$u, toDisplayString$1(formatTime(remainingTime.value)), 1)
          ], 2)
        ])) : createCommentVNode("", true),
        !hasStarted.value ? (openBlock(), createElementBlock("div", _hoisted_4$s, [
          createBaseVNode("button", {
            onClick: startPractice,
            class: "bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 sm:px-6 sm:py-3 md:px-8 md:py-4 rounded-lg sm:rounded-xl md:rounded-2xl font-semibold text-sm sm:text-base md:text-lg transition-colors shadow-lg hover:shadow-xl"
          }, [
            _cache[1] || (_cache[1] = createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6 inline-block mr-1 sm:mr-2 md:mr-3",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z",
                "clip-rule": "evenodd"
              })
            ], -1)),
            createTextVNode(" " + toDisplayString$1(unref(t)("practice.timer.startPractice", "Start Practice")), 1)
          ]),
          createBaseVNode("div", _hoisted_5$q, toDisplayString$1(timeLimitText.value), 1)
        ])) : createCommentVNode("", true),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          showTimeoutModal.value ? (openBlock(), createElementBlock("div", _hoisted_6$o, [
            createBaseVNode("div", _hoisted_7$n, [
              createBaseVNode("div", _hoisted_8$n, [
                _cache[2] || (_cache[2] = createBaseVNode("div", { class: "text-red-500 mb-3 sm:mb-4 md:mb-5" }, [
                  createBaseVNode("svg", {
                    class: "w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 mx-auto",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z",
                      "clip-rule": "evenodd"
                    })
                  ])
                ], -1)),
                createBaseVNode("h3", _hoisted_9$n, toDisplayString$1(unref(t)("practice.timer.timeUp", "Time is up!")), 1),
                createBaseVNode("p", _hoisted_10$m, toDisplayString$1(unref(t)("practice.timer.timeUpMessage", "Your time is up. Would you like to try again or skip this card?")), 1),
                createBaseVNode("div", _hoisted_11$m, [
                  createBaseVNode("button", {
                    onClick: restartPractice,
                    class: "flex-1 bg-blue-500 hover:bg-blue-600 text-white px-3 py-2 sm:px-4 sm:py-2 md:px-5 md:py-3 rounded-lg font-medium transition-colors text-xs sm:text-sm md:text-base"
                  }, toDisplayString$1(unref(t)("practice.timer.tryAgain", "Try Again")), 1),
                  createBaseVNode("button", {
                    onClick: skipCard,
                    class: "flex-1 bg-gray-500 hover:bg-gray-600 text-white px-3 py-2 sm:px-4 sm:py-2 md:px-5 md:py-3 rounded-lg font-medium transition-colors text-xs sm:text-sm md:text-base"
                  }, toDisplayString$1(unref(t)("practice.timer.skip", "Skip")), 1)
                ])
              ])
            ])
          ])) : createCommentVNode("", true)
        ]))
      ]);
    };
  }
});

const PracticeTimer = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__scopeId", "data-v-1d84fe0e"]]);

const PracticeTimer$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: PracticeTimer
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$x = {
  key: 0,
  class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
};
const _hoisted_2$u = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl p-8 max-w-md mx-4 text-center" };
const _hoisted_3$t = { class: "text-lg sm:text-xl font-bold text-gray-900 dark:text-white mb-2" };
const _hoisted_4$r = { class: "text-sm sm:text-base text-gray-600 dark:text-white/80 mb-6" };
const _hoisted_5$p = { class: "flex gap-2 sm:gap-3" };
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "ExitWarningModal",
  props: {
    show: { type: Boolean }
  },
  emits: ["continue", "confirm"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$x, [
        createBaseVNode("div", _hoisted_2$u, [
          _cache[2] || (_cache[2] = createBaseVNode("div", { class: "text-orange-500 mb-4" }, [
            createBaseVNode("svg", {
              class: "w-16 h-16 mx-auto",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z",
                "clip-rule": "evenodd"
              })
            ])
          ], -1)),
          createBaseVNode("h3", _hoisted_3$t, toDisplayString$1(unref(t)("practice.exitWarning.title", "Leave Practice?")), 1),
          createBaseVNode("p", _hoisted_4$r, toDisplayString$1(unref(t)("practice.exitWarning.message", "Are you sure you want to leave? Your progress will be lost.")), 1),
          createBaseVNode("div", _hoisted_5$p, [
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => emit("continue")),
              class: "flex-1 bg-blue-500 hover:bg-blue-600 text-white px-2 sm:px-4 py-2 rounded-lg text-sm sm:text-base font-medium transition-colors"
            }, toDisplayString$1(unref(t)("practice.exitWarning.continue", "Stay")), 1),
            createBaseVNode("button", {
              onClick: _cache[1] || (_cache[1] = ($event) => emit("confirm")),
              class: "flex-1 bg-red-500 hover:bg-red-600 text-white px-2 sm:px-4 py-2 rounded-lg text-sm sm:text-base font-medium transition-colors"
            }, toDisplayString$1(unref(t)("practice.exitWarning.exit", "Leave")), 1)
          ])
        ])
      ])) : createCommentVNode("", true);
    };
  }
});

const ExitWarningModal = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$x
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$w = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-green-50 to-emerald-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_2$t = { class: "flex items-center justify-between" };
const _hoisted_3$s = { class: "text-lg sm:text-xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_4$q = { class: "px-6 py-6" };
const _hoisted_5$o = {
  class: "text-center mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_6$n = { class: "text-gray-600 dark:text-gray-300" };
const _hoisted_7$m = { class: "grid grid-cols-1 gap-4 mb-6" };
const _hoisted_8$m = {
  class: "bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-4 animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_9$m = { class: "flex items-center justify-between" };
const _hoisted_10$l = { class: "flex items-center space-x-2" };
const _hoisted_11$l = { class: "font-medium text-green-700 dark:text-green-300" };
const _hoisted_12$l = { class: "text-2xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_13$l = {
  class: "bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4 animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_14$l = { class: "flex items-center justify-between" };
const _hoisted_15$i = { class: "flex items-center space-x-2" };
const _hoisted_16$i = { class: "font-medium text-red-700 dark:text-red-300" };
const _hoisted_17$i = { class: "text-2xl font-bold text-red-600 dark:text-red-400" };
const _hoisted_18$h = {
  class: "bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4 animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_19$h = { class: "flex items-center justify-between mb-2" };
const _hoisted_20$h = { class: "flex items-center space-x-2" };
const _hoisted_21$h = { class: "font-medium text-blue-700 dark:text-blue-300" };
const _hoisted_22$f = { class: "text-2xl font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_23$f = { class: "flex items-center justify-between" };
const _hoisted_24$e = { class: "font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_25$e = { class: "space-y-3" };
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "CompletionModal",
  props: {
    show: { type: Boolean },
    stats: {},
    cardCount: {}
  },
  emits: ["restart", "go-back"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        "enter-active-class": "transition-all duration-500 ease-out",
        "enter-from-class": "opacity-0",
        "enter-to-class": "opacity-100",
        "leave-active-class": "transition-all duration-300 ease-in",
        "leave-from-class": "opacity-100",
        "leave-to-class": "opacity-0"
      }, {
        default: withCtx(() => [
          _ctx.show ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm",
            onWheel: _cache[4] || (_cache[4] = withModifiers(() => {
            }, ["prevent"])),
            onTouchmove: _cache[5] || (_cache[5] = withModifiers(() => {
            }, ["prevent"]))
          }, [
            createVNode(Transition, {
              "enter-active-class": "transition-all duration-500 ease-out",
              "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
              "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
              "leave-active-class": "transition-all duration-300 ease-in",
              "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
              "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
            }, {
              default: withCtx(() => [
                _ctx.show ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: "w-full max-w-md sm:max-w-lg bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 overflow-hidden transform",
                  onClick: _cache[3] || (_cache[3] = withModifiers(() => {
                  }, ["stop"]))
                }, [
                  createBaseVNode("div", _hoisted_1$w, [
                    createBaseVNode("div", _hoisted_2$t, [
                      createBaseVNode("h2", _hoisted_3$s, [
                        _cache[6] || (_cache[6] = createBaseVNode("span", { class: "w-2 h-2 bg-green-500 rounded-full animate-pulse" }, null, -1)),
                        createBaseVNode("span", null, toDisplayString$1(unref(t)("flashcard.completion.title", "Completed!")), 1)
                      ]),
                      createBaseVNode("button", {
                        onClick: _cache[0] || (_cache[0] = ($event) => emit("go-back")),
                        class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                      }, _cache[7] || (_cache[7] = [
                        createBaseVNode("svg", {
                          class: "w-6 h-6",
                          fill: "none",
                          stroke: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          createBaseVNode("path", {
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            "stroke-width": "2",
                            d: "M6 18L18 6M6 6l12 12"
                          })
                        ], -1)
                      ]))
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_4$q, [
                    _cache[11] || (_cache[11] = createBaseVNode("div", {
                      class: "flex justify-center mb-6 animate-fade-in-up",
                      style: { "animation-delay": "0.1s" }
                    }, [
                      createBaseVNode("div", { class: "flex items-center justify-center h-16 w-16 rounded-full bg-green-100 dark:bg-green-900 shadow-lg transform hover:scale-110 transition-all duration-300" }, [
                        createBaseVNode("svg", {
                          class: "h-8 w-8 text-green-600 dark:text-green-400",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                            "clip-rule": "evenodd"
                          })
                        ])
                      ])
                    ], -1)),
                    createBaseVNode("div", _hoisted_5$o, [
                      createBaseVNode("p", _hoisted_6$n, toDisplayString$1(unref(t)("flashcard.completion.description", { count: _ctx.cardCount }, `You have completed ${_ctx.cardCount} flashcards.`)), 1)
                    ]),
                    createBaseVNode("div", _hoisted_7$m, [
                      createBaseVNode("div", _hoisted_8$m, [
                        createBaseVNode("div", _hoisted_9$m, [
                          createBaseVNode("div", _hoisted_10$l, [
                            _cache[8] || (_cache[8] = createBaseVNode("span", { class: "w-2 h-2 bg-green-500 rounded-full" }, null, -1)),
                            createBaseVNode("span", _hoisted_11$l, toDisplayString$1(unref(t)("flashcard.completion.correct", "Correct")), 1)
                          ]),
                          createBaseVNode("span", _hoisted_12$l, toDisplayString$1(_ctx.stats.correct), 1)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_13$l, [
                        createBaseVNode("div", _hoisted_14$l, [
                          createBaseVNode("div", _hoisted_15$i, [
                            _cache[9] || (_cache[9] = createBaseVNode("span", { class: "w-2 h-2 bg-red-500 rounded-full" }, null, -1)),
                            createBaseVNode("span", _hoisted_16$i, toDisplayString$1(unref(t)("flashcard.completion.incorrect", "Incorrect")), 1)
                          ]),
                          createBaseVNode("span", _hoisted_17$i, toDisplayString$1(_ctx.stats.incorrect), 1)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_18$h, [
                        createBaseVNode("div", _hoisted_19$h, [
                          createBaseVNode("div", _hoisted_20$h, [
                            _cache[10] || (_cache[10] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full" }, null, -1)),
                            createBaseVNode("span", _hoisted_21$h, toDisplayString$1(unref(t)("flashcard.completion.accuracy", "Accuracy")), 1)
                          ]),
                          createBaseVNode("span", _hoisted_22$f, toDisplayString$1(_ctx.stats.correct + _ctx.stats.incorrect > 0 ? Math.round(_ctx.stats.correct / (_ctx.stats.correct + _ctx.stats.incorrect) * 100) : 0) + "%", 1)
                        ]),
                        createBaseVNode("div", _hoisted_23$f, [
                          createBaseVNode("span", _hoisted_24$e, toDisplayString$1(unref(t)("flashcard.completion.result", "Result")) + ":", 1),
                          createBaseVNode("span", {
                            class: normalizeClass(["px-3 py-1 text-sm font-medium rounded-full transition-all duration-300 hover:scale-105", _ctx.stats.correct + _ctx.stats.incorrect > 0 && Math.round(_ctx.stats.correct / (_ctx.stats.correct + _ctx.stats.incorrect) * 100) >= 70 ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 shadow-green-200 dark:shadow-green-900" : "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200 shadow-red-200 dark:shadow-red-900"])
                          }, toDisplayString$1(_ctx.stats.correct + _ctx.stats.incorrect > 0 && Math.round(_ctx.stats.correct / (_ctx.stats.correct + _ctx.stats.incorrect) * 100) >= 70 ? unref(t)("flashcard.history.pass", "Pass") : unref(t)("flashcard.history.fail", "Fail")), 3)
                        ])
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_25$e, [
                      createBaseVNode("button", {
                        onClick: _cache[1] || (_cache[1] = ($event) => emit("restart")),
                        class: "w-full px-6 py-3 bg-blue-500 hover:bg-blue-600 text-white font-medium rounded-lg shadow-md transition-all duration-300 hover:scale-105 hover:shadow-lg transform hover:-translate-y-0.5 active:scale-95 animate-fade-in-up",
                        style: { "animation-delay": "0.6s" }
                      }, toDisplayString$1(unref(t)("common.restart", "Practice Again")), 1),
                      createBaseVNode("button", {
                        onClick: _cache[2] || (_cache[2] = ($event) => emit("go-back")),
                        class: "w-full px-6 py-3 bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 font-medium rounded-lg shadow-md transition-all duration-300 hover:scale-105 hover:shadow-lg transform hover:-translate-y-0.5 active:scale-95 animate-fade-in-up",
                        style: { "animation-delay": "0.7s" }
                      }, toDisplayString$1(unref(t)("common.back", "Back")), 1)
                    ])
                  ])
                ])) : createCommentVNode("", true)
              ]),
              _: 1
            })
          ], 32)) : createCommentVNode("", true)
        ]),
        _: 1
      });
    };
  }
});

const CompletionModal = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__scopeId", "data-v-8ac791bd"]]);

const CompletionModal$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: CompletionModal
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$v = {
  key: 0,
  class: "fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$s = { class: "w-full max-w-4xl max-h-[80vh]" };
const _hoisted_3$r = { class: "px-6 py-4 border-b border-gray-200 dark:border-dark-bg-mute flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] rounded-t-xl" };
const _hoisted_4$p = { class: "flex items-center justify-between" };
const _hoisted_5$n = { class: "text-xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$m = ["aria-label"];
const _hoisted_7$l = { class: "px-6 py-4 flex-1 overflow-y-auto min-h-0" };
const _hoisted_8$l = {
  key: 0,
  class: "text-center py-8"
};
const _hoisted_9$l = { class: "mt-2 text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_10$k = { class: "mt-1 text-sm text-gray-500 dark:text-white/70" };
const _hoisted_11$k = {
  key: 1,
  class: "space-y-4"
};
const _hoisted_12$k = { class: "flex justify-between items-start" };
const _hoisted_13$k = { class: "flex-1" };
const _hoisted_14$k = { class: "flex items-center space-x-2 mb-2" };
const _hoisted_15$h = { class: "text-sm text-gray-500 dark:text-white/70" };
const _hoisted_16$h = ["aria-disabled", "title", "aria-label", "onClick"];
const _hoisted_17$h = ["title", "aria-label", "onClick"];
const _hoisted_18$g = { class: "grid grid-cols-2 md:grid-cols-4 gap-4 text-sm" };
const _hoisted_19$g = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_20$g = { class: "ml-1 font-medium text-gray-900 dark:text-white" };
const _hoisted_21$g = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_22$e = { class: "ml-1 font-medium text-green-600 dark:text-green-400" };
const _hoisted_23$e = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_24$d = { class: "ml-1 font-medium text-red-600 dark:text-red-400" };
const _hoisted_25$d = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_26$c = { class: "ml-1 font-medium text-gray-900 dark:text-white" };
const _hoisted_27$b = { class: "mt-2" };
const _hoisted_28$b = { class: "text-gray-500 dark:text-white/70 text-sm" };
const _hoisted_29$a = { class: "flex flex-wrap gap-1 mt-1" };
const _hoisted_30$9 = { class: "text-right" };
const _hoisted_31$9 = { class: "text-lg font-bold text-gray-900 dark:text-white" };
const _hoisted_32$8 = { class: "text-xs text-gray-500 dark:text-white/70" };
const _hoisted_33$8 = { class: "mt-1" };
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "HistoryModal",
  props: {
    show: { type: Boolean },
    history: {},
    getModeColor: { type: Function },
    getModeText: { type: Function },
    formatDate: { type: Function },
    formatDuration: { type: Function },
    deleteSession: { type: Function }
  },
  emits: ["close", "open-details", "delete-session"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const { t } = useI18n();
    const hasSessionDetails = (sessionId, flag) => {
      if (flag) return true;
      try {
        return !!localStorage.getItem(`flashcard-session-details:${sessionId}`);
      } catch {
        return false;
      }
    };
    const getCategoryDisplay = (category) => {
      if (category.includes(".")) {
        const parts = category.split(".");
        const fallback = parts[parts.length - 1];
        if (category === "flashcard.modes.flashcard") return t(category, "Flashcard");
        if (category === "flashcard.modes.quiz") return t(category, "Quiz");
        if (category === "flashcard.modes.typing") return t(category, "Typing");
        if (category === "flashcard.modes.listening") return t(category, "Listening");
        if (category === "flashcard.modes.image") return t(category, "Image");
        if (category === "flashcard.modes.pronunciation") return t(category, "Pronunciation");
        return t(category, fallback.charAt(0).toUpperCase() + fallback.slice(1));
      }
      return category;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$v, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$s, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-dark-bg-mute flex flex-col max-h-[80vh] transform",
                      onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$r, [
                        createBaseVNode("div", _hoisted_4$p, [
                          createBaseVNode("h3", _hoisted_5$n, [
                            _cache[2] || (_cache[2] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("flashcard.history.title", "Practice History")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: _cache[0] || (_cache[0] = ($event) => emit("close")),
                            "aria-label": unref(t)("common.close", "Close"),
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-white/80 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-dark-bg-soft"
                          }, _cache[3] || (_cache[3] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]), 8, _hoisted_6$m)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_7$l, [
                        _ctx.history.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_8$l, [
                          _cache[4] || (_cache[4] = createBaseVNode("svg", {
                            class: "mx-auto h-12 w-12 text-gray-400 dark:text-white/40",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            stroke: "currentColor"
                          }, [
                            createBaseVNode("path", {
                              "stroke-linecap": "round",
                              "stroke-linejoin": "round",
                              "stroke-width": "2",
                              d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                            })
                          ], -1)),
                          createBaseVNode("h3", _hoisted_9$l, toDisplayString$1(unref(t)("flashcard.history.empty.title", "No History Yet")), 1),
                          createBaseVNode("p", _hoisted_10$k, toDisplayString$1(unref(t)("flashcard.history.empty.description", "Complete a practice session to see your history here.")), 1)
                        ])) : (openBlock(), createElementBlock("div", _hoisted_11$k, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.history, (session) => {
                            return openBlock(), createElementBlock("div", {
                              key: session.id,
                              class: "bg-gray-50 dark:bg-dark-bg-mute rounded-lg p-4"
                            }, [
                              createBaseVNode("div", _hoisted_12$k, [
                                createBaseVNode("div", _hoisted_13$k, [
                                  createBaseVNode("div", _hoisted_14$k, [
                                    createBaseVNode("span", {
                                      class: normalizeClass(["px-2 py-1 text-xs font-medium rounded-full", _ctx.getModeColor(session.mode)])
                                    }, toDisplayString$1(_ctx.getModeText(session.mode)), 3),
                                    createBaseVNode("span", _hoisted_15$h, toDisplayString$1(_ctx.formatDate(session.date)), 1),
                                    createBaseVNode("button", {
                                      class: normalizeClass(["inline-flex items-center ml-1 px-2 py-1 rounded-md border border-blue-200 bg-blue-50 text-blue-600 hover:bg-blue-100 hover:text-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400/50 transition dark:text-blue-300 dark:bg-blue-900/30 dark:border-blue-800 dark:hover:bg-blue-900/40 dark:hover:text-blue-200", !hasSessionDetails(session.id, session.hasDetails) ? "opacity-50" : ""]),
                                      "aria-disabled": !hasSessionDetails(session.id, session.hasDetails),
                                      title: hasSessionDetails(session.id, session.hasDetails) ? unref(t)("flashcard.history.viewDetails", "View details") : unref(t)("flashcard.history.noDetails", "No details available"),
                                      "aria-label": unref(t)("flashcard.history.viewDetails", "View details"),
                                      onClick: ($event) => emit("open-details", session.id)
                                    }, _cache[5] || (_cache[5] = [
                                      createBaseVNode("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        class: "h-4 w-4",
                                        viewBox: "0 0 24 24",
                                        fill: "currentColor"
                                      }, [
                                        createBaseVNode("path", { d: "M12 5c-7.633 0-10 7-10 7s2.367 7 10 7 10-7 10-7-2.367-7-10-7Zm0 12a5 5 0 1 1 0-10 5 5 0 0 1 0 10Zm0-2a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" })
                                      ], -1)
                                    ]), 10, _hoisted_16$h),
                                    createBaseVNode("button", {
                                      class: "inline-flex items-center ml-1 px-2 py-1 rounded-md border border-red-200 bg-red-50 text-red-600 hover:bg-red-100 hover:text-red-700 focus:outline-none focus:ring-2 focus:ring-red-400/50 transition dark:text-red-300 dark:bg-red-900/30 dark:border-red-800 dark:hover:bg-red-900/40 dark:hover:text-red-200",
                                      title: unref(t)("flashcard.history.deleteSession", "Delete session"),
                                      "aria-label": unref(t)("flashcard.history.deleteSession", "Delete session"),
                                      onClick: ($event) => emit("delete-session", session.id)
                                    }, _cache[6] || (_cache[6] = [
                                      createBaseVNode("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        class: "h-4 w-4",
                                        viewBox: "0 0 24 24",
                                        fill: "currentColor"
                                      }, [
                                        createBaseVNode("path", { d: "M3 6h18m-2 0v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6m3 0V4c0-1 1-2 2-2h4c0-1 1-2 2-2v2m-6 5v6m4-6v6" })
                                      ], -1)
                                    ]), 8, _hoisted_17$h)
                                  ]),
                                  createBaseVNode("div", _hoisted_18$g, [
                                    createBaseVNode("div", null, [
                                      createBaseVNode("span", _hoisted_19$g, toDisplayString$1(unref(t)("flashcard.history.totalCards", "Total Cards")) + ":", 1),
                                      createBaseVNode("span", _hoisted_20$g, toDisplayString$1(session.totalCards), 1)
                                    ]),
                                    createBaseVNode("div", null, [
                                      createBaseVNode("span", _hoisted_21$g, toDisplayString$1(unref(t)("flashcard.history.correct", "Correct")) + ":", 1),
                                      createBaseVNode("span", _hoisted_22$e, toDisplayString$1(session.correctAnswers), 1)
                                    ]),
                                    createBaseVNode("div", null, [
                                      createBaseVNode("span", _hoisted_23$e, toDisplayString$1(unref(t)("flashcard.history.incorrect", "Incorrect")) + ":", 1),
                                      createBaseVNode("span", _hoisted_24$d, toDisplayString$1(session.incorrectAnswers), 1)
                                    ]),
                                    createBaseVNode("div", null, [
                                      createBaseVNode("span", _hoisted_25$d, toDisplayString$1(unref(t)("flashcard.history.duration", "Duration")) + ":", 1),
                                      createBaseVNode("span", _hoisted_26$c, toDisplayString$1(_ctx.formatDuration(session.duration)), 1)
                                    ])
                                  ]),
                                  createBaseVNode("div", _hoisted_27$b, [
                                    createBaseVNode("span", _hoisted_28$b, toDisplayString$1(unref(t)("flashcard.history.categories", "Categories")) + ":", 1),
                                    createBaseVNode("div", _hoisted_29$a, [
                                      (openBlock(true), createElementBlock(Fragment, null, renderList(session.categories, (category) => {
                                        return openBlock(), createElementBlock("span", {
                                          key: category,
                                          class: "px-2 py-1 text-xs bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 rounded"
                                        }, toDisplayString$1(getCategoryDisplay(category)), 1);
                                      }), 128))
                                    ])
                                  ])
                                ]),
                                createBaseVNode("div", _hoisted_30$9, [
                                  createBaseVNode("div", _hoisted_31$9, toDisplayString$1(Math.round(session.correctAnswers / session.totalCards * 100)) + "% ", 1),
                                  createBaseVNode("div", _hoisted_32$8, toDisplayString$1(unref(t)("flashcard.history.accuracy", "Accuracy")), 1),
                                  createBaseVNode("div", _hoisted_33$8, [
                                    createBaseVNode("span", {
                                      class: normalizeClass(["text-xs font-medium px-2 py-0.5 rounded-full", Math.round(session.correctAnswers / session.totalCards * 100) >= 70 ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" : "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200"])
                                    }, toDisplayString$1(Math.round(session.correctAnswers / session.totalCards * 100) >= 70 ? unref(t)("flashcard.history.pass", "Pass") : unref(t)("flashcard.history.fail", "Fail")), 3)
                                  ])
                                ])
                              ])
                            ]);
                          }), 128))
                        ]))
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const HistoryModal = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$v
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$u = {
  key: 0,
  class: "fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-[60] backdrop-blur-sm"
};
const _hoisted_2$r = { class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-dark-bg-mute flex flex-col max-h-[82vh]" };
const _hoisted_3$q = { class: "px-6 py-4 border-b border-gray-200 dark:border-dark-bg-mute flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] rounded-t-xl" };
const _hoisted_4$o = { class: "flex items-center justify-between" };
const _hoisted_5$m = { class: "text-lg md:text-xl font-semibold text-gray-900 dark:text-white flex items-center gap-2" };
const _hoisted_6$l = ["aria-label"];
const _hoisted_7$k = { class: "px-4 md:px-6 py-4 flex-1 overflow-y-auto min-h-0" };
const _hoisted_8$k = {
  key: 0,
  class: "text-center py-10"
};
const _hoisted_9$k = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_10$j = {
  key: 1,
  class: "space-y-4"
};
const _hoisted_11$j = { class: "grid grid-cols-2 md:grid-cols-4 gap-3 text-sm" };
const _hoisted_12$j = { class: "bg-blue-50 dark:bg-blue-900/30 rounded-lg p-3" };
const _hoisted_13$j = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_14$j = { class: "text-gray-900 dark:text-white font-semibold" };
const _hoisted_15$g = { class: "bg-green-50 dark:bg-green-900/30 rounded-lg p-3" };
const _hoisted_16$g = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_17$g = { class: "text-green-700 dark:text-green-400 font-semibold" };
const _hoisted_18$f = { class: "bg-red-50 dark:bg-red-900/30 rounded-lg p-3" };
const _hoisted_19$f = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_20$f = { class: "text-red-700 dark:text-red-400 font-semibold" };
const _hoisted_21$f = { class: "bg-indigo-50 dark:bg-indigo-900/30 rounded-lg p-3" };
const _hoisted_22$d = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_23$d = { class: "text-indigo-700 dark:text-indigo-300 font-semibold" };
const _hoisted_24$c = { class: "divide-y divide-gray-200 dark:divide-dark-bg-mute rounded-lg overflow-hidden border border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_25$c = { class: "flex items-start justify-between gap-3" };
const _hoisted_26$b = { class: "min-w-0" };
const _hoisted_27$a = { class: "flex items-center gap-2" };
const _hoisted_28$a = { class: "text-sm font-semibold text-gray-900 dark:text-white truncate" };
const _hoisted_29$9 = { class: "text-xs text-gray-500 dark:text-white/70 truncate" };
const _hoisted_30$8 = { class: "mt-1 text-sm" };
const _hoisted_31$8 = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_32$7 = { class: "text-sm text-gray-500 dark:text-white/70" };
const _hoisted_33$7 = { class: "ml-1 text-gray-900 dark:text-white" };
const _hoisted_34$7 = {
  key: 0,
  class: "mt-3 space-y-2"
};
const _hoisted_35$7 = ["onClick"];
const _hoisted_36$6 = ["src", "alt"];
const _hoisted_37$5 = ["onClick"];
const _hoisted_38$5 = { class: "uppercase tracking-wider" };
const _hoisted_39$4 = {
  key: 1,
  class: "mt-3 space-y-3"
};
const _hoisted_40$4 = { class: "bg-gradient-to-r from-emerald-50 to-green-50 dark:from-emerald-900/20 dark:to-green-900/20 rounded-lg border border-emerald-200 dark:border-emerald-800/50 p-3 animate-fade-in-up" };
const _hoisted_41$3 = { class: "flex items-center gap-3" };
const _hoisted_42$3 = { class: "flex-shrink-0" };
const _hoisted_43$3 = {
  key: 0,
  class: "w-6 h-6 text-emerald-600 dark:text-emerald-400 animate-bounce",
  fill: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_44$3 = {
  key: 1,
  class: "w-6 h-6 text-red-600 dark:text-red-400 animate-ping",
  fill: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_45$2 = { class: "flex-1 min-w-0" };
const _hoisted_46$2 = { class: "flex items-center gap-2" };
const _hoisted_47$2 = { class: "text-xs text-gray-500 dark:text-white/70 mt-1" };
const _hoisted_48$2 = { class: "grid grid-cols-2 md:grid-cols-4 gap-3 mt-3 text-xs" };
const _hoisted_49$2 = { class: "bg-white dark:bg-[#0a0a0a] rounded-md p-2 border border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_50$2 = { class: "font-semibold text-gray-900 dark:text-white animate-counter" };
const _hoisted_51$1 = { class: "bg-white dark:bg-[#0a0a0a] rounded-md p-2 border border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_52$1 = { class: "font-semibold text-emerald-600 dark:text-emerald-400 animate-counter" };
const _hoisted_53$1 = { class: "bg-white dark:bg-[#0a0a0a] rounded-md p-2 border border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_54$1 = { class: "font-semibold text-blue-600 dark:text-blue-400 animate-counter" };
const _hoisted_55$1 = { class: "bg-white dark:bg-[#0a0a0a] rounded-md p-2 border border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_56$1 = { class: "font-semibold text-red-600 dark:text-red-400 animate-counter" };
const _hoisted_57$1 = { class: "mt-3" };
const _hoisted_58$1 = { class: "mt-2 text-xs text-gray-500 dark:text-white/70 flex items-center gap-4" };
const _hoisted_59$1 = { key: 0 };
const _hoisted_60$1 = {
  key: 2,
  class: "text-xs text-gray-500 dark:text-white/70 mt-1"
};
const _hoisted_61$1 = { class: "flex items-center gap-2" };
const _hoisted_62$1 = {
  key: 0,
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  class: "w-4 h-4",
  fill: "currentColor"
};
const _hoisted_63$1 = {
  key: 1,
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  class: "w-4 h-4",
  fill: "currentColor"
};
const _hoisted_64$1 = { class: "text-xs text-gray-500 dark:text-white/70" };
const _hoisted_65$1 = {
  key: 0,
  class: "fixed inset-0 z-[70] bg-black/60 backdrop-blur-sm flex items-center justify-center p-4"
};
const _hoisted_66$1 = { class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-dark-bg-mute flex flex-col max-h-[86vh]" };
const _hoisted_67$1 = { class: "px-6 py-4 border-b border-gray-200 dark:border-dark-bg-mute flex-shrink-0 bg-gradient-to-r from-indigo-50 to-purple-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] rounded-t-xl" };
const _hoisted_68$1 = { class: "flex items-center justify-between" };
const _hoisted_69$1 = { class: "text-lg md:text-xl font-semibold text-gray-900 dark:text-white flex items-center gap-2" };
const _hoisted_70$1 = ["aria-label"];
const _hoisted_71$1 = { class: "p-4 md:p-6 overflow-y-auto min-h-0" };
const _hoisted_72$1 = { class: "flex flex-col md:flex-row gap-6 items-start" };
const _hoisted_73$1 = {
  key: 0,
  class: "flex-shrink-0"
};
const _hoisted_74$1 = ["src", "alt"];
const _hoisted_75$1 = { class: "flex-1" };
const _hoisted_76$1 = { class: "flex flex-wrap gap-2 items-center" };
const _hoisted_77$1 = { class: "uppercase tracking-wider" };
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "SessionDetailModal",
  props: {
    show: { type: Boolean },
    details: {}
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const SnakeReplay = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => SnakeReplay$1),true              ?void 0:void 0));
    const emit = __emit;
    const { t } = useI18n();
    const zoomOpen = ref(false);
    const zoomImage = ref(void 0);
    const zoomSlots = ref([]);
    const openZoom = (entry) => {
      const img = entry?.extra?.pictionary?.image;
      const s = (entry?.extra?.pictionary?.slots || []).map((x) => ({
        char: x.char,
        fixed: !!x.fixed,
        separator: !!x.separator
      }));
      zoomImage.value = img;
      zoomSlots.value = s;
      zoomOpen.value = true;
    };
    const closeZoom = () => {
      zoomOpen.value = false;
    };
    const getDirectionName = (direction) => {
      if (direction.x === 1) return "→ Right";
      if (direction.x === -1) return "← Left";
      if (direction.y === 1) return "↓ Down";
      if (direction.y === -1) return "↑ Up";
      return "⏸ Stopped";
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$u, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-95 translate-y-4",
                "enter-to-class": "opacity-100 scale-100 translate-y-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0",
                "leave-to-class": "opacity-0 scale-95 translate-y-4"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: "w-full max-w-5xl max-h-[82vh]",
                    onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("div", _hoisted_2$r, [
                      createBaseVNode("div", _hoisted_3$q, [
                        createBaseVNode("div", _hoisted_4$o, [
                          createBaseVNode("h3", _hoisted_5$m, [
                            _cache[3] || (_cache[3] = createBaseVNode("span", { class: "w-2 h-2 bg-indigo-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("flashcard.history.details.title", "Session Details")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: _cache[0] || (_cache[0] = ($event) => emit("close")),
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-white/80 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-dark-bg-soft",
                            "aria-label": unref(t)("common.close", "Close")
                          }, _cache[4] || (_cache[4] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]), 8, _hoisted_6$l)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_7$k, [
                        !_ctx.details ? (openBlock(), createElementBlock("div", _hoisted_8$k, [
                          createBaseVNode("div", _hoisted_9$k, toDisplayString$1(unref(t)("flashcard.history.details.noData", "No details available for this session")), 1)
                        ])) : (openBlock(), createElementBlock("div", _hoisted_10$j, [
                          createBaseVNode("div", _hoisted_11$j, [
                            createBaseVNode("div", _hoisted_12$j, [
                              createBaseVNode("div", _hoisted_13$j, toDisplayString$1(unref(t)("flashcard.history.totalCards", "Total Cards")), 1),
                              createBaseVNode("div", _hoisted_14$j, toDisplayString$1(_ctx.details.total), 1)
                            ]),
                            createBaseVNode("div", _hoisted_15$g, [
                              createBaseVNode("div", _hoisted_16$g, toDisplayString$1(unref(t)("flashcard.history.correct", "Correct")), 1),
                              createBaseVNode("div", _hoisted_17$g, toDisplayString$1(_ctx.details.correct), 1)
                            ]),
                            createBaseVNode("div", _hoisted_18$f, [
                              createBaseVNode("div", _hoisted_19$f, toDisplayString$1(unref(t)("flashcard.history.incorrect", "Incorrect")), 1),
                              createBaseVNode("div", _hoisted_20$f, toDisplayString$1(_ctx.details.incorrect), 1)
                            ]),
                            createBaseVNode("div", _hoisted_21$f, [
                              createBaseVNode("div", _hoisted_22$d, toDisplayString$1(unref(t)("flashcard.modes.mode", "Mode")), 1),
                              createBaseVNode("div", _hoisted_23$d, toDisplayString$1(_ctx.details.mode), 1)
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_24$c, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.details.entries, (e, idx) => {
                              return openBlock(), createElementBlock("div", {
                                key: idx,
                                class: "p-3 md:p-4 bg-white dark:bg-gray-custom"
                              }, [
                                createBaseVNode("div", _hoisted_25$c, [
                                  createBaseVNode("div", _hoisted_26$b, [
                                    createBaseVNode("div", _hoisted_27$a, [
                                      createBaseVNode("span", _hoisted_28$a, toDisplayString$1(e.word), 1),
                                      createBaseVNode("span", _hoisted_29$9, "— " + toDisplayString$1(e.meaningShort), 1)
                                    ]),
                                    createBaseVNode("div", _hoisted_30$8, [
                                      createBaseVNode("span", _hoisted_31$8, toDisplayString$1(unref(t)("flashcard.history.details.yourAnswer", "Your answer")) + ":", 1),
                                      createBaseVNode("span", {
                                        class: normalizeClass(["ml-1", e.isCorrect ? "text-green-700 dark:text-green-400" : "text-red-700 dark:text-red-400"])
                                      }, toDisplayString$1(e.userAnswer || unref(t)("flashcard.history.details.noAnswer", "No answer")), 3)
                                    ]),
                                    createBaseVNode("div", _hoisted_32$7, [
                                      createBaseVNode("span", null, toDisplayString$1(unref(t)("flashcard.history.details.correctAnswer", "Correct answer")) + ":", 1),
                                      createBaseVNode("span", _hoisted_33$7, toDisplayString$1(e.correctAnswer), 1)
                                    ]),
                                    e.mode === "pictionary" ? (openBlock(), createElementBlock("div", _hoisted_34$7, [
                                      e.extra?.pictionary?.image ? (openBlock(), createElementBlock("div", {
                                        key: 0,
                                        class: "flex items-center gap-3 cursor-zoom-in select-none",
                                        onClick: ($event) => openZoom(e)
                                      }, [
                                        createBaseVNode("img", {
                                          src: e.extra.pictionary.image,
                                          alt: unref(t)("flashcard.pictionary.imageAlt", "Pictionary image"),
                                          class: "w-24 h-24 object-contain rounded-lg border border-gray-200 dark:border-dark-bg-mute bg-white dark:bg-dark-bg-soft"
                                        }, null, 8, _hoisted_36$6)
                                      ], 8, _hoisted_35$7)) : createCommentVNode("", true),
                                      e.extra?.pictionary?.slots && e.extra.pictionary.slots.length ? (openBlock(), createElementBlock("div", {
                                        key: 1,
                                        class: "flex flex-wrap gap-1.5 items-center cursor-zoom-in select-none",
                                        onClick: ($event) => openZoom(e)
                                      }, [
                                        (openBlock(true), createElementBlock(Fragment, null, renderList(e.extra.pictionary.slots, (slot, sIdx) => {
                                          return openBlock(), createElementBlock(Fragment, null, [
                                            slot.separator ? (openBlock(), createElementBlock("div", {
                                              key: `sep-${sIdx}`,
                                              class: "px-1 text-base text-gray-700 dark:text-white/80 select-none"
                                            }, toDisplayString$1(slot.char), 1)) : (openBlock(), createElementBlock("div", {
                                              key: `box-${sIdx}`,
                                              class: normalizeClass(["w-8 h-10 sm:w-9 sm:h-11 flex items-center justify-center rounded-md border text-lg font-semibold bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white border-gray-300 dark:border-dark-bg-mute", slot.fixed ? "opacity-90" : ""])
                                            }, [
                                              createBaseVNode("span", _hoisted_38$5, toDisplayString$1(slot.char || " "), 1)
                                            ], 2))
                                          ], 64);
                                        }), 256))
                                      ], 8, _hoisted_37$5)) : createCommentVNode("", true)
                                    ])) : createCommentVNode("", true),
                                    e.mode === "snake-game" && e.extra?.snakeGame ? (openBlock(), createElementBlock("div", _hoisted_39$4, [
                                      createBaseVNode("div", _hoisted_40$4, [
                                        createBaseVNode("div", _hoisted_41$3, [
                                          createBaseVNode("div", _hoisted_42$3, [
                                            createBaseVNode("div", {
                                              class: normalizeClass(["w-10 h-10 rounded-full flex items-center justify-center animate-pulse", e.extra.snakeGame.wasCorrect ? "bg-emerald-100 dark:bg-emerald-900/50" : "bg-red-100 dark:bg-red-900/50"])
                                            }, [
                                              e.extra.snakeGame.wasCorrect ? (openBlock(), createElementBlock("svg", _hoisted_43$3, _cache[5] || (_cache[5] = [
                                                createBaseVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" }, null, -1)
                                              ]))) : (openBlock(), createElementBlock("svg", _hoisted_44$3, _cache[6] || (_cache[6] = [
                                                createBaseVNode("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }, null, -1)
                                              ])))
                                            ], 2)
                                          ]),
                                          createBaseVNode("div", _hoisted_45$2, [
                                            createBaseVNode("div", _hoisted_46$2, [
                                              createBaseVNode("span", {
                                                class: normalizeClass(["text-sm font-medium", e.extra.snakeGame.wasCorrect ? "text-emerald-700 dark:text-emerald-300" : "text-red-700 dark:text-red-300"])
                                              }, toDisplayString$1(e.extra.snakeGame.wasCorrect ? "🐍 Ate Correct Food" : "🐍 Ate Wrong Food"), 3),
                                              createBaseVNode("span", {
                                                class: normalizeClass(["text-xs px-2 py-0.5 rounded-full", e.extra.snakeGame.foodType === "primary" ? "bg-emerald-100 text-emerald-800 dark:bg-emerald-900/50 dark:text-emerald-200" : "bg-amber-100 text-amber-800 dark:bg-amber-900/50 dark:text-amber-200"])
                                              }, toDisplayString$1(e.extra.snakeGame.foodType === "primary" ? "Target Food" : "Decoy Food"), 3)
                                            ]),
                                            createBaseVNode("div", _hoisted_47$2, " Position: (" + toDisplayString$1(e.extra.snakeGame.position.x) + ", " + toDisplayString$1(e.extra.snakeGame.position.y) + ") ", 1)
                                          ])
                                        ]),
                                        createBaseVNode("div", _hoisted_48$2, [
                                          createBaseVNode("div", _hoisted_49$2, [
                                            _cache[7] || (_cache[7] = createBaseVNode("div", { class: "text-gray-500 dark:text-white/70" }, "Snake Length", -1)),
                                            createBaseVNode("div", _hoisted_50$2, toDisplayString$1(e.extra.snakeGame.snakeLength), 1)
                                          ]),
                                          createBaseVNode("div", _hoisted_51$1, [
                                            _cache[8] || (_cache[8] = createBaseVNode("div", { class: "text-gray-500 dark:text-white/70" }, "Game Score", -1)),
                                            createBaseVNode("div", _hoisted_52$1, toDisplayString$1(e.extra.snakeGame.gameScore), 1)
                                          ]),
                                          createBaseVNode("div", _hoisted_53$1, [
                                            _cache[9] || (_cache[9] = createBaseVNode("div", { class: "text-gray-500 dark:text-white/70" }, "Words Done", -1)),
                                            createBaseVNode("div", _hoisted_54$1, toDisplayString$1(e.extra.snakeGame.wordsCompleted), 1)
                                          ]),
                                          createBaseVNode("div", _hoisted_55$1, [
                                            _cache[10] || (_cache[10] = createBaseVNode("div", { class: "text-gray-500 dark:text-white/70" }, "Wrong Bites", -1)),
                                            createBaseVNode("div", _hoisted_56$1, toDisplayString$1(e.extra.snakeGame.wrongEatenCount), 1)
                                          ])
                                        ]),
                                        createBaseVNode("div", _hoisted_57$1, [
                                          _cache[11] || (_cache[11] = createBaseVNode("div", { class: "text-xs text-gray-500 dark:text-white/70 mb-2" }, "Snake Movement & Food Position:", -1)),
                                          createVNode(unref(SnakeReplay), {
                                            data: e.extra.snakeGame
                                          }, null, 8, ["data"]),
                                          createBaseVNode("div", _hoisted_58$1, [
                                            createBaseVNode("span", null, "🐍 Length: " + toDisplayString$1(e.extra.snakeGame.snakeLength), 1),
                                            e.extra.snakeGame.direction ? (openBlock(), createElementBlock("span", _hoisted_59$1, " Direction: " + toDisplayString$1(getDirectionName(e.extra.snakeGame.direction)), 1)) : createCommentVNode("", true)
                                          ])
                                        ])
                                      ])
                                    ])) : createCommentVNode("", true),
                                    e.notes ? (openBlock(), createElementBlock("div", _hoisted_60$1, toDisplayString$1(e.notes), 1)) : createCommentVNode("", true)
                                  ]),
                                  createBaseVNode("div", _hoisted_61$1, [
                                    createBaseVNode("span", {
                                      class: normalizeClass(["inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs", e.isCorrect ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" : "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200"])
                                    }, [
                                      e.isCorrect ? (openBlock(), createElementBlock("svg", _hoisted_62$1, _cache[12] || (_cache[12] = [
                                        createBaseVNode("path", { d: "M9 16.17 4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" }, null, -1)
                                      ]))) : (openBlock(), createElementBlock("svg", _hoisted_63$1, _cache[13] || (_cache[13] = [
                                        createBaseVNode("path", { d: "m19 6.41-1.41-1.41L12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }, null, -1)
                                      ]))),
                                      createBaseVNode("span", null, toDisplayString$1(e.isCorrect ? unref(t)("flashcard.history.correct", "Correct") : unref(t)("flashcard.history.incorrect", "Incorrect")), 1)
                                    ], 2),
                                    createBaseVNode("span", _hoisted_64$1, toDisplayString$1(new Date(e.timestamp).toLocaleString()), 1)
                                  ])
                                ])
                              ]);
                            }), 128))
                          ])
                        ]))
                      ])
                    ])
                  ])
                ]),
                _: 1
              }),
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0",
                "enter-to-class": "opacity-100",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100",
                "leave-to-class": "opacity-0"
              }, {
                default: withCtx(() => [
                  zoomOpen.value ? (openBlock(), createElementBlock("div", _hoisted_65$1, [
                    createVNode(Transition, {
                      "enter-active-class": "transition-all duration-500 ease-out",
                      "enter-from-class": "opacity-0 scale-95 translate-y-4",
                      "enter-to-class": "opacity-100 scale-100 translate-y-0",
                      "leave-active-class": "transition-all duration-300 ease-in",
                      "leave-from-class": "opacity-100 scale-100 translate-y-0",
                      "leave-to-class": "opacity-0 scale-95 translate-y-4"
                    }, {
                      default: withCtx(() => [
                        createBaseVNode("div", {
                          class: "w-full max-w-4xl max-h-[86vh]",
                          onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                          }, ["stop"]))
                        }, [
                          createBaseVNode("div", _hoisted_66$1, [
                            createBaseVNode("div", _hoisted_67$1, [
                              createBaseVNode("div", _hoisted_68$1, [
                                createBaseVNode("h3", _hoisted_69$1, [
                                  _cache[14] || (_cache[14] = createBaseVNode("span", { class: "w-2 h-2 bg-indigo-500 rounded-full animate-pulse" }, null, -1)),
                                  createBaseVNode("span", null, toDisplayString$1(unref(t)("flashcard.pictionary.preview", "Pictionary Preview")), 1)
                                ]),
                                createBaseVNode("button", {
                                  onClick: closeZoom,
                                  class: "text-gray-400 hover:text-gray-600 dark:hover:text-white/80 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-dark-bg-soft",
                                  "aria-label": unref(t)("common.close", "Close")
                                }, _cache[15] || (_cache[15] = [
                                  createBaseVNode("svg", {
                                    class: "w-6 h-6",
                                    fill: "none",
                                    stroke: "currentColor",
                                    viewBox: "0 0 24 24"
                                  }, [
                                    createBaseVNode("path", {
                                      "stroke-linecap": "round",
                                      "stroke-linejoin": "round",
                                      "stroke-width": "2",
                                      d: "M6 18L18 6M6 6l12 12"
                                    })
                                  ], -1)
                                ]), 8, _hoisted_70$1)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_71$1, [
                              createBaseVNode("div", _hoisted_72$1, [
                                zoomImage.value ? (openBlock(), createElementBlock("div", _hoisted_73$1, [
                                  createBaseVNode("img", {
                                    src: zoomImage.value,
                                    alt: unref(t)("flashcard.pictionary.imageAlt", "Pictionary image"),
                                    class: "w-[320px] h-[240px] md:w-[420px] md:h-[300px] object-contain rounded-lg border border-gray-200 dark:border-dark-bg-mute bg-white dark:bg-dark-bg-soft"
                                  }, null, 8, _hoisted_74$1)
                                ])) : createCommentVNode("", true),
                                createBaseVNode("div", _hoisted_75$1, [
                                  createBaseVNode("div", _hoisted_76$1, [
                                    (openBlock(true), createElementBlock(Fragment, null, renderList(zoomSlots.value, (slot, sIdx) => {
                                      return openBlock(), createElementBlock(Fragment, null, [
                                        slot.separator ? (openBlock(), createElementBlock("div", {
                                          key: `sep-${sIdx}`,
                                          class: "px-1 text-xl text-gray-700 dark:text-white/80 select-none"
                                        }, toDisplayString$1(slot.char), 1)) : (openBlock(), createElementBlock("div", {
                                          key: `box-${sIdx}`,
                                          class: normalizeClass(["w-12 h-14 sm:w-14 sm:h-16 flex items-center justify-center rounded-lg border text-2xl font-semibold bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white border-gray-300 dark:border-dark-bg-mute", slot.fixed ? "opacity-90" : ""])
                                        }, [
                                          createBaseVNode("span", _hoisted_77$1, toDisplayString$1(slot.char || " "), 1)
                                        ], 2))
                                      ], 64);
                                    }), 256))
                                  ])
                                ])
                              ])
                            ])
                          ])
                        ])
                      ]),
                      _: 1
                    })
                  ])) : createCommentVNode("", true)
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const SessionDetailModal = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$u
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$t = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$q = { class: "w-full max-w-md" };
const _hoisted_3$p = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] rounded-t-xl" };
const _hoisted_4$n = { class: "flex items-center justify-between" };
const _hoisted_5$l = { class: "text-lg font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$k = { class: "px-6 py-4" };
const _hoisted_7$j = { class: "space-y-4" };
const _hoisted_8$j = { class: "relative" };
const _hoisted_9$j = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_10$i = {
  key: 0,
  class: "absolute top-full left-0 right-0 mt-1 bg-white dark:bg-[#0a0a0a] border border-gray-300 dark:border-gray-700 rounded-md shadow-xl z-[99999] overflow-hidden"
};
const _hoisted_11$i = { class: "p-3 border-b border-gray-200 dark:border-gray-700" };
const _hoisted_12$i = ["placeholder"];
const _hoisted_13$i = { class: "max-h-[240px] overflow-y-auto" };
const _hoisted_14$i = ["onClick"];
const _hoisted_15$f = {
  key: 0,
  class: "px-3 py-2 text-sm text-gray-500 dark:text-gray-400 text-center"
};
const _hoisted_16$f = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_17$f = ["value"];
const _hoisted_18$e = { value: "" };
const _hoisted_19$e = ["value"];
const _hoisted_20$e = { class: "flex items-center" };
const _hoisted_21$e = ["checked"];
const _hoisted_22$c = { class: "text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_23$c = { class: "flex items-center" };
const _hoisted_24$b = ["checked"];
const _hoisted_25$b = { class: "text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_26$a = { class: "flex justify-end space-x-3 mt-6" };
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "SettingsModal",
  props: {
    show: { type: Boolean },
    settings: {},
    localSettings: {},
    dateFilterEnabled: { type: Boolean },
    selectedDate: {}
  },
  emits: ["update:settings", "update:local-settings", "cancel", "apply"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const { getCategories, getLevels, allVocabularies } = useVocabularyStore();
    const levels = getLevels;
    const categoryDropdownOpen = ref(false);
    const categorySearchQuery = ref("");
    const categories = computed(() => {
      if (props.dateFilterEnabled && props.selectedDate) {
        const vocabulariesForDate = allVocabularies.value.filter((vocab) => {
          return vocab.createdAt && vocab.createdAt.startsWith(props.selectedDate);
        });
        const categoriesForDate = new Set(vocabulariesForDate.map((vocab) => vocab.category));
        return Array.from(categoriesForDate);
      }
      const categorySet = new Set(allVocabularies.value.map((v) => v.category));
      return Array.from(categorySet);
    });
    const filteredCategories = computed(() => {
      if (!categorySearchQuery.value) return categories.value;
      return categories.value.filter((category) => {
        const topicName = getTopicName(category).toLowerCase();
        return topicName.includes(categorySearchQuery.value.toLowerCase());
      });
    });
    const getSelectedCategoryDisplay = () => {
      if (!props.localSettings.category) {
        return t("flashcard.settings.all", "All");
      }
      return getTopicName(props.localSettings.category);
    };
    const toggleCategoryDropdown = () => {
      categoryDropdownOpen.value = !categoryDropdownOpen.value;
      if (categoryDropdownOpen.value) {
        categorySearchQuery.value = "";
      }
    };
    const selectCategory = (category) => {
      updateLocalSetting("category", { target: { value: category } });
      categoryDropdownOpen.value = false;
      categorySearchQuery.value = "";
    };
    const handleClickOutside = (event) => {
      const target = event.target;
      if (!target.closest(".relative")) {
        categoryDropdownOpen.value = false;
      }
    };
    watch(() => props.show, (newShow) => {
      if (!newShow) {
        categoryDropdownOpen.value = false;
        categorySearchQuery.value = "";
      }
    });
    onMounted(() => {
      document.addEventListener("click", handleClickOutside);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleClickOutside);
    });
    const updateLocalSetting = (key, event) => {
      const target = event.target;
      const value = target.type === "checkbox" ? target.checked : target.value;
      emit("update:local-settings", { ...props.localSettings, [key]: value });
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$t, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$q, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 transform",
                      onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$p, [
                        createBaseVNode("div", _hoisted_4$n, [
                          createBaseVNode("h3", _hoisted_5$l, [
                            _cache[10] || (_cache[10] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("flashcard.settings.title", "Flashcard Settings")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: _cache[0] || (_cache[0] = ($event) => emit("cancel")),
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[11] || (_cache[11] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_6$k, [
                        createBaseVNode("div", _hoisted_7$j, [
                          createBaseVNode("div", _hoisted_8$j, [
                            createBaseVNode("label", _hoisted_9$j, toDisplayString$1(unref(t)("flashcard.settings.category", "Category")), 1),
                            createBaseVNode("button", {
                              type: "button",
                              onClick: toggleCategoryDropdown,
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white text-left flex items-center justify-between hover:border-blue-300 dark:hover:border-blue-600 transition-colors"
                            }, [
                              createBaseVNode("span", null, toDisplayString$1(getSelectedCategoryDisplay()), 1),
                              (openBlock(), createElementBlock("svg", {
                                class: normalizeClass(["w-4 h-4 transition-transform duration-200", categoryDropdownOpen.value ? "rotate-180" : ""]),
                                fill: "currentColor",
                                viewBox: "0 0 20 20"
                              }, _cache[12] || (_cache[12] = [
                                createBaseVNode("path", {
                                  "fill-rule": "evenodd",
                                  d: "M5.23 7.21a.75.75 0 011.06.02L10 11.17l3.71-3.94a.75.75 0 111.08 1.04l-4.24 4.5a.75.75 0 01-1.08 0L5.21 8.27a.75.75 0 01.02-1.06z",
                                  "clip-rule": "evenodd"
                                }, null, -1)
                              ]), 2))
                            ]),
                            createVNode(Transition, {
                              "enter-active-class": "transition-all duration-200 ease-out",
                              "enter-from-class": "opacity-0 scale-95 translate-y-2",
                              "enter-to-class": "opacity-100 scale-100 translate-y-0",
                              "leave-active-class": "transition-all duration-150 ease-in",
                              "leave-from-class": "opacity-100 scale-100 translate-y-0",
                              "leave-to-class": "opacity-0 scale-95 translate-y-2"
                            }, {
                              default: withCtx(() => [
                                categoryDropdownOpen.value ? (openBlock(), createElementBlock("div", _hoisted_10$i, [
                                  createBaseVNode("div", _hoisted_11$i, [
                                    withDirectives(createBaseVNode("input", {
                                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => categorySearchQuery.value = $event),
                                      type: "text",
                                      placeholder: unref(t)("common.search", "Search") + "...",
                                      class: "w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0f0f0f] text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none",
                                      onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                                      }, ["stop"]))
                                    }, null, 8, _hoisted_12$i), [
                                      [vModelText, categorySearchQuery.value]
                                    ])
                                  ]),
                                  createBaseVNode("div", _hoisted_13$i, [
                                    createBaseVNode("div", {
                                      class: normalizeClass(["px-3 py-2 text-sm cursor-pointer hover:bg-blue-50 dark:hover:bg-blue-900/20 text-gray-900 dark:text-white transition-colors", _ctx.localSettings.category === "" ? "bg-blue-100 dark:bg-blue-900/30 font-medium" : ""]),
                                      onClick: _cache[3] || (_cache[3] = ($event) => selectCategory(""))
                                    }, toDisplayString$1(unref(t)("flashcard.settings.all", "All")), 3),
                                    (openBlock(true), createElementBlock(Fragment, null, renderList(filteredCategories.value, (category) => {
                                      return openBlock(), createElementBlock("div", {
                                        key: category,
                                        class: normalizeClass(["px-3 py-2 text-sm cursor-pointer hover:bg-blue-50 dark:hover:bg-blue-900/20 text-gray-900 dark:text-white transition-colors", _ctx.localSettings.category === category ? "bg-blue-100 dark:bg-blue-900/30 font-medium" : ""]),
                                        onClick: ($event) => selectCategory(category)
                                      }, toDisplayString$1(unref(getTopicName)(category)), 11, _hoisted_14$i);
                                    }), 128)),
                                    filteredCategories.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_15$f, toDisplayString$1(unref(t)("common.noResults", "No results found")), 1)) : createCommentVNode("", true)
                                  ])
                                ])) : createCommentVNode("", true)
                              ]),
                              _: 1
                            })
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("label", _hoisted_16$f, toDisplayString$1(unref(t)("flashcard.settings.level", "Level")), 1),
                            createBaseVNode("select", {
                              value: _ctx.localSettings.level,
                              onChange: _cache[4] || (_cache[4] = ($event) => updateLocalSetting("level", $event)),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white"
                            }, [
                              createBaseVNode("option", _hoisted_18$e, toDisplayString$1(unref(t)("flashcard.settings.all", "All")), 1),
                              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(levels), (level) => {
                                return openBlock(), createElementBlock("option", {
                                  key: level,
                                  value: level
                                }, toDisplayString$1(unref(t)(`flashcard.settings.${level.toLowerCase()}`, level)), 9, _hoisted_19$e);
                              }), 128))
                            ], 40, _hoisted_17$f)
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("label", _hoisted_20$e, [
                              createBaseVNode("input", {
                                type: "checkbox",
                                checked: _ctx.localSettings.autoFlip,
                                onChange: _cache[5] || (_cache[5] = ($event) => updateLocalSetting("autoFlip", $event)),
                                class: "mr-2"
                              }, null, 40, _hoisted_21$e),
                              createBaseVNode("span", _hoisted_22$c, toDisplayString$1(unref(t)("flashcard.settings.autoFlip", "Auto-flip after answering")), 1)
                            ])
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("label", _hoisted_23$c, [
                              createBaseVNode("input", {
                                type: "checkbox",
                                checked: _ctx.localSettings.shuffleCards,
                                onChange: _cache[6] || (_cache[6] = ($event) => updateLocalSetting("shuffleCards", $event)),
                                class: "mr-2"
                              }, null, 40, _hoisted_24$b),
                              createBaseVNode("span", _hoisted_25$b, toDisplayString$1(unref(t)("flashcard.settings.shuffle", "Shuffle cards")), 1)
                            ])
                          ])
                        ]),
                        createBaseVNode("div", _hoisted_26$a, [
                          createBaseVNode("button", {
                            onClick: _cache[7] || (_cache[7] = ($event) => emit("cancel")),
                            class: "px-4 py-2 text-gray-700 dark:text-gray-300 border border-gray-300 dark:border-gray-700 rounded-md hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
                          }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                          createBaseVNode("button", {
                            onClick: _cache[8] || (_cache[8] = ($event) => emit("apply")),
                            class: "px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md transition-colors"
                          }, toDisplayString$1(unref(t)("common.apply", "Apply")), 1)
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const SettingsModal = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$t
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$s = {
  key: 1,
  class: "text-center h-full flex flex-col justify-start md:justify-center items-center gap-3 md:gap-4"
};
const _hoisted_2$p = { class: "mb-6" };
const _hoisted_3$o = { class: "px-2.5 py-0.5 bg-blue-100 dark:bg-dark-bg-mute text-blue-800 dark:text-blue-300 text-xs sm:text-sm font-medium rounded-full" };
const _hoisted_4$m = { class: "text-3xl sm:text-4xl md:text-5xl leading-tight font-bold text-gray-900 dark:text-white mb-3 md:mb-4 break-words" };
const _hoisted_5$k = { class: "text-base sm:text-lg md:text-xl text-gray-500 dark:text-white/70 mb-6 md:mb-8 break-words" };
const _hoisted_6$j = {
  key: 0,
  class: "text-red-500 dark:text-red-400"
};
const _hoisted_7$i = { key: 1 };
const _hoisted_8$i = ["disabled"];
const _hoisted_9$i = { class: "mt-5 sm:mt-6 md:mt-8" };
const _hoisted_10$h = {
  key: 0,
  class: "text-gray-600 dark:text-white/80 text-sm sm:text-base break-words"
};
const _hoisted_11$h = { class: "font-medium text-gray-800 dark:text-white" };
const _hoisted_12$h = {
  key: 1,
  class: "mt-4"
};
const _hoisted_13$h = {
  key: 0,
  class: "text-lg sm:text-xl md:text-2xl font-bold text-green-600 dark:text-green-400"
};
const _hoisted_14$h = {
  key: 1,
  class: "text-lg sm:text-xl md:text-2xl font-bold text-red-600 dark:text-red-400"
};
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "PronunciationMode",
  props: {
    card: {},
    isRecording: { type: Boolean },
    pronunciationResult: {},
    pronunciationAnswered: { type: Boolean },
    pronunciationCorrect: { type: Boolean },
    isSpeechRecognitionSupported: { type: Boolean },
    getTopicName: { type: Function },
    wordsCrushEnabled: { type: Boolean }
  },
  emits: ["start-recording", "game-completed", "play-audio"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const WordsCrushMode = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => WordsCrushMode$1),true              ?void 0:void 0));
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const props = __props;
    const emit = __emit;
    const handleStartRecording = () => {
      emit("start-recording");
    };
    const handleGameCompleted = (isCorrect) => {
      isCorrectAnswer.value = isCorrect;
      setTimeout(() => {
        triggerFirework.value = true;
        triggerSound.value = true;
      }, 50);
      emit("game-completed", isCorrect);
    };
    const handlePlayAudio = () => {
      emit("play-audio");
    };
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    watch(() => props.pronunciationAnswered, (newValue) => {
      if (newValue && !triggerFirework.value && !props.wordsCrushEnabled) {
        isCorrectAnswer.value = props.pronunciationCorrect;
        setTimeout(() => {
          triggerFirework.value = true;
          triggerSound.value = true;
        }, 50);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-dark-bg-mute p-4 sm:p-6 md:p-8 min-h-96 h-auto select-none overflow-hidden",
        onCopy: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        _ctx.wordsCrushEnabled && _ctx.card ? (openBlock(), createBlock(unref(WordsCrushMode), {
          key: 0,
          card: _ctx.card,
          "get-topic-name": _ctx.getTopicName,
          onGameCompleted: handleGameCompleted,
          onPlayAudio: handlePlayAudio
        }, null, 8, ["card", "get-topic-name"])) : (openBlock(), createElementBlock("div", _hoisted_1$s, [
          createBaseVNode("div", _hoisted_2$p, [
            createBaseVNode("span", _hoisted_3$o, toDisplayString$1(_ctx.card?.category ? _ctx.getTopicName(_ctx.card.category) : ""), 1)
          ]),
          createBaseVNode("h2", _hoisted_4$m, toDisplayString$1(_ctx.card?.word), 1),
          createBaseVNode("p", _hoisted_5$k, toDisplayString$1(_ctx.card?.pronunciation), 1),
          !_ctx.isSpeechRecognitionSupported ? (openBlock(), createElementBlock("div", _hoisted_6$j, toDisplayString$1(unref(t)("flashcard.pronunciation.microphoneError", "Microphone error! Please check microphone access permissions.")), 1)) : (openBlock(), createElementBlock("div", _hoisted_7$i, [
            createBaseVNode("button", {
              onClick: handleStartRecording,
              disabled: _ctx.isRecording,
              class: normalizeClass(["bg-red-500 hover:bg-red-600 text-white p-4 sm:p-5 md:p-6 rounded-full transition-colors disabled:opacity-50", { "animate-pulse": _ctx.isRecording }])
            }, _cache[3] || (_cache[3] = [
              createBaseVNode("svg", {
                class: "w-8 h-8",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", { d: "M7 4a3 3 0 016 0v6a3 3 0 11-6 0V4z" }),
                createBaseVNode("path", { d: "M5.5 9.5a.5.5 0 01.5.5v1a4 4 0 004 4h.5a.5.5 0 010 1h-.5a5 5 0 01-5-5v-1a.5.5 0 01.5-.5z" }),
                createBaseVNode("path", { d: "M10 18a5 5 0 005-5h-1a4 4 0 01-4 4v1z" })
              ], -1)
            ]), 10, _hoisted_8$i)
          ])),
          createBaseVNode("div", _hoisted_9$i, [
            _ctx.pronunciationResult ? (openBlock(), createElementBlock("p", _hoisted_10$h, [
              createTextVNode(toDisplayString$1(unref(t)("flashcard.pronunciation.yourRecording", "Your Recording")) + ": ", 1),
              createBaseVNode("span", _hoisted_11$h, toDisplayString$1(_ctx.pronunciationResult), 1)
            ])) : createCommentVNode("", true),
            _ctx.pronunciationAnswered ? (openBlock(), createElementBlock("div", _hoisted_12$h, [
              _ctx.pronunciationCorrect ? (openBlock(), createElementBlock("p", _hoisted_13$h, toDisplayString$1(unref(t)("flashcard.listening.correct", "✓ Correct!")), 1)) : (openBlock(), createElementBlock("p", _hoisted_14$h, toDisplayString$1(unref(t)("flashcard.pronunciation.tryAgain", "Try Again!")), 1))
            ])) : createCommentVNode("", true)
          ])
        ])),
        createVNode(unref(FireworkSoundEffect), {
          ref_key: "fireworkEffect",
          ref: fireworkEffect,
          "trigger-firework": triggerFirework.value,
          "trigger-sound": triggerSound.value,
          "is-correct": isCorrectAnswer.value,
          onEffectComplete: resetTriggers
        }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
      ], 32);
    };
  }
});

const PronunciationMode = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$s
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$r = { class: "text-center h-full flex flex-col justify-center" };
const _hoisted_2$o = { class: "mb-6" };
const _hoisted_3$n = { class: "px-3 py-1 bg-blue-100 dark:bg-gray-800 text-blue-800 dark:text-blue-300 text-xs sm:text-sm md:text-base font-medium rounded-full" };
const _hoisted_4$l = { class: "mb-8" };
const _hoisted_5$j = {
  key: 0,
  class: "text-base sm:text-lg md:text-xl text-gray-600 dark:text-gray-300 mb-8"
};
const _hoisted_6$i = {
  key: 1,
  class: "text-base sm:text-lg md:text-xl text-gray-600 dark:text-gray-300 mb-8"
};
const _hoisted_7$h = {
  key: 2,
  class: "max-w-md mx-auto"
};
const _hoisted_8$h = ["value", "disabled", "placeholder"];
const _hoisted_9$h = {
  key: 0,
  class: "mt-4"
};
const _hoisted_10$g = {
  key: 0,
  class: "text-green-600 dark:text-green-400 font-medium"
};
const _hoisted_11$g = {
  key: 1,
  class: "text-red-600 dark:text-red-400 font-medium"
};
const _hoisted_12$g = { class: "text-sm text-gray-500 dark:text-gray-400 mt-2" };
const _hoisted_13$g = {
  key: 3,
  class: "w-full px-2 sm:px-3 md:px-0"
};
const _hoisted_14$g = { class: "grid grid-cols-1 grid-2-cols-480 sm:grid-cols-2 gap-1.5 sm:gap-3 justify-items-stretch w-full max-w-none" };
const _hoisted_15$e = ["onClick", "disabled"];
const _hoisted_16$e = { class: "inline-flex items-center justify-center w-5 h-5 rounded-full text-xs font-semibold bg-gray-200 text-gray-700 dark:bg-white/10 dark:text-white/80 shrink-0" };
const _hoisted_17$e = { class: "truncate overflow-hidden min-w-0" };
const _hoisted_18$d = {
  key: 0,
  class: "mt-4 text-center"
};
const _hoisted_19$d = {
  key: 0,
  class: "text-green-600 dark:text-green-400 font-medium"
};
const _hoisted_20$d = {
  key: 1,
  class: "text-red-600 dark:text-red-400 font-medium"
};
const _hoisted_21$d = { class: "text-sm text-gray-500 dark:text-gray-400 mt-2" };
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "ListeningMode",
  props: {
    card: {},
    listeningAnswer: {},
    listeningAnswered: { type: Boolean },
    listeningCorrect: { type: Boolean },
    listeningQuizEnabled: { type: Boolean },
    listeningQuizOptions: {},
    listeningQuizSelected: {},
    listeningQuizAnswered: { type: Boolean },
    getTopicName: { type: Function }
  },
  emits: ["update:listeningAnswer", "check-answer", "play-audio", "select-listening-quiz-answer"],
  setup(__props, { emit: __emit }) {
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const props = __props;
    const emit = __emit;
    const stripDiacritics = (s) => s.replace(/[ưừứửữự]/g, "w").replace(/[ƯỪỨỬỮỰ]/g, "W").normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/đ/g, "d").replace(/Đ/g, "D");
    const listeningInput = ref(null);
    const focusListeningInput = async () => {
      await nextTick();
      try {
        listeningInput.value?.focus({ preventScroll: true });
      } catch {
        listeningInput.value?.focus();
      }
    };
    const ensureListeningFocus = () => {
      if (!props.listeningQuizEnabled && !props.listeningAnswered) {
        if (document.activeElement !== listeningInput.value) {
          focusListeningInput();
        }
      }
    };
    const onListeningBlur = () => {
      ensureListeningFocus();
    };
    const onInput = (event) => {
      const el = event.target;
      const sanitized = stripDiacritics(el.value);
      if (sanitized !== el.value) {
        el.value = sanitized;
      }
      emit("update:listeningAnswer", sanitized);
    };
    onMounted(() => {
      ensureListeningFocus();
    });
    const handleCheckAnswer = () => {
      if (props.listeningAnswered) return;
      emit("check-answer");
      setTimeout(() => {
        isCorrectAnswer.value = props.listeningCorrect;
        triggerFirework.value = true;
        triggerSound.value = true;
      }, 100);
    };
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    watch(() => props.listeningAnswered, (newValue) => {
      if (newValue && !triggerFirework.value) {
        isCorrectAnswer.value = props.listeningCorrect;
        setTimeout(() => {
          triggerFirework.value = true;
          triggerSound.value = true;
        }, 50);
      }
    });
    watch(() => props.listeningAnswered, (answered) => {
      if (!answered) ensureListeningFocus();
    });
    watch(() => props.card, () => {
      ensureListeningFocus();
    });
    watch(() => props.listeningQuizEnabled, (val) => {
      if (!val) ensureListeningFocus();
    });
    const { t } = useI18n();
    const onSelectListeningOption = (opt) => {
      if (!props.listeningQuizAnswered) {
        emit("select-listening-quiz-answer", opt);
      }
    };
    const isOptionSelected = (opt) => props.listeningQuizSelected === opt;
    const isOptionCorrect = (opt) => props.card ? opt.trim().toLowerCase() === props.card.word.trim().toLowerCase() : false;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 p-6 sm:p-8 h-auto sm:h-96 select-none",
        onCopy: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[3] || (_cache[3] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createBaseVNode("div", _hoisted_1$r, [
          createBaseVNode("div", _hoisted_2$o, [
            createBaseVNode("span", _hoisted_3$n, toDisplayString$1(_ctx.card?.category ? _ctx.getTopicName(_ctx.card.category) : ""), 1)
          ]),
          createBaseVNode("div", _hoisted_4$l, [
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => emit("play-audio")),
              class: "bg-blue-500 hover:bg-blue-600 text-white p-6 rounded-full transition-colors"
            }, _cache[4] || (_cache[4] = [
              createBaseVNode("svg", {
                class: "w-8 h-8",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.816L4.846 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.846l3.537-3.816a1 1 0 011.617.816zM16 8a2 2 0 11-4 0 2 2 0 014 0zm-2 6a4 4 0 100-8 4 4 0 000 8z",
                  "clip-rule": "evenodd"
                })
              ], -1)
            ]))
          ]),
          !_ctx.listeningQuizEnabled ? (openBlock(), createElementBlock("p", _hoisted_5$j, toDisplayString$1(unref(t)("flashcard.listening.instruction", "Listen and type the word you hear:")), 1)) : (openBlock(), createElementBlock("p", _hoisted_6$i, toDisplayString$1(unref(t)("flashcard.listening.instructionQuiz", "Choose the word you hear:")), 1)),
          !_ctx.listeningQuizEnabled ? (openBlock(), createElementBlock("div", _hoisted_7$h, [
            createBaseVNode("input", {
              ref_key: "listeningInput",
              ref: listeningInput,
              value: _ctx.listeningAnswer,
              onInput,
              onKeyup: withKeys(handleCheckAnswer, ["enter"]),
              type: "text",
              disabled: _ctx.listeningAnswered,
              class: "w-full p-4 text-center text-lg sm:text-xl md:text-2xl border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 select-text",
              placeholder: unref(t)("flashcard.listening.placeholder", "Type the word you hear..."),
              inputmode: "text",
              autocapitalize: "none",
              autocomplete: "off",
              spellcheck: "false",
              onBlur: onListeningBlur
            }, null, 40, _hoisted_8$h),
            _ctx.listeningAnswered ? (openBlock(), createElementBlock("div", _hoisted_9$h, [
              _ctx.listeningCorrect ? (openBlock(), createElementBlock("p", _hoisted_10$g, toDisplayString$1(unref(t)("flashcard.listening.correct", "✓ Correct!")), 1)) : (openBlock(), createElementBlock("p", _hoisted_11$g, toDisplayString$1(unref(t)("flashcard.listening.incorrect", "✗ Correct answer:")) + " " + toDisplayString$1(_ctx.card?.word), 1)),
              createBaseVNode("p", _hoisted_12$g, toDisplayString$1(_ctx.card?.meaning), 1)
            ])) : createCommentVNode("", true)
          ])) : (openBlock(), createElementBlock("div", _hoisted_13$g, [
            createBaseVNode("div", _hoisted_14$g, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.listeningQuizOptions, (opt, idx) => {
                return openBlock(), createElementBlock("button", {
                  key: idx,
                  onClick: ($event) => onSelectListeningOption(opt),
                  disabled: _ctx.listeningQuizAnswered,
                  translate: "no",
                  class: normalizeClass(["notranslate px-3 py-1.5 sm:py-2 rounded-md border text-[13px] sm:text-sm transition-all duration-150 disabled:opacity-70 disabled:cursor-not-allowed text-left flex items-center gap-2 w-full min-w-0", [
                    _ctx.listeningQuizAnswered ? isOptionCorrect(opt) ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300 border-green-300 dark:border-green-700" : isOptionSelected(opt) ? "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-300 border-red-300 dark:border-red-700" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60 hover:shadow-sm hover:scale-[1.01] dark:hover:bg-white/5"
                  ]])
                }, [
                  createBaseVNode("span", _hoisted_16$e, toDisplayString$1(String.fromCharCode(65 + idx)), 1),
                  createBaseVNode("span", _hoisted_17$e, toDisplayString$1(opt), 1)
                ], 10, _hoisted_15$e);
              }), 128))
            ]),
            _ctx.listeningAnswered ? (openBlock(), createElementBlock("div", _hoisted_18$d, [
              _ctx.listeningCorrect ? (openBlock(), createElementBlock("p", _hoisted_19$d, toDisplayString$1(unref(t)("flashcard.listening.correct", "✓ Correct!")), 1)) : (openBlock(), createElementBlock("p", _hoisted_20$d, toDisplayString$1(unref(t)("flashcard.listening.incorrect", "✗ Correct answer:")) + " " + toDisplayString$1(_ctx.card?.word), 1)),
              createBaseVNode("p", _hoisted_21$d, toDisplayString$1(_ctx.card?.meaning), 1)
            ])) : createCommentVNode("", true)
          ]))
        ]),
        createVNode(unref(FireworkSoundEffect), {
          ref_key: "fireworkEffect",
          ref: fireworkEffect,
          "trigger-firework": triggerFirework.value,
          "trigger-sound": triggerSound.value,
          "is-correct": isCorrectAnswer.value,
          onEffectComplete: resetTriggers
        }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
      ], 32);
    };
  }
});

const ListeningMode = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__scopeId", "data-v-849d04c0"]]);

const ListeningMode$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: ListeningMode
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$q = {
  key: 0,
  class: "grid grid-cols-3 gap-4 mt-8"
};
const _hoisted_2$n = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg p-4 text-center shadow border border-gray-200 dark:border-gray-800" };
const _hoisted_3$m = { class: "text-2xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_4$k = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_5$i = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg p-4 text-center shadow border border-gray-200 dark:border-gray-800" };
const _hoisted_6$h = { class: "text-2xl font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_7$g = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_8$g = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg p-4 text-center shadow border border-gray-200 dark:border-gray-800" };
const _hoisted_9$g = { class: "text-2xl font-bold text-red-600 dark:text-red-400" };
const _hoisted_10$f = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_11$f = {
  key: 1,
  class: "grid grid-cols-2 gap-4 mt-8"
};
const _hoisted_12$f = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg p-4 text-center shadow border border-gray-200 dark:border-gray-800" };
const _hoisted_13$f = { class: "text-2xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_14$f = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_15$d = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg p-4 text-center shadow border border-gray-200 dark:border-gray-800" };
const _hoisted_16$d = { class: "text-2xl font-bold text-red-600 dark:text-red-400" };
const _hoisted_17$d = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "PracticeStats",
  props: {
    stats: {},
    mode: {}
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return _ctx.mode === "flashcard" ? (openBlock(), createElementBlock("div", _hoisted_1$q, [
        createBaseVNode("div", _hoisted_2$n, [
          createBaseVNode("p", _hoisted_3$m, toDisplayString$1(_ctx.stats.easy), 1),
          createBaseVNode("p", _hoisted_4$k, toDisplayString$1(unref(t)("common.easy", "Easy")), 1)
        ]),
        createBaseVNode("div", _hoisted_5$i, [
          createBaseVNode("p", _hoisted_6$h, toDisplayString$1(_ctx.stats.reviewed), 1),
          createBaseVNode("p", _hoisted_7$g, toDisplayString$1(unref(t)("common.reviewed", "Reviewed")), 1)
        ]),
        createBaseVNode("div", _hoisted_8$g, [
          createBaseVNode("p", _hoisted_9$g, toDisplayString$1(_ctx.stats.difficult), 1),
          createBaseVNode("p", _hoisted_10$f, toDisplayString$1(unref(t)("common.difficult", "Difficult")), 1)
        ])
      ])) : (openBlock(), createElementBlock("div", _hoisted_11$f, [
        createBaseVNode("div", _hoisted_12$f, [
          createBaseVNode("p", _hoisted_13$f, toDisplayString$1(_ctx.stats.correct), 1),
          createBaseVNode("p", _hoisted_14$f, toDisplayString$1(unref(t)("common.correct", "Correct")), 1)
        ]),
        createBaseVNode("div", _hoisted_15$d, [
          createBaseVNode("p", _hoisted_16$d, toDisplayString$1(_ctx.stats.incorrect), 1),
          createBaseVNode("p", _hoisted_17$d, toDisplayString$1(unref(t)("common.incorrect", "Incorrect")), 1)
        ])
      ]));
    };
  }
});

const PracticeStats = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$q
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$p = { class: "text-center py-12" };
const _hoisted_2$m = { class: "mt-2 text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_3$l = { class: "mt-1 text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_4$j = { class: "mt-6" };
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "FlashcardEmptyState",
  emits: ["go-to-vocabulary"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$p, [
        _cache[1] || (_cache[1] = createBaseVNode("svg", {
          class: "mx-auto h-12 w-12 text-gray-400 dark:text-gray-500",
          fill: "none",
          viewBox: "0 0 24 24",
          stroke: "currentColor"
        }, [
          createBaseVNode("path", {
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            "stroke-width": "2",
            d: "M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"
          })
        ], -1)),
        createBaseVNode("h3", _hoisted_2$m, toDisplayString$1(unref(t)("flashcard.empty.title", "No flashcards to practice")), 1),
        createBaseVNode("p", _hoisted_3$l, toDisplayString$1(unref(t)("flashcard.empty.description", "Add some words to your vocabulary to get started.")), 1),
        createBaseVNode("div", _hoisted_4$j, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => emit("go-to-vocabulary")),
            class: "inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700"
          }, toDisplayString$1(unref(t)("flashcard.empty.action", "Add Vocabulary")), 1)
        ])
      ]);
    };
  }
});

const FlashcardEmptyState = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$p
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$o = { class: "h-full flex flex-col overflow-hidden" };
const _hoisted_2$l = { class: "mb-4 flex items-center justify-center gap-3" };
const _hoisted_3$k = { class: "px-3 py-1 bg-purple-100 dark:bg-dark-bg-mute text-purple-800 dark:text-purple-300 text-sm font-medium rounded-full" };
const _hoisted_4$i = { class: "flex items-center gap-2" };
const _hoisted_5$h = { class: "text-xs text-gray-600 dark:text-white/70" };
const _hoisted_6$g = ["aria-pressed", "title"];
const _hoisted_7$f = { class: "flex-1 flex items-center justify-center mb-4 min-h-0" };
const _hoisted_8$f = {
  key: 0,
  class: "flex items-center justify-center bg-gradient-to-br from-teal-50 to-cyan-50 dark:from-teal-900/30 dark:to-cyan-900/30 rounded-xl p-6 w-full max-w-lg border border-teal-200 dark:border-teal-700/50 shadow-sm"
};
const _hoisted_9$f = { class: "text-center space-y-3" };
const _hoisted_10$e = { class: "max-h-32 overflow-y-auto" };
const _hoisted_11$e = { class: "text-lg font-medium text-gray-900 dark:text-white leading-relaxed" };
const _hoisted_12$e = { class: "text-sm text-teal-600 dark:text-teal-400 font-medium" };
const _hoisted_13$e = {
  key: 0,
  class: "relative"
};
const _hoisted_14$e = ["src", "alt"];
const _hoisted_15$c = {
  key: 0,
  class: "absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-dark-bg-mute rounded-lg"
};
const _hoisted_16$c = { class: "text-center" };
const _hoisted_17$c = { class: "text-sm text-gray-500 dark:text-white/60 mt-2" };
const _hoisted_18$c = {
  key: 1,
  class: "flex items-center justify-center bg-gray-100 dark:bg-dark-bg-mute rounded-lg p-8 w-full max-w-sm"
};
const _hoisted_19$c = { class: "text-center" };
const _hoisted_20$c = { class: "text-sm text-gray-500 dark:text-white/60 mt-2" };
const _hoisted_21$c = { class: "flex-shrink-0" };
const _hoisted_22$b = { class: "flex flex-wrap gap-2 justify-center items-center" };
const _hoisted_23$b = {
  key: 0,
  class: "px-1 text-lg text-gray-700 dark:text-white/80 select-none"
};
const _hoisted_24$a = ["onClick", "onDragover", "onDrop"];
const _hoisted_25$a = {
  key: 0,
  class: "uppercase tracking-wider"
};
const _hoisted_26$9 = {
  key: 1,
  class: "caret-block",
  "aria-hidden": "true"
};
const _hoisted_27$9 = {
  key: 2,
  class: "uppercase tracking-wider"
};
const _hoisted_28$9 = {
  key: 0,
  class: "mt-3"
};
const _hoisted_29$8 = { class: "mb-2 flex justify-center" };
const _hoisted_30$7 = { class: "relative w-48 sm:w-56" };
const _hoisted_31$7 = ["placeholder"];
const _hoisted_32$6 = ["aria-label", "title"];
const _hoisted_33$6 = { class: "flex flex-wrap gap-2 justify-center" };
const _hoisted_34$6 = ["onDragstart"];
const _hoisted_35$6 = {
  key: 0,
  class: "text-center space-y-2 max-h-32 overflow-y-auto mt-3"
};
const _hoisted_36$5 = {
  key: 0,
  class: "w-4 h-4 mr-1",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_37$4 = {
  key: 1,
  class: "w-4 h-4 mr-1",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_38$4 = {
  key: 0,
  class: "text-center"
};
const _hoisted_39$3 = { class: "text-sm text-gray-600 dark:text-white/70" };
const _hoisted_40$3 = { class: "font-semibold text-gray-900 dark:text-white" };
const _hoisted_41$2 = { class: "text-xs text-gray-500 dark:text-white/60 mt-1 line-clamp-2" };
const _hoisted_42$2 = {
  key: 1,
  class: "text-center"
};
const _hoisted_43$2 = { class: "text-sm text-gray-600 dark:text-white/70 line-clamp-2" };
const _hoisted_44$2 = {
  key: 1,
  class: "text-center text-sm text-gray-500 dark:text-white/60 mt-3"
};
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "PictionaryMode",
  props: {
    card: {},
    pictionaryAnswer: {},
    pictionaryAnswered: { type: Boolean },
    pictionaryCorrect: { type: Boolean },
    definitionMode: { type: Boolean },
    getTopicName: { type: Function }
  },
  emits: ["update:pictionary-answer", "check-answer", "pictionary-snapshot"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const { playAudio } = useVoiceStore();
    const imageError = ref(false);
    const hiddenInput = ref(null);
    const isFocused = ref(false);
    const isComposing = ref(false);
    const dragMode = ref(false);
    const letterBank = Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
    const letterQuery = ref("");
    const filteredLetterBank = computed(() => {
      const q = letterQuery.value.trim().toUpperCase();
      if (!q) return letterBank;
      const onlyLetters = q.replace(/[^A-Z]/g, "");
      if (!onlyLetters) return letterBank;
      const set = new Set(onlyLetters.split(""));
      return letterBank.filter((ch) => set.has(ch));
    });
    const clearLetterQuery = () => {
      letterQuery.value = "";
    };
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const slots = ref([]);
    const normalizeWord = (w) => w.normalize("NFKC");
    const buildSlots = (word) => {
      const letters = normalizeWord(word);
      const arr = [];
      const isAlpha = (c) => /^[a-z]$/i.test(c);
      const meaningfulIndices = [];
      for (let i = 0; i < letters.length; i++) {
        const c = letters[i];
        if (isAlpha(c)) {
          meaningfulIndices.push(i);
        }
      }
      const alphaCount = meaningfulIndices.length;
      const hintCount = alphaCount <= 3 ? 1 : 2;
      const hintSet = /* @__PURE__ */ new Set();
      while (hintSet.size < Math.min(hintCount, alphaCount)) {
        const r = meaningfulIndices[Math.floor(Math.random() * alphaCount)];
        hintSet.add(r);
      }
      for (let i = 0; i < letters.length; i++) {
        const c = letters[i];
        if (!isAlpha(c)) {
          arr.push({ char: c, fixed: true, separator: true });
          continue;
        }
        if (hintSet.has(i)) {
          arr.push({ char: c.toUpperCase(), fixed: true });
        } else {
          arr.push({ char: "", fixed: false });
        }
      }
      slots.value = arr;
      pushAnswer();
    };
    const pushAnswer = () => {
      const answer = slots.value.map((s) => s.separator ? s.char : s.char || "").join("");
      emit("update:pictionary-answer", answer);
    };
    const emitSnapshot = () => {
      const snapshot = slots.value.map((s) => ({ char: s.char, fixed: s.fixed, separator: s.separator }));
      emit("pictionary-snapshot", { slots: snapshot });
    };
    const focusInput = async () => {
      await nextTick();
      try {
        hiddenInput.value?.focus({ preventScroll: true });
      } catch {
        hiddenInput.value?.focus();
      }
      isFocused.value = true;
    };
    const ensureFocusIfNeeded = () => {
      if (!props.pictionaryAnswered && !dragMode.value) {
        if (document.activeElement !== hiddenInput.value) {
          focusInput();
        }
      }
    };
    const onHiddenBlur = () => {
      isFocused.value = false;
      ensureFocusIfNeeded();
    };
    const nextEditableIndex = () => slots.value.findIndex((s) => !s.fixed && !s.char);
    const lastFilledEditableIndex = () => {
      for (let i = slots.value.length - 1; i >= 0; i--) {
        const s = slots.value[i];
        if (!s.fixed && s.char) return i;
      }
      return -1;
    };
    const stripDiacritics = (s) => s.replace(/[ưừứửữự]/g, "w").replace(/[ƯỪỨỬỮỰ]/g, "W").normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/đ/g, "d").replace(/Đ/g, "D");
    const handleKeydown = (e) => {
      if (props.pictionaryAnswered) return;
      if (isComposing.value) return;
      const key = e.key;
      if (dragMode.value) {
        if (key === "Enter") {
          emitSnapshot();
          emit("check-answer");
        }
        return;
      }
      const alpha = stripDiacritics(key);
      if (/^[a-z]$/i.test(alpha)) {
        const idx = nextEditableIndex();
        if (idx !== -1) {
          slots.value[idx].char = alpha.toUpperCase();
          pushAnswer();
        }
        return;
      }
      if (key === "Backspace") {
        const idx = lastFilledEditableIndex();
        if (idx !== -1) {
          slots.value[idx].char = "";
          pushAnswer();
        }
      } else if (key === "Enter") {
        emitSnapshot();
        emit("check-answer");
      }
    };
    const handleBeforeInput = (e) => {
      if (props.pictionaryAnswered) return;
      if (isComposing.value) {
        return;
      }
      if (dragMode.value) {
        if (hiddenInput.value) hiddenInput.value.value = "";
        return;
      }
      const ie = e;
      const type = ie.inputType;
      if (type === "insertText") {
        const data = stripDiacritics(ie.data || "");
        if (/^[a-z]$/i.test(data)) {
          const idx = nextEditableIndex();
          if (idx !== -1) {
            slots.value[idx].char = data.toUpperCase();
            pushAnswer();
          }
        }
      } else if (type === "deleteContentBackward") {
        const idx = lastFilledEditableIndex();
        if (idx !== -1) {
          slots.value[idx].char = "";
          pushAnswer();
        }
      } else if (type === "insertLineBreak") {
        emitSnapshot();
        emit("check-answer");
      }
      if (hiddenInput.value) hiddenInput.value.value = "";
    };
    const handleInput = (e) => {
      if (isComposing.value) return;
      if (hiddenInput.value) hiddenInput.value.value = "";
    };
    const onCompositionStart = () => {
      isComposing.value = true;
    };
    const onCompositionUpdate = (e) => {
      const data = (e.data || "").toString();
      stripDiacritics(data);
    };
    const onCompositionEnd = (e) => {
      const dataRaw = (e.data || hiddenInput.value?.value || "").toString();
      const finalized = stripDiacritics(dataRaw).toUpperCase();
      for (const ch of finalized) {
        if (!/^[A-Z]$/.test(ch)) continue;
        const idx = nextEditableIndex();
        if (idx === -1) break;
        slots.value[idx].char = ch;
      }
      pushAnswer();
      if (hiddenInput.value) hiddenInput.value.value = "";
      isComposing.value = false;
    };
    const allEditableFilled = () => {
      return slots.value.every((s) => s.fixed || s.separator || !!s.char);
    };
    const maybeAutoCheck = () => {
      if (dragMode.value && !props.pictionaryAnswered && allEditableFilled()) {
        emitSnapshot();
        emit("check-answer");
      }
    };
    watch(() => props.card, (c) => {
      imageError.value = false;
      if (c?.word) buildSlots(c.word);
      ensureFocusIfNeeded();
    });
    onMounted(() => {
      if (props.card?.word) buildSlots(props.card.word);
      focusInput();
      document.addEventListener("visibilitychange", ensureFocusIfNeeded);
    });
    onBeforeUnmount(() => {
      document.removeEventListener("visibilitychange", ensureFocusIfNeeded);
    });
    const handleImageError = () => {
      imageError.value = true;
    };
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    watch(() => props.pictionaryAnswered, (newVal) => {
      if (newVal && !triggerFirework.value) {
        isCorrectAnswer.value = props.pictionaryCorrect;
        setTimeout(() => {
          triggerFirework.value = true;
          triggerSound.value = true;
        }, 50);
      }
      if (newVal && props.pictionaryCorrect && props.card?.word) {
        Promise.resolve(playAudio(props.card.word)).catch(() => {
        });
      }
      if (newVal) {
        isFocused.value = false;
      }
      if (!newVal) {
        ensureFocusIfNeeded();
      }
    });
    const toggleDragMode = () => {
      dragMode.value = !dragMode.value;
      if (!dragMode.value) {
        focusInput();
      } else {
        isFocused.value = false;
      }
    };
    const onLetterDragStart = (ch, ev) => {
      ev.dataTransfer?.setData("text/plain", ch);
      ev.dataTransfer?.setDragImage?.(createDragImage(ch), 12, 12);
    };
    const onSlotDragOver = (idx, _ev) => {
      const s = slots.value[idx];
      if (!s || s.fixed || s.separator) return;
    };
    const onSlotDrop = (idx, ev) => {
      const s = slots.value[idx];
      if (!s || s.fixed || s.separator) return;
      const ch = (ev.dataTransfer?.getData("text/plain") || "").toUpperCase();
      if (/^[A-Z]$/.test(ch)) {
        s.char = ch;
        pushAnswer();
        clearLetterQuery();
        maybeAutoCheck();
      }
    };
    const onSlotClick = (idx) => {
      const s = slots.value[idx];
      if (!s || s.separator || s.fixed) return;
      if (dragMode.value) {
        if (s.char) {
          s.char = "";
          pushAnswer();
        }
      } else {
        focusInput();
      }
    };
    const createDragImage = (ch) => {
      const el = document.createElement("div");
      el.textContent = ch;
      el.style.position = "absolute";
      el.style.top = "-1000px";
      el.style.left = "-1000px";
      el.style.padding = "6px 8px";
      el.style.fontWeight = "700";
      el.style.fontSize = "16px";
      el.style.borderRadius = "8px";
      el.style.background = "rgba(37,99,235,0.15)";
      el.style.color = "#1D4ED8";
      el.style.border = "1px solid rgba(37,99,235,0.35)";
      document.body.appendChild(el);
      setTimeout(() => document.body.removeChild(el), 0);
      return el;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-black rounded-xl shadow-2xl border border-gray-200 dark:border-dark-bg-mute p-6 min-h-96 max-h-[560px] select-none",
        onCopy: _cache[3] || (_cache[3] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[4] || (_cache[4] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[5] || (_cache[5] = withModifiers(() => {
        }, ["prevent"])),
        onClick: focusInput
      }, [
        createBaseVNode("div", _hoisted_1$o, [
          createBaseVNode("div", _hoisted_2$l, [
            createBaseVNode("span", _hoisted_3$k, toDisplayString$1(_ctx.card?.category ? _ctx.getTopicName(_ctx.card.category) : ""), 1),
            createBaseVNode("div", _hoisted_4$i, [
              createBaseVNode("span", _hoisted_5$h, toDisplayString$1(unref(t)("flashcard.pictionary.dragToggle", "Drag & Drop")), 1),
              createBaseVNode("button", {
                class: normalizeClass(["relative inline-flex h-5 w-9 items-center rounded-full transition-colors border border-gray-300 dark:border-dark-bg-mute", dragMode.value ? "bg-blue-600" : "bg-gray-200 dark:bg-dark-bg-soft"]),
                onClick: withModifiers(toggleDragMode, ["stop"]),
                "aria-pressed": dragMode.value ? "true" : "false",
                title: unref(t)("flashcard.pictionary.dragToggle", "Drag & Drop")
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", dragMode.value ? "translate-x-5" : "translate-x-1"])
                }, null, 2)
              ], 10, _hoisted_6$g)
            ])
          ]),
          createBaseVNode("div", _hoisted_7$f, [
            props.definitionMode ? (openBlock(), createElementBlock("div", _hoisted_8$f, [
              createBaseVNode("div", _hoisted_9$f, [
                _cache[6] || (_cache[6] = createBaseVNode("div", { class: "mx-auto w-12 h-12 bg-teal-100 dark:bg-teal-800/50 rounded-full flex items-center justify-center mb-4" }, [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 text-teal-600 dark:text-teal-400",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    stroke: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                    })
                  ])
                ], -1)),
                createBaseVNode("div", _hoisted_10$e, [
                  createBaseVNode("p", _hoisted_11$e, toDisplayString$1(_ctx.card?.meaning || unref(t)("flashcard.pictionary.noDefinition", "No definition available")), 1)
                ]),
                createBaseVNode("p", _hoisted_12$e, toDisplayString$1(unref(t)("flashcard.pictionary.definitionHint", "Guess the word from this definition")), 1)
              ])
            ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              _ctx.card?.image ? (openBlock(), createElementBlock("div", _hoisted_13$e, [
                createBaseVNode("img", {
                  src: _ctx.card.image,
                  alt: unref(t)("flashcard.pictionary.imageAlt", "Pictionary image"),
                  class: "max-w-full max-h-40 object-contain rounded-lg shadow-md border border-gray-200 dark:border-dark-bg-mute",
                  onError: handleImageError
                }, null, 40, _hoisted_14$e),
                imageError.value ? (openBlock(), createElementBlock("div", _hoisted_15$c, [
                  createBaseVNode("div", _hoisted_16$c, [
                    _cache[7] || (_cache[7] = createBaseVNode("svg", {
                      class: "mx-auto h-12 w-12 text-gray-400 dark:text-white/50",
                      fill: "none",
                      viewBox: "0 0 24 24",
                      stroke: "currentColor"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 16m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                      })
                    ], -1)),
                    createBaseVNode("p", _hoisted_17$c, toDisplayString$1(unref(t)("flashcard.image.imageError", "Could not load image.")), 1)
                  ])
                ])) : createCommentVNode("", true)
              ])) : (openBlock(), createElementBlock("div", _hoisted_18$c, [
                createBaseVNode("div", _hoisted_19$c, [
                  _cache[8] || (_cache[8] = createBaseVNode("svg", {
                    class: "mx-auto h-16 w-16 text-gray-400 dark:text-white/50",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    stroke: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 16m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                    })
                  ], -1)),
                  createBaseVNode("p", _hoisted_20$c, toDisplayString$1(unref(t)("flashcard.image.noImage", "No image available for this card.")), 1)
                ])
              ]))
            ], 64))
          ]),
          createBaseVNode("div", _hoisted_21$c, [
            createBaseVNode("div", _hoisted_22$b, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(slots.value, (slot, idx) => {
                return openBlock(), createElementBlock("div", { key: idx }, [
                  slot.separator ? (openBlock(), createElementBlock("div", _hoisted_23$b, toDisplayString$1(slot.char), 1)) : (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(["w-10 h-12 sm:w-12 sm:h-14 flex items-center justify-center rounded-md border text-xl sm:text-2xl font-semibold bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white border-gray-300 dark:border-dark-bg-mute transition-all duration-200", [
                      slot.fixed ? "opacity-90" : "cursor-pointer hover:bg-gray-50 dark:hover:bg-dark-bg-mute hover:border-blue-300 dark:hover:border-blue-600 hover:shadow-sm",
                      dragMode.value && !slot.fixed ? "ring-0" : ""
                    ]]),
                    onClick: ($event) => onSlotClick(idx),
                    onDragover: withModifiers(($event) => onSlotDragOver(idx), ["prevent"]),
                    onDrop: withModifiers(($event) => onSlotDrop(idx, $event), ["prevent"])
                  }, [
                    slot.char ? (openBlock(), createElementBlock("span", _hoisted_25$a, toDisplayString$1(slot.char), 1)) : !dragMode.value && isFocused.value && !_ctx.pictionaryAnswered && idx === nextEditableIndex() ? (openBlock(), createElementBlock("span", _hoisted_26$9)) : (openBlock(), createElementBlock("span", _hoisted_27$9, " "))
                  ], 42, _hoisted_24$a))
                ]);
              }), 128))
            ]),
            dragMode.value && !_ctx.pictionaryAnswered ? (openBlock(), createElementBlock("div", _hoisted_28$9, [
              createBaseVNode("div", _hoisted_29$8, [
                createBaseVNode("div", _hoisted_30$7, [
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => letterQuery.value = $event),
                    type: "text",
                    inputmode: "text",
                    autocomplete: "off",
                    spellcheck: "false",
                    placeholder: unref(t)("common.search", "Search"),
                    class: "w-full px-3 pr-8 py-1.5 text-sm rounded-md border bg-white text-gray-900 border-gray-300 dark:bg-dark-bg-soft dark:text-white dark:border-dark-bg-mute focus:outline-none focus:ring-2 focus:ring-blue-500",
                    onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                    }, ["stop"]))
                  }, null, 8, _hoisted_31$7), [
                    [vModelText, letterQuery.value]
                  ]),
                  createBaseVNode("button", {
                    type: "button",
                    class: normalizeClass(["absolute right-1.5 top-1/2 -translate-y-1/2 z-10 p-1 rounded text-gray-500 dark:text-white/70 hover:bg-gray-100 dark:hover:bg-white/10", { "opacity-40 pointer-events-none": !letterQuery.value }]),
                    onClick: withModifiers(clearLetterQuery, ["stop"]),
                    "aria-label": unref(t)("common.clear", "Clear"),
                    title: unref(t)("common.clear", "Clear")
                  }, _cache[9] || (_cache[9] = [
                    createBaseVNode("svg", {
                      class: "w-4 h-4",
                      viewBox: "0 0 20 20",
                      fill: "currentColor",
                      "aria-hidden": "true"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)
                  ]), 10, _hoisted_32$6)
                ])
              ]),
              createBaseVNode("div", _hoisted_33$6, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(filteredLetterBank.value, (ch) => {
                  return openBlock(), createElementBlock("button", {
                    key: ch,
                    class: "w-8 h-10 sm:w-9 sm:h-11 inline-flex items-center justify-center rounded-md text-base sm:text-lg font-semibold border bg-blue-50 text-blue-700 border-blue-200 dark:bg-dark-bg-soft dark:text-blue-300 dark:border-blue-900/40 hover:shadow transition",
                    draggable: "true",
                    onDragstart: ($event) => onLetterDragStart(ch, $event)
                  }, toDisplayString$1(ch), 41, _hoisted_34$6);
                }), 128))
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("input", {
              ref_key: "hiddenInput",
              ref: hiddenInput,
              type: "text",
              class: "fixed top-0 left-0 w-px h-px opacity-0",
              tabindex: "-1",
              "aria-hidden": "true",
              autocomplete: "off",
              autocapitalize: "off",
              spellcheck: "false",
              inputmode: "text",
              onBeforeinput: withModifiers(handleBeforeInput, ["stop", "prevent"]),
              onInput: withModifiers(handleInput, ["stop", "prevent"]),
              onKeydown: withModifiers(handleKeydown, ["stop", "prevent"]),
              onCompositionstart: onCompositionStart,
              onCompositionupdate: onCompositionUpdate,
              onCompositionend: onCompositionEnd,
              onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
              onBlur: onHiddenBlur
            }, null, 544)
          ]),
          _ctx.pictionaryAnswered ? (openBlock(), createElementBlock("div", _hoisted_35$6, [
            createBaseVNode("div", {
              class: normalizeClass([
                "inline-flex items-center px-3 py-1 rounded-full text-sm font-medium",
                _ctx.pictionaryCorrect ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300" : "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-300"
              ])
            }, [
              _ctx.pictionaryCorrect ? (openBlock(), createElementBlock("svg", _hoisted_36$5, _cache[10] || (_cache[10] = [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                  "clip-rule": "evenodd"
                }, null, -1)
              ]))) : (openBlock(), createElementBlock("svg", _hoisted_37$4, _cache[11] || (_cache[11] = [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 0 1 1.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 0 1 0-1.414z",
                  "clip-rule": "evenodd"
                }, null, -1)
              ]))),
              createTextVNode(" " + toDisplayString$1(_ctx.pictionaryCorrect ? unref(t)("common.correct", "Correct") : unref(t)("common.incorrect", "Incorrect")), 1)
            ], 2),
            !_ctx.pictionaryCorrect ? (openBlock(), createElementBlock("div", _hoisted_38$4, [
              createBaseVNode("p", _hoisted_39$3, [
                createTextVNode(toDisplayString$1(unref(t)("flashcard.image.correctAnswer", "Correct answer")) + ": ", 1),
                createBaseVNode("span", _hoisted_40$3, toDisplayString$1(_ctx.card?.word), 1)
              ]),
              createBaseVNode("p", _hoisted_41$2, toDisplayString$1(_ctx.card?.meaning), 1)
            ])) : (openBlock(), createElementBlock("div", _hoisted_42$2, [
              createBaseVNode("p", _hoisted_43$2, toDisplayString$1(_ctx.card?.meaning), 1)
            ]))
          ])) : createCommentVNode("", true),
          !_ctx.pictionaryAnswered ? (openBlock(), createElementBlock("p", _hoisted_44$2, toDisplayString$1(props.definitionMode ? dragMode.value ? unref(t)("flashcard.pictionary.dragInstructionDefinition", "Look at the definition above, drag letters into the boxes, then press Enter to check.") : unref(t)("flashcard.pictionary.instructionDefinition", "Look at the definition above, click the boxes and type to fill in the missing letters. Press Enter to check.") : dragMode.value ? unref(t)("flashcard.pictionary.dragInstruction", "Drag letters into the boxes, then press Enter to check.") : unref(t)("flashcard.pictionary.instruction", "Click the boxes and type to fill in the missing letters. Press Enter to check.")), 1)) : createCommentVNode("", true),
          createVNode(unref(FireworkSoundEffect), {
            ref_key: "fireworkEffect",
            ref: fireworkEffect,
            "trigger-firework": triggerFirework.value,
            "trigger-sound": triggerSound.value,
            "is-correct": isCorrectAnswer.value,
            onEffectComplete: resetTriggers
          }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
        ])
      ], 32);
    };
  }
});

const PictionaryMode = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__scopeId", "data-v-66235204"]]);

const PictionaryMode$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: PictionaryMode
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$n = { class: "h-full flex flex-col overflow-hidden" };
const _hoisted_2$k = { class: "mb-4 flex items-center justify-center gap-3" };
const _hoisted_3$j = { class: "px-3 py-1 bg-purple-100 dark:bg-dark-bg-mute text-purple-800 dark:text-purple-300 text-sm font-medium rounded-full" };
const _hoisted_4$h = { class: "flex items-center gap-2" };
const _hoisted_5$g = { class: "text-xs text-gray-600 dark:text-white/70" };
const _hoisted_6$f = { class: "flex-1 flex items-center justify-center mb-4 min-h-0" };
const _hoisted_7$e = {
  key: 0,
  class: "flex items-center justify-center bg-gradient-to-br from-teal-50 to-cyan-50 dark:from-teal-900/30 dark:to-cyan-900/30 rounded-xl p-6 w-full max-w-lg border border-teal-200 dark:border-teal-700/50 shadow-sm"
};
const _hoisted_8$e = { class: "text-center space-y-3" };
const _hoisted_9$e = { class: "max-h-32 overflow-y-auto" };
const _hoisted_10$d = { class: "text-lg font-medium text-gray-900 dark:text-white leading-relaxed" };
const _hoisted_11$d = {
  key: 1,
  class: "relative"
};
const _hoisted_12$d = ["src", "alt"];
const _hoisted_13$d = {
  key: 0,
  class: "absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-dark-bg-mute rounded-lg"
};
const _hoisted_14$d = { class: "text-center" };
const _hoisted_15$b = { class: "text-sm text-gray-500 dark:text-white/60 mt-2" };
const _hoisted_16$b = {
  key: 2,
  class: "flex items-center justify-center bg-gray-100 dark:bg-dark-bg-mute rounded-lg p-8 w-full max-w-sm"
};
const _hoisted_17$b = { class: "text-center" };
const _hoisted_18$b = { class: "text-sm text-gray-500 dark:text-white/60 mt-2" };
const _hoisted_19$b = { class: "flex-shrink-0 mb-4" };
const _hoisted_20$b = { class: "w-full max-w-full overflow-x-auto" };
const _hoisted_21$b = { class: "flex flex-wrap gap-2 xs:gap-1.5 sm:gap-2 md:gap-3 justify-center items-center min-w-fit px-1" };
const _hoisted_22$a = {
  key: 0,
  class: "px-1 text-sm xs:text-base sm:text-lg text-gray-700 dark:text-white/80 select-none"
};
const _hoisted_23$a = ["onClick"];
const _hoisted_24$9 = { class: "tile-face tile-back absolute inset-0 flex items-center justify-center rounded-lg border-2 bg-white dark:bg-dark-bg-soft border-green-400 dark:border-green-500 shadow-lg text-sm xs:text-base sm:text-xl md:text-2xl font-bold text-gray-900 dark:text-white" };
const _hoisted_25$9 = {
  key: 0,
  class: "flex-shrink-0 mb-4"
};
const _hoisted_26$8 = { class: "max-w-md mx-auto" };
const _hoisted_27$8 = { class: "relative" };
const _hoisted_28$8 = ["placeholder", "disabled"];
const _hoisted_29$7 = {
  key: 1,
  class: "text-center space-y-2 max-h-32 overflow-y-auto"
};
const _hoisted_30$6 = {
  key: 0,
  class: "w-4 h-4 mr-1",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_31$6 = {
  key: 1,
  class: "w-4 h-4 mr-1",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_32$5 = {
  key: 0,
  class: "text-center"
};
const _hoisted_33$5 = { class: "text-sm text-gray-600 dark:text-white/70" };
const _hoisted_34$5 = { class: "font-semibold text-gray-900 dark:text-white" };
const _hoisted_35$5 = { class: "text-xs text-gray-500 dark:text-white/60 mt-1 line-clamp-2" };
const _hoisted_36$4 = {
  key: 1,
  class: "text-center"
};
const _hoisted_37$3 = { class: "text-sm text-gray-600 dark:text-white/70 line-clamp-2" };
const _hoisted_38$3 = {
  key: 2,
  class: "text-center text-sm text-gray-500 dark:text-white/60 mt-3"
};
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "FlipTileMode",
  props: {
    card: {},
    flipTileAnswer: {},
    flipTileAnswered: { type: Boolean },
    flipTileCorrect: { type: Boolean },
    getTopicName: { type: Function },
    useHints: { type: Boolean }
  },
  emits: ["update:flip-tile-answer", "check-answer"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const { playAudio } = useVoiceStore();
    const useHints = computed(() => props.useHints ?? true);
    const imageError = ref(false);
    const answerInput = ref(null);
    const userAnswer = ref("");
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const tiles = ref([]);
    const normalizeWord = (w) => w.normalize("NFKC");
    const buildTiles = (word) => {
      const letters = normalizeWord(word);
      const arr = [];
      const isAlpha = (c) => /^[a-z]$/i.test(c);
      for (let i = 0; i < letters.length; i++) {
        const c = letters[i];
        if (!isAlpha(c)) {
          arr.push({ char: c, flipped: true, separator: true });
          continue;
        }
        arr.push({ char: c, flipped: false });
      }
      tiles.value = arr;
    };
    const flippedCount = computed(() => {
      return tiles.value.filter((tile) => tile.flipped && !tile.separator).length;
    });
    const totalLetterTiles = computed(() => tiles.value.filter((tile) => !tile.separator).length);
    const maxFlips = computed(() => totalLetterTiles.value <= 4 ? 1 : 2);
    const canFlipMore = computed(() => flippedCount.value < maxFlips.value);
    const onTileClick = (idx) => {
      const tile = tiles.value[idx];
      if (!tile || tile.separator || tile.flipped || props.flipTileAnswered) return;
      if (canFlipMore.value) {
        tile.flipped = true;
      }
    };
    const onAnswerInput = () => {
      emit("update:flip-tile-answer", userAnswer.value);
    };
    const checkAnswer = () => {
      if (!userAnswer.value.trim()) return;
      emit("check-answer");
    };
    const handleImageError = () => {
      imageError.value = true;
    };
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    watch(() => props.flipTileAnswered, (newVal) => {
      if (newVal) {
        tiles.value.forEach((tile) => {
          if (!tile.separator) tile.flipped = true;
        });
        if (!triggerFirework.value) {
          isCorrectAnswer.value = props.flipTileCorrect;
          setTimeout(() => {
            triggerFirework.value = true;
            triggerSound.value = true;
          }, 50);
        }
      }
      if (newVal && props.flipTileCorrect && props.card?.word) {
        Promise.resolve(playAudio(props.card.word)).catch(() => {
        });
      }
    });
    watch(() => props.card, (c) => {
      imageError.value = false;
      userAnswer.value = "";
      if (c?.word) {
        buildTiles(c.word);
      }
      nextTick(() => {
        answerInput.value?.focus();
      });
    });
    watch(() => props.flipTileAnswer, (newVal) => {
      if (newVal !== userAnswer.value) {
        userAnswer.value = newVal;
      }
    });
    onMounted(() => {
      if (props.card?.word) {
        buildTiles(props.card.word);
      }
      nextTick(() => {
        answerInput.value?.focus();
      });
    });
    const enforceInputFocus = () => {
      if (!props.flipTileAnswered) {
        setTimeout(() => {
          answerInput.value?.focus();
        }, 0);
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-dark-bg-mute p-6 min-h-96 max-h-[560px] select-none",
        onCopy: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[3] || (_cache[3] = withModifiers(() => {
        }, ["prevent"])),
        onMousedown: enforceInputFocus
      }, [
        createBaseVNode("div", _hoisted_1$n, [
          createBaseVNode("div", _hoisted_2$k, [
            createBaseVNode("span", _hoisted_3$j, toDisplayString$1(_ctx.card?.category ? _ctx.getTopicName(_ctx.card.category) : ""), 1),
            createBaseVNode("div", _hoisted_4$h, [
              createBaseVNode("span", _hoisted_5$g, toDisplayString$1(unref(t)("flashcard.flipTile.tilesFlipped", "Tiles flipped")) + ": " + toDisplayString$1(flippedCount.value) + "/" + toDisplayString$1(maxFlips.value), 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_6$f, [
            useHints.value || !_ctx.card?.image ? (openBlock(), createElementBlock("div", _hoisted_7$e, [
              createBaseVNode("div", _hoisted_8$e, [
                _cache[4] || (_cache[4] = createBaseVNode("div", { class: "mx-auto w-12 h-12 bg-teal-100 dark:bg-teal-800/50 rounded-full flex items-center justify-center mb-4" }, [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 text-teal-600 dark:text-teal-400",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    stroke: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                    })
                  ])
                ], -1)),
                createBaseVNode("div", _hoisted_9$e, [
                  createBaseVNode("p", _hoisted_10$d, toDisplayString$1(_ctx.card?.meaning || unref(t)("flashcard.flipTile.noDefinition", "No definition available")), 1)
                ])
              ])
            ])) : !useHints.value && _ctx.card?.image ? (openBlock(), createElementBlock("div", _hoisted_11$d, [
              createBaseVNode("img", {
                src: _ctx.card.image,
                alt: unref(t)("flashcard.flipTile.imageAlt", "Flip tile image"),
                class: "max-w-full max-h-40 object-contain rounded-lg shadow-md border border-gray-200 dark:border-dark-bg-mute filter blur-sm",
                onError: handleImageError
              }, null, 40, _hoisted_12$d),
              imageError.value ? (openBlock(), createElementBlock("div", _hoisted_13$d, [
                createBaseVNode("div", _hoisted_14$d, [
                  _cache[5] || (_cache[5] = createBaseVNode("svg", {
                    class: "mx-auto h-12 w-12 text-gray-400 dark:text-white/50",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    stroke: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 16m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2 2v12a2 2 0 002 2z"
                    })
                  ], -1)),
                  createBaseVNode("p", _hoisted_15$b, toDisplayString$1(unref(t)("flashcard.image.imageError", "Could not load image.")), 1)
                ])
              ])) : createCommentVNode("", true)
            ])) : (openBlock(), createElementBlock("div", _hoisted_16$b, [
              createBaseVNode("div", _hoisted_17$b, [
                _cache[6] || (_cache[6] = createBaseVNode("svg", {
                  class: "mx-auto h-16 w-16 text-gray-400 dark:text-white/50",
                  fill: "none",
                  viewBox: "0 0 24 24",
                  stroke: "currentColor"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 16m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2 2v12a2 2 0 002 2z"
                  })
                ], -1)),
                createBaseVNode("p", _hoisted_18$b, toDisplayString$1(unref(t)("flashcard.flipTile.noContent", "No content available for this card.")), 1)
              ])
            ]))
          ]),
          createBaseVNode("div", _hoisted_19$b, [
            createBaseVNode("div", _hoisted_20$b, [
              createBaseVNode("div", _hoisted_21$b, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(tiles.value, (tile, idx) => {
                  return openBlock(), createElementBlock("div", { key: idx }, [
                    tile.separator ? (openBlock(), createElementBlock("div", _hoisted_22$a, toDisplayString$1(tile.char), 1)) : (openBlock(), createElementBlock("div", {
                      key: 1,
                      class: normalizeClass(["relative w-8 h-10 xs:w-10 xs:h-12 sm:w-12 sm:h-14 md:w-14 md:h-16 transition-all duration-500 tile-3d flex-shrink-0", [{ "cursor-pointer": !tile.flipped && canFlipMore.value }, tile.flipped ? "is-flipped" : "hover:shadow-xl hover:scale-105"]]),
                      onClick: ($event) => onTileClick(idx)
                    }, [
                      _cache[7] || (_cache[7] = createBaseVNode("div", { class: "tile-face absolute inset-0 flex items-center justify-center rounded-lg border-2 bg-gradient-to-br from-blue-500 to-purple-600 dark:from-blue-600 dark:to-purple-700 border-blue-400 dark:border-blue-500 shadow-lg" }, [
                        createBaseVNode("div", { class: "text-white" }, [
                          createBaseVNode("svg", {
                            class: "w-3 h-3 xs:w-4 xs:h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
                            fill: "currentColor",
                            viewBox: "0 0 20 20"
                          }, [
                            createBaseVNode("path", {
                              "fill-rule": "evenodd",
                              d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z",
                              "clip-rule": "evenodd"
                            })
                          ])
                        ])
                      ], -1)),
                      createBaseVNode("div", _hoisted_24$9, toDisplayString$1(tile.char.toUpperCase()), 1)
                    ], 10, _hoisted_23$a))
                  ]);
                }), 128))
              ])
            ])
          ]),
          !_ctx.flipTileAnswered ? (openBlock(), createElementBlock("div", _hoisted_25$9, [
            createBaseVNode("div", _hoisted_26$8, [
              createBaseVNode("div", _hoisted_27$8, [
                withDirectives(createBaseVNode("input", {
                  ref_key: "answerInput",
                  ref: answerInput,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => userAnswer.value = $event),
                  type: "text",
                  placeholder: unref(t)("flashcard.flipTile.answerPlaceholder", "Type your answer..."),
                  class: "w-full px-4 py-3 text-lg font-medium text-center rounded-xl border-2 bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white border-gray-300 dark:border-dark-bg-mute focus:outline-none focus:border-blue-500 dark:focus:border-blue-400 focus:ring-2 focus:ring-blue-200 dark:focus:ring-blue-800/50 transition-all duration-200",
                  disabled: _ctx.flipTileAnswered,
                  onKeydown: withKeys(checkAnswer, ["enter"]),
                  onInput: onAnswerInput
                }, null, 40, _hoisted_28$8), [
                  [vModelText, userAnswer.value]
                ]),
                userAnswer.value.trim() ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  onClick: checkAnswer,
                  class: "absolute right-3 top-1/2 transform -translate-y-1/2 px-3 py-1 bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white text-sm font-medium rounded-lg transition-colors duration-200"
                }, toDisplayString$1(unref(t)("flashcard.flipTile.check", "Check")), 1)) : createCommentVNode("", true)
              ])
            ])
          ])) : createCommentVNode("", true),
          _ctx.flipTileAnswered ? (openBlock(), createElementBlock("div", _hoisted_29$7, [
            createBaseVNode("div", {
              class: normalizeClass([
                "inline-flex items-center px-3 py-1 rounded-full text-sm font-medium",
                _ctx.flipTileCorrect ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300" : "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-300"
              ])
            }, [
              _ctx.flipTileCorrect ? (openBlock(), createElementBlock("svg", _hoisted_30$6, _cache[8] || (_cache[8] = [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                  "clip-rule": "evenodd"
                }, null, -1)
              ]))) : (openBlock(), createElementBlock("svg", _hoisted_31$6, _cache[9] || (_cache[9] = [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                  "clip-rule": "evenodd"
                }, null, -1)
              ]))),
              createTextVNode(" " + toDisplayString$1(_ctx.flipTileCorrect ? unref(t)("common.correct", "Correct") : unref(t)("common.incorrect", "Incorrect")), 1)
            ], 2),
            !_ctx.flipTileCorrect ? (openBlock(), createElementBlock("div", _hoisted_32$5, [
              createBaseVNode("p", _hoisted_33$5, [
                createTextVNode(toDisplayString$1(unref(t)("flashcard.image.correctAnswer", "Correct answer")) + ": ", 1),
                createBaseVNode("span", _hoisted_34$5, toDisplayString$1(_ctx.card?.word), 1)
              ]),
              createBaseVNode("p", _hoisted_35$5, toDisplayString$1(_ctx.card?.meaning), 1)
            ])) : (openBlock(), createElementBlock("div", _hoisted_36$4, [
              createBaseVNode("p", _hoisted_37$3, toDisplayString$1(_ctx.card?.meaning), 1)
            ]))
          ])) : createCommentVNode("", true),
          !_ctx.flipTileAnswered ? (openBlock(), createElementBlock("p", _hoisted_38$3, toDisplayString$1(unref(t)("flashcard.flipTile.instruction", `Click on tiles to reveal letters (max ${maxFlips.value}), then type your answer and press Enter.`)), 1)) : createCommentVNode("", true),
          createVNode(unref(FireworkSoundEffect), {
            ref_key: "fireworkEffect",
            ref: fireworkEffect,
            "trigger-firework": triggerFirework.value,
            "trigger-sound": triggerSound.value,
            "is-correct": isCorrectAnswer.value,
            onEffectComplete: resetTriggers
          }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
        ])
      ], 32);
    };
  }
});

const FlipTileMode = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__scopeId", "data-v-315f8aba"]]);

const FlipTileMode$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: FlipTileMode
}, Symbol.toStringTag, { value: 'Module' }));

class GameStateManager {
  // Game State
  score = ref(0);
  wordsMatched = ref(0);
  gameOver = ref(false);
  bubbles = ref([]);
  shootingBubble = ref(null);
  currentShooterWord = ref("");
  currentShooterColor = ref("#FF6B6B");
  explosions = ref([]);
  particles = ref([]);
  screenShake = ref({ x: 0, y: 0, intensity: 0 });
  aimLine = ref({ visible: false, x: 0, y: 0 });
  shooterPosition = ref({ x: 400, y: 550 });
  rowAnimationActive = ref(false);
  // Private state for color mapping
  wordColorMap = /* @__PURE__ */ new Map();
  COLORS = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7", "#DDA0DD", "#98D8C8", "#FFB347"];
  // Game Management Methods
  resetGame() {
    this.score.value = 0;
    this.wordsMatched.value = 0;
    this.gameOver.value = false;
    this.bubbles.value = [];
    this.shootingBubble.value = null;
    this.explosions.value = [];
    this.particles.value = [];
    this.screenShake.value = { x: 0, y: 0, intensity: 0 };
    this.aimLine.value = { visible: false, x: 0, y: 0 };
    this.currentShooterWord.value = "";
    this.currentShooterColor.value = "#FF6B6B";
  }
  updateScore(points) {
    this.score.value += points;
  }
  incrementWordsMatched() {
    this.wordsMatched.value += 1;
  }
  setGameOver(gameOver) {
    this.gameOver.value = gameOver;
  }
  setRowAnimationActive(active) {
    this.rowAnimationActive.value = active;
  }
  // Bubble Management
  addBubble(bubble) {
    this.bubbles.value.push(bubble);
  }
  removeBubbles(bubbleIds) {
    this.bubbles.value = this.bubbles.value.filter(
      (bubble) => !bubbleIds.includes(bubble.id)
    );
  }
  setShootingBubble(bubble) {
    this.shootingBubble.value = bubble;
  }
  selectNextShooterWord(words) {
    if (words.length > 0) {
      const randomWord = words[Math.floor(Math.random() * words.length)];
      this.currentShooterWord.value = randomWord.word;
      this.currentShooterColor.value = this.getColorForWord(randomWord.word);
    }
  }
  // Visual Effects Management
  updateAimLine(position) {
    if (position) {
      this.aimLine.value = {
        visible: true,
        x: position.x,
        y: position.y
      };
    } else {
      this.aimLine.value.visible = false;
    }
  }
  addExplosion(explosion) {
    this.explosions.value.push(explosion);
  }
  updateExplosions() {
    this.explosions.value.forEach((explosion) => {
      if (!explosion.active) return;
      if (explosion.shockwave.radius < explosion.shockwave.maxRadius) {
        explosion.shockwave.radius += 2;
        explosion.shockwave.intensity = Math.max(0, 1 - explosion.shockwave.radius / explosion.shockwave.maxRadius);
      }
      let activeParticles = 0;
      explosion.particles.forEach((particle) => {
        if (particle.life > 0) {
          particle.x += particle.vx;
          particle.y += particle.vy;
          particle.rotation += particle.rotationSpeed;
          switch (particle.type) {
            case "burst":
              particle.vy += 0.15;
              particle.vx *= 0.96;
              particle.vy *= 0.96;
              particle.life -= 0.025;
              break;
            case "spark":
              particle.vy += 0.05;
              particle.vx *= 0.99;
              particle.vy *= 0.99;
              particle.life -= 0.04;
              break;
            case "glow":
              particle.vy += 0.08;
              particle.vx *= 0.97;
              particle.vy *= 0.97;
              particle.life -= 0.015;
              break;
          }
          activeParticles++;
        }
      });
      if (activeParticles === 0 && explosion.shockwave.radius >= explosion.shockwave.maxRadius) {
        explosion.active = false;
      }
    });
    this.updateScreenShake();
    this.explosions.value = this.explosions.value.filter((explosion) => explosion.active);
  }
  // Screen Shake Management
  addScreenShake(intensity) {
    this.screenShake.value.intensity = Math.max(this.screenShake.value.intensity, intensity);
  }
  updateScreenShake() {
    if (this.screenShake.value.intensity > 0) {
      this.screenShake.value.x = (Math.random() - 0.5) * this.screenShake.value.intensity;
      this.screenShake.value.y = (Math.random() - 0.5) * this.screenShake.value.intensity;
      this.screenShake.value.intensity *= 0.9;
      if (this.screenShake.value.intensity < 0.1) {
        this.screenShake.value.intensity = 0;
        this.screenShake.value.x = 0;
        this.screenShake.value.y = 0;
      }
    }
  }
  // Private helper method for color mapping
  getColorForWord(word) {
    if (!this.wordColorMap.has(word)) {
      let hash = 0;
      for (let i = 0; i < word.length; i++) {
        hash = (hash << 5) - hash + word.charCodeAt(i) & 4294967295;
      }
      const colorIndex = Math.abs(hash) % this.COLORS.length;
      this.wordColorMap.set(word, this.COLORS[colorIndex]);
    }
    return this.wordColorMap.get(word);
  }
}
const useGameStateManager = () => {
  return new GameStateManager();
};

class PhysicsEngine {
  BUBBLE_SIZE = 40;
  COLORS = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7", "#DDA0DD", "#98D8C8", "#FFB347"];
  // Small epsilon to treat tiny gaps as contact to avoid visible spacing
  CONTACT_EPS = 8;
  wordColorMap = /* @__PURE__ */ new Map();
  stateManager;
  constructor(stateManager) {
    this.stateManager = stateManager;
  }
  getColorForWord(word) {
    if (!this.wordColorMap.has(word)) {
      let hash = 0;
      for (let i = 0; i < word.length; i++) {
        hash = (hash << 5) - hash + word.charCodeAt(i) & 4294967295;
      }
      const colorIndex = Math.abs(hash) % this.COLORS.length;
      this.wordColorMap.set(word, this.COLORS[colorIndex]);
    }
    return this.wordColorMap.get(word);
  }
  checkCollision(bubble1, bubble2) {
    const dx = bubble2.x - bubble1.x;
    const dy = bubble2.y - bubble1.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance <= this.BUBBLE_SIZE;
  }
  animateShootingBubble(bubble, vx, vy, onLand, existingBubbles, canvasWidth = 800, canvasHeight = 600) {
    let bounceCount = 0;
    const maxBounces = 3;
    let currentVx = vx;
    let currentVy = vy;
    const animate = () => {
      bubble.x += currentVx;
      bubble.y += currentVy;
      if (existingBubbles) {
        for (const existing of existingBubbles) {
          const isAnimating = this.stateManager?.rowAnimationActive.value;
          const isNewRow = isAnimating && (existing.row ?? 0) < 0;
          const existingX = isNewRow ? existing.x : isAnimating && existing.stableX !== void 0 ? existing.stableX : existing.x;
          const existingY = isNewRow ? this.BUBBLE_SIZE / 2 : isAnimating && existing.stableY !== void 0 ? existing.stableY : existing.y;
          const dx0 = bubble.x - existingX;
          const dy0 = bubble.y - existingY;
          const dist0 = Math.sqrt(dx0 * dx0 + dy0 * dy0);
          const nearThreshold = this.BUBBLE_SIZE + this.CONTACT_EPS;
          const approaching = dx0 * currentVx + dy0 * currentVy <= 0;
          if (dist0 <= nearThreshold && approaching) {
            console.log("Collision/near-contact detected! Computing tangent and triple-contact placement");
            let dx = dx0;
            let dy = dy0;
            let dist = dist0;
            if (dist < 0.01) {
              dx = -currentVx || 0;
              dy = -currentVy || -1;
              const norm = Math.sqrt(dx * dx + dy * dy) || 1;
              dx /= norm;
              dy /= norm;
            } else {
              dx /= dist;
              dy /= dist;
            }
            const tangentX = existingX + dx * this.BUBBLE_SIZE;
            const tangentY = existingY + dy * this.BUBBLE_SIZE;
            bubble.x = tangentX;
            bubble.y = tangentY;
            if (existingBubbles) {
              this.snapToGrid(bubble, existingBubbles);
              this.forceToNearestFreeSeat(bubble, existingBubbles, canvasWidth, canvasHeight);
            } else {
              const verticalSpacing = this.BUBBLE_SIZE * Math.sqrt(3) / 2;
              const baseX = this.BUBBLE_SIZE / 2;
              const baseY = this.BUBBLE_SIZE / 2;
              bubble.row = Math.max(0, Math.round((bubble.y - baseY) / verticalSpacing));
              bubble.col = Math.max(0, Math.round((bubble.x - baseX) / this.BUBBLE_SIZE));
            }
            currentVx = 0;
            currentVy = 0;
            onLand(bubble);
            return;
          }
        }
      }
      if (bubble.x <= this.BUBBLE_SIZE / 2 || bubble.x >= canvasWidth - this.BUBBLE_SIZE / 2) {
        currentVx = -currentVx * 0.8;
        bounceCount++;
        bubble.x = Math.max(this.BUBBLE_SIZE / 2, Math.min(canvasWidth - this.BUBBLE_SIZE / 2, bubble.x));
      }
      if (bubble.y <= this.BUBBLE_SIZE / 2) {
        bubble.y = this.BUBBLE_SIZE / 2;
        const baseX = this.BUBBLE_SIZE / 2;
        const targetCol = Math.round((bubble.x - baseX) / this.BUBBLE_SIZE);
        bubble.x = baseX + targetCol * this.BUBBLE_SIZE;
        bubble.row = 0;
        bubble.col = Math.max(0, targetCol);
        currentVy = 0;
        bounceCount = maxBounces;
      }
      if (bubble.y >= canvasHeight - this.BUBBLE_SIZE / 2) {
        bubble.y = canvasHeight - this.BUBBLE_SIZE / 2;
        currentVy = 0;
        bounceCount = maxBounces;
      }
      if (bounceCount > 0 && currentVy > 2) {
        currentVy += 0.05;
      }
      const slowMoving = Math.abs(currentVx) < 3 && Math.abs(currentVy) < 3;
      const nearLeftWall = bubble.x <= this.BUBBLE_SIZE / 2 + 20;
      const nearRightWall = bubble.x >= canvasWidth - this.BUBBLE_SIZE / 2 - 20;
      const nearTopWall = bubble.y <= this.BUBBLE_SIZE / 2 + 20;
      const stickToWall = bounceCount > 0 && (slowMoving && (nearLeftWall || nearRightWall) || nearTopWall && Math.abs(currentVy) < 2);
      if (bubble.y <= this.BUBBLE_SIZE / 2 && currentVy <= 0 || bounceCount >= maxBounces || stickToWall) {
        if (existingBubbles && existingBubbles.length > 0) {
          const captureRadius = this.BUBBLE_SIZE + this.CONTACT_EPS;
          let nearest = null;
          let bestDist = Number.POSITIVE_INFINITY;
          for (const b of existingBubbles) {
            const isAnimating = this.stateManager?.rowAnimationActive.value;
            const isNewRow = isAnimating && (b.row ?? 0) < 0;
            const bx = isNewRow ? b.x : isAnimating && b.stableX !== void 0 ? b.stableX : b.x;
            const by = isNewRow ? this.BUBBLE_SIZE / 2 : isAnimating && b.stableY !== void 0 ? b.stableY : b.y;
            const dx = bubble.x - bx;
            const dy = bubble.y - by;
            const d = Math.sqrt(dx * dx + dy * dy);
            const dot = dx * currentVx + dy * currentVy;
            if (dot > 0) continue;
            if (d < captureRadius && d < bestDist) {
              nearest = b;
              bestDist = d;
            }
          }
          if (nearest) {
            const isAnimating2 = this.stateManager?.rowAnimationActive.value;
            const isNewRow2 = isAnimating2 && (nearest.row ?? 0) < 0;
            const nx = isNewRow2 ? nearest.x : isAnimating2 && nearest.stableX !== void 0 ? nearest.stableX : nearest.x;
            const ny = isNewRow2 ? this.BUBBLE_SIZE / 2 : isAnimating2 && nearest.stableY !== void 0 ? nearest.stableY : nearest.y;
            let ndx = bubble.x - nx;
            let ndy = bubble.y - ny;
            const nlen = Math.sqrt(ndx * ndx + ndy * ndy) || 1;
            ndx /= nlen;
            ndy /= nlen;
            const tangentX = nx + ndx * this.BUBBLE_SIZE;
            const tangentY = ny + ndy * this.BUBBLE_SIZE;
            const triple = this.findTripleContactPosition(
              nearest,
              existingBubbles,
              { x: tangentX, y: tangentY },
              canvasWidth,
              canvasHeight
            );
            const finalX = triple ? triple.x : tangentX;
            const finalY = triple ? triple.y : tangentY;
            bubble.x = finalX;
            bubble.y = finalY;
            this.snapToGrid(bubble, existingBubbles);
            this.forceToNearestFreeSeat(bubble, existingBubbles, canvasWidth, canvasHeight);
            onLand(bubble);
            return;
          }
        }
        onLand(bubble);
        return;
      }
      requestAnimationFrame(animate);
    };
    animate();
  }
  // Attempt to find a position where the new bubble touches the collided bubble
  // and one of its neighbors simultaneously (triple-contact). Returns null if none valid.
  findTripleContactPosition(collided, existingBubbles, tangentPoint, canvasWidth, canvasHeight) {
    const R = this.BUBBLE_SIZE;
    const rWall = this.BUBBLE_SIZE / 2;
    const intersections = (ax, ay, bx, by) => {
      const dx = bx - ax;
      const dy = by - ay;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < 1e-6 || d > 2 * R) return [];
      const a = d / 2;
      const h2 = R * R - a * a;
      if (h2 < -1e-6) return [];
      const h = h2 > 0 ? Math.sqrt(Math.max(0, h2)) : 0;
      const mx = ax + a * dx / d;
      const my = ay + a * dy / d;
      const rx = -dy * h / d;
      const ry = dx * h / d;
      return [
        { x: mx + rx, y: my + ry },
        { x: mx - rx, y: my - ry }
      ];
    };
    const inBounds = (x, y) => x >= rWall && x <= canvasWidth - rWall && y >= rWall && y <= canvasHeight - rWall;
    const positionFree = (x, y) => {
      for (const b of existingBubbles) {
        const dx = b.x - x;
        const dy = b.y - y;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < this.BUBBLE_SIZE - 0.1) return false;
      }
      return true;
    };
    const neighbors = existingBubbles.filter((b) => b !== collided).filter((b) => {
      const dx = b.x - collided.x;
      const dy = b.y - collided.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      return d > 0.5 * this.BUBBLE_SIZE && d < 1.5 * this.BUBBLE_SIZE;
    });
    let best = null;
    let bestScore = Number.POSITIVE_INFINITY;
    for (const nb of neighbors) {
      const pts = intersections(collided.x, collided.y, nb.x, nb.y);
      for (const p of pts) {
        if (!inBounds(p.x, p.y)) continue;
        if (!positionFree(p.x, p.y)) continue;
        const dx = p.x - tangentPoint.x;
        const dy = p.y - tangentPoint.y;
        const score = dx * dx + dy * dy;
        if (score < bestScore) {
          best = p;
          bestScore = score;
        }
      }
    }
    return best;
  }
  // Quantize the dynamic baseY to the nearest valid grid line to stabilize row/column mapping
  getQuantizedBaseY(existingBubbles) {
    if (!existingBubbles || existingBubbles.length === 0) return this.BUBBLE_SIZE / 2;
    const verticalSpacing = this.BUBBLE_SIZE * Math.sqrt(3) / 2;
    const baseRef = this.BUBBLE_SIZE / 2;
    const isAnimating = this.stateManager?.rowAnimationActive.value;
    if (isAnimating) {
      const stableRowBubbles = existingBubbles.filter((b) => (b.row ?? 0) >= 0);
      if (stableRowBubbles.length === 0) return baseRef;
      const minRow = Math.min(...stableRowBubbles.map((b) => b.row ?? 0));
      const quantized = baseRef + minRow * verticalSpacing;
      console.log("getQuantizedBaseY (ANIMATION): minRow =", minRow, "quantized baseY =", quantized);
      return quantized;
    } else {
      const minRow = Math.min(...existingBubbles.map((b) => b.row ?? 0));
      const quantized = baseRef + minRow * verticalSpacing;
      console.log("getQuantizedBaseY (NORMAL): minRow =", minRow, "quantized baseY =", quantized);
      return quantized;
    }
  }
  // Compute the pixel center for a given grid seat (row, col)
  getSeatCenter(row, col, existingBubbles) {
    const verticalSpacing = this.BUBBLE_SIZE * Math.sqrt(3) / 2;
    const baseX = this.BUBBLE_SIZE / 2;
    const baseY = this.getQuantizedBaseY(existingBubbles);
    const topOffset = this.getTopRowOffset(existingBubbles);
    const rowOffset = row % 2 === 0 ? topOffset : topOffset === 0 ? this.BUBBLE_SIZE / 2 : 0;
    const x = baseX + rowOffset + col * this.BUBBLE_SIZE;
    const y = baseY + row * verticalSpacing;
    return { x, y };
  }
  // Infer the current top-row horizontal offset (0 or B/2) from existing row-0 bubbles
  // Uses stableX during row animation to avoid drift.
  getTopRowOffset(existingBubbles) {
    const B = this.BUBBLE_SIZE;
    const baseX = B / 2;
    const isAnimating = this.stateManager?.rowAnimationActive.value;
    const row0 = existingBubbles.filter((b) => (b.row ?? 0) === 0);
    if (row0.length === 0) return 0;
    let sumEven = 0;
    let sumOdd = 0;
    for (const b of row0) {
      const bx = isAnimating && b.stableX !== void 0 ? b.stableX : b.x;
      const nearestEven = baseX + Math.round((bx - baseX) / B) * B;
      const nearestOdd = baseX + B / 2 + Math.round((bx - (baseX + B / 2)) / B) * B;
      sumEven += Math.abs(bx - nearestEven);
      sumOdd += Math.abs(bx - nearestOdd);
    }
    return sumEven <= sumOdd ? 0 : B / 2;
  }
  // Check if a seat (by center coords) is already occupied by an existing bubble
  isSeatOccupied(x, y, existingBubbles) {
    const seatTol = 0.25;
    const isAnimating = this.stateManager?.rowAnimationActive.value;
    for (const b of existingBubbles) {
      const bubbleX = isAnimating && b.stableX !== void 0 ? b.stableX : b.x;
      const bubbleY = isAnimating && b.stableY !== void 0 ? b.stableY : b.y;
      const dx = bubbleX - x;
      const dy = bubbleY - y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d <= seatTol) return true;
    }
    return false;
  }
  // Force bubble to its computed seat or the nearest free seat to avoid overlaps/mis-seating
  forceToNearestFreeSeat(bubble, existingBubbles, canvasWidth, canvasHeight) {
    const rWall = this.BUBBLE_SIZE / 2;
    const inBounds = (x, y) => x >= rWall && x <= canvasWidth - rWall && y >= rWall && y <= canvasHeight - rWall;
    let center = this.getSeatCenter(bubble.row, bubble.col, existingBubbles);
    if (inBounds(center.x, center.y) && !this.isSeatOccupied(center.x, center.y, existingBubbles)) {
      bubble.x = center.x;
      bubble.y = center.y;
      return;
    }
    let best = null;
    let bestScore = Number.POSITIVE_INFINITY;
    const MAX_DELTA = 2;
    for (let dr = -MAX_DELTA; dr <= MAX_DELTA; dr++) {
      const rr = Math.max(0, bubble.row + dr);
      for (let dc = -MAX_DELTA; dc <= MAX_DELTA; dc++) {
        const cc = Math.max(0, bubble.col + dc);
        center = this.getSeatCenter(rr, cc, existingBubbles);
        if (!inBounds(center.x, center.y)) continue;
        if (this.isSeatOccupied(center.x, center.y, existingBubbles)) continue;
        const dx = center.x - bubble.x;
        const dy = center.y - bubble.y;
        const score = dx * dx + dy * dy;
        if (score < bestScore) {
          bestScore = score;
          best = { row: rr, col: cc, x: center.x, y: center.y };
        }
      }
    }
    if (best) {
      bubble.row = best.row;
      bubble.col = best.col;
      bubble.x = best.x;
      bubble.y = best.y;
    } else {
      bubble.x = Math.max(rWall, Math.min(canvasWidth - rWall, center.x));
      bubble.y = Math.max(rWall, Math.min(canvasHeight - rWall, center.y));
    }
  }
  snapToGrid(bubble, existingBubbles) {
    console.log("Snapping bubble to grid. Current position:", bubble.x, bubble.y);
    const verticalSpacing = this.BUBBLE_SIZE * Math.sqrt(3) / 2;
    const baseX = this.BUBBLE_SIZE / 2;
    const baseY = this.getQuantizedBaseY(existingBubbles);
    const targetRow = Math.max(0, Math.round((bubble.y - baseY) / verticalSpacing));
    const topOffset = this.getTopRowOffset(existingBubbles);
    const offsetX = targetRow % 2 === 0 ? topOffset : topOffset === 0 ? this.BUBBLE_SIZE / 2 : 0;
    const targetCol = Math.max(0, Math.round((bubble.x - baseX - offsetX) / this.BUBBLE_SIZE));
    bubble.row = targetRow;
    bubble.col = targetCol;
    console.log("Grid coordinates assigned:", `row=${bubble.row}, col=${bubble.col}`, "Position preserved:", bubble.x, bubble.y);
  }
  lightenColor(color, amount) {
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * amount * 100);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 255) + amt;
    const B = (num & 255) + amt;
    return "#" + (16777216 + (R < 255 ? R < 1 ? 0 : R : 255) * 65536 + (G < 255 ? G < 1 ? 0 : G : 255) * 256 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
  }
}
const usePhysicsEngine = (stateManager) => {
  return new PhysicsEngine(stateManager);
};

class VisualEffects {
  BUBBLE_SIZE = 40;
  createBounceEffect(x, y) {
    const particlesArray = [];
    for (let i = 0; i < 4; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 1 + Math.random() * 2;
      particlesArray.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 1 + Math.random(),
        color: "#87CEEB",
        life: 0.5,
        maxLife: 0.5,
        type: "spark",
        rotation: 0,
        rotationSpeed: 0
      });
    }
    return {
      x,
      y,
      particles: particlesArray,
      active: true,
      shockwave: {
        radius: 0,
        maxRadius: this.BUBBLE_SIZE / 3,
        intensity: 0.3
      }
    };
  }
  createImpactEffect(x, y, color) {
    const particlesArray = [];
    for (let i = 0; i < 6; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 2 + Math.random() * 3;
      particlesArray.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 2 + Math.random() * 3,
        color,
        life: 0.8,
        maxLife: 0.8,
        type: "burst",
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.2
      });
    }
    return {
      x,
      y,
      particles: particlesArray,
      active: true,
      shockwave: {
        radius: 0,
        maxRadius: this.BUBBLE_SIZE,
        intensity: 0.6
      }
    };
  }
  createExplosion(x, y, color) {
    const particlesArray = [];
    for (let i = 0; i < 15; i++) {
      const angle = Math.PI * 2 * i / 15;
      const speed = 3 + Math.random() * 5;
      particlesArray.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 4 + Math.random() * 6,
        color,
        life: 1,
        maxLife: 1,
        type: "burst",
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.3
      });
    }
    for (let i = 0; i < 8; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 6 + Math.random() * 4;
      particlesArray.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 1 + Math.random() * 2,
        color: "#FFD700",
        life: 0.8,
        maxLife: 0.8,
        type: "spark",
        rotation: 0,
        rotationSpeed: 0
      });
    }
    for (let i = 0; i < 5; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 1 + Math.random() * 2;
      particlesArray.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 8 + Math.random() * 4,
        color: this.lightenColor(color, 0.3),
        life: 1.2,
        maxLife: 1.2,
        type: "glow",
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.1
      });
    }
    return {
      x,
      y,
      particles: particlesArray,
      active: true,
      shockwave: {
        radius: 0,
        maxRadius: this.BUBBLE_SIZE * 2,
        intensity: 1
      }
    };
  }
  updateParticles(particles) {
    particles.forEach((particle) => {
      if (particle.life > 0) {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.rotation += particle.rotationSpeed;
        switch (particle.type) {
          case "burst":
            particle.vy += 0.15;
            particle.vx *= 0.96;
            particle.vy *= 0.96;
            particle.life -= 0.025;
            break;
          case "spark":
            particle.vy += 0.05;
            particle.vx *= 0.99;
            particle.vy *= 0.99;
            particle.life -= 0.04;
            break;
          case "glow":
            particle.vy += 0.08;
            particle.vx *= 0.97;
            particle.vy *= 0.97;
            particle.life -= 0.015;
            break;
        }
      }
    });
  }
  lightenColor(color, amount) {
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * amount * 100);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 255) + amt;
    const B = (num & 255) + amt;
    return "#" + (16777216 + (R < 255 ? R < 1 ? 0 : R : 255) * 65536 + (G < 255 ? G < 1 ? 0 : G : 255) * 256 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
  }
}
const useVisualEffects = () => {
  return new VisualEffects();
};

class CanvasRenderer {
  canvasWidth = ref(800);
  canvasHeight = ref(600);
  gameCanvas = ref();
  ctx = null;
  BUBBLE_SIZE = 40;
  initializeCanvas() {
    if (!this.gameCanvas.value) return false;
    const canvas = this.gameCanvas.value;
    this.ctx = canvas.getContext("2d");
    if (!this.ctx) return false;
    const container = canvas.parentElement;
    if (container) {
      this.canvasWidth.value = container.clientWidth;
      this.canvasHeight.value = container.clientHeight;
      canvas.width = this.canvasWidth.value;
      canvas.height = this.canvasHeight.value;
    }
    return true;
  }
  setCanvasSize(width, height) {
    this.canvasWidth.value = width;
    this.canvasHeight.value = height;
    if (this.gameCanvas.value) {
      this.gameCanvas.value.width = width;
      this.gameCanvas.value.height = height;
    }
  }
  clearCanvas() {
    if (!this.ctx) return;
    this.ctx.clearRect(0, 0, this.canvasWidth.value, this.canvasHeight.value);
  }
  drawBackground() {
    if (!this.ctx) return;
    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvasHeight.value);
    gradient.addColorStop(0, "#1a1a2e");
    gradient.addColorStop(1, "#16213e");
    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.canvasWidth.value, this.canvasHeight.value);
  }
  drawBubble(bubble) {
    if (!this.ctx) return;
    const cx = Math.round(bubble.x * 2) / 2;
    const cy = Math.round(bubble.y * 2) / 2;
    const r = this.BUBBLE_SIZE / 2 - 1;
    this.ctx.save();
    this.ctx.shadowColor = bubble.color;
    this.ctx.shadowBlur = 6;
    const gradient = this.ctx.createRadialGradient(
      cx - this.BUBBLE_SIZE / 6,
      cy - this.BUBBLE_SIZE / 6,
      0,
      cx,
      cy,
      r
    );
    gradient.addColorStop(0, this.lightenColor(bubble.color, 0.3));
    gradient.addColorStop(1, bubble.color);
    this.ctx.fillStyle = gradient;
    this.ctx.beginPath();
    this.ctx.arc(cx, cy, r, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.strokeStyle = "#fff";
    this.ctx.lineWidth = 2;
    this.ctx.stroke();
    this.ctx.strokeStyle = "rgba(255,255,255,0.4)";
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.arc(cx, cy, r - 3, 0, Math.PI * 2);
    this.ctx.stroke();
    this.ctx.restore();
    this.ctx.save();
    this.ctx.shadowColor = "rgba(0,0,0,0.7)";
    this.ctx.shadowBlur = 3;
    this.ctx.shadowOffsetX = 1;
    this.ctx.shadowOffsetY = 1;
    this.ctx.fillStyle = "#fff";
    this.ctx.font = "bold 16px Arial";
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "middle";
    const text = bubble.displayText || bubble.word.charAt(0).toUpperCase();
    if (bubble.isBomb) {
      const time = Date.now() / 1e3;
      const pulse = 0.9 + 0.1 * Math.sin(time * 8);
      this.ctx.save();
      this.ctx.scale(pulse, pulse);
      this.ctx.fillStyle = "#FFA500";
      this.ctx.font = "bold 22px Arial";
      this.ctx.fillText("💣", cx / pulse, (cy - 2) / pulse);
      this.ctx.restore();
      this.ctx.fillStyle = "#fff";
      this.ctx.font = "bold 10px Arial";
      this.ctx.fillText(text, cx, cy + 14);
      this.ctx.strokeStyle = "#FF4444";
      this.ctx.lineWidth = 2;
      this.ctx.setLineDash([5, 5]);
      this.ctx.beginPath();
      this.ctx.arc(cx, cy, r + 5, 0, Math.PI * 2);
      this.ctx.stroke();
      this.ctx.setLineDash([]);
    } else {
      this.ctx.fillText(text, cx, cy);
    }
    this.ctx.restore();
  }
  drawShooter(position, word, color, displayText) {
    if (!this.ctx) return;
    this.ctx.save();
    const pulseIntensity = 0.8 + 0.2 * Math.sin(Date.now() * 8e-3);
    this.ctx.shadowColor = color;
    this.ctx.shadowBlur = 15 * pulseIntensity;
    const gradient = this.ctx.createRadialGradient(
      position.x - this.BUBBLE_SIZE / 6,
      position.y - this.BUBBLE_SIZE / 6,
      0,
      position.x,
      position.y,
      this.BUBBLE_SIZE / 2
    );
    gradient.addColorStop(0, color);
    gradient.addColorStop(1, color);
    this.ctx.fillStyle = gradient;
    this.ctx.beginPath();
    this.ctx.arc(position.x, position.y, this.BUBBLE_SIZE / 2, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.strokeStyle = "#fff";
    this.ctx.lineWidth = 3;
    this.ctx.stroke();
    this.ctx.strokeStyle = "rgba(255,255,255,0.3)";
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.arc(position.x, position.y, this.BUBBLE_SIZE / 2 - 4, 0, Math.PI * 2);
    this.ctx.stroke();
    this.ctx.restore();
    this.ctx.save();
    this.ctx.shadowColor = "rgba(0,0,0,0.8)";
    this.ctx.shadowBlur = 4;
    this.ctx.shadowOffsetX = 1;
    this.ctx.shadowOffsetY = 1;
    this.ctx.fillStyle = "#fff";
    this.ctx.font = "bold 18px Arial";
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "middle";
    const text = displayText || word.charAt(0).toUpperCase();
    this.ctx.fillText(text, position.x, position.y);
    this.ctx.restore();
  }
  drawShootingBubble(bubble) {
    if (!this.ctx) return;
    this.ctx.save();
    this.ctx.shadowColor = bubble.color;
    this.ctx.shadowBlur = 15;
    const pulseIntensity = 0.98 + 0.02 * Math.sin(Date.now() * 0.01);
    const sx = Math.round(bubble.x * 2) / 2;
    const sy = Math.round(bubble.y * 2) / 2;
    const r0 = this.BUBBLE_SIZE / 2 - 1;
    const gradient = this.ctx.createRadialGradient(
      sx - this.BUBBLE_SIZE / 5,
      sy - this.BUBBLE_SIZE / 5,
      0,
      sx,
      sy,
      r0
    );
    gradient.addColorStop(0, this.lightenColor(bubble.color, 0.5));
    gradient.addColorStop(1, bubble.color);
    this.ctx.fillStyle = gradient;
    this.ctx.beginPath();
    this.ctx.arc(sx, sy, r0 * pulseIntensity, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.strokeStyle = "#fff";
    this.ctx.lineWidth = 3;
    this.ctx.stroke();
    this.ctx.strokeStyle = "rgba(255,255,255,0.6)";
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.arc(sx, sy, (r0 - 3) * pulseIntensity, 0, Math.PI * 2);
    this.ctx.stroke();
    this.ctx.restore();
    this.ctx.save();
    this.ctx.shadowColor = "rgba(0,0,0,0.9)";
    this.ctx.shadowBlur = 5;
    this.ctx.shadowOffsetX = 1;
    this.ctx.shadowOffsetY = 1;
    this.ctx.fillStyle = "#fff";
    this.ctx.font = "bold 17px Arial";
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "middle";
    const text = bubble.displayText || bubble.word.charAt(0).toUpperCase();
    this.ctx.fillText(text, sx, sy);
    this.ctx.restore();
  }
  drawExplosions(explosions) {
    if (!this.ctx) return;
    explosions.forEach((explosion) => {
      if (!explosion.active || !this.ctx) return;
      if (explosion.shockwave.intensity > 0) {
        this.ctx.save();
        this.ctx.globalAlpha = explosion.shockwave.intensity * 0.3;
        this.ctx.strokeStyle = "#FFD700";
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(explosion.x, explosion.y, explosion.shockwave.radius, 0, Math.PI * 2);
        this.ctx.stroke();
        this.ctx.restore();
      }
      explosion.particles.forEach((particle) => {
        if (particle.life <= 0 || !this.ctx) return;
        const alpha = particle.life / particle.maxLife;
        this.ctx.save();
        this.ctx.translate(particle.x, particle.y);
        this.ctx.rotate(particle.rotation);
        this.ctx.globalAlpha = alpha;
        switch (particle.type) {
          case "burst":
            this.ctx.shadowColor = particle.color;
            this.ctx.shadowBlur = particle.size * 2;
            this.ctx.fillStyle = particle.color;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, particle.size * alpha, 0, Math.PI * 2);
            this.ctx.fill();
            break;
          case "spark":
            this.ctx.strokeStyle = particle.color;
            this.ctx.lineWidth = particle.size * alpha;
            this.ctx.lineCap = "round";
            this.ctx.beginPath();
            this.ctx.moveTo(-particle.size, 0);
            this.ctx.lineTo(particle.size, 0);
            this.ctx.stroke();
            break;
          case "glow":
            const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, particle.size * alpha);
            gradient.addColorStop(0, particle.color);
            gradient.addColorStop(1, "transparent");
            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, particle.size * alpha, 0, Math.PI * 2);
            this.ctx.fill();
            break;
        }
        this.ctx.restore();
      });
    });
  }
  drawAimLine(aimLine, shooterPosition) {
    if (!this.ctx || !aimLine.visible) return;
    const ctx = this.ctx;
    ctx.strokeStyle = "rgba(255,255,255,0.8)";
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    const leftX = this.BUBBLE_SIZE / 2;
    const rightX = this.canvasWidth.value - this.BUBBLE_SIZE / 2;
    const topY = this.BUBBLE_SIZE / 2;
    let px = shooterPosition.x;
    let py = shooterPosition.y;
    let vx = aimLine.x - shooterPosition.x;
    let vy = aimLine.y - shooterPosition.y;
    const len = Math.sqrt(vx * vx + vy * vy) || 1;
    vx /= len;
    vy /= len;
    if (vy > -0.01) vy = -0.01;
    ctx.beginPath();
    ctx.moveTo(px, py);
    let bounces = 0;
    const maxBounces = 2;
    let safeGuard = 0;
    while (bounces <= maxBounces && safeGuard++ < 10) {
      const tTop = (topY - py) / vy;
      let tWall = Number.POSITIVE_INFINITY;
      let wallX = px;
      if (vx > 0) {
        tWall = (rightX - px) / vx;
        wallX = rightX;
      } else if (vx < 0) {
        tWall = (leftX - px) / vx;
        wallX = leftX;
      }
      const tMin = Math.min(
        tTop > 0 ? tTop : Number.POSITIVE_INFINITY,
        tWall > 0 ? tWall : Number.POSITIVE_INFINITY
      );
      const nx = px + vx * tMin;
      const ny = py + vy * tMin;
      ctx.lineTo(nx, ny);
      if (tTop > 0 && tTop <= tMin + 1e-6) {
        break;
      }
      px = wallX;
      py = ny;
      vx = -vx;
      bounces++;
      ctx.moveTo(px, py);
    }
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.shadowColor = "#fff";
    ctx.shadowBlur = 10;
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
  lightenColor(color, amount) {
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * amount * 100);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 255) + amt;
    const B = (num & 255) + amt;
    return "#" + (16777216 + (R < 255 ? R < 1 ? 0 : R : 255) * 65536 + (G < 255 ? G < 1 ? 0 : G : 255) * 256 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
  }
}
const useCanvasRenderer = () => {
  return new CanvasRenderer();
};

class InputHandler {
  updateAim(event, canvas) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mouseX = (event.clientX - rect.left) * scaleX;
    const mouseY = (event.clientY - rect.top) * scaleY;
    console.log(`Mouse: ${event.clientX}, ${event.clientY} | Canvas: ${mouseX}, ${mouseY} | Scale: ${scaleX.toFixed(2)}, ${scaleY.toFixed(2)}`);
    const shooterX = canvas.width / 2;
    const shooterY = canvas.height - 50;
    const dx = mouseX - shooterX;
    const dy = mouseY - shooterY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (mouseY < shooterY - 20 && distance > 20) {
      return {
        x: mouseX,
        y: mouseY
      };
    }
    return null;
  }
  getShootingVector(event, canvas, shooterPosition) {
    const rect = canvas.getBoundingClientRect();
    if (!rect) return null;
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const targetX = (event.clientX - rect.left) * scaleX;
    const targetY = (event.clientY - rect.top) * scaleY;
    console.log(`Shooting at: ${targetX}, ${targetY} (scaled from ${event.clientX}, ${event.clientY})`);
    const BUBBLE_SIZE = 40;
    const leftX = BUBBLE_SIZE / 2;
    const rightX = canvas.width - BUBBLE_SIZE / 2;
    const topY = BUBBLE_SIZE / 2;
    let vx = targetX - shooterPosition.x;
    let vy = targetY - shooterPosition.y;
    const len0 = Math.sqrt(vx * vx + vy * vy) || 1;
    vx /= len0;
    vy /= len0;
    if (vy > -0.01) vy = -0.01;
    let px = shooterPosition.x;
    let py = shooterPosition.y;
    let bounces = 0;
    const maxBounces = 2;
    let endX = targetX;
    let endY = targetY;
    while (bounces <= maxBounces) {
      const tTop = (topY - py) / vy;
      let tWall = Number.POSITIVE_INFINITY;
      if (vx > 0) {
        tWall = (rightX - px) / vx;
      } else if (vx < 0) {
        tWall = (leftX - px) / vx;
      }
      const tMin = Math.min(
        tTop > 0 ? tTop : Number.POSITIVE_INFINITY,
        tWall > 0 ? tWall : Number.POSITIVE_INFINITY
      );
      endX = px + vx * tMin;
      endY = py + vy * tMin;
      break;
    }
    const dx = endX - shooterPosition.x;
    const dy = endY - shooterPosition.y;
    const distance = Math.sqrt(dx * dx + dy * dy) || 1;
    const speed = 8;
    const normalizedDx = dx / distance * speed;
    const normalizedDy = dy / distance * speed;
    console.log(`Direction (reflected): dx=${normalizedDx.toFixed(2)}, dy=${normalizedDy.toFixed(2)}`);
    return { vx: normalizedDx, vy: normalizedDy };
  }
}
const useInputHandler = () => {
  return new InputHandler();
};

class GameLogic {
  BUBBLE_SIZE = 40;
  COLORS = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7", "#DDA0DD", "#98D8C8", "#FFB347"];
  checkForMatches(newBubble, bubbles) {
    console.log("Checking matches for bubble:", newBubble.word, newBubble.x, newBubble.y);
    const visited = /* @__PURE__ */ new Set();
    const connectedBubbles = [];
    const findConnected = (bubble) => {
      if (visited.has(bubble.id)) return;
      visited.add(bubble.id);
      connectedBubbles.push(bubble);
      console.log("Found connected bubble:", bubble.word, bubble.x, bubble.y);
      bubbles.forEach((other) => {
        if (other.id !== bubble.id && !visited.has(other.id) && other.word === bubble.word) {
          const dx = other.x - bubble.x;
          const dy = other.y - bubble.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          console.log(`Distance between ${bubble.word} and ${other.word}: ${distance}, BUBBLE_SIZE: ${this.BUBBLE_SIZE}`);
          if (distance <= this.BUBBLE_SIZE * 1.2) {
            console.log("Found adjacent bubble:", other.word, other.x, other.y);
            findConnected(other);
          }
        }
      });
    };
    findConnected(newBubble);
    console.log(`Found ${connectedBubbles.length} connected bubbles:`, connectedBubbles.map((b) => b.word));
    const shouldRemove = connectedBubbles.length >= 3;
    if (shouldRemove) {
      console.log("MATCH FOUND! Removing bubbles:", connectedBubbles.map((b) => b.word));
    } else {
      console.log("No match - not enough connected bubbles");
    }
    return {
      matchedBubbles: connectedBubbles,
      shouldRemove
    };
  }
  removeFloatingBubbles(bubbles) {
    const topConnected = /* @__PURE__ */ new Set();
    const markTopConnected = (bubble) => {
      if (topConnected.has(bubble.id)) return;
      topConnected.add(bubble.id);
      bubbles.forEach((other) => {
        if (other.id !== bubble.id && !topConnected.has(other.id)) {
          const dx = other.x - bubble.x;
          const dy = other.y - bubble.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance <= this.BUBBLE_SIZE * 1.1) {
            markTopConnected(other);
          }
        }
      });
    };
    bubbles.forEach((bubble) => {
      if (bubble.row === 0) {
        markTopConnected(bubble);
      }
    });
    const remainingBubbles = bubbles.filter((bubble) => topConnected.has(bubble.id));
    const removedBubbles = bubbles.filter((bubble) => !topConnected.has(bubble.id));
    return {
      remainingBubbles,
      removedBubbles
    };
  }
  setupInitialBubbles(words, vietnameseMode = false) {
    const bubbles = [];
    const verticalSpacing = this.BUBBLE_SIZE * Math.sqrt(3) / 2;
    const baseX = this.BUBBLE_SIZE / 2;
    const baseY = this.BUBBLE_SIZE / 2;
    const bubblesPerRow = 8;
    for (let i = 0; i < words.length; i++) {
      const row = Math.floor(i / bubblesPerRow);
      const col = i % bubblesPerRow;
      const offsetX = row % 2 === 0 ? 0 : this.BUBBLE_SIZE / 2;
      const x = baseX + offsetX + col * this.BUBBLE_SIZE;
      const y = baseY + row * verticalSpacing;
      const bubble = {
        x,
        y,
        word: words[i].word,
        color: this.getColorForWord(words[i].word),
        // Use consistent color for same word
        id: `initial-${i}`,
        row,
        col,
        vietnameseMeaning: words[i].meaning,
        // Store Vietnamese meaning
        displayText: vietnameseMode && words[i].meaning ? words[i].meaning.substring(0, 2).toUpperCase() : words[i].word.charAt(0).toUpperCase()
        // Default to English first 1 letter
      };
      bubbles.push(bubble);
    }
    return bubbles;
  }
  isGameWon(bubbles) {
    return bubbles.length === 0;
  }
  calculateScore(matchedBubbles, floatingBubbles) {
    return matchedBubbles * 10 + floatingBubbles * 5;
  }
  getColorForWord(word) {
    let hash = 0;
    for (let i = 0; i < word.length; i++) {
      hash = (hash << 5) - hash + word.charCodeAt(i) & 4294967295;
    }
    const colorIndex = Math.abs(hash) % this.COLORS.length;
    return this.COLORS[colorIndex];
  }
}
const useGameLogic = () => {
  return new GameLogic();
};

class BubbleShooterGame {
  // Dependencies
  stateManager;
  audioSystem;
  physicsEngine;
  visualEffects;
  canvasRenderer;
  inputHandler;
  gameLogic;
  // Private properties
  animationFrame = null;
  currentWords = [];
  vietnameseMode = false;
  // Timed row insertion & animation state
  rowInsertTimer = null;
  ROW_INSERT_INTERVAL = 2e4;
  rowAnimationActive = false;
  // Bomb system
  bombHits = /* @__PURE__ */ new Map();
  // Track hits per bomb bubble
  rowAnimationStart = 0;
  rowAnimationDuration = 600;
  // ms
  rowShiftAmount = 34;
  // will be recalculated in constructor
  rowStartYMap = /* @__PURE__ */ new Map();
  rowStartXMap = /* @__PURE__ */ new Map();
  newRowBubbles = [];
  newRowDelays = /* @__PURE__ */ new Map();
  constructor() {
    this.stateManager = useGameStateManager();
    this.audioSystem = useAudioSystem();
    this.physicsEngine = usePhysicsEngine(this.stateManager);
    this.visualEffects = useVisualEffects();
    this.canvasRenderer = useCanvasRenderer();
    this.inputHandler = useInputHandler();
    this.gameLogic = useGameLogic();
    this.rowShiftAmount = this.physicsEngine.BUBBLE_SIZE * Math.sqrt(3) / 2;
  }
  // ===== Row Insertion Feature =====
  triggerRowInsertion() {
    if (this.rowAnimationActive || this.stateManager.gameOver.value) return;
    if (this.stateManager.shootingBubble.value) return;
    this.rowAnimationActive = true;
    this.stateManager.setRowAnimationActive(true);
    this.rowAnimationStart = performance.now();
    this.rowStartYMap.clear();
    this.rowStartXMap.clear();
    this.newRowBubbles = [];
    this.newRowDelays.clear();
    this.stateManager.bubbles.value.forEach((b) => {
      this.rowStartYMap.set(b.id, b.y);
      this.rowStartXMap.set(b.id, b.x);
      const verticalSpacing = this.physicsEngine.BUBBLE_SIZE * Math.sqrt(3) / 2;
      const baseX2 = this.physicsEngine.BUBBLE_SIZE / 2;
      const baseY = this.physicsEngine.BUBBLE_SIZE / 2;
      const offsetX2 = (b.row ?? 0) % 2 === 0 ? 0 : this.physicsEngine.BUBBLE_SIZE / 2;
      b.stableX = baseX2 + offsetX2 + (b.col ?? 0) * this.physicsEngine.BUBBLE_SIZE;
      b.stableY = baseY + (b.row ?? 0) * verticalSpacing;
    });
    const B = this.physicsEngine.BUBBLE_SIZE;
    const baseX = B / 2;
    const currentTop = this.stateManager.bubbles.value.filter((b) => (b.row ?? 0) === 0);
    const nearestGridX = (x, offsetX2) => {
      const colF = Math.round((x - (baseX + offsetX2)) / B);
      return baseX + offsetX2 + colF * B;
    };
    let sumEven = 0, sumOdd = 0;
    if (currentTop.length > 0) {
      currentTop.forEach((b) => {
        sumEven += Math.abs(b.x - nearestGridX(b.x, 0));
        sumOdd += Math.abs(b.x - nearestGridX(b.x, B / 2));
      });
    }
    const effOffsetRow1 = currentTop.length === 0 ? 0 : sumEven <= sumOdd ? 0 : B / 2;
    const desiredOffsetRow0 = effOffsetRow1 === 0 ? B / 2 : 0;
    const canvasW = this.canvasRenderer.canvasWidth.value || 800;
    const offsetX = desiredOffsetRow0;
    const Bsize = this.physicsEngine.BUBBLE_SIZE;
    const bubblesPerRow = Math.max(1, Math.floor((canvasW - 10 - offsetX) / Bsize));
    for (let col = 0; col < bubblesPerRow; col++) {
      const vocab = this.currentWords[Math.floor(Math.random() * Math.max(1, this.currentWords.length))];
      const word = vocab?.word || "·";
      const color = this.physicsEngine.getColorForWord(word);
      const x = col * this.physicsEngine.BUBBLE_SIZE + this.physicsEngine.BUBBLE_SIZE / 2 + offsetX;
      const startY = -this.physicsEngine.BUBBLE_SIZE;
      const isBomb = Math.random() < 0.2;
      const bubble = {
        x,
        y: startY,
        word,
        color: isBomb ? "#FF4444" : color,
        // Bomb bubbles are red
        id: `row-${Date.now()}-${col}`,
        row: -1,
        col,
        vietnameseMeaning: vocab?.meaning || "",
        displayText: this.vietnameseMode && vocab?.meaning ? vocab.meaning.substring(0, 2).toUpperCase() : word.charAt(0).toUpperCase(),
        isBomb
      };
      this.stateManager.addBubble(bubble);
      this.newRowBubbles.push(bubble);
      this.newRowDelays.set(bubble.id, col * 60);
    }
  }
  updateRowInsertionAnimation() {
    if (!this.rowAnimationActive) return;
    const now = performance.now();
    const elapsed = now - this.rowAnimationStart;
    const t = Math.min(1, elapsed / this.rowAnimationDuration);
    const ease = 1 - Math.pow(1 - t, 3);
    this.stateManager.bubbles.value.forEach((b) => {
      if (this.newRowDelays.has(b.id)) return;
      const startY = this.rowStartYMap.get(b.id);
      const startX = this.rowStartXMap.get(b.id);
      if (startY != null) {
        b.y = startY + ease * this.rowShiftAmount;
      }
      if (startX != null) {
        b.x = startX;
      }
    });
    const targetTopY = this.physicsEngine.BUBBLE_SIZE / 2;
    const movingTopY = targetTopY + ease * this.rowShiftAmount;
    const epsilon = 1;
    const rowBelow = this.stateManager.bubbles.value.filter((b) => !this.newRowDelays.has(b.id) && (b.row ?? 0) === 0);
    let allNewSettled = true;
    for (const nb of this.newRowBubbles) {
      const delay = this.newRowDelays.get(nb.id) || 0;
      const localElapsed = Math.max(0, elapsed - delay);
      const tt = Math.min(1, localElapsed / Math.max(1, this.rowAnimationDuration - delay));
      const ease2 = 1 - Math.pow(1 - tt, 3);
      const startY = -this.physicsEngine.BUBBLE_SIZE;
      const plannedY = startY + (targetTopY - startY) * ease2;
      let allowed = movingTopY - this.rowShiftAmount - epsilon;
      if (rowBelow.length > 0) {
        let nearest = rowBelow[0];
        let bestDx = Math.abs(nearest.x - nb.x);
        for (let i = 1; i < rowBelow.length; i++) {
          const dx = Math.abs(rowBelow[i].x - nb.x);
          if (dx < bestDx) {
            bestDx = dx;
            nearest = rowBelow[i];
          }
        }
        const B = this.physicsEngine.BUBBLE_SIZE;
        const dxClamped = Math.min(bestDx, B);
        const dyMin = dxClamped >= B ? 0 : Math.sqrt(B * B - dxClamped * dxClamped);
        allowed = Math.min(allowed, nearest.y - dyMin - epsilon);
      }
      nb.y = Math.round(Math.min(plannedY, allowed) * 2) / 2;
      if (tt < 1) allNewSettled = false;
    }
    if (t >= 1 && allNewSettled) {
      this.stateManager.bubbles.value.forEach((b) => {
        if (this.newRowDelays.has(b.id)) return;
        const prevRow = b.row ?? 0;
        const nextRow = prevRow + 1;
        const startX = this.rowStartXMap.get(b.id);
        if (startX != null) b.x = startX;
        b.row = nextRow;
        const yExact = this.physicsEngine.BUBBLE_SIZE / 2 + nextRow * this.rowShiftAmount;
        b.y = Math.round(yExact * 2) / 2;
        const offsetX = nextRow % 2 === 0 ? 0 : this.physicsEngine.BUBBLE_SIZE / 2;
        const colF = Math.round(
          (b.x - (this.physicsEngine.BUBBLE_SIZE / 2 + offsetX)) / this.physicsEngine.BUBBLE_SIZE
        );
        b.col = Math.max(0, colF);
      });
      const B2 = this.physicsEngine.BUBBLE_SIZE;
      const baseX2 = B2 / 2;
      const currentTop2 = this.stateManager.bubbles.value.filter((b) => (b.row ?? 0) === 1);
      let sumEven2 = 0, sumOdd2 = 0;
      if (currentTop2.length > 0) {
        currentTop2.forEach((b) => {
          sumEven2 += Math.abs(b.x - (baseX2 + Math.round((b.x - baseX2) / B2) * B2));
          sumOdd2 += Math.abs(b.x - (baseX2 + B2 / 2 + Math.round((b.x - (baseX2 + B2 / 2)) / B2) * B2));
        });
      }
      const effOffsetRow1b = currentTop2.length === 0 ? 0 : sumEven2 <= sumOdd2 ? 0 : B2 / 2;
      const desiredOffsetRow0b = effOffsetRow1b === 0 ? B2 / 2 : 0;
      this.newRowBubbles.forEach((nb) => {
        const col0 = Math.round((nb.x - (baseX2 + desiredOffsetRow0b)) / B2);
        nb.col = Math.max(0, col0);
        nb.row = 0;
        nb.y = Math.round(targetTopY * 2) / 2;
      });
      this.stateManager.addScreenShake(4);
      this.audioSystem.playImpactSound();
      this.stateManager.bubbles.value.forEach((b) => {
        delete b.stableX;
        delete b.stableY;
      });
      this.rowAnimationActive = false;
      this.stateManager.setRowAnimationActive(false);
      this.rowStartYMap.clear();
      this.rowStartXMap.clear();
      this.newRowDelays.clear();
      this.newRowBubbles = [];
    }
  }
  initialize(canvas, words, vietnameseMode = false) {
    this.canvasRenderer.gameCanvas.value = canvas;
    this.currentWords = words;
    this.vietnameseMode = vietnameseMode;
    if (!this.canvasRenderer.initializeCanvas()) {
      console.error("Failed to initialize canvas");
      return;
    }
    this.stateManager.shooterPosition.value = {
      x: this.canvasRenderer.canvasWidth.value / 2,
      y: this.canvasRenderer.canvasHeight.value - 50
    };
    const initialBubbles = this.gameLogic.setupInitialBubbles(words, this.vietnameseMode);
    initialBubbles.forEach((bubble) => this.stateManager.addBubble(bubble));
    this.stateManager.selectNextShooterWord(words);
    this.startGameLoop();
    if (this.rowInsertTimer) window.clearInterval(this.rowInsertTimer);
    this.rowInsertTimer = window.setInterval(() => this.triggerRowInsertion(), this.ROW_INSERT_INTERVAL);
  }
  startGameLoop() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }
    const gameLoop = () => {
      this.updateRowInsertionAnimation();
      this.stateManager.updateExplosions();
      this.canvasRenderer.clearCanvas();
      const shake = this.stateManager.screenShake.value;
      const ctx = this.canvasRenderer.gameCanvas.value?.getContext("2d");
      if (ctx) {
        ctx.save();
        ctx.translate(shake.x, shake.y);
        this.canvasRenderer.drawBackground();
        this.stateManager.bubbles.value.forEach((bubble) => {
          this.canvasRenderer.drawBubble(bubble);
        });
        this.canvasRenderer.drawExplosions(this.stateManager.explosions.value);
        this.canvasRenderer.drawShooter(
          this.stateManager.shooterPosition.value,
          this.stateManager.currentShooterWord.value,
          this.stateManager.currentShooterColor.value,
          this.getShooterDisplayText()
        );
        if (this.stateManager.shootingBubble.value) {
          this.canvasRenderer.drawShootingBubble(this.stateManager.shootingBubble.value);
        }
        this.canvasRenderer.drawAimLine(
          this.stateManager.aimLine.value,
          this.stateManager.shooterPosition.value
        );
        ctx.restore();
      }
      if (this.gameLogic.isGameWon(this.stateManager.bubbles.value)) {
        this.stateManager.setGameOver(true);
        return;
      }
      if (!this.stateManager.gameOver.value) {
        this.animationFrame = requestAnimationFrame(gameLoop);
      }
    };
    gameLoop();
  }
  stopGameLoop() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
    if (this.rowInsertTimer) {
      window.clearInterval(this.rowInsertTimer);
      this.rowInsertTimer = null;
    }
  }
  updateAim(event) {
    const canvas = this.canvasRenderer.gameCanvas.value;
    if (!canvas || this.stateManager.shootingBubble.value) return;
    const aimPosition = this.inputHandler.updateAim(event, canvas);
    this.stateManager.updateAimLine(aimPosition);
  }
  shootBubble(event) {
    const canvas = this.canvasRenderer.gameCanvas.value;
    if (!canvas || this.stateManager.shootingBubble.value || !this.stateManager.currentShooterWord.value || this.rowAnimationActive) {
      return;
    }
    const shootingVector = this.inputHandler.getShootingVector(
      event,
      canvas,
      this.stateManager.shooterPosition.value
    );
    if (!shootingVector) return;
    this.stateManager.updateAimLine(null);
    const shooterWord = this.stateManager.currentShooterWord.value;
    const currentWordVocab = this.currentWords.find((vocab) => vocab.word === shooterWord);
    const bubble = {
      x: this.stateManager.shooterPosition.value.x,
      y: this.stateManager.shooterPosition.value.y,
      word: shooterWord,
      color: this.stateManager.currentShooterColor.value,
      id: `shooting-${Date.now()}`,
      row: -1,
      col: -1,
      vietnameseMeaning: currentWordVocab?.meaning || "",
      displayText: shooterWord.charAt(0).toUpperCase()
      // Shooter bubble always shows English first letter
    };
    this.stateManager.setShootingBubble(bubble);
    if (bubble.word) {
      this.audioSystem.playVocabularySound(bubble.word, "en");
    }
    this.physicsEngine.animateShootingBubble(
      bubble,
      shootingVector.vx,
      shootingVector.vy,
      (landedBubble) => this.handleBubbleLanded(landedBubble),
      this.stateManager.bubbles.value,
      // Pass existing bubbles for immediate collision detection
      this.canvasRenderer.canvasWidth.value,
      // Pass actual canvas width for responsive boundaries
      this.canvasRenderer.canvasHeight.value
      // Pass actual canvas height for responsive boundaries
    );
    this.stateManager.selectNextShooterWord(this.currentWords);
  }
  restartGame(words) {
    this.stopGameLoop();
    this.currentWords = words;
    this.stateManager.resetGame();
    const initialBubbles = this.gameLogic.setupInitialBubbles(words);
    initialBubbles.forEach((bubble) => this.stateManager.addBubble(bubble));
    this.stateManager.selectNextShooterWord(words);
    this.startGameLoop();
    if (this.rowInsertTimer) window.clearInterval(this.rowInsertTimer);
    this.rowInsertTimer = window.setInterval(() => this.triggerRowInsertion(), this.ROW_INSERT_INTERVAL);
  }
  updateVietnameseMode(enabled) {
    this.vietnameseMode = enabled;
    this.stateManager.bubbles.value.forEach((bubble) => {
      if (enabled && bubble.vietnameseMeaning) {
        bubble.displayText = bubble.vietnameseMeaning.substring(0, 2).toUpperCase();
      } else {
        bubble.displayText = bubble.word.charAt(0).toUpperCase();
      }
    });
  }
  getShooterDisplayText() {
    const word = this.stateManager.currentShooterWord.value;
    if (!word) return "";
    const vocab = this.currentWords.find((w) => w.word === word);
    if (this.vietnameseMode && vocab?.meaning) {
      return vocab.meaning.substring(0, 2).toUpperCase();
    } else {
      return word.charAt(0).toUpperCase();
    }
  }
  cleanup() {
    this.stopGameLoop();
  }
  handleBubbleLanded(bubble) {
    const impactEffect = this.visualEffects.createImpactEffect(bubble.x, bubble.y, bubble.color);
    this.stateManager.addExplosion(impactEffect);
    this.audioSystem.playImpactSound();
    this.stateManager.setShootingBubble(null);
    if (this.vietnameseMode && bubble.vietnameseMeaning) {
      bubble.displayText = bubble.vietnameseMeaning.substring(0, 2).toUpperCase();
    } else {
      bubble.displayText = bubble.word.charAt(0).toUpperCase();
    }
    this.physicsEngine.snapToGrid(bubble, this.stateManager.bubbles.value);
    this.stateManager.addBubble(bubble);
    this.checkBombHits(bubble);
    const matchResult = this.gameLogic.checkForMatches(bubble, this.stateManager.bubbles.value);
    if (matchResult.shouldRemove) {
      matchResult.matchedBubbles.forEach((matchedBubble) => {
        const explosion = this.visualEffects.createExplosion(
          matchedBubble.x,
          matchedBubble.y,
          matchedBubble.color
        );
        this.stateManager.addExplosion(explosion);
      });
      const bubbleIds = matchResult.matchedBubbles.map((b) => b.id);
      this.stateManager.removeBubbles(bubbleIds);
      const matchScore = this.gameLogic.calculateScore(matchResult.matchedBubbles.length, 0);
      this.stateManager.updateScore(matchScore);
      this.stateManager.incrementWordsMatched();
      this.audioSystem.playExplosionSound();
      this.stateManager.addScreenShake(8);
      this.handleFloatingBubbles();
    }
  }
  handleFloatingBubbles() {
    const floatingResult = this.gameLogic.removeFloatingBubbles(this.stateManager.bubbles.value);
    if (floatingResult.removedBubbles.length > 0) {
      floatingResult.removedBubbles.forEach((floatingBubble) => {
        const effect = this.visualEffects.createImpactEffect(
          floatingBubble.x,
          floatingBubble.y,
          floatingBubble.color
        );
        this.stateManager.addExplosion(effect);
      });
      this.stateManager.bubbles.value = floatingResult.remainingBubbles;
      const bonusScore = this.gameLogic.calculateScore(0, floatingResult.removedBubbles.length);
      this.stateManager.updateScore(bonusScore);
    }
  }
  checkBombHits(landedBubble) {
    const adjacentBombs = this.stateManager.bubbles.value.filter((bubble) => {
      if (!bubble.isBomb) return false;
      const dx = bubble.x - landedBubble.x;
      const dy = bubble.y - landedBubble.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance <= this.physicsEngine.BUBBLE_SIZE * 1.1;
    });
    adjacentBombs.forEach((bomb) => {
      const currentHits = this.bombHits.get(bomb.id) || 0;
      const newHits = currentHits + 1;
      this.bombHits.set(bomb.id, newHits);
      console.log(`Bomb ${bomb.id} hit ${newHits}/2 times`);
      if (newHits >= 2) {
        this.triggerMassiveExplosion(bomb);
        this.bombHits.delete(bomb.id);
      }
    });
  }
  triggerMassiveExplosion(bombBubble) {
    console.log("💥 MASSIVE BOMB EXPLOSION! DEVASTATION!");
    for (let i = 0; i < 3; i++) {
      const offsetX = (Math.random() - 0.5) * this.physicsEngine.BUBBLE_SIZE * 2;
      const offsetY = (Math.random() - 0.5) * this.physicsEngine.BUBBLE_SIZE * 2;
      const massiveExplosion = this.visualEffects.createExplosion(
        bombBubble.x + offsetX,
        bombBubble.y + offsetY,
        "#FF4444"
      );
      massiveExplosion.shockwave.maxRadius = this.physicsEngine.BUBBLE_SIZE * 12;
      massiveExplosion.particles.forEach((particle) => {
        particle.size *= 4;
        particle.maxLife *= 3;
        particle.vx *= 3;
        particle.vy *= 3;
      });
      this.stateManager.addExplosion(massiveExplosion);
    }
    for (let i = 0; i < 60; i++) {
      const angle = Math.PI * 2 * i / 60;
      const speed = 20 + Math.random() * 15;
      const explosionParticles = {
        x: bombBubble.x,
        y: bombBubble.y,
        particles: [{
          x: bombBubble.x,
          y: bombBubble.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          size: 12 + Math.random() * 8,
          color: ["#FF2222", "#FF4444", "#FF6666", "#FFAA44", "#FFFF44", "#FF8844"][Math.floor(Math.random() * 6)],
          life: 150,
          maxLife: 150,
          type: "burst",
          rotation: 0,
          rotationSpeed: (Math.random() - 0.5) * 0.5
        }],
        active: true,
        shockwave: {
          radius: 0,
          maxRadius: this.physicsEngine.BUBBLE_SIZE * 10,
          intensity: 1
        },
        radius: 0,
        maxRadius: this.physicsEngine.BUBBLE_SIZE * 10,
        intensity: 1
      };
      this.stateManager.addExplosion(explosionParticles);
    }
    const explosionRadius = this.physicsEngine.BUBBLE_SIZE * 6;
    const bubblesInRange = this.stateManager.bubbles.value.filter((bubble) => {
      const dx = bubble.x - bombBubble.x;
      const dy = bubble.y - bombBubble.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance <= explosionRadius;
    });
    const bubbleIds = bubblesInRange.map((b) => b.id);
    this.stateManager.removeBubbles(bubbleIds);
    bubblesInRange.forEach((bubble) => {
      if (bubble.isBomb) {
        this.bombHits.delete(bubble.id);
      }
    });
    this.stateManager.addScreenShake(35);
    this.audioSystem.playExplosionSound();
    setTimeout(() => this.audioSystem.playExplosionSound(), 100);
    setTimeout(() => this.audioSystem.playExplosionSound(), 200);
    this.stateManager.updateScore(1e3 + bubblesInRange.length * 50);
    console.log(`💥 BOMB DEVASTATION: Destroyed ${bubblesInRange.length} bubbles!`);
    const floatingResult = this.gameLogic.removeFloatingBubbles(this.stateManager.bubbles.value);
    if (floatingResult.removedBubbles.length > 0) {
      this.stateManager.removeBubbles(floatingResult.removedBubbles.map((b) => b.id));
      const floatingScore = this.gameLogic.calculateScore(0, floatingResult.removedBubbles.length);
      this.stateManager.updateScore(floatingScore);
    }
  }
}
const useBubbleShooterGame = () => {
  return new BubbleShooterGame();
};

const _hoisted_1$m = { class: "bubble-shooter-game h-full min-h-[600px] sm:min-h-[500px] md:min-h-0 flex flex-col" };
const _hoisted_2$j = { class: "p-4 sm:p-6 md:p-8 bg-gradient-to-r from-purple-600 to-pink-600 dark:from-purple-800 dark:to-pink-800 text-white" };
const _hoisted_3$i = { class: "flex justify-between items-center" };
const _hoisted_4$g = { class: "text-lg sm:text-xl md:text-2xl font-bold" };
const _hoisted_5$f = { class: "text-sm sm:text-base opacity-90" };
const _hoisted_6$e = { class: "text-right" };
const _hoisted_7$d = { class: "text-2xl sm:text-3xl font-bold" };
const _hoisted_8$d = { class: "text-xs sm:text-sm opacity-90" };
const _hoisted_9$d = { class: "flex-1 min-h-[450px] sm:min-h-[350px] md:min-h-0 relative bg-gradient-to-b from-blue-100 to-blue-200 dark:from-[#0a0a0a] dark:to-[#0f0f0f] overflow-hidden" };
const _hoisted_10$c = ["viewBox"];
const _hoisted_11$c = ["x1", "y1", "x2", "y2"];
const _hoisted_12$c = { class: "absolute bottom-20 left-1/2 transform -translate-x-1/2 bg-white dark:bg-[#0a0a0a] rounded-lg px-4 py-2 shadow-lg border-2 border-purple-500" };
const _hoisted_13$c = { class: "text-center" };
const _hoisted_14$c = { class: "text-lg sm:text-xl font-bold text-gray-800 dark:text-white" };
const _hoisted_15$a = { class: "text-xs sm:text-sm text-gray-600 dark:text-white/70" };
const _hoisted_16$a = {
  key: 0,
  class: "absolute inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center p-4"
};
const _hoisted_17$a = { class: "bg-white dark:bg-[#0a0a0a] rounded-2xl p-6 sm:p-8 max-w-md w-full text-center shadow-2xl border border-gray-200 dark:border-[#0f0f0f]" };
const _hoisted_18$a = { class: "text-xl sm:text-2xl font-bold mb-2 text-gray-800 dark:text-white" };
const _hoisted_19$a = { class: "text-gray-600 dark:text-white/70 mb-4" };
const _hoisted_20$a = { class: "text-sm text-gray-500 dark:text-white/60 mb-6" };
const _hoisted_21$a = { class: "flex gap-3 justify-center" };
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "BubbleShooterMode",
  props: {
    words: {},
    vietnameseMode: { type: Boolean }
  },
  emits: ["game-complete"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const { t } = useI18n();
    const emit = __emit;
    const game = useBubbleShooterGame();
    const gameCanvas = ref();
    const canvasWidth = computed(() => game.canvasRenderer.canvasWidth.value);
    const canvasHeight = computed(() => game.canvasRenderer.canvasHeight.value);
    const score = computed(() => game.stateManager.score.value);
    const wordsMatched = computed(() => game.stateManager.wordsMatched.value);
    const gameOver = computed(() => game.stateManager.gameOver.value);
    const currentShooterWord = computed(() => game.stateManager.currentShooterWord.value);
    computed(() => {
      const word = game.stateManager.currentShooterWord.value;
      if (!word) return "";
      const vocab = props.words.find((w) => w.word === word);
      if (props.vietnameseMode && vocab?.meaning) {
        return vocab.meaning.substring(0, 2).toUpperCase();
      } else {
        return word.charAt(0).toUpperCase();
      }
    });
    const aimLine = computed(() => game.stateManager.aimLine.value);
    const shooterPosition = computed(() => game.stateManager.shooterPosition.value);
    const stopGameOverWatch = watch(
      () => game.stateManager.gameOver.value,
      (isGameOver) => {
        if (isGameOver) {
          emit("game-complete");
        }
      }
    );
    onMounted(async () => {
      await nextTick();
      if (!gameCanvas.value) return;
      game.initialize(gameCanvas.value, props.words, props.vietnameseMode);
    });
    watch(() => props.vietnameseMode, (newValue) => {
      game.updateVietnameseMode(newValue ?? false);
    });
    onUnmounted(() => {
      stopGameOverWatch();
      game.cleanup();
    });
    const updateAim = (event) => {
      game.updateAim(event);
    };
    const shootBubble = (event) => {
      game.shootBubble(event);
    };
    const restartGame = () => {
      game.stopGameLoop();
      game.stateManager.resetGame();
      if (gameCanvas.value) {
        game.initialize(gameCanvas.value, props.words);
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$m, [
        createBaseVNode("div", _hoisted_2$j, [
          createBaseVNode("div", _hoisted_3$i, [
            createBaseVNode("div", null, [
              createBaseVNode("h2", _hoisted_4$g, toDisplayString$1(unref(t)("flashcard.bubbleShooter.title", "Bubble Shooter")), 1),
              createBaseVNode("p", _hoisted_5$f, toDisplayString$1(unref(t)("flashcard.bubbleShooter.instruction", "Shoot bubbles to match 4 or more words!")), 1)
            ]),
            createBaseVNode("div", _hoisted_6$e, [
              createBaseVNode("div", _hoisted_7$d, toDisplayString$1(score.value), 1),
              createBaseVNode("div", _hoisted_8$d, toDisplayString$1(unref(t)("flashcard.bubbleShooter.score", "Score")), 1)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_9$d, [
          createBaseVNode("canvas", {
            ref_key: "gameCanvas",
            ref: gameCanvas,
            class: "w-full h-full cursor-crosshair",
            onClick: shootBubble,
            onMousemove: updateAim
          }, null, 544),
          aimLine.value.visible ? (openBlock(), createElementBlock("svg", {
            key: 0,
            class: "absolute inset-0 w-full h-full pointer-events-none",
            viewBox: `0 0 ${canvasWidth.value} ${canvasHeight.value}`
          }, [
            createBaseVNode("line", {
              x1: shooterPosition.value.x,
              y1: shooterPosition.value.y,
              x2: aimLine.value.x,
              y2: aimLine.value.y,
              stroke: "rgba(255,255,255,0.7)",
              "stroke-width": "2",
              "stroke-dasharray": "5,5"
            }, null, 8, _hoisted_11$c)
          ], 8, _hoisted_10$c)) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_12$c, [
            createBaseVNode("div", _hoisted_13$c, [
              createBaseVNode("div", _hoisted_14$c, toDisplayString$1(currentShooterWord.value), 1),
              createBaseVNode("div", _hoisted_15$a, toDisplayString$1(unref(t)("flashcard.bubbleShooter.currentWord", "Current Word")), 1)
            ])
          ]),
          createVNode(Transition, {
            name: "modal",
            appear: ""
          }, {
            default: withCtx(() => [
              gameOver.value ? (openBlock(), createElementBlock("div", _hoisted_16$a, [
                createBaseVNode("div", _hoisted_17$a, [
                  _cache[1] || (_cache[1] = createBaseVNode("div", { class: "w-16 h-16 sm:w-20 sm:h-20 mx-auto mb-4 bg-gradient-to-r from-green-400 to-blue-500 rounded-full flex items-center justify-center animate-pulse" }, [
                    createBaseVNode("svg", {
                      class: "w-8 h-8 sm:w-10 sm:h-10 text-white",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                        "clip-rule": "evenodd"
                      })
                    ])
                  ], -1)),
                  createBaseVNode("h3", _hoisted_18$a, toDisplayString$1(unref(t)("flashcard.bubbleShooter.gameComplete", "Game Complete!")), 1),
                  createBaseVNode("p", _hoisted_19$a, toDisplayString$1(unref(t)("flashcard.bubbleShooter.finalScore", { score: score.value })), 1),
                  createBaseVNode("p", _hoisted_20$a, toDisplayString$1(unref(t)("flashcard.bubbleShooter.wordsMatched", { count: wordsMatched.value })), 1),
                  createBaseVNode("div", _hoisted_21$a, [
                    createBaseVNode("button", {
                      onClick: restartGame,
                      class: "px-6 py-2 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-lg font-medium transform hover:scale-105 transition-all duration-200"
                    }, toDisplayString$1(unref(t)("flashcard.bubbleShooter.playAgain", "Play Again")), 1),
                    createBaseVNode("button", {
                      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("game-complete")),
                      class: "px-6 py-2 bg-gray-500 hover:bg-gray-600 dark:bg-[#0f0f0f] dark:hover:bg-[#1a1a1a] text-white rounded-lg font-medium transform hover:scale-105 transition-all duration-200"
                    }, toDisplayString$1(unref(t)("common.finish", "Finish")), 1)
                  ])
                ])
              ])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
});

const BubbleShooterMode = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-98a69fca"]]);

const BubbleShooterMode$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: BubbleShooterMode
}, Symbol.toStringTag, { value: 'Module' }));

class SnakeStateManager {
  snake = ref({
    body: [{ x: 10, y: 10 }],
    direction: { x: 0, y: 0 },
    currentWord: ""
  });
  food = ref(null);
  secondaryFood = ref(null);
  score = ref(0);
  gameOver = ref(false);
  gameRunning = ref(false);
  currentTargetWord = ref("");
  wordsCompleted = ref(0);
  gameSpeed = ref(150);
  // milliseconds between moves
  lastEatenFoodPos = ref(null);
  lastEatenWord = ref(null);
  doubleBaitMode = ref(false);
  wrongEatenCount = ref(0);
  isLastWord = false;
  words = [];
  vietnameseMode = false;
  usedWords = /* @__PURE__ */ new Set();
  // Audio context for sound effects
  audioContext = null;
  // Timeline recording callback
  onMoveCallback;
  resetGame() {
    this.snake.value = {
      body: [{ x: 10, y: 10 }],
      direction: { x: 0, y: 0 },
      currentWord: ""
    };
    this.food.value = null;
    this.secondaryFood.value = null;
    this.score.value = 0;
    this.gameOver.value = false;
    this.gameRunning.value = false;
    this.currentTargetWord.value = "";
    this.wordsCompleted.value = 0;
    this.usedWords.clear();
    this.lastEatenFoodPos.value = null;
    this.lastEatenWord.value = null;
    this.doubleBaitMode.value = false;
    this.wrongEatenCount.value = 0;
    this.isLastWord = false;
  }
  updateDirection(direction) {
    const currentDir = this.snake.value.direction;
    if (direction.x !== -currentDir.x || direction.y !== -currentDir.y) {
      this.snake.value.direction = direction;
    }
  }
  moveSnake() {
    if (!this.gameRunning.value || this.gameOver.value) return;
    const snake = this.snake.value;
    const head = { ...snake.body[0] };
    head.x += snake.direction.x;
    head.y += snake.direction.y;
    if (head.x < 0) head.x = 29;
    else if (head.x >= 30) head.x = 0;
    if (head.y < 0) head.y = 19;
    else if (head.y >= 20) head.y = 0;
    if (this.checkCollision()) {
      this.setGameOver();
      return;
    }
    snake.body.unshift(head);
    const headNow = this.snake.value.body[0];
    const hitPrimary = this.food.value && headNow.x === this.food.value.position.x && headNow.y === this.food.value.position.y;
    const hitSecondary = this.secondaryFood.value && headNow.x === this.secondaryFood.value.position.x && headNow.y === this.secondaryFood.value.position.y;
    if (hitPrimary) {
      this.incrementScore();
      this.wordsCompleted.value++;
      if (this.food.value) {
        this.lastEatenFoodPos.value = { ...this.food.value.position };
        this.lastEatenWord.value = this.food.value.word;
      }
      this.playEatFoodSound();
      if (this.isLastWord) {
        this.setGameOver();
        return;
      }
      this.generateFood(this.words, this.vietnameseMode);
    } else if (hitSecondary) {
      this.wrongEatenCount.value++;
      if (this.secondaryFood.value) {
        this.lastEatenFoodPos.value = { ...this.secondaryFood.value.position };
        this.lastEatenWord.value = this.secondaryFood.value.word;
      }
      snake.body.pop();
      this.generateFood(this.words, this.vietnameseMode);
    } else {
      snake.body.pop();
    }
    if (this.onMoveCallback) {
      this.onMoveCallback([...snake.body.map((seg) => ({ x: seg.x, y: seg.y }))], { x: snake.direction.x, y: snake.direction.y });
    }
  }
  generateFood(words, vietnameseMode) {
    this.words = words;
    this.vietnameseMode = vietnameseMode;
    if (words.length === 0) return;
    const availableWords = words.filter((w) => !this.usedWords.has(w.word));
    if (availableWords.length === 0) {
      this.setGameOver();
      return;
    }
    const targetWord = availableWords[Math.floor(Math.random() * availableWords.length)];
    this.usedWords.add(targetWord.word);
    this.currentTargetWord.value = targetWord.word;
    const remainingWords = words.filter((w) => !this.usedWords.has(w.word));
    if (remainingWords.length === 0) {
      this.isLastWord = true;
    } else {
      this.isLastWord = false;
    }
    const randomFreePos = (blocked = []) => {
      let pos;
      do {
        pos = {
          x: Math.floor(Math.random() * 25) + 2,
          // Grid 30x20, avoid edges
          y: Math.floor(Math.random() * 15) + 2
        };
      } while (this.snake.value.body.some((seg) => seg.x === pos.x && seg.y === pos.y) || blocked.some((b) => b.x === pos.x && b.y === pos.y));
      return pos;
    };
    const primaryPos = randomFreePos();
    this.food.value = {
      position: primaryPos,
      word: targetWord.word,
      firstLetter: vietnameseMode && targetWord.meaning ? targetWord.meaning.charAt(0).toUpperCase() : targetWord.word.charAt(0).toUpperCase(),
      meaning: targetWord.meaning
    };
    if (!this.doubleBaitMode.value) {
      this.secondaryFood.value = null;
      return;
    }
    const others = words.filter((w) => w.word !== targetWord.word);
    if (others.length === 0) {
      this.secondaryFood.value = null;
      return;
    }
    const wrong = others[Math.floor(Math.random() * others.length)];
    const secondaryPos = randomFreePos([primaryPos]);
    this.secondaryFood.value = {
      position: secondaryPos,
      word: wrong.word,
      firstLetter: vietnameseMode && wrong.meaning ? wrong.meaning.charAt(0).toUpperCase() : wrong.word.charAt(0).toUpperCase(),
      meaning: wrong.meaning
    };
  }
  checkCollision() {
    const head = this.snake.value.body[0];
    for (let i = 1; i < this.snake.value.body.length; i++) {
      if (head.x === this.snake.value.body[i].x && head.y === this.snake.value.body[i].y) {
        return true;
      }
    }
    return false;
  }
  checkFoodCollision() {
    if (!this.food.value) return false;
    const head = this.snake.value.body[0];
    return head.x === this.food.value.position.x && head.y === this.food.value.position.y;
  }
  incrementScore() {
    this.score.value += 10;
  }
  setGameOver() {
    this.gameOver.value = true;
    this.gameRunning.value = false;
  }
  setGameRunning(running) {
    this.gameRunning.value = running;
  }
  setDoubleBaitMode(enabled, words, vietnameseMode) {
    this.doubleBaitMode.value = enabled;
    if (words && typeof vietnameseMode === "boolean") {
      this.generateFood(words, vietnameseMode);
      return;
    }
    if (this.gameRunning.value && !this.gameOver.value) {
      this.generateFood(this.words, this.vietnameseMode);
    }
  }
  // Set timeline recording callback
  setTimelineCallback(callback) {
    this.onMoveCallback = callback;
  }
  initializeAudioContext() {
    if (!this.audioContext) {
      try {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      } catch (error) {
        console.warn("Web Audio API not supported:", error);
      }
    }
  }
  playEatFoodSound() {
    this.initializeAudioContext();
    if (!this.audioContext) return;
    try {
      const currentTime = this.audioContext.currentTime;
      const gainNode = this.audioContext.createGain();
      gainNode.connect(this.audioContext.destination);
      const frequencies = [261.63, 329.63, 392];
      frequencies.forEach((freq, index) => {
        const oscillator = this.audioContext.createOscillator();
        const noteGain = this.audioContext.createGain();
        oscillator.connect(noteGain);
        noteGain.connect(gainNode);
        oscillator.frequency.setValueAtTime(freq, currentTime);
        oscillator.type = "sine";
        const startTime = currentTime + index * 0.08;
        const endTime = startTime + 0.15;
        noteGain.gain.setValueAtTime(0, startTime);
        noteGain.gain.linearRampToValueAtTime(0.3, startTime + 0.02);
        noteGain.gain.exponentialRampToValueAtTime(0.01, endTime);
        oscillator.start(startTime);
        oscillator.stop(endTime);
      });
    } catch (error) {
      console.warn("Error playing eat food sound:", error);
    }
  }
}

class SnakeCanvasRenderer {
  canvasWidth = ref(600);
  canvasHeight = ref(400);
  gridSize = ref(20);
  canvas = null;
  ctx = null;
  // Simple particle system for explosion effect
  particles = [];
  // Tomato juice splatter stains (fade on the floor)
  stains = [];
  // Shock rings for a juicy burst feeling
  rings = [];
  initialize(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");
    canvas.width = this.canvasWidth.value;
    canvas.height = this.canvasHeight.value;
    const resizeObserver = new ResizeObserver(() => {
      this.handleResize();
    });
    resizeObserver.observe(canvas.parentElement || canvas);
  }
  // Draw a small label with the food meaning above the tile
  drawFoodLabel(food, variant) {
    if (!this.ctx) return;
    const ctx = this.ctx;
    const gridSize = this.gridSize.value;
    const x = food.position.x * gridSize;
    const y = food.position.y * gridSize;
    const text = (food.meaning || food.word || "").toString();
    if (!text) return;
    ctx.save();
    const bg = variant === "primary" ? "#065f46" : "#7c2d12";
    const stroke = variant === "primary" ? "#10b981" : "#f59e0b";
    const textColor = "#ffffff";
    ctx.font = `${Math.max(10, Math.floor(gridSize * 0.6))}px sans-serif`;
    const paddingX = 6;
    const metrics = ctx.measureText(text);
    const textWidth = metrics.width;
    const labelWidth = textWidth + paddingX * 2;
    const labelHeight = Math.max(gridSize * 0.7, 16);
    const labelX = x + gridSize / 2 - labelWidth / 2;
    const labelY = y - labelHeight - 6;
    const r = 6;
    ctx.beginPath();
    ctx.moveTo(labelX + r, labelY);
    ctx.lineTo(labelX + labelWidth - r, labelY);
    ctx.quadraticCurveTo(labelX + labelWidth, labelY, labelX + labelWidth, labelY + r);
    ctx.lineTo(labelX + labelWidth, labelY + labelHeight - r);
    ctx.quadraticCurveTo(labelX + labelWidth, labelY + labelHeight, labelX + labelWidth - r, labelY + labelHeight);
    ctx.lineTo(labelX + r, labelY + labelHeight);
    ctx.quadraticCurveTo(labelX, labelY + labelHeight, labelX, labelY + labelHeight - r);
    ctx.lineTo(labelX, labelY + r);
    ctx.quadraticCurveTo(labelX, labelY, labelX + r, labelY);
    ctx.closePath();
    ctx.fillStyle = bg;
    ctx.fill();
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = textColor;
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";
    ctx.fillText(text, labelX + labelWidth / 2, labelY + labelHeight / 2);
    ctx.restore();
  }
  handleResize() {
    if (!this.canvas) return;
    const container = this.canvas.parentElement;
    if (container) {
      const rect = container.getBoundingClientRect();
      const aspectRatio = 30 / 20;
      let width = Math.min(rect.width - 40, 600);
      let height = width / aspectRatio;
      if (height > rect.height - 40) {
        height = rect.height - 40;
        width = height * aspectRatio;
      }
      this.canvasWidth.value = width;
      this.canvasHeight.value = height;
      this.gridSize.value = width / 30;
      this.canvas.width = width;
      this.canvas.height = height;
    }
  }
  render(stateManager) {
    if (!this.ctx) return;
    this.clearCanvas();
    this.drawGrid();
    this.updateAndDrawStains();
    this.drawFood(stateManager.food.value, "primary");
    this.drawFood(stateManager.secondaryFood?.value || null, "secondary");
    if (stateManager.doubleBaitMode?.value) {
      if (stateManager.food.value) this.drawFoodLabel(stateManager.food.value, "primary");
      if (stateManager.secondaryFood?.value) this.drawFoodLabel(stateManager.secondaryFood.value, "secondary");
    }
    this.drawSnake(stateManager.snake.value);
    if (stateManager.lastEatenFoodPos.value) {
      const gs = this.gridSize.value;
      const cx = stateManager.lastEatenFoodPos.value.x * gs + gs / 2;
      const cy = stateManager.lastEatenFoodPos.value.y * gs + gs / 2;
      this.spawnExplosion(cx, cy);
      this.spawnSplatStains(cx, cy);
      this.spawnShockRing(cx, cy);
      stateManager.lastEatenFoodPos.value = null;
    }
    this.updateAndDrawParticles();
    this.updateAndDrawRings();
  }
  clearCanvas() {
    if (!this.ctx) return;
    this.ctx.fillStyle = "#0a0a0a";
    this.ctx.fillRect(0, 0, this.canvasWidth.value, this.canvasHeight.value);
  }
  drawGrid() {
    if (!this.ctx) return;
    this.ctx.strokeStyle = "#0f0f0f";
    this.ctx.lineWidth = 1;
    const gridSize = this.gridSize.value;
    for (let x = 0; x <= 30; x++) {
      this.ctx.beginPath();
      this.ctx.moveTo(x * gridSize, 0);
      this.ctx.lineTo(x * gridSize, this.canvasHeight.value);
      this.ctx.stroke();
    }
    for (let y = 0; y <= 20; y++) {
      this.ctx.beginPath();
      this.ctx.moveTo(0, y * gridSize);
      this.ctx.lineTo(this.canvasWidth.value, y * gridSize);
      this.ctx.stroke();
    }
  }
  drawSnake(snake) {
    if (!this.ctx) return;
    const gridSize = this.gridSize.value;
    snake.body.forEach((segment, index) => {
      if (!this.ctx) return;
      if (index === 0) {
        this.ctx.fillStyle = "#10b981";
      } else {
        this.ctx.fillStyle = "#059669";
      }
      this.ctx.fillRect(
        segment.x * gridSize + 1,
        segment.y * gridSize + 1,
        gridSize - 2,
        gridSize - 2
      );
      this.ctx.strokeStyle = "#047857";
      this.ctx.lineWidth = 2;
      this.ctx.strokeRect(
        segment.x * gridSize + 1,
        segment.y * gridSize + 1,
        gridSize - 2,
        gridSize - 2
      );
    });
  }
  drawFood(food, variant = "primary") {
    if (!this.ctx || !food) return;
    const gridSize = this.gridSize.value;
    const x = food.position.x * gridSize;
    const y = food.position.y * gridSize;
    this.ctx.fillStyle = variant === "secondary" ? "#f59e0b" : "#ef4444";
    this.ctx.beginPath();
    this.ctx.arc(x + gridSize / 2, y + gridSize / 2, gridSize * 0.35, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.fillStyle = "rgba(255,255,255,0.8)";
    this.ctx.beginPath();
    this.ctx.arc(x + gridSize / 2 - 3, y + gridSize / 2 - 3, gridSize * 0.12, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.fillStyle = "#111827";
    this.ctx.font = `${Math.floor(gridSize * 0.6)}px Inter, system-ui, -apple-system, Segoe UI, Roboto`;
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "middle";
    this.ctx.fillText(
      food.firstLetter,
      x + gridSize / 2,
      y + gridSize / 2
    );
  }
  // Particle helpers
  spawnExplosion(cx, cy) {
    const colors = ["#ef4444", "#dc2626", "#f43f5e", "#f59e0b"];
    const count = 20;
    for (let i = 0; i < count; i++) {
      const angle = Math.PI * 2 * i / count;
      const speed = 5 + Math.random() * 3;
      this.particles.push({
        x: cx,
        y: cy,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 0,
        maxLife: 6 + Math.floor(Math.random() * 5),
        // very short for instant burst
        radius: 1.5 + Math.random() * 1.5,
        color: colors[Math.floor(Math.random() * colors.length)]
      });
    }
    if (this.particles.length > 300) {
      this.particles.splice(0, this.particles.length - 300);
    }
  }
  updateAndDrawParticles() {
    if (!this.ctx) return;
    const gravity = 0;
    const friction = 1;
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.vx *= friction;
      p.vy = p.vy * friction + gravity;
      p.x += p.vx;
      p.y += p.vy;
      p.life++;
      const alpha = Math.max(0, 1 - p.life / p.maxLife);
      this.ctx.globalAlpha = alpha;
      this.ctx.fillStyle = p.color;
      this.ctx.beginPath();
      this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
      this.ctx.fill();
      this.ctx.globalAlpha = 1;
      if (p.life >= p.maxLife) {
        this.particles.splice(i, 1);
      }
    }
  }
  spawnSplatStains(cx, cy) {
    const stainColors = ["#b91c1c", "#dc2626", "#ef4444"];
    const splats = 3 + Math.floor(Math.random() * 3);
    for (let i = 0; i < splats; i++) {
      const offsetR = Math.random() * 10;
      const offsetA = Math.random() * Math.PI * 2;
      const sx = cx + Math.cos(offsetA) * offsetR;
      const sy = cy + Math.sin(offsetA) * offsetR;
      this.stains.push({
        x: sx,
        y: sy,
        radius: 6 + Math.random() * 8,
        alpha: 0.6,
        decay: 0.06 + Math.random() * 0.06,
        color: stainColors[Math.floor(Math.random() * stainColors.length)]
      });
    }
    if (this.stains.length > 80) {
      this.stains.splice(0, this.stains.length - 80);
    }
  }
  updateAndDrawStains() {
    if (!this.ctx) return;
    for (let i = this.stains.length - 1; i >= 0; i--) {
      const s = this.stains[i];
      this.ctx.globalAlpha = Math.max(0, s.alpha);
      this.ctx.fillStyle = s.color;
      this.ctx.beginPath();
      this.ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
      this.ctx.fill();
      this.ctx.globalAlpha = 1;
      s.alpha -= s.decay;
      if (s.alpha <= 0) {
        this.stains.splice(i, 1);
      }
    }
  }
  spawnShockRing(cx, cy) {
    this.rings.push({
      x: cx,
      y: cy,
      r: 2,
      maxR: 28,
      life: 0,
      maxLife: 10,
      color: "#ef4444"
    });
  }
  updateAndDrawRings() {
    if (!this.ctx) return;
    for (let i = this.rings.length - 1; i >= 0; i--) {
      const ring = this.rings[i];
      ring.life++;
      const t = ring.life / ring.maxLife;
      ring.r = 2 + (ring.maxR - 2) * t;
      const alpha = Math.max(0, 1 - t);
      this.ctx.globalAlpha = alpha;
      this.ctx.strokeStyle = ring.color;
      this.ctx.lineWidth = 2;
      this.ctx.beginPath();
      this.ctx.arc(ring.x, ring.y, ring.r, 0, Math.PI * 2);
      this.ctx.stroke();
      this.ctx.globalAlpha = 1;
      if (ring.life >= ring.maxLife) {
        this.rings.splice(i, 1);
      }
    }
  }
}

class SnakeGameEngine {
  gameLoopId = ref(null);
  lastTimestamp = 0;
  accumulatorMs = 0;
  startGameLoop(stateManager, renderer) {
    if (this.gameLoopId.value) return;
    this.lastTimestamp = performance.now();
    this.accumulatorMs = 0;
    const frame = (ts) => {
      const dt = ts - this.lastTimestamp;
      this.lastTimestamp = ts;
      this.accumulatorMs += dt;
      while (stateManager.gameRunning.value && !stateManager.gameOver.value && this.accumulatorMs >= stateManager.gameSpeed.value) {
        stateManager.moveSnake();
        this.accumulatorMs -= stateManager.gameSpeed.value;
      }
      renderer.render(stateManager);
      if (stateManager.gameRunning.value && !stateManager.gameOver.value) {
        this.gameLoopId.value = requestAnimationFrame(frame);
      } else {
        this.gameLoopId.value = null;
      }
    };
    this.gameLoopId.value = requestAnimationFrame(frame);
  }
  stopGameLoop() {
    if (this.gameLoopId.value) {
      cancelAnimationFrame(this.gameLoopId.value);
      this.gameLoopId.value = null;
    }
  }
}

class SnakeGame {
  stateManager;
  canvasRenderer;
  gameEngine;
  constructor() {
    this.stateManager = new SnakeStateManager();
    this.canvasRenderer = new SnakeCanvasRenderer();
    this.gameEngine = new SnakeGameEngine();
  }
  initialize(canvas, words, vietnameseMode = false) {
    this.canvasRenderer.initialize(canvas);
    this.stateManager.resetGame();
    this.stateManager.generateFood(words, vietnameseMode);
    this.canvasRenderer.render(this.stateManager);
  }
  startGame() {
    if (this.stateManager.gameRunning.value) return;
    this.stateManager.setGameRunning(true);
    this.stateManager.updateDirection({ x: 1, y: 0 });
    this.gameEngine.startGameLoop(this.stateManager, this.canvasRenderer);
  }
  stopGame() {
    this.stateManager.setGameRunning(false);
    this.gameEngine.stopGameLoop();
  }
  handleKeyPress(event) {
    if (!this.stateManager.gameRunning.value || this.stateManager.gameOver.value) return;
    const directions = {
      ArrowUp: { x: 0, y: -1 },
      ArrowDown: { x: 0, y: 1 },
      ArrowLeft: { x: -1, y: 0 },
      ArrowRight: { x: 1, y: 0 },
      w: { x: 0, y: -1 },
      s: { x: 0, y: 1 },
      a: { x: -1, y: 0 },
      d: { x: 1, y: 0 }
    };
    const direction = directions[event.key];
    if (direction) {
      event.preventDefault();
      this.stateManager.updateDirection(direction);
    }
  }
  updateVietnameseMode(_vietnameseMode) {
    if (this.stateManager.gameRunning.value && this.stateManager.food.value) ;
  }
  cleanup() {
    this.stopGame();
  }
}

function useSnakeGame() {
  return new SnakeGame();
}

const _hoisted_1$l = { class: "snake-game h-full min-h-[600px] sm:min-h-[500px] md:min-h-0 flex flex-col" };
const _hoisted_2$i = { class: "p-4 sm:p-6 md:p-8 bg-gradient-to-r from-green-600 to-emerald-600 dark:from-green-800 dark:to-emerald-800 text-white" };
const _hoisted_3$h = { class: "flex justify-between items-center" };
const _hoisted_4$f = { class: "text-lg sm:text-xl md:text-2xl font-bold" };
const _hoisted_5$e = { class: "text-sm sm:text-base opacity-90" };
const _hoisted_6$d = { class: "text-right" };
const _hoisted_7$c = { class: "text-2xl sm:text-3xl font-bold" };
const _hoisted_8$c = { class: "text-xs sm:text-sm opacity-90" };
const _hoisted_9$c = { class: "flex-1 min-h-[450px] sm:min-h-[350px] md:min-h-0 relative bg-gradient-to-b from-gray-100 to-gray-200 dark:from-[#0a0a0a] dark:to-[#0f0f0f] overflow-hidden" };
const _hoisted_10$b = { class: "text-center" };
const _hoisted_11$b = { class: "text-sm sm:text-base font-bold text-gray-800 dark:text-white" };
const _hoisted_12$b = {
  key: 0,
  class: "text-xs sm:text-sm text-gray-700 dark:text-white/80"
};
const _hoisted_13$b = { class: "text-[11px] sm:text-xs text-gray-600 dark:text-white/70" };
const _hoisted_14$b = {
  key: 1,
  class: "absolute top-4 left-4 bg-white/90 dark:bg-[#0a0a0a]/90 rounded-lg p-3 backdrop-blur-sm"
};
const _hoisted_15$9 = { class: "text-sm text-gray-700 dark:text-white" };
const _hoisted_16$9 = { class: "font-semibold mb-1" };
const _hoisted_17$9 = { class: "text-xs space-y-1" };
const _hoisted_18$9 = { class: "absolute top-4 right-4 bg-white/90 dark:bg-[#0a0a0a]/90 rounded-lg p-3 backdrop-blur-sm" };
const _hoisted_19$9 = { class: "text-center text-sm" };
const _hoisted_20$9 = { class: "text-xs text-gray-600 dark:text-white/70" };
const _hoisted_21$9 = { class: "text-lg font-bold text-green-600 dark:text-green-400" };
const _hoisted_22$9 = {
  key: 2,
  class: "absolute inset-0 flex items-center justify-center"
};
const _hoisted_23$9 = {
  class: "lg:hidden absolute bottom-3 left-0 right-0 flex items-center justify-center select-none",
  "aria-hidden": "false"
};
const _hoisted_24$8 = { class: "inline-flex flex-col items-center gap-2 bg-white/90 dark:bg-[#0a0a0a]/90 border border-gray-200 dark:border-[#0f0f0f] rounded-xl p-3 shadow-lg" };
const _hoisted_25$8 = ["aria-label"];
const _hoisted_26$7 = { class: "flex items-center gap-2" };
const _hoisted_27$7 = ["aria-label"];
const _hoisted_28$7 = ["aria-label"];
const _hoisted_29$6 = ["aria-label"];
const _hoisted_30$5 = {
  key: 0,
  class: "absolute inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center p-4"
};
const _hoisted_31$5 = { class: "bg-white dark:bg-[#0a0a0a] rounded-2xl p-6 sm:p-8 max-w-md w-full text-center shadow-2xl border border-gray-200 dark:border-[#0f0f0f]" };
const _hoisted_32$4 = { class: "text-xl sm:text-2xl font-bold mb-2 text-gray-800 dark:text-white" };
const _hoisted_33$4 = { class: "text-gray-600 dark:text-white/70 mb-4" };
const _hoisted_34$4 = { class: "text-sm text-gray-500 dark:text-white/60 mb-6" };
const _hoisted_35$4 = { class: "flex gap-3 justify-center" };
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "SnakeGameMode",
  props: {
    words: {},
    vietnameseMode: { type: Boolean },
    doubleBaitMode: { type: Boolean },
    recordTimeline: { type: Boolean }
  },
  emits: ["game-complete", "correct-food-eaten", "wrong-food-eaten"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const { t } = useI18n();
    const emit = __emit;
    const game = useSnakeGame();
    const gameCanvas = ref();
    computed(() => game.canvasRenderer.canvasWidth.value);
    computed(() => game.canvasRenderer.canvasHeight.value);
    const gridSize = computed(() => game.canvasRenderer.gridSize.value);
    const score = computed(() => game.stateManager.score.value);
    const wordsCompleted = computed(() => game.stateManager.wordsCompleted.value);
    const gameOver = computed(() => game.stateManager.gameOver.value);
    const gameRunning = computed(() => game.stateManager.gameRunning.value);
    const currentTargetWord = computed(() => game.stateManager.currentTargetWord.value);
    const snakeHead = computed(() => game.stateManager.snake.value.body[0]);
    const timelineFrames = ref([]);
    const handleTimelineFrame = (body, direction) => {
      if (!props.recordTimeline) return;
      timelineFrames.value.push({
        body: [...body],
        direction: { ...direction }
      });
    };
    watch(
      () => props.recordTimeline,
      (enabled) => {
        if (enabled) {
          game.stateManager.setTimelineCallback(handleTimelineFrame);
          timelineFrames.value = [];
        } else {
          game.stateManager.setTimelineCallback(void 0);
          timelineFrames.value = [];
        }
      }
    );
    const snakeHeadDisplayStyle = computed(() => {
      if (!snakeHead.value || !gameRunning.value) {
        return { display: "none" };
      }
      const x = snakeHead.value.x * gridSize.value + gridSize.value / 2;
      const y = snakeHead.value.y * gridSize.value - 40;
      return {
        left: `${x}px`,
        top: `${y}px`,
        transform: "translateX(-50%)",
        zIndex: "10"
      };
    });
    const currentTargetPronunciation = computed(() => {
      const w = currentTargetWord.value;
      if (!w) return "";
      const found = props.words.find((v) => v.word === w);
      return found?.pronunciation || "";
    });
    const currentTargetPronunciationDisplay = computed(() => {
      const raw = (currentTargetPronunciation.value || "").trim();
      if (!raw) return "";
      const stripped = raw.replace(/^\s*[\/\[\]()]+|[\/\[\]()]+\s*$/g, "");
      return stripped ? `/${stripped}/` : "";
    });
    const prevWordsCompleted = ref(0);
    const stopWordsWatch = watch(
      () => game.stateManager.wordsCompleted.value,
      (newVal, oldVal) => {
        if (typeof oldVal === "number" && newVal > oldVal) {
          const lastWord = game.stateManager.lastEatenWord?.value || "";
          const lastPosition = game.stateManager.lastEatenFoodPos?.value || { x: 0, y: 0 };
          const currentVocab = props.words.find((w) => w.word === lastWord);
          const details = {
            word: lastWord,
            meaningShort: currentVocab?.meaning || lastWord,
            position: lastPosition,
            snakeLength: game.stateManager.snake.value.body.length,
            gameScore: game.stateManager.score.value,
            wordsCompleted: game.stateManager.wordsCompleted.value,
            wrongEatenCount: game.stateManager.wrongEatenCount?.value ?? 0,
            snakeBody: [...game.stateManager.snake.value.body],
            direction: { ...game.stateManager.snake.value.direction },
            timelineFrames: props.recordTimeline && timelineFrames.value.length ? [...timelineFrames.value.map((f) => ({
              body: f.body.map((seg) => ({ x: seg.x, y: seg.y })),
              direction: { x: f.direction.x, y: f.direction.y }
            }))] : void 0
          };
          console.log("[DEBUG] Snake correct food details:", details);
          console.log("[DEBUG] Snake body:", details.snakeBody);
          console.log("[DEBUG] Snake direction:", details.direction);
          emit("correct-food-eaten", details);
          if (props.recordTimeline) timelineFrames.value = [];
          if (lastWord) {
            const { playAudio } = useVoiceStore();
            playAudio(lastWord).catch(() => {
            });
          }
        }
        prevWordsCompleted.value = newVal;
      }
    );
    const prevWrongEaten = ref(0);
    const stopWrongWatch = watch(
      () => game.stateManager.wrongEatenCount?.value,
      (newVal, oldVal) => {
        if (typeof newVal === "number" && typeof oldVal === "number" && newVal > oldVal) {
          const lastWord = game.stateManager.lastEatenWord?.value || "";
          const lastPosition = game.stateManager.lastEatenFoodPos?.value || { x: 0, y: 0 };
          const currentVocab = props.words.find((w) => w.word === lastWord);
          const details = {
            word: lastWord,
            meaningShort: currentVocab?.meaning || lastWord,
            position: lastPosition,
            snakeLength: game.stateManager.snake.value.body.length,
            gameScore: game.stateManager.score.value,
            wordsCompleted: game.stateManager.wordsCompleted.value,
            wrongEatenCount: newVal,
            snakeBody: [...game.stateManager.snake.value.body],
            direction: { ...game.stateManager.snake.value.direction },
            timelineFrames: props.recordTimeline && timelineFrames.value.length ? [...timelineFrames.value.map((f) => ({
              body: f.body.map((seg) => ({ x: seg.x, y: seg.y })),
              direction: { x: f.direction.x, y: f.direction.y }
            }))] : void 0
          };
          emit("wrong-food-eaten", details);
          if (props.recordTimeline) timelineFrames.value = [];
          if (lastWord) {
            const { playAudio } = useVoiceStore();
            playAudio(lastWord).catch(() => {
            });
          }
        }
        if (typeof newVal === "number") prevWrongEaten.value = newVal;
      }
    );
    const stopGameOverWatch = watch(
      () => game.stateManager.gameOver.value,
      (isGameOver) => {
        if (isGameOver) {
          emit("game-complete");
        }
      }
    );
    watch(() => props.vietnameseMode, (newValue) => {
      game.updateVietnameseMode(newValue ?? false);
      if (game.stateManager.gameRunning.value) {
        game.stateManager.generateFood(props.words, newValue ?? false);
      }
    });
    watch(() => props.doubleBaitMode, (enabled) => {
      if (game.stateManager.setDoubleBaitMode) {
        game.stateManager.setDoubleBaitMode(!!enabled, props.words, props.vietnameseMode ?? false);
      }
    });
    const focusCanvas = () => {
      if (gameCanvas.value) {
        gameCanvas.value.focus();
      }
    };
    const startGame = () => {
      game.startGame();
      focusCanvas();
    };
    const restartGame = () => {
      game.stopGame();
      game.stateManager.resetGame();
      if (gameCanvas.value) {
        game.initialize(gameCanvas.value, props.words, props.vietnameseMode);
        if (game.stateManager.setDoubleBaitMode) {
          game.stateManager.setDoubleBaitMode(!!props.doubleBaitMode, props.words, props.vietnameseMode ?? false);
        }
        if (props.recordTimeline) {
          game.stateManager.setTimelineCallback(handleTimelineFrame);
        } else {
          game.stateManager.setTimelineCallback(void 0);
        }
      }
    };
    const handleKeyPress = (event) => {
      game.handleKeyPress(event);
    };
    const changeDirection = (dx, dy) => {
      if (gameOver.value) return;
      const notRunning = !gameRunning.value;
      if (notRunning) {
        game.startGame();
      }
      game.stateManager.updateDirection({ x: dx, y: dy });
    };
    onMounted(async () => {
      await nextTick();
      if (!gameCanvas.value) return;
      game.initialize(gameCanvas.value, props.words, props.vietnameseMode);
      if (game.stateManager.setDoubleBaitMode) {
        game.stateManager.setDoubleBaitMode(!!props.doubleBaitMode, props.words, props.vietnameseMode ?? false);
      }
      if (props.recordTimeline) {
        game.stateManager.setTimelineCallback(handleTimelineFrame);
      } else {
        game.stateManager.setTimelineCallback(void 0);
      }
      document.addEventListener("keydown", handleKeyPress);
    });
    onUnmounted(() => {
      stopGameOverWatch();
      stopWordsWatch();
      stopWrongWatch();
      document.removeEventListener("keydown", handleKeyPress);
      game.cleanup();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$l, [
        createBaseVNode("div", _hoisted_2$i, [
          createBaseVNode("div", _hoisted_3$h, [
            createBaseVNode("div", null, [
              createBaseVNode("h2", _hoisted_4$f, toDisplayString$1(unref(t)("flashcard.snakeGame.title", "Snake Hunt")), 1),
              createBaseVNode("p", _hoisted_5$e, toDisplayString$1(unref(t)("flashcard.snakeGame.instruction", "Guide the snake to catch vocabulary letters!")), 1)
            ]),
            createBaseVNode("div", _hoisted_6$d, [
              createBaseVNode("div", _hoisted_7$c, toDisplayString$1(score.value), 1),
              createBaseVNode("div", _hoisted_8$c, toDisplayString$1(unref(t)("flashcard.snakeGame.score", "Score")), 1)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_9$c, [
          createBaseVNode("canvas", {
            ref_key: "gameCanvas",
            ref: gameCanvas,
            class: "w-full h-full border-2 border-gray-300 dark:border-[#0f0f0f]",
            tabindex: "0",
            onKeydown: handleKeyPress
          }, null, 544),
          currentTargetWord.value && gameRunning.value && !gameOver.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "absolute bg-white dark:bg-[#0a0a0a] rounded-lg px-3 py-2 shadow-lg border-2 border-green-500 pointer-events-none",
            style: normalizeStyle(snakeHeadDisplayStyle.value)
          }, [
            createBaseVNode("div", _hoisted_10$b, [
              createBaseVNode("div", _hoisted_11$b, toDisplayString$1(currentTargetWord.value), 1),
              currentTargetPronunciationDisplay.value ? (openBlock(), createElementBlock("div", _hoisted_12$b, toDisplayString$1(currentTargetPronunciationDisplay.value), 1)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_13$b, toDisplayString$1(unref(t)("flashcard.snakeGame.target", "Target")), 1)
            ])
          ], 4)) : createCommentVNode("", true),
          !gameRunning.value && !gameOver.value ? (openBlock(), createElementBlock("div", _hoisted_14$b, [
            createBaseVNode("div", _hoisted_15$9, [
              createBaseVNode("div", _hoisted_16$9, toDisplayString$1(unref(t)("flashcard.snakeGame.controls", "Controls")) + ":", 1),
              createBaseVNode("div", _hoisted_17$9, [
                createBaseVNode("div", null, toDisplayString$1(unref(t)("flashcard.snakeGame.arrowKeys", "Arrow Keys / WASD")), 1),
                createBaseVNode("div", null, toDisplayString$1(unref(t)("flashcard.snakeGame.clickToStart", "Click START to begin")), 1)
              ])
            ])
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_18$9, [
            createBaseVNode("div", _hoisted_19$9, [
              createBaseVNode("div", _hoisted_20$9, toDisplayString$1(unref(t)("flashcard.snakeGame.completed", "Completed")), 1),
              createBaseVNode("div", _hoisted_21$9, toDisplayString$1(wordsCompleted.value), 1)
            ])
          ]),
          !gameRunning.value && !gameOver.value ? (openBlock(), createElementBlock("div", _hoisted_22$9, [
            createBaseVNode("button", {
              onClick: startGame,
              class: "px-8 py-4 bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white rounded-2xl font-bold text-lg transform hover:scale-105 transition-all duration-200 shadow-2xl"
            }, toDisplayString$1(unref(t)("flashcard.snakeGame.start", "START HUNT")), 1)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_23$9, [
            createBaseVNode("div", _hoisted_24$8, [
              createBaseVNode("button", {
                type: "button",
                "aria-label": unref(t)("flashcard.snakeGame.up", "Up"),
                class: "w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 rounded-lg flex items-center justify-center bg-emerald-500 hover:bg-emerald-600 text-white shadow active:scale-95 transition",
                onClick: _cache[0] || (_cache[0] = ($event) => changeDirection(0, -1))
              }, _cache[5] || (_cache[5] = [
                createBaseVNode("svg", {
                  class: "w-6 h-6 sm:w-7 sm:h-7",
                  viewBox: "0 0 20 20",
                  fill: "currentColor"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M10 4a.75.75 0 01.53.22l5 5a.75.75 0 11-1.06 1.06L10.75 6.56V16a.75.75 0 01-1.5 0V6.56L5.53 10.28a.75.75 0 01-1.06-1.06l5-5A.75.75 0 0110 4z",
                    "clip-rule": "evenodd"
                  })
                ], -1)
              ]), 8, _hoisted_25$8),
              createBaseVNode("div", _hoisted_26$7, [
                createBaseVNode("button", {
                  type: "button",
                  "aria-label": unref(t)("flashcard.snakeGame.left", "Left"),
                  class: "w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 rounded-lg flex items-center justify-center bg-emerald-500 hover:bg-emerald-600 text-white shadow active:scale-95 transition",
                  onClick: _cache[1] || (_cache[1] = ($event) => changeDirection(-1, 0))
                }, _cache[6] || (_cache[6] = [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 sm:w-7 sm:h-7",
                    viewBox: "0 0 20 20",
                    fill: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M4 10a.75.75 0 01.22-.53l5-5a.75.75 0 111.06 1.06L6.56 9.25H16a.75.75 0 010 1.5H6.56l3.72 3.72a.75.75 0 11-1.06 1.06l-5-5A.75.75 0 014 10z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)
                ]), 8, _hoisted_27$7),
                createBaseVNode("button", {
                  type: "button",
                  "aria-label": unref(t)("flashcard.snakeGame.down", "Down"),
                  class: "w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 rounded-lg flex items-center justify-center bg-emerald-500 hover:bg-emerald-600 text-white shadow active:scale-95 transition",
                  onClick: _cache[2] || (_cache[2] = ($event) => changeDirection(0, 1))
                }, _cache[7] || (_cache[7] = [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 sm:w-7 sm:h-7",
                    viewBox: "0 0 20 20",
                    fill: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M10 16a.75.75 0 01-.53-.22l-5-5a.75.75 0 111.06-1.06l3.72 3.72V4a.75.75 0 011.5 0v9.44l3.72-3.72a.75.75 0 111.06 1.06l-5 5A.75.75 0 0110 16z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)
                ]), 8, _hoisted_28$7),
                createBaseVNode("button", {
                  type: "button",
                  "aria-label": unref(t)("flashcard.snakeGame.right", "Right"),
                  class: "w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 rounded-lg flex items-center justify-center bg-emerald-500 hover:bg-emerald-600 text-white shadow active:scale-95 transition",
                  onClick: _cache[3] || (_cache[3] = ($event) => changeDirection(1, 0))
                }, _cache[8] || (_cache[8] = [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 sm:w-7 sm:h-7",
                    viewBox: "0 0 20 20",
                    fill: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M16 10a.75.75 0 01-.22.53l-5 5a.75.75 0 11-1.06-1.06l3.72-3.72H4a.75.75 0 010-1.5h9.44L9.72 5.53a.75.75 0 111.06-1.06l5 5c.14.14.22.33.22.53z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)
                ]), 8, _hoisted_29$6)
              ])
            ])
          ]),
          createVNode(Transition, {
            name: "modal",
            appear: ""
          }, {
            default: withCtx(() => [
              gameOver.value ? (openBlock(), createElementBlock("div", _hoisted_30$5, [
                createBaseVNode("div", _hoisted_31$5, [
                  _cache[9] || (_cache[9] = createBaseVNode("div", { class: "w-16 h-16 sm:w-20 sm:h-20 mx-auto mb-4 bg-gradient-to-r from-green-400 to-emerald-500 rounded-full flex items-center justify-center animate-pulse" }, [
                    createBaseVNode("svg", {
                      class: "w-8 h-8 sm:w-10 sm:h-10 text-white",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                        "clip-rule": "evenodd"
                      })
                    ])
                  ], -1)),
                  createBaseVNode("h3", _hoisted_32$4, toDisplayString$1(unref(t)("flashcard.snakeGame.gameComplete", "Hunt Complete!")), 1),
                  createBaseVNode("p", _hoisted_33$4, toDisplayString$1(unref(t)("flashcard.snakeGame.finalScore", { score: score.value }, `Final Score: ${score.value}`)), 1),
                  createBaseVNode("p", _hoisted_34$4, toDisplayString$1(unref(t)("flashcard.snakeGame.wordsHunted", { count: wordsCompleted.value }, `Words hunted: ${wordsCompleted.value}`)), 1),
                  createBaseVNode("div", _hoisted_35$4, [
                    createBaseVNode("button", {
                      onClick: restartGame,
                      class: "px-6 py-2 bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white rounded-lg font-medium transform hover:scale-105 transition-all duration-200"
                    }, toDisplayString$1(unref(t)("flashcard.snakeGame.playAgain", "Hunt Again")), 1),
                    createBaseVNode("button", {
                      onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("game-complete")),
                      class: "px-6 py-2 bg-gray-500 hover:bg-gray-600 dark:bg-[#0f0f0f] dark:hover:bg-[#1a1a1a] text-white rounded-lg font-medium transform hover:scale-105 transition-all duration-200"
                    }, toDisplayString$1(unref(t)("common.finish", "Finish")), 1)
                  ])
                ])
              ])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
});

const SnakeGameMode = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__scopeId", "data-v-43ecfa73"]]);

const SnakeGameMode$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: SnakeGameMode
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$k = { class: "bg-white dark:bg-[#0a0a0a] shadow" };
const _hoisted_2$h = { class: "max-w-4xl mx-auto py-6 px-4 sm:px-6 lg:px-8" };
const _hoisted_3$g = { class: "flex items-center justify-between" };
const _hoisted_4$e = { class: "flex items-center" };
const _hoisted_5$d = { class: "flex items-center space-x-4" };
const _hoisted_6$c = { class: "text-right" };
const _hoisted_7$b = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_8$b = { class: "text-right" };
const _hoisted_9$b = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "QuizHeader",
  props: {
    timeRemaining: {},
    score: {}
  },
  emits: ["go-back"],
  setup(__props, { emit: __emit }) {
    const formatTime = (seconds) => {
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      return `${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$k, [
        createBaseVNode("div", _hoisted_2$h, [
          createBaseVNode("div", _hoisted_3$g, [
            createBaseVNode("div", _hoisted_4$e, [
              createBaseVNode("button", {
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("go-back")),
                class: "mr-4 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
              }, _cache[1] || (_cache[1] = [
                createBaseVNode("svg", {
                  class: "w-6 h-6",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                    "clip-rule": "evenodd"
                  })
                ], -1)
              ])),
              _cache[2] || (_cache[2] = createBaseVNode("div", null, [
                createBaseVNode("h1", { class: "text-3xl font-bold text-gray-900 dark:text-white" }, "Quiz"),
                createBaseVNode("p", { class: "mt-2 text-sm text-gray-600 dark:text-gray-400" }, "Kiểm tra kiến thức của bạn")
              ], -1))
            ]),
            createBaseVNode("div", _hoisted_5$d, [
              createBaseVNode("div", _hoisted_6$c, [
                _cache[3] || (_cache[3] = createBaseVNode("p", { class: "text-sm text-gray-500 dark:text-gray-400" }, "Thời gian", -1)),
                createBaseVNode("p", _hoisted_7$b, toDisplayString$1(formatTime(_ctx.timeRemaining)), 1)
              ]),
              createBaseVNode("div", _hoisted_8$b, [
                _cache[4] || (_cache[4] = createBaseVNode("p", { class: "text-sm text-gray-500 dark:text-gray-400" }, "Điểm", -1)),
                createBaseVNode("p", _hoisted_9$b, toDisplayString$1(_ctx.score), 1)
              ])
            ])
          ])
        ])
      ]);
    };
  }
});

const QuizHeader = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$k
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$j = { class: "max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-4" };
const _hoisted_2$g = { class: "flex justify-between text-sm text-gray-600 dark:text-gray-400 mb-2" };
const _hoisted_3$f = { class: "w-full bg-gray-200 rounded-full h-2" };
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "QuizProgress",
  props: {
    currentQuestionIndex: {},
    totalQuestions: {},
    progressPercentage: {}
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$j, [
        createBaseVNode("div", _hoisted_2$g, [
          createBaseVNode("span", null, toDisplayString$1(unref(t)("quiz.progress.question")) + " " + toDisplayString$1(_ctx.currentQuestionIndex + 1) + " / " + toDisplayString$1(_ctx.totalQuestions), 1),
          createBaseVNode("span", null, toDisplayString$1(Math.round(_ctx.progressPercentage)) + "%", 1)
        ]),
        createBaseVNode("div", _hoisted_3$f, [
          createBaseVNode("div", {
            class: "bg-purple-500 h-2 rounded-full transition-all duration-300",
            style: normalizeStyle({ width: _ctx.progressPercentage + "%" })
          }, null, 4)
        ])
      ]);
    };
  }
});

const QuizProgress = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$j
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$i = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg p-8 border border-gray-200 dark:border-gray-700" };
const _hoisted_2$f = { class: "text-center mb-8" };
const _hoisted_3$e = { class: "text-2xl font-bold text-gray-900 dark:text-white mb-4" };
const _hoisted_4$d = { class: "text-gray-600 dark:text-gray-400" };
const _hoisted_5$c = { class: "grid grid-cols-1 md:grid-cols-2 gap-6 mb-8" };
const _hoisted_6$b = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_7$a = { value: "vocabulary" };
const _hoisted_8$a = { value: "grammar" };
const _hoisted_9$a = { value: "mixed" };
const _hoisted_10$a = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_11$a = { value: "" };
const _hoisted_12$a = ["value"];
const _hoisted_13$a = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_14$a = { value: "5" };
const _hoisted_15$8 = { value: "10" };
const _hoisted_16$8 = { value: "15" };
const _hoisted_17$8 = { value: "20" };
const _hoisted_18$8 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_19$8 = { value: "0" };
const _hoisted_20$8 = { value: "5" };
const _hoisted_21$8 = { value: "10" };
const _hoisted_22$8 = { value: "15" };
const _hoisted_23$8 = { class: "text-center" };
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "QuizSetup",
  props: {
    settings: {},
    availableLevels: {}
  },
  emits: ["start-quiz"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const localSettings = ref({ ...props.settings });
    watch(localSettings, (newSettings) => {
      emit("start-quiz", newSettings);
    }, { deep: true });
    const handleStartQuiz = () => {
      emit("start-quiz", localSettings.value);
    };
    const getLevelText = (level) => {
      switch (level) {
        case "beginner":
          return t("levels.beginner");
        case "intermediate":
          return t("levels.intermediate");
        case "advanced":
          return t("levels.advanced");
        default:
          return level;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$i, [
        createBaseVNode("div", _hoisted_2$f, [
          createBaseVNode("h2", _hoisted_3$e, toDisplayString$1(unref(t)("quiz.setup.title")), 1),
          createBaseVNode("p", _hoisted_4$d, toDisplayString$1(unref(t)("quiz.setup.description")), 1)
        ]),
        createBaseVNode("div", _hoisted_5$c, [
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_6$b, toDisplayString$1(unref(t)("quiz.setup.type")), 1),
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => localSettings.value.type = $event),
              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white"
            }, [
              createBaseVNode("option", _hoisted_7$a, toDisplayString$1(unref(t)("quiz.types.vocabulary")), 1),
              createBaseVNode("option", _hoisted_8$a, toDisplayString$1(unref(t)("quiz.types.grammar")), 1),
              createBaseVNode("option", _hoisted_9$a, toDisplayString$1(unref(t)("quiz.types.mixed")), 1)
            ], 512), [
              [vModelSelect, localSettings.value.type]
            ])
          ]),
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_10$a, toDisplayString$1(unref(t)("quiz.setup.level")), 1),
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => localSettings.value.level = $event),
              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white"
            }, [
              createBaseVNode("option", _hoisted_11$a, toDisplayString$1(unref(t)("quiz.setup.allLevels")), 1),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.availableLevels, (level) => {
                return openBlock(), createElementBlock("option", {
                  key: level,
                  value: level
                }, toDisplayString$1(getLevelText(level)), 9, _hoisted_12$a);
              }), 128))
            ], 512), [
              [vModelSelect, localSettings.value.level]
            ])
          ]),
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_13$a, toDisplayString$1(unref(t)("quiz.setup.questionCount")), 1),
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => localSettings.value.questionCount = $event),
              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white"
            }, [
              createBaseVNode("option", _hoisted_14$a, "5 " + toDisplayString$1(unref(t)("quiz.progress.question").toLowerCase()), 1),
              createBaseVNode("option", _hoisted_15$8, "10 " + toDisplayString$1(unref(t)("quiz.progress.question").toLowerCase()), 1),
              createBaseVNode("option", _hoisted_16$8, "15 " + toDisplayString$1(unref(t)("quiz.progress.question").toLowerCase()), 1),
              createBaseVNode("option", _hoisted_17$8, "20 " + toDisplayString$1(unref(t)("quiz.progress.question").toLowerCase()), 1)
            ], 512), [
              [vModelSelect, localSettings.value.questionCount]
            ])
          ]),
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_18$8, toDisplayString$1(unref(t)("quiz.setup.timeLimit")), 1),
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => localSettings.value.timeLimit = $event),
              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white"
            }, [
              createBaseVNode("option", _hoisted_19$8, toDisplayString$1(unref(t)("quiz.setup.unlimited")), 1),
              createBaseVNode("option", _hoisted_20$8, "5 " + toDisplayString$1(unref(t)("common.minutes")), 1),
              createBaseVNode("option", _hoisted_21$8, "10 " + toDisplayString$1(unref(t)("common.minutes")), 1),
              createBaseVNode("option", _hoisted_22$8, "15 " + toDisplayString$1(unref(t)("common.minutes")), 1)
            ], 512), [
              [vModelSelect, localSettings.value.timeLimit]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_23$8, [
          createBaseVNode("button", {
            onClick: handleStartQuiz,
            class: "bg-purple-500 hover:bg-purple-600 text-white font-medium py-3 px-8 rounded-lg transition-colors"
          }, toDisplayString$1(unref(t)("quiz.setup.start")), 1)
        ])
      ]);
    };
  }
});

const QuizSetup = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$i
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$h = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg p-8 border border-gray-200 dark:border-gray-700" };
const _hoisted_2$e = { class: "mb-8" };
const _hoisted_3$d = { class: "flex items-center justify-between mb-4" };
const _hoisted_4$c = { class: "px-3 py-1 bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200 text-sm font-medium rounded-full" };
const _hoisted_5$b = { class: "text-xl font-semibold text-gray-900 dark:text-white mb-6" };
const _hoisted_6$a = { class: "space-y-3" };
const _hoisted_7$9 = ["onClick"];
const _hoisted_8$9 = { class: "flex items-center" };
const _hoisted_9$9 = {
  key: 0,
  class: "text-white text-sm font-bold"
};
const _hoisted_10$9 = {
  key: 1,
  class: "text-gray-500 text-sm font-bold"
};
const _hoisted_11$9 = { class: "text-gray-900 dark:text-white" };
const _hoisted_12$9 = { class: "flex justify-between" };
const _hoisted_13$9 = ["disabled"];
const _hoisted_14$9 = ["disabled"];
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "QuizQuestion",
  props: {
    question: {},
    selectedAnswer: {},
    isFirstQuestion: { type: Boolean },
    isLastQuestion: { type: Boolean }
  },
  emits: ["select-answer", "previous-question", "next-question"],
  setup(__props, { emit: __emit }) {
    const getLevelColor = (level) => {
      switch (level) {
        case "beginner":
          return "bg-green-100 text-green-800";
        case "intermediate":
          return "bg-yellow-100 text-yellow-800";
        case "advanced":
          return "bg-red-100 text-red-800";
        default:
          return "bg-gray-100 text-gray-800";
      }
    };
    const { t } = useI18n();
    const getLevelText = (level) => {
      switch (level) {
        case "beginner":
          return t("levels.beginner");
        case "intermediate":
          return t("levels.intermediate");
        case "advanced":
          return t("levels.advanced");
        default:
          return level;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$h, [
        createBaseVNode("div", _hoisted_2$e, [
          createBaseVNode("div", _hoisted_3$d, [
            createBaseVNode("span", _hoisted_4$c, toDisplayString$1(_ctx.question.type === "vocabulary" ? unref(t)("quiz.types.vocabulary") : unref(t)("quiz.types.grammar")), 1),
            createBaseVNode("span", {
              class: normalizeClass([getLevelColor(_ctx.question.level), "px-3 py-1 text-sm font-medium rounded-full"])
            }, toDisplayString$1(getLevelText(_ctx.question.level)), 3)
          ]),
          createBaseVNode("h3", _hoisted_5$b, toDisplayString$1(_ctx.question.question), 1),
          createBaseVNode("div", _hoisted_6$a, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.question.options, (option, index) => {
              return openBlock(), createElementBlock("div", {
                key: index,
                onClick: ($event) => _ctx.$emit("select-answer", index),
                class: normalizeClass([
                  "p-4 border-2 rounded-lg cursor-pointer transition-all",
                  _ctx.selectedAnswer === index ? "border-purple-500 bg-purple-50 dark:bg-purple-900/20" : "border-gray-200 dark:border-gray-600 hover:border-gray-300 dark:hover:border-gray-500 hover:bg-gray-50 dark:hover:bg-gray-800"
                ])
              }, [
                createBaseVNode("div", _hoisted_8$9, [
                  createBaseVNode("div", {
                    class: normalizeClass([
                      "w-6 h-6 rounded-full border-2 mr-3 flex items-center justify-center",
                      _ctx.selectedAnswer === index ? "border-purple-500 bg-purple-500" : "border-gray-300"
                    ])
                  }, [
                    _ctx.selectedAnswer === index ? (openBlock(), createElementBlock("span", _hoisted_9$9, toDisplayString$1(String.fromCharCode(65 + index)), 1)) : (openBlock(), createElementBlock("span", _hoisted_10$9, toDisplayString$1(String.fromCharCode(65 + index)), 1))
                  ], 2),
                  createBaseVNode("span", _hoisted_11$9, toDisplayString$1(option), 1)
                ])
              ], 10, _hoisted_7$9);
            }), 128))
          ])
        ]),
        createBaseVNode("div", _hoisted_12$9, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("previous-question")),
            disabled: _ctx.isFirstQuestion,
            class: "bg-gray-500 hover:bg-gray-600 disabled:bg-gray-300 text-white font-medium py-2 px-6 rounded-lg transition-colors"
          }, toDisplayString$1(unref(t)("quiz.navigation.previous")), 9, _hoisted_13$9),
          createBaseVNode("button", {
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("next-question")),
            disabled: _ctx.selectedAnswer === null,
            class: "bg-purple-500 hover:bg-purple-600 disabled:bg-purple-300 text-white font-medium py-2 px-6 rounded-lg transition-colors"
          }, toDisplayString$1(_ctx.isLastQuestion ? unref(t)("quiz.navigation.finish") : unref(t)("quiz.navigation.next")), 9, _hoisted_14$9)
        ])
      ]);
    };
  }
});

const QuizQuestion = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$h
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$g = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg p-8 border border-gray-200 dark:border-gray-700" };
const _hoisted_2$d = { class: "text-center mb-8" };
const _hoisted_3$c = { class: "text-3xl font-bold text-gray-900 dark:text-white mb-2" };
const _hoisted_4$b = { class: "text-gray-600 dark:text-gray-400" };
const _hoisted_5$a = { class: "grid grid-cols-1 md:grid-cols-3 gap-6 mb-8" };
const _hoisted_6$9 = { class: "text-center p-6 bg-green-50 dark:bg-green-900/20 rounded-lg" };
const _hoisted_7$8 = { class: "text-3xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_8$8 = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_9$8 = { class: "text-center p-6 bg-blue-50 dark:bg-blue-900/20 rounded-lg" };
const _hoisted_10$8 = { class: "text-3xl font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_11$8 = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_12$8 = { class: "text-center p-6 bg-purple-50 dark:bg-purple-900/20 rounded-lg" };
const _hoisted_13$8 = { class: "text-3xl font-bold text-purple-600 dark:text-purple-400" };
const _hoisted_14$8 = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_15$7 = { class: "text-center mb-8" };
const _hoisted_16$7 = { class: "mb-8" };
const _hoisted_17$7 = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_18$7 = { class: "space-y-4" };
const _hoisted_19$7 = { class: "flex items-start justify-between mb-2" };
const _hoisted_20$7 = { class: "font-medium text-gray-900 dark:text-white" };
const _hoisted_21$7 = {
  key: 0,
  class: "text-green-600"
};
const _hoisted_22$7 = {
  key: 1,
  class: "text-red-600"
};
const _hoisted_23$7 = { class: "text-sm text-gray-600 dark:text-gray-400 mb-1" };
const _hoisted_24$7 = { class: "font-medium" };
const _hoisted_25$7 = {
  key: 0,
  class: "text-sm text-red-600"
};
const _hoisted_26$6 = { class: "font-medium" };
const _hoisted_27$6 = {
  key: 1,
  class: "text-sm text-gray-500 mt-2"
};
const _hoisted_28$6 = { class: "font-medium" };
const _hoisted_29$5 = { class: "flex justify-center space-x-4" };
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "QuizResults",
  props: {
    questions: {},
    userAnswers: {},
    score: {},
    correctAnswers: {},
    totalQuestions: {},
    accuracy: {}
  },
  emits: ["restart-quiz", "go-back"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$g, [
        createBaseVNode("div", _hoisted_2$d, [
          _cache[2] || (_cache[2] = createBaseVNode("div", { class: "mx-auto flex items-center justify-center h-16 w-16 rounded-full bg-green-100 dark:bg-green-900 mb-4" }, [
            createBaseVNode("svg", {
              class: "h-8 w-8 text-green-600 dark:text-green-400",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                "clip-rule": "evenodd"
              })
            ])
          ], -1)),
          createBaseVNode("h2", _hoisted_3$c, toDisplayString$1(unref(t)("quiz.results.completed")), 1),
          createBaseVNode("p", _hoisted_4$b, toDisplayString$1(unref(t)("quiz.results.yourResults")), 1)
        ]),
        createBaseVNode("div", _hoisted_5$a, [
          createBaseVNode("div", _hoisted_6$9, [
            createBaseVNode("p", _hoisted_7$8, toDisplayString$1(_ctx.score), 1),
            createBaseVNode("p", _hoisted_8$8, toDisplayString$1(unref(t)("quiz.results.score")), 1)
          ]),
          createBaseVNode("div", _hoisted_9$8, [
            createBaseVNode("p", _hoisted_10$8, toDisplayString$1(_ctx.correctAnswers) + "/" + toDisplayString$1(_ctx.totalQuestions), 1),
            createBaseVNode("p", _hoisted_11$8, toDisplayString$1(unref(t)("quiz.results.correct")), 1)
          ]),
          createBaseVNode("div", _hoisted_12$8, [
            createBaseVNode("p", _hoisted_13$8, toDisplayString$1(Math.round(_ctx.accuracy)) + "%", 1),
            createBaseVNode("p", _hoisted_14$8, toDisplayString$1(unref(t)("quiz.results.accuracy")), 1)
          ])
        ]),
        createBaseVNode("div", _hoisted_15$7, [
          createBaseVNode("span", {
            class: normalizeClass(["inline-block px-4 py-2 text-sm font-medium rounded-full", _ctx.accuracy >= 70 ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200" : "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200"])
          }, toDisplayString$1(_ctx.accuracy >= 70 ? unref(t)("quiz.results.passed") : unref(t)("quiz.results.failed")) + " (" + toDisplayString$1(_ctx.accuracy >= 70 ? unref(t)("quiz.results.above") : unref(t)("quiz.results.below")) + " 70%) ", 3)
        ]),
        createBaseVNode("div", _hoisted_16$7, [
          createBaseVNode("h3", _hoisted_17$7, toDisplayString$1(unref(t)("quiz.results.reviewAnswers")), 1),
          createBaseVNode("div", _hoisted_18$7, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.questions, (question, index) => {
              return openBlock(), createElementBlock("div", {
                key: index,
                class: "border border-gray-200 dark:border-gray-600 rounded-lg p-4"
              }, [
                createBaseVNode("div", _hoisted_19$7, [
                  createBaseVNode("p", _hoisted_20$7, toDisplayString$1(index + 1) + ". " + toDisplayString$1(question.question), 1),
                  _ctx.userAnswers[index] === question.correctAnswer ? (openBlock(), createElementBlock("span", _hoisted_21$7, _cache[3] || (_cache[3] = [
                    createBaseVNode("svg", {
                      class: "w-5 h-5",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)
                  ]))) : (openBlock(), createElementBlock("span", _hoisted_22$7, _cache[4] || (_cache[4] = [
                    createBaseVNode("svg", {
                      class: "w-5 h-5",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)
                  ])))
                ]),
                createBaseVNode("p", _hoisted_23$7, [
                  createBaseVNode("span", _hoisted_24$7, toDisplayString$1(unref(t)("quiz.results.correctAnswer")) + ":", 1),
                  createTextVNode(" " + toDisplayString$1(question.options[question.correctAnswer]), 1)
                ]),
                _ctx.userAnswers[index] !== question.correctAnswer ? (openBlock(), createElementBlock("p", _hoisted_25$7, [
                  createBaseVNode("span", _hoisted_26$6, toDisplayString$1(unref(t)("quiz.results.yourAnswer")) + ":", 1),
                  createTextVNode(" " + toDisplayString$1(question.options[_ctx.userAnswers[index]] || unref(t)("quiz.results.noAnswer")), 1)
                ])) : createCommentVNode("", true),
                question.explanation ? (openBlock(), createElementBlock("p", _hoisted_27$6, [
                  createBaseVNode("span", _hoisted_28$6, toDisplayString$1(unref(t)("quiz.results.explanation")) + ":", 1),
                  createTextVNode(" " + toDisplayString$1(question.explanation), 1)
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])
        ]),
        createBaseVNode("div", _hoisted_29$5, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("restart-quiz")),
            class: "bg-purple-500 hover:bg-purple-600 text-white font-medium py-2 px-6 rounded-lg transition-colors"
          }, toDisplayString$1(unref(t)("quiz.results.restartQuiz")), 1),
          createBaseVNode("button", {
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("go-back")),
            class: "bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-6 rounded-lg transition-colors"
          }, toDisplayString$1(unref(t)("common.goBack")), 1)
        ])
      ]);
    };
  }
});

const QuizResults = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$g
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$f = { class: "relative" };
const _hoisted_2$c = ["title"];
const _hoisted_3$b = {
  key: 0,
  class: "w-5 h-5 text-yellow-500 transition-transform duration-200 hover:rotate-12",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_4$a = {
  key: 1,
  class: "w-5 h-5 text-blue-400 transition-transform duration-200 hover:rotate-12",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_5$9 = {
  key: 2,
  class: "absolute inset-0 rounded-lg bg-blue-400 opacity-30 animate-ping"
};
const _hoisted_6$8 = {
  key: 0,
  class: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs font-medium text-white bg-gray-900 dark:bg-black dark:text-white dark:border dark:border-gray-600 rounded shadow-lg whitespace-nowrap z-50"
};
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "ThemeToggle",
  setup(__props) {
    const themeStore = useThemeStore();
    const isAnimating = ref(false);
    const showTooltip = ref(false);
    let tooltipTimer = null;
    const toggleTheme = () => {
      isAnimating.value = true;
      themeStore.toggleTheme();
      setTimeout(() => {
        isAnimating.value = false;
      }, 300);
    };
    const handleMouseEnter = () => {
      if (tooltipTimer) {
        clearTimeout(tooltipTimer);
      }
      tooltipTimer = setTimeout(() => {
        showTooltip.value = true;
      }, 500);
    };
    const handleMouseLeave = () => {
      if (tooltipTimer) {
        clearTimeout(tooltipTimer);
      }
      showTooltip.value = false;
    };
    const handleKeydown = (event) => {
      if ((event.ctrlKey || event.metaKey) && event.shiftKey && event.key === "T") {
        event.preventDefault();
        toggleTheme();
      }
    };
    onMounted(() => {
      const button = document.querySelector("[data-theme-toggle]");
      if (button) {
        button.addEventListener("mouseenter", handleMouseEnter);
        button.addEventListener("mouseleave", handleMouseLeave);
      }
      document.addEventListener("keydown", handleKeydown);
    });
    onUnmounted(() => {
      const button = document.querySelector("[data-theme-toggle]");
      if (button) {
        button.removeEventListener("mouseenter", handleMouseEnter);
        button.removeEventListener("mouseleave", handleMouseLeave);
      }
      document.removeEventListener("keydown", handleKeydown);
      if (tooltipTimer) {
        clearTimeout(tooltipTimer);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$f, [
        createBaseVNode("button", {
          onClick: toggleTheme,
          class: "relative inline-flex items-center justify-center w-10 h-10 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-black text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-900 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400",
          title: unref(themeStore).themeLabel()
        }, [
          !unref(themeStore).isDarkMode ? (openBlock(), createElementBlock("svg", _hoisted_3$b, _cache[0] || (_cache[0] = [
            createBaseVNode("path", {
              "fill-rule": "evenodd",
              d: "M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z",
              "clip-rule": "evenodd"
            }, null, -1)
          ]))) : (openBlock(), createElementBlock("svg", _hoisted_4$a, _cache[1] || (_cache[1] = [
            createBaseVNode("path", { d: "M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z" }, null, -1)
          ]))),
          isAnimating.value ? (openBlock(), createElementBlock("span", _hoisted_5$9)) : createCommentVNode("", true)
        ], 8, _hoisted_2$c),
        showTooltip.value ? (openBlock(), createElementBlock("div", _hoisted_6$8, [
          createTextVNode(toDisplayString$1(unref(themeStore).themeLabel()) + " ", 1),
          _cache[2] || (_cache[2] = createBaseVNode("div", { class: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900 dark:border-t-black" }, null, -1))
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const ThemeToggle = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-4c550120"]]);

const ThemeToggle$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: ThemeToggle
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$e = {
  key: 0,
  class: "flex items-center"
};
const _hoisted_2$b = {
  key: 1,
  class: "flex items-center"
};
const _hoisted_3$a = {
  key: 2,
  class: "flex items-center"
};
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "LanguageSwitcher",
  setup(__props) {
    const currentLocale = computed(() => getLocale());
    const toggleLanguage = () => {
      toggleLocale();
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        onClick: toggleLanguage,
        class: "inline-flex items-center px-3 py-1.5 border border-gray-300 dark:border-dark-bg-mute rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-white bg-white dark:bg-dark-bg-soft hover:bg-gray-50 dark:hover:bg-dark-bg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
      }, [
        currentLocale.value === "en" ? (openBlock(), createElementBlock("span", _hoisted_1$e, _cache[0] || (_cache[0] = [
          createBaseVNode("img", {
            src: "https://flagcdn.com/w20/us.png",
            width: "20",
            height: "15",
            class: "mr-2",
            alt: "English"
          }, null, -1),
          createTextVNode(" EN ")
        ]))) : currentLocale.value === "vi" ? (openBlock(), createElementBlock("span", _hoisted_2$b, _cache[1] || (_cache[1] = [
          createBaseVNode("img", {
            src: "https://flagcdn.com/w20/vn.png",
            width: "20",
            height: "15",
            class: "mr-2",
            alt: "Tiếng Việt"
          }, null, -1),
          createTextVNode(" VI ")
        ]))) : (openBlock(), createElementBlock("span", _hoisted_3$a, _cache[2] || (_cache[2] = [
          createBaseVNode("img", {
            src: "https://flagcdn.com/w20/kr.png",
            width: "20",
            height: "15",
            class: "mr-2",
            alt: "한국어"
          }, null, -1),
          createTextVNode(" KO ")
        ])))
      ]);
    };
  }
});

const LanguageSwitcher = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$e
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$d = ["title"];
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "MoveButton",
  props: {
    word: {},
    moveMode: { type: Boolean }
  },
  emits: ["move-vocabulary"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const props = __props;
    const emit = __emit;
    const handleMoveClick = () => {
      emit("move-vocabulary", {
        word: props.word,
        targetDate: "",
        sourceDate: props.word.createdAt
      });
    };
    return (_ctx, _cache) => {
      return _ctx.moveMode ? (openBlock(), createElementBlock("button", {
        key: 0,
        onClick: withModifiers(handleMoveClick, ["stop"]),
        class: "text-blue-500 hover:text-blue-600 dark:text-blue-400 dark:hover:text-blue-300 transition-colors",
        title: unref(t)("vocabulary.moveToDateGroup", "Move to another date group")
      }, _cache[0] || (_cache[0] = [
        createBaseVNode("svg", {
          class: "w-4 h-4",
          fill: "none",
          stroke: "currentColor",
          viewBox: "0 0 24 24"
        }, [
          createBaseVNode("path", {
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            "stroke-width": "2",
            d: "M13 7l5 5m0 0l-5 5m5-5H6"
          })
        ], -1)
      ]), 8, _hoisted_1$d)) : createCommentVNode("", true);
    };
  }
});

const _hoisted_1$c = { class: "flex flex-col lg:flex-row lg:items-center lg:justify-between xl:items-center xl:justify-between 2xl:items-center 2xl:justify-between space-y-3 lg:space-y-0" };
const _hoisted_2$a = { class: "flex-1" };
const _hoisted_3$9 = { class: "flex flex-col sm:flex-row sm:items-start xl:items-center 2xl:items-center space-y-3 sm:space-y-0 sm:space-x-4" };
const _hoisted_4$9 = {
  key: 0,
  class: "flex-shrink-0 self-center sm:self-start xl:self-center 2xl:self-center"
};
const _hoisted_5$8 = { class: "w-16 h-16 sm:w-20 sm:h-20 rounded-lg overflow-hidden border-2 border-gray-200 dark:border-gray-600" };
const _hoisted_6$7 = ["src", "alt"];
const _hoisted_7$7 = { class: "flex-1" };
const _hoisted_8$7 = { class: "text-base sm:text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_9$7 = { class: "text-xs sm:text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_10$7 = { class: "text-xs sm:text-sm text-gray-600 dark:text-gray-300 mt-1" };
const _hoisted_11$7 = { class: "flex items-center space-x-4 mt-2 text-xs text-gray-500 dark:text-gray-400" };
const _hoisted_12$7 = {
  key: 0,
  class: "flex items-center space-x-1"
};
const _hoisted_13$7 = {
  key: 1,
  class: "flex items-center space-x-1"
};
const _hoisted_14$7 = { class: "flex-2" };
const _hoisted_15$6 = { class: "flex items-center space-x-2" };
const _hoisted_16$6 = { class: "text-gray-700 dark:text-gray-300" };
const _hoisted_17$6 = {
  key: 0,
  class: "text-sm text-gray-500 dark:text-gray-400 mt-1"
};
const _hoisted_18$6 = { class: "font-medium" };
const _hoisted_19$6 = { class: "flex-shrink-0" };
const _hoisted_20$6 = { class: "text-xs text-gray-500 mt-1" };
const _hoisted_21$6 = { class: "flex items-center space-x-2 ml-4 xl:items-center 2xl:items-center" };
const _hoisted_22$6 = {
  class: "w-5 h-5",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_23$6 = {
  key: 0,
  d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"
};
const _hoisted_24$6 = {
  key: 1,
  d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z",
  fill: "none",
  stroke: "currentColor"
};
const _hoisted_25$6 = {
  key: 0,
  class: "fixed inset-0 z-[9999] flex items-center justify-center bg-black bg-opacity-75 p-4 backdrop-blur-sm"
};
const _hoisted_26$5 = { class: "relative w-full max-w-2xl bg-white dark:bg-[#0a0a0a] rounded-lg overflow-hidden shadow-2xl h-[400px] sm:h-[500px] md:h-[600px] transform" };
const _hoisted_27$5 = { class: "w-full h-full flex items-center justify-center p-4" };
const _hoisted_28$5 = ["src", "alt"];
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "VocabularyCard",
  props: {
    word: {},
    moveMode: { type: Boolean }
  },
  emits: ["play-audio", "edit-word", "delete-word", "toggle-favorite", "view-details", "move-vocabulary"],
  setup(__props, { emit: __emit }) {
    const { t, locale } = useI18n();
    const isImageModalOpen = ref(false);
    const openImageModal = () => {
      isImageModalOpen.value = true;
      document.body.style.overflow = "hidden";
    };
    const closeImageModal = () => {
      isImageModalOpen.value = false;
      document.body.style.overflow = "";
    };
    const props = __props;
    const emit = __emit;
    onUnmounted(() => {
      if (isImageModalOpen.value) {
        document.body.style.overflow = "";
      }
    });
    const viewDetails = () => {
      emit("view-details", props.word);
    };
    const handleImageError = (event) => {
      const img = event.target;
      console.warn(`Failed to load image for word: ${props.word.word}`, img.src);
      const container = img.closest(".flex-shrink-0");
      if (container) {
        container.style.display = "none";
      }
    };
    const getLevelColor = (level) => {
      switch (level) {
        case "beginner":
          return "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200";
        case "intermediate":
          return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200";
        case "advanced":
          return "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200";
        default:
          return "bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200";
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", {
          class: "p-3 sm:p-4 md:p-6 hover:bg-gray-50 dark:hover:bg-gray-custom cursor-pointer",
          onClick: viewDetails
        }, [
          createBaseVNode("div", _hoisted_1$c, [
            createBaseVNode("div", _hoisted_2$a, [
              createBaseVNode("div", _hoisted_3$9, [
                _ctx.word.image ? (openBlock(), createElementBlock("div", _hoisted_4$9, [
                  createBaseVNode("div", _hoisted_5$8, [
                    createBaseVNode("img", {
                      src: _ctx.word.image,
                      alt: `${unref(t)("vocabulary.image.preview", "Image preview")} - ${_ctx.word.word}`,
                      class: "w-full h-full object-cover cursor-pointer",
                      onError: handleImageError,
                      onClick: withModifiers(openImageModal, ["stop"])
                    }, null, 40, _hoisted_6$7)
                  ])
                ])) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_7$7, [
                  createBaseVNode("h4", _hoisted_8$7, toDisplayString$1(_ctx.word.word), 1),
                  createBaseVNode("p", _hoisted_9$7, toDisplayString$1(_ctx.word.pronunciation), 1),
                  createBaseVNode("p", _hoisted_10$7, toDisplayString$1(_ctx.word.partOfSpeech), 1),
                  createBaseVNode("div", _hoisted_11$7, [
                    _ctx.word.createdAt ? (openBlock(), createElementBlock("div", _hoisted_12$7, [
                      _cache[5] || (_cache[5] = createBaseVNode("svg", {
                        class: "w-3 h-3",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)),
                      createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.createdAt", "Created at")) + ": " + toDisplayString$1(unref(getRelativeTime)(_ctx.word.createdAt, unref(t))), 1)
                    ])) : createCommentVNode("", true),
                    _ctx.word.updatedAt && _ctx.word.updatedAt !== _ctx.word.createdAt ? (openBlock(), createElementBlock("div", _hoisted_13$7, [
                      _cache[6] || (_cache[6] = createBaseVNode("svg", {
                        class: "w-3 h-3",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", { d: "M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" })
                      ], -1)),
                      createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.updatedAt", "Updated at")) + ": " + toDisplayString$1(unref(getRelativeTime)(_ctx.word.updatedAt, unref(t))), 1)
                    ])) : createCommentVNode("", true)
                  ])
                ]),
                createBaseVNode("div", _hoisted_14$7, [
                  createBaseVNode("div", _hoisted_15$6, [
                    createBaseVNode("p", _hoisted_16$6, toDisplayString$1(_ctx.word.meaning), 1),
                    createVNode(unref(_sfc_main$d), {
                      word: _ctx.word,
                      "move-mode": _ctx.moveMode,
                      onMoveVocabulary: _cache[0] || (_cache[0] = ($event) => emit("move-vocabulary", $event))
                    }, null, 8, ["word", "move-mode"])
                  ]),
                  _ctx.word.example ? (openBlock(), createElementBlock("p", _hoisted_17$6, [
                    createBaseVNode("span", _hoisted_18$6, toDisplayString$1(unref(t)("vocabulary.example", "Example")) + ":", 1),
                    createTextVNode(" " + toDisplayString$1(_ctx.word.example), 1)
                  ])) : createCommentVNode("", true)
                ]),
                createBaseVNode("div", _hoisted_19$6, [
                  createBaseVNode("span", {
                    class: normalizeClass([getLevelColor(_ctx.word.level), "px-2 py-1 text-xs font-medium rounded-full"])
                  }, toDisplayString$1(unref(t)(`vocabulary.levels.${_ctx.word.level}`, _ctx.word.level)), 3),
                  createBaseVNode("p", _hoisted_20$6, toDisplayString$1(unref(getTopicName)(_ctx.word.category, unref(t), unref(locale), _ctx.word)), 1)
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_21$6, [
              createBaseVNode("button", {
                onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.$emit("toggle-favorite", _ctx.word), ["stop"])),
                class: normalizeClass(["text-gray-500 hover:text-yellow-500", { "text-yellow-500": _ctx.word.favorite }])
              }, [
                (openBlock(), createElementBlock("svg", _hoisted_22$6, [
                  _ctx.word.favorite ? (openBlock(), createElementBlock("path", _hoisted_23$6)) : (openBlock(), createElementBlock("path", _hoisted_24$6))
                ]))
              ], 2),
              createBaseVNode("button", {
                onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.$emit("play-audio", _ctx.word.word), ["stop"])),
                class: "text-blue-500 hover:text-blue-600"
              }, _cache[7] || (_cache[7] = [
                createBaseVNode("svg", {
                  class: "w-5 h-5",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.816L4.846 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.846l3.537-3.816a1 1 0 011.617.816zM16 8a2 2 0 11-4 0 2 2 0 014 0zM14 8a2 2 0 012-2v4a2 2 0 01-2-2z",
                    "clip-rule": "evenodd"
                  })
                ], -1)
              ])),
              createBaseVNode("button", {
                onClick: _cache[3] || (_cache[3] = withModifiers(($event) => _ctx.$emit("edit-word", _ctx.word), ["stop"])),
                class: "text-gray-500 hover:text-gray-600"
              }, _cache[8] || (_cache[8] = [
                createBaseVNode("svg", {
                  class: "w-5 h-5",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
                ], -1)
              ])),
              createBaseVNode("button", {
                onClick: _cache[4] || (_cache[4] = withModifiers(($event) => _ctx.$emit("delete-word", _ctx.word), ["stop"])),
                class: "text-red-500 hover:text-red-600"
              }, _cache[9] || (_cache[9] = [
                createBaseVNode("svg", {
                  class: "w-5 h-5",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M9 2a1 1 0 000 2h2a1 1 0 100-2H9z",
                    "clip-rule": "evenodd"
                  }),
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",
                    "clip-rule": "evenodd"
                  })
                ], -1)
              ]))
            ])
          ])
        ]),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          createVNode(Transition, {
            "enter-active-class": "transition-all duration-500 ease-out",
            "enter-from-class": "opacity-0",
            "enter-to-class": "opacity-100",
            "leave-active-class": "transition-all duration-300 ease-in",
            "leave-from-class": "opacity-100",
            "leave-to-class": "opacity-0"
          }, {
            default: withCtx(() => [
              isImageModalOpen.value ? (openBlock(), createElementBlock("div", _hoisted_25$6, [
                createVNode(Transition, {
                  "enter-active-class": "transition-all duration-500 ease-out",
                  "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                  "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                  "leave-active-class": "transition-all duration-300 ease-in",
                  "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                  "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_26$5, [
                      createBaseVNode("button", {
                        onClick: closeImageModal,
                        class: "absolute top-4 right-4 z-[10000] text-gray-600 dark:text-white hover:text-gray-800 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 bg-white dark:bg-[#0a0a0a] bg-opacity-80 dark:bg-opacity-80 rounded-full p-2 shadow-lg"
                      }, _cache[10] || (_cache[10] = [
                        createBaseVNode("svg", {
                          class: "w-6 h-6",
                          fill: "none",
                          stroke: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          createBaseVNode("path", {
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            "stroke-width": "2",
                            d: "M6 18L18 6M6 6l12 12"
                          })
                        ], -1)
                      ])),
                      createBaseVNode("div", _hoisted_27$5, [
                        createBaseVNode("img", {
                          src: _ctx.word.image,
                          alt: `${unref(t)("vocabulary.image.preview", "Image preview")} - ${_ctx.word.word}`,
                          class: "max-w-full max-h-full object-contain rounded-lg shadow-lg animate-fade-in-up",
                          style: { "animation-delay": "0.2s" }
                        }, null, 8, _hoisted_28$5)
                      ])
                    ])
                  ]),
                  _: 1
                })
              ])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ]))
      ]);
    };
  }
});

const VocabularyCard = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-facc0634"]]);

const VocabularyCard$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: VocabularyCard
}, Symbol.toStringTag, { value: 'Module' }));

function useDailyProgress() {
  const { practiceHistory } = useFlashcardHistory();
  const DAILY_TARGET = 10;
  const getDailyProgress = (targetDate) => {
    const target = new Date(targetDate);
    const targetDateString = target.toDateString();
    const sessionsForDate = practiceHistory.value.filter((session) => {
      const sessionDate = new Date(session.date);
      return sessionDate.toDateString() === targetDateString;
    });
    const uniqueWordsLearned = /* @__PURE__ */ new Set();
    sessionsForDate.forEach((session) => {
      const wordsInSession = session.correctAnswers;
      for (let i = 0; i < wordsInSession; i++) {
        uniqueWordsLearned.add(`${session.id}-${i}`);
      }
    });
    const wordsLearned = uniqueWordsLearned.size;
    const percentage = Math.min(wordsLearned / DAILY_TARGET * 100, 100);
    return {
      date: targetDate,
      wordsLearned,
      totalWords: DAILY_TARGET,
      percentage: Math.round(percentage),
      isCompleted: percentage >= 100
    };
  };
  const getMultipleDailyProgress = (dates) => {
    return dates.map((date) => getDailyProgress(date));
  };
  const getTodayProgress = () => {
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    return getDailyProgress(today);
  };
  const getWeeklyProgress = () => {
    const today = /* @__PURE__ */ new Date();
    const weekStart = new Date(today);
    weekStart.setDate(today.getDate() - today.getDay());
    const weekDates = [];
    for (let i = 0; i < 7; i++) {
      const date = new Date(weekStart);
      date.setDate(weekStart.getDate() + i);
      weekDates.push(date.toISOString().split("T")[0]);
    }
    const weeklyStats = getMultipleDailyProgress(weekDates);
    const totalWordsLearned = weeklyStats.reduce((sum, day) => sum + day.wordsLearned, 0);
    const totalTarget = DAILY_TARGET * 7;
    const weeklyPercentage = Math.min(totalWordsLearned / totalTarget * 100, 100);
    return {
      wordsLearned: totalWordsLearned,
      totalWords: totalTarget,
      percentage: Math.round(weeklyPercentage),
      daysCompleted: weeklyStats.filter((day) => day.isCompleted).length,
      dailyStats: weeklyStats
    };
  };
  const hasActivityForDate = (targetDate) => {
    const target = new Date(targetDate);
    const targetDateString = target.toDateString();
    return practiceHistory.value.some((session) => {
      const sessionDate = new Date(session.date);
      return sessionDate.toDateString() === targetDateString;
    });
  };
  return {
    DAILY_TARGET,
    getDailyProgress,
    getMultipleDailyProgress,
    getTodayProgress,
    getWeeklyProgress,
    hasActivityForDate
  };
}

const _hoisted_1$b = { class: "mb-3 xs:mb-4 sm:mb-6" };
const _hoisted_2$9 = { class: "sticky top-0 bg-gray-50 dark:bg-[#0f0f0f] px-2 xs:px-3 sm:px-4 md:px-6 py-2 xs:py-2.5 sm:py-3 border-b border-gray-200 dark:border-gray-700 z-10" };
const _hoisted_3$8 = { class: "sm:block md:hidden" };
const _hoisted_4$8 = { class: "flex items-center space-x-1 flex-1" };
const _hoisted_5$7 = { class: "p-0.5 rounded-md" };
const _hoisted_6$6 = { class: "text-xs sm:text-sm md:text-base lg:text-lg xl:text-base 2xl:text-lg font-semibold text-gray-700 dark:text-gray-300 flex items-center space-x-1" };
const _hoisted_7$6 = { class: "inline-flex items-center ml-1.5 xs:ml-2" };
const _hoisted_8$6 = { class: "relative inline-flex items-center cursor-pointer" };
const _hoisted_9$6 = ["disabled"];
const _hoisted_10$6 = { class: "text-xs sm:text-sm md:text-base lg:text-lg xl:text-base 2xl:text-lg text-gray-500 dark:text-gray-400" };
const _hoisted_11$6 = ["disabled"];
const _hoisted_12$6 = {
  key: 0,
  class: "flex items-center justify-center mb-3"
};
const _hoisted_13$6 = { class: "flex items-center space-x-1 w-full max-w-[280px]" };
const _hoisted_14$6 = ["placeholder"];
const _hoisted_15$5 = ["aria-label"];
const _hoisted_16$5 = ["aria-label"];
const _hoisted_17$5 = { key: 1 };
const _hoisted_18$5 = {
  key: 0,
  class: "flex items-center justify-center mb-1.5"
};
const _hoisted_19$5 = { class: "flex items-center space-x-1 px-2.5 py-1 bg-orange-50 dark:bg-orange-900/50 rounded-lg border border-orange-200 dark:border-orange-700 max-w-[180px]" };
const _hoisted_20$5 = { class: "relative flex-1 min-w-0" };
const _hoisted_21$5 = {
  key: 0,
  class: "absolute z-[9999] bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 dark:bg-gray-700 text-white text-xs rounded-lg shadow-lg whitespace-nowrap"
};
const _hoisted_22$5 = ["aria-label"];
const _hoisted_23$5 = { class: "grid grid-cols-2 gap-2 max-w-[280px] sm:max-w-[320px] mx-auto" };
const _hoisted_24$5 = ["aria-label"];
const _hoisted_25$5 = { class: "text-center leading-tight" };
const _hoisted_26$4 = {
  key: 1,
  class: "flex"
};
const _hoisted_27$4 = ["aria-label"];
const _hoisted_28$4 = { class: "text-center leading-tight" };
const _hoisted_29$4 = {
  key: 3,
  class: "flex"
};
const _hoisted_30$4 = { class: "hidden md:block" };
const _hoisted_31$4 = { class: "flex items-center space-x-2" };
const _hoisted_32$3 = { class: "p-1 rounded-md" };
const _hoisted_33$3 = { class: "text-xs xs:text-sm sm:text-sm md:text-base lg:text-base xl:text-sm 2xl:text-base font-semibold text-gray-700 dark:text-gray-300 flex items-center space-x-1 xs:space-x-1.5 sm:space-x-2" };
const _hoisted_34$3 = { class: "inline-flex items-center ml-1.5 xs:ml-2" };
const _hoisted_35$3 = { class: "relative inline-flex items-center cursor-pointer" };
const _hoisted_36$3 = { class: "hidden lg:flex items-center space-x-2" };
const _hoisted_37$2 = ["disabled"];
const _hoisted_38$2 = { class: "text-xs sm:text-sm md:text-base lg:text-lg xl:text-sm 2xl:text-base text-gray-500 dark:text-gray-400" };
const _hoisted_39$2 = ["disabled"];
const _hoisted_40$2 = { class: "relative inline-flex items-center cursor-pointer" };
const _hoisted_41$1 = { class: "text-xs sm:text-sm md:text-base lg:text-lg xl:text-sm 2xl:text-base text-gray-600 dark:text-gray-300" };
const _hoisted_42$1 = ["disabled"];
const _hoisted_43$1 = { class: "text-xs sm:text-sm md:text-base text-gray-500 dark:text-gray-400" };
const _hoisted_44$1 = ["disabled"];
const _hoisted_45$1 = {
  key: 0,
  class: "flex items-center space-x-2"
};
const _hoisted_46$1 = {
  key: 0,
  class: "flex items-center space-x-1 xs:space-x-1.5 sm:space-x-1.5 md:space-x-2 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 bg-orange-50 dark:bg-orange-900/50 rounded-full border border-orange-200 dark:border-orange-700"
};
const _hoisted_47$1 = { class: "relative" };
const _hoisted_48$1 = {
  key: 0,
  class: "absolute z-[9999] bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 dark:bg-gray-700 text-white text-xs rounded-lg shadow-lg whitespace-nowrap"
};
const _hoisted_49$1 = ["aria-label"];
const _hoisted_50$1 = ["aria-label"];
const _hoisted_51 = { class: "whitespace-nowrap" };
const _hoisted_52 = ["aria-label"];
const _hoisted_53 = {
  key: 1,
  class: "flex items-center space-x-1 xs:space-x-1.5 sm:space-x-2 w-full max-w-[150px] xs:max-w-[200px] sm:max-w-xs"
};
const _hoisted_54 = ["placeholder"];
const _hoisted_55 = ["aria-label"];
const _hoisted_56 = ["aria-label"];
const _hoisted_57 = { class: "hidden lg:block" };
const _hoisted_58 = { class: "flex-1 flex justify-center mx-1 xs:mx-2 sm:mx-4 min-w-0" };
const _hoisted_59 = {
  key: 0,
  class: "flex items-center space-x-1.5 xs:space-x-1.5 sm:space-x-2 flex-nowrap"
};
const _hoisted_60 = {
  key: 0,
  class: "flex items-center space-x-1 md:space-x-1.5 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 lg:py-1.5 xl:py-1.5 2xl:py-1.5 bg-orange-50 dark:bg-orange-900/50 rounded-full border border-orange-200 dark:border-orange-700 flex-shrink-0"
};
const _hoisted_61 = { class: "relative" };
const _hoisted_62 = {
  key: 0,
  class: "absolute z-[9999] bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 dark:bg-gray-700 text-white text-xs rounded-lg shadow-lg whitespace-nowrap"
};
const _hoisted_63 = ["aria-label"];
const _hoisted_64 = ["aria-label"];
const _hoisted_65 = ["aria-label"];
const _hoisted_66 = ["placeholder"];
const _hoisted_67 = ["aria-label"];
const _hoisted_68 = ["aria-label"];
const _hoisted_69 = {
  key: 0,
  class: "accordion-content"
};
const _hoisted_70 = {
  key: 0,
  class: "divide-y divide-gray-200 dark:divide-gray-700"
};
const _hoisted_71 = ["onMouseenter", "onMouseleave"];
const _hoisted_72 = { class: "bg-gray-50 dark:bg-gray-custom border-b border-gray-200 dark:border-gray-700" };
const _hoisted_73 = ["id", "onClick"];
const _hoisted_74 = { class: "flex items-center space-x-2" };
const _hoisted_75 = { class: "flex items-center space-x-1" };
const _hoisted_76 = { class: "text-sm font-medium text-gray-600 dark:text-gray-400" };
const _hoisted_77 = { class: "text-xs text-gray-500" };
const _hoisted_78 = ["onMouseenter"];
const _hoisted_79 = ["aria-label"];
const _hoisted_80 = { class: "text-xs font-semibold mb-2" };
const _hoisted_81 = {
  key: 0,
  class: "text-xs text-gray-600 dark:text-white/70"
};
const _hoisted_82 = ["onClick"];
const _hoisted_83 = { class: "text-gray-500 dark:text-white/60" };
const _hoisted_84 = ["onClick", "title"];
const _hoisted_85 = { class: "flex items-center justify-between text-xs" };
const _hoisted_86 = { class: "flex-1 flex justify-between sm:hidden" };
const _hoisted_87 = ["onClick", "disabled"];
const _hoisted_88 = ["onClick", "disabled"];
const _hoisted_89 = { class: "hidden sm:flex-1 sm:flex sm:items-center sm:justify-between" };
const _hoisted_90 = { class: "text-xs text-gray-700 dark:text-gray-300" };
const _hoisted_91 = { class: "relative z-0 inline-flex rounded-md shadow-sm -space-x-px" };
const _hoisted_92 = ["onClick", "disabled"];
const _hoisted_93 = { class: "sr-only" };
const _hoisted_94 = ["onClick", "disabled"];
const _hoisted_95 = ["onClick", "disabled"];
const _hoisted_96 = { class: "sr-only" };
const _hoisted_97 = {
  key: 0,
  class: "topic-accordion-content py-2"
};
const _hoisted_98 = { class: "divide-y divide-gray-200 dark:divide-gray-700" };
const _hoisted_99 = {
  key: 1,
  class: "divide-y divide-gray-200 dark:divide-gray-700"
};
const SHOW_ACTION_BUTTONS_KEY = "vocabulary-show-action-buttons-by-date";
const itemsPerCategoryPage = 5;
const TOPIC_PAGINATION_STORAGE_KEY = "vocabulary-topic-pagination-state";
const TOPICS_STORAGE_KEY = "vocabulary-group-topics";
const PENDING_OPEN_KEY = "open-date-topic-pending";
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "DateGroupAccordion",
  props: {
    group: {},
    defaultExpanded: { type: Boolean, default: false },
    accordionState: { default: () => ({}) },
    hoverToExpandEnabled: { type: Boolean, default: false },
    globalMoveMode: { type: Boolean, default: false }
  },
  emits: ["play-audio", "edit-word", "delete-word", "toggle-favorite", "view-details", "date-group-previous", "date-group-next", "accordion-toggle", "note-saved", "open-note-dialog", "open-add-vocabulary-dialog", "open-grammar-manager", "move-vocabulary", "request-available-dates", "navigate-to-date-topic", "batch-move-category"],
  setup(__props, { emit: __emit }) {
    const { t, locale } = useI18n();
    const VocabularyCard = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => VocabularyCard$1),true              ?void 0:void 0))
    );
    const VocabularyNoteButton$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => VocabularyNoteButton),true              ?void 0:void 0))
    );
    const GrammarManagerButton$1 = defineAsyncComponent(() => loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => GrammarManagerButton),true              ?void 0:void 0))());
    const CircularProgress = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => CircularProgress$1),true              ?void 0:void 0))
    );
    const props = __props;
    const totalVocabularyCount = computed(() => {
      if (props.group.totalItems && props.group.totalItems > 0) {
        return props.group.totalItems;
      }
      if (props.group.topics && props.group.topics.length > 0) {
        return props.group.topics.reduce((total, topicGroup) => {
          return total + (topicGroup.vocabularies?.length || 0);
        }, 0);
      } else {
        return props.group.vocabularies?.length || 0;
      }
    });
    const isTodayGroup = computed(() => {
      const today = /* @__PURE__ */ new Date();
      const todayKey = getDateKey(today.toISOString());
      return props.group.date === todayKey;
    });
    const { getDailyProgress, DAILY_TARGET } = useDailyProgress();
    const dailyProgress = computed(() => getDailyProgress(props.group.date));
    const headerProgress = computed(() => {
      const count = totalVocabularyCount.value;
      const percentage = Math.min(count / DAILY_TARGET * 100, 100);
      return {
        percentage: Math.round(percentage),
        wordsLearned: dailyProgress.value.wordsLearned,
        totalWords: DAILY_TARGET
      };
    });
    computed(() => {
      const pctLabel = t("progress.percentage", "Percentage");
      const learnedLabel = t("progress.wordsLearned", "Words learned");
      return `${pctLabel}: ${dailyProgress.value.percentage}% · ${learnedLabel}: ${dailyProgress.value.wordsLearned}/${dailyProgress.value.totalWords}`;
    });
    const headerProgressTooltip = computed(() => {
      const pctLabel = t("progress.percentage", "Percentage");
      const vocabLabel = t("vocabulary.words", "Words");
      return `${pctLabel}: ${headerProgress.value.percentage}% · ${totalVocabularyCount.value}/${DAILY_TARGET} ${vocabLabel}`;
    });
    const vocabularyCountColor = computed(() => {
      const count = totalVocabularyCount.value;
      const group = Math.floor(count / 10);
      const colors = [
        // 0-9 words: Red
        { light: "text-red-600", dark: "dark:text-red-400" },
        // 10-19 words: Orange  
        { light: "text-orange-600", dark: "dark:text-orange-400" },
        // 20-29 words: Yellow
        { light: "text-yellow-600", dark: "dark:text-yellow-400" },
        // 30-39 words: Green
        { light: "text-green-600", dark: "dark:text-green-400" },
        // 40-49 words: Blue
        { light: "text-blue-600", dark: "dark:text-blue-400" },
        // 50+ words: Purple
        { light: "text-purple-600", dark: "dark:text-purple-400" }
      ];
      const colorIndex = Math.min(group, colors.length - 1);
      const color = colors[colorIndex];
      return `${color.light} ${color.dark}`;
    });
    const isTopicTruncated = computed(() => {
      if (!groupTopic.value) {
        return false;
      }
      if (topicSpanMobile.value) {
        return topicSpanMobile.value.scrollWidth > topicSpanMobile.value.clientWidth;
      }
      if (topicSpanDesktop.value) {
        return topicSpanDesktop.value.scrollWidth > topicSpanDesktop.value.clientWidth;
      }
      return false;
    });
    const isExpanded = ref(false);
    ref(false);
    ref(null);
    const accordionContent = ref();
    const accordionMaxHeight = ref(0);
    const showActionButtons = ref(true);
    const loadActionButtonsState = () => {
      try {
        const saved = localStorage.getItem(SHOW_ACTION_BUTTONS_KEY);
        if (saved !== null) {
          const allStates = JSON.parse(saved);
          if (typeof allStates === "object" && allStates[props.group.date] !== void 0) {
            showActionButtons.value = allStates[props.group.date];
          }
        }
      } catch (error) {
        console.warn("Failed to load action buttons state from localStorage:", error);
        showActionButtons.value = true;
      }
    };
    const saveActionButtonsState = () => {
      try {
        const saved = localStorage.getItem(SHOW_ACTION_BUTTONS_KEY);
        let allStates = {};
        if (saved !== null) {
          allStates = JSON.parse(saved);
        }
        allStates[props.group.date] = showActionButtons.value;
        localStorage.setItem(SHOW_ACTION_BUTTONS_KEY, JSON.stringify(allStates));
      } catch (error) {
        console.warn("Failed to save action buttons state to localStorage:", error);
      }
    };
    watch(showActionButtons, () => {
      saveActionButtonsState();
    });
    const expandedTopics = ref({});
    const topicPaginationState = ref({});
    const loadTopicPaginationState = () => {
      try {
        const stored = localStorage.getItem(TOPIC_PAGINATION_STORAGE_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch (error) {
        console.warn("Failed to load topic pagination state from localStorage:", error);
        return {};
      }
    };
    const saveTopicPaginationState = (state) => {
      try {
        localStorage.setItem(TOPIC_PAGINATION_STORAGE_KEY, JSON.stringify(state));
      } catch (error) {
        console.warn("Failed to save topic pagination state to localStorage:", error);
      }
    };
    const toggleTopicAccordion = (topic) => {
      expandedTopics.value[topic] = !expandedTopics.value[topic];
      if (!topicPaginationState.value[topic]) {
        topicPaginationState.value[topic] = { currentPage: 1 };
      }
    };
    const isTopicExpanded = (topic) => {
      return expandedTopics.value[topic] || false;
    };
    const getTopicCurrentPage = (topic) => {
      return topicPaginationState.value[topic]?.currentPage || 1;
    };
    const setTopicCurrentPage = (topic, page) => {
      if (!topicPaginationState.value[topic]) {
        topicPaginationState.value[topic] = { currentPage: 1 };
      }
      topicPaginationState.value[topic].currentPage = page;
      saveTopicPaginationState(topicPaginationState.value);
    };
    const getPaginatedTopicVocabularies = (topicGroup) => {
      const currentPage = getTopicCurrentPage(topicGroup.topic);
      const totalItems = topicGroup.vocabularies.length;
      const startIndex = (currentPage - 1) * itemsPerCategoryPage;
      const endIndex = startIndex + itemsPerCategoryPage;
      return {
        vocabularies: topicGroup.vocabularies.slice(startIndex, endIndex),
        currentPage,
        totalPages: Math.ceil(totalItems / itemsPerCategoryPage),
        totalItems,
        startIndex: startIndex + 1,
        endIndex: Math.min(endIndex, totalItems),
        hasNext: currentPage < Math.ceil(totalItems / itemsPerCategoryPage),
        hasPrevious: currentPage > 1
      };
    };
    const goToTopicPage = (topic, page) => {
      const totalItems = props.group.topics?.find((t2) => t2.topic === topic)?.vocabularies.length || 0;
      const totalPages = Math.ceil(totalItems / itemsPerCategoryPage);
      if (page >= 1 && page <= totalPages) {
        setTopicCurrentPage(topic, page);
      }
    };
    const nextTopicPage = (topic) => {
      const currentPage = getTopicCurrentPage(topic);
      const totalItems = props.group.topics?.find((t2) => t2.topic === topic)?.vocabularies.length || 0;
      const totalPages = Math.ceil(totalItems / itemsPerCategoryPage);
      if (currentPage < totalPages) {
        setTopicCurrentPage(topic, currentPage + 1);
      }
    };
    const previousTopicPage = (topic) => {
      const currentPage = getTopicCurrentPage(topic);
      if (currentPage > 1) {
        setTopicCurrentPage(topic, currentPage - 1);
      }
    };
    const getVisibleTopicPages = (currentPage, totalPages) => {
      if (totalPages <= 7) {
        return Array.from({ length: totalPages }, (_, i) => i + 1);
      }
      if (currentPage <= 4) {
        return [1, 2, 3, 4, 5, -1, totalPages];
      }
      if (currentPage >= totalPages - 3) {
        return [1, -1, totalPages - 4, totalPages - 3, totalPages - 2, totalPages - 1, totalPages];
      }
      return [1, -1, currentPage - 1, currentPage, currentPage + 1, -1, totalPages];
    };
    const hoverTimeouts = ref({});
    const handleTopicHover = (topic, isHovering) => {
      if (props.hoverToExpandEnabled) {
        if (hoverTimeouts.value[topic]) {
          clearTimeout(hoverTimeouts.value[topic]);
          delete hoverTimeouts.value[topic];
        }
        if (isHovering) {
          expandedTopics.value[topic] = true;
        } else {
          hoverTimeouts.value[topic] = setTimeout(() => {
            if (!isModalOpen()) {
              expandedTopics.value[topic] = false;
            }
            delete hoverTimeouts.value[topic];
          }, 200);
        }
      }
    };
    const isMouseOutsideVocabulary = ref(false);
    const handleVocabularyListMouseLeave = () => {
      if (props.hoverToExpandEnabled) {
        isMouseOutsideVocabulary.value = true;
        if (!isModalOpen()) {
          closeAllTopics();
        }
      }
    };
    const handleVocabularyListMouseEnter = () => {
      if (props.hoverToExpandEnabled) {
        isMouseOutsideVocabulary.value = false;
      }
    };
    const closeAllTopics = () => {
      Object.keys(expandedTopics.value).forEach((topic) => {
        expandedTopics.value[topic] = false;
      });
      Object.keys(hoverTimeouts.value).forEach((topic) => {
        if (hoverTimeouts.value[topic]) {
          clearTimeout(hoverTimeouts.value[topic]);
          delete hoverTimeouts.value[topic];
        }
      });
    };
    const isModalOpen = () => {
      const modalSelectors = [
        '[role="dialog"]',
        ".modal",
        ".dialog",
        '[data-headlessui-state="open"]',
        // HeadlessUI modals
        ".fixed.inset-0"
        // Common modal backdrop pattern
      ];
      return modalSelectors.some((selector) => {
        const elements = document.querySelectorAll(selector);
        return Array.from(elements).some((el) => {
          const style = window.getComputedStyle(el);
          return style.display !== "none" && style.visibility !== "hidden";
        });
      });
    };
    const showTopicInput = ref(false);
    const topicInputValue = ref("");
    const topicInput = ref();
    const groupTopic = ref("");
    const showTopicTooltip = ref(false);
    const topicSpanMobile = ref();
    const topicSpanDesktop = ref();
    const getStoredTopics = () => {
      try {
        const stored = localStorage.getItem(TOPICS_STORAGE_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch (error) {
        console.warn("Failed to load group topics from localStorage:", error);
        return {};
      }
    };
    const setStoredTopics = (topics) => {
      try {
        localStorage.setItem(TOPICS_STORAGE_KEY, JSON.stringify(topics));
      } catch (error) {
        console.warn("Failed to save group topics to localStorage:", error);
      }
    };
    const editTopic = () => {
      topicInputValue.value = groupTopic.value;
      showTopicInput.value = true;
      nextTick(() => {
        topicInput.value?.focus();
      });
    };
    const saveTopic = () => {
      const trimmedTopic = topicInputValue.value.trim();
      groupTopic.value = trimmedTopic;
      const storedTopics = getStoredTopics();
      if (trimmedTopic) {
        storedTopics[props.group.date] = trimmedTopic;
      } else {
        delete storedTopics[props.group.date];
      }
      setStoredTopics(storedTopics);
      showTopicInput.value = false;
      topicInputValue.value = "";
    };
    const cancelTopicInput = () => {
      showTopicInput.value = false;
      topicInputValue.value = "";
    };
    const handleMoveVocabulary = (data) => {
      emit("move-vocabulary", data);
    };
    const formatDateForDisplay = (dateStr) => {
      const date = new Date(dateStr);
      return date.toLocaleDateString(locale.value, {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    };
    const calculateHeight = async () => {
      if (!accordionContent.value) return;
      const innerElement = accordionContent.value.querySelector(".accordion-inner");
      if (innerElement) {
        const clone = innerElement.cloneNode(true);
        clone.style.visibility = "hidden";
        clone.style.position = "absolute";
        clone.style.height = "auto";
        clone.style.maxHeight = "none";
        clone.style.overflow = "visible";
        document.body.appendChild(clone);
        await nextTick();
        accordionMaxHeight.value = clone.scrollHeight + 24;
        document.body.removeChild(clone);
      }
    };
    const modalWatchInterval = ref(null);
    const startModalWatcher = () => {
      if (modalWatchInterval.value) return;
      modalWatchInterval.value = setInterval(() => {
        if (props.hoverToExpandEnabled && isMouseOutsideVocabulary.value && !isModalOpen()) {
          closeAllTopics();
        }
      }, 300);
    };
    const stopModalWatcher = () => {
      if (modalWatchInterval.value) {
        clearInterval(modalWatchInterval.value);
        modalWatchInterval.value = null;
      }
    };
    const toggleAccordion = () => {
      isExpanded.value = !isExpanded.value;
      emit("accordion-toggle", props.group.date, isExpanded.value);
    };
    const openAddVocabularyDialog = () => {
      emit("open-add-vocabulary-dialog", props.group.date);
    };
    const openGrammarManager = (date) => {
      emit("open-grammar-manager", date);
    };
    const handleBatchMoveCategory = (topicGroup) => {
      emit("batch-move-category", {
        topic: topicGroup.topic,
        words: topicGroup.vocabularies,
        sourceDate: props.group.date
      });
    };
    const availableDatesByTopic = ref({});
    const infoHoverTopic = ref(null);
    const handleInfoMouseEnter = (topic) => {
      infoHoverTopic.value = topic;
      emit("request-available-dates", { topic, currentDate: props.group.date });
    };
    const handleInfoMouseLeave = () => {
      setTimeout(() => {
        if (!isHoveringTooltip.value) {
          infoHoverTopic.value = null;
        }
      }, 120);
    };
    const handleAvailableDatesResponse = (e) => {
      const detail = e.detail;
      if (!detail) return;
      if (detail.currentDate !== props.group.date) return;
      availableDatesByTopic.value[detail.topic] = detail.availableDates || [];
    };
    const handleNavigateClick = (targetDate, topic) => {
      console.log("🎯 Tooltip navigation:", { targetDate, topic, currentDate: props.group.date });
      infoHoverTopic.value = null;
      if (targetDate === props.group.date) {
        console.log("📍 Same date navigation - expanding locally");
        isExpanded.value = true;
        expandedTopics.value[topic] = true;
        nextTick(() => {
          const el = document.getElementById(`date-group-${props.group.date}-topic-${topic}`);
          if (el && typeof el.scrollIntoView === "function") {
            el.scrollIntoView({ behavior: "smooth", block: "center" });
          }
        });
      } else {
        console.log("🚀 Cross-date navigation - emitting to parent");
        emit("navigate-to-date-topic", { date: targetDate, topic });
      }
    };
    const handleOpenDateTopic = (e) => {
      const detail = e.detail;
      console.log("📨 Received open-date-topic event:", { detail, currentDate: props.group.date });
      if (!detail) {
        console.log("❌ No detail in event");
        return;
      }
      if (detail.date !== props.group.date) {
        console.log("⏭️ Event not for this date group");
        return;
      }
      console.log("✅ Opening accordion for cross-date navigation:", detail.topic);
      isExpanded.value = true;
      expandedTopics.value[detail.topic] = true;
      emit("accordion-toggle", props.group.date, true);
      if (props.accordionState) {
        props.accordionState[props.group.date] = true;
      }
      nextTick(() => {
        setTimeout(() => {
          const el = document.getElementById(`date-group-${props.group.date}-topic-${detail.topic}`);
          if (el && typeof el.scrollIntoView === "function") {
            console.log("🎯 Scrolling to topic element");
            el.scrollIntoView({ behavior: "smooth", block: "center" });
          } else {
            console.log("❌ Topic element not found:", `date-group-${props.group.date}-topic-${detail.topic}`);
          }
          try {
            sessionStorage.removeItem(PENDING_OPEN_KEY);
          } catch {
          }
        }, 100);
      });
    };
    const isHoveringTooltip = ref(false);
    const handleTooltipMouseEnter = () => {
      isHoveringTooltip.value = true;
    };
    const handleTooltipMouseLeave = () => {
      isHoveringTooltip.value = false;
      infoHoverTopic.value = null;
    };
    onMounted(async () => {
      loadActionButtonsState();
      topicPaginationState.value = loadTopicPaginationState();
      if (props.accordionState && typeof props.accordionState[props.group.date] === "boolean") {
        isExpanded.value = props.accordionState[props.group.date];
      }
      const storedTopics = getStoredTopics();
      if (storedTopics[props.group.date]) {
        groupTopic.value = storedTopics[props.group.date];
      }
      window.addEventListener("vocabulary-list-mouse-leave", handleVocabularyListMouseLeave);
      window.addEventListener("vocabulary-list-mouse-enter", handleVocabularyListMouseEnter);
      startModalWatcher();
      await nextTick();
      await calculateHeight();
      try {
        const raw = sessionStorage.getItem(PENDING_OPEN_KEY);
        if (raw) {
          const pending = JSON.parse(raw);
          if (pending && pending.date === props.group.date) {
            console.log("🧭 Applying pending open on mount:", pending);
            isExpanded.value = true;
            expandedTopics.value[pending.topic] = true;
            emit("accordion-toggle", props.group.date, true);
            if (props.accordionState) {
              props.accordionState[props.group.date] = true;
            }
            nextTick(() => {
              setTimeout(() => {
                const el = document.getElementById(`date-group-${props.group.date}-topic-${pending.topic}`);
                if (el && typeof el.scrollIntoView === "function") {
                  el.scrollIntoView({ behavior: "smooth", block: "center" });
                }
              }, 100);
            });
            sessionStorage.removeItem(PENDING_OPEN_KEY);
          }
        }
      } catch (err) {
        console.warn("Failed to apply pending open-date-topic on mount:", err);
      }
      window.addEventListener("available-dates-response", handleAvailableDatesResponse);
      window.addEventListener("open-date-topic", handleOpenDateTopic);
    });
    onUnmounted(() => {
      window.removeEventListener("vocabulary-list-mouse-leave", handleVocabularyListMouseLeave);
      window.removeEventListener("vocabulary-list-mouse-enter", handleVocabularyListMouseEnter);
      stopModalWatcher();
      Object.keys(hoverTimeouts.value).forEach((topic) => {
        if (hoverTimeouts.value[topic]) {
          clearTimeout(hoverTimeouts.value[topic]);
        }
      });
      window.removeEventListener("available-dates-response", handleAvailableDatesResponse);
      window.removeEventListener("open-date-topic", handleOpenDateTopic);
    });
    const emit = __emit;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1$b, [
          createBaseVNode("div", _hoisted_2$9, [
            createBaseVNode("div", _hoisted_3$8, [
              createBaseVNode("div", {
                onClick: toggleAccordion,
                class: "flex items-center justify-between mb-2 cursor-pointer py-1 -mx-1 px-1 rounded hover:bg-gray-50 dark:hover:bg-gray-custom transition-colors"
              }, [
                createBaseVNode("div", _hoisted_4$8, [
                  createBaseVNode("div", _hoisted_5$7, [
                    (openBlock(), createElementBlock("svg", {
                      class: normalizeClass(["w-2.5 h-2.5 text-gray-500 dark:text-gray-400 transition-transform duration-200", { "transform rotate-90": isExpanded.value }]),
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, _cache[48] || (_cache[48] = [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                        "clip-rule": "evenodd"
                      }, null, -1)
                    ]), 2))
                  ]),
                  createBaseVNode("h4", _hoisted_6$6, [
                    _cache[49] || (_cache[49] = createBaseVNode("svg", {
                      class: "w-2.5 h-2.5",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)),
                    createBaseVNode("span", null, toDisplayString$1(_ctx.group.displayDate), 1),
                    createBaseVNode("span", {
                      class: normalizeClass(["text-xs xs:text-xs sm:text-sm md:text-sm lg:text-base xl:text-sm 2xl:text-base font-semibold transition-colors duration-300", vocabularyCountColor.value])
                    }, " (" + toDisplayString$1(totalVocabularyCount.value) + ") ", 3),
                    createBaseVNode("span", _hoisted_7$6, [
                      createVNode(unref(CircularProgress), {
                        percentage: headerProgress.value.percentage,
                        size: 26,
                        "stroke-width": 1.5,
                        "show-text": true,
                        title: headerProgressTooltip.value
                      }, null, 8, ["percentage", "title"])
                    ])
                  ])
                ]),
                createBaseVNode("div", {
                  class: "flex items-center space-x-1",
                  onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                  }, ["stop"]))
                }, [
                  createBaseVNode("label", _hoisted_8$6, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showActionButtons.value = $event),
                      class: "sr-only peer"
                    }, null, 512), [
                      [vModelCheckbox, showActionButtons.value]
                    ]),
                    _cache[50] || (_cache[50] = createBaseVNode("div", { class: "w-9 h-5 sm:w-11 sm:h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-1 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 sm:after:h-5 sm:after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600" }, null, -1))
                  ])
                ]),
                isExpanded.value && _ctx.group.totalPages && _ctx.group.totalPages > 1 ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: "flex items-center space-x-1",
                  onClick: _cache[4] || (_cache[4] = withModifiers(() => {
                  }, ["stop"]))
                }, [
                  createBaseVNode("button", {
                    onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("date-group-previous", _ctx.group.date)),
                    disabled: (_ctx.group.currentPage || 1) === 1,
                    class: "px-1.5 py-0.5 xs:px-2 xs:py-1 sm:px-3 sm:py-1 md:px-4 md:py-1.5 xl:px-4 xl:py-1.5 2xl:px-5 2xl:py-2 text-xs xs:text-xs sm:text-sm md:text-sm lg:text-base xl:text-base 2xl:text-lg border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                  }, " ‹ ", 8, _hoisted_9$6),
                  createBaseVNode("span", _hoisted_10$6, toDisplayString$1(_ctx.group.currentPage || 1) + "/" + toDisplayString$1(_ctx.group.totalPages), 1),
                  createBaseVNode("button", {
                    onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("date-group-next", _ctx.group.date)),
                    disabled: (_ctx.group.currentPage || 1) === _ctx.group.totalPages,
                    class: "px-1.5 py-0.5 xs:px-2 xs:py-1 sm:px-3 sm:py-1 md:px-4 md:py-1.5 xl:px-4 xl:py-1.5 2xl:px-5 2xl:py-2 text-xs xs:text-xs sm:text-sm md:text-sm lg:text-base xl:text-base 2xl:text-lg border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                  }, " › ", 8, _hoisted_11$6)
                ])) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", {
                class: "w-full",
                onClick: _cache[10] || (_cache[10] = withModifiers(() => {
                }, ["stop"]))
              }, [
                showTopicInput.value ? (openBlock(), createElementBlock("div", _hoisted_12$6, [
                  createBaseVNode("div", _hoisted_13$6, [
                    withDirectives(createBaseVNode("input", {
                      ref_key: "topicInput",
                      ref: topicInput,
                      "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => topicInputValue.value = $event),
                      onKeyup: [
                        withKeys(saveTopic, ["enter"]),
                        withKeys(cancelTopicInput, ["escape"])
                      ],
                      type: "text",
                      placeholder: unref(t)("vocabulary.accordion.topicPlaceholder"),
                      class: "flex-1 px-3 py-2 text-xs border border-orange-300 dark:border-orange-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
                    }, null, 40, _hoisted_14$6), [
                      [vModelText, topicInputValue.value]
                    ]),
                    createBaseVNode("button", {
                      onClick: saveTopic,
                      class: "px-2 py-2 text-xs bg-orange-600 hover:bg-orange-700 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500 transition-colors",
                      "aria-label": unref(t)("vocabulary.accordion.saveTopic")
                    }, _cache[51] || (_cache[51] = [
                      createBaseVNode("svg", {
                        class: "w-3 h-3",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)
                    ]), 8, _hoisted_15$5),
                    createBaseVNode("button", {
                      onClick: cancelTopicInput,
                      class: "px-2 py-2 text-xs bg-gray-500 hover:bg-gray-600 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors dark:bg-blue-700 dark:hover:bg-blue-600 dark:focus:ring-blue-500",
                      "aria-label": unref(t)("vocabulary.accordion.cancelTopic")
                    }, _cache[52] || (_cache[52] = [
                      createBaseVNode("svg", {
                        class: "w-3 h-3",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)
                    ]), 8, _hoisted_16$5)
                  ])
                ])) : (openBlock(), createElementBlock("div", _hoisted_17$5, [
                  groupTopic.value ? (openBlock(), createElementBlock("div", _hoisted_18$5, [
                    createBaseVNode("div", _hoisted_19$5, [
                      _cache[55] || (_cache[55] = createBaseVNode("svg", {
                        class: "w-3 h-3 text-orange-600 dark:text-orange-400 flex-shrink-0",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)),
                      createBaseVNode("div", _hoisted_20$5, [
                        createBaseVNode("span", {
                          ref_key: "topicSpanMobile",
                          ref: topicSpanMobile,
                          class: "text-xs font-medium text-orange-700 dark:text-orange-300 truncate block cursor-default",
                          onMouseenter: _cache[6] || (_cache[6] = ($event) => showTopicTooltip.value = true),
                          onMouseleave: _cache[7] || (_cache[7] = ($event) => showTopicTooltip.value = false)
                        }, toDisplayString$1(groupTopic.value), 545),
                        showTopicTooltip.value && isTopicTruncated.value ? (openBlock(), createElementBlock("div", _hoisted_21$5, [
                          createTextVNode(toDisplayString$1(groupTopic.value) + " ", 1),
                          _cache[53] || (_cache[53] = createBaseVNode("div", { class: "absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-gray-900 dark:border-t-gray-700" }, null, -1))
                        ])) : createCommentVNode("", true)
                      ]),
                      createBaseVNode("button", {
                        onClick: withModifiers(editTopic, ["stop"]),
                        class: "text-orange-600 dark:text-orange-400 hover:text-orange-700 dark:hover:text-orange-300 focus:outline-none flex-shrink-0 p-0.5 rounded hover:bg-orange-100 dark:hover:bg-orange-800/50 transition-colors",
                        "aria-label": unref(t)("vocabulary.accordion.editTopic")
                      }, _cache[54] || (_cache[54] = [
                        createBaseVNode("svg", {
                          class: "w-3 h-3",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
                        ], -1)
                      ]), 8, _hoisted_22$5)
                    ])
                  ])) : createCommentVNode("", true),
                  createBaseVNode("div", _hoisted_23$5, [
                    !groupTopic.value ? (openBlock(), createElementBlock("button", {
                      key: 0,
                      onClick: _cache[8] || (_cache[8] = withModifiers(($event) => showTopicInput.value = true, ["stop"])),
                      class: "flex flex-col items-center justify-center p-2 sm:p-3 text-xs sm:text-sm font-medium text-orange-600 dark:text-orange-400 hover:text-orange-700 dark:hover:text-orange-300 hover:bg-orange-50 dark:hover:bg-orange-900/50 rounded-md border border-dashed border-orange-300 dark:border-orange-600 hover:border-orange-400 dark:hover:border-orange-500 transition-all duration-200 focus:outline-none focus:ring-1 focus:ring-orange-500 min-h-[56px] sm:min-h-[64px] hover:scale-[1.02]",
                      "aria-label": unref(t)("vocabulary.accordion.addTopic", "Add Topic")
                    }, [
                      _cache[56] || (_cache[56] = createBaseVNode("svg", {
                        class: "w-3.5 h-3.5 sm:w-4 sm:h-4 mb-0.5",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)),
                      createBaseVNode("span", _hoisted_25$5, toDisplayString$1(unref(t)("vocabulary.accordion.addTopic", "Add Topic")), 1)
                    ], 8, _hoisted_24$5)) : createCommentVNode("", true),
                    showActionButtons.value ? (openBlock(), createElementBlock("div", _hoisted_26$4, [
                      createVNode(unref(VocabularyNoteButton$1), {
                        date: _ctx.group.date,
                        "is-today": isTodayGroup.value,
                        class: normalizeClass("w-full flex flex-col items-center justify-center p-2 sm:p-3 text-xs sm:text-sm font-medium min-h-[56px] sm:min-h-[64px] hover:scale-[1.02] transition-all duration-200 rounded-md"),
                        onOpenNoteDialog: _cache[9] || (_cache[9] = () => emit("open-note-dialog", { date: _ctx.group.date, words: _ctx.group.vocabularies }))
                      }, null, 8, ["date", "is-today"])
                    ])) : createCommentVNode("", true),
                    showActionButtons.value ? (openBlock(), createElementBlock("button", {
                      key: 2,
                      onClick: withModifiers(openAddVocabularyDialog, ["stop"]),
                      class: "flex flex-col items-center justify-center p-2 sm:p-3 text-xs sm:text-sm font-medium text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 hover:bg-blue-50 dark:hover:bg-blue-900/50 rounded-md border border-dashed border-blue-300 dark:border-blue-600 hover:border-blue-400 dark:hover:border-blue-500 transition-all duration-200 focus:outline-none focus:ring-1 focus:ring-blue-500 min-h-[56px] sm:min-h-[64px] hover:scale-[1.02]",
                      "aria-label": unref(t)("vocabulary.addWord", "Add Word")
                    }, [
                      _cache[57] || (_cache[57] = createBaseVNode("svg", {
                        class: "w-3.5 h-3.5 sm:w-4 sm:h-4 mb-0.5",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)),
                      createBaseVNode("span", _hoisted_28$4, toDisplayString$1(unref(t)("vocabulary.addWord", "Add Word")), 1)
                    ], 8, _hoisted_27$4)) : createCommentVNode("", true),
                    showActionButtons.value ? (openBlock(), createElementBlock("div", _hoisted_29$4, [
                      createVNode(unref(GrammarManagerButton$1), {
                        date: _ctx.group.date,
                        class: normalizeClass("w-full flex flex-col items-center justify-center p-2 sm:p-3 text-xs sm:text-sm font-medium min-h-[56px] sm:min-h-[64px] hover:scale-[1.02] transition-all duration-200 rounded-md"),
                        onOpenGrammarManager: openGrammarManager
                      }, null, 8, ["date"])
                    ])) : createCommentVNode("", true)
                  ])
                ]))
              ])
            ]),
            createBaseVNode("div", _hoisted_30$4, [
              createBaseVNode("div", {
                onClick: toggleAccordion,
                class: "flex items-center justify-between cursor-pointer py-1 -mx-1 px-1 rounded hover:bg-gray-50 dark:hover:bg-gray-custom transition-colors"
              }, [
                createBaseVNode("div", _hoisted_31$4, [
                  createBaseVNode("div", _hoisted_32$3, [
                    (openBlock(), createElementBlock("svg", {
                      class: normalizeClass(["w-3 xs:w-3.5 sm:w-4 h-3 xs:h-3.5 sm:h-4 text-gray-500 dark:text-gray-400 transition-transform duration-200", { "transform rotate-90": isExpanded.value }]),
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, _cache[58] || (_cache[58] = [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                        "clip-rule": "evenodd"
                      }, null, -1)
                    ]), 2))
                  ]),
                  createBaseVNode("h4", _hoisted_33$3, [
                    _cache[59] || (_cache[59] = createBaseVNode("svg", {
                      class: "w-3 md:w-4 lg:w-4 xl:w-5 xl:h-5 2xl:w-6 2xl:h-6 h-3 md:h-4 lg:h-4",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)),
                    createBaseVNode("span", null, toDisplayString$1(_ctx.group.displayDate), 1),
                    createBaseVNode("span", {
                      class: normalizeClass(["text-xs xs:text-xs sm:text-sm md:text-sm lg:text-base xl:text-sm 2xl:text-base font-semibold transition-colors duration-300", vocabularyCountColor.value])
                    }, " (" + toDisplayString$1(totalVocabularyCount.value) + " " + toDisplayString$1(unref(t)("vocabulary.words", "words")) + ") ", 3),
                    createBaseVNode("span", _hoisted_34$3, [
                      createVNode(unref(CircularProgress), {
                        percentage: headerProgress.value.percentage,
                        size: 28,
                        "stroke-width": 1.5,
                        "show-text": true,
                        title: headerProgressTooltip.value
                      }, null, 8, ["percentage", "title"])
                    ])
                  ])
                ]),
                createBaseVNode("div", {
                  class: "lg:hidden flex items-center space-x-2",
                  onClick: _cache[12] || (_cache[12] = withModifiers(() => {
                  }, ["stop"]))
                }, [
                  createBaseVNode("label", _hoisted_35$3, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => showActionButtons.value = $event),
                      class: "sr-only peer"
                    }, null, 512), [
                      [vModelCheckbox, showActionButtons.value]
                    ]),
                    _cache[60] || (_cache[60] = createBaseVNode("div", { class: "w-7 h-4 bg-gray-200 peer-focus:outline-none peer-focus:ring-1 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-3 after:w-3 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600" }, null, -1))
                  ])
                ]),
                createBaseVNode("div", _hoisted_36$3, [
                  isExpanded.value && _ctx.group.totalPages && _ctx.group.totalPages > 1 ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: "flex items-center space-x-2",
                    onClick: _cache[15] || (_cache[15] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("button", {
                      onClick: _cache[13] || (_cache[13] = ($event) => _ctx.$emit("date-group-previous", _ctx.group.date)),
                      disabled: (_ctx.group.currentPage || 1) === 1,
                      class: "px-2 md:px-2 py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 xl:px-3 xl:py-1.5 2xl:px-4 2xl:py-2 text-xs xs:text-xs sm:text-sm md:text-sm lg:text-base xl:text-sm 2xl:text-base border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, toDisplayString$1(unref(t)("common.previous")), 9, _hoisted_37$2),
                    createBaseVNode("span", _hoisted_38$2, toDisplayString$1(_ctx.group.currentPage || 1) + " / " + toDisplayString$1(_ctx.group.totalPages), 1),
                    createBaseVNode("button", {
                      onClick: _cache[14] || (_cache[14] = ($event) => _ctx.$emit("date-group-next", _ctx.group.date)),
                      disabled: (_ctx.group.currentPage || 1) === _ctx.group.totalPages,
                      class: "px-2 md:px-2 py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 xl:px-3 xl:py-1.5 2xl:px-4 2xl:py-2 text-xs xs:text-xs sm:text-sm md:text-sm lg:text-base xl:text-sm 2xl:text-base border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, toDisplayString$1(unref(t)("common.next")), 9, _hoisted_39$2)
                  ])) : createCommentVNode("", true),
                  createBaseVNode("div", {
                    class: "flex items-center space-x-2",
                    onClick: _cache[17] || (_cache[17] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("label", _hoisted_40$2, [
                      withDirectives(createBaseVNode("input", {
                        type: "checkbox",
                        "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => showActionButtons.value = $event),
                        class: "sr-only peer"
                      }, null, 512), [
                        [vModelCheckbox, showActionButtons.value]
                      ]),
                      _cache[61] || (_cache[61] = createBaseVNode("div", { class: "w-9 h-5 sm:w-11 sm:h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 sm:after:h-5 sm:after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600" }, null, -1))
                    ]),
                    createBaseVNode("span", _hoisted_41$1, toDisplayString$1(unref(t)("common.actions", "Actions")), 1)
                  ])
                ])
              ]),
              isExpanded.value && _ctx.group.totalPages && _ctx.group.totalPages > 1 ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "lg:hidden flex items-center justify-center space-x-1 mt-2",
                onClick: _cache[20] || (_cache[20] = withModifiers(() => {
                }, ["stop"]))
              }, [
                createBaseVNode("button", {
                  onClick: _cache[18] || (_cache[18] = ($event) => _ctx.$emit("date-group-previous", _ctx.group.date)),
                  disabled: (_ctx.group.currentPage || 1) === 1,
                  class: "px-1.5 py-0.5 xs:px-2 xs:py-1 sm:px-3 sm:py-1 md:px-4 md:py-1.5 text-xs xs:text-xs sm:text-sm md:text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                }, " ‹ ", 8, _hoisted_42$1),
                createBaseVNode("span", _hoisted_43$1, toDisplayString$1(_ctx.group.currentPage || 1) + "/" + toDisplayString$1(_ctx.group.totalPages), 1),
                createBaseVNode("button", {
                  onClick: _cache[19] || (_cache[19] = ($event) => _ctx.$emit("date-group-next", _ctx.group.date)),
                  disabled: (_ctx.group.currentPage || 1) === _ctx.group.totalPages,
                  class: "px-1.5 py-0.5 xs:px-2 xs:py-1 sm:px-3 sm:py-1 md:px-4 md:py-1.5 text-xs xs:text-xs sm:text-sm md:text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                }, " › ", 8, _hoisted_44$1)
              ])) : createCommentVNode("", true),
              createBaseVNode("div", {
                class: "lg:hidden flex items-center justify-center space-x-2 mt-2",
                onClick: _cache[26] || (_cache[26] = withModifiers(() => {
                }, ["stop"]))
              }, [
                !showTopicInput.value ? (openBlock(), createElementBlock("div", _hoisted_45$1, [
                  groupTopic.value ? (openBlock(), createElementBlock("div", _hoisted_46$1, [
                    _cache[64] || (_cache[64] = createBaseVNode("svg", {
                      class: "w-2.5 xs:w-3 sm:w-3 md:w-4 h-2.5 xs:h-3 sm:h-3 md:h-4 text-orange-600 dark:text-orange-400",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)),
                    createBaseVNode("div", _hoisted_47$1, [
                      createBaseVNode("span", {
                        ref: "topicSpanTablet",
                        class: "font-medium text-orange-700 dark:text-orange-300 truncate max-w-[80px] sm:max-w-none block cursor-default text-xs xs:text-xs sm:text-sm md:text-sm",
                        onMouseenter: _cache[21] || (_cache[21] = ($event) => showTopicTooltip.value = true),
                        onMouseleave: _cache[22] || (_cache[22] = ($event) => showTopicTooltip.value = false)
                      }, toDisplayString$1(groupTopic.value), 545),
                      showTopicTooltip.value && isTopicTruncated.value ? (openBlock(), createElementBlock("div", _hoisted_48$1, [
                        createTextVNode(toDisplayString$1(groupTopic.value) + " ", 1),
                        _cache[62] || (_cache[62] = createBaseVNode("div", { class: "absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-gray-900 dark:border-t-gray-700" }, null, -1))
                      ])) : createCommentVNode("", true)
                    ]),
                    createBaseVNode("button", {
                      onClick: withModifiers(editTopic, ["stop"]),
                      class: "text-orange-600 dark:text-orange-400 hover:text-orange-800 dark:hover:text-orange-200 focus:outline-none flex-shrink-0",
                      "aria-label": unref(t)("vocabulary.accordion.editTopic")
                    }, _cache[63] || (_cache[63] = [
                      createBaseVNode("svg", {
                        class: "w-2.5 xs:w-3 sm:w-3 md:w-4 h-2.5 xs:h-3 sm:h-3 md:h-4",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
                      ], -1)
                    ]), 8, _hoisted_49$1)
                  ])) : (openBlock(), createElementBlock("button", {
                    key: 1,
                    onClick: _cache[23] || (_cache[23] = withModifiers(($event) => showTopicInput.value = true, ["stop"])),
                    class: "flex items-center space-x-0.5 xs:space-x-1 sm:space-x-1 md:space-x-1.5 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 text-xs xs:text-xs sm:text-sm md:text-sm bg-orange-50 hover:bg-orange-100 dark:bg-orange-900/20 dark:hover:bg-orange-800/30 text-orange-600 dark:text-orange-400 rounded-full border border-orange-200 dark:border-orange-800 cursor-pointer transition-colors duration-150",
                    "aria-label": unref(t)("vocabulary.accordion.addTopic", "Add Topic")
                  }, [
                    _cache[65] || (_cache[65] = createBaseVNode("svg", {
                      class: "w-3 md:w-4 h-3 md:h-4",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)),
                    createBaseVNode("span", _hoisted_51, toDisplayString$1(unref(t)("vocabulary.accordion.addTopic", "Add Topic")), 1)
                  ], 8, _hoisted_50$1)),
                  showActionButtons.value ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    createVNode(unref(VocabularyNoteButton$1), {
                      date: _ctx.group.date,
                      "is-today": isTodayGroup.value,
                      onOpenNoteDialog: _cache[24] || (_cache[24] = () => emit("open-note-dialog", { date: _ctx.group.date, words: _ctx.group.vocabularies }))
                    }, null, 8, ["date", "is-today"]),
                    createBaseVNode("button", {
                      onClick: openAddVocabularyDialog,
                      class: "flex items-center space-x-1 md:space-x-1.5 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 text-xs md:text-sm font-medium text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 hover:bg-blue-50 dark:hover:bg-blue-900/50 rounded-full border border-dashed border-blue-300 dark:border-blue-600 hover:border-blue-400 dark:hover:border-blue-500 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500",
                      "aria-label": unref(t)("vocabulary.addWord", "Add Word")
                    }, [
                      _cache[66] || (_cache[66] = createBaseVNode("svg", {
                        class: "w-3 md:w-4 h-3 md:h-4",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)),
                      createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.addWord", "Add Word")), 1)
                    ], 8, _hoisted_52),
                    createVNode(unref(GrammarManagerButton$1), {
                      date: _ctx.group.date,
                      onOpenGrammarManager: openGrammarManager
                    }, null, 8, ["date"])
                  ], 64)) : createCommentVNode("", true)
                ])) : (openBlock(), createElementBlock("div", _hoisted_53, [
                  withDirectives(createBaseVNode("input", {
                    ref: "topicInputTablet",
                    "onUpdate:modelValue": _cache[25] || (_cache[25] = ($event) => topicInputValue.value = $event),
                    onKeyup: [
                      withKeys(saveTopic, ["enter"]),
                      withKeys(cancelTopicInput, ["escape"])
                    ],
                    type: "text",
                    placeholder: unref(t)("vocabulary.accordion.topicPlaceholder"),
                    class: "flex-1 px-2 xs:px-2 sm:px-2 md:px-2 py-0.5 xs:py-1 sm:py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 text-xs border border-orange-300 dark:border-orange-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
                  }, null, 40, _hoisted_54), [
                    [vModelText, topicInputValue.value]
                  ]),
                  createBaseVNode("button", {
                    onClick: saveTopic,
                    class: "px-1.5 xs:px-2 sm:px-2 md:px-2 py-0.5 xs:py-1 sm:py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 text-xs bg-orange-600 hover:bg-orange-700 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500 transition-colors",
                    "aria-label": unref(t)("vocabulary.accordion.saveTopic")
                  }, _cache[67] || (_cache[67] = [
                    createBaseVNode("svg", {
                      class: "w-3 h-3",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)
                  ]), 8, _hoisted_55),
                  createBaseVNode("button", {
                    onClick: cancelTopicInput,
                    class: "px-1.5 xs:px-2 sm:px-2 md:px-2 py-0.5 xs:py-1 sm:py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 text-xs bg-gray-500 hover:bg-gray-600 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors",
                    "aria-label": unref(t)("vocabulary.accordion.cancelTopic")
                  }, _cache[68] || (_cache[68] = [
                    createBaseVNode("svg", {
                      class: "w-3 h-3",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)
                  ]), 8, _hoisted_56)
                ]))
              ])
            ]),
            createBaseVNode("div", _hoisted_57, [
              createBaseVNode("div", {
                onClick: toggleAccordion,
                class: "flex items-center justify-between flex-wrap gap-1 cursor-pointer py-1 -mx-1 px-1 rounded hover:bg-gray-50 dark:hover:bg-gray-custom transition-colors"
              }, [
                createBaseVNode("div", _hoisted_58, [
                  !showTopicInput.value ? (openBlock(), createElementBlock("div", _hoisted_59, [
                    groupTopic.value ? (openBlock(), createElementBlock("div", _hoisted_60, [
                      _cache[71] || (_cache[71] = createBaseVNode("svg", {
                        class: "w-3 md:w-4 lg:w-4 xl:w-5 xl:h-5 2xl:w-6 2xl:h-6 h-3 md:h-4 lg:h-4 text-orange-600 dark:text-orange-400",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)),
                      createBaseVNode("div", _hoisted_61, [
                        createBaseVNode("span", {
                          ref_key: "topicSpanDesktop",
                          ref: topicSpanDesktop,
                          class: "text-xs md:text-sm lg:text-base xl:text-sm 2xl:text-base font-medium text-orange-700 dark:text-orange-300 truncate max-w-[80px] sm:max-w-none block cursor-default",
                          onMouseenter: _cache[27] || (_cache[27] = ($event) => showTopicTooltip.value = true),
                          onMouseleave: _cache[28] || (_cache[28] = ($event) => showTopicTooltip.value = false)
                        }, toDisplayString$1(groupTopic.value), 545),
                        showTopicTooltip.value && isTopicTruncated.value ? (openBlock(), createElementBlock("div", _hoisted_62, [
                          createTextVNode(toDisplayString$1(groupTopic.value) + " ", 1),
                          _cache[69] || (_cache[69] = createBaseVNode("div", { class: "absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-gray-900 dark:border-t-gray-700" }, null, -1))
                        ])) : createCommentVNode("", true)
                      ]),
                      createBaseVNode("button", {
                        onClick: withModifiers(editTopic, ["stop"]),
                        class: "text-orange-600 dark:text-orange-400 hover:text-orange-800 dark:hover:text-orange-200 focus:outline-none flex-shrink-0",
                        "aria-label": unref(t)("vocabulary.accordion.editTopic")
                      }, _cache[70] || (_cache[70] = [
                        createBaseVNode("svg", {
                          class: "w-3 md:w-4 lg:w-4 xl:w-5 xl:h-5 2xl:w-6 2xl:h-6 h-3 md:h-4 lg:h-4",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
                        ], -1)
                      ]), 8, _hoisted_63)
                    ])) : (openBlock(), createElementBlock("button", {
                      key: 1,
                      onClick: _cache[29] || (_cache[29] = withModifiers(($event) => showTopicInput.value = true, ["stop"])),
                      class: "flex items-center space-x-1 md:space-x-1.5 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 text-xs md:text-sm lg:text-base xl:text-sm 2xl:text-base font-medium bg-orange-50 hover:bg-orange-100 dark:bg-orange-900/20 dark:hover:bg-orange-800/30 text-orange-600 dark:text-orange-400 rounded-full border border-dashed border-orange-200 dark:border-orange-800 hover:border-orange-400 dark:hover:border-orange-500 transition-colors focus:outline-none focus:ring-2 focus:ring-orange-500",
                      "aria-label": unref(t)("vocabulary.accordion.addTopic", "Add Topic")
                    }, [
                      _cache[72] || (_cache[72] = createBaseVNode("svg", {
                        class: "w-3 md:w-4 lg:w-4 xl:w-5 xl:h-5 2xl:w-6 2xl:h-6 h-3 md:h-4 lg:h-4",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)),
                      createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.accordion.addTopic", "Add Topic")), 1)
                    ], 8, _hoisted_64)),
                    showActionButtons.value ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                      createBaseVNode("div", {
                        class: "flex-shrink-0",
                        onClick: _cache[31] || (_cache[31] = withModifiers(() => {
                        }, ["stop"]))
                      }, [
                        createVNode(unref(VocabularyNoteButton$1), {
                          date: _ctx.group.date,
                          "is-today": isTodayGroup.value,
                          onOpenNoteDialog: _cache[30] || (_cache[30] = () => emit("open-note-dialog", { date: _ctx.group.date, words: _ctx.group.vocabularies }))
                        }, null, 8, ["date", "is-today"])
                      ]),
                      createBaseVNode("div", {
                        class: "flex-shrink-0",
                        onClick: _cache[32] || (_cache[32] = withModifiers(() => {
                        }, ["stop"]))
                      }, [
                        createBaseVNode("button", {
                          onClick: openAddVocabularyDialog,
                          class: "flex items-center space-x-1 md:space-x-1.5 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 text-xs md:text-sm lg:text-base xl:text-sm 2xl:text-base font-medium text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 hover:bg-blue-50 dark:hover:bg-blue-900/50 rounded-full border border-dashed border-blue-300 dark:border-blue-600 hover:border-blue-400 dark:hover:border-blue-500 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500",
                          "aria-label": unref(t)("vocabulary.addWord", "Add Word")
                        }, [
                          _cache[73] || (_cache[73] = createBaseVNode("svg", {
                            class: "w-3 md:w-4 lg:w-4 xl:w-5 xl:h-5 2xl:w-6 2xl:h-6 h-3 md:h-4 lg:h-4",
                            fill: "currentColor",
                            viewBox: "0 0 20 20"
                          }, [
                            createBaseVNode("path", {
                              "fill-rule": "evenodd",
                              d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                              "clip-rule": "evenodd"
                            })
                          ], -1)),
                          createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.addWord", "Add Word")), 1)
                        ], 8, _hoisted_65)
                      ]),
                      createBaseVNode("div", {
                        class: "flex-shrink-0",
                        onClick: _cache[33] || (_cache[33] = withModifiers(() => {
                        }, ["stop"]))
                      }, [
                        createVNode(unref(GrammarManagerButton$1), {
                          date: _ctx.group.date,
                          onOpenGrammarManager: openGrammarManager
                        }, null, 8, ["date"])
                      ])
                    ], 64)) : createCommentVNode("", true)
                  ])) : (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: "flex items-center space-x-1 xs:space-x-1.5 sm:space-x-2 w-full max-w-[150px] xs:max-w-[200px] sm:max-w-xs",
                    onClick: _cache[35] || (_cache[35] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    withDirectives(createBaseVNode("input", {
                      ref_key: "topicInput",
                      ref: topicInput,
                      "onUpdate:modelValue": _cache[34] || (_cache[34] = ($event) => topicInputValue.value = $event),
                      onKeyup: [
                        withKeys(saveTopic, ["enter"]),
                        withKeys(cancelTopicInput, ["escape"])
                      ],
                      type: "text",
                      placeholder: unref(t)("vocabulary.accordion.topicPlaceholder"),
                      class: "flex-1 px-2 xs:px-2 sm:px-2 md:px-2 py-0.5 xs:py-1 sm:py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 text-xs border border-orange-300 dark:border-orange-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
                    }, null, 40, _hoisted_66), [
                      [vModelText, topicInputValue.value]
                    ]),
                    createBaseVNode("button", {
                      onClick: saveTopic,
                      class: "px-1.5 xs:px-2 sm:px-2 md:px-2 py-0.5 xs:py-1 sm:py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 text-xs bg-orange-600 hover:bg-orange-700 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500 transition-colors",
                      "aria-label": unref(t)("vocabulary.accordion.saveTopic")
                    }, _cache[74] || (_cache[74] = [
                      createBaseVNode("svg", {
                        class: "w-3 h-3",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)
                    ]), 8, _hoisted_67),
                    createBaseVNode("button", {
                      onClick: cancelTopicInput,
                      class: "px-1.5 xs:px-2 sm:px-2 md:px-2 py-0.5 xs:py-1 sm:py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 text-xs bg-gray-500 hover:bg-gray-600 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors",
                      "aria-label": unref(t)("vocabulary.accordion.cancelTopic")
                    }, _cache[75] || (_cache[75] = [
                      createBaseVNode("svg", {
                        class: "w-3 h-3",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)
                    ]), 8, _hoisted_68)
                  ]))
                ])
              ])
            ])
          ]),
          createVNode(Transition, { name: "accordion" }, {
            default: withCtx(() => [
              isExpanded.value ? (openBlock(), createElementBlock("div", _hoisted_69, [
                _ctx.group.topics && _ctx.group.topics.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_70, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.group.topics, (topicGroup) => {
                    return openBlock(), createElementBlock("div", {
                      key: topicGroup.topic,
                      class: "topic-group",
                      onMouseenter: ($event) => _ctx.hoverToExpandEnabled ? handleTopicHover(topicGroup.topic, true) : null,
                      onMouseleave: ($event) => _ctx.hoverToExpandEnabled ? handleTopicHover(topicGroup.topic, false) : null
                    }, [
                      createBaseVNode("div", _hoisted_72, [
                        createBaseVNode("div", {
                          id: `date-group-${_ctx.group.date}-topic-${topicGroup.topic}`,
                          class: "flex items-center justify-between px-6 py-3 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-custom/50",
                          onClick: ($event) => toggleTopicAccordion(topicGroup.topic)
                        }, [
                          createBaseVNode("div", _hoisted_74, [
                            (openBlock(), createElementBlock("svg", {
                              class: normalizeClass(["w-4 h-4 text-gray-400 dark:text-gray-500 transition-transform duration-200", { "transform rotate-90": isTopicExpanded(topicGroup.topic) }]),
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, _cache[76] || (_cache[76] = [
                              createBaseVNode("path", {
                                "fill-rule": "evenodd",
                                d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                                "clip-rule": "evenodd"
                              }, null, -1)
                            ]), 2)),
                            createBaseVNode("div", _hoisted_75, [
                              createBaseVNode("h5", _hoisted_76, [
                                createTextVNode(toDisplayString$1(unref(getTopicName)(topicGroup.topic, unref(t), unref(locale))) + " ", 1),
                                createBaseVNode("span", _hoisted_77, "(" + toDisplayString$1(topicGroup.vocabularies.length) + ")", 1)
                              ]),
                              createBaseVNode("div", {
                                class: "relative",
                                onMouseenter: withModifiers(($event) => handleInfoMouseEnter(topicGroup.topic), ["stop"]),
                                onMouseleave: handleInfoMouseLeave,
                                onClick: _cache[36] || (_cache[36] = withModifiers(() => {
                                }, ["stop"]))
                              }, [
                                createBaseVNode("button", {
                                  type: "button",
                                  class: "p-1 text-blue-600 dark:text-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-md",
                                  "aria-label": unref(t)("vocabulary.sameTopicDatesAria", "Show dates with same topic")
                                }, _cache[77] || (_cache[77] = [
                                  createBaseVNode("svg", {
                                    viewBox: "0 0 24 24",
                                    fill: "currentColor",
                                    class: "w-4 h-4"
                                  }, [
                                    createBaseVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm.75 15h-1.5v-6h1.5v6zm0-8h-1.5V7h1.5v2z" })
                                  ], -1)
                                ]), 8, _hoisted_79),
                                infoHoverTopic.value === topicGroup.topic ? (openBlock(), createElementBlock("div", {
                                  key: 0,
                                  class: "absolute left-full top-1/2 -translate-y-1/2 ml-3 w-64 rounded-lg shadow-xl ring-1 ring-black/5 bg-white text-gray-800 p-3 z-30 border border-gray-200 dark:bg-[#0a0a0a] dark:text-white dark:border dark:border-[#0f0f0f]",
                                  onMouseenter: handleTooltipMouseEnter,
                                  onMouseleave: handleTooltipMouseLeave
                                }, [
                                  _cache[78] || (_cache[78] = createBaseVNode("div", {
                                    class: "absolute -left-1.5 top-1/2 -translate-y-1/2 w-3 h-3 rotate-45 bg-white dark:bg-[#0a0a0a]",
                                    "aria-hidden": "true"
                                  }, null, -1)),
                                  createBaseVNode("div", _hoisted_80, toDisplayString$1(unref(t)("vocabulary.sameTopicDatesTitle", "Dates with same topic")), 1),
                                  !availableDatesByTopic.value[topicGroup.topic] || availableDatesByTopic.value[topicGroup.topic].length === 0 ? (openBlock(), createElementBlock("div", _hoisted_81, toDisplayString$1(unref(t)("vocabulary.sameTopicDatesEmpty", "No other dates found for this topic")), 1)) : (openBlock(), createElementBlock("ul", {
                                    key: 1,
                                    class: normalizeClass(["text-xs space-y-1 pr-1 overflow-y-auto", { "max-h-24": (availableDatesByTopic.value[topicGroup.topic]?.length || 0) >= 4 }])
                                  }, [
                                    (openBlock(true), createElementBlock(Fragment, null, renderList(availableDatesByTopic.value[topicGroup.topic], (d) => {
                                      return openBlock(), createElementBlock("li", {
                                        key: d.date,
                                        class: "flex items-center justify-between hover:bg-white dark:hover:bg-[#0f0f0f] rounded px-2 py-1 cursor-pointer",
                                        onClick: ($event) => handleNavigateClick(d.date, topicGroup.topic)
                                      }, [
                                        createBaseVNode("span", null, toDisplayString$1(formatDateForDisplay(d.date)), 1),
                                        createBaseVNode("span", _hoisted_83, "(" + toDisplayString$1(d.count) + ")", 1)
                                      ], 8, _hoisted_82);
                                    }), 128))
                                  ], 2))
                                ], 32)) : createCommentVNode("", true)
                              ], 40, _hoisted_78)
                            ])
                          ]),
                          _ctx.globalMoveMode && topicGroup.vocabularies.length > 0 ? (openBlock(), createElementBlock("button", {
                            key: 0,
                            onClick: withModifiers(($event) => handleBatchMoveCategory(topicGroup), ["stop"]),
                            class: "ml-auto mr-2 p-1.5 text-purple-600 dark:text-purple-400 hover:bg-purple-50 dark:hover:bg-purple-900/20 rounded-md transition-colors",
                            title: unref(t)("vocabulary.moveCategoryToAnotherDay", "Move all words in this category to another day")
                          }, _cache[79] || (_cache[79] = [
                            createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"
                              })
                            ], -1)
                          ]), 8, _hoisted_84)) : createCommentVNode("", true)
                        ], 8, _hoisted_73),
                        isTopicExpanded(topicGroup.topic) && getPaginatedTopicVocabularies(topicGroup).totalPages > 1 ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          class: "px-6 pb-3",
                          onClick: _cache[37] || (_cache[37] = withModifiers(() => {
                          }, ["stop"]))
                        }, [
                          createBaseVNode("div", _hoisted_85, [
                            createBaseVNode("div", _hoisted_86, [
                              createBaseVNode("button", {
                                onClick: ($event) => previousTopicPage(topicGroup.topic),
                                disabled: !getPaginatedTopicVocabularies(topicGroup).hasPrevious,
                                class: "relative inline-flex items-center px-2 md:px-2 py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 border border-gray-300 dark:border-gray-600 text-xs font-medium rounded text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                              }, toDisplayString$1(unref(t)("common.previous")), 9, _hoisted_87),
                              createBaseVNode("button", {
                                onClick: ($event) => nextTopicPage(topicGroup.topic),
                                disabled: !getPaginatedTopicVocabularies(topicGroup).hasNext,
                                class: "ml-2 relative inline-flex items-center px-2 md:px-2 py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 border border-gray-300 dark:border-gray-600 text-xs font-medium rounded text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                              }, toDisplayString$1(unref(t)("common.next")), 9, _hoisted_88)
                            ]),
                            createBaseVNode("div", _hoisted_89, [
                              createBaseVNode("div", null, [
                                createBaseVNode("p", _hoisted_90, toDisplayString$1(unref(t)("vocabulary.showingCategoryItems", {
                                  start: getPaginatedTopicVocabularies(topicGroup).startIndex,
                                  end: getPaginatedTopicVocabularies(topicGroup).endIndex,
                                  total: getPaginatedTopicVocabularies(topicGroup).totalItems
                                }, `Showing ${getPaginatedTopicVocabularies(topicGroup).startIndex} to ${getPaginatedTopicVocabularies(topicGroup).endIndex} of ${getPaginatedTopicVocabularies(topicGroup).totalItems} items`)), 1)
                              ]),
                              createBaseVNode("div", null, [
                                createBaseVNode("nav", _hoisted_91, [
                                  createBaseVNode("button", {
                                    onClick: ($event) => previousTopicPage(topicGroup.topic),
                                    disabled: !getPaginatedTopicVocabularies(topicGroup).hasPrevious,
                                    class: "relative inline-flex items-center px-1.5 md:px-1.5 py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 rounded-l-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-xs font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                                  }, [
                                    createBaseVNode("span", _hoisted_93, toDisplayString$1(unref(t)("common.previous")), 1),
                                    _cache[80] || (_cache[80] = createBaseVNode("svg", {
                                      class: "h-3 w-3",
                                      fill: "currentColor",
                                      viewBox: "0 0 20 20"
                                    }, [
                                      createBaseVNode("path", {
                                        "fill-rule": "evenodd",
                                        d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                                        "clip-rule": "evenodd"
                                      })
                                    ], -1))
                                  ], 8, _hoisted_92),
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(getVisibleTopicPages(getPaginatedTopicVocabularies(topicGroup).currentPage, getPaginatedTopicVocabularies(topicGroup).totalPages), (page) => {
                                    return openBlock(), createElementBlock("button", {
                                      key: `${topicGroup.topic}-${page}`,
                                      onClick: ($event) => page > 0 ? goToTopicPage(topicGroup.topic, page) : null,
                                      disabled: page === -1,
                                      class: normalizeClass([
                                        page === getPaginatedTopicVocabularies(topicGroup).currentPage ? "z-10 bg-blue-50 dark:bg-blue-900 border-blue-500 dark:border-blue-400 text-blue-600 dark:text-blue-300" : page === -1 ? "bg-white dark:bg-[#0a0a0a] border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-400 cursor-default" : "bg-white dark:bg-[#0a0a0a] border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600",
                                        "relative inline-flex items-center px-2 md:px-2 py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 border text-xs font-medium"
                                      ])
                                    }, toDisplayString$1(page === -1 ? "..." : page), 11, _hoisted_94);
                                  }), 128)),
                                  createBaseVNode("button", {
                                    onClick: ($event) => nextTopicPage(topicGroup.topic),
                                    disabled: !getPaginatedTopicVocabularies(topicGroup).hasNext,
                                    class: "relative inline-flex items-center px-1.5 md:px-1.5 py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 rounded-r-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-xs font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                                  }, [
                                    createBaseVNode("span", _hoisted_96, toDisplayString$1(unref(t)("common.next")), 1),
                                    _cache[81] || (_cache[81] = createBaseVNode("svg", {
                                      class: "h-3 w-3",
                                      fill: "currentColor",
                                      viewBox: "0 0 20 20"
                                    }, [
                                      createBaseVNode("path", {
                                        "fill-rule": "evenodd",
                                        d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                                        "clip-rule": "evenodd"
                                      })
                                    ], -1))
                                  ], 8, _hoisted_95)
                                ])
                              ])
                            ])
                          ])
                        ])) : createCommentVNode("", true)
                      ]),
                      createVNode(Transition, { name: "topic-accordion" }, {
                        default: withCtx(() => [
                          isTopicExpanded(topicGroup.topic) ? (openBlock(), createElementBlock("div", _hoisted_97, [
                            createBaseVNode("div", _hoisted_98, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(getPaginatedTopicVocabularies(topicGroup).vocabularies, (word) => {
                                return openBlock(), createBlock(unref(VocabularyCard), {
                                  key: word.id,
                                  word,
                                  "move-mode": _ctx.globalMoveMode,
                                  onPlayAudio: _cache[38] || (_cache[38] = ($event) => _ctx.$emit("play-audio", $event)),
                                  onEditWord: _cache[39] || (_cache[39] = ($event) => _ctx.$emit("edit-word", $event)),
                                  onDeleteWord: _cache[40] || (_cache[40] = ($event) => _ctx.$emit("delete-word", $event)),
                                  onToggleFavorite: _cache[41] || (_cache[41] = ($event) => _ctx.$emit("toggle-favorite", $event)),
                                  onViewDetails: _cache[42] || (_cache[42] = ($event) => _ctx.$emit("view-details", $event)),
                                  onMoveVocabulary: handleMoveVocabulary
                                }, null, 8, ["word", "move-mode"]);
                              }), 128))
                            ])
                          ])) : createCommentVNode("", true)
                        ]),
                        _: 2
                      }, 1024)
                    ], 40, _hoisted_71);
                  }), 128))
                ])) : (openBlock(), createElementBlock("div", _hoisted_99, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.group.vocabularies, (word) => {
                    return openBlock(), createBlock(unref(VocabularyCard), {
                      key: word.id,
                      word,
                      "move-mode": _ctx.globalMoveMode,
                      onPlayAudio: _cache[43] || (_cache[43] = ($event) => _ctx.$emit("play-audio", $event)),
                      onEditWord: _cache[44] || (_cache[44] = ($event) => _ctx.$emit("edit-word", $event)),
                      onDeleteWord: _cache[45] || (_cache[45] = ($event) => _ctx.$emit("delete-word", $event)),
                      onToggleFavorite: _cache[46] || (_cache[46] = ($event) => _ctx.$emit("toggle-favorite", $event)),
                      onViewDetails: _cache[47] || (_cache[47] = ($event) => _ctx.$emit("view-details", $event)),
                      onMoveVocabulary: handleMoveVocabulary
                    }, null, 8, ["word", "move-mode"]);
                  }), 128))
                ]))
              ])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
});

const DateGroupAccordion = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-6105a4b6"]]);

const DateGroupAccordion$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: DateGroupAccordion
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$a = { class: "space-y-4" };
const _hoisted_2$8 = { class: "relative" };
const _hoisted_3$7 = {
  for: "image-upload",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
};
const _hoisted_4$7 = { class: "flex items-center space-x-4 mb-4" };
const _hoisted_5$6 = { key: 0 };
const _hoisted_6$5 = { class: "flex flex-col items-center space-y-2" };
const _hoisted_7$5 = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_8$5 = { class: "font-medium text-blue-600 dark:text-blue-400" };
const _hoisted_9$5 = { class: "text-xs text-gray-500 dark:text-gray-500" };
const _hoisted_10$5 = {
  key: 1,
  class: "space-y-3"
};
const _hoisted_11$5 = ["placeholder"];
const _hoisted_12$5 = ["disabled"];
const _hoisted_13$5 = {
  key: 0,
  class: "animate-spin -ml-1 mr-2 h-4 w-4 text-white",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _hoisted_14$5 = {
  key: 2,
  class: "space-y-3"
};
const _hoisted_15$4 = { class: "p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 text-sm" };
const _hoisted_16$4 = { class: "flex items-center space-x-2 mt-2" };
const _hoisted_17$4 = ["disabled"];
const _hoisted_18$4 = {
  key: 0,
  class: "animate-spin -ml-1 mr-2 h-4 w-4 text-white",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _hoisted_19$4 = {
  key: 1,
  class: "w-4 h-4",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_20$4 = {
  key: 0,
  class: "text-green-600 dark:text-green-400 text-sm"
};
const _hoisted_21$4 = { class: "p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 text-sm" };
const _hoisted_22$4 = { key: 0 };
const _hoisted_23$4 = {
  key: 1,
  class: "space-y-2"
};
const _hoisted_24$4 = { class: "flex items-center space-x-2" };
const _hoisted_25$4 = ["disabled"];
const _hoisted_26$3 = {
  key: 0,
  class: "animate-spin -ml-1 mr-2 h-4 w-4 text-white",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _hoisted_27$3 = {
  key: 1,
  class: "w-4 h-4",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_28$3 = {
  key: 0,
  class: "text-green-600 dark:text-green-400 text-sm"
};
const _hoisted_29$3 = {
  key: 1,
  class: "text-yellow-600 dark:text-yellow-400 text-sm"
};
const _hoisted_30$3 = {
  key: 3,
  class: "relative"
};
const _hoisted_31$3 = { class: "border-2 border-gray-200 dark:border-gray-600 rounded-lg overflow-hidden" };
const _hoisted_32$2 = ["src", "alt"];
const _hoisted_33$2 = { class: "flex items-center justify-between mt-2" };
const _hoisted_34$2 = { class: "flex items-center space-x-2" };
const _hoisted_35$2 = { class: "text-xs text-gray-500 dark:text-gray-400" };
const _hoisted_36$2 = { key: 0 };
const _hoisted_37$1 = { key: 1 };
const _hoisted_38$1 = {
  key: 4,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50"
};
const _hoisted_39$1 = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg p-6 w-full max-w-md mx-4" };
const _hoisted_40$1 = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_41 = { class: "space-y-4" };
const _hoisted_42 = ["placeholder"];
const _hoisted_43 = { class: "flex justify-end space-x-3" };
const _hoisted_44 = ["disabled"];
const _hoisted_45 = {
  key: 5,
  class: "absolute inset-0 bg-white dark:bg-[#0a0a0a] bg-opacity-75 flex items-center justify-center rounded-lg"
};
const _hoisted_46 = { class: "flex items-center space-x-2 text-blue-600 dark:text-blue-400" };
const _hoisted_47 = { class: "text-sm" };
const _hoisted_48 = {
  key: 0,
  class: "p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md"
};
const _hoisted_49 = { class: "flex items-center space-x-2" };
const _hoisted_50 = { class: "text-sm text-red-700 dark:text-red-300" };
const MAX_FILE_SIZE = 5 * 1024 * 1024;
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "ImageUpload",
  props: {
    modelValue: { default: null }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const fileInput = ref();
    const imagePreview = ref(null);
    const imageInfo = ref(null);
    const isDragOver = ref(false);
    const isProcessing = ref(false);
    const errorMessage = ref(null);
    const inputMethod = ref("upload");
    const imageUrl = ref("");
    const newImageUrl = ref("");
    const showUrlEdit = ref(false);
    const copyStatus = ref(null);
    const SUPPORTED_TYPES = ["image/jpeg", "image/png", "image/gif", "image/webp"];
    const handlePaste = async (e) => {
      try {
        const target = e.target;
        if (target && target.closest('input, textarea, [contenteditable="true"]')) return;
        if (inputMethod.value !== "copy") return;
        const cd = e.clipboardData;
        if (!cd) return;
        const items = cd.items;
        let imageFile = null;
        if (items && items.length) {
          for (let i = 0; i < items.length; i++) {
            const it = items[i];
            if (it.kind === "file" && it.type.startsWith("image/")) {
              const f = it.getAsFile();
              if (f) {
                imageFile = f;
                break;
              }
            }
          }
        }
        if (!imageFile && cd.files && cd.files.length > 0 && cd.files[0].type.startsWith("image/")) {
          imageFile = cd.files[0];
        }
        if (imageFile) {
          e.preventDefault();
          await processFile(imageFile);
          copyStatus.value = { type: "success", message: t("vocabulary.image.paste.success", "Image pasted!") || "Image pasted!" };
          return;
        }
        const text = cd.getData("text/plain");
        if (text && isValidImageUrl(text)) {
          e.preventDefault();
          imageUrl.value = text;
          await handleUrlInput();
          copyStatus.value = { type: "success", message: t("vocabulary.image.paste.success", "Image pasted!") || "Image pasted!" };
          return;
        }
        errorMessage.value = t("vocabulary.image.paste.noImage", "Clipboard does not contain an image");
      } catch (err) {
        console.error("Paste handler error:", err);
        errorMessage.value = t("vocabulary.image.paste.error", "Failed to paste from clipboard");
      }
    };
    onMounted(() => {
      if (inputMethod.value === "copy") {
        window.addEventListener("paste", handlePaste);
      }
    });
    watch(inputMethod, (val, oldVal) => {
      if (oldVal === "copy") {
        window.removeEventListener("paste", handlePaste);
      }
      if (val === "copy") {
        window.addEventListener("paste", handlePaste);
      }
    });
    onUnmounted(() => {
      window.removeEventListener("paste", handlePaste);
    });
    const triggerFileInput = () => {
      fileInput.value?.click();
    };
    const handleFileChange = (event) => {
      const target = event.target;
      const file = target.files?.[0];
      if (file) {
        processFile(file);
      }
    };
    const handleDragOver = (event) => {
      event.preventDefault();
      isDragOver.value = true;
    };
    const handleDragLeave = (event) => {
      event.preventDefault();
      isDragOver.value = false;
    };
    const handleDrop = (event) => {
      event.preventDefault();
      isDragOver.value = false;
      const files = event.dataTransfer?.files;
      if (files && files.length > 0) {
        processFile(files[0]);
      }
    };
    const processFile = async (file) => {
      errorMessage.value = null;
      if (!SUPPORTED_TYPES.includes(file.type)) {
        errorMessage.value = t("vocabulary.image.errors.unsupportedFormat", "Unsupported file format");
        return;
      }
      if (file.size > MAX_FILE_SIZE) {
        errorMessage.value = t("vocabulary.image.errors.fileTooLarge", "File size too large");
        return;
      }
      isProcessing.value = true;
      try {
        const base64 = await fileToBase64(file);
        imagePreview.value = base64;
        imageInfo.value = {
          name: file.name,
          size: file.size
        };
        emit("update:modelValue", base64);
      } catch (error) {
        console.error("Error processing image:", error);
        errorMessage.value = t("vocabulary.image.errors.processingFailed", "Failed to process image");
      } finally {
        isProcessing.value = false;
      }
    };
    const fileToBase64 = (file) => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => {
          const result = reader.result;
          resolve(result);
        };
        reader.onerror = (error) => reject(error);
      });
    };
    const dataUrlToBlob = async (dataUrl) => {
      const res = await fetch(dataUrl);
      return await res.blob();
    };
    const fetchImageBlob = async (url) => {
      const res = await fetch(url, { mode: "cors" });
      if (!res.ok) throw new Error("Fetch failed");
      return await res.blob();
    };
    const urlToBlobViaCanvas = (url) => {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          try {
            const canvas = document.createElement("canvas");
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            const ctx = canvas.getContext("2d");
            if (!ctx) return reject(new Error("Canvas not supported"));
            ctx.drawImage(img, 0, 0);
            canvas.toBlob((blob) => {
              if (blob) resolve(blob);
              else reject(new Error("Canvas toBlob failed"));
            });
          } catch (e) {
            reject(e);
          }
        };
        img.onerror = () => reject(new Error("Image load error"));
        img.src = url;
      });
    };
    const copyImageToClipboard = async () => {
      copyStatus.value = null;
      errorMessage.value = null;
      if (!imagePreview.value) {
        errorMessage.value = t("vocabulary.image.copy.noImage", "No image to copy. Please upload or load an image first.");
        return;
      }
      const hasClipboard = !!(navigator.clipboard && navigator.clipboard.write && window.ClipboardItem);
      if (!hasClipboard) {
        errorMessage.value = t("vocabulary.image.copy.unsupported", "Clipboard API for images is not supported in this browser.");
        return;
      }
      isProcessing.value = true;
      try {
        let blob;
        if (imagePreview.value.startsWith("data:")) {
          blob = await dataUrlToBlob(imagePreview.value);
        } else if (imagePreview.value.startsWith("http")) {
          try {
            blob = await fetchImageBlob(imagePreview.value);
          } catch {
            blob = await urlToBlobViaCanvas(imagePreview.value);
          }
        } else {
          throw new Error("Unknown image source");
        }
        const mime = blob.type || "image/png";
        const item = new window.ClipboardItem({ [mime]: blob });
        await navigator.clipboard.write([item]);
        copyStatus.value = { type: "success", message: t("vocabulary.image.copy.success", "Image copied to clipboard!") || "Image copied to clipboard!" };
      } catch (err) {
        console.error("Copy image failed:", err);
        errorMessage.value = t("vocabulary.image.copy.failed", "Failed to copy image. Some images cannot be copied due to browser or CORS restrictions.");
        if (imagePreview.value?.startsWith("http")) {
          copyStatus.value = { type: "warning", message: t("vocabulary.image.copy.corsNote", "Tip: Images from some websites block copying. Try uploading the image instead.") || "Tip: Images from some websites block copying. Try uploading the image instead." };
        }
      } finally {
        isProcessing.value = false;
        setTimeout(() => {
          copyStatus.value = null;
        }, 2500);
      }
    };
    const pasteImageFromClipboard = async () => {
      copyStatus.value = null;
      errorMessage.value = null;
      if (inputMethod.value !== "copy") return;
      const canRead = !!(navigator.clipboard && navigator.clipboard.read);
      isProcessing.value = true;
      try {
        if (canRead) {
          const items = await navigator.clipboard.read();
          for (const item of items) {
            const types = item.types || [];
            const imageType = types.find((t2) => t2.startsWith("image/"));
            if (imageType) {
              const blob = await item.getType(imageType);
              const ext = (blob.type.split("/")[1] || "png").replace(/[^a-z0-9]/gi, "");
              const file = new File([blob], `clipboard-${Date.now()}.${ext}`, { type: blob.type });
              await processFile(file);
              copyStatus.value = { type: "success", message: t("vocabulary.image.paste.success", "Image pasted!") || "Image pasted!" };
              return;
            }
          }
        }
        if (navigator.clipboard && navigator.clipboard.readText) {
          const text = await navigator.clipboard.readText();
          const url = text?.trim();
          if (url && isValidImageUrl(url)) {
            imageUrl.value = url;
            await handleUrlInput();
            copyStatus.value = { type: "success", message: t("vocabulary.image.paste.success", "Image pasted!") || "Image pasted!" };
            return;
          }
        }
        errorMessage.value = t("vocabulary.image.paste.noImage", "Clipboard does not contain an image");
      } catch (err) {
        console.error("pasteImageFromClipboard failed:", err);
        errorMessage.value = t("vocabulary.image.paste.error", "Failed to paste from clipboard");
      } finally {
        isProcessing.value = false;
        if (copyStatus.value?.type === "success") {
          setTimeout(() => {
            copyStatus.value = null;
          }, 2500);
        }
      }
    };
    const removeImage = () => {
      imagePreview.value = null;
      imageInfo.value = null;
      errorMessage.value = null;
      imageUrl.value = "";
      if (fileInput.value) {
        fileInput.value.value = "";
      }
      emit("update:modelValue", null);
    };
    const handleUrlInput = async () => {
      if (!imageUrl.value.trim()) {
        errorMessage.value = t("vocabulary.image.errors.emptyUrl");
        return;
      }
      if (!isValidImageUrl(imageUrl.value)) {
        errorMessage.value = t("vocabulary.image.errors.invalidUrl");
        return;
      }
      isProcessing.value = true;
      errorMessage.value = null;
      try {
        await validateImageUrl(imageUrl.value);
        imagePreview.value = imageUrl.value;
        imageInfo.value = null;
        emit("update:modelValue", imageUrl.value);
      } catch (error) {
        console.error("Error loading image from URL:", error);
        if (isValidImageUrl(imageUrl.value)) {
          imagePreview.value = imageUrl.value;
          imageInfo.value = null;
          emit("update:modelValue", imageUrl.value);
          errorMessage.value = t("vocabulary.image.errors.corsWarning");
        } else {
          errorMessage.value = t("vocabulary.image.errors.urlLoadFailed");
        }
      } finally {
        isProcessing.value = false;
      }
    };
    const handleUrlChange = async () => {
      if (!newImageUrl.value.trim()) {
        errorMessage.value = t("vocabulary.image.errors.emptyUrl");
        return;
      }
      if (!isValidImageUrl(newImageUrl.value)) {
        errorMessage.value = t("vocabulary.image.errors.invalidUrl");
        return;
      }
      isProcessing.value = true;
      errorMessage.value = null;
      try {
        await validateImageUrl(newImageUrl.value);
        imagePreview.value = newImageUrl.value;
        imageUrl.value = newImageUrl.value;
        emit("update:modelValue", newImageUrl.value);
        showUrlEdit.value = false;
        newImageUrl.value = "";
      } catch (error) {
        console.error("Error loading image from URL:", error);
        if (isValidImageUrl(newImageUrl.value)) {
          imagePreview.value = newImageUrl.value;
          imageUrl.value = newImageUrl.value;
          emit("update:modelValue", newImageUrl.value);
          showUrlEdit.value = false;
          newImageUrl.value = "";
          errorMessage.value = t("vocabulary.image.errors.corsWarning");
        } else {
          errorMessage.value = t("vocabulary.image.errors.urlLoadFailed");
        }
      } finally {
        isProcessing.value = false;
      }
    };
    const isValidImageUrl = (url) => {
      try {
        const urlObj = new URL(url);
        if (!["http:", "https:"].includes(urlObj.protocol)) {
          return false;
        }
        const imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".webp", ".bmp", ".svg"];
        const pathname = urlObj.pathname.toLowerCase();
        const hasImageExtension = imageExtensions.some((ext) => pathname.includes(ext));
        const commonImageHosts = [
          "imgur.com",
          "cloudinary.com",
          "unsplash.com",
          "pexels.com",
          "pixabay.com",
          "googleusercontent.com",
          "gstatic.com",
          "ggpht.com",
          // Google services
          "fbcdn.net",
          "cdninstagram.com",
          // Facebook/Instagram
          "twimg.com",
          // Twitter
          "amazonaws.com",
          "s3.",
          // AWS S3
          "githubusercontent.com",
          // GitHub
          "wikimedia.org",
          "wikipedia.org",
          // Wikipedia
          "flickr.com",
          "staticflickr.com",
          // Flickr
          "dropbox.com",
          "dropboxusercontent.com",
          // Dropbox
          "drive.google.com",
          // Google Drive
          "ibb.co",
          "postimg.cc",
          // Image hosting services
          "cdn.",
          "images.",
          "img.",
          "static.",
          "media."
          // Common CDN patterns
        ];
        const hasImageHost = commonImageHosts.some((host) => url.includes(host));
        const imageQueryParams = ["jpg", "jpeg", "png", "gif", "webp", "image", "img", "photo"];
        const queryString = urlObj.search.toLowerCase();
        const hasImageQuery = imageQueryParams.some((param) => queryString.includes(param));
        return hasImageExtension || hasImageHost || hasImageQuery;
      } catch {
        return false;
      }
    };
    const validateImageUrl = (url) => {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const timeout = setTimeout(() => {
          reject(new Error("Image load timeout"));
        }, 8e3);
        img.onload = () => {
          clearTimeout(timeout);
          resolve();
        };
        img.onerror = () => {
          clearTimeout(timeout);
          if (isValidImageUrl(url)) {
            console.warn("Image validation failed but URL looks valid, accepting anyway");
            resolve();
          } else {
            reject(new Error("Failed to load image"));
          }
        };
        img.src = url;
      });
    };
    const formatFileSize = (bytes) => {
      if (bytes === 0) return "0 Bytes";
      const k = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    };
    watch(
      () => props.modelValue,
      (newValue) => {
        if (newValue !== imagePreview.value) {
          imagePreview.value = newValue;
          if (!newValue) {
            imageInfo.value = null;
            errorMessage.value = null;
            imageUrl.value = "";
          } else {
            if (newValue.startsWith("http")) {
              inputMethod.value = "url";
              imageUrl.value = newValue;
            } else {
              inputMethod.value = "upload";
            }
          }
        }
      },
      { immediate: true }
    );
    watch(inputMethod, (newMethod) => {
      errorMessage.value = null;
    });
    onMounted(() => {
      if (props.modelValue) {
        imagePreview.value = props.modelValue;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$a, [
        createBaseVNode("div", _hoisted_2$8, [
          createBaseVNode("label", _hoisted_3$7, toDisplayString$1(unref(t)("vocabulary.image.title", "Image")), 1),
          createBaseVNode("div", _hoisted_4$7, [
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => inputMethod.value = "upload"),
              type: "button",
              class: normalizeClass([
                "px-4 py-2 text-sm font-medium rounded-lg transition-colors",
                inputMethod.value === "upload" ? "bg-blue-600 text-white" : "bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600"
              ])
            }, toDisplayString$1(unref(t)("vocabulary.image.upload", "Upload")), 3),
            createBaseVNode("button", {
              onClick: _cache[1] || (_cache[1] = ($event) => inputMethod.value = "url"),
              type: "button",
              class: normalizeClass([
                "px-4 py-2 text-sm font-medium rounded-lg transition-colors",
                inputMethod.value === "url" ? "bg-blue-600 text-white" : "bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600"
              ])
            }, toDisplayString$1(unref(t)("vocabulary.image.url", "URL")), 3),
            createBaseVNode("button", {
              onClick: _cache[2] || (_cache[2] = ($event) => inputMethod.value = "copy"),
              type: "button",
              class: normalizeClass([
                "px-4 py-2 text-sm font-medium rounded-lg transition-colors",
                inputMethod.value === "copy" ? "bg-blue-600 text-white" : "bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600"
              ])
            }, toDisplayString$1(unref(t)("vocabulary.image.copyTab", "Copy")), 3)
          ]),
          createBaseVNode("input", {
            id: "image-upload",
            ref_key: "fileInput",
            ref: fileInput,
            type: "file",
            accept: "image/*",
            onChange: handleFileChange,
            class: "hidden"
          }, null, 544),
          inputMethod.value === "upload" && !imagePreview.value ? (openBlock(), createElementBlock("div", _hoisted_5$6, [
            createBaseVNode("div", {
              onClick: triggerFileInput,
              onDragover: withModifiers(handleDragOver, ["prevent"]),
              onDragleave: withModifiers(handleDragLeave, ["prevent"]),
              onDrop: withModifiers(handleDrop, ["prevent"]),
              class: normalizeClass([
                "border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors",
                isDragOver.value ? "border-blue-500 bg-blue-50 dark:bg-blue-900/20" : "border-gray-300 dark:border-gray-600 hover:border-blue-400 dark:hover:border-blue-500",
                "bg-gray-50 dark:bg-[#0a0a0a]/50 hover:bg-gray-100 dark:hover:bg-gray-700/50"
              ])
            }, [
              createBaseVNode("div", _hoisted_6$5, [
                _cache[7] || (_cache[7] = createBaseVNode("svg", {
                  class: "w-8 h-8 text-gray-400 dark:text-gray-500",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                  })
                ], -1)),
                createBaseVNode("div", _hoisted_7$5, [
                  createBaseVNode("span", _hoisted_8$5, toDisplayString$1(unref(t)("vocabulary.image.clickToUpload", "Click to upload")), 1),
                  createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.image.orDragDrop", " or drag and drop")), 1)
                ]),
                createBaseVNode("p", _hoisted_9$5, toDisplayString$1(unref(t)("vocabulary.image.supportedFormats", "PNG, JPG, GIF up to 10MB")), 1)
              ])
            ], 34)
          ])) : createCommentVNode("", true),
          inputMethod.value === "url" && !imagePreview.value ? (openBlock(), createElementBlock("div", _hoisted_10$5, [
            createBaseVNode("div", null, [
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => imageUrl.value = $event),
                onBlur: handleUrlInput,
                onKeyup: withKeys(handleUrlInput, ["enter"]),
                type: "url",
                placeholder: unref(t)("vocabulary.image.urlPlaceholder", "Enter image URL"),
                class: "w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
              }, null, 40, _hoisted_11$5), [
                [vModelText, imageUrl.value]
              ])
            ]),
            createBaseVNode("button", {
              onClick: handleUrlInput,
              disabled: !imageUrl.value.trim() || isProcessing.value,
              type: "button",
              class: "w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white rounded-lg transition-colors flex items-center justify-center space-x-2"
            }, [
              isProcessing.value ? (openBlock(), createElementBlock("svg", _hoisted_13$5, _cache[8] || (_cache[8] = [
                createBaseVNode("circle", {
                  class: "opacity-25",
                  cx: "12",
                  cy: "12",
                  r: "10",
                  stroke: "currentColor",
                  "stroke-width": "4"
                }, null, -1),
                createBaseVNode("path", {
                  class: "opacity-75",
                  fill: "currentColor",
                  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                }, null, -1)
              ]))) : createCommentVNode("", true),
              createBaseVNode("span", null, toDisplayString$1(isProcessing.value ? unref(t)("vocabulary.image.loading", "Loading...") : unref(t)("vocabulary.image.loadFromUrl", "Load from URL")), 1)
            ], 8, _hoisted_12$5)
          ])) : createCommentVNode("", true),
          inputMethod.value === "copy" ? (openBlock(), createElementBlock("div", _hoisted_14$5, [
            createBaseVNode("div", _hoisted_15$4, [
              createBaseVNode("p", null, toDisplayString$1(unref(t)("vocabulary.image.paste.hint", "Press Ctrl+V to paste an image, or click the button:")), 1),
              createBaseVNode("div", _hoisted_16$4, [
                createBaseVNode("button", {
                  onClick: pasteImageFromClipboard,
                  type: "button",
                  class: "px-4 py-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white rounded-lg transition-colors flex items-center space-x-2",
                  disabled: isProcessing.value
                }, [
                  isProcessing.value ? (openBlock(), createElementBlock("svg", _hoisted_18$4, _cache[9] || (_cache[9] = [
                    createBaseVNode("circle", {
                      class: "opacity-25",
                      cx: "12",
                      cy: "12",
                      r: "10",
                      stroke: "currentColor",
                      "stroke-width": "4"
                    }, null, -1),
                    createBaseVNode("path", {
                      class: "opacity-75",
                      fill: "currentColor",
                      d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    }, null, -1)
                  ]))) : (openBlock(), createElementBlock("svg", _hoisted_19$4, _cache[10] || (_cache[10] = [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M8 16h8M8 12h8m8-5H8l-2-2H4a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7z"
                    }, null, -1)
                  ]))),
                  createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.image.paste.button", "Paste image from clipboard")), 1)
                ], 8, _hoisted_17$4),
                copyStatus.value && copyStatus.value.type === "success" ? (openBlock(), createElementBlock("span", _hoisted_20$4, toDisplayString$1(copyStatus.value.message), 1)) : createCommentVNode("", true)
              ])
            ]),
            createBaseVNode("div", _hoisted_21$4, [
              !imagePreview.value ? (openBlock(), createElementBlock("p", _hoisted_22$4, toDisplayString$1(unref(t)("vocabulary.image.copy.noImage", "No image to copy. Please upload or load an image first.")), 1)) : (openBlock(), createElementBlock("div", _hoisted_23$4, [
                createBaseVNode("p", null, toDisplayString$1(unref(t)("vocabulary.image.copy.description", "Copy the current image to your clipboard as an actual image, not just the URL.")), 1),
                createBaseVNode("div", _hoisted_24$4, [
                  createBaseVNode("button", {
                    onClick: copyImageToClipboard,
                    type: "button",
                    class: "px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white rounded-lg transition-colors flex items-center space-x-2",
                    disabled: isProcessing.value
                  }, [
                    isProcessing.value ? (openBlock(), createElementBlock("svg", _hoisted_26$3, _cache[11] || (_cache[11] = [
                      createBaseVNode("circle", {
                        class: "opacity-25",
                        cx: "12",
                        cy: "12",
                        r: "10",
                        stroke: "currentColor",
                        "stroke-width": "4"
                      }, null, -1),
                      createBaseVNode("path", {
                        class: "opacity-75",
                        fill: "currentColor",
                        d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                      }, null, -1)
                    ]))) : (openBlock(), createElementBlock("svg", _hoisted_27$3, _cache[12] || (_cache[12] = [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M8 16h8M8 12h8m-9 8h10a2 2 0 002-2V6a2 2 0 00-2-2H9l-3 3v11a2 2 0 002 2z"
                      }, null, -1)
                    ]))),
                    createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.image.copy.button", "Copy image to clipboard")), 1)
                  ], 8, _hoisted_25$4),
                  copyStatus.value && copyStatus.value.type === "success" ? (openBlock(), createElementBlock("span", _hoisted_28$3, toDisplayString$1(copyStatus.value.message), 1)) : copyStatus.value && copyStatus.value.type === "warning" ? (openBlock(), createElementBlock("span", _hoisted_29$3, toDisplayString$1(copyStatus.value.message), 1)) : createCommentVNode("", true)
                ])
              ]))
            ])
          ])) : createCommentVNode("", true),
          imagePreview.value ? (openBlock(), createElementBlock("div", _hoisted_30$3, [
            createBaseVNode("div", _hoisted_31$3, [
              createBaseVNode("img", {
                src: imagePreview.value,
                alt: unref(t)("vocabulary.image.preview", "Image preview"),
                class: "w-full h-48 object-cover"
              }, null, 8, _hoisted_32$2)
            ]),
            createBaseVNode("div", _hoisted_33$2, [
              createBaseVNode("div", _hoisted_34$2, [
                inputMethod.value === "upload" ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  onClick: triggerFileInput,
                  type: "button",
                  class: "px-3 py-1 text-sm bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors flex items-center space-x-1"
                }, [
                  _cache[13] || (_cache[13] = createBaseVNode("svg", {
                    class: "w-4 h-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
                    })
                  ], -1)),
                  createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.image.changeFile", "Change Image")), 1)
                ])) : createCommentVNode("", true),
                inputMethod.value === "url" ? (openBlock(), createElementBlock("button", {
                  key: 1,
                  onClick: _cache[4] || (_cache[4] = ($event) => showUrlEdit.value = true),
                  type: "button",
                  class: "px-3 py-1 text-sm bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors flex items-center space-x-1"
                }, [
                  _cache[14] || (_cache[14] = createBaseVNode("svg", {
                    class: "w-4 h-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"
                    })
                  ], -1)),
                  createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.image.changeUrl", "Change URL")), 1)
                ])) : createCommentVNode("", true),
                createBaseVNode("button", {
                  onClick: removeImage,
                  type: "button",
                  class: "px-3 py-1 text-sm bg-red-600 hover:bg-red-700 text-white rounded-md transition-colors flex items-center space-x-1"
                }, [
                  _cache[15] || (_cache[15] = createBaseVNode("svg", {
                    class: "w-4 h-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                    })
                  ], -1)),
                  createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.image.remove", "Remove")), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_35$2, [
                imageInfo.value && inputMethod.value === "upload" ? (openBlock(), createElementBlock("div", _hoisted_36$2, toDisplayString$1(formatFileSize(imageInfo.value.size)), 1)) : createCommentVNode("", true),
                inputMethod.value === "url" ? (openBlock(), createElementBlock("div", _hoisted_37$1, toDisplayString$1(unref(t)("vocabulary.image.fromUrl", "From URL")), 1)) : createCommentVNode("", true)
              ])
            ])
          ])) : createCommentVNode("", true),
          showUrlEdit.value ? (openBlock(), createElementBlock("div", _hoisted_38$1, [
            createBaseVNode("div", _hoisted_39$1, [
              createBaseVNode("h3", _hoisted_40$1, toDisplayString$1(unref(t)("vocabulary.image.changeUrl", "Change URL")), 1),
              createBaseVNode("div", _hoisted_41, [
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => newImageUrl.value = $event),
                  onKeyup: withKeys(handleUrlChange, ["enter"]),
                  type: "url",
                  placeholder: unref(t)("vocabulary.image.urlPlaceholder", "Enter image URL"),
                  class: "w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
                }, null, 40, _hoisted_42), [
                  [vModelText, newImageUrl.value]
                ]),
                createBaseVNode("div", _hoisted_43, [
                  createBaseVNode("button", {
                    onClick: _cache[6] || (_cache[6] = ($event) => showUrlEdit.value = false),
                    type: "button",
                    class: "px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors"
                  }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                  createBaseVNode("button", {
                    onClick: handleUrlChange,
                    disabled: !newImageUrl.value.trim() || isProcessing.value,
                    type: "button",
                    class: "px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white rounded-lg transition-colors"
                  }, toDisplayString$1(isProcessing.value ? unref(t)("vocabulary.image.loading", "Loading...") : unref(t)("common.update", "Update")), 9, _hoisted_44)
                ])
              ])
            ])
          ])) : createCommentVNode("", true),
          isProcessing.value ? (openBlock(), createElementBlock("div", _hoisted_45, [
            createBaseVNode("div", _hoisted_46, [
              _cache[16] || (_cache[16] = createBaseVNode("svg", {
                class: "animate-spin w-5 h-5",
                fill: "none",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("circle", {
                  class: "opacity-25",
                  cx: "12",
                  cy: "12",
                  r: "10",
                  stroke: "currentColor",
                  "stroke-width": "4"
                }),
                createBaseVNode("path", {
                  class: "opacity-75",
                  fill: "currentColor",
                  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                })
              ], -1)),
              createBaseVNode("span", _hoisted_47, toDisplayString$1(unref(t)("vocabulary.image.processing", "Processing...")), 1)
            ])
          ])) : createCommentVNode("", true)
        ]),
        errorMessage.value ? (openBlock(), createElementBlock("div", _hoisted_48, [
          createBaseVNode("div", _hoisted_49, [
            _cache[17] || (_cache[17] = createBaseVNode("svg", {
              class: "w-5 h-5 text-red-500",
              fill: "none",
              stroke: "currentColor",
              viewBox: "0 0 24 24"
            }, [
              createBaseVNode("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              })
            ], -1)),
            createBaseVNode("span", _hoisted_50, toDisplayString$1(errorMessage.value), 1)
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const ImageUpload = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$a
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$9 = {
  key: 0,
  class: "fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-[60000] backdrop-blur-sm"
};
const _hoisted_2$7 = { class: "w-full max-w-2xl max-h-[90vh]" };
const _hoisted_3$6 = { class: "px-5 py-4 border-b border-gray-200 dark:border-dark-bg-mute bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-dark-bg-soft dark:to-dark-bg-soft flex items-center justify-between" };
const _hoisted_4$6 = { class: "text-lg font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_5$5 = ["title", "aria-label"];
const _hoisted_6$4 = { class: "px-5 py-4 border-b border-gray-200 dark:border-dark-bg-mute bg-white dark:bg-dark-bg-soft sticky top-0 z-10" };
const _hoisted_7$4 = { class: "relative mb-4" };
const _hoisted_8$4 = ["placeholder"];
const _hoisted_9$4 = { class: "p-3 rounded-lg border border-gray-200 dark:border-dark-bg-mute bg-white dark:bg-dark-bg-mute mb-4" };
const _hoisted_10$4 = { class: "text-2xl md:text-3xl font-mono text-gray-900 dark:text-white break-words min-h-[2.5rem]" };
const _hoisted_11$4 = { class: "flex flex-wrap gap-2" };
const _hoisted_12$4 = ["title", "aria-label"];
const _hoisted_13$4 = ["title", "aria-label"];
const _hoisted_14$4 = ["title", "aria-label"];
const _hoisted_15$3 = ["title", "aria-label"];
const _hoisted_16$3 = { class: "px-5 py-4 space-y-4 overflow-y-auto flex-1 min-h-0" };
const _hoisted_17$3 = { class: "space-y-4" };
const _hoisted_18$3 = { class: "text-sm font-medium text-gray-600 dark:text-white/70 mb-2 flex items-center" };
const _hoisted_19$3 = { class: "grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 gap-2" };
const _hoisted_20$3 = ["onClick", "title"];
const _hoisted_21$3 = { class: "font-bold text-base" };
const _hoisted_22$3 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_23$3 = ["onClick", "title"];
const _hoisted_24$3 = { class: "text-sm font-medium text-gray-600 dark:text-white/70 mb-2 flex items-center" };
const _hoisted_25$3 = { class: "grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-2" };
const _hoisted_26$2 = ["onClick", "title"];
const _hoisted_27$2 = { class: "font-bold text-base" };
const _hoisted_28$2 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_29$2 = ["onClick", "title"];
const _hoisted_30$2 = { class: "pb-4" };
const _hoisted_31$2 = { class: "text-sm font-medium text-gray-600 dark:text-white/70 mb-2 flex items-center" };
const _hoisted_32$1 = { class: "grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 gap-2" };
const _hoisted_33$1 = ["onClick", "title"];
const _hoisted_34$1 = { class: "font-bold text-base" };
const _hoisted_35$1 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_36$1 = ["onClick", "title"];
const _hoisted_37 = { class: "px-5 py-4 border-t border-gray-200 dark:border-dark-bg-mute bg-white dark:bg-[#0a0a0a] sticky bottom-0 z-10" };
const _hoisted_38 = { class: "text-sm font-medium text-gray-600 dark:text-white/70 mb-2 flex items-center" };
const _hoisted_39 = { class: "flex flex-wrap gap-2" };
const _hoisted_40 = ["onClick"];
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "IpaPickerModal",
  props: {
    modelValue: { type: Boolean },
    initialValue: { default: "" }
  },
  emits: ["update:modelValue", "apply"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const { playAudio } = useVoiceStore();
    const ipaDraft = ref("");
    const searchQuery = ref("");
    const searchInputRef = ref(null);
    const IPA_VOWELS = [
      // Monophthongs (short/long where applicable)
      { symbol: "i", letter: "ee", description: 'Long "ee" sound as in "see"' },
      { symbol: "iː", letter: "ee", description: 'Long "ee" sound as in "see"' },
      { symbol: "ɪ", letter: "i", description: 'Short "i" sound as in "sit"' },
      { symbol: "e", letter: "e", description: '"e" sound as in "bed"' },
      { symbol: "ɛ", letter: "e", description: 'Open "e" sound as in "bet"' },
      { symbol: "æ", letter: "a", description: '"a" sound as in "cat"' },
      { symbol: "u", letter: "oo", description: 'Long "oo" sound as in "boot"' },
      { symbol: "uː", letter: "oo", description: 'Long "oo" sound as in "boot"' },
      { symbol: "ʊ", letter: "u", description: 'Short "u" sound as in "put"' },
      { symbol: "o", letter: "o", description: '"o" sound as in "go"' },
      { symbol: "ɔ", letter: "aw", description: '"aw" sound as in "saw"' },
      { symbol: "ɒ", letter: "o", description: 'Short "o" sound as in "lot"' },
      { symbol: "ɑ", letter: "a", description: '"a" sound as in "father"' },
      { symbol: "ʌ", letter: "u", description: '"u" sound as in "cup"' },
      { symbol: "ɜ", letter: "ur", description: '"ur" sound as in "bird"' },
      { symbol: "ɜː", letter: "ur", description: 'Long "ur" sound as in "bird"' },
      { symbol: "ɝ", letter: "er", description: 'R-colored "er" sound' },
      { symbol: "ɚ", letter: "er", description: 'Unstressed "er" sound' },
      { symbol: "ə", letter: "uh", description: 'Schwa - unstressed "uh" sound' }
    ];
    const IPA_DIPHTHONGS = [
      // Common diphthongs (BrE/AmE variants included)
      { symbol: "eɪ", letter: "ay", description: '"ay" sound as in "day"' },
      { symbol: "aɪ", letter: "i", description: '"i" sound as in "my"' },
      { symbol: "ɔɪ", letter: "oy", description: '"oy" sound as in "boy"' },
      { symbol: "aʊ", letter: "ow", description: '"ow" sound as in "now"' },
      { symbol: "əʊ", letter: "o", description: '"o" sound as in "go" (British)' },
      { symbol: "oʊ", letter: "o", description: '"o" sound as in "go" (American)' },
      { symbol: "ɪə", letter: "ear", description: '"ear" sound as in "near"' },
      { symbol: "eə", letter: "air", description: '"air" sound as in "hair"' },
      { symbol: "ʊə", letter: "oor", description: '"oor" sound as in "poor"' }
    ];
    const IPA_CONSONANTS = [
      // Plosives
      { symbol: "p", letter: "p", description: '"p" sound as in "pat"' },
      { symbol: "b", letter: "b", description: '"b" sound as in "bat"' },
      { symbol: "t", letter: "t", description: '"t" sound as in "tap"' },
      { symbol: "d", letter: "d", description: '"d" sound as in "day"' },
      { symbol: "k", letter: "k", description: '"k" sound as in "cat"' },
      { symbol: "g", letter: "g", description: '"g" sound as in "go"' },
      // Fricatives
      { symbol: "f", letter: "f", description: '"f" sound as in "fat"' },
      { symbol: "v", letter: "v", description: '"v" sound as in "vat"' },
      { symbol: "θ", letter: "th", description: 'Voiceless "th" as in "think"' },
      { symbol: "ð", letter: "th", description: 'Voiced "th" as in "this"' },
      { symbol: "s", letter: "s", description: '"s" sound as in "sat"' },
      { symbol: "z", letter: "z", description: '"z" sound as in "zoo"' },
      { symbol: "ʃ", letter: "sh", description: '"sh" sound as in "she"' },
      { symbol: "ʒ", letter: "zh", description: '"zh" sound as in "measure"' },
      { symbol: "h", letter: "h", description: '"h" sound as in "hat"' },
      // Affricates
      { symbol: "tʃ", letter: "ch", description: '"ch" sound as in "chair"' },
      { symbol: "dʒ", letter: "j", description: '"j" sound as in "jar"' },
      // Nasals
      { symbol: "m", letter: "m", description: '"m" sound as in "mat"' },
      { symbol: "n", letter: "n", description: '"n" sound as in "net"' },
      { symbol: "ŋ", letter: "ng", description: '"ng" sound as in "sing"' },
      // Liquids
      { symbol: "l", letter: "l", description: '"l" sound as in "let"' },
      { symbol: "ɫ", letter: "l", description: 'Dark "l" sound' },
      { symbol: "r", letter: "r", description: 'Rolled "r" sound' },
      { symbol: "ɹ", letter: "r", description: 'English "r" sound as in "red"' },
      // Glides
      { symbol: "w", letter: "w", description: '"w" sound as in "wet"' },
      { symbol: "j", letter: "y", description: '"y" sound as in "yes"' },
      // Other
      { symbol: "ʔ", letter: "'", description: "Glottal stop" },
      { symbol: "ɾ", letter: "t", description: 'Flap "t" as in "butter" (American)' },
      { symbol: "ʍ", letter: "wh", description: 'Voiceless "wh" as in "what"' }
    ];
    const IPA_MARKS = ["ˈ", "ˌ", "ː", ".", " "];
    const filteredVowels = computed(() => {
      if (!searchQuery.value) return IPA_VOWELS;
      const query = searchQuery.value.toLowerCase();
      return IPA_VOWELS.filter(
        (vowel) => vowel.symbol.includes(query) || vowel.letter.toLowerCase().includes(query) || vowel.description.toLowerCase().includes(query)
      );
    });
    const filteredDiphthongs = computed(() => {
      if (!searchQuery.value) return IPA_DIPHTHONGS;
      const query = searchQuery.value.toLowerCase();
      return IPA_DIPHTHONGS.filter(
        (diphthong) => diphthong.symbol.includes(query) || diphthong.letter.toLowerCase().includes(query) || diphthong.description.toLowerCase().includes(query)
      );
    });
    const filteredConsonants = computed(() => {
      if (!searchQuery.value) return IPA_CONSONANTS;
      const query = searchQuery.value.toLowerCase();
      return IPA_CONSONANTS.filter(
        (consonant) => consonant.symbol.includes(query) || consonant.letter.toLowerCase().includes(query) || consonant.description.toLowerCase().includes(query)
      );
    });
    watch(() => props.modelValue, async (isOpen) => {
      if (isOpen) {
        ipaDraft.value = props.initialValue || "";
        searchQuery.value = "";
        await nextTick();
        setTimeout(() => {
          focusSearchInput();
        }, 100);
      }
    });
    const closeModal = () => {
      emit("update:modelValue", false);
    };
    const focusSearchInput = () => {
      if (searchInputRef.value) {
        searchInputRef.value.focus();
      }
    };
    const refocusSearchInput = () => {
      setTimeout(() => {
        focusSearchInput();
      }, 50);
    };
    const appendIpa = (symbol) => {
      ipaDraft.value += symbol;
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const clearIpa = () => {
      ipaDraft.value = "";
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const backspaceIpa = () => {
      if (!ipaDraft.value) return;
      ipaDraft.value = ipaDraft.value.slice(0, -1);
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const wrapWithSlashes = () => {
      const trimmed = ipaDraft.value.trim();
      if (!trimmed) {
        ipaDraft.value = "/ /";
      } else {
        const alreadyWrapped = trimmed.startsWith("/") && trimmed.endsWith("/");
        ipaDraft.value = alreadyWrapped ? trimmed : `/${trimmed.replace(/^\/+|\/+$/g, "")}/`;
      }
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const applyIpa = () => {
      emit("apply", ipaDraft.value.trim());
      closeModal();
    };
    const speakIPA = async (symbol, event) => {
      event.stopPropagation();
      const ipaToWord = {
        // Vowels
        "i": "see",
        "iː": "see",
        "ɪ": "sit",
        "e": "bed",
        "ɛ": "bet",
        "æ": "cat",
        "u": "boot",
        "uː": "boot",
        "ʊ": "put",
        "o": "go",
        "ɔ": "saw",
        "ɒ": "lot",
        "ɑ": "father",
        "ʌ": "cup",
        "ɜ": "bird",
        "ɜː": "bird",
        "ɝ": "bird",
        "ɚ": "butter",
        "ə": "about",
        // Diphthongs
        "eɪ": "day",
        "aɪ": "my",
        "ɔɪ": "boy",
        "aʊ": "now",
        "əʊ": "go",
        "oʊ": "go",
        "ɪə": "near",
        "eə": "hair",
        "ʊə": "poor",
        // Consonants
        "p": "pat",
        "b": "bat",
        "t": "tap",
        "d": "day",
        "k": "cat",
        "g": "go",
        "f": "fat",
        "v": "vat",
        "θ": "think",
        "ð": "this",
        "s": "sat",
        "z": "zoo",
        "ʃ": "she",
        "ʒ": "measure",
        "h": "hat",
        "tʃ": "chair",
        "dʒ": "jar",
        "m": "mat",
        "n": "net",
        "ŋ": "sing",
        "l": "let",
        "ɫ": "call",
        "r": "red",
        "ɹ": "red",
        "w": "wet",
        "j": "yes",
        "ʔ": "button",
        "ɾ": "butter",
        "ʍ": "what"
      };
      const textToSpeak = ipaToWord[symbol] || symbol;
      try {
        await playAudio(textToSpeak);
      } catch (error) {
        console.warn("Failed to play IPA pronunciation:", error);
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$9, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$7, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-dark-bg-soft shadow-2xl rounded-xl border border-gray-200 dark:border-dark-bg-mute overflow-hidden transform flex flex-col max-h-[90vh]",
                      onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$6, [
                        createBaseVNode("h3", _hoisted_4$6, [
                          _cache[2] || (_cache[2] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                          createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.pronunciation.ipaPickerTitle", "IPA Picker")), 1)
                        ]),
                        createBaseVNode("button", {
                          type: "button",
                          onClick: closeModal,
                          class: "text-gray-400 hover:text-gray-600 dark:hover:text-white transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-dark-bg-mute",
                          title: unref(t)("common.close", "Close"),
                          "aria-label": unref(t)("common.close", "Close")
                        }, _cache[3] || (_cache[3] = [
                          createBaseVNode("svg", {
                            class: "w-6 h-6",
                            fill: "none",
                            stroke: "currentColor",
                            viewBox: "0 0 24 24"
                          }, [
                            createBaseVNode("path", {
                              "stroke-linecap": "round",
                              "stroke-linejoin": "round",
                              "stroke-width": "2",
                              d: "M6 18L18 6M6 6l12 12"
                            })
                          ], -1)
                        ]), 8, _hoisted_5$5)
                      ]),
                      createBaseVNode("div", _hoisted_6$4, [
                        createBaseVNode("div", _hoisted_7$4, [
                          _cache[4] || (_cache[4] = createBaseVNode("div", { class: "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none" }, [
                            createBaseVNode("svg", {
                              class: "h-5 w-5 text-gray-400",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                              })
                            ])
                          ], -1)),
                          withDirectives(createBaseVNode("input", {
                            ref_key: "searchInputRef",
                            ref: searchInputRef,
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
                            type: "text",
                            class: "block w-full pl-10 pr-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-dark-bg-mute dark:text-white",
                            placeholder: unref(t)("common.search", "Search IPA symbols..."),
                            onBlur: refocusSearchInput
                          }, null, 40, _hoisted_8$4), [
                            [vModelText, searchQuery.value]
                          ])
                        ]),
                        createBaseVNode("div", _hoisted_9$4, [
                          createBaseVNode("div", _hoisted_10$4, toDisplayString$1(ipaDraft.value || unref(t)("vocabulary.pronunciation.previewPlaceholder", "Start building IPA...")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_11$4, [
                          createBaseVNode("button", {
                            type: "button",
                            onClick: wrapWithSlashes,
                            class: "px-3 py-1.5 rounded-lg border border-gray-300 dark:border-dark-bg-mute text-gray-800 dark:text-white dark:bg-dark-bg-mute hover:bg-gray-100 dark:hover:bg-dark-bg-soft",
                            title: unref(t)("vocabulary.pronunciation.wrap", "Wrap with slashes"),
                            "aria-label": unref(t)("vocabulary.pronunciation.wrap", "Wrap with slashes")
                          }, " /.../ ", 8, _hoisted_12$4),
                          createBaseVNode("button", {
                            type: "button",
                            onClick: backspaceIpa,
                            class: "px-3 py-1.5 rounded-lg border border-gray-300 dark:border-dark-bg-mute text-gray-800 dark:text-white dark:bg-dark-bg-mute hover:bg-gray-100 dark:hover:bg-dark-bg-soft",
                            title: unref(t)("common.backspace", "Backspace"),
                            "aria-label": unref(t)("common.backspace", "Backspace")
                          }, toDisplayString$1(unref(t)("common.backspace", "Backspace")), 9, _hoisted_13$4),
                          createBaseVNode("button", {
                            type: "button",
                            onClick: clearIpa,
                            class: "px-3 py-1.5 rounded-lg border border-gray-300 dark:border-dark-bg-mute text-gray-800 dark:text-white dark:bg-dark-bg-mute hover:bg-gray-100 dark:hover:bg-dark-bg-soft",
                            title: unref(t)("common.clear", "Clear"),
                            "aria-label": unref(t)("common.clear", "Clear")
                          }, toDisplayString$1(unref(t)("common.clear", "Clear")), 9, _hoisted_14$4),
                          createBaseVNode("button", {
                            type: "button",
                            onClick: applyIpa,
                            class: "ml-auto px-3 py-1.5 rounded-lg bg-green-600 hover:bg-green-700 text-white",
                            title: unref(t)("common.apply", "Apply"),
                            "aria-label": unref(t)("common.apply", "Apply")
                          }, toDisplayString$1(unref(t)("common.apply", "Apply")), 9, _hoisted_15$3)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_16$3, [
                        createBaseVNode("div", _hoisted_17$3, [
                          createBaseVNode("div", null, [
                            createBaseVNode("div", _hoisted_18$3, [
                              _cache[5] || (_cache[5] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.pronunciation.vowels", "Vowels")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_19$3, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredVowels.value, (vowel) => {
                                return openBlock(), createElementBlock("div", {
                                  key: "v-" + vowel.symbol,
                                  class: "relative"
                                }, [
                                  createBaseVNode("button", {
                                    type: "button",
                                    onClick: ($event) => appendIpa(vowel.symbol),
                                    class: "w-full p-2 bg-blue-100 hover:bg-blue-200 dark:bg-blue-900 dark:hover:bg-blue-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm border border-gray-300 dark:border-dark-bg-mute",
                                    title: vowel.description
                                  }, [
                                    createBaseVNode("span", _hoisted_21$3, toDisplayString$1(vowel.symbol), 1),
                                    createBaseVNode("span", _hoisted_22$3, toDisplayString$1(vowel.letter), 1)
                                  ], 8, _hoisted_20$3),
                                  createBaseVNode("button", {
                                    type: "button",
                                    onClick: ($event) => speakIPA(vowel.symbol, $event),
                                    class: "absolute -top-1 -right-1 w-5 h-5 bg-green-500 hover:bg-green-600 text-white rounded-full flex items-center justify-center text-xs transition-all duration-200 hover:scale-110 shadow-md",
                                    title: `Pronounce ${vowel.symbol}`
                                  }, _cache[6] || (_cache[6] = [
                                    createBaseVNode("svg", {
                                      class: "w-3 h-3",
                                      fill: "currentColor",
                                      viewBox: "0 0 20 20"
                                    }, [
                                      createBaseVNode("path", {
                                        "fill-rule": "evenodd",
                                        d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.824L4.8 13.6H2a1 1 0 01-1-1V7.4a1 1 0 011-1h2.8l3.583-3.224a1 1 0 01.617-.176zM12 5a1 1 0 011.414 0L15 6.586l1.586-1.586a1 1 0 111.414 1.414L16.414 8 18 9.586a1 1 0 01-1.414 1.414L15 9.414 13.414 11A1 1 0 0112 9.586L13.586 8 12 6.414A1 1 0 0112 5z",
                                        "clip-rule": "evenodd"
                                      })
                                    ], -1)
                                  ]), 8, _hoisted_23$3)
                                ]);
                              }), 128))
                            ])
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("div", _hoisted_24$3, [
                              _cache[7] || (_cache[7] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.pronunciation.diphthongs", "Diphthongs")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_25$3, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredDiphthongs.value, (diphthong) => {
                                return openBlock(), createElementBlock("div", {
                                  key: "d-" + diphthong.symbol,
                                  class: "relative"
                                }, [
                                  createBaseVNode("button", {
                                    type: "button",
                                    onClick: ($event) => appendIpa(diphthong.symbol),
                                    class: "w-full p-2 bg-green-100 hover:bg-green-200 dark:bg-green-900 dark:hover:bg-green-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm border border-gray-300 dark:border-dark-bg-mute",
                                    title: diphthong.description
                                  }, [
                                    createBaseVNode("span", _hoisted_27$2, toDisplayString$1(diphthong.symbol), 1),
                                    createBaseVNode("span", _hoisted_28$2, toDisplayString$1(diphthong.letter), 1)
                                  ], 8, _hoisted_26$2),
                                  createBaseVNode("button", {
                                    type: "button",
                                    onClick: ($event) => speakIPA(diphthong.symbol, $event),
                                    class: "absolute -top-1 -right-1 w-5 h-5 bg-green-500 hover:bg-green-600 text-white rounded-full flex items-center justify-center text-xs transition-all duration-200 hover:scale-110 shadow-md",
                                    title: `Pronounce ${diphthong.symbol}`
                                  }, _cache[8] || (_cache[8] = [
                                    createBaseVNode("svg", {
                                      class: "w-3 h-3",
                                      fill: "currentColor",
                                      viewBox: "0 0 20 20"
                                    }, [
                                      createBaseVNode("path", {
                                        "fill-rule": "evenodd",
                                        d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.824L4.8 13.6H2a1 1 0 01-1-1V7.4a1 1 0 011-1h2.8l3.583-3.224a1 1 0 01.617-.176zM12 5a1 1 0 011.414 0L15 6.586l1.586-1.586a1 1 0 111.414 1.414L16.414 8 18 9.586a1 1 0 01-1.414 1.414L15 9.414 13.414 11A1 1 0 0112 9.586L13.586 8 12 6.414A1 1 0 0112 5z",
                                        "clip-rule": "evenodd"
                                      })
                                    ], -1)
                                  ]), 8, _hoisted_29$2)
                                ]);
                              }), 128))
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_30$2, [
                            createBaseVNode("div", _hoisted_31$2, [
                              _cache[9] || (_cache[9] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.pronunciation.consonants", "Consonants")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_32$1, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredConsonants.value, (consonant) => {
                                return openBlock(), createElementBlock("div", {
                                  key: "c-" + consonant.symbol,
                                  class: "relative"
                                }, [
                                  createBaseVNode("button", {
                                    type: "button",
                                    onClick: ($event) => appendIpa(consonant.symbol),
                                    class: "w-full p-2 bg-purple-100 hover:bg-purple-200 dark:bg-purple-900 dark:hover:bg-purple-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm border border-gray-300 dark:border-dark-bg-mute",
                                    title: consonant.description
                                  }, [
                                    createBaseVNode("span", _hoisted_34$1, toDisplayString$1(consonant.symbol), 1),
                                    createBaseVNode("span", _hoisted_35$1, toDisplayString$1(consonant.letter), 1)
                                  ], 8, _hoisted_33$1),
                                  createBaseVNode("button", {
                                    type: "button",
                                    onClick: ($event) => speakIPA(consonant.symbol, $event),
                                    class: "absolute -top-1 -right-1 w-5 h-5 bg-green-500 hover:bg-green-600 text-white rounded-full flex items-center justify-center text-xs transition-all duration-200 hover:scale-110 shadow-md",
                                    title: `Pronounce ${consonant.symbol}`
                                  }, _cache[10] || (_cache[10] = [
                                    createBaseVNode("svg", {
                                      class: "w-3 h-3",
                                      fill: "currentColor",
                                      viewBox: "0 0 20 20"
                                    }, [
                                      createBaseVNode("path", {
                                        "fill-rule": "evenodd",
                                        d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.824L4.8 13.6H2a1 1 0 01-1-1V7.4a1 1 0 011-1h2.8l3.583-3.224a1 1 0 01.617-.176zM12 5a1 1 0 011.414 0L15 6.586l1.586-1.586a1 1 0 111.414 1.414L16.414 8 18 9.586a1 1 0 01-1.414 1.414L15 9.414 13.414 11A1 1 0 0112 9.586L13.586 8 12 6.414A1 1 0 0112 5z",
                                        "clip-rule": "evenodd"
                                      })
                                    ], -1)
                                  ]), 8, _hoisted_36$1)
                                ]);
                              }), 128))
                            ])
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_37, [
                        createBaseVNode("div", _hoisted_38, [
                          _cache[11] || (_cache[11] = createBaseVNode("span", { class: "w-1 h-4 bg-orange-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.pronunciation.marks", "Marks")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_39, [
                          (openBlock(), createElementBlock(Fragment, null, renderList(IPA_MARKS, (mark) => {
                            return createBaseVNode("button", {
                              key: "m-" + mark,
                              type: "button",
                              onClick: ($event) => appendIpa(mark),
                              class: "px-3 py-2 bg-orange-100 hover:bg-orange-200 dark:bg-orange-900 dark:hover:bg-orange-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 border border-gray-300 dark:border-dark-bg-mute font-mono"
                            }, toDisplayString$1(mark === " " ? unref(t)("common.space", "Space") : mark), 9, _hoisted_40);
                          }), 64))
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const IpaPickerModal = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$9
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$8 = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$6 = { class: "w-full max-h-[90vh] flex flex-col max-w-full sm:max-w-lg md:max-w-2xl lg:max-w-4xl" };
const _hoisted_3$5 = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$5 = { class: "flex items-center justify-between" };
const _hoisted_5$4 = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$3 = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 bg-white dark:bg-[#0a0a0a] sticky top-0 z-10" };
const _hoisted_7$3 = { class: "relative mb-4" };
const _hoisted_8$3 = ["placeholder"];
const _hoisted_9$3 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_10$3 = { class: "relative" };
const _hoisted_11$3 = ["placeholder"];
const _hoisted_12$3 = ["title"];
const _hoisted_13$3 = ["title"];
const _hoisted_14$3 = { class: "px-6 py-4 flex-1 overflow-y-auto min-h-0" };
const _hoisted_15$2 = { class: "space-y-6" };
const _hoisted_16$2 = { class: "text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center" };
const _hoisted_17$2 = { class: "grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-2" };
const _hoisted_18$2 = ["onClick", "title"];
const _hoisted_19$2 = { class: "font-bold text-base" };
const _hoisted_20$2 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_21$2 = { class: "text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center" };
const _hoisted_22$2 = { class: "grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-2" };
const _hoisted_23$2 = ["onClick", "title"];
const _hoisted_24$2 = { class: "font-bold text-base" };
const _hoisted_25$2 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_26$1 = { class: "text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center" };
const _hoisted_27$1 = { class: "grid grid-cols-6 sm:grid-cols-8 md:grid-cols-10 gap-2" };
const _hoisted_28$1 = ["onClick"];
const _hoisted_29$1 = { class: "px-6 py-4 border-t border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gray-50 dark:bg-[#0a0a0a]" };
const _hoisted_30$1 = { class: "flex justify-between items-center space-x-3" };
const _hoisted_31$1 = { class: "flex space-x-3" };
const HANGEUL_START = 44032;
const JUNGSUNG_COUNT = 21;
const JONGSUNG_COUNT = 28;
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "KoreanInputHelper",
  props: {
    modelValue: { type: Boolean },
    initialValue: { default: "" }
  },
  emits: ["update:modelValue", "input-confirmed"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const currentInput = ref("");
    const searchQuery = ref("");
    const searchInputRef = ref(null);
    const koreanConsonants = [
      { char: "ㄱ", romanization: "g/k", description: "g as in go, k as in sky" },
      { char: "ㄴ", romanization: "n", description: "n as in no" },
      { char: "ㄷ", romanization: "d/t", description: "d as in do, t as in stop" },
      { char: "ㄹ", romanization: "r/l", description: "r as in run, l as in love" },
      { char: "ㅁ", romanization: "m", description: "m as in moon" },
      { char: "ㅂ", romanization: "b/p", description: "b as in boy, p as in spy" },
      { char: "ㅅ", romanization: "s", description: "s as in see" },
      { char: "ㅇ", romanization: "ng", description: "ng as in sing (silent at start)" },
      { char: "ㅈ", romanization: "j", description: "j as in jump" },
      { char: "ㅊ", romanization: "ch", description: "ch as in chair" },
      { char: "ㅋ", romanization: "k", description: "k as in key" },
      { char: "ㅌ", romanization: "t", description: "t as in top" },
      { char: "ㅍ", romanization: "p", description: "p as in pie" },
      { char: "ㅎ", romanization: "h", description: "h as in home" },
      { char: "ㄲ", romanization: "kk", description: "stronger k sound" },
      { char: "ㄸ", romanization: "tt", description: "stronger t sound" },
      { char: "ㅃ", romanization: "pp", description: "stronger p sound" },
      { char: "ㅆ", romanization: "ss", description: "stronger s sound" },
      { char: "ㅉ", romanization: "jj", description: "stronger j sound" }
    ];
    const koreanVowels = [
      { char: "ㅏ", romanization: "a", description: "a as in father" },
      { char: "ㅑ", romanization: "ya", description: "ya as in yard" },
      { char: "ㅓ", romanization: "eo", description: "uh as in up" },
      { char: "ㅕ", romanization: "yeo", description: "yuh sound" },
      { char: "ㅗ", romanization: "o", description: "o as in go" },
      { char: "ㅛ", romanization: "yo", description: "yo as in yo-yo" },
      { char: "ㅜ", romanization: "u", description: "u as in moon" },
      { char: "ㅠ", romanization: "yu", description: "yu as in you" },
      { char: "ㅡ", romanization: "eu", description: "uh sound (lips spread)" },
      { char: "ㅣ", romanization: "i", description: "i as in machine" },
      { char: "ㅐ", romanization: "ae", description: "ae as in cat" },
      { char: "ㅒ", romanization: "yae", description: "yae sound" },
      { char: "ㅔ", romanization: "e", description: "e as in red" },
      { char: "ㅖ", romanization: "ye", description: "ye as in yes" },
      { char: "ㅘ", romanization: "wa", description: "wa as in water" },
      { char: "ㅙ", romanization: "wae", description: "wae sound" },
      { char: "ㅚ", romanization: "oe", description: "we sound" },
      { char: "ㅝ", romanization: "wo", description: "wo sound" },
      { char: "ㅞ", romanization: "we", description: "we sound" },
      { char: "ㅟ", romanization: "wi", description: "wi as in we" },
      { char: "ㅢ", romanization: "ui", description: "ui sound" }
    ];
    const commonKoreanSyllables = [
      // Basic syllables (기본 음절)
      "가",
      "나",
      "다",
      "라",
      "마",
      "바",
      "사",
      "아",
      "자",
      "차",
      "카",
      "타",
      "파",
      "하",
      // Common particles & endings (조사 및 어미)
      "은",
      "을",
      "이",
      "가",
      "의",
      "에",
      "로",
      "와",
      "과",
      "나",
      "도",
      "만",
      "부터",
      "까지",
      // Frequent syllables (자주 쓰이는 음절)
      "고",
      "수",
      "한",
      "그",
      "요",
      "지",
      "시",
      "인",
      "대",
      "중",
      "모",
      "서",
      "있",
      "있다",
      // Common verbs/adjectives (동사/형용사)
      "하다",
      "되다",
      "있다",
      "없다",
      "같다",
      "다르다",
      "좋다",
      "나쁘다",
      "크다",
      "작다",
      // Common nouns (명사)
      "사람",
      "시간",
      "일",
      "날",
      "년",
      "월",
      "주",
      "분",
      "초",
      "때",
      "곳",
      "것",
      "말",
      "글",
      // Common adverbs (부사)
      "정말",
      "진짜",
      "아주",
      "매우",
      "너무",
      "조금",
      "많이",
      "잘",
      "못",
      "안",
      "또",
      "다시",
      // Numbers (숫자)
      "일",
      "이",
      "삼",
      "사",
      "오",
      "육",
      "칠",
      "팔",
      "구",
      "십",
      "백",
      "천",
      "만"
    ];
    const chosungMap = ["ㄱ", "ㄲ", "ㄴ", "ㄷ", "ㄸ", "ㄹ", "ㅁ", "ㅂ", "ㅃ", "ㅅ", "ㅆ", "ㅇ", "ㅈ", "ㅉ", "ㅊ", "ㅋ", "ㅌ", "ㅍ", "ㅎ"];
    const jungsungMap = ["ㅏ", "ㅐ", "ㅑ", "ㅒ", "ㅓ", "ㅔ", "ㅕ", "ㅖ", "ㅗ", "ㅘ", "ㅙ", "ㅚ", "ㅛ", "ㅜ", "ㅝ", "ㅞ", "ㅟ", "ㅠ", "ㅡ", "ㅢ", "ㅣ"];
    const jongsungMap = ["", "ㄱ", "ㄲ", "ㄳ", "ㄴ", "ㄵ", "ㄶ", "ㄷ", "ㄹ", "ㄺ", "ㄻ", "ㄼ", "ㄽ", "ㄾ", "ㄿ", "ㅀ", "ㅁ", "ㅂ", "ㅄ", "ㅅ", "ㅆ", "ㅇ", "ㅈ", "ㅊ", "ㅋ", "ㅌ", "ㅍ", "ㅎ"];
    const isConsonant = (char) => {
      const code = char.charCodeAt(0);
      return code >= 12593 && code <= 12622;
    };
    const isVowel = (char) => {
      const code = char.charCodeAt(0);
      return code >= 12623 && code <= 12643;
    };
    const isSyllable = (char) => {
      const code = char.charCodeAt(0);
      return code >= 44032 && code <= 55203;
    };
    const decomposeSyllable = (syllable) => {
      const code = syllable.charCodeAt(0) - HANGEUL_START;
      const chosung = Math.floor(code / (JUNGSUNG_COUNT * JONGSUNG_COUNT));
      const jungsung = Math.floor(code % (JUNGSUNG_COUNT * JONGSUNG_COUNT) / JONGSUNG_COUNT);
      const jongsung = code % JONGSUNG_COUNT;
      return {
        chosung: chosungMap[chosung],
        jungsung: jungsungMap[jungsung],
        jongsung: jongsung > 0 ? jongsungMap[jongsung] : ""
      };
    };
    const composeSyllable = (chosung, jungsung, jongsung = "") => {
      const chosungIndex = chosungMap.indexOf(chosung);
      const jungsungIndex = jungsungMap.indexOf(jungsung);
      const jongsungIndex = jongsung ? jongsungMap.indexOf(jongsung) : 0;
      if (chosungIndex === -1 || jungsungIndex === -1 || jongsungIndex === -1) {
        return null;
      }
      const syllableCode = HANGEUL_START + chosungIndex * JUNGSUNG_COUNT * JONGSUNG_COUNT + jungsungIndex * JONGSUNG_COUNT + jongsungIndex;
      return String.fromCharCode(syllableCode);
    };
    const focusSearchInput = () => {
      if (searchInputRef.value) {
        searchInputRef.value.focus();
      }
    };
    const refocusSearchInput = () => {
      setTimeout(() => {
        focusSearchInput();
      }, 50);
    };
    const addCharacter = (character) => {
      const currentText = currentInput.value;
      if (isConsonant(character) || isVowel(character)) {
        const lastChar = currentText.slice(-1);
        if (lastChar && isSyllable(lastChar)) {
          const decomposed = decomposeSyllable(lastChar);
          if (isVowel(character) && decomposed.chosung && !decomposed.jungsung) {
            const newSyllable = composeSyllable(decomposed.chosung, character);
            if (newSyllable) {
              currentInput.value = currentText.slice(0, -1) + newSyllable;
              return;
            }
          } else if (isConsonant(character) && decomposed.chosung && decomposed.jungsung && !decomposed.jongsung) {
            const newSyllable = composeSyllable(decomposed.chosung, decomposed.jungsung, character);
            if (newSyllable) {
              currentInput.value = currentText.slice(0, -1) + newSyllable;
              return;
            }
          }
        } else if (lastChar && isConsonant(lastChar) && isVowel(character)) {
          const newSyllable = composeSyllable(lastChar, character);
          if (newSyllable) {
            currentInput.value = currentText.slice(0, -1) + newSyllable;
            return;
          }
        }
      }
      currentInput.value += character;
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const clearInput = () => {
      currentInput.value = "";
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const backspaceInput = () => {
      if (currentInput.value.length === 0) return;
      const currentText = currentInput.value;
      const lastChar = currentText.slice(-1);
      if (isSyllable(lastChar)) {
        const decomposed = decomposeSyllable(lastChar);
        if (decomposed.jongsung) {
          const newSyllable = composeSyllable(decomposed.chosung, decomposed.jungsung);
          if (newSyllable) {
            currentInput.value = currentText.slice(0, -1) + newSyllable;
            return;
          }
        } else if (decomposed.jungsung) {
          currentInput.value = currentText.slice(0, -1) + decomposed.chosung;
          return;
        }
      }
      currentInput.value = currentText.slice(0, -1);
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const closeDialog = () => {
      emit("update:modelValue", false);
    };
    const confirmInput = () => {
      emit("input-confirmed", currentInput.value);
      emit("update:modelValue", false);
    };
    const filteredConsonants = computed(() => {
      if (!searchQuery.value) return koreanConsonants;
      const query = searchQuery.value.toLowerCase();
      return koreanConsonants.filter(
        (consonant) => consonant.char.includes(query) || consonant.romanization.toLowerCase().includes(query) || consonant.description.toLowerCase().includes(query)
      );
    });
    const filteredVowels = computed(() => {
      if (!searchQuery.value) return koreanVowels;
      const query = searchQuery.value.toLowerCase();
      return koreanVowels.filter(
        (vowel) => vowel.char.includes(query) || vowel.romanization.toLowerCase().includes(query) || vowel.description.toLowerCase().includes(query)
      );
    });
    const filteredCommonSyllables = computed(() => {
      if (!searchQuery.value) return commonKoreanSyllables;
      const query = searchQuery.value.toLowerCase();
      return commonKoreanSyllables.filter((syllable) => syllable.includes(query));
    });
    watch(() => props.initialValue, (newValue) => {
      if (newValue !== void 0) {
        currentInput.value = newValue;
      }
    });
    watch(() => props.modelValue, async (isOpen) => {
      if (isOpen) {
        currentInput.value = props.initialValue || "";
        searchQuery.value = "";
        await nextTick();
        setTimeout(() => {
          focusSearchInput();
        }, 100);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$8, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$6, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 flex flex-col h-full overflow-hidden transform",
                      onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$5, [
                        createBaseVNode("div", _hoisted_4$5, [
                          createBaseVNode("h2", _hoisted_5$4, [
                            _cache[3] || (_cache[3] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("korean.inputHelper.title", "Korean Input Helper")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: closeDialog,
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[4] || (_cache[4] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_6$3, [
                        createBaseVNode("div", _hoisted_7$3, [
                          _cache[5] || (_cache[5] = createBaseVNode("div", { class: "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none" }, [
                            createBaseVNode("svg", {
                              class: "h-5 w-5 text-gray-400",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                              })
                            ])
                          ], -1)),
                          withDirectives(createBaseVNode("input", {
                            ref_key: "searchInputRef",
                            ref: searchInputRef,
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
                            type: "text",
                            class: "block w-full pl-10 pr-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-dark-bg-mute dark:text-white",
                            placeholder: unref(t)("common.search", "Search Korean characters..."),
                            onBlur: refocusSearchInput
                          }, null, 40, _hoisted_8$3), [
                            [vModelText, searchQuery.value]
                          ])
                        ]),
                        createBaseVNode("div", null, [
                          createBaseVNode("label", _hoisted_9$3, [
                            _cache[6] || (_cache[6] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                            createTextVNode(" " + toDisplayString$1(unref(t)("korean.inputHelper.preview", "Preview")), 1)
                          ]),
                          createBaseVNode("div", _hoisted_10$3, [
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => currentInput.value = $event),
                              type: "text",
                              class: "w-full px-3 py-2 pr-20 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 text-lg",
                              placeholder: unref(t)("korean.inputHelper.placeholder", "Type or click characters below..."),
                              readonly: ""
                            }, null, 8, _hoisted_11$3), [
                              [vModelText, currentInput.value]
                            ]),
                            currentInput.value ? (openBlock(), createElementBlock("button", {
                              key: 0,
                              onClick: backspaceInput,
                              class: "absolute right-12 top-1/2 -translate-y-1/2 w-8 h-6 bg-orange-500 hover:bg-orange-600 text-white rounded flex items-center justify-center text-xs font-bold transition-all duration-300 hover:scale-110",
                              title: unref(t)("common.backspace", "Backspace")
                            }, " ⌫ ", 8, _hoisted_12$3)) : createCommentVNode("", true),
                            currentInput.value ? (openBlock(), createElementBlock("button", {
                              key: 1,
                              onClick: clearInput,
                              class: "absolute right-2 top-1/2 -translate-y-1/2 w-6 h-6 bg-red-500 hover:bg-red-600 text-white rounded-full flex items-center justify-center text-xs font-bold transition-all duration-300 hover:scale-110",
                              title: unref(t)("common.clear", "Clear")
                            }, " × ", 8, _hoisted_13$3)) : createCommentVNode("", true)
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_14$3, [
                        createBaseVNode("div", _hoisted_15$2, [
                          createBaseVNode("div", null, [
                            createBaseVNode("h3", _hoisted_16$2, [
                              _cache[7] || (_cache[7] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("korean.inputHelper.consonants", "Consonants (자음)")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_17$2, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredConsonants.value, (consonant) => {
                                return openBlock(), createElementBlock("button", {
                                  key: consonant.char,
                                  onClick: ($event) => addCharacter(consonant.char),
                                  class: "p-2 bg-blue-100 hover:bg-blue-200 dark:bg-blue-900 dark:hover:bg-blue-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm",
                                  title: consonant.description
                                }, [
                                  createBaseVNode("span", _hoisted_19$2, toDisplayString$1(consonant.char), 1),
                                  createBaseVNode("span", _hoisted_20$2, toDisplayString$1(consonant.romanization), 1)
                                ], 8, _hoisted_18$2);
                              }), 128))
                            ])
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("h3", _hoisted_21$2, [
                              _cache[8] || (_cache[8] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("korean.inputHelper.vowels", "Vowels (모음)")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_22$2, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredVowels.value, (vowel) => {
                                return openBlock(), createElementBlock("button", {
                                  key: vowel.char,
                                  onClick: ($event) => addCharacter(vowel.char),
                                  class: "p-2 bg-green-100 hover:bg-green-200 dark:bg-green-900 dark:hover:bg-green-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm",
                                  title: vowel.description
                                }, [
                                  createBaseVNode("span", _hoisted_24$2, toDisplayString$1(vowel.char), 1),
                                  createBaseVNode("span", _hoisted_25$2, toDisplayString$1(vowel.romanization), 1)
                                ], 8, _hoisted_23$2);
                              }), 128))
                            ])
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("h3", _hoisted_26$1, [
                              _cache[9] || (_cache[9] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("korean.inputHelper.commonSyllables", "Common Syllables")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_27$1, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredCommonSyllables.value, (syllable) => {
                                return openBlock(), createElementBlock("button", {
                                  key: syllable,
                                  onClick: ($event) => addCharacter(syllable),
                                  class: "px-3 py-2 bg-purple-100 hover:bg-purple-200 dark:bg-purple-900 dark:hover:bg-purple-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 font-medium"
                                }, toDisplayString$1(syllable), 9, _hoisted_28$1);
                              }), 128))
                            ])
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_29$1, [
                        createBaseVNode("div", _hoisted_30$1, [
                          createBaseVNode("button", {
                            type: "button",
                            onClick: clearInput,
                            class: "px-4 py-2 text-sm font-medium text-gray-600 dark:text-gray-400 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition-all duration-300 hover:scale-105"
                          }, toDisplayString$1(unref(t)("common.clear", "Clear")), 1),
                          createBaseVNode("div", _hoisted_31$1, [
                            createBaseVNode("button", {
                              type: "button",
                              onClick: closeDialog,
                              class: "px-4 py-2 text-sm font-medium text-gray-600 dark:text-gray-400 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition-all duration-300 hover:scale-105"
                            }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                            createBaseVNode("button", {
                              type: "button",
                              onClick: confirmInput,
                              class: "px-4 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-lg transition-all duration-300 hover:scale-105 shadow-lg"
                            }, toDisplayString$1(unref(t)("common.confirm", "Confirm")), 1)
                          ])
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const KoreanInputHelper = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$8
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$7 = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$5 = { class: "w-full max-h-[90vh] flex flex-col max-w-full sm:max-w-lg md:max-w-2xl lg:max-w-4xl" };
const _hoisted_3$4 = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-green-50 to-emerald-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$4 = { class: "flex items-center justify-between" };
const _hoisted_5$3 = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$2 = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 bg-white dark:bg-[#0a0a0a] sticky top-0 z-10" };
const _hoisted_7$2 = { class: "relative mb-4" };
const _hoisted_8$2 = ["placeholder"];
const _hoisted_9$2 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_10$2 = { class: "relative" };
const _hoisted_11$2 = ["placeholder"];
const _hoisted_12$2 = ["title"];
const _hoisted_13$2 = ["title"];
const _hoisted_14$2 = { class: "px-6 py-4 flex-1 overflow-y-auto min-h-0" };
const _hoisted_15$1 = { class: "space-y-6" };
const _hoisted_16$1 = { class: "text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center" };
const _hoisted_17$1 = { class: "grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-2" };
const _hoisted_18$1 = ["onClick", "title"];
const _hoisted_19$1 = { class: "font-bold" };
const _hoisted_20$1 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_21$1 = { class: "text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center" };
const _hoisted_22$1 = { class: "grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-2" };
const _hoisted_23$1 = ["onClick", "title"];
const _hoisted_24$1 = { class: "font-bold" };
const _hoisted_25$1 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_26 = { class: "text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center" };
const _hoisted_27 = { class: "grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 gap-2" };
const _hoisted_28 = ["onClick", "title"];
const _hoisted_29 = { class: "font-bold" };
const _hoisted_30 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_31 = { class: "text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center" };
const _hoisted_32 = { class: "flex flex-wrap gap-2" };
const _hoisted_33 = ["onClick", "title"];
const _hoisted_34 = { class: "px-6 py-4 border-t border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gray-50 dark:bg-[#0a0a0a]" };
const _hoisted_35 = { class: "flex justify-between items-center space-x-3" };
const _hoisted_36 = { class: "flex space-x-3" };
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "KoreanPronunciationHelper",
  props: {
    modelValue: { type: Boolean },
    initialValue: { default: "" }
  },
  emits: ["update:modelValue", "pronunciation-confirmed"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const currentPronunciation = ref("");
    const searchQuery = ref("");
    const searchInputRef = ref(null);
    const koreanConsonantSounds = [
      { korean: "ㄱ", romanization: "g/k", description: "g as in go, k as in sky" },
      { korean: "ㄴ", romanization: "n", description: "n as in no" },
      { korean: "ㄷ", romanization: "d/t", description: "d as in do, t as in stop" },
      { korean: "ㄹ", romanization: "r/l", description: "r as in run, l as in love" },
      { korean: "ㅁ", romanization: "m", description: "m as in moon" },
      { korean: "ㅂ", romanization: "b/p", description: "b as in boy, p as in spy" },
      { korean: "ㅅ", romanization: "s", description: "s as in see" },
      { korean: "ㅇ", romanization: "ng", description: "ng as in sing" },
      { korean: "ㅈ", romanization: "j", description: "j as in jump" },
      { korean: "ㅊ", romanization: "ch", description: "ch as in chair" },
      { korean: "ㅋ", romanization: "k", description: "k as in key" },
      { korean: "ㅌ", romanization: "t", description: "t as in top" },
      { korean: "ㅍ", romanization: "p", description: "p as in pie" },
      { korean: "ㅎ", romanization: "h", description: "h as in home" },
      { korean: "ㄲ", romanization: "kk", description: "stronger k sound" },
      { korean: "ㄸ", romanization: "tt", description: "stronger t sound" },
      { korean: "ㅃ", romanization: "pp", description: "stronger p sound" },
      { korean: "ㅆ", romanization: "ss", description: "stronger s sound" },
      { korean: "ㅉ", romanization: "jj", description: "stronger j sound" }
    ];
    const koreanVowelSounds = [
      { korean: "ㅏ", romanization: "a", description: "a as in father" },
      { korean: "ㅑ", romanization: "ya", description: "ya as in yard" },
      { korean: "ㅓ", romanization: "eo", description: "uh as in up" },
      { korean: "ㅕ", romanization: "yeo", description: "yuh sound" },
      { korean: "ㅗ", romanization: "o", description: "o as in go" },
      { korean: "ㅛ", romanization: "yo", description: "yo as in yo-yo" },
      { korean: "ㅜ", romanization: "u", description: "u as in moon" },
      { korean: "ㅠ", romanization: "yu", description: "yu as in you" },
      { korean: "ㅡ", romanization: "eu", description: "uh sound (lips spread)" },
      { korean: "ㅣ", romanization: "i", description: "i as in machine" },
      { korean: "ㅐ", romanization: "ae", description: "ae as in cat" },
      { korean: "ㅒ", romanization: "yae", description: "yae sound" },
      { korean: "ㅔ", romanization: "e", description: "e as in red" },
      { korean: "ㅖ", romanization: "ye", description: "ye as in yes" },
      { korean: "ㅘ", romanization: "wa", description: "wa as in water" },
      { korean: "ㅙ", romanization: "wae", description: "wae sound" },
      { korean: "ㅚ", romanization: "oe", description: "we sound" },
      { korean: "ㅝ", romanization: "wo", description: "wo sound" },
      { korean: "ㅞ", romanization: "we", description: "we sound" },
      { korean: "ㅟ", romanization: "wi", description: "wi as in we" },
      { korean: "ㅢ", romanization: "ui", description: "ui sound" }
    ];
    const commonKoreanPatterns = [
      { korean: "안", romanization: "an", description: "an sound" },
      { korean: "음", romanization: "eum", description: "eum sound" },
      { korean: "이", romanization: "i", description: "i sound" },
      { korean: "은", romanization: "eun", description: "eun sound" },
      { korean: "을", romanization: "eul", description: "eul sound" },
      { korean: "의", romanization: "ui", description: "ui sound" },
      { korean: "에", romanization: "e", description: "e sound" },
      { korean: "게", romanization: "ge", description: "ge sound" },
      { korean: "세", romanization: "se", description: "se sound" },
      { korean: "데", romanization: "de", description: "de sound" },
      { korean: "네", romanization: "ne", description: "ne sound" },
      { korean: "베", romanization: "be", description: "be sound" }
    ];
    const specialChars = [
      { char: "-", description: "Syllable separator" },
      { char: "'", description: "Glottal stop" },
      { char: ":", description: "Long vowel marker" },
      { char: " ", description: "Space" },
      { char: "(", description: "Open parenthesis" },
      { char: ")", description: "Close parenthesis" },
      { char: "[", description: "Open bracket" },
      { char: "]", description: "Close bracket" }
    ];
    const filteredConsonantSounds = computed(() => {
      if (!searchQuery.value) return koreanConsonantSounds;
      const query = searchQuery.value.toLowerCase();
      return koreanConsonantSounds.filter(
        (sound) => sound.korean.includes(query) || sound.romanization.toLowerCase().includes(query) || sound.description.toLowerCase().includes(query)
      );
    });
    const filteredVowelSounds = computed(() => {
      if (!searchQuery.value) return koreanVowelSounds;
      const query = searchQuery.value.toLowerCase();
      return koreanVowelSounds.filter(
        (sound) => sound.korean.includes(query) || sound.romanization.toLowerCase().includes(query) || sound.description.toLowerCase().includes(query)
      );
    });
    const filteredCommonPatterns = computed(() => {
      if (!searchQuery.value) return commonKoreanPatterns;
      const query = searchQuery.value.toLowerCase();
      return commonKoreanPatterns.filter(
        (pattern) => pattern.korean.includes(query) || pattern.romanization.toLowerCase().includes(query) || pattern.description.toLowerCase().includes(query)
      );
    });
    const focusSearchInput = () => {
      if (searchInputRef.value) {
        searchInputRef.value.focus();
      }
    };
    const refocusSearchInput = () => {
      setTimeout(() => {
        focusSearchInput();
      }, 50);
    };
    const addSound = (sound) => {
      currentPronunciation.value += sound;
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const clearPronunciation = () => {
      currentPronunciation.value = "";
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const backspacePronunciation = () => {
      if (currentPronunciation.value.length > 0) {
        currentPronunciation.value = currentPronunciation.value.slice(0, -1);
      }
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const closeDialog = () => {
      emit("update:modelValue", false);
    };
    const confirmPronunciation = () => {
      emit("pronunciation-confirmed", currentPronunciation.value);
      emit("update:modelValue", false);
    };
    watch(() => props.initialValue, (newValue) => {
      currentPronunciation.value = newValue;
    }, { immediate: true });
    watch(() => props.modelValue, async (isOpen) => {
      if (isOpen) {
        currentPronunciation.value = props.initialValue;
        searchQuery.value = "";
        await nextTick();
        setTimeout(() => {
          focusSearchInput();
        }, 100);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$7, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$5, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 flex flex-col h-full overflow-hidden transform",
                      onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$4, [
                        createBaseVNode("div", _hoisted_4$4, [
                          createBaseVNode("h2", _hoisted_5$3, [
                            _cache[3] || (_cache[3] = createBaseVNode("span", { class: "w-2 h-2 bg-green-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("korean.pronunciationHelper.title", "Korean Pronunciation Helper")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: closeDialog,
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[4] || (_cache[4] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_6$2, [
                        createBaseVNode("div", _hoisted_7$2, [
                          _cache[5] || (_cache[5] = createBaseVNode("div", { class: "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none" }, [
                            createBaseVNode("svg", {
                              class: "h-5 w-5 text-gray-400",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                              })
                            ])
                          ], -1)),
                          withDirectives(createBaseVNode("input", {
                            ref_key: "searchInputRef",
                            ref: searchInputRef,
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
                            type: "text",
                            class: "block w-full pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-green-500 dark:bg-[#0a0a0a] dark:text-white",
                            placeholder: unref(t)("common.search", "Search Korean sounds..."),
                            onBlur: refocusSearchInput
                          }, null, 40, _hoisted_8$2), [
                            [vModelText, searchQuery.value]
                          ])
                        ]),
                        createBaseVNode("div", null, [
                          createBaseVNode("label", _hoisted_9$2, [
                            _cache[6] || (_cache[6] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                            createTextVNode(" " + toDisplayString$1(unref(t)("korean.pronunciationHelper.preview", "Pronunciation Preview")), 1)
                          ]),
                          createBaseVNode("div", _hoisted_10$2, [
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => currentPronunciation.value = $event),
                              type: "text",
                              class: "w-full px-3 py-2 pr-20 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-300 text-lg",
                              placeholder: unref(t)("korean.pronunciationHelper.placeholder", "Click Korean sounds below..."),
                              readonly: ""
                            }, null, 8, _hoisted_11$2), [
                              [vModelText, currentPronunciation.value]
                            ]),
                            currentPronunciation.value ? (openBlock(), createElementBlock("button", {
                              key: 0,
                              onClick: backspacePronunciation,
                              class: "absolute right-12 top-1/2 -translate-y-1/2 w-8 h-6 bg-orange-500 hover:bg-orange-600 text-white rounded flex items-center justify-center text-xs font-bold transition-all duration-300 hover:scale-110",
                              title: unref(t)("common.backspace", "Backspace")
                            }, " ⌫ ", 8, _hoisted_12$2)) : createCommentVNode("", true),
                            currentPronunciation.value ? (openBlock(), createElementBlock("button", {
                              key: 1,
                              onClick: clearPronunciation,
                              class: "absolute right-2 top-1/2 -translate-y-1/2 w-6 h-6 bg-red-500 hover:bg-red-600 text-white rounded-full flex items-center justify-center text-xs font-bold transition-all duration-300 hover:scale-110",
                              title: unref(t)("common.clear", "Clear")
                            }, " × ", 8, _hoisted_13$2)) : createCommentVNode("", true)
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_14$2, [
                        createBaseVNode("div", _hoisted_15$1, [
                          createBaseVNode("div", null, [
                            createBaseVNode("h3", _hoisted_16$1, [
                              _cache[7] || (_cache[7] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("korean.pronunciationHelper.consonantSounds", "Consonant Sounds (자음 소리)")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_17$1, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredConsonantSounds.value, (sound) => {
                                return openBlock(), createElementBlock("button", {
                                  key: sound.korean,
                                  onClick: ($event) => addSound(sound.romanization),
                                  class: "p-2 bg-blue-100 hover:bg-blue-200 dark:bg-blue-900 dark:hover:bg-blue-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm",
                                  title: sound.description
                                }, [
                                  createBaseVNode("span", _hoisted_19$1, toDisplayString$1(sound.korean), 1),
                                  createBaseVNode("span", _hoisted_20$1, toDisplayString$1(sound.romanization), 1)
                                ], 8, _hoisted_18$1);
                              }), 128))
                            ])
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("h3", _hoisted_21$1, [
                              _cache[8] || (_cache[8] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("korean.pronunciationHelper.vowelSounds", "Vowel Sounds (모음 소리)")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_22$1, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredVowelSounds.value, (sound) => {
                                return openBlock(), createElementBlock("button", {
                                  key: sound.korean,
                                  onClick: ($event) => addSound(sound.romanization),
                                  class: "p-2 bg-green-100 hover:bg-green-200 dark:bg-green-900 dark:hover:bg-green-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm",
                                  title: sound.description
                                }, [
                                  createBaseVNode("span", _hoisted_24$1, toDisplayString$1(sound.korean), 1),
                                  createBaseVNode("span", _hoisted_25$1, toDisplayString$1(sound.romanization), 1)
                                ], 8, _hoisted_23$1);
                              }), 128))
                            ])
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("h3", _hoisted_26, [
                              _cache[9] || (_cache[9] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("korean.pronunciationHelper.commonPatterns", "Common Patterns")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_27, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredCommonPatterns.value, (pattern) => {
                                return openBlock(), createElementBlock("button", {
                                  key: pattern.korean,
                                  onClick: ($event) => addSound(pattern.romanization),
                                  class: "p-2 bg-purple-100 hover:bg-purple-200 dark:bg-purple-900 dark:hover:bg-purple-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm",
                                  title: pattern.description
                                }, [
                                  createBaseVNode("span", _hoisted_29, toDisplayString$1(pattern.korean), 1),
                                  createBaseVNode("span", _hoisted_30, toDisplayString$1(pattern.romanization), 1)
                                ], 8, _hoisted_28);
                              }), 128))
                            ])
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("h3", _hoisted_31, [
                              _cache[10] || (_cache[10] = createBaseVNode("span", { class: "w-1 h-4 bg-yellow-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("korean.pronunciationHelper.specialChars", "Special Characters")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_32, [
                              (openBlock(), createElementBlock(Fragment, null, renderList(specialChars, (char) => {
                                return createBaseVNode("button", {
                                  key: char.char,
                                  onClick: ($event) => addSound(char.char),
                                  class: "px-3 py-2 bg-yellow-100 hover:bg-yellow-200 dark:bg-yellow-900 dark:hover:bg-yellow-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 text-sm font-mono",
                                  title: char.description
                                }, toDisplayString$1(char.char), 9, _hoisted_33);
                              }), 64))
                            ])
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_34, [
                        createBaseVNode("div", _hoisted_35, [
                          createBaseVNode("button", {
                            type: "button",
                            onClick: clearPronunciation,
                            class: "px-4 py-2 text-sm font-medium text-gray-600 dark:text-gray-400 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition-all duration-300 hover:scale-105"
                          }, toDisplayString$1(unref(t)("common.clear", "Clear")), 1),
                          createBaseVNode("div", _hoisted_36, [
                            createBaseVNode("button", {
                              type: "button",
                              onClick: closeDialog,
                              class: "px-4 py-2 text-sm font-medium text-gray-600 dark:text-gray-400 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition-all duration-300 hover:scale-105"
                            }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                            createBaseVNode("button", {
                              type: "button",
                              onClick: confirmPronunciation,
                              class: "px-4 py-2 text-sm font-medium text-white bg-green-600 hover:bg-green-700 rounded-lg transition-all duration-300 hover:scale-105 shadow-lg"
                            }, toDisplayString$1(unref(t)("common.confirm", "Confirm")), 1)
                          ])
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const KoreanPronunciationHelper = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-6520a892"]]);

const KoreanPronunciationHelper$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: KoreanPronunciationHelper
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$6 = {
  key: 0,
  class: "fixed inset-0 bg-black/60 flex items-center justify-center p-4 z-[10000] backdrop-blur-sm"
};
const _hoisted_2$4 = { class: "w-full max-h-[90vh] flex flex-col max-w-full sm:max-w-lg md:max-w-2xl" };
const _hoisted_3$3 = {
  class: "px-6 py-4 border-b border-gray-200 dark:border-[#0f0f0f] flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_4$3 = { class: "flex items-center justify-between" };
const _hoisted_5$2 = { class: "text-lg sm:text-xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$1 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_7$1 = {
  for: "rate",
  class: "block text-sm font-medium text-gray-700 dark:text-white/80"
};
const _hoisted_8$1 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_9$1 = {
  for: "pitch",
  class: "block text-sm font-medium text-gray-700 dark:text-white/80"
};
const _hoisted_10$1 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_11$1 = {
  for: "volume",
  class: "block text-sm font-medium text-gray-700 dark:text-white/80"
};
const _hoisted_12$1 = {
  class: "px-6 py-4 border-t border-gray-200 dark:border-[#0f0f0f] flex-shrink-0 bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_13$1 = { class: "flex justify-between items-center" };
const _hoisted_14$1 = { class: "space-x-3" };
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "VoiceSettingsModal",
  props: {
    show: { type: Boolean },
    voiceType: {},
    voiceName: {},
    initialSettings: {}
  },
  emits: ["close", "save", "reset"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const localSettings = ref({ ...props.initialSettings });
    const modalContentRef = ref(null);
    watch(() => props.initialSettings, (newSettings) => {
      if (newSettings) {
        localSettings.value = { ...newSettings };
      }
    }, { deep: true, immediate: true });
    watch(() => props.show, (isOpen) => {
      if (isOpen) {
        document.body.style.overflow = "hidden";
      } else {
        document.body.style.overflow = "";
      }
    }, { immediate: true });
    onUnmounted(() => {
      document.body.style.overflow = "";
    });
    const close = () => {
      emit("close");
    };
    const save = () => {
      emit("save", { voiceType: props.voiceType, settings: localSettings.value });
      close();
    };
    const resetToDefaults = () => {
      emit("reset", props.voiceType);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$6, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$4, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-[#0f0f0f] flex flex-col h-full overflow-hidden transform",
                      onClick: _cache[3] || (_cache[3] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$3, [
                        createBaseVNode("div", _hoisted_4$3, [
                          createBaseVNode("h2", _hoisted_5$2, [
                            _cache[4] || (_cache[4] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("voice.settings.title", "Voice Settings")) + ": " + toDisplayString$1(_ctx.voiceName), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: close,
                            class: "text-gray-500 hover:text-gray-700 dark:text-white/70 dark:hover:text-white transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-black"
                          }, _cache[5] || (_cache[5] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", {
                        ref_key: "modalContentRef",
                        ref: modalContentRef,
                        class: "px-6 py-4 flex-1 overflow-y-auto min-h-0 space-y-6"
                      }, [
                        createBaseVNode("div", _hoisted_6$1, [
                          createBaseVNode("label", _hoisted_7$1, toDisplayString$1(unref(t)("voice.settings.rate", "Rate")) + " (" + toDisplayString$1(localSettings.value.rate.toFixed(2)) + ")", 1),
                          withDirectives(createBaseVNode("input", {
                            id: "rate",
                            type: "range",
                            min: "0.5",
                            max: "2",
                            step: "0.1",
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => localSettings.value.rate = $event),
                            class: "w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-[#0f0f0f]"
                          }, null, 512), [
                            [
                              vModelText,
                              localSettings.value.rate,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("div", _hoisted_8$1, [
                          createBaseVNode("label", _hoisted_9$1, toDisplayString$1(unref(t)("voice.settings.pitch", "Pitch")) + " (" + toDisplayString$1(localSettings.value.pitch.toFixed(2)) + ")", 1),
                          withDirectives(createBaseVNode("input", {
                            id: "pitch",
                            type: "range",
                            min: "0",
                            max: "2",
                            step: "0.1",
                            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => localSettings.value.pitch = $event),
                            class: "w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-[#0f0f0f]"
                          }, null, 512), [
                            [
                              vModelText,
                              localSettings.value.pitch,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("div", _hoisted_10$1, [
                          createBaseVNode("label", _hoisted_11$1, toDisplayString$1(unref(t)("voice.settings.volume", "Volume")) + " (" + toDisplayString$1(localSettings.value.volume.toFixed(2)) + ")", 1),
                          withDirectives(createBaseVNode("input", {
                            id: "volume",
                            type: "range",
                            min: "0",
                            max: "1",
                            step: "0.1",
                            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => localSettings.value.volume = $event),
                            class: "w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-[#0f0f0f]"
                          }, null, 512), [
                            [
                              vModelText,
                              localSettings.value.volume,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ])
                      ], 512),
                      createBaseVNode("div", _hoisted_12$1, [
                        createBaseVNode("div", _hoisted_13$1, [
                          createBaseVNode("button", {
                            onClick: resetToDefaults,
                            class: "px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 dark:bg-[#0a0a0a] dark:text-white/80 dark:hover:bg-black border dark:border-[#0f0f0f] transition-colors"
                          }, toDisplayString$1(unref(t)("common.resetToDefault", "Reset to Default")), 1),
                          createBaseVNode("div", _hoisted_14$1, [
                            createBaseVNode("button", {
                              onClick: close,
                              class: "px-4 py-2 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 dark:bg-[#0a0a0a] dark:text-white/80 dark:hover:bg-black border dark:border-[#0f0f0f] transition-colors"
                            }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                            createBaseVNode("button", {
                              onClick: save,
                              class: "px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors"
                            }, toDisplayString$1(unref(t)("common.save", "Save")), 1)
                          ])
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const VoiceSettingsModal = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-2954474a"]]);

const VoiceSettingsModal$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: VoiceSettingsModal
}, Symbol.toStringTag, { value: 'Module' }));

// canvas-confetti v1.9.3 built on 2024-04-30T22:19:17.794Z
var module = {};

// source content
/* globals Map */

(function main(global, module, isWorker, workerSize) {
  var canUseWorker = !!(
    global.Worker &&
    global.Blob &&
    global.Promise &&
    global.OffscreenCanvas &&
    global.OffscreenCanvasRenderingContext2D &&
    global.HTMLCanvasElement &&
    global.HTMLCanvasElement.prototype.transferControlToOffscreen &&
    global.URL &&
    global.URL.createObjectURL);

  var canUsePaths = typeof Path2D === 'function' && typeof DOMMatrix === 'function';
  var canDrawBitmap = (function () {
    // this mostly supports ssr
    if (!global.OffscreenCanvas) {
      return false;
    }

    var canvas = new OffscreenCanvas(1, 1);
    var ctx = canvas.getContext('2d');
    ctx.fillRect(0, 0, 1, 1);
    var bitmap = canvas.transferToImageBitmap();

    try {
      ctx.createPattern(bitmap, 'no-repeat');
    } catch (e) {
      return false;
    }

    return true;
  })();

  function noop() {}

  // create a promise if it exists, otherwise, just
  // call the function directly
  function promise(func) {
    var ModulePromise = module.exports.Promise;
    var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;

    if (typeof Prom === 'function') {
      return new Prom(func);
    }

    func(noop, noop);

    return null;
  }

  var bitmapMapper = (function (skipTransform, map) {
    // see https://github.com/catdad/canvas-confetti/issues/209
    // creating canvases is actually pretty expensive, so we should create a
    // 1:1 map for bitmap:canvas, so that we can animate the confetti in
    // a performant manner, but also not store them forever so that we don't
    // have a memory leak
    return {
      transform: function(bitmap) {
        if (skipTransform) {
          return bitmap;
        }

        if (map.has(bitmap)) {
          return map.get(bitmap);
        }

        var canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
        var ctx = canvas.getContext('2d');
        ctx.drawImage(bitmap, 0, 0);

        map.set(bitmap, canvas);

        return canvas;
      },
      clear: function () {
        map.clear();
      }
    };
  })(canDrawBitmap, new Map());

  var raf = (function () {
    var TIME = Math.floor(1000 / 60);
    var frame, cancel;
    var frames = {};
    var lastFrameTime = 0;

    if (typeof requestAnimationFrame === 'function' && typeof cancelAnimationFrame === 'function') {
      frame = function (cb) {
        var id = Math.random();

        frames[id] = requestAnimationFrame(function onFrame(time) {
          if (lastFrameTime === time || lastFrameTime + TIME - 1 < time) {
            lastFrameTime = time;
            delete frames[id];

            cb();
          } else {
            frames[id] = requestAnimationFrame(onFrame);
          }
        });

        return id;
      };
      cancel = function (id) {
        if (frames[id]) {
          cancelAnimationFrame(frames[id]);
        }
      };
    } else {
      frame = function (cb) {
        return setTimeout(cb, TIME);
      };
      cancel = function (timer) {
        return clearTimeout(timer);
      };
    }

    return { frame: frame, cancel: cancel };
  }());

  var getWorker = (function () {
    var worker;
    var prom;
    var resolves = {};

    function decorate(worker) {
      function execute(options, callback) {
        worker.postMessage({ options: options || {}, callback: callback });
      }
      worker.init = function initWorker(canvas) {
        var offscreen = canvas.transferControlToOffscreen();
        worker.postMessage({ canvas: offscreen }, [offscreen]);
      };

      worker.fire = function fireWorker(options, size, done) {
        if (prom) {
          execute(options, null);
          return prom;
        }

        var id = Math.random().toString(36).slice(2);

        prom = promise(function (resolve) {
          function workerDone(msg) {
            if (msg.data.callback !== id) {
              return;
            }

            delete resolves[id];
            worker.removeEventListener('message', workerDone);

            prom = null;

            bitmapMapper.clear();

            done();
            resolve();
          }

          worker.addEventListener('message', workerDone);
          execute(options, id);

          resolves[id] = workerDone.bind(null, { data: { callback: id }});
        });

        return prom;
      };

      worker.reset = function resetWorker() {
        worker.postMessage({ reset: true });

        for (var id in resolves) {
          resolves[id]();
          delete resolves[id];
        }
      };
    }

    return function () {
      if (worker) {
        return worker;
      }

      if (!isWorker && canUseWorker) {
        var code = [
          'var CONFETTI, SIZE = {}, module = {};',
          '(' + main.toString() + ')(this, module, true, SIZE);',
          'onmessage = function(msg) {',
          '  if (msg.data.options) {',
          '    CONFETTI(msg.data.options).then(function () {',
          '      if (msg.data.callback) {',
          '        postMessage({ callback: msg.data.callback });',
          '      }',
          '    });',
          '  } else if (msg.data.reset) {',
          '    CONFETTI && CONFETTI.reset();',
          '  } else if (msg.data.resize) {',
          '    SIZE.width = msg.data.resize.width;',
          '    SIZE.height = msg.data.resize.height;',
          '  } else if (msg.data.canvas) {',
          '    SIZE.width = msg.data.canvas.width;',
          '    SIZE.height = msg.data.canvas.height;',
          '    CONFETTI = module.exports.create(msg.data.canvas);',
          '  }',
          '}',
        ].join('\n');
        try {
          worker = new Worker(URL.createObjectURL(new Blob([code])));
        } catch (e) {
          // eslint-disable-next-line no-console
          typeof console !== undefined && typeof console.warn === 'function' ? console.warn('🎊 Could not load worker', e) : null;

          return null;
        }

        decorate(worker);
      }

      return worker;
    };
  })();

  var defaults = {
    particleCount: 50,
    angle: 90,
    spread: 45,
    startVelocity: 45,
    decay: 0.9,
    gravity: 1,
    drift: 0,
    ticks: 200,
    x: 0.5,
    y: 0.5,
    shapes: ['square', 'circle'],
    zIndex: 100,
    colors: [
      '#26ccff',
      '#a25afd',
      '#ff5e7e',
      '#88ff5a',
      '#fcff42',
      '#ffa62d',
      '#ff36ff'
    ],
    // probably should be true, but back-compat
    disableForReducedMotion: false,
    scalar: 1
  };

  function convert(val, transform) {
    return transform ? transform(val) : val;
  }

  function isOk(val) {
    return !(val === null || val === undefined);
  }

  function prop(options, name, transform) {
    return convert(
      options && isOk(options[name]) ? options[name] : defaults[name],
      transform
    );
  }

  function onlyPositiveInt(number){
    return number < 0 ? 0 : Math.floor(number);
  }

  function randomInt(min, max) {
    // [min, max)
    return Math.floor(Math.random() * (max - min)) + min;
  }

  function toDecimal(str) {
    return parseInt(str, 16);
  }

  function colorsToRgb(colors) {
    return colors.map(hexToRgb);
  }

  function hexToRgb(str) {
    var val = String(str).replace(/[^0-9a-f]/gi, '');

    if (val.length < 6) {
        val = val[0]+val[0]+val[1]+val[1]+val[2]+val[2];
    }

    return {
      r: toDecimal(val.substring(0,2)),
      g: toDecimal(val.substring(2,4)),
      b: toDecimal(val.substring(4,6))
    };
  }

  function getOrigin(options) {
    var origin = prop(options, 'origin', Object);
    origin.x = prop(origin, 'x', Number);
    origin.y = prop(origin, 'y', Number);

    return origin;
  }

  function setCanvasWindowSize(canvas) {
    canvas.width = document.documentElement.clientWidth;
    canvas.height = document.documentElement.clientHeight;
  }

  function setCanvasRectSize(canvas) {
    var rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
  }

  function getCanvas(zIndex) {
    var canvas = document.createElement('canvas');

    canvas.style.position = 'fixed';
    canvas.style.top = '0px';
    canvas.style.left = '0px';
    canvas.style.pointerEvents = 'none';
    canvas.style.zIndex = zIndex;

    return canvas;
  }

  function ellipse(context, x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {
    context.save();
    context.translate(x, y);
    context.rotate(rotation);
    context.scale(radiusX, radiusY);
    context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);
    context.restore();
  }

  function randomPhysics(opts) {
    var radAngle = opts.angle * (Math.PI / 180);
    var radSpread = opts.spread * (Math.PI / 180);

    return {
      x: opts.x,
      y: opts.y,
      wobble: Math.random() * 10,
      wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),
      velocity: (opts.startVelocity * 0.5) + (Math.random() * opts.startVelocity),
      angle2D: -radAngle + ((0.5 * radSpread) - (Math.random() * radSpread)),
      tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,
      color: opts.color,
      shape: opts.shape,
      tick: 0,
      totalTicks: opts.ticks,
      decay: opts.decay,
      drift: opts.drift,
      random: Math.random() + 2,
      tiltSin: 0,
      tiltCos: 0,
      wobbleX: 0,
      wobbleY: 0,
      gravity: opts.gravity * 3,
      ovalScalar: 0.6,
      scalar: opts.scalar,
      flat: opts.flat
    };
  }

  function updateFetti(context, fetti) {
    fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;
    fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;
    fetti.velocity *= fetti.decay;

    if (fetti.flat) {
      fetti.wobble = 0;
      fetti.wobbleX = fetti.x + (10 * fetti.scalar);
      fetti.wobbleY = fetti.y + (10 * fetti.scalar);

      fetti.tiltSin = 0;
      fetti.tiltCos = 0;
      fetti.random = 1;
    } else {
      fetti.wobble += fetti.wobbleSpeed;
      fetti.wobbleX = fetti.x + ((10 * fetti.scalar) * Math.cos(fetti.wobble));
      fetti.wobbleY = fetti.y + ((10 * fetti.scalar) * Math.sin(fetti.wobble));

      fetti.tiltAngle += 0.1;
      fetti.tiltSin = Math.sin(fetti.tiltAngle);
      fetti.tiltCos = Math.cos(fetti.tiltAngle);
      fetti.random = Math.random() + 2;
    }

    var progress = (fetti.tick++) / fetti.totalTicks;

    var x1 = fetti.x + (fetti.random * fetti.tiltCos);
    var y1 = fetti.y + (fetti.random * fetti.tiltSin);
    var x2 = fetti.wobbleX + (fetti.random * fetti.tiltCos);
    var y2 = fetti.wobbleY + (fetti.random * fetti.tiltSin);

    context.fillStyle = 'rgba(' + fetti.color.r + ', ' + fetti.color.g + ', ' + fetti.color.b + ', ' + (1 - progress) + ')';

    context.beginPath();

    if (canUsePaths && fetti.shape.type === 'path' && typeof fetti.shape.path === 'string' && Array.isArray(fetti.shape.matrix)) {
      context.fill(transformPath2D(
        fetti.shape.path,
        fetti.shape.matrix,
        fetti.x,
        fetti.y,
        Math.abs(x2 - x1) * 0.1,
        Math.abs(y2 - y1) * 0.1,
        Math.PI / 10 * fetti.wobble
      ));
    } else if (fetti.shape.type === 'bitmap') {
      var rotation = Math.PI / 10 * fetti.wobble;
      var scaleX = Math.abs(x2 - x1) * 0.1;
      var scaleY = Math.abs(y2 - y1) * 0.1;
      var width = fetti.shape.bitmap.width * fetti.scalar;
      var height = fetti.shape.bitmap.height * fetti.scalar;

      var matrix = new DOMMatrix([
        Math.cos(rotation) * scaleX,
        Math.sin(rotation) * scaleX,
        -Math.sin(rotation) * scaleY,
        Math.cos(rotation) * scaleY,
        fetti.x,
        fetti.y
      ]);

      // apply the transform matrix from the confetti shape
      matrix.multiplySelf(new DOMMatrix(fetti.shape.matrix));

      var pattern = context.createPattern(bitmapMapper.transform(fetti.shape.bitmap), 'no-repeat');
      pattern.setTransform(matrix);

      context.globalAlpha = (1 - progress);
      context.fillStyle = pattern;
      context.fillRect(
        fetti.x - (width / 2),
        fetti.y - (height / 2),
        width,
        height
      );
      context.globalAlpha = 1;
    } else if (fetti.shape === 'circle') {
      context.ellipse ?
        context.ellipse(fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) :
        ellipse(context, fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);
    } else if (fetti.shape === 'star') {
      var rot = Math.PI / 2 * 3;
      var innerRadius = 4 * fetti.scalar;
      var outerRadius = 8 * fetti.scalar;
      var x = fetti.x;
      var y = fetti.y;
      var spikes = 5;
      var step = Math.PI / spikes;

      while (spikes--) {
        x = fetti.x + Math.cos(rot) * outerRadius;
        y = fetti.y + Math.sin(rot) * outerRadius;
        context.lineTo(x, y);
        rot += step;

        x = fetti.x + Math.cos(rot) * innerRadius;
        y = fetti.y + Math.sin(rot) * innerRadius;
        context.lineTo(x, y);
        rot += step;
      }
    } else {
      context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));
      context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));
      context.lineTo(Math.floor(x2), Math.floor(y2));
      context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));
    }

    context.closePath();
    context.fill();

    return fetti.tick < fetti.totalTicks;
  }

  function animate(canvas, fettis, resizer, size, done) {
    var animatingFettis = fettis.slice();
    var context = canvas.getContext('2d');
    var animationFrame;
    var destroy;

    var prom = promise(function (resolve) {
      function onDone() {
        animationFrame = destroy = null;

        context.clearRect(0, 0, size.width, size.height);
        bitmapMapper.clear();

        done();
        resolve();
      }

      function update() {
        if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {
          size.width = canvas.width = workerSize.width;
          size.height = canvas.height = workerSize.height;
        }

        if (!size.width && !size.height) {
          resizer(canvas);
          size.width = canvas.width;
          size.height = canvas.height;
        }

        context.clearRect(0, 0, size.width, size.height);

        animatingFettis = animatingFettis.filter(function (fetti) {
          return updateFetti(context, fetti);
        });

        if (animatingFettis.length) {
          animationFrame = raf.frame(update);
        } else {
          onDone();
        }
      }

      animationFrame = raf.frame(update);
      destroy = onDone;
    });

    return {
      addFettis: function (fettis) {
        animatingFettis = animatingFettis.concat(fettis);

        return prom;
      },
      canvas: canvas,
      promise: prom,
      reset: function () {
        if (animationFrame) {
          raf.cancel(animationFrame);
        }

        if (destroy) {
          destroy();
        }
      }
    };
  }

  function confettiCannon(canvas, globalOpts) {
    var isLibCanvas = !canvas;
    var allowResize = !!prop(globalOpts || {}, 'resize');
    var hasResizeEventRegistered = false;
    var globalDisableForReducedMotion = prop(globalOpts, 'disableForReducedMotion', Boolean);
    var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, 'useWorker');
    var worker = shouldUseWorker ? getWorker() : null;
    var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;
    var initialized = (canvas && worker) ? !!canvas.__confetti_initialized : false;
    var preferLessMotion = typeof matchMedia === 'function' && matchMedia('(prefers-reduced-motion)').matches;
    var animationObj;

    function fireLocal(options, size, done) {
      var particleCount = prop(options, 'particleCount', onlyPositiveInt);
      var angle = prop(options, 'angle', Number);
      var spread = prop(options, 'spread', Number);
      var startVelocity = prop(options, 'startVelocity', Number);
      var decay = prop(options, 'decay', Number);
      var gravity = prop(options, 'gravity', Number);
      var drift = prop(options, 'drift', Number);
      var colors = prop(options, 'colors', colorsToRgb);
      var ticks = prop(options, 'ticks', Number);
      var shapes = prop(options, 'shapes');
      var scalar = prop(options, 'scalar');
      var flat = !!prop(options, 'flat');
      var origin = getOrigin(options);

      var temp = particleCount;
      var fettis = [];

      var startX = canvas.width * origin.x;
      var startY = canvas.height * origin.y;

      while (temp--) {
        fettis.push(
          randomPhysics({
            x: startX,
            y: startY,
            angle: angle,
            spread: spread,
            startVelocity: startVelocity,
            color: colors[temp % colors.length],
            shape: shapes[randomInt(0, shapes.length)],
            ticks: ticks,
            decay: decay,
            gravity: gravity,
            drift: drift,
            scalar: scalar,
            flat: flat
          })
        );
      }

      // if we have a previous canvas already animating,
      // add to it
      if (animationObj) {
        return animationObj.addFettis(fettis);
      }

      animationObj = animate(canvas, fettis, resizer, size , done);

      return animationObj.promise;
    }

    function fire(options) {
      var disableForReducedMotion = globalDisableForReducedMotion || prop(options, 'disableForReducedMotion', Boolean);
      var zIndex = prop(options, 'zIndex', Number);

      if (disableForReducedMotion && preferLessMotion) {
        return promise(function (resolve) {
          resolve();
        });
      }

      if (isLibCanvas && animationObj) {
        // use existing canvas from in-progress animation
        canvas = animationObj.canvas;
      } else if (isLibCanvas && !canvas) {
        // create and initialize a new canvas
        canvas = getCanvas(zIndex);
        document.body.appendChild(canvas);
      }

      if (allowResize && !initialized) {
        // initialize the size of a user-supplied canvas
        resizer(canvas);
      }

      var size = {
        width: canvas.width,
        height: canvas.height
      };

      if (worker && !initialized) {
        worker.init(canvas);
      }

      initialized = true;

      if (worker) {
        canvas.__confetti_initialized = true;
      }

      function onResize() {
        if (worker) {
          // TODO this really shouldn't be immediate, because it is expensive
          var obj = {
            getBoundingClientRect: function () {
              if (!isLibCanvas) {
                return canvas.getBoundingClientRect();
              }
            }
          };

          resizer(obj);

          worker.postMessage({
            resize: {
              width: obj.width,
              height: obj.height
            }
          });
          return;
        }

        // don't actually query the size here, since this
        // can execute frequently and rapidly
        size.width = size.height = null;
      }

      function done() {
        animationObj = null;

        if (allowResize) {
          hasResizeEventRegistered = false;
          global.removeEventListener('resize', onResize);
        }

        if (isLibCanvas && canvas) {
          if (document.body.contains(canvas)) {
            document.body.removeChild(canvas); 
          }
          canvas = null;
          initialized = false;
        }
      }

      if (allowResize && !hasResizeEventRegistered) {
        hasResizeEventRegistered = true;
        global.addEventListener('resize', onResize, false);
      }

      if (worker) {
        return worker.fire(options, size, done);
      }

      return fireLocal(options, size, done);
    }

    fire.reset = function () {
      if (worker) {
        worker.reset();
      }

      if (animationObj) {
        animationObj.reset();
      }
    };

    return fire;
  }

  // Make default export lazy to defer worker creation until called.
  var defaultFire;
  function getDefaultFire() {
    if (!defaultFire) {
      defaultFire = confettiCannon(null, { useWorker: true, resize: true });
    }
    return defaultFire;
  }

  function transformPath2D(pathString, pathMatrix, x, y, scaleX, scaleY, rotation) {
    var path2d = new Path2D(pathString);

    var t1 = new Path2D();
    t1.addPath(path2d, new DOMMatrix(pathMatrix));

    var t2 = new Path2D();
    // see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/DOMMatrix
    t2.addPath(t1, new DOMMatrix([
      Math.cos(rotation) * scaleX,
      Math.sin(rotation) * scaleX,
      -Math.sin(rotation) * scaleY,
      Math.cos(rotation) * scaleY,
      x,
      y
    ]));

    return t2;
  }

  function shapeFromPath(pathData) {
    if (!canUsePaths) {
      throw new Error('path confetti are not supported in this browser');
    }

    var path, matrix;

    if (typeof pathData === 'string') {
      path = pathData;
    } else {
      path = pathData.path;
      matrix = pathData.matrix;
    }

    var path2d = new Path2D(path);
    var tempCanvas = document.createElement('canvas');
    var tempCtx = tempCanvas.getContext('2d');

    if (!matrix) {
      // attempt to figure out the width of the path, up to 1000x1000
      var maxSize = 1000;
      var minX = maxSize;
      var minY = maxSize;
      var maxX = 0;
      var maxY = 0;
      var width, height;

      // do some line skipping... this is faster than checking
      // every pixel and will be mostly still correct
      for (var x = 0; x < maxSize; x += 2) {
        for (var y = 0; y < maxSize; y += 2) {
          if (tempCtx.isPointInPath(path2d, x, y, 'nonzero')) {
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
        }
      }

      width = maxX - minX;
      height = maxY - minY;

      var maxDesiredSize = 10;
      var scale = Math.min(maxDesiredSize/width, maxDesiredSize/height);

      matrix = [
        scale, 0, 0, scale,
        -Math.round((width/2) + minX) * scale,
        -Math.round((height/2) + minY) * scale
      ];
    }

    return {
      type: 'path',
      path: path,
      matrix: matrix
    };
  }

  function shapeFromText(textData) {
    var text,
        scalar = 1,
        color = '#000000',
        // see https://nolanlawson.com/2022/04/08/the-struggle-of-using-native-emoji-on-the-web/
        fontFamily = '"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", "EmojiOne Color", "Android Emoji", "Twemoji Mozilla", "system emoji", sans-serif';

    if (typeof textData === 'string') {
      text = textData;
    } else {
      text = textData.text;
      scalar = 'scalar' in textData ? textData.scalar : scalar;
      fontFamily = 'fontFamily' in textData ? textData.fontFamily : fontFamily;
      color = 'color' in textData ? textData.color : color;
    }

    // all other confetti are 10 pixels,
    // so this pixel size is the de-facto 100% scale confetti
    var fontSize = 10 * scalar;
    var font = '' + fontSize + 'px ' + fontFamily;

    var canvas = new OffscreenCanvas(fontSize, fontSize);
    var ctx = canvas.getContext('2d');

    ctx.font = font;
    var size = ctx.measureText(text);
    var width = Math.ceil(size.actualBoundingBoxRight + size.actualBoundingBoxLeft);
    var height = Math.ceil(size.actualBoundingBoxAscent + size.actualBoundingBoxDescent);

    var padding = 2;
    var x = size.actualBoundingBoxLeft + padding;
    var y = size.actualBoundingBoxAscent + padding;
    width += padding + padding;
    height += padding + padding;

    canvas = new OffscreenCanvas(width, height);
    ctx = canvas.getContext('2d');
    ctx.font = font;
    ctx.fillStyle = color;

    ctx.fillText(text, x, y);

    var scale = 1 / scalar;

    return {
      type: 'bitmap',
      // TODO these probably need to be transfered for workers
      bitmap: canvas.transferToImageBitmap(),
      matrix: [scale, 0, 0, scale, -width * scale / 2, -height * scale / 2]
    };
  }

  module.exports = function() {
    return getDefaultFire().apply(this, arguments);
  };
  module.exports.reset = function() {
    getDefaultFire().reset();
  };
  module.exports.create = confettiCannon;
  module.exports.shapeFromPath = shapeFromPath;
  module.exports.shapeFromText = shapeFromText;
}((function () {
  if (typeof window !== 'undefined') {
    return window;
  }

  if (typeof self !== 'undefined') {
    return self;
  }

  return this || {};
})(), module, false));

// end source content

const confetti = module.exports;
module.exports.create;

const _hoisted_1$5 = { class: "firework-sound-effect" };
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "FireworkSoundEffect",
  props: {
    triggerFirework: { type: Boolean, default: false },
    triggerSound: { type: Boolean, default: false },
    isCorrect: { type: Boolean, default: true },
    soundVolume: { default: 0.5 }
  },
  emits: ["effect-complete"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    toRefs(props);
    let audioContextInstance = null;
    const getAudioContext = () => {
      if (!audioContextInstance || audioContextInstance.state === "closed") {
        audioContextInstance = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContextInstance;
    };
    const createSuccessSound = () => {
      try {
        const audioContext = getAudioContext();
        if (audioContext.state === "suspended") {
          audioContext.resume();
        }
        const playNote = (frequency, startTime, duration) => {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          oscillator.frequency.setValueAtTime(frequency, startTime);
          oscillator.type = "sine";
          gainNode.gain.setValueAtTime(0, startTime);
          gainNode.gain.linearRampToValueAtTime(props.soundVolume * 0.4, startTime + 0.02);
          gainNode.gain.exponentialRampToValueAtTime(1e-3, startTime + duration);
          oscillator.start(startTime);
          oscillator.stop(startTime + duration);
          oscillator.onended = () => {
            oscillator.disconnect();
            gainNode.disconnect();
          };
        };
        const now = audioContext.currentTime;
        playNote(523.25, now, 0.5);
        playNote(659.25, now + 0.15, 0.5);
        playNote(783.99, now + 0.3, 0.6);
      } catch (error) {
        console.warn("Web Audio API not supported:", error);
      }
    };
    const createErrorSound = () => {
      try {
        const audioContext = getAudioContext();
        if (audioContext.state === "suspended") {
          audioContext.resume();
        }
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        const now = audioContext.currentTime;
        oscillator.frequency.setValueAtTime(400, now);
        oscillator.frequency.exponentialRampToValueAtTime(180, now + 0.8);
        oscillator.type = "sawtooth";
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(props.soundVolume * 0.5, now + 0.02);
        gainNode.gain.exponentialRampToValueAtTime(1e-3, now + 0.8);
        oscillator.start(now);
        oscillator.stop(now + 0.8);
        oscillator.onended = () => {
          oscillator.disconnect();
          gainNode.disconnect();
        };
      } catch (error) {
        console.warn("Web Audio API not supported:", error);
      }
    };
    const triggerFireworkEffect = () => {
      if (!props.triggerFirework) return;
      if (props.isCorrect) {
        confetti({
          particleCount: 100,
          spread: 70,
          origin: { y: 0.6 },
          colors: ["#00ff00", "#32cd32", "#7cfc00", "#adff2f", "#9aff9a"]
        });
        setTimeout(() => {
          confetti({
            particleCount: 50,
            angle: 60,
            spread: 55,
            origin: { x: 0, y: 0.8 },
            colors: ["#ffd700", "#ffff00", "#ffffe0", "#fffacd"]
          });
        }, 200);
        setTimeout(() => {
          confetti({
            particleCount: 50,
            angle: 120,
            spread: 55,
            origin: { x: 1, y: 0.8 },
            colors: ["#ff69b4", "#ff1493", "#ffb6c1", "#ffc0cb"]
          });
        }, 400);
      } else {
        confetti({
          particleCount: 30,
          spread: 45,
          origin: { y: 0.7 },
          colors: ["#ff4444", "#ff6666", "#ff8888", "#ffaaaa"],
          gravity: 1.2,
          scalar: 0.8
        });
      }
    };
    const playSoundEffect = () => {
      if (!props.triggerSound) return;
      try {
        if (props.isCorrect) {
          createSuccessSound();
        } else {
          createErrorSound();
        }
      } catch (error) {
        console.warn("Sound playback error:", error);
        playFallbackSound(props.isCorrect);
      }
    };
    const playFallbackSound = (isCorrect2) => {
      try {
        const audioContext = getAudioContext();
        if (audioContext.state === "suspended") {
          audioContext.resume();
        }
        const now = audioContext.currentTime;
        if (isCorrect2) {
          const frequencies = [523, 659, 784];
          frequencies.forEach((freq, index) => {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            const startTime = now + index * 0.15;
            oscillator.frequency.setValueAtTime(freq, startTime);
            oscillator.type = "sine";
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(props.soundVolume * 0.4, startTime + 0.02);
            gainNode.gain.exponentialRampToValueAtTime(1e-3, startTime + 0.4);
            oscillator.start(startTime);
            oscillator.stop(startTime + 0.4);
            oscillator.onended = () => {
              oscillator.disconnect();
              gainNode.disconnect();
            };
          });
        } else {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          oscillator.frequency.setValueAtTime(400, now);
          oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.6);
          oscillator.type = "sawtooth";
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(props.soundVolume * 0.5, now + 0.02);
          gainNode.gain.exponentialRampToValueAtTime(1e-3, now + 0.6);
          oscillator.start(now);
          oscillator.stop(now + 0.6);
          oscillator.onended = () => {
            oscillator.disconnect();
            gainNode.disconnect();
          };
        }
      } catch (error) {
        console.warn("Web Audio API fallback failed:", error);
      }
    };
    const triggerEffects = () => {
      if (props.triggerFirework || props.triggerSound) {
        triggerFireworkEffect();
        playSoundEffect();
        setTimeout(() => {
          emit("effect-complete");
        }, 1e3);
      }
    };
    const { triggerFirework, triggerSound, isCorrect } = toRefs(props);
    watch([triggerFirework, triggerSound], ([newFirework, newSound]) => {
      if (newFirework || newSound) {
        triggerEffects();
      }
    }, { immediate: false });
    onUnmounted(() => {
      if (audioContextInstance && audioContextInstance.state !== "closed") {
        setTimeout(() => {
          if (audioContextInstance && audioContextInstance.state !== "closed") {
            audioContextInstance.close();
            audioContextInstance = null;
          }
        }, 1e3);
      }
    });
    __expose({
      triggerEffects,
      triggerFireworkEffect,
      playSoundEffect
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$5);
    };
  }
});

const FireworkSoundEffect = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-146028e4"]]);

const FireworkSoundEffect$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: FireworkSoundEffect
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$4 = { class: "relative bg-gray-100 dark:bg-[#0a0a0a] rounded-md p-2 overflow-hidden" };
const _hoisted_2$3 = {
  class: "grid grid-cols-15 gap-px",
  style: { "grid-template-columns": "repeat(15, minmax(0, 1fr))" }
};
const _hoisted_3$2 = { class: "absolute inset-0 pointer-events-none" };
const _hoisted_4$2 = { class: "w-full h-full flex items-center justify-center" };
const _hoisted_5$1 = { class: "absolute inset-0 pointer-events-none" };
const gridW = 15;
const gridH = 10;
const cellSize = 8;
const gap = 1;
const padding = 8;
const stepInterval = 140;
const maxSteps = 18;
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "SnakeReplay",
  props: {
    data: {}
  },
  setup(__props) {
    const props = __props;
    const totalCells = gridW * gridH;
    const scalePos = (p) => ({ x: Math.floor(p.x / 2), y: Math.floor(p.y / 2) });
    const scaledFood = computed(() => scalePos(props.data.position));
    const state = reactive({
      head: scalePos(props.data.snakeBody[0] || { x: 0, y: 0 }),
      body: props.data.snakeBody.slice(1).map(scalePos),
      dir: { ...props.data.direction }
    });
    const head = computed(() => state.head);
    const renderBody = computed(() => state.body);
    const currentDirection = computed(() => state.dir);
    const baseCellClass = (index) => {
      const x = index % gridW;
      const y = Math.floor(index / gridW);
      if (x === scaledFood.value.x && y === scaledFood.value.y) {
        return props.data.wasCorrect ? "bg-emerald-300/70 dark:bg-emerald-700/60" : "bg-red-300/70 dark:bg-red-700/60";
      }
      return "bg-gray-200 dark:bg-dark-bg-soft hover:bg-gray-300 dark:hover:bg-dark-bg-soft";
    };
    const toPixel = (p) => ({
      left: `${padding + p.x * (cellSize + gap)}px`,
      top: `${padding + p.y * (cellSize + gap)}px`
    });
    const headStyle = (p) => ({
      position: "absolute",
      zIndex: 10,
      ...toPixel(p)
    });
    const segmentStyle = (p, idx) => ({
      position: "absolute",
      zIndex: 5,
      opacity: Math.max(0.35, 1 - idx * 0.1),
      transition: "left 120ms linear, top 120ms linear, opacity 300ms ease",
      ...toPixel(p)
    });
    const foodStyle = (p) => ({
      position: "absolute",
      ...toPixel(p)
    });
    const directionDotStyle = (d) => {
      let transform = "translate(-50%, -50%)";
      if (d.x === 1) transform += " translateX(25%)";
      else if (d.x === -1) transform += " translateX(-25%)";
      else if (d.y === 1) transform += " translateY(25%)";
      else if (d.y === -1) transform += " translateY(-25%)";
      return { position: "absolute", left: "50%", top: "50%", transform };
    };
    let rafId = null;
    let lastStep = 0;
    const inBounds = (p) => p.x >= 0 && p.y >= 0 && p.x < gridW && p.y < gridH;
    let frameIndex = 0;
    const nextStep = () => {
      const now = performance.now();
      if (now - lastStep < stepInterval) {
        rafId = requestAnimationFrame(nextStep);
        return;
      }
      lastStep = now;
      const hasTimeline = props.data.timelineFrames && props.data.timelineFrames.length > 0;
      if (hasTimeline) {
        const frames = props.data.timelineFrames;
        const f = frames[frameIndex % frames.length];
        const headSeg = f.body[0] || { x: 0, y: 0 };
        state.head = scalePos(headSeg);
        state.body = f.body.slice(1).map(scalePos);
        state.dir = { x: f.direction.x, y: f.direction.y };
        frameIndex = (frameIndex + 1) % frames.length;
      } else {
        const target = scaledFood.value;
        const dx = target.x - state.head.x;
        const dy = target.y - state.head.y;
        const step = { x: Math.sign(dx), y: Math.sign(dy) };
        const move = Math.abs(dx) >= Math.abs(dy) ? { x: step.x, y: 0 } : { x: 0, y: step.y };
        const newBody = [{ ...state.head }, ...state.body.slice(0, Math.max(0, state.body.length - 0))];
        state.body = newBody.slice(0, props.data.snakeBody.length - 1);
        const newHead = { x: state.head.x + move.x, y: state.head.y + move.y };
        state.dir = move;
        if (inBounds(newHead)) state.head = newHead;
        loopCounter.value++;
        const reached = state.head.x === target.x && state.head.y === target.y;
        if (reached || loopCounter.value >= maxSteps) {
          state.head = scalePos(props.data.snakeBody[0] || { x: 0, y: 0 });
          state.body = props.data.snakeBody.slice(1).map(scalePos);
          state.dir = { ...props.data.direction };
          loopCounter.value = 0;
        }
      }
      rafId = requestAnimationFrame(nextStep);
    };
    const loopCounter = ref(0);
    onMounted(() => {
      lastStep = performance.now();
      rafId = requestAnimationFrame(nextStep);
    });
    onUnmounted(() => {
      if (rafId) cancelAnimationFrame(rafId);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        createBaseVNode("div", _hoisted_2$3, [
          (openBlock(), createElementBlock(Fragment, null, renderList(totalCells, (i) => {
            return createBaseVNode("div", {
              key: i,
              class: normalizeClass(["w-2 h-2 transition-colors duration-300", baseCellClass(i - 1)])
            }, null, 2);
          }), 64))
        ]),
        createBaseVNode("div", _hoisted_3$2, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(renderBody.value, (seg, idx) => {
            return openBlock(), createElementBlock("div", {
              key: `seg-${idx}`,
              class: "w-2 h-2 rounded-sm bg-green-300 dark:bg-green-600",
              style: normalizeStyle(segmentStyle(seg, idx))
            }, null, 4);
          }), 128)),
          head.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "w-3 h-3 rounded-full bg-green-500 border border-green-300 animate-pulse",
            style: normalizeStyle(headStyle(head.value))
          }, [
            createBaseVNode("div", _hoisted_4$2, [
              createBaseVNode("div", {
                class: "w-1 h-1 bg-white rounded-full",
                style: normalizeStyle(directionDotStyle(currentDirection.value))
              }, null, 4)
            ])
          ], 4)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_5$1, [
          createBaseVNode("div", {
            class: normalizeClass(["w-3 h-3 rounded-full animate-ping", _ctx.data.wasCorrect ? "bg-emerald-400 dark:bg-emerald-500" : "bg-red-400 dark:bg-red-500"]),
            style: normalizeStyle(foodStyle(scaledFood.value))
          }, null, 6)
        ])
      ]);
    };
  }
});

const SnakeReplay = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-b407b167"]]);

const SnakeReplay$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: SnakeReplay
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$3 = { class: "mb-1" };
const _hoisted_2$2 = { class: "px-2 py-1 bg-purple-100 dark:bg-dark-bg-mute text-purple-800 dark:text-purple-300 text-xs font-medium rounded-full" };
const _hoisted_3$1 = { class: "text-lg sm:text-xl md:text-2xl xl:text-xl 2xl:text-2xl font-bold text-purple-900 dark:text-purple-300 mb-1 px-1 text-center" };
const _hoisted_4$1 = { class: "text-xs sm:text-sm xl:text-sm 2xl:text-sm text-gray-600 dark:text-white/70 mb-1 max-w-sm px-1 text-center" };
const _hoisted_5 = { class: "text-center mb-2" };
const _hoisted_6 = { class: "text-sm sm:text-base md:text-lg xl:text-base 2xl:text-lg text-gray-500 dark:text-white/70 break-words px-1" };
const _hoisted_7 = { class: "text-xs sm:text-sm text-gray-400 dark:text-white/60 mt-1" };
const _hoisted_8 = { class: "flex flex-wrap justify-center gap-1 sm:gap-1.5 mb-2 px-2 max-w-full" };
const _hoisted_9 = ["onUpdate:modelValue", "onInput", "onKeydown"];
const _hoisted_10 = {
  key: 1,
  class: "uppercase text-purple-700 dark:text-purple-300"
};
const _hoisted_11 = {
  key: 2,
  class: "uppercase text-yellow-600 dark:text-yellow-400"
};
const _hoisted_12 = {
  key: 1,
  class: "w-2 sm:w-3"
};
const _hoisted_13 = { class: "mb-0.5 xl:mb-0.5 2xl:mb-1" };
const _hoisted_14 = { class: "flex flex-wrap justify-center gap-2 px-1 mb-2" };
const _hoisted_15 = ["disabled"];
const _hoisted_16 = {
  key: 0,
  class: "px-1 text-center mt-0.5 xl:mt-0 2xl:mt-0.5 bg-gray-50 dark:bg-dark-bg-soft rounded py-1 xl:py-0.5 2xl:py-1"
};
const _hoisted_17 = {
  key: 0,
  class: "text-sm sm:text-base xl:text-base 2xl:text-lg font-bold text-green-600 dark:text-green-400 mb-0.5 xl:mb-0.5 2xl:mb-1"
};
const _hoisted_18 = {
  key: 1,
  class: "text-sm sm:text-base xl:text-base 2xl:text-lg font-bold text-red-600 dark:text-red-400 mb-0.5 xl:mb-0.5 2xl:mb-1"
};
const _hoisted_19 = { class: "space-y-0.5 xl:space-y-0 2xl:space-y-0.5 border-t border-gray-200 dark:border-dark-bg-mute pt-0.5 xl:pt-0 2xl:pt-0.5" };
const _hoisted_20 = { class: "text-sm xl:text-sm 2xl:text-base text-gray-700 dark:text-white/80" };
const _hoisted_21 = { class: "font-semibold" };
const _hoisted_22 = { class: "font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_23 = { class: "text-sm xl:text-sm 2xl:text-base text-gray-700 dark:text-white/80" };
const _hoisted_24 = { class: "font-semibold" };
const _hoisted_25 = { class: "font-medium text-gray-900 dark:text-white" };
const maxHints = 2;
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "WordsCrushMode",
  props: {
    card: {},
    getTopicName: { type: Function }
  },
  emits: ["game-completed", "play-audio"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const wordSlots = ref([]);
    const gameCompleted = ref(false);
    const isCorrect = ref(false);
    const hintsUsed = ref(0);
    const letterInputs = ref([]);
    const createWordSlots = () => {
      if (!props.card?.word) return [];
      const word = props.card.word.toLowerCase();
      const slots = [];
      for (let i = 0; i < word.length; i++) {
        const char = word[i];
        if (char === " ") {
          slots.push({
            char: " ",
            separator: true,
            filled: false,
            userInput: "",
            correct: false,
            incorrect: false,
            revealed: false
          });
        } else {
          slots.push({
            char,
            separator: false,
            filled: false,
            userInput: "",
            correct: false,
            incorrect: false,
            revealed: false
          });
        }
      }
      const letterSlots = slots.filter((slot) => !slot.separator);
      const hideCount = Math.ceil(letterSlots.length * 0.5);
      const indicesToHide = [];
      while (indicesToHide.length < hideCount) {
        const randomIndex = Math.floor(Math.random() * letterSlots.length);
        const actualIndex = slots.findIndex((slot) => slot === letterSlots[randomIndex]);
        if (!indicesToHide.includes(actualIndex)) {
          indicesToHide.push(actualIndex);
        }
      }
      const shownLetterIndices = [];
      slots.forEach((slot, index) => {
        if (!slot.separator && !indicesToHide.includes(index)) {
          shownLetterIndices.push(index);
        }
      });
      const shownLetters = shownLetterIndices.map((index) => slots[index].char);
      const shuffledLetters = [...shownLetters].sort(() => Math.random() - 0.5);
      let shuffleIndex = 0;
      slots.forEach((slot, index) => {
        if (!slot.separator) {
          if (indicesToHide.includes(index)) ; else {
            slot.filled = true;
            slot.userInput = shuffledLetters[shuffleIndex];
            shuffleIndex++;
          }
        }
      });
      return slots;
    };
    const canCheckAnswer = computed(() => {
      return wordSlots.value.filter((slot) => !slot.separator && !slot.filled).every((slot) => slot.userInput.trim() !== "");
    });
    const initializeGame = () => {
      if (!props.card?.word) return;
      wordSlots.value = createWordSlots();
      gameCompleted.value = false;
      isCorrect.value = false;
      hintsUsed.value = 0;
      letterInputs.value = [];
    };
    const handleLetterInput = (index, event) => {
      const target = event.target;
      const value = target.value.toLowerCase();
      if (value && /^[a-zA-Z]$/.test(value)) {
        wordSlots.value[index].userInput = value;
        const nextEmptyIndex = wordSlots.value.findIndex(
          (slot, i) => i > index && !slot.separator && !slot.filled && slot.userInput === ""
        );
        if (nextEmptyIndex !== -1 && letterInputs.value[nextEmptyIndex]) {
          nextTick(() => {
            letterInputs.value[nextEmptyIndex].focus();
          });
        }
      } else if (value === "") {
        wordSlots.value[index].userInput = "";
      } else {
        target.value = "";
        wordSlots.value[index].userInput = "";
      }
    };
    const handleKeyDown = (index, event) => {
      if (event.key === "Backspace" && wordSlots.value[index].userInput === "") {
        const prevEmptyIndex = wordSlots.value.findIndex(
          (slot, i) => i < index && !slot.separator && !slot.filled
        );
        if (prevEmptyIndex !== -1) {
          const reversedIndex = [...wordSlots.value].reverse().findIndex((slot, i) => {
            const originalIndex = wordSlots.value.length - 1 - i;
            return originalIndex < index && !slot.separator && !slot.filled;
          });
          if (reversedIndex !== -1) {
            const actualIndex = wordSlots.value.length - 1 - reversedIndex;
            if (letterInputs.value[actualIndex]) {
              nextTick(() => {
                letterInputs.value[actualIndex].focus();
              });
            }
          }
        }
      } else if (event.key === "Enter") {
        checkAnswer();
      }
    };
    const checkAnswer = () => {
      if (!canCheckAnswer.value) return;
      let allCorrect = true;
      wordSlots.value.forEach((slot) => {
        if (!slot.separator && !slot.filled) {
          const isLetterCorrect = slot.userInput.toLowerCase() === slot.char.toLowerCase();
          slot.correct = isLetterCorrect;
          slot.incorrect = !isLetterCorrect;
          if (!isLetterCorrect) allCorrect = false;
        }
      });
      gameCompleted.value = true;
      isCorrect.value = allCorrect;
      emit("game-completed", allCorrect);
    };
    const revealHint = () => {
      if (hintsUsed.value >= maxHints) return;
      const emptySlots = wordSlots.value.filter((slot) => !slot.separator && !slot.filled && slot.userInput === "");
      if (emptySlots.length === 0) return;
      const randomSlot = emptySlots[Math.floor(Math.random() * emptySlots.length)];
      randomSlot.revealed = true;
      randomSlot.userInput = randomSlot.char;
      hintsUsed.value++;
    };
    const resetGame = () => {
      initializeGame();
    };
    const playPronunciation = () => {
      if (props.card?.word) {
        emit("play-audio", "vocabulary", props.card.word);
      }
    };
    onMounted(() => {
      initializeGame();
    });
    watch(() => props.card, () => {
      initializeGame();
    }, { deep: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "text-center w-full h-full flex flex-col justify-center items-center gap-1 sm:gap-2 p-2 sm:p-3 md:p-4 xl:p-3 2xl:p-4 overflow-hidden",
        onCopy: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createBaseVNode("div", _hoisted_1$3, [
          createBaseVNode("span", _hoisted_2$2, toDisplayString$1(_ctx.card?.category ? _ctx.getTopicName(_ctx.card.category) : ""), 1)
        ]),
        createBaseVNode("h2", _hoisted_3$1, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.title", "Words Crush: Anagram Challenge")), 1),
        createBaseVNode("p", _hoisted_4$1, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.instruction", "Fill in the missing letters to complete the word")), 1),
        createBaseVNode("div", _hoisted_5, [
          createBaseVNode("p", _hoisted_6, toDisplayString$1(_ctx.card?.pronunciation), 1),
          createBaseVNode("p", _hoisted_7, toDisplayString$1(_ctx.card?.meaning), 1)
        ]),
        createBaseVNode("div", _hoisted_8, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(wordSlots.value, (slot, index) => {
            return openBlock(), createElementBlock("div", {
              key: index,
              class: "relative"
            }, [
              !slot.separator ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(["w-8 h-8 sm:w-10 sm:h-10 md:w-12 md:h-12 xl:w-10 xl:h-10 2xl:w-11 2xl:h-11 border-2 border-purple-300 dark:border-purple-600 rounded-lg flex items-center justify-center text-sm sm:text-lg md:text-xl xl:text-lg 2xl:text-xl font-bold transition-all duration-200", {
                  "border-green-500 bg-green-50 dark:bg-green-900/20": slot.correct,
                  "border-red-500 bg-red-50 dark:bg-red-900/20": slot.incorrect,
                  "bg-white dark:bg-dark-bg": !slot.correct && !slot.incorrect && !slot.filled,
                  "bg-purple-50 dark:bg-purple-900/20 border-purple-500": slot.filled,
                  "bg-yellow-50 dark:bg-yellow-900/20 border-yellow-400": slot.revealed && !gameCompleted.value
                }])
              }, [
                !slot.filled && !slot.revealed ? withDirectives((openBlock(), createElementBlock("input", {
                  key: 0,
                  "onUpdate:modelValue": ($event) => slot.userInput = $event,
                  onInput: ($event) => handleLetterInput(index, $event),
                  onKeydown: ($event) => handleKeyDown(index, $event),
                  type: "text",
                  maxlength: "1",
                  class: "w-full h-full bg-transparent text-center text-sm sm:text-lg md:text-xl xl:text-lg 2xl:text-xl font-bold uppercase border-none outline-none text-gray-900 dark:text-white placeholder-gray-400 dark:placeholder-gray-500",
                  ref_for: true,
                  ref: "letterInput",
                  placeholder: "?"
                }, null, 40, _hoisted_9)), [
                  [vModelText, slot.userInput]
                ]) : slot.filled ? (openBlock(), createElementBlock("span", _hoisted_10, toDisplayString$1(slot.char), 1)) : (openBlock(), createElementBlock("span", _hoisted_11, toDisplayString$1(slot.char), 1))
              ], 2)) : (openBlock(), createElementBlock("div", _hoisted_12))
            ]);
          }), 128))
        ]),
        createBaseVNode("div", _hoisted_13, [
          createBaseVNode("button", {
            onClick: playPronunciation,
            class: "px-2 py-0.5 md:px-3 md:py-1 xl:px-3 xl:py-1 2xl:px-3 2xl:py-1 text-xs sm:text-sm xl:text-sm 2xl:text-sm bg-blue-600 hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800 text-white rounded font-medium transition-colors flex items-center gap-1"
          }, [
            _cache[3] || (_cache[3] = createBaseVNode("svg", {
              class: "w-3 h-3 xl:w-3 xl:h-3 2xl:w-3 2xl:h-3",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.773l-4.146-3.382a.5.5 0 00-.319-.118H2a1 1 0 01-1-1V8a1 1 0 011-1h1.918a.5.5 0 00.319-.118l4.146-3.382zM14 5a1 1 0 011 1v8a1 1 0 11-2 0V6a1 1 0 011-1zm2.025 1.13a1 1 0 011.414.057 7 7 0 010 9.816 1 1 0 11-1.471-1.358 5 5 0 000-7.1 1 1 0 01.057-1.415zM16.5 8.5a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1z",
                "clip-rule": "evenodd"
              })
            ], -1)),
            createTextVNode(" " + toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.playSound", "Play Sound")), 1)
          ])
        ]),
        createBaseVNode("div", _hoisted_14, [
          !gameCompleted.value ? (openBlock(), createElementBlock("button", {
            key: 0,
            onClick: checkAnswer,
            disabled: !canCheckAnswer.value,
            class: "px-3 py-1.5 text-sm bg-gradient-to-r from-purple-600 to-purple-700 hover:from-purple-700 hover:to-purple-800 text-white rounded-lg font-medium transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed shadow-lg"
          }, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.checkAnswer", "Check Answer")), 9, _hoisted_15)) : createCommentVNode("", true),
          !gameCompleted.value && hintsUsed.value < maxHints ? (openBlock(), createElementBlock("button", {
            key: 1,
            onClick: revealHint,
            class: "px-3 py-1.5 text-sm bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 text-white rounded-lg font-medium transition-all duration-200 shadow-lg"
          }, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.hint", "Hint")) + " (" + toDisplayString$1(hintsUsed.value) + "/" + toDisplayString$1(maxHints) + ") ", 1)) : createCommentVNode("", true),
          createBaseVNode("button", {
            onClick: resetGame,
            class: "px-3 py-1.5 text-sm bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white rounded-lg font-medium transition-all duration-200 shadow-lg"
          }, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.reset", "Reset")), 1)
        ]),
        gameCompleted.value ? (openBlock(), createElementBlock("div", _hoisted_16, [
          isCorrect.value ? (openBlock(), createElementBlock("p", _hoisted_17, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.correct", " Correct!")), 1)) : (openBlock(), createElementBlock("p", _hoisted_18, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.tryAgain", "Try Again!")), 1)),
          createBaseVNode("div", _hoisted_19, [
            createBaseVNode("p", _hoisted_20, [
              createBaseVNode("span", _hoisted_21, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.correctWord", "Word")) + ":", 1),
              createBaseVNode("span", _hoisted_22, toDisplayString$1(_ctx.card?.word), 1)
            ]),
            createBaseVNode("p", _hoisted_23, [
              createBaseVNode("span", _hoisted_24, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.meaning", "Meaning")) + ":", 1),
              createBaseVNode("span", _hoisted_25, toDisplayString$1(_ctx.card?.meaning), 1)
            ])
          ])
        ])) : createCommentVNode("", true)
      ], 32);
    };
  }
});

const WordsCrushMode = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-b9d619f0"]]);

const WordsCrushMode$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: WordsCrushMode
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$2 = ["aria-label"];
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "VocabularyNoteButton",
  props: {
    date: {},
    isToday: { type: Boolean }
  },
  emits: ["open-note-dialog"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const props = __props;
    const emit = __emit;
    const openNoteDialog = () => {
      emit("open-note-dialog", props.date);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        onClick: openNoteDialog,
        class: "flex items-center space-x-1 md:space-x-1.5 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 text-xs md:text-sm lg:text-base xl:text-sm 2xl:text-base font-medium text-green-600 dark:text-green-400 hover:text-green-800 dark:hover:text-green-200 hover:bg-green-50 dark:hover:bg-green-900/50 rounded-full border border-dashed border-green-300 dark:border-green-600 hover:border-green-400 dark:hover:border-green-500 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500",
        "aria-label": unref(t)("vocabulary.notes.manageNotes", "Manage Notes")
      }, [
        _cache[0] || (_cache[0] = createBaseVNode("svg", {
          class: "w-3 md:w-4 lg:w-4 xl:w-5 xl:h-5 2xl:w-6 2xl:h-6 h-3 md:h-4 lg:h-4",
          fill: "currentColor",
          viewBox: "0 0 20 20"
        }, [
          createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
        ], -1)),
        createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.notes.manageNotes", "Manage Notes")), 1)
      ], 8, _hoisted_1$2);
    };
  }
});

const VocabularyNoteButton = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$2
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$1 = ["aria-label"];
const _hoisted_2$1 = { class: "hidden xs:inline" };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "GrammarManagerButton",
  props: {
    date: {}
  },
  emits: ["openGrammarManager"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const props = __props;
    const emit = __emit;
    const openGrammarManager = () => {
      emit("openGrammarManager", props.date);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        onClick: openGrammarManager,
        class: "flex items-center space-x-1 md:space-x-1.5 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 text-xs md:text-sm lg:text-base xl:text-sm 2xl:text-base font-medium text-purple-600 dark:text-purple-400 hover:text-purple-800 dark:hover:text-purple-200 hover:bg-purple-50 dark:hover:bg-purple-900/50 rounded-full border border-dashed border-purple-300 dark:border-purple-600 hover:border-purple-400 dark:hover:border-purple-500 transition-colors focus:outline-none focus:ring-2 focus:ring-purple-500",
        "aria-label": unref(t)("grammar.manager.manageGrammar", "Manage Grammar")
      }, [
        _cache[0] || (_cache[0] = createBaseVNode("svg", {
          class: "w-3 md:w-4 lg:w-4 xl:w-5 xl:h-5 2xl:w-6 2xl:h-6 h-3 md:h-4 lg:h-4",
          fill: "none",
          stroke: "currentColor",
          viewBox: "0 0 24 24"
        }, [
          createBaseVNode("path", {
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            "stroke-width": "2",
            d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
          })
        ], -1)),
        createBaseVNode("span", _hoisted_2$1, toDisplayString$1(unref(t)("grammar.manager.manageGrammar", "Manage Grammar")), 1)
      ], 8, _hoisted_1$1);
    };
  }
});

const GrammarManagerButton = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$1
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1 = { class: "relative inline-flex items-center justify-center" };
const _hoisted_2 = ["width", "height", "viewBox"];
const _hoisted_3 = ["cx", "cy", "r", "stroke-width"];
const _hoisted_4 = ["cx", "cy", "r", "stroke-width", "stroke-dasharray", "stroke-dashoffset"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "CircularProgress",
  props: {
    percentage: { default: 0 },
    size: { default: 48 },
    strokeWidth: { default: 4 },
    color: { default: "" },
    showText: { type: Boolean, default: true },
    customText: { default: "" }
  },
  setup(__props) {
    const props = __props;
    const radius = computed(() => (props.size - props.strokeWidth) / 2);
    const circumference = computed(() => radius.value * 2 * Math.PI);
    const strokeDashoffset = computed(() => {
      const progress = Math.min(Math.max(props.percentage, 0), 100);
      return circumference.value - progress / 100 * circumference.value;
    });
    const progressColor = computed(() => {
      if (props.color) return props.color;
      if (props.percentage >= 100) {
        return "text-green-500 dark:text-green-400";
      } else if (props.percentage >= 70) {
        return "text-blue-500 dark:text-blue-400";
      } else if (props.percentage >= 40) {
        return "text-yellow-500 dark:text-yellow-400";
      } else {
        return "text-orange-500 dark:text-orange-400";
      }
    });
    const textColor = computed(() => {
      if (props.percentage >= 100) {
        return "text-green-600 dark:text-green-300";
      } else if (props.percentage >= 70) {
        return "text-blue-600 dark:text-blue-300";
      } else if (props.percentage >= 40) {
        return "text-yellow-600 dark:text-yellow-300";
      } else {
        return "text-orange-600 dark:text-orange-300";
      }
    });
    const textSizeClass = computed(() => {
      if (props.size <= 32) {
        return "text-xs";
      } else if (props.size <= 48) {
        return "text-sm";
      } else if (props.size <= 64) {
        return "text-base";
      } else {
        return "text-lg";
      }
    });
    const displayValue = computed(() => {
      if (props.customText) {
        return props.customText;
      }
      if (!props.showText) {
        return "";
      }
      return `${Math.round(props.percentage)}%`;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        (openBlock(), createElementBlock("svg", {
          width: _ctx.size,
          height: _ctx.size,
          class: "transform -rotate-90",
          viewBox: `0 0 ${_ctx.size} ${_ctx.size}`
        }, [
          createBaseVNode("circle", {
            cx: _ctx.size / 2,
            cy: _ctx.size / 2,
            r: radius.value,
            stroke: "currentColor",
            "stroke-width": _ctx.strokeWidth,
            fill: "transparent",
            class: "text-gray-200 dark:text-dark-bg-mute opacity-50"
          }, null, 8, _hoisted_3),
          createBaseVNode("circle", {
            cx: _ctx.size / 2,
            cy: _ctx.size / 2,
            r: radius.value,
            stroke: "currentColor",
            "stroke-width": _ctx.strokeWidth,
            fill: "transparent",
            "stroke-dasharray": circumference.value,
            "stroke-dashoffset": strokeDashoffset.value,
            class: normalizeClass([progressColor.value, "transition-all duration-500 ease-in-out"]),
            "stroke-linecap": "round"
          }, null, 10, _hoisted_4)
        ], 8, _hoisted_2)),
        createBaseVNode("div", {
          class: normalizeClass(["absolute inset-0 flex items-center justify-center z-10", textSizeClass.value])
        }, [
          createBaseVNode("span", {
            class: normalizeClass(["font-bold transition-colors duration-300 bg-white dark:bg-dark-bg rounded-full px-0.5 py-0.5 shadow-sm", textColor.value]),
            style: { "line-height": "1" }
          }, toDisplayString$1(displayValue.value), 3)
        ], 2)
      ]);
    };
  }
});

const CircularProgress = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-938779d2"]]);

const CircularProgress$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: CircularProgress
}, Symbol.toStringTag, { value: 'Module' }));
