true              &&(function polyfill() {
	const relList = document.createElement("link").relList;
	if (relList && relList.supports && relList.supports("modulepreload")) return;
	for (const link of document.querySelectorAll("link[rel=\"modulepreload\"]")) processPreload(link);
	new MutationObserver((mutations) => {
		for (const mutation of mutations) {
			if (mutation.type !== "childList") continue;
			for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
		}
	}).observe(document, {
		childList: true,
		subtree: true
	});
	function getFetchOpts(link) {
		const fetchOpts = {};
		if (link.integrity) fetchOpts.integrity = link.integrity;
		if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
		if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
		else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
		else fetchOpts.credentials = "same-origin";
		return fetchOpts;
	}
	function processPreload(link) {
		if (link.ep) return;
		link.ep = true;
		const fetchOpts = getFetchOpts(link);
		fetch(link.href, fetchOpts);
	}
}());

/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn$1 = (val, key) => hasOwnProperty$2.call(val, key);
const isArray$2 = Array.isArray;
const isMap = (val) => toTypeString$1(val) === "[object Map]";
const isSet = (val) => toTypeString$1(val) === "[object Set]";
const isDate$1 = (val) => toTypeString$1(val) === "[object Date]";
const isFunction$2 = (val) => typeof val === "function";
const isString$3 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$3 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return (isObject$3(val) || isFunction$2(val)) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString$1 = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString$1(value).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString$1(val) === "[object Object]";
const isIntegerKey = (key) => isString$3(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize$1 = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize$1(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString$3(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis$1;
const getGlobalThis$1 = () => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray$2(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$3(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$3(value) || isObject$3(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$3(value)) {
    res = value;
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$3(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate$1(a);
  let bValidType = isDate$1(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray$2(a);
  bValidType = isArray$2(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$3(a);
  bValidType = isObject$3(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString$1 = (val) => {
  return isString$3(val) ? val : val == null ? "" : isArray$2(val) || isObject$3(val) && (val.toString === objectToString$1 || !isFunction$2(val.toString)) ? isRef$1(val) ? toDisplayString$1(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$3(val) && !isArray$2(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};

/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this._on = 0;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = void 0;
    }
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed2) {
  if (computed2.flags & 4 && !(computed2.flags & 16)) {
    return;
  }
  computed2.flags &= -17;
  if (computed2.globalVersion === globalVersion) {
    return;
  }
  computed2.globalVersion = globalVersion;
  if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
    return;
  }
  computed2.flags |= 2;
  const dep = computed2.dep;
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed2;
  shouldTrack = true;
  try {
    prepareDeps(computed2);
    const value = computed2.fn(computed2._value);
    if (dep.version === 0 || hasChanged(value, computed2._value)) {
      computed2.flags |= 128;
      computed2._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed2);
    computed2.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  // TODO isolatedDeclarations "__v_skip"
  constructor(computed2) {
    this.computed = computed2;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
    this.__v_skip = true;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false) ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed2 = link.dep.computed;
    if (computed2 && !link.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l = computed2.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray$2(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray$2(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toReactive(value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply$1(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply$1(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
  },
  find(fn, thisArg) {
    return apply$1(this, "find", fn, thisArg, toReactive, arguments);
  },
  findIndex(fn, thisArg) {
    return apply$1(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply$1(this, "findLast", fn, thisArg, toReactive, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply$1(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply$1(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply$1(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply$1(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self, method, wrapValue) {
  const arr = shallowReadArray(self);
  const iter = arr[method]();
  if (arr !== self && !isShallow(self)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply$1(self, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self);
  const needsWrap = arr !== self && !isShallow(self);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toReactive(item), index, self);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self, method, fn, args) {
  const arr = shallowReadArray(self);
  let wrappedFn = fn;
  if (arr !== self) {
    if (!isShallow(self)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toReactive(item), index, self);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self, method, args) {
  const arr = toRaw(self);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self)[method].apply(self, args);
  endBatch();
  resetTracking();
  return res;
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty$1(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$2(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$3(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$1(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn$1(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$2(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend$1(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0);
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn$1(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$3(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!hasOwn$1(value, "__v_skip") && Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject$3(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$3(value) ? readonly(value) : value;
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  const ret = isArray$2(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
  }
  get value() {
    const val = this._object[this._key];
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this["__v_isRef"] = true;
    this["__v_isReadonly"] = true;
    this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction$2(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$3(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction$2(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$2(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction$2(s)) {
        return call ? call(s, 2) : s();
      } else ;
    });
  } else if (isFunction$2(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope && scope.active) {
      remove(scope.effects, effect2);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          oldValue = newValue;
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !isObject$3(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if (isPlainObject$2(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}

/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$3(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$2(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$2(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray$2(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex$1(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId$1(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId$1(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId$1(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex$1(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$2(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= -2;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId$1(a) - getId$1(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= -2;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId$1 = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false) ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= -2;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction$2(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$3(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          if (parentComponent && parentComponent.isCE) {
            parentComponent.ce._teleportTarget = container2;
          }
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace !== "svg" && isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (!disabled) {
            mount(target, targetAnchor);
            updateCssVars(n2, false);
          }
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        n2.el.__isMounted = false;
        queuePostRenderEffect(() => {
          mountToTarget();
          delete n2.el.__isMounted;
        }, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
        queuePostRenderEffect(() => {
          TeleportImpl.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        }, parentSuspense);
        return;
      }
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const disabled = isTeleportDisabled(vnode.props);
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetStart = targetNode;
        vnode.targetAnchor = targetNode && nextSibling(targetNode);
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c of children) {
      if (c.type !== Comment) {
        child = c;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$2(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  if (vnode.component) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction$2(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction$2(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$2(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
    return hasOwn$1(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref3) {
    if (isString$3(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$2(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString$3(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$2(existing) && remove(existing, refValue);
          } else {
            if (!isArray$2(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (canSetSetupRef(ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          ref3.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const isComment = (node) => node.nodeType === 8;
getGlobalThis$1().requestIdleCallback || ((cb) => setTimeout(cb, 1));
getGlobalThis$1().cancelIdleCallback || ((id) => clearTimeout(id));
function forEachElement(node, cb) {
  if (isComment(node) && node.data === "[") {
    let depth = 1;
    let next = node.nextSibling;
    while (next) {
      if (next.nodeType === 1) {
        const result = cb(next);
        if (result === false) {
          break;
        }
      } else if (isComment(next)) {
        if (next.data === "]") {
          if (--depth === 0) break;
        } else if (next.data === "[") {
          depth++;
        }
      }
      next = next.nextSibling;
    }
  } else {
    cb(node);
  }
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if (isFunction$2(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    hydrate: hydrateStrategy,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return /* @__PURE__ */ defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    __asyncHydrate(el, instance, hydrate) {
      const doHydrate = hydrateStrategy ? () => {
        const performHydrate = () => {
          hydrate();
        };
        const teardown = hydrateStrategy(
          performHydrate,
          (cb) => forEachElement(el, cb)
        );
        if (teardown) {
          (instance.bum || (instance.bum = [])).push(teardown);
        }
        (instance.u || (instance.u = [])).push(() => true);
      } : hydrate;
      if (resolvedComp) {
        doHydrate();
      } else {
        load().then(() => !instance.isUnmounted && doHydrate());
      }
    },
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      markAsyncBoundary(instance);
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.update();
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref22, props, children, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref22;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$3(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize$1(name) || selfName === capitalize$1(camelize$1(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize$1(name)] || registry[capitalize$1(camelize$1(name))]);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache;
  const sourceIsArray = isArray$2(source);
  if (sourceIsArray || isString$3(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    let isReadonlySource = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      isReadonlySource = isReadonly(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? isReadonlySource ? toReadonly(toReactive(source[i])) : toReactive(source[i]) : source[i],
        i,
        void 0,
        cached
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached);
    }
  } else if (isObject$3(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached)
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback)],
      64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || ([]),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode$1(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i) ,
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i) 
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn$1(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$1(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn$1(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray$2(props) ? props.reduce(
    (normalized, p) => (normalized[p] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$2(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$3(data)) ; else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$2(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$2(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$2(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$3(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$3(raw)) {
    const handler = ctx[raw];
    if (isFunction$2(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (isFunction$2(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject$3(raw)) {
    if (isArray$2(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$2(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions$1(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  if (isObject$3(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions$1(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions$1(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ; else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$1(
      isFunction$2(to) ? to.call(this, this) : to,
      isFunction$2(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$2(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$2(to) && isArray$2(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend$1(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (!isFunction$2(rootComponent)) {
      rootComponent = extend$1({}, rootComponent);
    }
    if (rootProps != null && !isObject$3(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$1,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ; else if (plugin && isFunction$2(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$2(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance) ; else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn$1(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize$1(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$1(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn$1(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn$1(options, camelKey = camelize$1(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn$1(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn$1(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$3(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$2(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize$1(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize$1(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? { type: opt } : extend$1({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray$2(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = isFunction$2(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction$2(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn$1(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$3(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot$1 = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if (isFunction$2(value)) {
      slots[key] = normalizeSlot$1(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || !isInternalKey(key)) {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const cacheIndexes = children.__;
    if (cacheIndexes) def(slots, "__", cacheIndexes, true);
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis$1();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    } else if (ref3 == null && n1 && n1.ref != null) {
      setRef(n1.ref, null, parentSuspense, n1, true);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        {
          if (root.ce && // @ts-expect-error _def is private
          root.ce._def.shadowRoot !== false) {
            root.ce._injectChildStyle(type);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance.scope.on();
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect2.run.bind(effect2);
    const job = instance.job = effect2.runIfDirty.bind(effect2);
    job.i = instance;
    job.id = instance.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => {
          if (vnode.ctx.isUnmounted) {
            hostRemove(el);
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      pauseTracking();
      setRef(ref3, null, parentSuspense, vnode, true);
      resetTracking();
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const {
      bum,
      scope,
      job,
      subTree,
      um,
      m,
      a,
      parent,
      slots: { __: slotCacheKeys }
    } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    if (parent && isArray$2(slotCacheKeys)) {
      slotCacheKeys.forEach((v) => {
        parent.renderCache[v] = void 0;
      });
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  return {
    render,
    hydrate,
    createApp: createAppAPI(render)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= -33;
    job.flags &= -5;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$2(ch1) && isArray$2(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend$1({}, options);
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$3(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$2(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize$1(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit$1(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => isString$3(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize$1(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$3(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray$2(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$3(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false) ;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render2(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root, vnode.transition);
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$2(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode$1(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$3(ref3) || isRef(ref3) || isFunction$2(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$3(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode$1(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$3(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$3(style)) {
      if (isProxy(style) && !isArray$2(style)) {
        style = extend$1({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$3(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$3(type) ? 4 : isFunction$2(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend$1({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$2(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode$1(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$2(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$2(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis$1();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1) setters.forEach((set) => set(v));
      else setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized || isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    pauseTracking();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = isPromise$1(setupResult);
    resetTracking();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult);
    }
  } else {
    finishComponentSetup(instance);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$2(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$3(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance);
}
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    instance.render = Component.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$2(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c;
};
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$3(propsOrChildren) && !isArray$2(propsOrChildren)) {
      if (isVNode$1(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode$1(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const version$1 = "3.5.17";

/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION$1 = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend$1(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if (isArray$2(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done, isCancelled) => {
    el._enterCancelled = isCancelled;
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };
  return extend$1(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      if (!el._enterCancelled) {
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
      } else {
        addTransitionClass(el, leaveActiveClass);
        forceReflow();
      }
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false, void 0, true);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true, void 0, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$3(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION$1}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION$1}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION$1) {
    if (transitionTimeout > 0) {
      type = TRANSITION$1;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION$1 : ANIMATION : null;
    propCount = type ? type === TRANSITION$1 ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION$1 && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION$1}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
const CSS_VAR_TEXT = Symbol("");
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    if (instance.ce) {
      setVarsOnNode(instance.ce, vars);
    } else {
      setVarsOnVNode(instance.subTree, vars);
    }
    updateTeleports(vars);
  };
  onBeforeUpdate(() => {
    queuePostFlushCb(setVars);
  });
  onMounted(() => {
    watch(setVars, NOOP, { flush: "post" });
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
      cssText += `--${key}: ${vars[key]};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString$3(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString$3(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray$2(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null) val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize$1(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean ? "" : isSymbol(value) ? String(value) : value
      );
    }
  }
}
function patchDOMProp(el, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(attrName || key);
}
function addEventListener$1(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener$1(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener$1(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener$1(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$2(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString$3(nextValue))
  ) {
    patchDOMProp(el, camelize$1(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$2(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$3(value)) {
    return false;
  }
  return key in el;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const decorate = (t) => {
  delete t.props.mode;
  return t;
};
const TransitionGroupImpl = /* @__PURE__ */ decorate({
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        prevChildren = [];
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
      prevChildren = [];
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = [];
      if (children) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            setTransitionHooks(
              child,
              resolveTransitionHooks(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        }
      }
      return createVNode(tag, null, children);
    };
  }
});
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$2(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener$1(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing) return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener$1(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener$1(el, "compositionstart", onCompositionStart);
      addEventListener$1(el, "compositionend", onCompositionEnd);
      addEventListener$1(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value === oldValue) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener$1(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el[assignKey];
      if (isArray$2(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  let checked;
  if (isArray$2(value)) {
    checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    checked = value.has(vnode.props.value);
  } else {
    if (value === oldValue) return;
    checked = looseEqual(value, getCheckboxValue(el, true));
  }
  if (el.checked !== checked) {
    el.checked = checked;
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener$1(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener$1(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? looseToNumber(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    if (!el._assigning) {
      setSelected(el, value);
    }
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  const isArrayValue = isArray$2(value);
  if (isMultiple && !isArrayValue && !isSet(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option.selected = value.some((v) => String(v) === String(optionValue));
        } else {
          option.selected = looseIndexOf(value, optionValue) > -1;
        }
      } else {
        option.selected = value.has(optionValue);
      }
    } else if (looseEqual(getValue(option), value)) {
      if (el.selectedIndex !== i) el.selectedIndex = i;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  const cache = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some(
      (k) => k === eventKey || keyNames[k] === eventKey
    )) {
      return fn(event);
    }
  });
};
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;
    if (!isFunction$2(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString$3(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}

/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia;
const setActivePinia = (pinia) => activePinia = pinia;
const piniaSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject$1(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia = markRaw({
    install(app) {
      setActivePinia(pinia);
      pinia._a = app;
      app.provide(piniaSymbol, pinia);
      app.config.globalProperties.$pinia = pinia;
      toBeInstalled.forEach((plugin) => _p.push(plugin));
      toBeInstalled = [];
    },
    use(plugin) {
      if (!this._a) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  return pinia;
}
const noop$1 = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop$1) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
const fallbackRunWithContext = (fn) => fn();
const ACTION_MARKER = Symbol();
const ACTION_NAME = Symbol();
function mergeReactiveObjects(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value, key) => target.set(key, value));
  } else if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function shouldHydrate(obj) {
  return !isPlainObject$1(obj) || !Object.prototype.hasOwnProperty.call(obj, skipHydrateSymbol);
}
const { assign: assign$3 } = Object;
function isComputed(o) {
  return !!(isRef(o) && o.effect);
}
function createOptionsStore(id, options, pinia, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia.state.value[id];
  let store;
  function setup() {
    if (!initialState && true) {
      pinia.state.value[id] = state ? state() : {};
    }
    const localState = toRefs(pinia.state.value[id]);
    return assign$3(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia);
        const store2 = pinia._s.get(id);
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id, setup, options, pinia, hot, true);
  return store;
}
function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$3({ actions: {} }, options);
  const $subscribeOptions = { deep: true };
  let isListening;
  let isSyncListening;
  let subscriptions = [];
  let actionSubscriptions = [];
  let debuggerEvents;
  const initialState = pinia.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    pinia.state.value[$id] = {};
  }
  ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state } = options;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign$3($state, newState);
    });
  } : (
    /* istanbul ignore next */
    noop$1
  );
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia._s.delete($id);
  }
  const action = (fn, name = "") => {
    if (ACTION_MARKER in fn) {
      fn[ACTION_NAME] = name;
      return fn;
    }
    const wrappedAction = function() {
      setActivePinia(pinia);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name: wrappedAction[ACTION_NAME],
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = fn.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          triggerSubscriptions(afterCallbackList, value);
          return value;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
    wrappedAction[ACTION_MARKER] = true;
    wrappedAction[ACTION_NAME] = name;
    return wrappedAction;
  };
  const partialStore = {
    _p: pinia,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign$3({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(partialStore);
  pinia._s.set($id, store);
  const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
  const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup({ action }))));
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        pinia.state.value[$id][key] = prop;
      }
    } else if (typeof prop === "function") {
      const actionValue = action(prop, key);
      setupStore[key] = actionValue;
      optionsForPlugin.actions[key] = prop;
    } else ;
  }
  assign$3(store, setupStore);
  assign$3(toRaw(store), setupStore);
  Object.defineProperty(store, "$state", {
    get: () => pinia.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        assign$3($state, state);
      });
    }
  });
  pinia._p.forEach((extender) => {
    {
      assign$3(store, scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineStore(id, setup, setupOptions) {
  let options;
  const isSetupStore = typeof setup === "function";
  options = isSetupStore ? setupOptions : setup;
  function useStore(pinia, hot) {
    const hasContext = hasInjectionContext();
    pinia = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    (pinia) || (hasContext ? inject(piniaSymbol, null) : null);
    if (pinia)
      setActivePinia(pinia);
    pinia = activePinia;
    if (!pinia._s.has(id)) {
      if (isSetupStore) {
        createSetupStore(id, setup, options, pinia);
      } else {
        createOptionsStore(id, options, pinia);
      }
    }
    const store = pinia._s.get(id);
    return store;
  }
  useStore.$id = id;
  return useStore;
}

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var isFunction$1 = (value) => typeof value === "function";
var isString$2 = (value) => typeof value === "string";
var isNonEmptyString = (value) => isString$2(value) && value.trim().length > 0;
var isNumber$1 = (value) => typeof value === "number";
var isUndefined = (value) => typeof value === "undefined";
var isObject$2 = (value) => typeof value === "object" && value !== null;
var isJSX = (obj) => hasProp(obj, "tag") && isNonEmptyString(obj.tag);
var isTouchEvent = (event) => window.TouchEvent && event instanceof TouchEvent;
var isToastComponent = (obj) => hasProp(obj, "component") && isToastContent(obj.component);
var isVueComponent = (c) => isFunction$1(c) || isObject$2(c);
var isToastContent = (obj) => !isUndefined(obj) && (isString$2(obj) || isVueComponent(obj) || isToastComponent(obj));
var isDOMRect = (obj) => isObject$2(obj) && ["height", "width", "right", "left", "top", "bottom"].every((p) => isNumber$1(obj[p]));
var hasProp = (obj, propKey) => (isObject$2(obj) || isFunction$1(obj)) && propKey in obj;
var getId = ((i) => () => i++)(0);
function getX(event) {
  return isTouchEvent(event) ? event.targetTouches[0].clientX : event.clientX;
}
function getY(event) {
  return isTouchEvent(event) ? event.targetTouches[0].clientY : event.clientY;
}
var removeElement = (el) => {
  if (!isUndefined(el.remove)) {
    el.remove();
  } else if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
};
var getVueComponentFromObj = (obj) => {
  if (isToastComponent(obj)) {
    return getVueComponentFromObj(obj.component);
  }
  if (isJSX(obj)) {
    return defineComponent({
      render() {
        return obj;
      }
    });
  }
  return typeof obj === "string" ? obj : toRaw(unref(obj));
};
var normalizeToastComponent = (obj) => {
  if (typeof obj === "string") {
    return obj;
  }
  const props = hasProp(obj, "props") && isObject$2(obj.props) ? obj.props : {};
  const listeners = hasProp(obj, "listeners") && isObject$2(obj.listeners) ? obj.listeners : {};
  return { component: getVueComponentFromObj(obj), props, listeners };
};
var isBrowser$1 = () => typeof window !== "undefined";

// src/ts/eventBus.ts
var EventBus = class {
  constructor() {
    this.allHandlers = {};
  }
  getHandlers(eventType) {
    return this.allHandlers[eventType] || [];
  }
  on(eventType, handler) {
    const handlers = this.getHandlers(eventType);
    handlers.push(handler);
    this.allHandlers[eventType] = handlers;
  }
  off(eventType, handler) {
    const handlers = this.getHandlers(eventType);
    handlers.splice(handlers.indexOf(handler) >>> 0, 1);
  }
  emit(eventType, event) {
    const handlers = this.getHandlers(eventType);
    handlers.forEach((handler) => handler(event));
  }
};
var isEventBusInterface = (e) => ["on", "off", "emit"].every((f) => hasProp(e, f) && isFunction$1(e[f]));

// src/ts/constants.ts
var TYPE;
(function(TYPE2) {
  TYPE2["SUCCESS"] = "success";
  TYPE2["ERROR"] = "error";
  TYPE2["WARNING"] = "warning";
  TYPE2["INFO"] = "info";
  TYPE2["DEFAULT"] = "default";
})(TYPE || (TYPE = {}));
var POSITION;
(function(POSITION2) {
  POSITION2["TOP_LEFT"] = "top-left";
  POSITION2["TOP_CENTER"] = "top-center";
  POSITION2["TOP_RIGHT"] = "top-right";
  POSITION2["BOTTOM_LEFT"] = "bottom-left";
  POSITION2["BOTTOM_CENTER"] = "bottom-center";
  POSITION2["BOTTOM_RIGHT"] = "bottom-right";
})(POSITION || (POSITION = {}));
var EVENTS;
(function(EVENTS2) {
  EVENTS2["ADD"] = "add";
  EVENTS2["DISMISS"] = "dismiss";
  EVENTS2["UPDATE"] = "update";
  EVENTS2["CLEAR"] = "clear";
  EVENTS2["UPDATE_DEFAULTS"] = "update_defaults";
})(EVENTS || (EVENTS = {}));
var VT_NAMESPACE = "Vue-Toastification";

// src/ts/propValidators.ts
var COMMON = {
  type: {
    type: String,
    default: TYPE.DEFAULT
  },
  classNames: {
    type: [String, Array],
    default: () => []
  },
  trueBoolean: {
    type: Boolean,
    default: true
  }
};
var ICON = {
  type: COMMON.type,
  customIcon: {
    type: [String, Boolean, Object, Function],
    default: true
  }
};
var CLOSE_BUTTON = {
  component: {
    type: [String, Object, Function, Boolean],
    default: "button"
  },
  classNames: COMMON.classNames,
  showOnHover: {
    type: Boolean,
    default: false
  },
  ariaLabel: {
    type: String,
    default: "close"
  }
};
var PROGRESS_BAR = {
  timeout: {
    type: [Number, Boolean],
    default: 5e3
  },
  hideProgressBar: {
    type: Boolean,
    default: false
  },
  isRunning: {
    type: Boolean,
    default: false
  }
};
var TRANSITION = {
  transition: {
    type: [Object, String],
    default: `${VT_NAMESPACE}__bounce`
  }
};
var CORE_TOAST = {
  position: {
    type: String,
    default: POSITION.TOP_RIGHT
  },
  draggable: COMMON.trueBoolean,
  draggablePercent: {
    type: Number,
    default: 0.6
  },
  pauseOnFocusLoss: COMMON.trueBoolean,
  pauseOnHover: COMMON.trueBoolean,
  closeOnClick: COMMON.trueBoolean,
  timeout: PROGRESS_BAR.timeout,
  hideProgressBar: PROGRESS_BAR.hideProgressBar,
  toastClassName: COMMON.classNames,
  bodyClassName: COMMON.classNames,
  icon: ICON.customIcon,
  closeButton: CLOSE_BUTTON.component,
  closeButtonClassName: CLOSE_BUTTON.classNames,
  showCloseButtonOnHover: CLOSE_BUTTON.showOnHover,
  accessibility: {
    type: Object,
    default: () => ({
      toastRole: "alert",
      closeButtonLabel: "close"
    })
  },
  rtl: {
    type: Boolean,
    default: false
  },
  eventBus: {
    type: Object,
    required: false,
    default: () => new EventBus()
  }
};
var TOAST = {
  id: {
    type: [String, Number],
    required: true,
    default: 0
  },
  type: COMMON.type,
  content: {
    type: [String, Object, Function],
    required: true,
    default: ""
  },
  onClick: {
    type: Function,
    default: void 0
  },
  onClose: {
    type: Function,
    default: void 0
  }
};
var CONTAINER = {
  container: {
    type: [
      Object,
      Function
    ],
    default: () => document.body
  },
  newestOnTop: COMMON.trueBoolean,
  maxToasts: {
    type: Number,
    default: 20
  },
  transition: TRANSITION.transition,
  toastDefaults: Object,
  filterBeforeCreate: {
    type: Function,
    default: (toast) => toast
  },
  filterToasts: {
    type: Function,
    default: (toasts) => toasts
  },
  containerClassName: COMMON.classNames,
  onMounted: Function,
  shareAppContext: [Boolean, Object]
};
var propValidators_default = {
  CORE_TOAST,
  TOAST,
  CONTAINER,
  PROGRESS_BAR,
  ICON,
  TRANSITION,
  CLOSE_BUTTON
};
var VtProgressBar_default = defineComponent({
  name: "VtProgressBar",
  props: propValidators_default.PROGRESS_BAR,
  data() {
    return {
      hasClass: true
    };
  },
  computed: {
    style() {
      return {
        animationDuration: `${this.timeout}ms`,
        animationPlayState: this.isRunning ? "running" : "paused",
        opacity: this.hideProgressBar ? 0 : 1
      };
    },
    cpClass() {
      return this.hasClass ? `${VT_NAMESPACE}__progress-bar` : "";
    }
  },
  watch: {
    timeout() {
      this.hasClass = false;
      this.$nextTick(() => this.hasClass = true);
    }
  },
  mounted() {
    this.$el.addEventListener("animationend", this.animationEnded);
  },
  beforeUnmount() {
    this.$el.removeEventListener("animationend", this.animationEnded);
  },
  methods: {
    animationEnded() {
      this.$emit("close-toast");
    }
  }
});
function render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", {
    style: normalizeStyle(_ctx.style),
    class: normalizeClass(_ctx.cpClass)
  }, null, 6);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtProgressBar.vue
VtProgressBar_default.render = render;
var VtProgressBar_default2 = VtProgressBar_default;
var VtCloseButton_default = defineComponent({
  name: "VtCloseButton",
  props: propValidators_default.CLOSE_BUTTON,
  computed: {
    buttonComponent() {
      if (this.component !== false) {
        return getVueComponentFromObj(this.component);
      }
      return "button";
    },
    classes() {
      const classes = [`${VT_NAMESPACE}__close-button`];
      if (this.showOnHover) {
        classes.push("show-on-hover");
      }
      return classes.concat(this.classNames);
    }
  }
});
var _hoisted_1$1t = /* @__PURE__ */ createTextVNode(" \xD7 ");
function render2(_ctx, _cache) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.buttonComponent), mergeProps({
    "aria-label": _ctx.ariaLabel,
    class: _ctx.classes
  }, _ctx.$attrs), {
    default: withCtx(() => [
      _hoisted_1$1t
    ]),
    _: 1
  }, 16, ["aria-label", "class"]);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtCloseButton.vue
VtCloseButton_default.render = render2;
var VtCloseButton_default2 = VtCloseButton_default;

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtSuccessIcon.vue?vue&type=script
var VtSuccessIcon_default = {};
var _hoisted_12$10 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "check-circle",
  class: "svg-inline--fa fa-check-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
var _hoisted_2$1q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"
}, null, -1);
var _hoisted_3$1m = [
  _hoisted_2$1q
];
function render3(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_12$10, _hoisted_3$1m);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtSuccessIcon.vue
VtSuccessIcon_default.render = render3;
var VtSuccessIcon_default2 = VtSuccessIcon_default;

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtInfoIcon.vue?vue&type=script
var VtInfoIcon_default = {};
var _hoisted_13$10 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "info-circle",
  class: "svg-inline--fa fa-info-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
var _hoisted_22$O = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"
}, null, -1);
var _hoisted_32$x = [
  _hoisted_22$O
];
function render4(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_13$10, _hoisted_32$x);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtInfoIcon.vue
VtInfoIcon_default.render = render4;
var VtInfoIcon_default2 = VtInfoIcon_default;

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtWarningIcon.vue?vue&type=script
var VtWarningIcon_default = {};
var _hoisted_14$$ = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "exclamation-circle",
  class: "svg-inline--fa fa-exclamation-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
var _hoisted_23$O = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
}, null, -1);
var _hoisted_33$w = [
  _hoisted_23$O
];
function render5(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_14$$, _hoisted_33$w);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtWarningIcon.vue
VtWarningIcon_default.render = render5;
var VtWarningIcon_default2 = VtWarningIcon_default;

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtErrorIcon.vue?vue&type=script
var VtErrorIcon_default = {};
var _hoisted_15$V = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "exclamation-triangle",
  class: "svg-inline--fa fa-exclamation-triangle fa-w-18",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 576 512"
};
var _hoisted_24$M = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
}, null, -1);
var _hoisted_34$t = [
  _hoisted_24$M
];
function render6(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_15$V, _hoisted_34$t);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/icons/VtErrorIcon.vue
VtErrorIcon_default.render = render6;
var VtErrorIcon_default2 = VtErrorIcon_default;

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtIcon.vue?vue&type=script
var VtIcon_default = defineComponent({
  name: "VtIcon",
  props: propValidators_default.ICON,
  computed: {
    customIconChildren() {
      return hasProp(this.customIcon, "iconChildren") ? this.trimValue(this.customIcon.iconChildren) : "";
    },
    customIconClass() {
      if (isString$2(this.customIcon)) {
        return this.trimValue(this.customIcon);
      } else if (hasProp(this.customIcon, "iconClass")) {
        return this.trimValue(this.customIcon.iconClass);
      }
      return "";
    },
    customIconTag() {
      if (hasProp(this.customIcon, "iconTag")) {
        return this.trimValue(this.customIcon.iconTag, "i");
      }
      return "i";
    },
    hasCustomIcon() {
      return this.customIconClass.length > 0;
    },
    component() {
      if (this.hasCustomIcon) {
        return this.customIconTag;
      }
      if (isToastContent(this.customIcon)) {
        return getVueComponentFromObj(this.customIcon);
      }
      return this.iconTypeComponent;
    },
    iconTypeComponent() {
      const types = {
        [TYPE.DEFAULT]: VtInfoIcon_default2,
        [TYPE.INFO]: VtInfoIcon_default2,
        [TYPE.SUCCESS]: VtSuccessIcon_default2,
        [TYPE.ERROR]: VtErrorIcon_default2,
        [TYPE.WARNING]: VtWarningIcon_default2
      };
      return types[this.type];
    },
    iconClasses() {
      const classes = [`${VT_NAMESPACE}__icon`];
      if (this.hasCustomIcon) {
        return classes.concat(this.customIconClass);
      }
      return classes;
    }
  },
  methods: {
    trimValue(value, empty = "") {
      return isNonEmptyString(value) ? value.trim() : empty;
    }
  }
});
function render7(_ctx, _cache) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.component), {
    class: normalizeClass(_ctx.iconClasses)
  }, {
    default: withCtx(() => [
      createTextVNode(toDisplayString$1(_ctx.customIconChildren), 1)
    ]),
    _: 1
  }, 8, ["class"]);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtIcon.vue
VtIcon_default.render = render7;
var VtIcon_default2 = VtIcon_default;

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtToast.vue?vue&type=script
var VtToast_default = defineComponent({
  name: "VtToast",
  components: { ProgressBar: VtProgressBar_default2, CloseButton: VtCloseButton_default2, Icon: VtIcon_default2 },
  inheritAttrs: false,
  props: Object.assign({}, propValidators_default.CORE_TOAST, propValidators_default.TOAST),
  data() {
    const data = {
      isRunning: true,
      disableTransitions: false,
      beingDragged: false,
      dragStart: 0,
      dragPos: { x: 0, y: 0 },
      dragRect: {}
    };
    return data;
  },
  computed: {
    classes() {
      const classes = [
        `${VT_NAMESPACE}__toast`,
        `${VT_NAMESPACE}__toast--${this.type}`,
        `${this.position}`
      ].concat(this.toastClassName);
      if (this.disableTransitions) {
        classes.push("disable-transition");
      }
      if (this.rtl) {
        classes.push(`${VT_NAMESPACE}__toast--rtl`);
      }
      return classes;
    },
    bodyClasses() {
      const classes = [
        `${VT_NAMESPACE}__toast-${isString$2(this.content) ? "body" : "component-body"}`
      ].concat(this.bodyClassName);
      return classes;
    },
    draggableStyle() {
      if (this.dragStart === this.dragPos.x) {
        return {};
      } else if (this.beingDragged) {
        return {
          transform: `translateX(${this.dragDelta}px)`,
          opacity: 1 - Math.abs(this.dragDelta / this.removalDistance)
        };
      } else {
        return {
          transition: "transform 0.2s, opacity 0.2s",
          transform: "translateX(0)",
          opacity: 1
        };
      }
    },
    dragDelta() {
      return this.beingDragged ? this.dragPos.x - this.dragStart : 0;
    },
    removalDistance() {
      if (isDOMRect(this.dragRect)) {
        return (this.dragRect.right - this.dragRect.left) * this.draggablePercent;
      }
      return 0;
    }
  },
  mounted() {
    if (this.draggable) {
      this.draggableSetup();
    }
    if (this.pauseOnFocusLoss) {
      this.focusSetup();
    }
  },
  beforeUnmount() {
    if (this.draggable) {
      this.draggableCleanup();
    }
    if (this.pauseOnFocusLoss) {
      this.focusCleanup();
    }
  },
  methods: {
    hasProp,
    getVueComponentFromObj,
    closeToast() {
      this.eventBus.emit(EVENTS.DISMISS, this.id);
    },
    clickHandler() {
      if (this.onClick) {
        this.onClick(this.closeToast);
      }
      if (this.closeOnClick) {
        if (!this.beingDragged || this.dragStart === this.dragPos.x) {
          this.closeToast();
        }
      }
    },
    timeoutHandler() {
      this.closeToast();
    },
    hoverPause() {
      if (this.pauseOnHover) {
        this.isRunning = false;
      }
    },
    hoverPlay() {
      if (this.pauseOnHover) {
        this.isRunning = true;
      }
    },
    focusPause() {
      this.isRunning = false;
    },
    focusPlay() {
      this.isRunning = true;
    },
    focusSetup() {
      addEventListener("blur", this.focusPause);
      addEventListener("focus", this.focusPlay);
    },
    focusCleanup() {
      removeEventListener("blur", this.focusPause);
      removeEventListener("focus", this.focusPlay);
    },
    draggableSetup() {
      const element = this.$el;
      element.addEventListener("touchstart", this.onDragStart, {
        passive: true
      });
      element.addEventListener("mousedown", this.onDragStart);
      addEventListener("touchmove", this.onDragMove, { passive: false });
      addEventListener("mousemove", this.onDragMove);
      addEventListener("touchend", this.onDragEnd);
      addEventListener("mouseup", this.onDragEnd);
    },
    draggableCleanup() {
      const element = this.$el;
      element.removeEventListener("touchstart", this.onDragStart);
      element.removeEventListener("mousedown", this.onDragStart);
      removeEventListener("touchmove", this.onDragMove);
      removeEventListener("mousemove", this.onDragMove);
      removeEventListener("touchend", this.onDragEnd);
      removeEventListener("mouseup", this.onDragEnd);
    },
    onDragStart(event) {
      this.beingDragged = true;
      this.dragPos = { x: getX(event), y: getY(event) };
      this.dragStart = getX(event);
      this.dragRect = this.$el.getBoundingClientRect();
    },
    onDragMove(event) {
      if (this.beingDragged) {
        event.preventDefault();
        if (this.isRunning) {
          this.isRunning = false;
        }
        this.dragPos = { x: getX(event), y: getY(event) };
      }
    },
    onDragEnd() {
      if (this.beingDragged) {
        if (Math.abs(this.dragDelta) >= this.removalDistance) {
          this.disableTransitions = true;
          this.$nextTick(() => this.closeToast());
        } else {
          setTimeout(() => {
            this.beingDragged = false;
            if (isDOMRect(this.dragRect) && this.pauseOnHover && this.dragRect.bottom >= this.dragPos.y && this.dragPos.y >= this.dragRect.top && this.dragRect.left <= this.dragPos.x && this.dragPos.x <= this.dragRect.right) {
              this.isRunning = false;
            } else {
              this.isRunning = true;
            }
          });
        }
      }
    }
  }
});
var _hoisted_16$U = ["role"];
function render8(_ctx, _cache) {
  const _component_Icon = resolveComponent("Icon");
  const _component_CloseButton = resolveComponent("CloseButton");
  const _component_ProgressBar = resolveComponent("ProgressBar");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.draggableStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.clickHandler && _ctx.clickHandler(...args)),
    onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.hoverPause && _ctx.hoverPause(...args)),
    onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.hoverPlay && _ctx.hoverPlay(...args))
  }, [
    _ctx.icon ? (openBlock(), createBlock(_component_Icon, {
      key: 0,
      "custom-icon": _ctx.icon,
      type: _ctx.type
    }, null, 8, ["custom-icon", "type"])) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      role: _ctx.accessibility.toastRole || "alert",
      class: normalizeClass(_ctx.bodyClasses)
    }, [
      typeof _ctx.content === "string" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createTextVNode(toDisplayString$1(_ctx.content), 1)
      ], 2112)) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.getVueComponentFromObj(_ctx.content)), mergeProps({
        key: 1,
        "toast-id": _ctx.id
      }, _ctx.hasProp(_ctx.content, "props") ? _ctx.content.props : {}, toHandlers(_ctx.hasProp(_ctx.content, "listeners") ? _ctx.content.listeners : {}), { onCloseToast: _ctx.closeToast }), null, 16, ["toast-id", "onCloseToast"]))
    ], 10, _hoisted_16$U),
    !!_ctx.closeButton ? (openBlock(), createBlock(_component_CloseButton, {
      key: 1,
      component: _ctx.closeButton,
      "class-names": _ctx.closeButtonClassName,
      "show-on-hover": _ctx.showCloseButtonOnHover,
      "aria-label": _ctx.accessibility.closeButtonLabel,
      onClick: withModifiers(_ctx.closeToast, ["stop"])
    }, null, 8, ["component", "class-names", "show-on-hover", "aria-label", "onClick"])) : createCommentVNode("v-if", true),
    _ctx.timeout ? (openBlock(), createBlock(_component_ProgressBar, {
      key: 2,
      "is-running": _ctx.isRunning,
      "hide-progress-bar": _ctx.hideProgressBar,
      timeout: _ctx.timeout,
      onCloseToast: _ctx.timeoutHandler
    }, null, 8, ["is-running", "hide-progress-bar", "timeout", "onCloseToast"])) : createCommentVNode("v-if", true)
  ], 38);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtToast.vue
VtToast_default.render = render8;
var VtToast_default2 = VtToast_default;
var VtTransition_default = defineComponent({
  name: "VtTransition",
  props: propValidators_default.TRANSITION,
  emits: ["leave"],
  methods: {
    hasProp,
    leave(el) {
      if (el instanceof HTMLElement) {
        el.style.left = el.offsetLeft + "px";
        el.style.top = el.offsetTop + "px";
        el.style.width = getComputedStyle(el).width;
        el.style.position = "absolute";
      }
    }
  }
});
function render9(_ctx, _cache) {
  return openBlock(), createBlock(TransitionGroup, {
    tag: "div",
    "enter-active-class": _ctx.transition.enter ? _ctx.transition.enter : `${_ctx.transition}-enter-active`,
    "move-class": _ctx.transition.move ? _ctx.transition.move : `${_ctx.transition}-move`,
    "leave-active-class": _ctx.transition.leave ? _ctx.transition.leave : `${_ctx.transition}-leave-active`,
    onLeave: _ctx.leave
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["enter-active-class", "move-class", "leave-active-class", "onLeave"]);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtTransition.vue
VtTransition_default.render = render9;
var VtTransition_default2 = VtTransition_default;

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtToastContainer.vue?vue&type=script
var VtToastContainer_default = defineComponent({
  name: "VueToastification",
  devtools: {
    hide: true
  },
  components: { Toast: VtToast_default2, VtTransition: VtTransition_default2 },
  props: Object.assign({}, propValidators_default.CORE_TOAST, propValidators_default.CONTAINER, propValidators_default.TRANSITION),
  data() {
    const data = {
      count: 0,
      positions: Object.values(POSITION),
      toasts: {},
      defaults: {}
    };
    return data;
  },
  computed: {
    toastArray() {
      return Object.values(this.toasts);
    },
    filteredToasts() {
      return this.defaults.filterToasts(this.toastArray);
    }
  },
  beforeMount() {
    const events = this.eventBus;
    events.on(EVENTS.ADD, this.addToast);
    events.on(EVENTS.CLEAR, this.clearToasts);
    events.on(EVENTS.DISMISS, this.dismissToast);
    events.on(EVENTS.UPDATE, this.updateToast);
    events.on(EVENTS.UPDATE_DEFAULTS, this.updateDefaults);
    this.defaults = this.$props;
  },
  mounted() {
    this.setup(this.container);
  },
  methods: {
    async setup(container) {
      if (isFunction$1(container)) {
        container = await container();
      }
      removeElement(this.$el);
      container.appendChild(this.$el);
    },
    setToast(props) {
      if (!isUndefined(props.id)) {
        this.toasts[props.id] = props;
      }
    },
    addToast(params) {
      params.content = normalizeToastComponent(params.content);
      const props = Object.assign({}, this.defaults, params.type && this.defaults.toastDefaults && this.defaults.toastDefaults[params.type], params);
      const toast = this.defaults.filterBeforeCreate(props, this.toastArray);
      toast && this.setToast(toast);
    },
    dismissToast(id) {
      const toast = this.toasts[id];
      if (!isUndefined(toast) && !isUndefined(toast.onClose)) {
        toast.onClose();
      }
      delete this.toasts[id];
    },
    clearToasts() {
      Object.keys(this.toasts).forEach((id) => {
        this.dismissToast(id);
      });
    },
    getPositionToasts(position) {
      const toasts = this.filteredToasts.filter((toast) => toast.position === position).slice(0, this.defaults.maxToasts);
      return this.defaults.newestOnTop ? toasts.reverse() : toasts;
    },
    updateDefaults(update) {
      if (!isUndefined(update.container)) {
        this.setup(update.container);
      }
      this.defaults = Object.assign({}, this.defaults, update);
    },
    updateToast({
      id,
      options,
      create
    }) {
      if (this.toasts[id]) {
        if (options.timeout && options.timeout === this.toasts[id].timeout) {
          options.timeout++;
        }
        this.setToast(Object.assign({}, this.toasts[id], options));
      } else if (create) {
        this.addToast(Object.assign({}, { id }, options));
      }
    },
    getClasses(position) {
      const classes = [`${VT_NAMESPACE}__container`, position];
      return classes.concat(this.defaults.containerClassName);
    }
  }
});
function render10(_ctx, _cache) {
  const _component_Toast = resolveComponent("Toast");
  const _component_VtTransition = resolveComponent("VtTransition");
  return openBlock(), createElementBlock("div", null, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.positions, (pos) => {
      return openBlock(), createElementBlock("div", { key: pos }, [
        createVNode(_component_VtTransition, {
          transition: _ctx.defaults.transition,
          class: normalizeClass(_ctx.getClasses(pos))
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.getPositionToasts(pos), (toast) => {
              return openBlock(), createBlock(_component_Toast, mergeProps({
                key: toast.id
              }, toast), null, 16);
            }), 128))
          ]),
          _: 2
        }, 1032, ["transition", "class"])
      ]);
    }), 128))
  ]);
}

// vue:/Users/maronato/Developer/vue-toastification/src/components/VtToastContainer.vue
VtToastContainer_default.render = render10;
var VtToastContainer_default2 = VtToastContainer_default;

// src/ts/interface.ts
var buildInterface = (globalOptions = {}, mountContainer = true) => {
  const events = globalOptions.eventBus = globalOptions.eventBus || new EventBus();
  if (mountContainer) {
    nextTick(() => {
      const app = createApp(VtToastContainer_default2, __spreadValues({}, globalOptions));
      const component = app.mount(document.createElement("div"));
      const onMounted = globalOptions.onMounted;
      if (!isUndefined(onMounted)) {
        onMounted(component, app);
      }
      if (globalOptions.shareAppContext) {
        const baseApp = globalOptions.shareAppContext;
        if (baseApp === true) {
          console.warn(`[${VT_NAMESPACE}] App to share context with was not provided.`);
        } else {
          app._context.components = baseApp._context.components;
          app._context.directives = baseApp._context.directives;
          app._context.mixins = baseApp._context.mixins;
          app._context.provides = baseApp._context.provides;
          app.config.globalProperties = baseApp.config.globalProperties;
        }
      }
    });
  }
  const toast = (content, options) => {
    const props = Object.assign({}, { id: getId(), type: TYPE.DEFAULT }, options, {
      content
    });
    events.emit(EVENTS.ADD, props);
    return props.id;
  };
  toast.clear = () => events.emit(EVENTS.CLEAR, void 0);
  toast.updateDefaults = (update) => {
    events.emit(EVENTS.UPDATE_DEFAULTS, update);
  };
  toast.dismiss = (id) => {
    events.emit(EVENTS.DISMISS, id);
  };
  function updateToast(id, { content, options }, create = false) {
    const opt = Object.assign({}, options, { content });
    events.emit(EVENTS.UPDATE, {
      id,
      options: opt,
      create
    });
  }
  toast.update = updateToast;
  toast.success = (content, options) => toast(content, Object.assign({}, options, { type: TYPE.SUCCESS }));
  toast.info = (content, options) => toast(content, Object.assign({}, options, { type: TYPE.INFO }));
  toast.error = (content, options) => toast(content, Object.assign({}, options, { type: TYPE.ERROR }));
  toast.warning = (content, options) => toast(content, Object.assign({}, options, { type: TYPE.WARNING }));
  return toast;
};

// src/index.ts
var createMockToastInterface = () => {
  const toast = () => console.warn(`[${VT_NAMESPACE}] This plugin does not support SSR!`);
  return new Proxy(toast, {
    get() {
      return toast;
    }
  });
};
function createToastInterface(optionsOrEventBus) {
  if (!isBrowser$1()) {
    return createMockToastInterface();
  }
  if (isEventBusInterface(optionsOrEventBus)) {
    return buildInterface({ eventBus: optionsOrEventBus }, false);
  }
  return buildInterface(optionsOrEventBus, true);
}
var toastInjectionKey = Symbol("VueToastification");
var globalEventBus = new EventBus();
var VueToastificationPlugin = (App, options) => {
  if ((options == null ? void 0 : options.shareAppContext) === true) {
    options.shareAppContext = App;
  }
  const inter = createToastInterface(__spreadValues({
    eventBus: globalEventBus
  }, options));
  App.provide(toastInjectionKey, inter);
};
var useToast = (eventBus) => {
  const toast = getCurrentInstance() ? inject(toastInjectionKey, void 0) : void 0;
  return toast ? toast : createToastInterface(globalEventBus);
};
var src_default = VueToastificationPlugin;

const scriptRel = 'modulepreload';const assetsURL = function(dep) { return "/web-english/"+dep };const seen = {};const __vitePreload = function preload(baseModule, deps, importerUrl) {
	let promise = Promise.resolve();
	if (true               && deps && deps.length > 0) {
		document.getElementsByTagName("link");
		const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
		const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
		function allSettled(promises$2) {
			return Promise.all(promises$2.map((p$1) => Promise.resolve(p$1).then((value$1) => ({
				status: "fulfilled",
				value: value$1
			}), (reason) => ({
				status: "rejected",
				reason
			}))));
		}
		promise = allSettled(deps.map((dep) => {
			dep = assetsURL(dep);
			if (dep in seen) return;
			seen[dep] = true;
			const isCss = dep.endsWith(".css");
			const cssSelector = isCss ? "[rel=\"stylesheet\"]" : "";
			if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
			const link = document.createElement("link");
			link.rel = isCss ? "stylesheet" : scriptRel;
			if (!isCss) link.as = "script";
			link.crossOrigin = "";
			link.href = dep;
			if (cspNonce) link.setAttribute("nonce", cspNonce);
			document.head.appendChild(link);
			if (isCss) return new Promise((res, rej) => {
				link.addEventListener("load", res);
				link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
			});
		}));
	}
	function handlePreloadError(err$2) {
		const e$1 = new Event("vite:preloadError", { cancelable: true });
		e$1.payload = err$2;
		window.dispatchEvent(e$1);
		if (!e$1.defaultPrevented) throw err$2;
	}
	return promise.then((res) => {
		for (const item of res || []) {
			if (item.status !== "rejected") continue;
			handlePreloadError(item.reason);
		}
		return baseModule().catch(handlePreloadError);
	});
};

/*!
  * vue-router v4.5.1
  * (c) 2025 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof document !== "undefined";
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module" || // support CF with dynamic imports that do not
  // add the Module string tag
  obj.default && isRouteComponent(obj.default);
}
const assign$2 = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = isArray$1(value) ? value.map(fn) : fn(value);
  }
  return newParams;
}
const noop = () => {
};
const isArray$1 = Array.isArray;
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash = "";
  const hashPos = location2.indexOf("#");
  let searchPos = location2.indexOf("?");
  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash,
    path,
    query,
    hash: decode(hash)
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a, b) {
  const aLastIndex = a.matched.length - 1;
  const bLastIndex = b.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
}
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length)
    return false;
  for (const key in a) {
    if (!isSameRouteLocationParamsValue(a[key], b[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a, b) {
  return isArray$1(a) ? isEquivalentArray(a, b) : isArray$1(b) ? isEquivalentArray(b, a) : a === b;
}
function isEquivalentArray(a, b) {
  return isArray$1(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;
}
function resolveRelativePath(to, from) {
  if (to.startsWith("/"))
    return to;
  if (!to)
    return from;
  const fromSegments = from.split("/");
  const toSegments = to.split("/");
  const lastToSegment = toSegments[toSegments.length - 1];
  if (lastToSegment === ".." || lastToSegment === ".") {
    toSegments.push("");
  }
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".")
      continue;
    if (segment === "..") {
      if (position > 1)
        position--;
    } else
      break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition).join("/");
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  // TODO: could we use a symbol in the future?
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.scrollX,
  top: window.scrollY
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
  }
}
function getScrollKey(path, delta) {
  const position = history.state ? history.state.position - delta : -1;
  return position + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search, hash } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to = createCurrentLocation(base, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }
      delta = fromState ? state.position - fromState.position : 0;
    } else {
      replace(to);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index = listeners.indexOf(callback);
      if (index > -1)
        listeners.splice(index, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign$2({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener, {
    passive: true
  });
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      // the length is off by one, we need to decrease it
      position: history2.length - 1,
      replaced: true,
      // don't add a scroll as the user may have an anchor, and we want
      // scrollBehavior to be triggered without a saved position
      scroll: null
    }, true);
  }
  function changeLocation(to, state, replace2) {
    const hashIndex = base.indexOf("#");
    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state, "", url);
      historyState.value = state;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url);
    }
  }
  function replace(to, data) {
    const state = assign$2({}, history2.state, buildState(
      historyState.value.back,
      // keep back and forward entries but override current position
      to,
      historyState.value.forward,
      true
    ), data, { position: historyState.value.position });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  function push(to, data) {
    const currentState = assign$2(
      {},
      // use current history state to gracefully handle a wrong call to
      // history.replaceState
      // https://github.com/vuejs/router/issues/366
      historyState.value,
      history2.state,
      {
        forward: to,
        scroll: computeScrollPosition()
      }
    );
    changeLocation(currentState.current, currentState, true);
    const state = assign$2({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign$2({
    // it's overridden right after
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function createWebHashHistory(base) {
  base = location.host ? base || location.pathname + location.search : "";
  if (!base.includes("#"))
    base += "#";
  return createWebHistory(base);
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type, params) {
  {
    return assign$2(new Error(), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign$2({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [
      90
      /* PathScore.Root */
    ];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token.type === 1) {
        const { value, repeatable, optional, regexp } = token;
        keys.push({
          name: value,
          repeatable,
          optional
        });
        const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re2 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re2})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
        if (!tokenIndex)
          subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
          // or /:p?-:p2
          optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re2 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i = score.length - 1;
    score[i][score[i].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict && !pattern.endsWith("/"))
    pattern += "(?:/|$)";
  const re = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse(path) {
    const match = path.match(re);
    const params = {};
    if (!match)
      return null;
    for (let i = 1; i < match.length; i++) {
      const value = match[i] || "";
      const key = keys[i - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) {
        if (token.type === 0) {
          path += token.value;
        } else if (token.type === 1) {
          const { value, repeatable, optional } = token;
          const param = value in params ? params[value] : "";
          if (isArray$1(param) && !repeatable) {
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          }
          const text = isArray$1(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path += text;
        }
      }
    }
    return path || "/";
  }
  return {
    re,
    score,
    keys,
    parse,
    stringify
  };
}
function compareScoreArray(a, b) {
  let i = 0;
  while (i < a.length && i < b.length) {
    const diff = b[i] - a[i];
    if (diff)
      return diff;
    i++;
  }
  if (a.length < b.length) {
    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
  } else if (a.length > b.length) {
    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a, b) {
  let i = 0;
  const aScore = a.score;
  const bScore = b.score;
  while (i < aScore.length && i < bScore.length) {
    const comp = compareScoreArray(aScore[i], bScore[i]);
    if (comp)
      return comp;
    i++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i = 0;
  let char;
  let buffer = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer = "";
  }
  function addCharToBuffer() {
    buffer += char;
  }
  while (i < path.length) {
    char = path[i++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign$2(parser, {
    record,
    parent,
    // these needs to be populated by the parent
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [mainNormalizedRecord];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(
          // we need to normalize again to ensure the `mods` property
          // being non enumerable
          normalizeRouteRecord(assign$2({}, mainNormalizedRecord, {
            // this allows us to hold a copy of the `components` option
            // so that async components cache is hold on the original record
            components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
            path: alias,
            // we might be the child of an alias
            aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
            // the aliases are always of the same kind as the original since they
            // are defined on the same record
          }))
        );
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher)) {
          removeRoute(record.name);
        }
      }
      if (isMatchable(matcher)) {
        insertMatcher(matcher);
      }
      if (mainNormalizedRecord.children) {
        const children = mainNormalizedRecord.children;
        for (let i = 0; i < children.length; i++) {
          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
        }
      }
      originalRecord = originalRecord || matcher;
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index = matchers.indexOf(matcherRef);
      if (index > -1) {
        matchers.splice(index, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    const index = findInsertionIndex(matcher, matchers);
    matchers.splice(index, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name = matcher.record.name;
      params = assign$2(
        // paramsFromLocation is a new object
        paramsFromLocation(
          currentLocation.params,
          // only keep params that exist in the resolved location
          // only keep optional params coming from a parent record
          matcher.keys.filter((k) => !k.optional).concat(matcher.parent ? matcher.parent.keys.filter((k) => k.optional) : []).map((k) => k.name)
        ),
        // discard any existing params in the current location that do not exist here
        // #1497 this ensures better active/exact matching
        location2.params && paramsFromLocation(location2.params, matcher.keys.map((k) => k.name))
      );
      path = matcher.stringify(params);
    } else if (location2.path != null) {
      path = location2.path;
      matcher = matchers.find((m) => m.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher.record.name;
      params = assign$2({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes.forEach((route) => addRoute(route));
  function clearRoutes() {
    matchers.length = 0;
    matcherMap.clear();
  }
  return {
    addRoute,
    resolve,
    removeRoute,
    clearRoutes,
    getRoutes,
    getRecordMatcher
  };
}
function paramsFromLocation(params, keys) {
  const newParams = {};
  for (const key of keys) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  const normalized = {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: record.aliasOf,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    // must be declared afterwards
    // mods: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
  Object.defineProperty(normalized, "mods", {
    value: {}
  });
  return normalized;
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props === "object" ? props[name] : props;
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign$2(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
  const options = {};
  for (const key in defaults) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
  }
  return options;
}
function findInsertionIndex(matcher, matchers) {
  let lower = 0;
  let upper = matchers.length;
  while (lower !== upper) {
    const mid = lower + upper >> 1;
    const sortOrder = comparePathParserScore(matcher, matchers[mid]);
    if (sortOrder < 0) {
      upper = mid;
    } else {
      lower = mid + 1;
    }
  }
  const insertionAncestor = getInsertionAncestor(matcher);
  if (insertionAncestor) {
    upper = matchers.lastIndexOf(insertionAncestor, upper - 1);
  }
  return upper;
}
function getInsertionAncestor(matcher) {
  let ancestor = matcher;
  while (ancestor = ancestor.parent) {
    if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) {
      return ancestor;
    }
  }
  return;
}
function isMatchable({ record }) {
  return !!(record.name || record.components && Object.keys(record.components).length || record.redirect);
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?")
    return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i = 0; i < searchParams.length; ++i) {
    const searchParam = searchParams[i].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!isArray$1(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values = isArray$1(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
    values.forEach((value2) => {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value2 != null)
          search += "=" + value2;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value = query[key];
    if (value !== void 0) {
      normalizedQuery[key] = isArray$1(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
const matchedRouteKey = Symbol("");
const viewDepthKey = Symbol("");
const routerKey = Symbol("");
const routeLocationKey = Symbol("");
const routerViewLocationKey = Symbol("");
function useCallbacks() {
  let handlers = [];
  function add(handler) {
    handlers.push(handler);
    return () => {
      const i = handlers.indexOf(handler);
      if (i > -1)
        handlers.splice(i, 1);
    };
  }
  function reset() {
    handlers = [];
  }
  return {
    add,
    list: () => handlers.slice(),
    reset
  };
}
function guardToPromiseFn(guard, to, from, record, name, runWithContext = (fn) => fn()) {
  const enterCallbackArray = record && // name is defined if record is because of the function overload
  (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve, reject) => {
    const next = (valid) => {
      if (valid === false) {
        reject(createRouterError(4, {
          from,
          to
        }));
      } else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
        record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
          enterCallbackArray.push(valid);
        }
        resolve();
      }
    };
    const guardReturn = runWithContext(() => guard.call(record && record.instances[name], to, from, next));
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to, from, runWithContext = (fn) => fn()) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name, runWithContext));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            throw new Error(`Couldn't resolve component "${name}" at "${record.path}"`);
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.mods[name] = resolved;
          record.components[name] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to, from, record, name, runWithContext)();
        }));
      }
    }
  }
  return guards;
}
function useLink(props) {
  const router = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => {
    const to = unref(props.to);
    return router.resolve(to);
  });
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index > -1)
      return index;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return (
      // we are dealing with nested routes
      length > 1 && // if the parent and matched route have the same path, this link is
      // referring to the empty child. Or we currently are on a different
      // child of the same parent
      getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index
    );
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e = {}) {
    if (guardEvent(e)) {
      const p = router[unref(props.replace) ? "replace" : "push"](
        unref(props.to)
        // avoid uncaught errors are they are logged anyway
      ).catch(noop);
      if (props.viewTransition && typeof document !== "undefined" && "startViewTransition" in document) {
        document.startViewTransition(() => p);
      }
      return p;
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
function preferSingleVNode(vnodes) {
  return vnodes.length === 1 ? vnodes[0] : vnodes;
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    },
    viewTransition: Boolean
  },
  useLink,
  setup(props, { slots }) {
    const link = reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && preferSingleVNode(slots.default(link));
      return props.custom ? children : h("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        // this would override user added attrs but Vue will still add
        // the listener, so we end up triggering both
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
    return;
  if (e.defaultPrevented)
    return;
  if (e.button !== void 0 && e.button !== 0)
    return;
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target = e.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e.preventDefault)
    e.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray$1(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  // #674 we manually inherit them
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  // Better compat for @vue/compat users
  // https://github.com/vuejs/router/issues/1315
  compatConfig: { MODE: 3 },
  setup(props, { attrs, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const injectedDepth = inject(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
      if (to) {
        to.instances[name] = instance;
        if (from && from !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from.updateGuards;
          }
        }
      }
      if (instance && to && // if there is no instance but to and from are the same this might be
      // the first visit
      (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const currentName = props.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h(ViewComponent, assign$2({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return (
        // pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        normalizeSlot(slots.default, { Component: component, route }) || component
      );
    };
  }
});
function normalizeSlot(slot, data) {
  if (!slot)
    return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = (
    // @ts-expect-error: intentionally avoid the type check
    applyToParams.bind(null, decode)
  );
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve(rawLocation, currentLocation) {
    currentLocation = assign$2({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign$2(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if (rawLocation.path != null) {
      matcherLocation = assign$2({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign$2({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign$2({}, rawLocation, {
        params: encodeParams(targetParams)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign$2({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign$2({
      fullPath,
      // keep the hash encoded so fullPath is effectively path + encodedQuery +
      // hash
      hash,
      query: (
        // if the user is using a custom query lib like qs, we might have
        // nested objects, so we keep the query as is, meaning it can contain
        // numbers at `$route.query`, but at the point, the user will have to
        // use their own type anyway.
        // https://github.com/vuejs/router/issues/328#issuecomment-649481567
        stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
      )
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign$2({}, to);
  }
  function checkCanceledNavigation(to, from) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from,
        to
      });
    }
  }
  function push(to) {
    return pushWithRedirect(to);
  }
  function replace(to) {
    return push(assign$2(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
          // force empty params
          { path: newTargetLocation }
        );
        newTargetLocation.params = {};
      }
      return assign$2({
        query: to.query,
        hash: to.hash,
        // avoid transferring params if the redirect has a path
        params: newTargetLocation.path != null ? {} : to.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve(to);
    const from = currentRoute.value;
    const data = to.state;
    const force = to.force;
    const replace2 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign$2(locationAsObject(shouldRedirect), {
          state: typeof shouldRedirect === "object" ? assign$2({}, data, shouldRedirect.state) : data,
          force,
          replace: replace2
        }),
        // keep original redirectedFrom if it exists
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from });
      handleScroll(
        from,
        from,
        // this is a push, the only way for it to be triggered from a
        // history.listen is with a redirect, which makes it become a push
        true,
        // This cannot be the first navigation because the initial location
        // cannot be manually navigated to
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? (
      // navigation redirects still mark the router as ready
      isNavigationFailure(
        error,
        2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
      ) ? error : markAsReady(error)
    ) : (
      // reject any unknown error
      triggerError(error, toLocation, from)
    )).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(
          failure2,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          return pushWithRedirect(
            // keep options
            assign$2({
              // preserve an existing replacement but allow the redirect to override it
              replace: replace2
            }, locationAsObject(failure2.to), {
              state: typeof failure2.to === "object" ? assign$2({}, data, failure2.to.state) : data,
              force
            }),
            // preserve the original redirectedFrom if any
            redirectedFrom || toLocation
          );
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
      }
      triggerAfterEach(toLocation, from, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to, from) {
    const error = checkCanceledNavigation(to, from);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function runWithContext(fn) {
    const app = installedApps.values().next().value;
    return app && typeof app.runWithContext === "function" ? app.runWithContext(fn) : fn();
  }
  function navigate(to, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of enteringRecords) {
        if (record.beforeEnter) {
          if (isArray$1(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from, runWithContext);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(
      err,
      8
      /* ErrorTypes.NAVIGATION_CANCELLED */
    ) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to, from, failure) {
    afterGuards.list().forEach((guard) => runWithContext(() => guard(to, from, failure)));
  }
  function finalizeNavigation(toLocation, from, isPush, replace2, data) {
    const error = checkCanceledNavigation(toLocation, from);
    if (error)
      return error;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign$2({
          scroll: isFirstNavigation && state && state.scroll
        }, data));
      else
        routerHistory.push(toLocation.fullPath, data);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      if (!router.listening)
        return;
      const toLocation = resolve(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign$2(shouldRedirect, { replace: true, force: true }), toLocation).catch(noop);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from).catch((error) => {
        if (isNavigationFailure(
          error,
          4 | 8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        )) {
          return error;
        }
        if (isNavigationFailure(
          error,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          pushWithRedirect(
            assign$2(locationAsObject(error.to), {
              force: true
            }),
            toLocation
            // avoid an uncaught rejection, let push call triggerError
          ).then((failure) => {
            if (isNavigationFailure(
              failure,
              4 | 16
              /* ErrorTypes.NAVIGATION_DUPLICATED */
            ) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop);
          return Promise.reject();
        }
        if (info.delta) {
          routerHistory.go(-info.delta, false);
        }
        return triggerError(error, toLocation, from);
      }).then((failure) => {
        failure = failure || finalizeNavigation(
          // after navigation, all matched components are resolved
          toLocation,
          from,
          false
        );
        if (failure) {
          if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
          // entry while a different route is displayed
          !isNavigationFailure(
            failure,
            8
            /* ErrorTypes.NAVIGATION_CANCELLED */
          )) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(
            failure,
            4 | 16
            /* ErrorTypes.NAVIGATION_DUPLICATED */
          )) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from, failure);
      }).catch(noop);
    });
  }
  let readyHandlers = useCallbacks();
  let errorListeners = useCallbacks();
  let ready;
  function triggerError(error, to, from) {
    markAsReady(error);
    const list = errorListeners.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to, from));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve2, reject) => {
      readyHandlers.add([resolve2, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve2, reject]) => err ? reject(err) : resolve2());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    clearRoutes: matcher.clearRoutes,
    hasRoute,
    getRoutes,
    resolve,
    options,
    push,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorListeners.add,
    isReady,
    install(app) {
      const router2 = this;
      app.component("RouterLink", RouterLink);
      app.component("RouterView", RouterView);
      app.config.globalProperties.$router = router2;
      Object.defineProperty(app.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && // used for the initial navigation client side to avoid pushing
      // multiple times when the router is used in multiple apps
      !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        Object.defineProperty(reactiveRoute, key, {
          get: () => currentRoute.value[key],
          enumerable: true
        });
      }
      app.provide(routerKey, router2);
      app.provide(routeLocationKey, shallowReactive(reactiveRoute));
      app.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app.unmount;
      installedApps.add(app);
      app.unmount = function() {
        installedApps.delete(app);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
  }
  return router;
}
function extractChangingRecords(to, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to.matched.length);
  for (let i = 0; i < len; i++) {
    const recordFrom = from.matched[i];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
function useRouter() {
  return inject(routerKey);
}
function useRoute(_name) {
  return inject(routeLocationKey);
}

const useModalStore = defineStore("modal", () => {
  const showVocabularyForm = ref(false);
  const showTopicManager = ref(false);
  const showNoteDialog = ref(false);
  const showVocabularyDetail = ref(false);
  const showGrammarManager = ref(false);
  const showCompletionModal = ref(false);
  const shouldHideBackToTop = computed(() => {
    return showVocabularyForm.value || showTopicManager.value || showNoteDialog.value || showGrammarManager.value || showVocabularyDetail.value || showCompletionModal.value;
  });
  const shouldHideAddNewWord = computed(() => {
    return showTopicManager.value || showNoteDialog.value || showGrammarManager.value || showVocabularyDetail.value;
  });
  const setVocabularyForm = (show) => {
    showVocabularyForm.value = show;
  };
  const setTopicManager = (show) => {
    showTopicManager.value = show;
  };
  const setNoteDialog = (show) => {
    showNoteDialog.value = show;
  };
  const setVocabularyDetail = (show) => {
    showVocabularyDetail.value = show;
  };
  const setGrammarManager = (show) => {
    showGrammarManager.value = show;
  };
  const setCompletionModal = (show) => {
    showCompletionModal.value = show;
    if (show) {
      document.body.classList.add("modal-open");
    } else {
      document.body.classList.remove("modal-open");
    }
  };
  return {
    // States
    showVocabularyForm,
    showTopicManager,
    showNoteDialog,
    showVocabularyDetail,
    showGrammarManager,
    showCompletionModal,
    // Computed
    shouldHideBackToTop,
    shouldHideAddNewWord,
    // Actions
    setVocabularyForm,
    setTopicManager,
    setNoteDialog,
    setVocabularyDetail,
    setGrammarManager,
    setCompletionModal
  };
});

const _hoisted_1$1s = {
  id: "app",
  class: "min-h-screen"
};
const _hoisted_2$1p = { class: "flex-1 pt-16" };
const _sfc_main$1t = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    const AppHeader = defineAsyncComponent(
      () => __vitePreload(() => Promise.resolve().then(() => AppHeader$1),true              ?void 0:void 0)
    );
    const BackToTop = defineAsyncComponent(
      () => __vitePreload(() => Promise.resolve().then(() => BackToTop$1),true              ?void 0:void 0)
    );
    const modalStore = useModalStore();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1s, [
        createVNode(unref(AppHeader)),
        createBaseVNode("main", _hoisted_2$1p, [
          createVNode(unref(RouterView))
        ]),
        withDirectives(createVNode(unref(BackToTop), null, null, 512), [
          [vShow, !unref(modalStore).shouldHideBackToTop]
        ])
      ]);
    };
  }
});

/*!
  * shared v9.14.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
const inBrowser = typeof window !== "undefined";
const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber = (val) => typeof val === "number" && isFinite(val);
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
const assign$1 = Object.assign;
const _create = Object.create;
const create = (obj = null) => _create(obj);
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : create());
};
function escapeHtml(rawText) {
  return rawText.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/\//g, "&#x2F;").replace(/=/g, "&#x3D;");
}
function escapeAttributeValue(value) {
  return value.replace(/&(?![a-zA-Z0-9#]{2,6};)/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function sanitizeTranslatedHtml(html) {
  html = html.replace(/(\w+)\s*=\s*"([^"]*)"/g, (_, attrName, attrValue) => `${attrName}="${escapeAttributeValue(attrValue)}"`);
  html = html.replace(/(\w+)\s*=\s*'([^']*)'/g, (_, attrName, attrValue) => `${attrName}='${escapeAttributeValue(attrValue)}'`);
  const eventHandlerPattern = /\s*on\w+\s*=\s*["']?[^"'>]+["']?/gi;
  if (eventHandlerPattern.test(html)) {
    html = html.replace(/(\s+)(on)(\w+\s*=)/gi, "$1&#111;n$3");
  }
  const javascriptUrlPattern = [
    // In href, src, action, formaction attributes
    /(\s+(?:href|src|action|formaction)\s*=\s*["']?)\s*javascript:/gi,
    // In style attributes within url()
    /(style\s*=\s*["'][^"']*url\s*\(\s*)javascript:/gi
  ];
  javascriptUrlPattern.forEach((pattern) => {
    html = html.replace(pattern, "$1javascript&#58;");
  });
  return html;
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
const isArray = Array.isArray;
const isFunction = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isBoolean = (val) => typeof val === "boolean";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$1(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const isPlainObject = (val) => {
  if (!isObject$1(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
};
const toDisplayString = (val) => {
  return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
function join$1(items, separator = "") {
  return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
}
function incrementer(code) {
  let current = code;
  return () => ++current;
}
const isNotObjectOrIsArray = (val) => !isObject$1(val) || isArray(val);
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack = [{ src, des }];
  while (stack.length) {
    const { src: src2, des: des2 } = stack.pop();
    Object.keys(src2).forEach((key) => {
      if (key === "__proto__") {
        return;
      }
      if (isObject$1(src2[key]) && !isObject$1(des2[key])) {
        des2[key] = Array.isArray(src2[key]) ? [] : create();
      }
      if (isNotObjectOrIsArray(des2[key]) || isNotObjectOrIsArray(src2[key])) {
        des2[key] = src2[key];
      } else {
        stack.push({ src: src2[key], des: des2[key] });
      }
    });
  }
}

/*!
  * message-compiler v9.14.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function createPosition(line, column, offset) {
    return { line, column, offset };
}
function createLocation(start, end, source) {
    const loc = { start, end };
    return loc;
}

/**
 * Original Utilities
 * written by kazuya kawaguchi
 */
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
/* eslint-disable */
function format$1(message, ...args) {
    if (args.length === 1 && isObject(args[0])) {
        args = args[0];
    }
    if (!args || !args.hasOwnProperty) {
        args = {};
    }
    return message.replace(RE_ARGS, (match, identifier) => {
        return args.hasOwnProperty(identifier) ? args[identifier] : '';
    });
}
const assign = Object.assign;
const isString = (val) => typeof val === 'string';
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isObject = (val) => val !== null && typeof val === 'object';
function join(items, separator = '') {
    return items.reduce((str, item, index) => (index === 0 ? str + item : str + separator + item), '');
}

const CompileWarnCodes = {
    USE_MODULO_SYNTAX: 1,
    __EXTEND_POINT__: 2
};
/** @internal */
const warnMessages = {
    [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
};
function createCompileWarn(code, loc, ...args) {
    const msg = format$1(warnMessages[code], ...(args || [])) ;
    const message = { message: String(msg), code };
    if (loc) {
        message.location = loc;
    }
    return message;
}

const CompileErrorCodes = {
    // tokenizer error codes
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    // parser error codes
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    // generator error codes
    UNHANDLED_CODEGEN_NODE_TYPE: 15,
    // minifier error codes
    UNHANDLED_MINIFIER_NODE_TYPE: 16,
    // Special value for higher-order compilers to pick up the last code
    // to avoid collision of error codes. This should always be kept as the last
    // item.
    __EXTEND_POINT__: 17
};
/** @internal */
const errorMessages = {
    // tokenizer error messages
    [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
    [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
    [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
    [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
    [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
    [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
    [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
    [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
    [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
    [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
    // parser error messages
    [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
    [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
    // generator error messages
    [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
    // minimizer error messages
    [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code, loc, options = {}) {
    const { domain, messages, args } = options;
    const msg = format$1((messages || errorMessages)[code] || '', ...(args || []))
        ;
    const error = new SyntaxError(String(msg));
    error.code = code;
    if (loc) {
        error.location = loc;
    }
    error.domain = domain;
    return error;
}
/** @internal */
function defaultOnError(error) {
    throw error;
}

const CHAR_SP = ' ';
const CHAR_CR = '\r';
const CHAR_LF = '\n';
const CHAR_LS = String.fromCharCode(0x2028);
const CHAR_PS = String.fromCharCode(0x2029);
function createScanner(str) {
    const _buf = str;
    let _index = 0;
    let _line = 1;
    let _column = 1;
    let _peekOffset = 0;
    const isCRLF = (index) => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;
    const isLF = (index) => _buf[index] === CHAR_LF;
    const isPS = (index) => _buf[index] === CHAR_PS;
    const isLS = (index) => _buf[index] === CHAR_LS;
    const isLineEnd = (index) => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);
    const index = () => _index;
    const line = () => _line;
    const column = () => _column;
    const peekOffset = () => _peekOffset;
    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
    const currentChar = () => charAt(_index);
    const currentPeek = () => charAt(_index + _peekOffset);
    function next() {
        _peekOffset = 0;
        if (isLineEnd(_index)) {
            _line++;
            _column = 0;
        }
        if (isCRLF(_index)) {
            _index++;
        }
        _index++;
        _column++;
        return _buf[_index];
    }
    function peek() {
        if (isCRLF(_index + _peekOffset)) {
            _peekOffset++;
        }
        _peekOffset++;
        return _buf[_index + _peekOffset];
    }
    function reset() {
        _index = 0;
        _line = 1;
        _column = 1;
        _peekOffset = 0;
    }
    function resetPeek(offset = 0) {
        _peekOffset = offset;
    }
    function skipToPeek() {
        const target = _index + _peekOffset;
        // eslint-disable-next-line no-unmodified-loop-condition
        while (target !== _index) {
            next();
        }
        _peekOffset = 0;
    }
    return {
        index,
        line,
        column,
        peekOffset,
        charAt,
        currentChar,
        currentPeek,
        next,
        peek,
        reset,
        resetPeek,
        skipToPeek
    };
}

const EOF = undefined;
const DOT = '.';
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$3 = 'tokenizer';
function createTokenizer(source, options = {}) {
    const location = options.location !== false;
    const _scnr = createScanner(source);
    const currentOffset = () => _scnr.index();
    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
    const _initLoc = currentPosition();
    const _initOffset = currentOffset();
    const _context = {
        currentType: 14 /* TokenTypes.EOF */,
        offset: _initOffset,
        startLoc: _initLoc,
        endLoc: _initLoc,
        lastType: 14 /* TokenTypes.EOF */,
        lastOffset: _initOffset,
        lastStartLoc: _initLoc,
        lastEndLoc: _initLoc,
        braceNest: 0,
        inLinked: false,
        text: ''
    };
    const context = () => _context;
    const { onError } = options;
    function emitError(code, pos, offset, ...args) {
        const ctx = context();
        pos.column += offset;
        pos.offset += offset;
        if (onError) {
            const loc = location ? createLocation(ctx.startLoc, pos) : null;
            const err = createCompileError(code, loc, {
                domain: ERROR_DOMAIN$3,
                args
            });
            onError(err);
        }
    }
    function getToken(context, type, value) {
        context.endLoc = currentPosition();
        context.currentType = type;
        const token = { type };
        if (location) {
            token.loc = createLocation(context.startLoc, context.endLoc);
        }
        if (value != null) {
            token.value = value;
        }
        return token;
    }
    const getEndToken = (context) => getToken(context, 14 /* TokenTypes.EOF */);
    function eat(scnr, ch) {
        if (scnr.currentChar() === ch) {
            scnr.next();
            return ch;
        }
        else {
            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
            return '';
        }
    }
    function peekSpaces(scnr) {
        let buf = '';
        while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
            buf += scnr.currentPeek();
            scnr.peek();
        }
        return buf;
    }
    function skipSpaces(scnr) {
        const buf = peekSpaces(scnr);
        scnr.skipToPeek();
        return buf;
    }
    function isIdentifierStart(ch) {
        if (ch === EOF) {
            return false;
        }
        const cc = ch.charCodeAt(0);
        return ((cc >= 97 && cc <= 122) || // a-z
            (cc >= 65 && cc <= 90) || // A-Z
            cc === 95 // _
        );
    }
    function isNumberStart(ch) {
        if (ch === EOF) {
            return false;
        }
        const cc = ch.charCodeAt(0);
        return cc >= 48 && cc <= 57; // 0-9
    }
    function isNamedIdentifierStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 2 /* TokenTypes.BraceLeft */) {
            return false;
        }
        peekSpaces(scnr);
        const ret = isIdentifierStart(scnr.currentPeek());
        scnr.resetPeek();
        return ret;
    }
    function isListIdentifierStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 2 /* TokenTypes.BraceLeft */) {
            return false;
        }
        peekSpaces(scnr);
        const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();
        const ret = isNumberStart(ch);
        scnr.resetPeek();
        return ret;
    }
    function isLiteralStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 2 /* TokenTypes.BraceLeft */) {
            return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === LITERAL_DELIMITER;
        scnr.resetPeek();
        return ret;
    }
    function isLinkedDotStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 8 /* TokenTypes.LinkedAlias */) {
            return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === "." /* TokenChars.LinkedDot */;
        scnr.resetPeek();
        return ret;
    }
    function isLinkedModifierStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 9 /* TokenTypes.LinkedDot */) {
            return false;
        }
        peekSpaces(scnr);
        const ret = isIdentifierStart(scnr.currentPeek());
        scnr.resetPeek();
        return ret;
    }
    function isLinkedDelimiterStart(scnr, context) {
        const { currentType } = context;
        if (!(currentType === 8 /* TokenTypes.LinkedAlias */ ||
            currentType === 12 /* TokenTypes.LinkedModifier */)) {
            return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === ":" /* TokenChars.LinkedDelimiter */;
        scnr.resetPeek();
        return ret;
    }
    function isLinkedReferStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 10 /* TokenTypes.LinkedDelimiter */) {
            return false;
        }
        const fn = () => {
            const ch = scnr.currentPeek();
            if (ch === "{" /* TokenChars.BraceLeft */) {
                return isIdentifierStart(scnr.peek());
            }
            else if (ch === "@" /* TokenChars.LinkedAlias */ ||
                ch === "%" /* TokenChars.Modulo */ ||
                ch === "|" /* TokenChars.Pipe */ ||
                ch === ":" /* TokenChars.LinkedDelimiter */ ||
                ch === "." /* TokenChars.LinkedDot */ ||
                ch === CHAR_SP ||
                !ch) {
                return false;
            }
            else if (ch === CHAR_LF) {
                scnr.peek();
                return fn();
            }
            else {
                // other characters
                return isTextStart(scnr, false);
            }
        };
        const ret = fn();
        scnr.resetPeek();
        return ret;
    }
    function isPluralStart(scnr) {
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === "|" /* TokenChars.Pipe */;
        scnr.resetPeek();
        return ret;
    }
    function detectModuloStart(scnr) {
        const spaces = peekSpaces(scnr);
        const ret = scnr.currentPeek() === "%" /* TokenChars.Modulo */ &&
            scnr.peek() === "{" /* TokenChars.BraceLeft */;
        scnr.resetPeek();
        return {
            isModulo: ret,
            hasSpace: spaces.length > 0
        };
    }
    function isTextStart(scnr, reset = true) {
        const fn = (hasSpace = false, prev = '', detectModulo = false) => {
            const ch = scnr.currentPeek();
            if (ch === "{" /* TokenChars.BraceLeft */) {
                return prev === "%" /* TokenChars.Modulo */ ? false : hasSpace;
            }
            else if (ch === "@" /* TokenChars.LinkedAlias */ || !ch) {
                return prev === "%" /* TokenChars.Modulo */ ? true : hasSpace;
            }
            else if (ch === "%" /* TokenChars.Modulo */) {
                scnr.peek();
                return fn(hasSpace, "%" /* TokenChars.Modulo */, true);
            }
            else if (ch === "|" /* TokenChars.Pipe */) {
                return prev === "%" /* TokenChars.Modulo */ || detectModulo
                    ? true
                    : !(prev === CHAR_SP || prev === CHAR_LF);
            }
            else if (ch === CHAR_SP) {
                scnr.peek();
                return fn(true, CHAR_SP, detectModulo);
            }
            else if (ch === CHAR_LF) {
                scnr.peek();
                return fn(true, CHAR_LF, detectModulo);
            }
            else {
                return true;
            }
        };
        const ret = fn();
        reset && scnr.resetPeek();
        return ret;
    }
    function takeChar(scnr, fn) {
        const ch = scnr.currentChar();
        if (ch === EOF) {
            return EOF;
        }
        if (fn(ch)) {
            scnr.next();
            return ch;
        }
        return null;
    }
    function isIdentifier(ch) {
        const cc = ch.charCodeAt(0);
        return ((cc >= 97 && cc <= 122) || // a-z
            (cc >= 65 && cc <= 90) || // A-Z
            (cc >= 48 && cc <= 57) || // 0-9
            cc === 95 || // _
            cc === 36 // $
        );
    }
    function takeIdentifierChar(scnr) {
        return takeChar(scnr, isIdentifier);
    }
    function isNamedIdentifier(ch) {
        const cc = ch.charCodeAt(0);
        return ((cc >= 97 && cc <= 122) || // a-z
            (cc >= 65 && cc <= 90) || // A-Z
            (cc >= 48 && cc <= 57) || // 0-9
            cc === 95 || // _
            cc === 36 || // $
            cc === 45 // -
        );
    }
    function takeNamedIdentifierChar(scnr) {
        return takeChar(scnr, isNamedIdentifier);
    }
    function isDigit(ch) {
        const cc = ch.charCodeAt(0);
        return cc >= 48 && cc <= 57; // 0-9
    }
    function takeDigit(scnr) {
        return takeChar(scnr, isDigit);
    }
    function isHexDigit(ch) {
        const cc = ch.charCodeAt(0);
        return ((cc >= 48 && cc <= 57) || // 0-9
            (cc >= 65 && cc <= 70) || // A-F
            (cc >= 97 && cc <= 102)); // a-f
    }
    function takeHexDigit(scnr) {
        return takeChar(scnr, isHexDigit);
    }
    function getDigits(scnr) {
        let ch = '';
        let num = '';
        while ((ch = takeDigit(scnr))) {
            num += ch;
        }
        return num;
    }
    function readModulo(scnr) {
        skipSpaces(scnr);
        const ch = scnr.currentChar();
        if (ch !== "%" /* TokenChars.Modulo */) {
            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
        }
        scnr.next();
        return "%" /* TokenChars.Modulo */;
    }
    function readText(scnr) {
        let buf = '';
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const ch = scnr.currentChar();
            if (ch === "{" /* TokenChars.BraceLeft */ ||
                ch === "}" /* TokenChars.BraceRight */ ||
                ch === "@" /* TokenChars.LinkedAlias */ ||
                ch === "|" /* TokenChars.Pipe */ ||
                !ch) {
                break;
            }
            else if (ch === "%" /* TokenChars.Modulo */) {
                if (isTextStart(scnr)) {
                    buf += ch;
                    scnr.next();
                }
                else {
                    break;
                }
            }
            else if (ch === CHAR_SP || ch === CHAR_LF) {
                if (isTextStart(scnr)) {
                    buf += ch;
                    scnr.next();
                }
                else if (isPluralStart(scnr)) {
                    break;
                }
                else {
                    buf += ch;
                    scnr.next();
                }
            }
            else {
                buf += ch;
                scnr.next();
            }
        }
        return buf;
    }
    function readNamedIdentifier(scnr) {
        skipSpaces(scnr);
        let ch = '';
        let name = '';
        while ((ch = takeNamedIdentifierChar(scnr))) {
            name += ch;
        }
        if (scnr.currentChar() === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        return name;
    }
    function readListIdentifier(scnr) {
        skipSpaces(scnr);
        let value = '';
        if (scnr.currentChar() === '-') {
            scnr.next();
            value += `-${getDigits(scnr)}`;
        }
        else {
            value += getDigits(scnr);
        }
        if (scnr.currentChar() === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        return value;
    }
    function isLiteral(ch) {
        return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
    }
    function readLiteral(scnr) {
        skipSpaces(scnr);
        // eslint-disable-next-line no-useless-escape
        eat(scnr, `\'`);
        let ch = '';
        let literal = '';
        while ((ch = takeChar(scnr, isLiteral))) {
            if (ch === '\\') {
                literal += readEscapeSequence(scnr);
            }
            else {
                literal += ch;
            }
        }
        const current = scnr.currentChar();
        if (current === CHAR_LF || current === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
            // TODO: Is it correct really?
            if (current === CHAR_LF) {
                scnr.next();
                // eslint-disable-next-line no-useless-escape
                eat(scnr, `\'`);
            }
            return literal;
        }
        // eslint-disable-next-line no-useless-escape
        eat(scnr, `\'`);
        return literal;
    }
    function readEscapeSequence(scnr) {
        const ch = scnr.currentChar();
        switch (ch) {
            case '\\':
            case `\'`: // eslint-disable-line no-useless-escape
                scnr.next();
                return `\\${ch}`;
            case 'u':
                return readUnicodeEscapeSequence(scnr, ch, 4);
            case 'U':
                return readUnicodeEscapeSequence(scnr, ch, 6);
            default:
                emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
                return '';
        }
    }
    function readUnicodeEscapeSequence(scnr, unicode, digits) {
        eat(scnr, unicode);
        let sequence = '';
        for (let i = 0; i < digits; i++) {
            const ch = takeHexDigit(scnr);
            if (!ch) {
                emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
                break;
            }
            sequence += ch;
        }
        return `\\${unicode}${sequence}`;
    }
    function isInvalidIdentifier(ch) {
        return (ch !== "{" /* TokenChars.BraceLeft */ &&
            ch !== "}" /* TokenChars.BraceRight */ &&
            ch !== CHAR_SP &&
            ch !== CHAR_LF);
    }
    function readInvalidIdentifier(scnr) {
        skipSpaces(scnr);
        let ch = '';
        let identifiers = '';
        while ((ch = takeChar(scnr, isInvalidIdentifier))) {
            identifiers += ch;
        }
        return identifiers;
    }
    function readLinkedModifier(scnr) {
        let ch = '';
        let name = '';
        while ((ch = takeIdentifierChar(scnr))) {
            name += ch;
        }
        return name;
    }
    function readLinkedRefer(scnr) {
        const fn = (buf) => {
            const ch = scnr.currentChar();
            if (ch === "{" /* TokenChars.BraceLeft */ ||
                ch === "%" /* TokenChars.Modulo */ ||
                ch === "@" /* TokenChars.LinkedAlias */ ||
                ch === "|" /* TokenChars.Pipe */ ||
                ch === "(" /* TokenChars.ParenLeft */ ||
                ch === ")" /* TokenChars.ParenRight */ ||
                !ch) {
                return buf;
            }
            else if (ch === CHAR_SP) {
                return buf;
            }
            else if (ch === CHAR_LF || ch === DOT) {
                buf += ch;
                scnr.next();
                return fn(buf);
            }
            else {
                buf += ch;
                scnr.next();
                return fn(buf);
            }
        };
        return fn('');
    }
    function readPlural(scnr) {
        skipSpaces(scnr);
        const plural = eat(scnr, "|" /* TokenChars.Pipe */);
        skipSpaces(scnr);
        return plural;
    }
    // TODO: We need refactoring of token parsing ...
    function readTokenInPlaceholder(scnr, context) {
        let token = null;
        const ch = scnr.currentChar();
        switch (ch) {
            case "{" /* TokenChars.BraceLeft */:
                if (context.braceNest >= 1) {
                    emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
                }
                scnr.next();
                token = getToken(context, 2 /* TokenTypes.BraceLeft */, "{" /* TokenChars.BraceLeft */);
                skipSpaces(scnr);
                context.braceNest++;
                return token;
            case "}" /* TokenChars.BraceRight */:
                if (context.braceNest > 0 &&
                    context.currentType === 2 /* TokenTypes.BraceLeft */) {
                    emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
                }
                scnr.next();
                token = getToken(context, 3 /* TokenTypes.BraceRight */, "}" /* TokenChars.BraceRight */);
                context.braceNest--;
                context.braceNest > 0 && skipSpaces(scnr);
                if (context.inLinked && context.braceNest === 0) {
                    context.inLinked = false;
                }
                return token;
            case "@" /* TokenChars.LinkedAlias */:
                if (context.braceNest > 0) {
                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                }
                token = readTokenInLinked(scnr, context) || getEndToken(context);
                context.braceNest = 0;
                return token;
            default: {
                let validNamedIdentifier = true;
                let validListIdentifier = true;
                let validLiteral = true;
                if (isPluralStart(scnr)) {
                    if (context.braceNest > 0) {
                        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                    }
                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));
                    // reset
                    context.braceNest = 0;
                    context.inLinked = false;
                    return token;
                }
                if (context.braceNest > 0 &&
                    (context.currentType === 5 /* TokenTypes.Named */ ||
                        context.currentType === 6 /* TokenTypes.List */ ||
                        context.currentType === 7 /* TokenTypes.Literal */)) {
                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                    context.braceNest = 0;
                    return readToken(scnr, context);
                }
                if ((validNamedIdentifier = isNamedIdentifierStart(scnr, context))) {
                    token = getToken(context, 5 /* TokenTypes.Named */, readNamedIdentifier(scnr));
                    skipSpaces(scnr);
                    return token;
                }
                if ((validListIdentifier = isListIdentifierStart(scnr, context))) {
                    token = getToken(context, 6 /* TokenTypes.List */, readListIdentifier(scnr));
                    skipSpaces(scnr);
                    return token;
                }
                if ((validLiteral = isLiteralStart(scnr, context))) {
                    token = getToken(context, 7 /* TokenTypes.Literal */, readLiteral(scnr));
                    skipSpaces(scnr);
                    return token;
                }
                if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
                    // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...
                    token = getToken(context, 13 /* TokenTypes.InvalidPlace */, readInvalidIdentifier(scnr));
                    emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
                    skipSpaces(scnr);
                    return token;
                }
                break;
            }
        }
        return token;
    }
    // TODO: We need refactoring of token parsing ...
    function readTokenInLinked(scnr, context) {
        const { currentType } = context;
        let token = null;
        const ch = scnr.currentChar();
        if ((currentType === 8 /* TokenTypes.LinkedAlias */ ||
            currentType === 9 /* TokenTypes.LinkedDot */ ||
            currentType === 12 /* TokenTypes.LinkedModifier */ ||
            currentType === 10 /* TokenTypes.LinkedDelimiter */) &&
            (ch === CHAR_LF || ch === CHAR_SP)) {
            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        switch (ch) {
            case "@" /* TokenChars.LinkedAlias */:
                scnr.next();
                token = getToken(context, 8 /* TokenTypes.LinkedAlias */, "@" /* TokenChars.LinkedAlias */);
                context.inLinked = true;
                return token;
            case "." /* TokenChars.LinkedDot */:
                skipSpaces(scnr);
                scnr.next();
                return getToken(context, 9 /* TokenTypes.LinkedDot */, "." /* TokenChars.LinkedDot */);
            case ":" /* TokenChars.LinkedDelimiter */:
                skipSpaces(scnr);
                scnr.next();
                return getToken(context, 10 /* TokenTypes.LinkedDelimiter */, ":" /* TokenChars.LinkedDelimiter */);
            default:
                if (isPluralStart(scnr)) {
                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));
                    // reset
                    context.braceNest = 0;
                    context.inLinked = false;
                    return token;
                }
                if (isLinkedDotStart(scnr, context) ||
                    isLinkedDelimiterStart(scnr, context)) {
                    skipSpaces(scnr);
                    return readTokenInLinked(scnr, context);
                }
                if (isLinkedModifierStart(scnr, context)) {
                    skipSpaces(scnr);
                    return getToken(context, 12 /* TokenTypes.LinkedModifier */, readLinkedModifier(scnr));
                }
                if (isLinkedReferStart(scnr, context)) {
                    skipSpaces(scnr);
                    if (ch === "{" /* TokenChars.BraceLeft */) {
                        // scan the placeholder
                        return readTokenInPlaceholder(scnr, context) || token;
                    }
                    else {
                        return getToken(context, 11 /* TokenTypes.LinkedKey */, readLinkedRefer(scnr));
                    }
                }
                if (currentType === 8 /* TokenTypes.LinkedAlias */) {
                    emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
                }
                context.braceNest = 0;
                context.inLinked = false;
                return readToken(scnr, context);
        }
    }
    // TODO: We need refactoring of token parsing ...
    function readToken(scnr, context) {
        let token = { type: 14 /* TokenTypes.EOF */ };
        if (context.braceNest > 0) {
            return readTokenInPlaceholder(scnr, context) || getEndToken(context);
        }
        if (context.inLinked) {
            return readTokenInLinked(scnr, context) || getEndToken(context);
        }
        const ch = scnr.currentChar();
        switch (ch) {
            case "{" /* TokenChars.BraceLeft */:
                return readTokenInPlaceholder(scnr, context) || getEndToken(context);
            case "}" /* TokenChars.BraceRight */:
                emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
                scnr.next();
                return getToken(context, 3 /* TokenTypes.BraceRight */, "}" /* TokenChars.BraceRight */);
            case "@" /* TokenChars.LinkedAlias */:
                return readTokenInLinked(scnr, context) || getEndToken(context);
            default: {
                if (isPluralStart(scnr)) {
                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));
                    // reset
                    context.braceNest = 0;
                    context.inLinked = false;
                    return token;
                }
                const { isModulo, hasSpace } = detectModuloStart(scnr);
                if (isModulo) {
                    return hasSpace
                        ? getToken(context, 0 /* TokenTypes.Text */, readText(scnr))
                        : getToken(context, 4 /* TokenTypes.Modulo */, readModulo(scnr));
                }
                if (isTextStart(scnr)) {
                    return getToken(context, 0 /* TokenTypes.Text */, readText(scnr));
                }
                break;
            }
        }
        return token;
    }
    function nextToken() {
        const { currentType, offset, startLoc, endLoc } = _context;
        _context.lastType = currentType;
        _context.lastOffset = offset;
        _context.lastStartLoc = startLoc;
        _context.lastEndLoc = endLoc;
        _context.offset = currentOffset();
        _context.startLoc = currentPosition();
        if (_scnr.currentChar() === EOF) {
            return getToken(_context, 14 /* TokenTypes.EOF */);
        }
        return readToken(_scnr, _context);
    }
    return {
        nextToken,
        currentOffset,
        currentPosition,
        context
    };
}

const ERROR_DOMAIN$2 = 'parser';
// Backslash backslash, backslash quote, uHHHH, UHHHHHH.
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
    switch (match) {
        case `\\\\`:
            return `\\`;
        // eslint-disable-next-line no-useless-escape
        case `\\\'`:
            // eslint-disable-next-line no-useless-escape
            return `\'`;
        default: {
            const codePoint = parseInt(codePoint4 || codePoint6, 16);
            if (codePoint <= 0xd7ff || codePoint >= 0xe000) {
                return String.fromCodePoint(codePoint);
            }
            // invalid ...
            // Replace them with U+FFFD REPLACEMENT CHARACTER.
            return '';
        }
    }
}
function createParser(options = {}) {
    const location = options.location !== false;
    const { onError, onWarn } = options;
    function emitError(tokenzer, code, start, offset, ...args) {
        const end = tokenzer.currentPosition();
        end.offset += offset;
        end.column += offset;
        if (onError) {
            const loc = location ? createLocation(start, end) : null;
            const err = createCompileError(code, loc, {
                domain: ERROR_DOMAIN$2,
                args
            });
            onError(err);
        }
    }
    function emitWarn(tokenzer, code, start, offset, ...args) {
        const end = tokenzer.currentPosition();
        end.offset += offset;
        end.column += offset;
        if (onWarn) {
            const loc = location ? createLocation(start, end) : null;
            onWarn(createCompileWarn(code, loc, args));
        }
    }
    function startNode(type, offset, loc) {
        const node = { type };
        if (location) {
            node.start = offset;
            node.end = offset;
            node.loc = { start: loc, end: loc };
        }
        return node;
    }
    function endNode(node, offset, pos, type) {
        if (location) {
            node.end = offset;
            if (node.loc) {
                node.loc.end = pos;
            }
        }
    }
    function parseText(tokenizer, value) {
        const context = tokenizer.context();
        const node = startNode(3 /* NodeTypes.Text */, context.offset, context.startLoc);
        node.value = value;
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseList(tokenizer, index) {
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc
        const node = startNode(5 /* NodeTypes.List */, offset, loc);
        node.index = parseInt(index, 10);
        tokenizer.nextToken(); // skip brach right
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseNamed(tokenizer, key, modulo) {
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc
        const node = startNode(4 /* NodeTypes.Named */, offset, loc);
        node.key = key;
        if (modulo === true) {
            node.modulo = true;
        }
        tokenizer.nextToken(); // skip brach right
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseLiteral(tokenizer, value) {
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc
        const node = startNode(9 /* NodeTypes.Literal */, offset, loc);
        node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
        tokenizer.nextToken(); // skip brach right
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseLinkedModifier(tokenizer) {
        const token = tokenizer.nextToken();
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context; // get linked dot loc
        const node = startNode(8 /* NodeTypes.LinkedModifier */, offset, loc);
        if (token.type !== 12 /* TokenTypes.LinkedModifier */) {
            // empty modifier
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
            node.value = '';
            endNode(node, offset, loc);
            return {
                nextConsumeToken: token,
                node
            };
        }
        // check token
        if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        node.value = token.value || '';
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return {
            node
        };
    }
    function parseLinkedKey(tokenizer, value) {
        const context = tokenizer.context();
        const node = startNode(7 /* NodeTypes.LinkedKey */, context.offset, context.startLoc);
        node.value = value;
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseLinked(tokenizer) {
        const context = tokenizer.context();
        const linkedNode = startNode(6 /* NodeTypes.Linked */, context.offset, context.startLoc);
        let token = tokenizer.nextToken();
        if (token.type === 9 /* TokenTypes.LinkedDot */) {
            const parsed = parseLinkedModifier(tokenizer);
            linkedNode.modifier = parsed.node;
            token = parsed.nextConsumeToken || tokenizer.nextToken();
        }
        // asset check token
        if (token.type !== 10 /* TokenTypes.LinkedDelimiter */) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        token = tokenizer.nextToken();
        // skip brace left
        if (token.type === 2 /* TokenTypes.BraceLeft */) {
            token = tokenizer.nextToken();
        }
        switch (token.type) {
            case 11 /* TokenTypes.LinkedKey */:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseLinkedKey(tokenizer, token.value || '');
                break;
            case 5 /* TokenTypes.Named */:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseNamed(tokenizer, token.value || '');
                break;
            case 6 /* TokenTypes.List */:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseList(tokenizer, token.value || '');
                break;
            case 7 /* TokenTypes.Literal */:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseLiteral(tokenizer, token.value || '');
                break;
            default: {
                // empty key
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
                const nextContext = tokenizer.context();
                const emptyLinkedKeyNode = startNode(7 /* NodeTypes.LinkedKey */, nextContext.offset, nextContext.startLoc);
                emptyLinkedKeyNode.value = '';
                endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
                linkedNode.key = emptyLinkedKeyNode;
                endNode(linkedNode, nextContext.offset, nextContext.startLoc);
                return {
                    nextConsumeToken: token,
                    node: linkedNode
                };
            }
        }
        endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
        return {
            node: linkedNode
        };
    }
    function parseMessage(tokenizer) {
        const context = tokenizer.context();
        const startOffset = context.currentType === 1 /* TokenTypes.Pipe */
            ? tokenizer.currentOffset()
            : context.offset;
        const startLoc = context.currentType === 1 /* TokenTypes.Pipe */
            ? context.endLoc
            : context.startLoc;
        const node = startNode(2 /* NodeTypes.Message */, startOffset, startLoc);
        node.items = [];
        let nextToken = null;
        let modulo = null;
        do {
            const token = nextToken || tokenizer.nextToken();
            nextToken = null;
            switch (token.type) {
                case 0 /* TokenTypes.Text */:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseText(tokenizer, token.value || ''));
                    break;
                case 6 /* TokenTypes.List */:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseList(tokenizer, token.value || ''));
                    break;
                case 4 /* TokenTypes.Modulo */:
                    modulo = true;
                    break;
                case 5 /* TokenTypes.Named */:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseNamed(tokenizer, token.value || '', !!modulo));
                    if (modulo) {
                        emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));
                        modulo = null;
                    }
                    break;
                case 7 /* TokenTypes.Literal */:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseLiteral(tokenizer, token.value || ''));
                    break;
                case 8 /* TokenTypes.LinkedAlias */: {
                    const parsed = parseLinked(tokenizer);
                    node.items.push(parsed.node);
                    nextToken = parsed.nextConsumeToken || null;
                    break;
                }
            }
        } while (context.currentType !== 14 /* TokenTypes.EOF */ &&
            context.currentType !== 1 /* TokenTypes.Pipe */);
        // adjust message node loc
        const endOffset = context.currentType === 1 /* TokenTypes.Pipe */
            ? context.lastOffset
            : tokenizer.currentOffset();
        const endLoc = context.currentType === 1 /* TokenTypes.Pipe */
            ? context.lastEndLoc
            : tokenizer.currentPosition();
        endNode(node, endOffset, endLoc);
        return node;
    }
    function parsePlural(tokenizer, offset, loc, msgNode) {
        const context = tokenizer.context();
        let hasEmptyMessage = msgNode.items.length === 0;
        const node = startNode(1 /* NodeTypes.Plural */, offset, loc);
        node.cases = [];
        node.cases.push(msgNode);
        do {
            const msg = parseMessage(tokenizer);
            if (!hasEmptyMessage) {
                hasEmptyMessage = msg.items.length === 0;
            }
            node.cases.push(msg);
        } while (context.currentType !== 14 /* TokenTypes.EOF */);
        if (hasEmptyMessage) {
            emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
        }
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseResource(tokenizer) {
        const context = tokenizer.context();
        const { offset, startLoc } = context;
        const msgNode = parseMessage(tokenizer);
        if (context.currentType === 14 /* TokenTypes.EOF */) {
            return msgNode;
        }
        else {
            return parsePlural(tokenizer, offset, startLoc, msgNode);
        }
    }
    function parse(source) {
        const tokenizer = createTokenizer(source, assign({}, options));
        const context = tokenizer.context();
        const node = startNode(0 /* NodeTypes.Resource */, context.offset, context.startLoc);
        if (location && node.loc) {
            node.loc.source = source;
        }
        node.body = parseResource(tokenizer);
        if (options.onCacheKey) {
            node.cacheKey = options.onCacheKey(source);
        }
        // assert whether achieved to EOF
        if (context.currentType !== 14 /* TokenTypes.EOF */) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');
        }
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    return { parse };
}
function getTokenCaption(token) {
    if (token.type === 14 /* TokenTypes.EOF */) {
        return 'EOF';
    }
    const name = (token.value || '').replace(/\r?\n/gu, '\\n');
    return name.length > 10 ? name.slice(0, 9) + '' : name;
}

function createTransformer(ast, options = {} // eslint-disable-line
) {
    const _context = {
        ast,
        helpers: new Set()
    };
    const context = () => _context;
    const helper = (name) => {
        _context.helpers.add(name);
        return name;
    };
    return { context, helper };
}
function traverseNodes(nodes, transformer) {
    for (let i = 0; i < nodes.length; i++) {
        traverseNode(nodes[i], transformer);
    }
}
function traverseNode(node, transformer) {
    // TODO: if we need pre-hook of transform, should be implemented to here
    switch (node.type) {
        case 1 /* NodeTypes.Plural */:
            traverseNodes(node.cases, transformer);
            transformer.helper("plural" /* HelperNameMap.PLURAL */);
            break;
        case 2 /* NodeTypes.Message */:
            traverseNodes(node.items, transformer);
            break;
        case 6 /* NodeTypes.Linked */: {
            const linked = node;
            traverseNode(linked.key, transformer);
            transformer.helper("linked" /* HelperNameMap.LINKED */);
            transformer.helper("type" /* HelperNameMap.TYPE */);
            break;
        }
        case 5 /* NodeTypes.List */:
            transformer.helper("interpolate" /* HelperNameMap.INTERPOLATE */);
            transformer.helper("list" /* HelperNameMap.LIST */);
            break;
        case 4 /* NodeTypes.Named */:
            transformer.helper("interpolate" /* HelperNameMap.INTERPOLATE */);
            transformer.helper("named" /* HelperNameMap.NAMED */);
            break;
    }
    // TODO: if we need post-hook of transform, should be implemented to here
}
// transform AST
function transform(ast, options = {} // eslint-disable-line
) {
    const transformer = createTransformer(ast);
    transformer.helper("normalize" /* HelperNameMap.NORMALIZE */);
    // traverse
    ast.body && traverseNode(ast.body, transformer);
    // set meta information
    const context = transformer.context();
    ast.helpers = Array.from(context.helpers);
}

function optimize(ast) {
    const body = ast.body;
    if (body.type === 2 /* NodeTypes.Message */) {
        optimizeMessageNode(body);
    }
    else {
        body.cases.forEach(c => optimizeMessageNode(c));
    }
    return ast;
}
function optimizeMessageNode(message) {
    if (message.items.length === 1) {
        const item = message.items[0];
        if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {
            message.static = item.value;
            delete item.value; // optimization for size
        }
    }
    else {
        const values = [];
        for (let i = 0; i < message.items.length; i++) {
            const item = message.items[i];
            if (!(item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */)) {
                break;
            }
            if (item.value == null) {
                break;
            }
            values.push(item.value);
        }
        if (values.length === message.items.length) {
            message.static = join(values);
            for (let i = 0; i < message.items.length; i++) {
                const item = message.items[i];
                if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {
                    delete item.value; // optimization for size
                }
            }
        }
    }
}

const ERROR_DOMAIN$1 = 'minifier';
/* eslint-disable @typescript-eslint/no-explicit-any */
function minify(node) {
    node.t = node.type;
    switch (node.type) {
        case 0 /* NodeTypes.Resource */: {
            const resource = node;
            minify(resource.body);
            resource.b = resource.body;
            delete resource.body;
            break;
        }
        case 1 /* NodeTypes.Plural */: {
            const plural = node;
            const cases = plural.cases;
            for (let i = 0; i < cases.length; i++) {
                minify(cases[i]);
            }
            plural.c = cases;
            delete plural.cases;
            break;
        }
        case 2 /* NodeTypes.Message */: {
            const message = node;
            const items = message.items;
            for (let i = 0; i < items.length; i++) {
                minify(items[i]);
            }
            message.i = items;
            delete message.items;
            if (message.static) {
                message.s = message.static;
                delete message.static;
            }
            break;
        }
        case 3 /* NodeTypes.Text */:
        case 9 /* NodeTypes.Literal */:
        case 8 /* NodeTypes.LinkedModifier */:
        case 7 /* NodeTypes.LinkedKey */: {
            const valueNode = node;
            if (valueNode.value) {
                valueNode.v = valueNode.value;
                delete valueNode.value;
            }
            break;
        }
        case 6 /* NodeTypes.Linked */: {
            const linked = node;
            minify(linked.key);
            linked.k = linked.key;
            delete linked.key;
            if (linked.modifier) {
                minify(linked.modifier);
                linked.m = linked.modifier;
                delete linked.modifier;
            }
            break;
        }
        case 5 /* NodeTypes.List */: {
            const list = node;
            list.i = list.index;
            delete list.index;
            break;
        }
        case 4 /* NodeTypes.Named */: {
            const named = node;
            named.k = named.key;
            delete named.key;
            break;
        }
        default:
            {
                throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
                    domain: ERROR_DOMAIN$1,
                    args: [node.type]
                });
            }
    }
    delete node.type;
}
/* eslint-enable @typescript-eslint/no-explicit-any */

// eslint-disable-next-line @typescript-eslint/triple-slash-reference
/// <reference types="source-map-js" />
const ERROR_DOMAIN = 'parser';
function createCodeGenerator(ast, options) {
    const { filename, breakLineCode, needIndent: _needIndent } = options;
    const location = options.location !== false;
    const _context = {
        filename,
        code: '',
        column: 1,
        line: 1,
        offset: 0,
        map: undefined,
        breakLineCode,
        needIndent: _needIndent,
        indentLevel: 0
    };
    if (location && ast.loc) {
        _context.source = ast.loc.source;
    }
    const context = () => _context;
    function push(code, node) {
        _context.code += code;
    }
    function _newline(n, withBreakLine = true) {
        const _breakLineCode = withBreakLine ? breakLineCode : '';
        push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
    }
    function indent(withNewLine = true) {
        const level = ++_context.indentLevel;
        withNewLine && _newline(level);
    }
    function deindent(withNewLine = true) {
        const level = --_context.indentLevel;
        withNewLine && _newline(level);
    }
    function newline() {
        _newline(_context.indentLevel);
    }
    const helper = (key) => `_${key}`;
    const needIndent = () => _context.needIndent;
    return {
        context,
        push,
        indent,
        deindent,
        newline,
        helper,
        needIndent
    };
}
function generateLinkedNode(generator, node) {
    const { helper } = generator;
    generator.push(`${helper("linked" /* HelperNameMap.LINKED */)}(`);
    generateNode(generator, node.key);
    if (node.modifier) {
        generator.push(`, `);
        generateNode(generator, node.modifier);
        generator.push(`, _type`);
    }
    else {
        generator.push(`, undefined, _type`);
    }
    generator.push(`)`);
}
function generateMessageNode(generator, node) {
    const { helper, needIndent } = generator;
    generator.push(`${helper("normalize" /* HelperNameMap.NORMALIZE */)}([`);
    generator.indent(needIndent());
    const length = node.items.length;
    for (let i = 0; i < length; i++) {
        generateNode(generator, node.items[i]);
        if (i === length - 1) {
            break;
        }
        generator.push(', ');
    }
    generator.deindent(needIndent());
    generator.push('])');
}
function generatePluralNode(generator, node) {
    const { helper, needIndent } = generator;
    if (node.cases.length > 1) {
        generator.push(`${helper("plural" /* HelperNameMap.PLURAL */)}([`);
        generator.indent(needIndent());
        const length = node.cases.length;
        for (let i = 0; i < length; i++) {
            generateNode(generator, node.cases[i]);
            if (i === length - 1) {
                break;
            }
            generator.push(', ');
        }
        generator.deindent(needIndent());
        generator.push(`])`);
    }
}
function generateResource(generator, node) {
    if (node.body) {
        generateNode(generator, node.body);
    }
    else {
        generator.push('null');
    }
}
function generateNode(generator, node) {
    const { helper } = generator;
    switch (node.type) {
        case 0 /* NodeTypes.Resource */:
            generateResource(generator, node);
            break;
        case 1 /* NodeTypes.Plural */:
            generatePluralNode(generator, node);
            break;
        case 2 /* NodeTypes.Message */:
            generateMessageNode(generator, node);
            break;
        case 6 /* NodeTypes.Linked */:
            generateLinkedNode(generator, node);
            break;
        case 8 /* NodeTypes.LinkedModifier */:
            generator.push(JSON.stringify(node.value), node);
            break;
        case 7 /* NodeTypes.LinkedKey */:
            generator.push(JSON.stringify(node.value), node);
            break;
        case 5 /* NodeTypes.List */:
            generator.push(`${helper("interpolate" /* HelperNameMap.INTERPOLATE */)}(${helper("list" /* HelperNameMap.LIST */)}(${node.index}))`, node);
            break;
        case 4 /* NodeTypes.Named */:
            generator.push(`${helper("interpolate" /* HelperNameMap.INTERPOLATE */)}(${helper("named" /* HelperNameMap.NAMED */)}(${JSON.stringify(node.key)}))`, node);
            break;
        case 9 /* NodeTypes.Literal */:
            generator.push(JSON.stringify(node.value), node);
            break;
        case 3 /* NodeTypes.Text */:
            generator.push(JSON.stringify(node.value), node);
            break;
        default:
            {
                throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
                    domain: ERROR_DOMAIN,
                    args: [node.type]
                });
            }
    }
}
// generate code from AST
const generate = (ast, options = {} // eslint-disable-line
) => {
    const mode = isString(options.mode) ? options.mode : 'normal';
    const filename = isString(options.filename)
        ? options.filename
        : 'message.intl';
    !!options.sourceMap;
    // prettier-ignore
    const breakLineCode = options.breakLineCode != null
        ? options.breakLineCode
        : mode === 'arrow'
            ? ';'
            : '\n';
    const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';
    const helpers = ast.helpers || [];
    const generator = createCodeGenerator(ast, {
        filename,
        breakLineCode,
        needIndent
    });
    generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);
    generator.indent(needIndent);
    if (helpers.length > 0) {
        generator.push(`const { ${join(helpers.map(s => `${s}: _${s}`), ', ')} } = ctx`);
        generator.newline();
    }
    generator.push(`return `);
    generateNode(generator, ast);
    generator.deindent(needIndent);
    generator.push(`}`);
    delete ast.helpers;
    const { code, map } = generator.context();
    return {
        ast,
        code,
        map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any
    };
};

function baseCompile$1(source, options = {}) {
    const assignedOptions = assign({}, options);
    const jit = !!assignedOptions.jit;
    const enalbeMinify = !!assignedOptions.minify;
    const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
    // parse source codes
    const parser = createParser(assignedOptions);
    const ast = parser.parse(source);
    if (!jit) {
        // transform ASTs
        transform(ast, assignedOptions);
        // generate javascript codes
        return generate(ast, assignedOptions);
    }
    else {
        // optimize ASTs
        enambeOptimize && optimize(ast);
        // minimize ASTs
        enalbeMinify && minify(ast);
        // In JIT mode, no ast transform, no code generation.
        return { ast, code: '' };
    }
}

/*!
  * core-base v9.14.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function initFeatureFlags$1() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
}
function isMessageAST(val) {
  return isObject$1(val) && resolveType(val) === 0 && (hasOwn(val, "b") || hasOwn(val, "body"));
}
const PROPS_BODY = ["b", "body"];
function resolveBody(node) {
  return resolveProps(node, PROPS_BODY);
}
const PROPS_CASES = ["c", "cases"];
function resolveCases(node) {
  return resolveProps(node, PROPS_CASES, []);
}
const PROPS_STATIC = ["s", "static"];
function resolveStatic(node) {
  return resolveProps(node, PROPS_STATIC);
}
const PROPS_ITEMS = ["i", "items"];
function resolveItems(node) {
  return resolveProps(node, PROPS_ITEMS, []);
}
const PROPS_TYPE = ["t", "type"];
function resolveType(node) {
  return resolveProps(node, PROPS_TYPE);
}
const PROPS_VALUE = ["v", "value"];
function resolveValue$1(node, type) {
  const resolved = resolveProps(node, PROPS_VALUE);
  if (resolved != null) {
    return resolved;
  } else {
    throw createUnhandleNodeError(type);
  }
}
const PROPS_MODIFIER = ["m", "modifier"];
function resolveLinkedModifier(node) {
  return resolveProps(node, PROPS_MODIFIER);
}
const PROPS_KEY = ["k", "key"];
function resolveLinkedKey(node) {
  const resolved = resolveProps(node, PROPS_KEY);
  if (resolved) {
    return resolved;
  } else {
    throw createUnhandleNodeError(
      6
      /* NodeTypes.Linked */
    );
  }
}
function resolveProps(node, props, defaultValue) {
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (hasOwn(node, prop) && node[prop] != null) {
      return node[prop];
    }
  }
  return defaultValue;
}
const AST_NODE_PROPS_KEYS = [
  ...PROPS_BODY,
  ...PROPS_CASES,
  ...PROPS_STATIC,
  ...PROPS_ITEMS,
  ...PROPS_KEY,
  ...PROPS_MODIFIER,
  ...PROPS_VALUE,
  ...PROPS_TYPE
];
function createUnhandleNodeError(type) {
  return new Error(`unhandled node type: ${type}`);
}
const pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch) {
  if (ch === void 0 || ch === null) {
    return "o";
  }
  const code2 = ch.charCodeAt(0);
  switch (code2) {
    case 91:
    // [
    case 93:
    // ]
    case 46:
    // .
    case 34:
    // "
    case 39:
      return ch;
    case 95:
    // _
    case 36:
    // $
    case 45:
      return "i";
    case 9:
    // Tab (HT)
    case 10:
    // Newline (LF)
    case 13:
    // Return (CR)
    case 160:
    // No-break space (NBSP)
    case 65279:
    // Byte Order Mark (BOM)
    case 8232:
    // Line Separator (LS)
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse(path) {
  const keys = [];
  let index = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c;
  let key;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  while (mode !== null) {
    index++;
    c = path[index];
    if (c === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys;
    }
  }
}
const cache = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject$1(obj) ? obj[path] : null;
}
function resolveValue(obj, path) {
  if (!isObject$1(obj)) {
    return null;
  }
  let hit = cache.get(path);
  if (!hit) {
    hit = parse(path);
    if (hit) {
      cache.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i = 0;
  while (i < len) {
    const key = hit[i];
    if (AST_NODE_PROPS_KEYS.includes(key) && isMessageAST(last)) {
      return null;
    }
    const val = last[key];
    if (val === void 0) {
      return null;
    }
    if (isFunction(last)) {
      return null;
    }
    last = val;
    i++;
  }
  return last;
}
const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join$1(values);
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
  const index = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
  return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index : index;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject$1(options.pluralRules) && isString$1(locale) && isFunction(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject$1(options.pluralRules) && isString$1(locale) && isFunction(options.pluralRules[locale]) ? pluralDefault : void 0;
  const plural = (messages) => {
    return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
  };
  const _list = options.list || [];
  const list = (index) => _list[index];
  const _named = options.named || create();
  isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key) => _named[key];
  function message(key) {
    const msg = isFunction(options.messages) ? options.messages(key) : isObject$1(options.messages) ? options.messages[key] : false;
    return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
  const normalize = isPlainObject(options.processor) && isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject(options.processor) && isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject(options.processor) && isString$1(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type2 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject$1(arg1)) {
        modifier = arg1.modifier || modifier;
        type2 = arg1.type || type2;
      } else if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString$1(arg2)) {
        type2 = arg2 || type2;
      }
    }
    const ret = message(key)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type2 === "vnode" && isArray(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type2) : msg;
  };
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign$1(create(), _list, _named)
  };
  return ctx;
}
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n, version, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n,
    version,
    meta
  });
}
const translateDevTools = /* @__PURE__ */ createDevToolsHook(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
const inc$1$1 = incrementer(code$1$1);
const CoreWarnCodes = {
  // 2
  FALLBACK_TO_TRANSLATE: inc$1$1(),
  // 3
  CANNOT_FORMAT_NUMBER: inc$1$1(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
  // 5
  CANNOT_FORMAT_DATE: inc$1$1(),
  // 6
  FALLBACK_TO_DATE_FORMAT: inc$1$1(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
  // 8
  __EXTEND_POINT__: inc$1$1()
  // 9
};
const code$2 = CompileErrorCodes.__EXTEND_POINT__;
const inc$2 = incrementer(code$2);
const CoreErrorCodes = {
  INVALID_ARGUMENT: code$2,
  // 17
  INVALID_DATE_ARGUMENT: inc$2(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: inc$2(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: inc$2(),
  // 23
  __EXTEND_POINT__: inc$2()
  // 24
};
function createCoreError(code2) {
  return createCompileError(code2, null, void 0);
}
function getLocale$1(context, options) {
  return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
}
let _resolveLocale;
function resolveLocale(locale) {
  if (isString$1(locale)) {
    return locale;
  } else {
    if (isFunction(locale)) {
      if (locale.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale.constructor.name === "Function") {
        const resolve = locale();
        if (isPromise(resolve)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
function fallbackWithSimple(ctx, fallback, start) {
  return [.../* @__PURE__ */ new Set([
    start,
    ...isArray(fallback) ? fallback : isObject$1(fallback) ? Object.keys(fallback) : isString$1(fallback) ? [fallback] : [start]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = isString$1(start) ? start : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block = [start];
    while (isArray(block)) {
      block = appendBlockToChain(chain, block, fallback);
    }
    const defaults = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block = isString$1(defaults) ? [defaults] : defaults;
    if (isArray(block)) {
      appendBlockToChain(chain, block, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block, blocks) {
  let follow = true;
  for (let i = 0; i < block.length && isBoolean(follow); i++) {
    const locale = block[i];
    if (isString$1(locale)) {
      follow = appendLocaleToChain(chain, block[i], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens = locale.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target, blocks) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale = target.replace(/!/g, "");
      chain.push(locale);
      if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale]) {
        follow = blocks[locale];
      }
    }
  }
  return follow;
}
const VERSION$1 = "9.14.5";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type) => {
      return type === "text" && isString$1(val) ? val.toUpperCase() : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type) => {
      return type === "text" && isString$1(val) ? val.toLowerCase() : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type) => {
      return type === "text" && isString$1(val) ? capitalize(val) : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }
  };
}
let _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
let _additionalMeta = null;
const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
  _additionalMeta = meta;
};
const getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta;
let _fallbackContext = null;
const setFallbackContext = (context) => {
  _fallbackContext = context;
};
const getFallbackContext = () => _fallbackContext;
let _cid = 0;
function createCoreContext(options = {}) {
  const onWarn = isFunction(options.onWarn) ? options.onWarn : warn;
  const version = isString$1(options.version) ? options.version : VERSION$1;
  const locale = isString$1(options.locale) || isFunction(options.locale) ? options.locale : DEFAULT_LOCALE;
  const _locale = isFunction(locale) ? DEFAULT_LOCALE : locale;
  const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
  const messages = isPlainObject(options.messages) ? options.messages : createResources(_locale);
  const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : createResources(_locale);
  const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : createResources(_locale);
  const modifiers = assign$1(create(), options.modifiers, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || create();
  const missing = isFunction(options.missing) ? options.missing : null;
  const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
  const messageResolver = isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$1(options.fallbackContext) ? options.fallbackContext : void 0;
  const internalOptions = options;
  const __datetimeFormatters = isObject$1(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject$1(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject$1(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version,
    cid: _cid,
    locale,
    fallbackLocale,
    messages,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version, __meta);
  }
  return context;
}
const createResources = (locale) => ({ [locale]: create() });
function handleMissing(context, key, locale, missingWarn, type) {
  const { missing, onWarn } = context;
  if (missing !== null) {
    const ret = missing(context, locale, key, type);
    return isString$1(ret) ? ret : key;
  } else {
    return key;
  }
}
function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
function isAlmostSameLocale(locale, compareLocale) {
  if (locale === compareLocale)
    return false;
  return locale.split("-")[0] === compareLocale.split("-")[0];
}
function isImplicitFallback(targetLocale, locales) {
  const index = locales.indexOf(targetLocale);
  if (index === -1) {
    return false;
  }
  for (let i = index + 1; i < locales.length; i++) {
    if (isAlmostSameLocale(targetLocale, locales[i])) {
      return true;
    }
  }
  return false;
}
function format(ast) {
  const msg = (ctx) => formatParts(ctx, ast);
  return msg;
}
function formatParts(ctx, ast) {
  const body = resolveBody(ast);
  if (body == null) {
    throw createUnhandleNodeError(
      0
      /* NodeTypes.Resource */
    );
  }
  const type = resolveType(body);
  if (type === 1) {
    const plural = body;
    const cases = resolveCases(plural);
    return ctx.plural(cases.reduce((messages, c) => [
      ...messages,
      formatMessageParts(ctx, c)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
function formatMessageParts(ctx, node) {
  const static_ = resolveStatic(node);
  if (static_ != null) {
    return ctx.type === "text" ? static_ : ctx.normalize([static_]);
  } else {
    const messages = resolveItems(node).reduce((acm, c) => [...acm, formatMessagePart(ctx, c)], []);
    return ctx.normalize(messages);
  }
}
function formatMessagePart(ctx, node) {
  const type = resolveType(node);
  switch (type) {
    case 3: {
      return resolveValue$1(node, type);
    }
    case 9: {
      return resolveValue$1(node, type);
    }
    case 4: {
      const named = node;
      if (hasOwn(named, "k") && named.k) {
        return ctx.interpolate(ctx.named(named.k));
      }
      if (hasOwn(named, "key") && named.key) {
        return ctx.interpolate(ctx.named(named.key));
      }
      throw createUnhandleNodeError(type);
    }
    case 5: {
      const list = node;
      if (hasOwn(list, "i") && isNumber(list.i)) {
        return ctx.interpolate(ctx.list(list.i));
      }
      if (hasOwn(list, "index") && isNumber(list.index)) {
        return ctx.interpolate(ctx.list(list.index));
      }
      throw createUnhandleNodeError(type);
    }
    case 6: {
      const linked = node;
      const modifier = resolveLinkedModifier(linked);
      const key = resolveLinkedKey(linked);
      return ctx.linked(formatMessagePart(ctx, key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
    }
    case 7: {
      return resolveValue$1(node, type);
    }
    case 8: {
      return resolveValue$1(node, type);
    }
    default:
      throw new Error(`unhandled node on format message part: ${type}`);
  }
}
const defaultOnCacheKey = (message) => message;
let compileCache = create();
function baseCompile(message, options = {}) {
  let detectError = false;
  const onError = options.onError || defaultOnError;
  options.onError = (err) => {
    detectError = true;
    onError(err);
  };
  return { ...baseCompile$1(message, options), detectError };
}
const compileToFunction = /* @__NO_SIDE_EFFECTS__ */ (message, context) => {
  if (!isString$1(message)) {
    throw createCoreError(CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE);
  }
  {
    isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { code: code2, detectError } = baseCompile(message, context);
    const msg = new Function(`return ${code2}`)();
    return !detectError ? compileCache[cacheKey] = msg : msg;
  }
};
function compile(message, context) {
  if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && isString$1(message)) {
    isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile(message, {
      ...context,
      location: false,
      jit: true
    });
    const msg = format(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    const cacheKey = message.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format(message);
    } else {
      return format(message);
    }
  }
}
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction(val);
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;
  const [key, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage;
  const defaultMsgOrKey = isString$1(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale = getLocale$1(context, options);
  escapeParameter && escapeParams(options);
  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale,
    messages[locale] || create()
  ];
  let format2 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$1(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let occurred = false;
  const onError = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  let ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (escapeParameter && isString$1(ret)) {
    ret = sanitizeTranslatedHtml(ret);
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString$1(key) ? key : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString$1(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign$1({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options) {
  if (isArray(options.list)) {
    options.list = options.list.map((item) => isString$1(item) ? escapeHtml(item) : item);
  } else if (isObject$1(options.named)) {
    Object.keys(options.named).forEach((key) => {
      if (isString$1(options.named[key])) {
        options.named[key] = escapeHtml(options.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  let message = create();
  let targetLocale;
  let format2 = null;
  const type = "translate";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    message = messages[targetLocale] || create();
    if ((format2 = resolveValue2(message, key)) === null) {
      format2 = message[key];
    }
    if (isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
      break;
    }
    if (!isImplicitFallback(targetLocale, locales)) {
      const missingRet = handleMissing(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        key,
        targetLocale,
        missingWarn,
        type
      );
      if (missingRet !== key) {
        format2 = missingRet;
      }
    }
  }
  return [format2, targetLocale, message];
}
function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = () => format2;
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format2;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  const messaged = msg(msgCtx);
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = create();
  if (!isString$1(arg1) && !isNumber(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber(arg2)) {
    options.plural = arg2;
  } else if (isString$1(arg2)) {
    options.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (isArray(arg2)) {
    options.list = arg2;
  }
  if (isNumber(arg3)) {
    options.plural = arg3;
  } else if (isString$1(arg3)) {
    options.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign$1(options, arg3);
  }
  return [key, options];
}
function getCompileContext(context, locale, key, source, warnHtmlMessage, onError) {
  return {
    locale,
    key,
    warnHtmlMessage,
    onError: (err) => {
      onError && onError(err);
      {
        throw err;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
  };
}
function getMessageContextOptions(context, locale, message, options) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = (key) => {
    let val = resolveValue2(message, key);
    if (val == null && fallbackContext) {
      const [, , message2] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message2, key);
    }
    if (isString$1(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key, locale, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options.list) {
    ctxOptions.list = options.list;
  }
  if (options.named) {
    ctxOptions.named = options.named;
  }
  if (isNumber(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }
  return ctxOptions;
}
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  const [key, value, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale$1(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$1(key) || key === "") {
    return new Intl.DateTimeFormat(locale, overrides).format(value);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "datetime format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign$1({}, format2, overrides));
    __datetimeFormatters.set(id, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = create();
  let overrides = create();
  let value;
  if (isString$1(arg1)) {
    const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
    value = new Date(dateTime);
    try {
      value.toISOString();
    } catch (e) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value = arg1;
  } else if (isNumber(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearDateTimeFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id = `${locale}__${key}`;
    if (!context.__datetimeFormatters.has(id)) {
      continue;
    }
    context.__datetimeFormatters.delete(id);
  }
}
function number(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  const [key, value, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale$1(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$1(key) || key === "") {
    return new Intl.NumberFormat(locale, overrides).format(value);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "number format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign$1({}, format2, overrides));
    __numberFormatters.set(id, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = create();
  let overrides = create();
  if (!isNumber(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value = arg1;
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearNumberFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id = `${locale}__${key}`;
    if (!context.__numberFormatters.has(id)) {
      continue;
    }
    context.__numberFormatters.delete(id);
  }
}
{
  initFeatureFlags$1();
}

/*!
  * vue-i18n v9.14.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
const VERSION = "9.14.5";
function initFeatureFlags() {
  if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }
  if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
const code$1 = CoreWarnCodes.__EXTEND_POINT__;
const inc$1 = incrementer(code$1);
({
  // 9
  NOT_SUPPORTED_PRESERVE: inc$1(),
  // 10
  NOT_SUPPORTED_FORMATTER: inc$1(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  // 14
  NOT_FOUND_PARENT_SCOPE: inc$1(),
  // 15
  IGNORE_OBJ_FLATTEN: inc$1(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
  // 18
});
const code = CoreErrorCodes.__EXTEND_POINT__;
const inc = incrementer(code);
const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: inc(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc(),
  // 26
  NOT_INSTALLED: inc(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  // 28
  // directive module errors
  REQUIRED_VALUE: inc(),
  // 29
  INVALID_VALUE: inc(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: inc(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: inc(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
  // 37
  // for enhancement
  __EXTEND_POINT__: inc()
  // 38
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, void 0);
}
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
function handleFlatJson(obj) {
  if (!isObject$1(obj)) {
    return obj;
  }
  if (isMessageAST(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject$1(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i = 0; i < lastIndex; i++) {
        if (subKeys[i] === "__proto__") {
          throw new Error(`unsafe key: ${subKeys[i]}`);
        }
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = create();
        }
        if (!isObject$1(currentObj[subKeys[i]])) {
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i]];
      }
      if (!hasStringValue) {
        if (!isMessageAST(currentObj)) {
          currentObj[subKeys[lastIndex]] = obj[key];
          delete obj[key];
        } else {
          if (!AST_NODE_PROPS_KEYS.includes(subKeys[lastIndex])) {
            delete obj[key];
          }
        }
      }
      if (!isMessageAST(currentObj)) {
        const target = currentObj[subKeys[lastIndex]];
        if (isObject$1(target)) {
          handleFlatJson(target);
        }
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale, options) {
  const { messages, __i18n, messageResolver, flatJson } = options;
  const ret = isPlainObject(messages) ? messages : isArray(__i18n) ? create() : { [locale]: create() };
  if (isArray(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale2, resource } = custom;
        if (locale2) {
          ret[locale2] = ret[locale2] || create();
          deepCopy(resource, ret[locale2]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString$1(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
function getComponentOptions(instance) {
  return instance.type;
}
function adjustI18nResources(gl, options, componentOptions) {
  let messages = isObject$1(options.messages) ? options.messages : create();
  if ("__i18nGlobal" in componentOptions) {
    messages = getLocaleMessages(gl.locale.value, {
      messages,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages);
  if (locales.length) {
    locales.forEach((locale) => {
      gl.mergeLocaleMessage(locale, messages[locale]);
    });
  }
  {
    if (isObject$1(options.datetimeFormats)) {
      const locales2 = Object.keys(options.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    }
    if (isObject$1(options.numberFormats)) {
      const locales2 = Object.keys(options.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
const DEVTOOLS_META = "__INTLIFY_META__";
const NOOP_RETURN_ARRAY = () => [];
const NOOP_RETURN_FALSE = () => false;
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale, key, type) => {
    return missing(locale, key, getCurrentInstance() || void 0, type);
  };
}
const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options;
  const _isGlobal = __root === void 0;
  const flatJson = options.flatJson;
  const _ref = inBrowser ? ref : shallowRef;
  const translateExistCompatible = !!options.translateExistCompatible;
  let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = _ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = _ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  let _fallbackFormat = !!options.fallbackFormat;
  let _missing = isFunction(options.missing) ? options.missing : null;
  let _runtimeMissing = isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
  let _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  let _escapeParameter = !!options.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  let _pluralRules = options.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      messageCompiler: options.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn(_context);
    } finally {
      if (__INTLIFY_PROD_DEVTOOLS__) ;
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (warnType !== "translate exists" && // for not `te` (e.g `t`)
    isNumber(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root) => Reflect.apply(root.t, root, [...args]), (key) => key, (val) => isString$1(val));
  }
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$1(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t(...[arg1, arg2, assign$1({ resolvedMessage: true }, arg3 || {})]);
  }
  function d(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root) => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function n(...args) {
    return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root) => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function normalize(values) {
    return values.map((val) => isString$1(val) || isNumber(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  const interpolate = (val) => val;
  const processor = {
    normalize,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray(val)
    );
  }
  function numberParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(number, null, [context, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[NumberPartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray(val)
    );
  }
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(datetime, null, [context, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[DatetimePartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray(val)
    );
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te(key, locale2) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString$1(locale2) ? locale2 : _locale.value;
      const message = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message, key);
      return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString$1(resolved) : resolved != null;
    }, () => [key], "translate exists", (root) => {
      return Reflect.apply(root.te, root, [key, locale2]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
  }
  function resolveMessages(key) {
    let messages2 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i = 0; i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages2 = messageValue;
        break;
      }
    }
    return messages2;
  }
  function tm(key) {
    const messages2 = resolveMessages(key);
    return messages2 != null ? messages2 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message) {
    if (flatJson) {
      const _message = { [locale2]: message };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message = _message[locale2];
    }
    _messages.value[locale2] = message;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    const _message = { [locale2]: message };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message = _message[locale2];
    deepCopy(message, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function mergeDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = assign$1(_datetimeFormats.value[locale2] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  function mergeNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = assign$1(_numberFormats.value[locale2] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm;
    composer.d = d;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  return composer;
}
function convertComposerOptions(options) {
  const locale = isString$1(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const missing = isFunction(options.missing) ? options.missing : void 0;
  const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
  const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
  const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const fallbackFormat = !!options.formatFallbackMessages;
  const modifiers = isPlainObject(options.modifiers) ? options.modifiers : {};
  const pluralizationRules = options.pluralizationRules;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : void 0;
  const warnHtmlMessage = isString$1(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
  const escapeParameter = !!options.escapeParameterHtml;
  const inheritLocale = isBoolean(options.sync) ? options.sync : true;
  let messages = options.messages;
  if (isPlainObject(options.sharedMessages)) {
    const sharedMessages = options.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages = locales.reduce((messages2, locale2) => {
      const message = messages2[locale2] || (messages2[locale2] = {});
      assign$1(message, sharedMessages[locale2]);
      return messages2;
    }, messages || {});
  }
  const { __i18n, __root, __injectWithOption } = options;
  const datetimeFormats = options.datetimeFormats;
  const numberFormats = options.numberFormats;
  const flatJson = options.flatJson;
  const translateExistCompatible = options.translateExistCompatible;
  return {
    locale,
    fallbackLocale,
    messages,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options.messageResolver,
    inheritLocale,
    translateExistCompatible,
    __i18n,
    __root,
    __injectWithOption
  };
}
function createVueI18n(options = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options));
    const { __extender } = options;
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // formatter
      get formatter() {
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler) {
        composer.setMissingHandler(handler);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        return true;
      },
      set preserveDirectiveContent(val) {
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = {};
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options2.locale = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options2.locale = arg2;
        } else if (isNumber(arg2)) {
          options2.plural = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isString$1(arg3)) {
          options2.locale = arg3;
        } else if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      // te
      te(key, locale) {
        return composer.te(key, locale);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },
      // setLocaleMessage
      setLocaleMessage(locale, message) {
        composer.setLocaleMessage(locale, message);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale, message) {
        composer.mergeLocaleMessage(locale, message);
      },
      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale, format2) {
        composer.setDateTimeFormat(locale, format2);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale, format2) {
        composer.mergeDateTimeFormat(locale, format2);
      },
      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      // getNumberFormat
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },
      // setNumberFormat
      setNumberFormat(locale, format2) {
        composer.setNumberFormat(locale, format2);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale, format2) {
        composer.mergeNumberFormat(locale, format2);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
        return -1;
      }
    };
    vueI18n.__extender = __extender;
    return vueI18n;
  }
}
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys) {
  if (keys.length === 1 && keys[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, create());
  }
}
function getFragmentableTag(tag) {
  return Fragment;
}
const TranslationImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign$1({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (val) => isNumber(val) || !isNaN(val)
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const { slots, attrs } = context;
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys = Object.keys(slots).filter((key) => key !== "_");
      const options = create();
      if (props.locale) {
        options.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options.plural = isString$1(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys);
      const children = i18n[TranslateVNodeSymbol](props.keypath, arg, options);
      const assignedAttrs = assign$1(create(), attrs);
      const tag = isString$1(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
      return h(tag, assignedAttrs, children);
    };
  }
});
const Translation = TranslationImpl;
function isVNode(target) {
  return isArray(target) && !isString$1(target[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs } = context;
  return () => {
    const options = { part: true };
    let overrides = create();
    if (props.locale) {
      options.locale = props.locale;
    }
    if (isString$1(props.format)) {
      options.key = props.format;
    } else if (isObject$1(props.format)) {
      if (isString$1(props.format.key)) {
        options.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options2, prop) => {
        return slotKeys.includes(prop) ? assign$1(create(), options2, { [prop]: props.format[prop] }) : options2;
      }, create());
    }
    const parts = partFormatter(...[props.value, options, overrides]);
    let children = [options.key];
    if (isArray(parts)) {
      children = parts.map((part, index) => {
        const slot = slots[part.type];
        const node = slot ? slot({ [part.type]: part.value, index, parts }) : [part.value];
        if (isVNode(node)) {
          node[0].key = `${part.type}-${index}`;
        }
        return node;
      });
    } else if (isString$1(parts)) {
      children = [parts];
    }
    const assignedAttrs = assign$1(create(), attrs);
    const tag = isString$1(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
    return h(tag, assignedAttrs, children);
  };
}
const NumberFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign$1({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n[NumberPartsSymbol](...args)
    ));
  }
});
const NumberFormat = NumberFormatImpl;
const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign$1({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n[DatetimePartsSymbol](...args)
    ));
  }
});
const DatetimeFormat = DatetimeFormatImpl;
function getComposer$2(i18n, instance) {
  const i18nInternal = i18n;
  if (i18n.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n.global.__composer;
  }
}
function vTDirective(i18n) {
  const _process = (binding) => {
    const { instance, modifiers, value } = binding;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n, instance.$);
    const parsedValue = parseValue(value);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register = (el, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n.global === composer) {
      el.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el.__composer = composer;
    el.textContent = textContent;
  };
  const unregister = (el) => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();
      el.__i18nWatcher = void 0;
      delete el.__i18nWatcher;
    }
    if (el.__composer) {
      el.__composer = void 0;
      delete el.__composer;
    }
  };
  const update = (el, { value }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue(value);
      el.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  };
  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update,
    getSSRProps
  };
}
function parseValue(value) {
  if (isString$1(value)) {
    return { path: value };
  } else if (isPlainObject(value)) {
    if (!("path" in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value) {
  const { path, locale, args, choice, plural } = value;
  const options = {};
  const named = args || {};
  if (isString$1(locale)) {
    options.locale = locale;
  }
  if (isNumber(choice)) {
    options.plural = choice;
  }
  if (isNumber(plural)) {
    options.plural = plural;
  }
  return [path, named, options];
}
function apply(app, i18n, ...options) {
  const pluginOptions = isPlainObject(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app.component(name, Translation));
    [NumberFormat.name, "I18nN"].forEach((name) => app.component(name, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name) => app.component(name, DatetimeFormat));
  }
  {
    app.directive("t", vTDirective(i18n));
  }
}
function defineMixin(vuei18n, composer, i18n) {
  return {
    beforeCreate() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const options = this.$options;
      if (options.i18n) {
        const optionsI18n = options.i18n;
        if (options.__i18n) {
          optionsI18n.__i18n = options.__i18n;
        }
        optionsI18n.__root = composer;
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          optionsI18n.__extender = i18n.__vueI18nExtend;
          this.$i18n = createVueI18n(optionsI18n);
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else if (options.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, options);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options.__i18n,
            __injectWithOption: true,
            __extender: i18n.__vueI18nExtend,
            __root: composer
          });
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else {
        this.$i18n = vuei18n;
      }
      if (options.__i18nGlobal) {
        adjustI18nResources(composer, options, options);
      }
      this.$t = (...args) => this.$i18n.t(...args);
      this.$rt = (...args) => this.$i18n.rt(...args);
      this.$tc = (...args) => this.$i18n.tc(...args);
      this.$te = (key, locale) => this.$i18n.te(key, locale);
      this.$d = (...args) => this.$i18n.d(...args);
      this.$n = (...args) => this.$i18n.n(...args);
      this.$tm = (key) => this.$i18n.tm(key);
      i18n.__setInstance(instance, this.$i18n);
    },
    mounted() {
    },
    unmounted() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const _vueI18n = this.$i18n;
      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;
      if (_vueI18n.__disposer) {
        _vueI18n.__disposer();
        delete _vueI18n.__disposer;
        delete _vueI18n.__extender;
      }
      i18n.__deleteInstance(instance);
      delete this.$i18n;
    }
  };
}
function mergeToGlobal(g, options) {
  g.locale = options.locale || g.locale;
  g.fallbackLocale = options.fallbackLocale || g.fallbackLocale;
  g.missing = options.missing || g.missing;
  g.silentTranslationWarn = options.silentTranslationWarn || g.silentFallbackWarn;
  g.silentFallbackWarn = options.silentFallbackWarn || g.silentFallbackWarn;
  g.formatFallbackMessages = options.formatFallbackMessages || g.formatFallbackMessages;
  g.postTranslation = options.postTranslation || g.postTranslation;
  g.warnHtmlInMessage = options.warnHtmlInMessage || g.warnHtmlInMessage;
  g.escapeParameterHtml = options.escapeParameterHtml || g.escapeParameterHtml;
  g.sync = options.sync || g.sync;
  g.__composer[SetPluralRulesSymbol](options.pluralizationRules || g.pluralizationRules);
  const messages = getLocaleMessages(g.locale, {
    messages: options.messages,
    __i18n: options.__i18n
  });
  Object.keys(messages).forEach((locale) => g.mergeLocaleMessage(locale, messages[locale]));
  if (options.datetimeFormats) {
    Object.keys(options.datetimeFormats).forEach((locale) => g.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
  }
  if (options.numberFormats) {
    Object.keys(options.numberFormats).forEach((locale) => g.mergeNumberFormat(locale, options.numberFormats[locale]));
  }
  return g;
}
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options = {}, VueI18nLegacy) {
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
  const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options, __legacyMode);
  const symbol = /* @__PURE__ */ makeSymbol("");
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  {
    const i18n = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      async install(app, ...options2) {
        app.__VUE_I18N_SYMBOL__ = symbol;
        app.provide(app.__VUE_I18N_SYMBOL__, i18n);
        if (isPlainObject(options2[0])) {
          const opts = options2[0];
          i18n.__composerExtend = opts.__composerExtend;
          i18n.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (!__legacyMode && __globalInjection) {
          globalReleaseHandler = injectGlobalFields(app, i18n.global);
        }
        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app, i18n, ...options2);
        }
        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app.mixin(defineMixin(__global, __global.__composer, i18n));
        }
        const unmountApp = app.unmount;
        app.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n.dispose();
          unmountApp();
        };
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n;
  }
}
function useI18n(options = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n = getI18nInstance(instance);
  const gl = getGlobalComposer(i18n);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options, componentOptions);
  if (__VUE_I18N_LEGACY_API__) {
    if (i18n.mode === "legacy" && !options.__useComponent) {
      if (!i18n.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }
      return useI18nForLegacy(instance, scope, gl, options);
    }
  }
  if (scope === "global") {
    adjustI18nResources(gl, options, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n, instance, options.__useComponent);
    if (composer2 == null) {
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign$1({}, options);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance, composer);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
function createGlobal(options, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
function getI18nInstance(instance) {
  {
    const i18n = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n;
  }
}
function getScope(options, componentOptions) {
  return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
}
function getGlobalComposer(i18n) {
  return i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
}
function getComposer(i18n, target, useComponent = false) {
  let composer = null;
  const root = target.root;
  let current = getParentComponentInstance(target, useComponent);
  while (current != null) {
    const i18nInternal = i18n;
    if (i18n.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
          if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
            composer = null;
          }
        }
      }
    }
    if (composer != null) {
      break;
    }
    if (root === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function getParentComponentInstance(target, useComponent = false) {
  if (target == null) {
    return null;
  }
  {
    return !useComponent ? target.parent : target.vnode.ctx || target.parent;
  }
}
function setupLifeCycle(i18n, target, composer) {
  {
    onMounted(() => {
    }, target);
    onUnmounted(() => {
      const _composer = composer;
      i18n.__deleteInstance(target);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target);
  }
}
function useI18nForLegacy(instance, scope, root, options = {}) {
  const isLocalScope = scope === "local";
  const _composer = shallowRef(null);
  if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }
  const _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : !isString$1(options.locale);
  const _locale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  const _missingWarn = isLocalScope ? root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const _fallbackWarn = isLocalScope ? root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const _fallbackRoot = isLocalScope ? root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const _fallbackFormat = !!options.fallbackFormat;
  const _missing = isFunction(options.missing) ? options.missing : null;
  const _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const _warnHtmlMessage = isLocalScope ? root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const _escapeParameter = !!options.escapeParameter;
  const _modifiers = isLocalScope ? root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  const _pluralRules = options.pluralRules || isLocalScope && root.pluralRules;
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }
      _locale.value = val;
    }
  });
  const fallbackLocale = computed({
    get: () => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }
      _fallbackLocale.value = val;
    }
  });
  const messages = computed(() => {
    if (_composer.value) {
      return _composer.value.messages.value;
    } else {
      return _messages.value;
    }
  });
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }
  function setPostTranslationHandler(handler) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler);
    }
  }
  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }
  function setMissingHandler(handler) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler);
    }
  }
  function warpWithDeps(fn) {
    trackReactivityValues();
    return fn();
  }
  function t(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
  }
  function rt(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
  }
  function d(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
  }
  function n(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
  }
  function tm(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }
  function te(key, locale2) {
    return _composer.value ? _composer.value.te(key, locale2) : false;
  }
  function getLocaleMessage(locale2) {
    return _composer.value ? _composer.value.getLocaleMessage(locale2) : {};
  }
  function setLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale2, message);
      _messages.value[locale2] = message;
    }
  }
  function mergeLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale2, message);
    }
  }
  function getDateTimeFormat(locale2) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale2) : {};
  }
  function setDateTimeFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale2, format2);
      _datetimeFormats.value[locale2] = format2;
    }
  }
  function mergeDateTimeFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale2, format2);
    }
  }
  function getNumberFormat(locale2) {
    return _composer.value ? _composer.value.getNumberFormat(locale2) : {};
  }
  function setNumberFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale2, format2);
      _numberFormats.value[locale2] = format2;
    }
  }
  function mergeNumberFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale2, format2);
    }
  }
  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },
    locale,
    fallbackLocale,
    messages,
    datetimeFormats,
    numberFormats,
    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },
    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },
    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },
    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },
    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },
    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },
    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },
    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },
    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },
    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },
    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },
    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },
    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },
    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },
    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },
    t,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt,
    d,
    n,
    tm,
    te,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };
  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach((locale2) => {
      composer.mergeLocaleMessage(locale2, _messages.value[locale2]);
    });
    Object.keys(_datetimeFormats.value).forEach((locale2) => {
      composer.mergeDateTimeFormat(locale2, _datetimeFormats.value[locale2]);
    });
    Object.keys(_numberFormats.value).forEach((locale2) => {
      composer.mergeNumberFormat(locale2, _numberFormats.value[locale2]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }
  onBeforeMount(() => {
    if (instance.proxy == null || instance.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    }
    const composer = _composer.value = instance.proxy.$i18n.__composer;
    if (scope === "global") {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocalScope) {
      sync(composer);
    }
  });
  return wrapper;
}
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app, composer) {
  const i18n = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n, prop, wrap);
  });
  app.config.globalProperties.$i18n = i18n;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app.config.globalProperties, `$${method}`, desc);
  });
  const dispose = () => {
    delete app.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app.config.globalProperties[`$${method}`];
    });
  };
  return dispose;
}
{
  initFeatureFlags();
}
if (__INTLIFY_JIT_COMPILATION__) {
  registerMessageCompiler(compile);
} else {
  registerMessageCompiler(compileToFunction);
}
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}

function loadComponentSafely(importFn) {
  return async () => {
    try {
      const module = await importFn();
      return module.default || module;
    } catch (error) {
      console.error("Component loading failed:", error);
      return {
        template: '<div class="error-component">Component failed to load</div>'
      };
    }
  };
}

const vocabularies = ref([]);
let nextId = 1;
let isInitialized = false;
const isStoreReady = ref(false);
const customTopics = ref([]);
const loadCustomTopics = () => {
  try {
    const saved = localStorage.getItem("customTopics");
    if (saved) {
      const parsedTopics = JSON.parse(saved);
      if (Array.isArray(parsedTopics)) {
        customTopics.value = parsedTopics;
      }
    }
  } catch (error) {
    console.error("Error loading custom topics:", error);
    customTopics.value = [];
  }
};
const loadFromLocalStorage = () => {
  try {
    const saved = localStorage.getItem("vocabularies");
    const savedNextId = localStorage.getItem("nextVocabId");
    if (saved) {
      const parsedVocabs = JSON.parse(saved);
      if (Array.isArray(parsedVocabs)) {
        vocabularies.value = parsedVocabs;
      }
    }
    if (savedNextId) {
      nextId = parseInt(savedNextId, 10) || 1;
    }
    loadCustomTopics();
    isInitialized = true;
    isStoreReady.value = true;
  } catch (error) {
    console.error("Error loading vocabularies from localStorage:", error);
    isInitialized = true;
    isStoreReady.value = true;
  }
};
const saveToLocalStorage = () => {
  try {
    localStorage.setItem("vocabularies", JSON.stringify(vocabularies.value));
    localStorage.setItem("nextVocabId", nextId.toString());
    localStorage.setItem("customTopics", JSON.stringify(customTopics.value));
  } catch (error) {
    console.error("Error saving data to localStorage:", error);
  }
};
function normalizeCategoryKeys() {
  const categoryKeys = [
    "technology",
    "business",
    "travel",
    "food",
    "health",
    "education",
    "sports",
    "entertainment",
    "science",
    "art",
    "music",
    "literature",
    "politics",
    "environment",
    "fashion",
    "finance"
  ];
  const translationMap = {
    technology: ["Technology", "Cng ngh"],
    business: ["Business", "Kinh doanh"],
    travel: ["Travel", "Du lch"],
    food: ["Food", "m thc"],
    health: ["Health", "Sc khe"],
    education: ["Education", "Gio dc"],
    sports: ["Sports", "Th thao"],
    entertainment: ["Entertainment", "Gii tr"],
    science: ["Science", "Khoa hc"],
    art: ["Art", "Ngh thut"],
    music: ["Music", "m nhc"],
    literature: ["Literature", "Vn hc"],
    politics: ["Politics", "Chnh tr"],
    environment: ["Environment", "Mi trng"],
    fashion: ["Fashion", "Thi trang"],
    finance: ["Finance", "Ti chnh"]
  };
  vocabularies.value.forEach((vocab) => {
    for (const key of categoryKeys) {
      if (vocab.category === key || translationMap[key].includes(vocab.category)) {
        vocab.category = key;
        break;
      }
    }
  });
  saveToLocalStorage();
}
if (typeof window !== "undefined") {
  loadFromLocalStorage();
  normalizeCategoryKeys();
}
function useVocabularyStore() {
  const allVocabularies = computed(() => vocabularies.value);
  const totalCount = computed(() => vocabularies.value.length);
  const getVocabularyById = (id) => {
    return vocabularies.value.find((vocab) => vocab.id === Number(id));
  };
  const addVocabulary = (vocabularyData) => {
    const newVocabulary = {
      ...vocabularyData,
      id: nextId++,
      createdAt: vocabularyData.createdAt || (/* @__PURE__ */ new Date()).toISOString()
    };
    vocabularies.value.unshift(newVocabulary);
    saveToLocalStorage();
    return newVocabulary;
  };
  const updateVocabulary = (id, updates) => {
    const index = vocabularies.value.findIndex((vocab) => vocab.id === id);
    if (index !== -1) {
      const existingVocab = vocabularies.value[index];
      vocabularies.value[index] = {
        ...existingVocab,
        ...updates,
        synonyms: updates.synonyms !== void 0 ? updates.synonyms : existingVocab.synonyms,
        antonyms: updates.antonyms !== void 0 ? updates.antonyms : existingVocab.antonyms,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      saveToLocalStorage();
      return true;
    }
    return false;
  };
  const deleteVocabulary = (id) => {
    const index = vocabularies.value.findIndex((vocab) => vocab.id === id);
    if (index !== -1) {
      vocabularies.value.splice(index, 1);
      saveToLocalStorage();
      return true;
    }
    return false;
  };
  const importVocabularies = (newVocabularies) => {
    try {
      let importedCount = 0;
      let updatedCount = 0;
      newVocabularies.forEach((importedVocab) => {
        const existingIndex = vocabularies.value.findIndex(
          (vocab) => vocab.word.toLowerCase() === importedVocab.word.toLowerCase()
        );
        if (existingIndex !== -1) {
          const existingVocab = vocabularies.value[existingIndex];
          vocabularies.value[existingIndex] = {
            ...existingVocab,
            // Keep original id and createdAt
            ...importedVocab,
            // Override with imported data
            id: existingVocab.id,
            // Preserve original ID
            createdAt: existingVocab.createdAt,
            // Preserve original creation date
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
            // Update modification time
          };
          updatedCount++;
        } else {
          const newVocab = {
            ...importedVocab,
            id: nextId++,
            createdAt: importedVocab.createdAt || (/* @__PURE__ */ new Date()).toISOString(),
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          vocabularies.value.unshift(newVocab);
          importedCount++;
        }
      });
      saveToLocalStorage();
      console.log(`Import completed: ${importedCount} new vocabularies added, ${updatedCount} existing vocabularies updated`);
      return true;
    } catch (error) {
      console.error("Error importing vocabularies:", error);
      return false;
    }
  };
  const filterVocabularies = (filters) => {
    return computed(() => {
      return vocabularies.value.filter((vocab) => {
        const matchesSearch = !filters.search || vocab.word.toLowerCase().includes(filters.search.toLowerCase()) || vocab.meaning.toLowerCase().includes(filters.search.toLowerCase());
        const matchesCategory = !filters.category || vocab.category === filters.category;
        const matchesLevel = !filters.level || vocab.level === filters.level;
        return matchesSearch && matchesCategory && matchesLevel;
      });
    });
  };
  const getCategories = computed(() => {
    const standardCategories = [
      "technology",
      "business",
      "travel",
      "food",
      "health",
      "education",
      "sports",
      "entertainment",
      "science",
      "art",
      "music",
      "literature",
      "politics",
      "environment",
      "fashion",
      "finance"
    ];
    const customTopicKeys = customTopics.value.map((topic) => topic.key);
    const usedCategories = new Set(vocabularies.value.map((vocab) => vocab.category));
    const additionalCategories = Array.from(usedCategories).filter(
      (cat) => !standardCategories.includes(cat) && !customTopicKeys.includes(cat)
    );
    return [...standardCategories, ...customTopicKeys, ...additionalCategories].sort();
  });
  const getCategoryUsage = computed(() => {
    const usage = {};
    vocabularies.value.forEach((vocab) => {
      usage[vocab.category] = (usage[vocab.category] || 0) + 1;
    });
    return usage;
  });
  const getLevels = computed(() => {
    const levels = new Set(vocabularies.value.map((vocab) => vocab.level));
    return Array.from(levels).sort();
  });
  const toggleFavorite = (id) => {
    const index = vocabularies.value.findIndex((vocab) => vocab.id === id);
    if (index !== -1) {
      vocabularies.value[index] = {
        ...vocabularies.value[index],
        favorite: !vocabularies.value[index].favorite,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      saveToLocalStorage();
      return true;
    }
    return false;
  };
  const favoriteVocabularies = computed(() => {
    return vocabularies.value.filter((vocab) => vocab.favorite);
  });
  const clearAllVocabularies = () => {
    try {
      vocabularies.value = [];
      nextId = 1;
      saveToLocalStorage();
      console.log("All vocabularies cleared successfully");
      return true;
    } catch (error) {
      console.error("Error clearing all vocabularies:", error);
      return false;
    }
  };
  const initializeStore = () => {
    if (!isInitialized) {
      loadFromLocalStorage();
    }
    return isStoreReady;
  };
  const refreshCustomTopics = () => {
    loadCustomTopics();
  };
  const addCustomTopic = (topic) => {
    const existingTopic = customTopics.value.find((t) => t.key === topic.key);
    if (!existingTopic) {
      customTopics.value.push(topic);
      saveToLocalStorage();
    }
  };
  const updateCustomTopic = (oldKey, topic) => {
    const index = customTopics.value.findIndex((t) => t.key === oldKey);
    if (index !== -1) {
      customTopics.value[index] = topic;
      saveToLocalStorage();
    }
  };
  const deleteCustomTopic = (key) => {
    const index = customTopics.value.findIndex((t) => t.key === key);
    if (index !== -1) {
      customTopics.value.splice(index, 1);
      saveToLocalStorage();
    }
  };
  return {
    // State
    allVocabularies,
    totalCount,
    favoriteVocabularies,
    isStoreReady,
    // Getters
    getVocabularyById,
    getCategories,
    getLevels,
    getCategoryUsage,
    // Actions
    addVocabulary,
    updateVocabulary,
    deleteVocabulary,
    clearAllVocabularies,
    importVocabularies,
    toggleFavorite,
    filterVocabularies,
    initializeStore,
    // Utils
    saveToLocalStorage,
    // Custom topics management
    customTopics,
    refreshCustomTopics,
    addCustomTopic,
    updateCustomTopic,
    deleteCustomTopic
  };
}

const formatDate = (dateString, locale = "vi-VN") => {
  if (!dateString) return "";
  try {
    const date = new Date(dateString);
    return date.toLocaleDateString(locale, {
      year: "numeric",
      month: "long",
      day: "numeric"
    });
  } catch (error) {
    return "";
  }
};
const getRelativeTime = (dateString, t) => {
  if (!dateString) return "";
  try {
    const date = new Date(dateString);
    const now = /* @__PURE__ */ new Date();
    const diffInMs = now.getTime() - date.getTime();
    const diffInHours = Math.floor(diffInMs / (1e3 * 60 * 60));
    const diffInDays = Math.floor(diffInHours / 24);
    if (diffInHours < 1) {
      const diffInMinutes = Math.floor(diffInMs / (1e3 * 60));
      if (diffInMinutes < 1) {
        return t ? t("time.ago.justNow") : "Just now";
      }
      return t ? t("time.ago.minutesAgo", { minutes: diffInMinutes }) : `${diffInMinutes} minutes ago`;
    } else if (diffInHours < 24) {
      return t ? t("time.ago.hoursAgo", { hours: diffInHours }) : `${diffInHours} hours ago`;
    } else if (diffInDays === 1) {
      return t ? t("time.ago.yesterday") : "Yesterday";
    } else if (diffInDays < 7) {
      return t ? t("time.ago.daysAgo", { days: diffInDays }) : `${diffInDays} days ago`;
    } else {
      return formatDate(dateString);
    }
  } catch (error) {
    return "";
  }
};
const getDateKey = (dateString) => {
  if (!dateString) return "";
  try {
    const date = new Date(dateString);
    return date.toISOString().split("T")[0];
  } catch (error) {
    return "";
  }
};
const groupVocabulariesByTopic = (vocabularies) => {
  const grouped = /* @__PURE__ */ new Map();
  const uncategorizedKey = "Uncategorized";
  vocabularies.forEach((vocab) => {
    const topic = vocab.category || uncategorizedKey;
    if (!grouped.has(topic)) {
      grouped.set(topic, []);
    }
    grouped.get(topic).push(vocab);
  });
  const result = Array.from(grouped.entries()).map(([topic, vocabs]) => {
    const firstVocab = vocabs[0];
    const categoryName = firstVocab?.categoryName || null;
    return {
      topic,
      categoryName,
      // Preserve category name from imported data
      vocabularies: vocabs.sort((a, b) => {
        const timeA = new Date(a.createdAt || "").getTime();
        const timeB = new Date(b.createdAt || "").getTime();
        return timeB - timeA;
      })
    };
  });
  return result.sort((a, b) => {
    if (a.topic === uncategorizedKey) return 1;
    if (b.topic === uncategorizedKey) return -1;
    return a.topic.localeCompare(b.topic);
  });
};
const groupVocabulariesByDateAndTopic = (vocabularies, locale = "vi-VN", t) => {
  const groupedByDate = groupVocabulariesByDate(vocabularies, locale, t);
  return groupedByDate.map((dateGroup) => {
    return {
      ...dateGroup,
      topics: groupVocabulariesByTopic(dateGroup.vocabularies)
    };
  });
};
const groupVocabulariesByDate = (vocabularies, locale = "vi-VN", t) => {
  const grouped = /* @__PURE__ */ new Map();
  vocabularies.forEach((vocab) => {
    const dateKey = getDateKey(vocab.createdAt);
    if (!dateKey) return;
    if (!grouped.has(dateKey)) {
      grouped.set(dateKey, []);
    }
    grouped.get(dateKey).push(vocab);
  });
  const result = Array.from(grouped.entries()).map(([dateKey, vocabs]) => ({
    date: dateKey,
    displayDate: getGroupDisplayDate(dateKey, locale, t),
    vocabularies: vocabs.sort((a, b) => {
      const timeA = new Date(a.createdAt || "").getTime();
      const timeB = new Date(b.createdAt || "").getTime();
      return timeB - timeA;
    })
  })).sort((a, b) => {
    return b.date.localeCompare(a.date);
  });
  return result;
};
const getGroupDisplayDate = (dateKey, locale = "vi-VN", t) => {
  try {
    const date = /* @__PURE__ */ new Date(dateKey + "T00:00:00");
    const today = /* @__PURE__ */ new Date();
    const yesterday = new Date(today);
    yesterday.setDate(today.getDate() - 1);
    const todayKey = getDateKey(today.toISOString());
    const yesterdayKey = getDateKey(yesterday.toISOString());
    if (dateKey === todayKey) {
      if (t) return t("time.today") || "Today";
      const l = locale.toLowerCase();
      if (l.startsWith("vi")) return "Hm nay";
      if (l.startsWith("ko")) return "";
      return "Today";
    } else if (dateKey === yesterdayKey) {
      if (t) return t("time.yesterday") || "Yesterday";
      const l = locale.toLowerCase();
      if (l.startsWith("vi")) return "Hm qua";
      if (l.startsWith("ko")) return "";
      return "Yesterday";
    } else {
      return formatDate(date.toISOString(), locale);
    }
  } catch (error) {
    return dateKey;
  }
};

const _hoisted_1$1r = { class: "min-h-screen overflow-x-hidden bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative" };
const _hoisted_2$1o = { class: "max-w-7xl mx-auto py-3 sm:py-5 px-3 sm:px-6 lg:px-8 relative" };
const _hoisted_3$1l = { class: "mb-6 sm:mb-8" };
const _hoisted_4$1g = { class: "grid grid-cols-1 md:grid-cols-2 gap-4 sm:gap-6 mb-6 sm:mb-8" };
const _hoisted_5$1d = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-105 hover:-translate-y-2 h-full min-h-[360px] sm:min-h-[420px] flex flex-col" };
const _hoisted_6$1a = { class: "px-4 py-5 sm:p-8 flex-1 flex flex-col" };
const _hoisted_7$16 = { class: "flex items-center mb-6" };
const _hoisted_8$14 = { class: "text-lg sm:text-xl md:text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent" };
const _hoisted_9$13 = { class: "grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4 flex-1" };
const _hoisted_10$12 = { class: "relative z-10 text-center" };
const _hoisted_11$12 = { class: "text-xs sm:text-sm md:text-base font-medium" };
const _hoisted_12$$ = { class: "relative z-10 text-center" };
const _hoisted_13$$ = { class: "text-xs sm:text-sm md:text-base font-medium" };
const _hoisted_14$_ = { class: "relative z-10 text-center" };
const _hoisted_15$U = { class: "text-xs sm:text-sm md:text-base font-medium" };
const _hoisted_16$T = { class: "relative z-10 text-center" };
const _hoisted_17$S = { class: "text-xs sm:text-sm md:text-base font-medium" };
const _hoisted_18$Q = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-105 hover:-translate-y-2 h-full min-h-[420px] flex flex-col" };
const _hoisted_19$Q = { class: "px-6 py-8 sm:p-8 flex-1 flex flex-col" };
const _hoisted_20$P = { class: "flex items-center mb-6" };
const _hoisted_21$P = { class: "text-lg sm:text-xl md:text-2xl font-bold bg-gradient-to-r from-green-600 to-blue-600 dark:from-green-400 dark:to-blue-400 bg-clip-text text-transparent" };
const _hoisted_22$N = { class: "space-y-4 flex-1" };
const _hoisted_23$N = { class: "flex-shrink-0" };
const _hoisted_24$L = { class: "flex-1 min-w-0" };
const _hoisted_25$L = { class: "text-xs sm:text-sm md:text-base font-semibold text-gray-900 dark:text-white truncate" };
const _hoisted_26$I = { class: "text-xs sm:text-sm text-blue-600 dark:text-blue-400 font-medium" };
const _sfc_main$1s = /* @__PURE__ */ defineComponent({
  __name: "DashboardView",
  setup(__props) {
    const LazyLoadComponent = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => LazyLoadComponent$1),true              ?void 0:void 0))
    );
    const DashboardHeader$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => DashboardHeader),true              ?void 0:void 0))
    );
    const DashboardStats$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => DashboardStats),true              ?void 0:void 0))
    );
    const FlashcardStats = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => FlashcardStats$1),true              ?void 0:void 0))
    );
    const router = useRouter();
    const { t } = useI18n();
    const vocabularyStore = useVocabularyStore();
    const stats = computed(() => {
      const allVocabs = vocabularyStore.allVocabularies.value;
      const favoriteCount = vocabularyStore.favoriteVocabularies.value.length;
      const categories = vocabularyStore.getCategories.value.length;
      const today = /* @__PURE__ */ new Date();
      const todayStr = today.toISOString().split("T")[0];
      const todayVocabs = allVocabs.filter(
        (v) => v.createdAt && v.createdAt.split("T")[0] === todayStr
      ).length;
      return {
        vocabularyLearned: allVocabs.length,
        grammarLessons: categories,
        // Use categories count as grammar lessons
        currentStreak: Math.max(1, todayVocabs),
        // At least 1 if there are vocabularies
        totalTime: favoriteCount * 5
        // Estimate 5 minutes per favorite vocabulary
      };
    });
    const recentActivities = computed(() => {
      const allVocabs = vocabularyStore.allVocabularies.value;
      const activities = [];
      const recentVocabs = [...allVocabs].sort((a, b) => {
        const aTime = a.updatedAt || a.createdAt || "";
        const bTime = b.updatedAt || b.createdAt || "";
        return new Date(bTime).getTime() - new Date(aTime).getTime();
      }).slice(0, 4);
      recentVocabs.forEach((vocab, index) => {
        const isUpdated = vocab.updatedAt && vocab.updatedAt !== vocab.createdAt;
        const timeStr = vocab.updatedAt || vocab.createdAt || "";
        const categoryTranslated = t(`categories.${vocab.category}`, vocab.category);
        activities.push({
          id: index + 1,
          title: isUpdated ? t("dashboard.activity.updated", { word: vocab.word, category: categoryTranslated }, `Updated '${vocab.word}' in ${categoryTranslated}`) : t("dashboard.activity.added", { word: vocab.word, category: categoryTranslated }, `Added '${vocab.word}' to ${categoryTranslated}`),
          time: timeStr ? getRelativeTime(timeStr, t) : t("dashboard.activity.justNow", "Just now"),
          iconColor: isUpdated ? "bg-blue-500" : "bg-green-500"
        });
      });
      if (activities.length === 0) {
        activities.push({
          id: 1,
          title: t("dashboard.activity.noActivity", "No recent activity"),
          time: t("dashboard.activity.addFirstVocab", "Add your first vocabulary to get started!"),
          iconColor: "bg-gray-500"
        });
      }
      return activities;
    });
    const navigateTo = (path) => {
      router.push(path);
    };
    onMounted(() => {
      vocabularyStore.initializeStore();
      console.log("Dashboard mounted with real data");
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1r, [
        _cache[20] || (_cache[20] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0"><div class="floating-shapes"><div class="absolute top-20 left-10 w-40 h-40 sm:w-64 sm:h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob"></div><div class="absolute top-40 right-10 w-48 h-48 sm:w-72 sm:h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000"></div><div class="absolute -bottom-8 left-20 w-56 h-56 sm:w-80 sm:h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000"></div></div></div>', 1)),
        createVNode(unref(LazyLoadComponent), { "animation-type": "fade-up" }, {
          default: withCtx(() => [
            createVNode(unref(DashboardHeader$1))
          ]),
          _: 1
        }),
        createBaseVNode("div", _hoisted_2$1o, [
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "slide-up",
            threshold: 0.2
          }, {
            default: withCtx(() => [
              createVNode(unref(DashboardStats$1), {
                stats: stats.value,
                class: "mb-8"
              }, null, 8, ["stats"])
            ]),
            _: 1
          }),
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "slide-up",
            threshold: 0.15
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_3$1l, [
                createVNode(unref(FlashcardStats))
              ])
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_4$1g, [
            createVNode(unref(LazyLoadComponent), {
              "animation-type": "slide-left",
              threshold: 0.15
            }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_5$1d, [
                  createBaseVNode("div", _hoisted_6$1a, [
                    createBaseVNode("div", _hoisted_7$16, [
                      _cache[4] || (_cache[4] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                        createBaseVNode("div", { class: "w-3 h-3 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full mr-3" })
                      ], -1)),
                      createBaseVNode("h3", _hoisted_8$14, toDisplayString$1(unref(t)("dashboard.quickActions", "Quick Actions")), 1)
                    ]),
                    createBaseVNode("div", _hoisted_9$13, [
                      createBaseVNode("button", {
                        onClick: _cache[0] || (_cache[0] = ($event) => navigateTo("/vocabulary")),
                        class: "group/btn relative overflow-hidden bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-semibold py-3 px-3 sm:py-4 sm:px-4 rounded-xl transition-all duration-300 transform hover:scale-105 hover:shadow-lg active:scale-95"
                      }, [
                        _cache[6] || (_cache[6] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-r from-blue-400 to-blue-500 opacity-0 group-hover/btn:opacity-100 transition-opacity duration-300" }, null, -1)),
                        createBaseVNode("div", _hoisted_10$12, [
                          _cache[5] || (_cache[5] = createBaseVNode("svg", {
                            class: "w-6 h-6 sm:w-7 sm:h-7 md:w-8 md:h-8 mx-auto mb-2 transform group-hover/btn:rotate-180 transition-transform duration-500",
                            fill: "currentColor",
                            viewBox: "0 0 20 20"
                          }, [
                            createBaseVNode("path", {
                              "fill-rule": "evenodd",
                              d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                              "clip-rule": "evenodd"
                            })
                          ], -1)),
                          createBaseVNode("span", _hoisted_11$12, toDisplayString$1(unref(t)("dashboard.actions.addVocabulary", "Add Vocabulary")), 1)
                        ]),
                        _cache[7] || (_cache[7] = createBaseVNode("div", { class: "absolute inset-0 bg-white opacity-0 group-hover/btn:opacity-20 transition-opacity duration-300" }, null, -1))
                      ]),
                      createBaseVNode("button", {
                        onClick: _cache[1] || (_cache[1] = ($event) => navigateTo("/practice/flashcard")),
                        class: "group/btn relative overflow-hidden bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-semibold py-3 px-3 sm:py-4 sm:px-4 rounded-xl transition-all duration-300 transform hover:scale-105 hover:shadow-lg active:scale-95"
                      }, [
                        _cache[9] || (_cache[9] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-r from-green-400 to-green-500 opacity-0 group-hover/btn:opacity-100 transition-opacity duration-300" }, null, -1)),
                        createBaseVNode("div", _hoisted_12$$, [
                          _cache[8] || (_cache[8] = createBaseVNode("svg", {
                            class: "w-6 h-6 sm:w-7 sm:h-7 md:w-8 md:h-8 mx-auto mb-2 transform group-hover/btn:scale-110 transition-transform duration-300",
                            fill: "currentColor",
                            viewBox: "0 0 20 20"
                          }, [
                            createBaseVNode("path", { d: "M7 3a1 1 0 000 2h6a1 1 0 100-2H7zM4 7a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zM2 11a2 2 0 012-2h12a2 2 0 012 2v4a2 2 0 01-2 2H4a2 2 0 01-2-2v-4z" })
                          ], -1)),
                          createBaseVNode("span", _hoisted_13$$, toDisplayString$1(unref(t)("dashboard.actions.practiceFlashcard", "Practice Flashcard")), 1)
                        ]),
                        _cache[10] || (_cache[10] = createBaseVNode("div", { class: "absolute inset-0 bg-white opacity-0 group-hover/btn:opacity-20 transition-opacity duration-300" }, null, -1))
                      ]),
                      createBaseVNode("button", {
                        onClick: _cache[2] || (_cache[2] = ($event) => navigateTo("/practice/quiz")),
                        class: "group/btn relative overflow-hidden bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 text-white font-semibold py-3 px-3 sm:py-4 sm:px-4 rounded-xl transition-all duration-300 transform hover:scale-105 hover:shadow-lg active:scale-95"
                      }, [
                        _cache[12] || (_cache[12] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-r from-yellow-400 to-yellow-500 opacity-0 group-hover/btn:opacity-100 transition-opacity duration-300" }, null, -1)),
                        createBaseVNode("div", _hoisted_14$_, [
                          _cache[11] || (_cache[11] = createBaseVNode("svg", {
                            class: "w-6 h-6 sm:w-7 sm:h-7 md:w-8 md:h-8 mx-auto mb-2 transform group-hover/btn:bounce",
                            fill: "currentColor",
                            viewBox: "0 0 20 20"
                          }, [
                            createBaseVNode("path", {
                              "fill-rule": "evenodd",
                              d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z",
                              "clip-rule": "evenodd"
                            })
                          ], -1)),
                          createBaseVNode("span", _hoisted_15$U, toDisplayString$1(unref(t)("dashboard.actions.takeQuiz", "Take a Quiz")), 1)
                        ]),
                        _cache[13] || (_cache[13] = createBaseVNode("div", { class: "absolute inset-0 bg-white opacity-0 group-hover/btn:opacity-20 transition-opacity duration-300" }, null, -1))
                      ]),
                      createBaseVNode("button", {
                        onClick: _cache[3] || (_cache[3] = ($event) => navigateTo("/grammar")),
                        class: "group/btn relative overflow-hidden bg-gradient-to-r from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700 text-white font-semibold py-3 px-3 sm:py-4 sm:px-4 rounded-xl transition-all duration-300 transform hover:scale-105 hover:shadow-lg active:scale-95"
                      }, [
                        _cache[15] || (_cache[15] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-r from-purple-400 to-purple-500 opacity-0 group-hover/btn:opacity-100 transition-opacity duration-300" }, null, -1)),
                        createBaseVNode("div", _hoisted_16$T, [
                          _cache[14] || (_cache[14] = createBaseVNode("svg", {
                            class: "w-6 h-6 sm:w-7 sm:h-7 md:w-8 md:h-8 mx-auto mb-2 transform group-hover/btn:rotate-12 transition-transform duration-300",
                            fill: "currentColor",
                            viewBox: "0 0 20 20"
                          }, [
                            createBaseVNode("path", { d: "M9 4.804A7.968 7.968 0 005.5 4c-1.255 0-2.443.29-3.5.804v10A7.969 7.969 0 015.5 14c1.669 0 3.218.51 4.5 1.385A7.962 7.962 0 0114.5 14c1.255 0 2.443.29 3.5.804v-10A7.968 7.968 0 0014.5 4c-1.255 0-2.443.29-3.5.804V12a1 1 0 11-2 0V4.804z" })
                          ], -1)),
                          createBaseVNode("span", _hoisted_17$S, toDisplayString$1(unref(t)("dashboard.actions.learnGrammar", "Learn Grammar")), 1)
                        ]),
                        _cache[16] || (_cache[16] = createBaseVNode("div", { class: "absolute inset-0 bg-white opacity-0 group-hover/btn:opacity-20 transition-opacity duration-300" }, null, -1))
                      ])
                    ])
                  ])
                ])
              ]),
              _: 1
            }),
            createVNode(unref(LazyLoadComponent), {
              "animation-type": "slide-up",
              threshold: 0.15
            }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_18$Q, [
                  createBaseVNode("div", _hoisted_19$Q, [
                    createBaseVNode("div", _hoisted_20$P, [
                      _cache[17] || (_cache[17] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                        createBaseVNode("div", { class: "w-3 h-3 bg-gradient-to-r from-green-400 to-blue-500 rounded-full mr-3" })
                      ], -1)),
                      createBaseVNode("h3", _hoisted_21$P, toDisplayString$1(unref(t)("dashboard.recentActivity", "Recent Activity")), 1)
                    ]),
                    createBaseVNode("div", _hoisted_22$N, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(recentActivities.value, (activity, index) => {
                        return openBlock(), createElementBlock("div", {
                          key: activity.id,
                          class: "group/activity flex items-center space-x-4 p-3 rounded-xl hover:bg-white/50 dark:hover:bg-white/5 transition-all duration-300 transform hover:scale-105",
                          style: normalizeStyle({ animationDelay: `${index * 100}ms` })
                        }, [
                          createBaseVNode("div", _hoisted_23$N, [
                            createBaseVNode("div", {
                              class: normalizeClass(["w-10 h-10 rounded-full flex items-center justify-center transform group-hover/activity:rotate-12 group-hover/activity:scale-110 transition-all duration-300", activity.iconColor])
                            }, _cache[18] || (_cache[18] = [
                              createBaseVNode("svg", {
                                class: "w-5 h-5 text-white",
                                fill: "currentColor",
                                viewBox: "0 0 20 20"
                              }, [
                                createBaseVNode("path", {
                                  "fill-rule": "evenodd",
                                  d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z",
                                  "clip-rule": "evenodd"
                                })
                              ], -1)
                            ]), 2)
                          ]),
                          createBaseVNode("div", _hoisted_24$L, [
                            createBaseVNode("p", _hoisted_25$L, toDisplayString$1(activity.title), 1),
                            createBaseVNode("p", _hoisted_26$I, toDisplayString$1(activity.time), 1)
                          ]),
                          _cache[19] || (_cache[19] = createBaseVNode("div", { class: "opacity-0 group-hover/activity:opacity-100 transition-opacity duration-300" }, [
                            createBaseVNode("svg", {
                              class: "w-5 h-5 text-blue-500 dark:text-blue-400",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M9 5l7 7-7 7"
                              })
                            ])
                          ], -1))
                        ], 4);
                      }), 128))
                    ])
                  ])
                ])
              ]),
              _: 1
            })
          ])
        ])
      ]);
    };
  }
});

const debugAvailableVoices = () => {
  if ("speechSynthesis" in window) {
    const voices = speechSynthesis.getVoices();
    console.log("=== AVAILABLE VOICES DEBUG ====");
    console.log(`Total voices found: ${voices.length}`);
    voices.forEach((voice, index) => {
      console.log(`${index + 1}. Name: "${voice.name}" | Lang: ${voice.lang} | Local: ${voice.localService} | Default: ${voice.default}`);
    });
    const koreanVoices = voices.filter((voice) => voice.lang.startsWith("ko"));
    console.log("\n=== KOREAN VOICES DETAIL ====");
    console.log(`Korean voices found: ${koreanVoices.length}`);
    koreanVoices.forEach((voice, index) => {
      const name = voice.name.toLowerCase();
      const genderGuess = name.includes("female") || name.includes("woman") ? " Female" : name.includes("male") || name.includes("man") ? " Male" : " Unknown";
      console.log(` ${index + 1}. "${voice.name}" | ${genderGuess} | Lang: ${voice.lang}`);
    });
    console.log("===============================");
    return voices;
  }
  return [];
};
const defaultSettings = {
  "female-sweet": { rate: 0.85, pitch: 1.1, volume: 1 },
  "female-clear": { rate: 1, pitch: 0.95, volume: 1 },
  "female-professional": { rate: 0.9, pitch: 0.85, volume: 1 },
  "male-strong": { rate: 0.8, pitch: 0.7, volume: 1 },
  "male-gentle": { rate: 0.9, pitch: 0.9, volume: 1 },
  "male-deep": { rate: 0.75, pitch: 0.6, volume: 1 },
  "korean-female": { rate: 0.95, pitch: 1.15, volume: 1 },
  "korean-male": { rate: 0.85, pitch: 0.5, volume: 1 }
};
const voiceSettings = ref({ ...defaultSettings });
const currentVoiceType = ref("female-sweet");
const availableVoices = ref([]);
const selectedVoice = ref(null);
const loadVoices = () => {
  if ("speechSynthesis" in window) {
    const voices = speechSynthesis.getVoices();
    console.log("Loading voices, total found:", voices.length);
    debugAvailableVoices();
    const englishVoices = voices.filter((voice) => voice.lang.startsWith("en"));
    const koreanVoices = voices.filter((voice) => voice.lang.startsWith("ko"));
    const allSupportedVoices = [...englishVoices, ...koreanVoices];
    console.log("English voices found:", englishVoices.length);
    console.log("Korean voices found:", koreanVoices.length);
    console.log("Total supported voices:", allSupportedVoices.length);
    availableVoices.value = allSupportedVoices;
    if (allSupportedVoices.length > 0) {
      updateSelectedVoice();
    }
  }
};
const updateSelectedVoice = () => {
  const voices = availableVoices.value;
  console.log("Updating voice selection, available voices:", voices.length);
  console.log("Current voice type:", currentVoiceType.value);
  if (voices.length === 0) {
    console.log("No voices available, loading voices...");
    loadVoices();
    return;
  }
  let targetVoice = null;
  const englishVoices = voices.filter((voice) => voice.lang.startsWith("en"));
  const koreanVoices = voices.filter((voice) => voice.lang.startsWith("ko"));
  const femaleVoices = englishVoices.filter((voice) => {
    const name = voice.name.toLowerCase();
    return name.includes("female") || name.includes("woman") || name.includes("zira") || name.includes("hazel") || name.includes("cortana") || name.includes("helena") || name.includes("susan") || name.includes("samantha") || name.includes("karen");
  });
  const maleVoices = englishVoices.filter((voice) => {
    const name = voice.name.toLowerCase();
    return name.includes("male") || name.includes("man") || name.includes("david") || name.includes("mark") || name.includes("daniel") || name.includes("richard") || name.includes("alex") || name.includes("tom") || name.includes("aaron");
  });
  const koreanFemaleVoices = koreanVoices.filter((voice) => {
    const name = voice.name.toLowerCase();
    if (name.includes("female") || name.includes("woman")) return true;
    if (name.includes("heami") || name.includes("yuna") || name.includes("seoyeon") || name.includes("sora") || name.includes("inha") || name.includes("nayeon") || name.includes("clara") || name.includes("aria")) return true;
    if (name.includes("male") || name.includes("man")) return false;
    return false;
  });
  const koreanMaleVoices = koreanVoices.filter((voice) => {
    const name = voice.name.toLowerCase();
    if (name.includes("male") || name.includes("man")) return true;
    if (name.includes("minho") || name.includes("woojin") || name.includes("taehyun") || name.includes("jun") || name.includes("alex") || name.includes("david") || name.includes("injoo")) return true;
    if (name.includes("female") || name.includes("woman")) return false;
    return false;
  });
  const remainingKoreanVoices = koreanVoices.filter(
    (voice) => !koreanFemaleVoices.includes(voice) && !koreanMaleVoices.includes(voice)
  );
  if (remainingKoreanVoices.length > 0) {
    const midPoint = Math.ceil(remainingKoreanVoices.length / 2);
    koreanFemaleVoices.push(...remainingKoreanVoices.slice(0, midPoint));
    koreanMaleVoices.push(...remainingKoreanVoices.slice(midPoint));
  }
  console.log(`English Female voices found: ${femaleVoices.length}`, femaleVoices.map((v) => v.name));
  console.log(`English Male voices found: ${maleVoices.length}`, maleVoices.map((v) => v.name));
  console.log(`Korean Female voices found: ${koreanFemaleVoices.length}`, koreanFemaleVoices.map((v) => v.name));
  console.log(`Korean Male voices found: ${koreanMaleVoices.length}`, koreanMaleVoices.map((v) => v.name));
  if (koreanFemaleVoices.length === 0 && koreanMaleVoices.length === 0 && koreanVoices.length > 0) {
    const halfPoint = Math.floor(koreanVoices.length / 2);
    koreanFemaleVoices.push(...koreanVoices.slice(0, halfPoint));
    koreanMaleVoices.push(...koreanVoices.slice(halfPoint));
    console.log("No Korean gender-specific voices found, splitting by index");
  }
  if (femaleVoices.length === 0 && maleVoices.length === 0 && englishVoices.length > 0) {
    const halfPoint = Math.floor(englishVoices.length / 2);
    femaleVoices.push(...englishVoices.slice(0, halfPoint));
    maleVoices.push(...englishVoices.slice(halfPoint));
    console.log("No English gender-specific voices found, splitting by index");
  }
  switch (currentVoiceType.value) {
    case "female-sweet":
      targetVoice = femaleVoices[0] || voices[0];
      console.log("Selected female-sweet:", targetVoice?.name);
      break;
    case "female-clear":
      targetVoice = femaleVoices[1] || femaleVoices[0] || voices[1] || voices[0];
      console.log("Selected female-clear:", targetVoice?.name);
      break;
    case "female-professional":
      targetVoice = femaleVoices[2] || femaleVoices[0] || voices[2] || voices[0];
      console.log("Selected female-professional:", targetVoice?.name);
      break;
    case "male-strong":
      targetVoice = maleVoices[0] || voices[Math.floor(voices.length / 2)] || voices[0];
      console.log("Selected male-strong:", targetVoice?.name);
      break;
    case "male-gentle":
      targetVoice = maleVoices[1] || maleVoices[0] || voices[Math.floor(voices.length / 2) + 1] || voices[0];
      console.log("Selected male-gentle:", targetVoice?.name);
      break;
    case "male-deep":
      targetVoice = maleVoices[2] || maleVoices[0] || voices[Math.floor(voices.length / 2) + 2] || voices[0];
      console.log("Selected male-deep:", targetVoice?.name);
      break;
    case "korean-female":
      targetVoice = koreanVoices[0] || voices[0];
      console.log(" KOREAN FEMALE - Selected voice:", targetVoice?.name, "Lang:", targetVoice?.lang);
      break;
    case "korean-male":
      if (koreanVoices.length >= 2) {
        targetVoice = koreanVoices[1];
        console.log(" KOREAN MALE - Using second Korean voice:", targetVoice?.name);
      } else if (koreanVoices.length === 1) {
        targetVoice = koreanVoices[0];
        console.log(" KOREAN MALE - Using same Korean voice with deep pitch (0.5):", targetVoice?.name);
      } else {
        targetVoice = maleVoices[0] || voices[0];
        console.log(" KOREAN MALE - No Korean voices, using male voice:", targetVoice?.name);
      }
      if (!targetVoice) {
        targetVoice = voices[0];
        console.log(" FALLBACK: Using first available voice:", targetVoice?.name);
      }
      console.log(" Total Korean voices:", koreanVoices.length, koreanVoices.map((v) => v.name));
      console.log(" Final selected voice for Korean Male:", targetVoice?.name, "Lang:", targetVoice?.lang);
      break;
  }
  console.log(`Looking for ${currentVoiceType.value} voice, found:`, targetVoice?.name);
  const previousVoice = selectedVoice.value?.name;
  selectedVoice.value = targetVoice || voices[0] || null;
  console.log("Voice changed from", previousVoice, "to", selectedVoice.value?.name);
};
const loadSettings = () => {
  const saved = localStorage.getItem("voice-settings");
  const savedType = localStorage.getItem("voice-type");
  if (saved) {
    try {
      const parsedSettings = JSON.parse(saved);
      voiceSettings.value = {
        ...defaultSettings,
        ...Object.keys(parsedSettings).reduce((acc, key) => {
          const voiceType = key;
          if (defaultSettings[voiceType]) {
            acc[voiceType] = { ...defaultSettings[voiceType], ...parsedSettings[voiceType] };
          }
          return acc;
        }, {})
      };
    } catch (error) {
      console.error("Error loading voice settings:", error);
      voiceSettings.value = { ...defaultSettings };
    }
  }
  if (savedType) {
    currentVoiceType.value = savedType;
  }
};
const saveSettings = () => {
  localStorage.setItem("voice-settings", JSON.stringify(voiceSettings.value));
  localStorage.setItem("voice-type", currentVoiceType.value);
};
const createUtterance = (text) => {
  updateSelectedVoice();
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.lang = "en-US";
  const settings = voiceSettings.value[currentVoiceType.value];
  utterance.rate = Math.max(0.1, Math.min(10, settings.rate));
  utterance.pitch = Math.max(0, Math.min(2, settings.pitch));
  utterance.volume = Math.max(0, Math.min(1, settings.volume));
  console.log("Creating utterance with voice type:", currentVoiceType.value);
  console.log("Selected voice for utterance:", selectedVoice.value?.name);
  if (selectedVoice.value) {
    utterance.voice = selectedVoice.value;
  }
  return utterance;
};
const playAudio = (text) => {
  return new Promise((resolve, reject) => {
    if (!("speechSynthesis" in window)) {
      console.warn("Speech synthesis not supported");
      reject(new Error("Speech synthesis not supported"));
      return;
    }
    const utterance = createUtterance(text);
    utterance.onend = () => resolve();
    utterance.onerror = (event) => reject(event.error);
    speechSynthesis.speak(utterance);
  });
};
const setVoiceType = (type) => {
  console.log("Setting voice type to:", type);
  currentVoiceType.value = type;
  if (availableVoices.value.length === 0) {
    loadVoices();
  }
  updateSelectedVoice();
  saveSettings();
  console.log("Voice updated to:", selectedVoice.value?.name);
};
const updateVoiceSettings = (type, newSettings) => {
  if (voiceSettings.value[type]) {
    voiceSettings.value[type] = { ...voiceSettings.value[type], ...newSettings };
    saveSettings();
  }
};
const resetVoiceSettings = (type) => {
  if (defaultSettings[type]) {
    voiceSettings.value[type] = { ...defaultSettings[type] };
    saveSettings();
  }
};
const getVoiceTypeOptions = () => {
  const { t } = useI18n();
  return [
    { value: "female-sweet", label: t("voice.types.female_sweet", "Female Sweet"), icon: "" },
    { value: "female-clear", label: t("voice.types.female_clear", "Female Clear"), icon: "" },
    { value: "female-professional", label: t("voice.types.female_professional", "Female Professional"), icon: "" },
    { value: "male-strong", label: t("voice.types.male_strong", "Male Strong"), icon: "" },
    { value: "male-gentle", label: t("voice.types.male_gentle", "Male Gentle"), icon: "" },
    { value: "male-deep", label: t("voice.types.male_deep", "Male Deep"), icon: "" },
    { value: "korean-female", label: t("voice.types.korean_female", "Korean Female"), icon: "" },
    { value: "korean-male", label: t("voice.types.korean_male", "Korean Male"), icon: "" }
  ];
};
const getCurrentVoiceInfo = () => {
  if (!selectedVoice.value) return null;
  const gender = currentVoiceType.value.includes("female") ? "female" : "male";
  return {
    name: selectedVoice.value.name,
    lang: selectedVoice.value.lang,
    gender
  };
};
watch(voiceSettings, () => {
  saveSettings();
}, { deep: true });
watch(currentVoiceType, (newType, oldType) => {
  if (newType !== oldType) {
    console.log("Voice type changed from", oldType, "to", newType);
    updateSelectedVoice();
    saveSettings();
  }
});
if ("speechSynthesis" in window) {
  speechSynthesis.onvoiceschanged = () => {
    loadVoices();
  };
}
loadSettings();
loadVoices();
const forceReloadVoices = () => {
  console.log(" Force reloading voices...");
  if ("speechSynthesis" in window) {
    speechSynthesis.cancel();
    speechSynthesis.getVoices();
    loadVoices();
    debugAvailableVoices();
  }
};
function useVoiceStore() {
  return {
    voiceSettings,
    currentVoiceType,
    availableVoices,
    selectedVoice,
    setVoiceType,
    updateVoiceSettings,
    resetVoiceSettings,
    playAudio,
    createUtterance,
    getVoiceTypeOptions,
    getCurrentVoiceInfo,
    loadVoices,
    forceReloadVoices,
    debugAvailableVoices
  };
}

const BUILT_IN_CATEGORIES = [
  "technology",
  "business",
  "travel",
  "food",
  "health",
  "education",
  "sports",
  "entertainment",
  "science",
  "art",
  "music",
  "literature",
  "politics",
  "environment",
  "fashion",
  "finance"
];
function normalizeLocale(input) {
  const s = (input || "").toLowerCase();
  if (s.startsWith("vi")) return "vi";
  if (s.startsWith("ko")) return "ko";
  return "en";
}
function getTopicName(categoryKey, t, locale, vocabularyItem) {
  const customTopics = getCustomTopics();
  const builtInKeys = BUILT_IN_CATEGORIES;
  const rawLocale = typeof locale === "string" ? locale : locale?.value;
  const currentLocale = normalizeLocale(rawLocale);
  let key = String(categoryKey || "").trim();
  const isNumericLike = /^\d+$/.test(key);
  if (isNumericLike && vocabularyItem && vocabularyItem.category && !/^\d+$/.test(String(vocabularyItem.category))) {
    key = String(vocabularyItem.category);
  }
  const keyLower = key.toLowerCase();
  if (vocabularyItem && vocabularyItem.categoryName) {
    const cn = String(vocabularyItem.categoryName).trim();
    const cnLower = cn.toLowerCase();
    const isKnownKey = builtInKeys.includes(cnLower) || customTopics.some((ct) => (ct.key || "").toLowerCase() === cnLower);
    if (!isKnownKey && currentLocale === "en") {
      return cn;
    }
  }
  const customTopic = customTopics.find((topic) => topic.key === key) || customTopics.find((topic) => (topic.key || "").toLowerCase() === keyLower);
  if (customTopic) {
    if (currentLocale === "vi") {
      return customTopic.vi || customTopic.en || customTopic.ko || key;
    }
    if (currentLocale === "ko") {
      return customTopic.ko || customTopic.en || customTopic.vi || key;
    }
    return customTopic.en || customTopic.vi || customTopic.ko || key;
  }
  if (t) {
    const translationKey = `vocabulary.categories.${keyLower}`;
    const translatedName = t(translationKey);
    if (translatedName && translatedName !== translationKey) {
      return translatedName;
    }
  }
  const builtInCategories = {
    "technology": { vi: "Cng ngh", en: "Technology", ko: "" },
    "business": { vi: "Kinh doanh", en: "Business", ko: "" },
    "travel": { vi: "Du lch", en: "Travel", ko: "" },
    "food": { vi: "m thc", en: "Food", ko: "" },
    "health": { vi: "Sc khe", en: "Health", ko: "" },
    "education": { vi: "Gio dc", en: "Education", ko: "" },
    "sports": { vi: "Th thao", en: "Sports", ko: "" },
    "entertainment": { vi: "Gii tr", en: "Entertainment", ko: "" },
    "science": { vi: "Khoa hc", en: "Science", ko: "" },
    "art": { vi: "Ngh thut", en: "Art", ko: "" },
    "music": { vi: "m nhc", en: "Music", ko: "" },
    "literature": { vi: "Vn hc", en: "Literature", ko: "" },
    "politics": { vi: "Chnh tr", en: "Politics", ko: "" },
    "environment": { vi: "Mi trng", en: "Environment", ko: "" },
    "fashion": { vi: "Thi trang", en: "Fashion", ko: "" },
    "finance": { vi: "Ti chnh", en: "Finance", ko: "" }
  };
  if (builtInCategories[keyLower]) {
    if (currentLocale === "vi") return builtInCategories[keyLower].vi;
    if (currentLocale === "ko") return builtInCategories[keyLower].ko;
    return builtInCategories[keyLower].en;
  }
  if (vocabularyItem && vocabularyItem.categoryName) {
    return String(vocabularyItem.categoryName);
  }
  return key.charAt(0).toUpperCase() + key.slice(1);
}
function getAllTopicsWithNames(t, locale) {
  const builtInCategories = BUILT_IN_CATEGORIES;
  const result = [];
  builtInCategories.forEach((key) => {
    result.push({
      key,
      name: getTopicName(key, t, locale)
    });
  });
  const customTopics = getCustomTopics();
  customTopics.forEach((topic) => {
    result.push({
      key: topic.key,
      name: getTopicName(topic.key, t, locale)
    });
  });
  return result.sort((a, b) => a.name.localeCompare(b.name));
}
function getCustomTopics() {
  try {
    const saved = localStorage.getItem("customTopics");
    if (saved) {
      const topics = JSON.parse(saved);
      return Array.isArray(topics) ? topics : [];
    }
  } catch (error) {
    console.error("Error loading custom topics:", error);
  }
  return [];
}
function useTopicName() {
  const { t, locale } = useI18n();
  return {
    getTopicName: (categoryKey) => {
      return getTopicName(categoryKey, t, locale);
    },
    getAllTopicsWithNames: () => {
      return getAllTopicsWithNames(t, locale);
    },
    currentLocale: locale
  };
}

function useVocabularyFilters() {
  const searchQuery = ref("");
  const selectedCategory = ref("");
  const selectedLevel = ref("");
  const showFavoritesOnly = ref(false);
  const currentPage = ref(1);
  const dateGroupPages = ref({});
  function getStoredValue(key, defaultValue) {
    try {
      const stored = localStorage.getItem(key);
      return stored !== null ? JSON.parse(stored) : defaultValue;
    } catch {
      return defaultValue;
    }
  }
  function setStoredValue(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
  }
  showFavoritesOnly.value = getStoredValue("vocabulary-show-favorites-only", false);
  searchQuery.value = getStoredValue("vocabulary-search-query", "");
  selectedCategory.value = getStoredValue("vocabulary-selected-category", "");
  selectedLevel.value = getStoredValue("vocabulary-selected-level", "");
  const updateShowFavoritesOnly = (value) => {
    showFavoritesOnly.value = value;
    setStoredValue("vocabulary-show-favorites-only", value);
    currentPage.value = 1;
    dateGroupPages.value = {};
  };
  const updateSearchQuery = (value) => {
    searchQuery.value = value;
    setStoredValue("vocabulary-search-query", value);
    currentPage.value = 1;
    dateGroupPages.value = {};
  };
  const updateSelectedCategory = (value) => {
    selectedCategory.value = value;
    setStoredValue("vocabulary-selected-category", value);
    currentPage.value = 1;
    dateGroupPages.value = {};
  };
  const updateSelectedLevel = (value) => {
    selectedLevel.value = value;
    setStoredValue("vocabulary-selected-level", value);
    currentPage.value = 1;
    dateGroupPages.value = {};
  };
  return {
    searchQuery,
    selectedCategory,
    selectedLevel,
    showFavoritesOnly,
    currentPage,
    dateGroupPages,
    updateShowFavoritesOnly,
    updateSearchQuery,
    updateSelectedCategory,
    updateSelectedLevel
  };
}

function useVocabularyPagination(filteredVocabulary, useGrouping, itemsPerPage) {
  const currentPage = ref(1);
  const totalPages = computed(() => {
    if (useGrouping.value) return 1;
    return Math.ceil(filteredVocabulary.value.length / itemsPerPage.value);
  });
  const paginatedVocabulary = computed(() => {
    if (useGrouping.value) return filteredVocabulary.value;
    const start = (currentPage.value - 1) * itemsPerPage.value;
    const end = start + itemsPerPage.value;
    return filteredVocabulary.value.slice(start, end);
  });
  const startIndex = computed(() => (currentPage.value - 1) * itemsPerPage.value + 1);
  const endIndex = computed(() => Math.min(currentPage.value * itemsPerPage.value, filteredVocabulary.value.length));
  const visiblePages = computed(() => {
    const pages = [];
    const start = Math.max(1, currentPage.value - 2);
    const end = Math.min(totalPages.value, currentPage.value + 2);
    for (let i = start; i <= end; i++) {
      pages.push(i);
    }
    return pages;
  });
  const previousPage = () => {
    if (currentPage.value > 1) currentPage.value--;
  };
  const nextPage = () => {
    if (currentPage.value < totalPages.value) currentPage.value++;
  };
  const goToPage = (page) => {
    currentPage.value = page;
  };
  return {
    currentPage,
    totalPages,
    paginatedVocabulary,
    startIndex,
    endIndex,
    visiblePages,
    previousPage,
    nextPage,
    goToPage
  };
}

function useVocabularyGrouping() {
  const useGrouping = ref(false);
  const itemsPerPageGrouped = ref(5);
  const dateGroupPages = ref({});
  const getStoredUseGrouping = () => {
    const stored = localStorage.getItem("vocabulary-use-grouping");
    return stored ? JSON.parse(stored) : false;
  };
  const setStoredUseGrouping = (value) => {
    localStorage.setItem("vocabulary-use-grouping", JSON.stringify(value));
  };
  useGrouping.value = getStoredUseGrouping();
  const toggleGrouping = () => {
    useGrouping.value = !useGrouping.value;
    setStoredUseGrouping(useGrouping.value);
  };
  const reloadGroupingState = () => {
    useGrouping.value = getStoredUseGrouping();
  };
  const dateGroupPrevious = (date, filteredVocabulary) => {
    const currentPage = dateGroupPages.value[date] || 1;
    if (currentPage > 1) {
      dateGroupPages.value[date] = currentPage - 1;
    }
  };
  const dateGroupNext = (date, filteredVocabulary) => {
    const currentPage = dateGroupPages.value[date] || 1;
    const dateGroup = filteredVocabulary.filter((word) => getDateKey(word.createdAt) === date);
    const totalPages = Math.ceil(dateGroup.length / itemsPerPageGrouped.value);
    if (currentPage < totalPages) {
      dateGroupPages.value[date] = currentPage + 1;
    }
  };
  const dateGroupGoToPage = (date, page) => {
    dateGroupPages.value[date] = page;
  };
  return {
    useGrouping,
    itemsPerPageGrouped,
    dateGroupPages,
    toggleGrouping,
    reloadGroupingState,
    dateGroupPrevious,
    dateGroupNext,
    dateGroupGoToPage
  };
}

function useVocabularyDialogs() {
  const showFormDialog = ref(false);
  const selectedVocabulary = ref(null);
  const showDetailDialog = ref(false);
  const selectedVocabularyForDetail = ref(null);
  const openAddDialog = () => {
    selectedVocabulary.value = null;
    showFormDialog.value = true;
    window.dispatchEvent(new CustomEvent("vocabulary-edit-word"));
  };
  const openEditDialog = (word) => {
    selectedVocabulary.value = word;
    showFormDialog.value = true;
    window.dispatchEvent(new CustomEvent("vocabulary-edit-word"));
  };
  const onVocabularySaved = () => {
    showFormDialog.value = false;
    selectedVocabulary.value = null;
  };
  const openDetailsDialog = (word) => {
    selectedVocabularyForDetail.value = word;
    showDetailDialog.value = true;
    window.dispatchEvent(new CustomEvent("vocabulary-view-details"));
  };
  const openEditFromDetail = (word) => {
    showDetailDialog.value = false;
    selectedVocabulary.value = word;
    showFormDialog.value = true;
    window.dispatchEvent(new CustomEvent("vocabulary-edit-word"));
  };
  return {
    showFormDialog,
    selectedVocabulary,
    showDetailDialog,
    selectedVocabularyForDetail,
    openAddDialog,
    openEditDialog,
    onVocabularySaved,
    openDetailsDialog,
    openEditFromDetail
  };
}

function useTopicManager(debounceAutoSave) {
  const showTopicManager = ref(false);
  const vocabularyStore = useVocabularyStore();
  const modalStore = useModalStore();
  const openTopicManager = () => {
    showTopicManager.value = true;
    modalStore.setTopicManager(true);
  };
  watch(showTopicManager, (newValue) => {
    modalStore.setTopicManager(newValue);
  });
  const onTopicAdded = (topic) => {
    vocabularyStore.addCustomTopic(topic);
    debounceAutoSave();
    window.dispatchEvent(new CustomEvent("topics-updated"));
  };
  const onTopicUpdated = (oldKey, topic) => {
    vocabularyStore.allVocabularies.value.forEach((vocab) => {
      if (vocab.category === oldKey) {
        vocabularyStore.updateVocabulary(vocab.id, { category: topic.key });
      }
    });
    vocabularyStore.updateCustomTopic(oldKey, topic);
    debounceAutoSave();
    window.dispatchEvent(new CustomEvent("topics-updated"));
  };
  const onTopicDeleted = (key) => {
    vocabularyStore.deleteCustomTopic(key);
    debounceAutoSave();
    window.dispatchEvent(new CustomEvent("topics-updated"));
  };
  return {
    showTopicManager,
    openTopicManager,
    onTopicAdded,
    onTopicUpdated,
    onTopicDeleted
  };
}

const GOOGLE_CLIENT_ID = "330597757388-cdngesnvlcn7uiev2ptar27bu1gco9bt.apps.googleusercontent.com";
const GOOGLE_API_KEY = "AIzaSyDQONqrEK8FmTVj2ci8AM-DMmBKFMMZz20";
const DISCOVERY_DOC = "https://www.googleapis.com/discovery/v1/apis/drive/v3/rest";
const SCOPES = "https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email";
const isGoogleApiLoaded = ref(false);
const isGoogleSignedIn = ref(false);
const googleUser = ref(null);
const googleUserEmail = ref("");
const authError = ref("");
const GOOGLE_TOKEN_KEY = "vocabulary-google-token";
const GOOGLE_USER_KEY = "vocabulary-google-user";
const GOOGLE_USER_EMAIL_KEY = "vocabulary-google-user-email";
const GOOGLE_SIGNED_IN_KEY = "vocabulary-is-google-signed-in";
class GoogleDriveAuth {
  static instance;
  gapi = null;
  tokenClient = null;
  autoRefreshTimer = null;
  constructor() {
    this.loadSavedAuthState();
  }
  static getInstance() {
    if (!GoogleDriveAuth.instance) {
      GoogleDriveAuth.instance = new GoogleDriveAuth();
    }
    return GoogleDriveAuth.instance;
  }
  /**
   * Load saved authentication state from localStorage
   */
  loadSavedAuthState() {
    try {
      const savedToken = localStorage.getItem(GOOGLE_TOKEN_KEY);
      const savedUser = localStorage.getItem(GOOGLE_USER_KEY);
      const savedEmail = localStorage.getItem(GOOGLE_USER_EMAIL_KEY);
      const savedSignedIn = localStorage.getItem(GOOGLE_SIGNED_IN_KEY);
      if (savedToken && savedUser && savedSignedIn === "true") {
        console.log(" Loading saved Google authentication state...");
        const tokenData = JSON.parse(savedToken);
        const userData = JSON.parse(savedUser);
        const tokenAge = Date.now() - (tokenData.timestamp || 0);
        const isTokenExpired = tokenAge > 90 * 24 * 60 * 60 * 1e3;
        googleUser.value = userData;
        googleUserEmail.value = savedEmail || "";
        isGoogleSignedIn.value = true;
        if (isTokenExpired) {
          console.log(" Saved Google token expired, will attempt silent refresh later");
        } else {
          console.log(" Google authentication state restored from localStorage");
        }
      } else {
        console.log(" No saved Google authentication state found");
      }
    } catch (error) {
      console.error(" Error loading saved auth state:", error);
    }
  }
  /**
   * Save authentication state to localStorage
   */
  saveAuthState(token, user, email) {
    try {
      localStorage.setItem(GOOGLE_TOKEN_KEY, JSON.stringify({
        access_token: token.access_token,
        timestamp: Date.now()
      }));
      localStorage.setItem(GOOGLE_USER_KEY, JSON.stringify(user));
      localStorage.setItem(GOOGLE_SIGNED_IN_KEY, "true");
      if (email) {
        localStorage.setItem(GOOGLE_USER_EMAIL_KEY, email);
      }
      console.log(" Google auth state saved to localStorage");
    } catch (error) {
      console.error(" Error saving auth state:", error);
    }
  }
  /**
   * Clear saved authentication state from localStorage
   */
  clearSavedAuthState() {
    try {
      localStorage.removeItem(GOOGLE_TOKEN_KEY);
      localStorage.removeItem(GOOGLE_USER_KEY);
      localStorage.removeItem(GOOGLE_USER_EMAIL_KEY);
      localStorage.removeItem(GOOGLE_SIGNED_IN_KEY);
      console.log(" Google auth state cleared from localStorage");
    } catch (error) {
      console.error(" Error clearing auth state:", error);
    }
  }
  /**
   * Initialize Google APIs
   */
  async initialize() {
    if (isGoogleApiLoaded.value && this.tokenClient && this.gapi) {
      console.log("Google APIs already initialized");
      return;
    }
    try {
      console.log(" Initializing Google APIs...");
      authError.value = "";
      await this.loadGoogleScripts();
      await Promise.all([
        this.initializeGapi(),
        this.initializeGIS()
      ]);
      if (!this.tokenClient || !this.gapi) {
        throw new Error("Google APIs initialization incomplete");
      }
      isGoogleApiLoaded.value = true;
      console.log(" Google APIs initialized successfully");
      await this.restoreTokenToGapi();
      if (isGoogleSignedIn.value) {
        this.startAutoRefresh();
        this.attachLifecycleListeners();
      }
    } catch (error) {
      console.error(" Failed to initialize Google APIs:", error);
      authError.value = "Failed to initialize Google APIs";
      isGoogleApiLoaded.value = false;
      throw error;
    }
  }
  /**
   * Restore saved token to gapi client
   */
  async restoreTokenToGapi() {
    try {
      const savedToken = localStorage.getItem(GOOGLE_TOKEN_KEY);
      if (savedToken && this.gapi && isGoogleSignedIn.value) {
        const tokenData = JSON.parse(savedToken);
        const tokenAge = Date.now() - (tokenData.timestamp || 0);
        const isTokenExpired = tokenAge > 90 * 24 * 60 * 60 * 1e3;
        if (!isTokenExpired) {
          console.log(" Restoring token to GAPI client...");
          this.gapi.client.setToken({ access_token: tokenData.access_token });
          console.log(" Token restored to GAPI client");
          await this.verifyTokenValidity();
        } else {
          console.log(" Token expired during restoration, attempting silent refresh...");
          const refreshSuccess = await this.attemptSilentRefresh();
          if (!refreshSuccess) {
            console.log(" Silent refresh failed during restoration. Keeping saved login state.");
            authError.value = "Token expired; will require refresh on next action";
          }
        }
      }
    } catch (error) {
      console.error(" Error restoring token to GAPI:", error);
      authError.value = "Failed to restore authentication";
    }
  }
  /**
   * Load Google API scripts dynamically
   */
  async loadGoogleScripts() {
    const loadScript = (src) => {
      return new Promise((resolve, reject) => {
        const existingScript = document.querySelector(`script[src="${src}"]`);
        if (existingScript && window.gapi && window.google) {
          resolve();
          return;
        }
        const script = document.createElement("script");
        script.src = src;
        script.async = true;
        script.defer = true;
        script.onload = () => {
          console.log(` Script loaded: ${src}`);
          resolve();
        };
        script.onerror = () => {
          console.error(` Failed to load script: ${src}`);
          reject(new Error(`Failed to load script: ${src}`));
        };
        document.head.appendChild(script);
      });
    };
    try {
      await Promise.all([
        loadScript("https://apis.google.com/js/api.js"),
        loadScript("https://accounts.google.com/gsi/client")
      ]);
      await new Promise((resolve) => setTimeout(resolve, 500));
      if (!window.gapi) {
        throw new Error("Google API (gapi) not loaded");
      }
      if (!window.google?.accounts) {
        throw new Error("Google Identity Services not loaded");
      }
      console.log(" Google scripts loaded and verified");
    } catch (error) {
      console.error(" Error loading Google scripts:", error);
      throw error;
    }
  }
  /**
   * Initialize Google API client
   */
  async initializeGapi() {
    return new Promise((resolve, reject) => {
      window.gapi.load("client", async () => {
        try {
          await window.gapi.client.init({
            apiKey: GOOGLE_API_KEY,
            discoveryDocs: [DISCOVERY_DOC]
          });
          this.gapi = window.gapi;
          console.log(" GAPI client initialized");
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    });
  }
  /**
   * Initialize Google Identity Services
   */
  async initializeGIS() {
    return new Promise((resolve, reject) => {
      try {
        this.tokenClient = window.google.accounts.oauth2.initTokenClient({
          client_id: GOOGLE_CLIENT_ID,
          scope: SCOPES,
          callback: (response) => {
            if (response.error) {
              console.error(" Token client error:", response.error);
              authError.value = response.error_description || "Authentication failed";
              isGoogleSignedIn.value = false;
            } else {
              console.log(" Token received successfully");
              this.handleAuthSuccess(response);
            }
          }
        });
        console.log(" Google Identity Services initialized");
        resolve();
      } catch (error) {
        reject(error);
      }
    });
  }
  /**
   * Sign in to Google account
   */
  async signIn() {
    try {
      console.log(" Initiating Google sign-in...");
      if (!this.tokenClient || !isGoogleApiLoaded.value) {
        console.log(" Auto-initializing Google APIs for sign-in...");
        await this.initialize();
      }
      if (!this.tokenClient) {
        throw new Error("Failed to initialize Google Identity Services");
      }
      authError.value = "";
      this.tokenClient.requestAccessToken({ prompt: "consent" });
      return new Promise((resolve) => {
        const timeoutId = setTimeout(() => {
          console.warn(" Google sign-in timeout");
          authError.value = "Sign-in timeout";
          resolve(false);
        }, 3e4);
        const checkAuth = () => {
          if (isGoogleSignedIn.value) {
            clearTimeout(timeoutId);
            this.startAutoRefresh();
            this.attachLifecycleListeners();
            resolve(true);
          } else if (authError.value) {
            clearTimeout(timeoutId);
            resolve(false);
          } else {
            setTimeout(checkAuth, 100);
          }
        };
        checkAuth();
      });
    } catch (error) {
      console.error(" Sign-in failed:", error);
      authError.value = "Sign-in failed";
      return false;
    }
  }
  /**
   * Sign out from Google account
   */
  async signOut() {
    try {
      if (this.gapi?.client?.getToken()) {
        window.google.accounts.oauth2.revoke(this.gapi.client.getToken().access_token);
      }
      isGoogleSignedIn.value = false;
      googleUser.value = null;
      googleUserEmail.value = "";
      authError.value = "";
      this.stopAutoRefresh();
      this.detachLifecycleListeners();
      this.clearSavedAuthState();
      console.log(" Signed out successfully and cleared saved state");
    } catch (error) {
      console.error(" Sign-out failed:", error);
      throw error;
    }
  }
  /**
   * Handle successful authentication
   */
  async handleAuthSuccess(response) {
    googleUser.value = response;
    isGoogleSignedIn.value = true;
    this.gapi.client.setToken({ access_token: response.access_token });
    const userEmail = await this.fetchUserEmail();
    console.log(" Fetched user email:", userEmail);
    if (userEmail) {
      googleUserEmail.value = userEmail;
      console.log(" Email set to reactive state:", googleUserEmail.value);
    } else {
      console.log(" No email received from API");
    }
    this.saveAuthState({ access_token: response.access_token }, response, userEmail || void 0);
    console.log(" Authentication successful and persisted");
    this.startAutoRefresh();
  }
  /**
   * Verify token validity with a test API call
   */
  async verifyTokenValidity() {
    try {
      if (!this.gapi?.client) return false;
      const response = await this.gapi.client.request({
        path: "https://www.googleapis.com/drive/v3/about?fields=user"
      });
      if (response.status === 200) {
        console.log(" Token verification successful");
        return true;
      } else {
        console.log(" Token verification failed:", response.status);
        return false;
      }
    } catch (error) {
      console.log(" Token verification error:", error);
      return false;
    }
  }
  /**
   * Attempt silent token refresh
   */
  async attemptSilentRefresh() {
    try {
      if (!this.tokenClient) {
        console.log(" No token client available for refresh");
        return false;
      }
      console.log(" Attempting silent token refresh...");
      return new Promise((resolve) => {
        const originalCallback = this.tokenClient.callback;
        let timeoutId;
        this.tokenClient.callback = (response) => {
          this.tokenClient.callback = originalCallback;
          if (timeoutId !== void 0) {
            clearTimeout(timeoutId);
          }
          if (response.error) {
            console.log(" Silent refresh failed:", response.error);
            if (response.error === "interaction_required" || response.error === "login_required") {
              console.log(" Silent refresh requires user interaction, skipping");
            }
            resolve(false);
          } else {
            console.log(" Silent refresh successful");
            this.handleAuthSuccess(response);
            resolve(true);
          }
        };
        try {
          this.tokenClient.requestAccessToken({ prompt: "none" });
          timeoutId = setTimeout(() => {
            this.tokenClient.callback = originalCallback;
            console.log(" Silent refresh timeout");
            resolve(false);
          }, 5e3);
        } catch (error) {
          this.tokenClient.callback = originalCallback;
          if (timeoutId !== void 0) {
            clearTimeout(timeoutId);
          }
          console.log(" Silent refresh request failed:", error);
          resolve(false);
        }
      });
    } catch (error) {
      console.error(" Silent refresh error:", error);
      return false;
    }
  }
  /**
   * Get current access token with automatic refresh if needed
   */
  async getAccessToken() {
    try {
      let currentToken = this.gapi?.client?.getToken()?.access_token;
      if (!currentToken) {
        console.log(" No current token available, trying silent refresh...");
        const refreshed = await this.attemptSilentRefresh();
        if (!refreshed) {
          return null;
        }
        currentToken = this.gapi?.client?.getToken()?.access_token;
      }
      const savedToken = localStorage.getItem(GOOGLE_TOKEN_KEY);
      if (savedToken) {
        const tokenData = JSON.parse(savedToken);
        const tokenAge = Date.now() - (tokenData.timestamp || 0);
        const isNearExpiry = tokenAge > 90 * 24 * 60 * 60 * 1e3;
        if (isNearExpiry) {
          console.log(" Token near expiry, attempting refresh...");
          const refreshSuccess = await this.attemptSilentRefresh();
          if (refreshSuccess) {
            return this.gapi?.client?.getToken()?.access_token || null;
          } else {
            console.log(" Token refresh failed, keeping saved login state");
            return null;
          }
        }
      }
      return currentToken;
    } catch (error) {
      console.error(" Error getting access token:", error);
      return null;
    }
  }
  /**
   * Check if user is signed in with token validation
   */
  async isSignedIn() {
    if (!isGoogleSignedIn.value) {
      return false;
    }
    const token = await this.getAccessToken();
    return token !== null || isGoogleSignedIn.value;
  }
  /**
   * Synchronous check for signed in state (for compatibility)
   */
  isSignedInSync() {
    return isGoogleSignedIn.value;
  }
  /**
   * Get current authentication error
   */
  getAuthError() {
    return authError.value;
  }
  /**
   * Auto refresh helpers
   */
  startAutoRefresh() {
    this.stopAutoRefresh();
    this.autoRefreshTimer = window.setInterval(async () => {
      if (!isGoogleSignedIn.value) return;
      const needsRefresh = await this.shouldRefreshToken();
      if (needsRefresh) {
        console.log(" Auto-refresh timer triggered - token needs refresh");
        await this.attemptSilentRefresh();
      } else {
        console.log(" Auto-refresh timer checked - token still valid");
      }
    }, 90 * 24 * 60 * 60 * 1e3);
    console.log(" Auto-refresh timer started");
  }
  stopAutoRefresh() {
    if (this.autoRefreshTimer) {
      clearInterval(this.autoRefreshTimer);
      this.autoRefreshTimer = null;
      console.log(" Auto-refresh timer stopped");
    }
  }
  visibilityHandler = async () => {
    if (document.visibilityState === "visible" && isGoogleSignedIn.value) {
      const needsRefresh = await this.shouldRefreshToken();
      if (needsRefresh) {
        console.log(" Page visible, token needs refresh");
        await this.attemptSilentRefresh();
      } else {
        console.log(" Page visible, token still valid");
      }
    }
  };
  onlineHandler = async () => {
    if (navigator.onLine && isGoogleSignedIn.value) {
      const needsRefresh = await this.shouldRefreshToken();
      if (needsRefresh) {
        console.log(" Back online, token needs refresh");
        await this.attemptSilentRefresh();
      } else {
        console.log(" Back online, token still valid");
      }
    }
  };
  attachLifecycleListeners() {
    document.addEventListener("visibilitychange", this.visibilityHandler);
    window.addEventListener("online", this.onlineHandler);
    console.log(" Lifecycle listeners attached");
  }
  detachLifecycleListeners() {
    document.removeEventListener("visibilitychange", this.visibilityHandler);
    window.removeEventListener("online", this.onlineHandler);
    console.log(" Lifecycle listeners detached");
  }
  /**
   * Fetch user email from Google API
   */
  async fetchUserEmail() {
    try {
      if (!this.gapi?.client) {
        console.log(" No GAPI client available for fetching user email");
        return null;
      }
      const response = await this.gapi.client.request({
        path: "https://www.googleapis.com/oauth2/v2/userinfo"
      });
      if (response.status === 200 && response.result?.email) {
        console.log(" User email fetched successfully");
        return response.result.email;
      } else {
        console.log(" Failed to fetch user email from API response");
        return null;
      }
    } catch (error) {
      console.error(" Error fetching user email:", error);
      return null;
    }
  }
  /**
   * Get current user email
   */
  async getUserEmail() {
    return googleUserEmail.value;
  }
  /**
   * Check if token actually needs refreshing
   */
  async shouldRefreshToken() {
    try {
      const currentToken = this.gapi?.client?.getToken()?.access_token;
      if (!currentToken) {
        console.log(" No current token, refresh needed");
        return true;
      }
      const savedToken = localStorage.getItem(GOOGLE_TOKEN_KEY);
      if (!savedToken) {
        console.log(" No saved token data, refresh needed");
        return true;
      }
      const tokenData = JSON.parse(savedToken);
      const tokenAge = Date.now() - (tokenData.timestamp || 0);
      const isNearExpiry = tokenAge > 90 * 24 * 60 * 60 * 1e3;
      if (isNearExpiry) {
        console.log(" Token is near expiry, refresh needed");
        return true;
      }
      console.log(" Token is still valid, no refresh needed");
      return false;
    } catch (error) {
      console.error(" Error checking token refresh need:", error);
      return false;
    }
  }
}
const useGoogleDriveAuth = () => {
  const authService = GoogleDriveAuth.getInstance();
  return {
    // Reactive states
    isGoogleApiLoaded: computed(() => isGoogleApiLoaded.value),
    isGoogleSignedIn: computed(() => isGoogleSignedIn.value),
    googleUser: computed(() => googleUser.value),
    googleUserEmail: computed(() => googleUserEmail.value),
    authError: computed(() => authError.value),
    // Methods
    initialize: () => authService.initialize(),
    signIn: () => authService.signIn(),
    signOut: () => authService.signOut(),
    isSignedIn: () => authService.isSignedIn(),
    isSignedInSync: () => authService.isSignedInSync(),
    getAccessToken: () => authService.getAccessToken(),
    getUserEmail: () => authService.getUserEmail()
  };
};
const googleDriveAuth = GoogleDriveAuth.getInstance();

class GoogleDriveApi {
  static instance;
  VOCABULARY_FOLDER_NAME = "Vocabulary Backup";
  BACKUP_FILE_NAME = "vocabulary-auto-backup.json";
  vocabularyFolderId = null;
  constructor() {
  }
  static getInstance() {
    if (!GoogleDriveApi.instance) {
      GoogleDriveApi.instance = new GoogleDriveApi();
    }
    return GoogleDriveApi.instance;
  }
  /**
   * Ensure user is authenticated before making API calls
   */
  async ensureAuthenticated() {
    if (!await googleDriveAuth.isSignedIn()) {
      console.log(" User not signed in, attempting to sign in...");
      return await googleDriveAuth.signIn();
    }
    return true;
  }
  /**
   * Handle 401 errors by refreshing token and retrying
   */
  async handleAuthError(operation) {
    try {
      const response = await operation();
      if (response.status === 401) {
        console.log(" Received 401 error, attempting token refresh...");
        const newToken = await googleDriveAuth.getAccessToken();
        if (!newToken) {
          throw new Error("Unable to refresh authentication token");
        }
        console.log(" Retrying operation with refreshed token...");
        const retryResponse = await operation();
        if (retryResponse.status === 401) {
          throw new Error("Authentication failed even after token refresh");
        }
        return retryResponse;
      }
      return response;
    } catch (error) {
      console.error(" Auth error handling failed:", error);
      throw error;
    }
  }
  /**
   * Find or create the vocabulary backup folder
   */
  async findOrCreateVocabularyFolder() {
    try {
      if (!await this.ensureAuthenticated()) {
        throw new Error("Authentication failed");
      }
      console.log(" Finding or creating vocabulary backup folder...");
      const response = await window.gapi.client.drive.files.list({
        q: `name='${this.VOCABULARY_FOLDER_NAME}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        spaces: "drive",
        fields: "files(id, name)"
      });
      if (response.result.files && response.result.files.length > 0) {
        this.vocabularyFolderId = response.result.files[0].id;
        console.log(" Found existing vocabulary folder:", this.vocabularyFolderId);
        return this.vocabularyFolderId;
      }
      const createResponse = await window.gapi.client.drive.files.create({
        resource: {
          name: this.VOCABULARY_FOLDER_NAME,
          mimeType: "application/vnd.google-apps.folder",
          description: "Automatically created folder for vocabulary backup files"
        },
        fields: "id"
      });
      this.vocabularyFolderId = createResponse.result.id;
      console.log(" Created new vocabulary folder:", this.vocabularyFolderId);
      return this.vocabularyFolderId;
    } catch (error) {
      console.error(" Failed to find or create vocabulary folder:", error);
      return null;
    }
  }
  /**
   * Upload vocabulary data to Google Drive
   */
  async uploadVocabularyData(data) {
    let dataSizeKB = 0;
    try {
      if (!await this.ensureAuthenticated()) {
        throw new Error("Authentication failed");
      }
      console.log(" Starting vocabulary data upload to Google Drive...");
      const folderId = await this.findOrCreateVocabularyFolder();
      if (!folderId) {
        throw new Error("Failed to create vocabulary folder");
      }
      const existingFile = await this.findVocabularyBackupFile();
      const jsonData = JSON.stringify(data, null, 2);
      dataSizeKB = Math.round(jsonData.length / 1024);
      console.log(` Preparing upload: ${dataSizeKB}KB of vocabulary data`);
      const blob = new Blob([jsonData], { type: "application/json" });
      let response;
      if (existingFile) {
        console.log(" Updating existing backup file:", existingFile.id);
        const createUpdateRequest = async () => {
          const accessToken = await googleDriveAuth.getAccessToken();
          if (!accessToken) {
            throw new Error("No access token available");
          }
          console.log(` Starting update request for ${dataSizeKB}KB data...`);
          const form = new FormData();
          form.append("metadata", new Blob([JSON.stringify({
            name: this.BACKUP_FILE_NAME,
            description: `Vocabulary backup - Updated: ${(/* @__PURE__ */ new Date()).toISOString()}`
          })], { type: "application/json" }));
          form.append("file", blob);
          const controller = new AbortController();
          const timeoutMs = Math.max(6e4, Math.min(6e5, 6e4 + dataSizeKB * 60));
          const timeoutMinutes = Math.round(timeoutMs / 6e4);
          console.log(` Setting ${timeoutMinutes} minute timeout for ${dataSizeKB}KB file`);
          const timeoutId = setTimeout(() => {
            console.log(` Upload timeout after ${timeoutMinutes} minutes, aborting request...`);
            controller.abort();
          }, timeoutMs);
          try {
            const response2 = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${existingFile.id}?uploadType=multipart&fields=id,name,modifiedTime,size`, {
              method: "PATCH",
              headers: {
                "Authorization": `Bearer ${accessToken}`
              },
              body: form,
              signal: controller.signal
            });
            clearTimeout(timeoutId);
            console.log(` Update request completed with status: ${response2.status}`);
            return response2;
          } catch (error) {
            clearTimeout(timeoutId);
            if (error.name === "AbortError") {
              throw new Error(`Upload timeout after ${timeoutMinutes} minutes for ${dataSizeKB}KB file`);
            }
            throw error;
          }
        };
        response = await this.handleAuthError(createUpdateRequest);
      } else {
        console.log(" Creating new backup file...");
        const createNewRequest = async () => {
          const accessToken = await googleDriveAuth.getAccessToken();
          if (!accessToken) {
            throw new Error("No access token available");
          }
          console.log(` Starting new file creation for ${dataSizeKB}KB data...`);
          const form = new FormData();
          form.append("metadata", new Blob([JSON.stringify({
            name: this.BACKUP_FILE_NAME,
            parents: [folderId],
            description: `Vocabulary backup - Created: ${(/* @__PURE__ */ new Date()).toISOString()}`
          })], { type: "application/json" }));
          form.append("file", blob);
          const controller = new AbortController();
          const timeoutMs = Math.max(6e4, Math.min(6e5, 6e4 + dataSizeKB * 60));
          const timeoutMinutes = Math.round(timeoutMs / 6e4);
          console.log(` Setting ${timeoutMinutes} minute timeout for ${dataSizeKB}KB file`);
          const timeoutId = setTimeout(() => {
            console.log(` Upload timeout after ${timeoutMinutes} minutes, aborting request...`);
            controller.abort();
          }, timeoutMs);
          try {
            const response2 = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name,modifiedTime,size", {
              method: "POST",
              headers: {
                "Authorization": `Bearer ${accessToken}`
              },
              body: form,
              signal: controller.signal
            });
            clearTimeout(timeoutId);
            console.log(` New file creation completed with status: ${response2.status}`);
            return response2;
          } catch (error) {
            clearTimeout(timeoutId);
            if (error.name === "AbortError") {
              throw new Error(`Upload timeout after ${timeoutMinutes} minutes for ${dataSizeKB}KB file`);
            }
            throw error;
          }
        };
        response = await this.handleAuthError(createNewRequest);
      }
      console.log(` Checking response status: ${response.status}`);
      if (!response.ok) {
        const errorText = await response.text().catch(() => "Unknown error");
        console.error(` HTTP error ${response.status} for ${dataSizeKB}KB upload:`, errorText);
        if (response.status === 401) {
          throw new Error("Authentication failed - please sign in to Google Drive again");
        } else if (response.status === 403) {
          throw new Error("Permission denied - please check Google Drive permissions");
        } else if (response.status === 413) {
          throw new Error(`File too large (${dataSizeKB}KB) - Google Drive limit exceeded`);
        } else if (response.status === 429) {
          throw new Error("Rate limit exceeded - please try again later");
        } else {
          throw new Error(`Upload failed with status ${response.status}: ${errorText}`);
        }
      }
      console.log(" Parsing response JSON...");
      const result = await response.json();
      console.log(` Vocabulary data (${dataSizeKB}KB) uploaded successfully:`, {
        fileId: result.id,
        fileName: result.name,
        size: result.size,
        modifiedTime: result.modifiedTime
      });
      return {
        success: true,
        fileId: result.id
      };
    } catch (error) {
      const errorMessage = error.message;
      const sizeInfo = typeof dataSizeKB !== "undefined" ? `${dataSizeKB}KB` : "unknown size";
      console.error(` Failed to upload vocabulary data (${sizeInfo}):`, {
        error: errorMessage,
        stack: error.stack
      });
      return {
        success: false,
        error: errorMessage
      };
    }
  }
  /**
   * Download vocabulary data from Google Drive
   */
  async downloadVocabularyData() {
    try {
      if (!await this.ensureAuthenticated()) {
        throw new Error("Authentication failed");
      }
      console.log(" Starting vocabulary data download from Google Drive...");
      const backupFile = await this.findVocabularyBackupFile();
      if (!backupFile) {
        return {
          success: false,
          error: "No vocabulary backup file found on Google Drive"
        };
      }
      console.log(" Found backup file:", backupFile.name, backupFile.id);
      const response = await window.gapi.client.drive.files.get({
        fileId: backupFile.id,
        alt: "media"
      });
      if (!response.body) {
        throw new Error("Empty response body");
      }
      const data = JSON.parse(response.body);
      console.log(" Vocabulary data downloaded successfully");
      return {
        success: true,
        data,
        lastModified: backupFile.modifiedTime
      };
    } catch (error) {
      console.error(" Failed to download vocabulary data:", error);
      return {
        success: false,
        error: error.message
      };
    }
  }
  /**
   * Find the vocabulary backup file in the vocabulary folder
   */
  async findVocabularyBackupFile() {
    try {
      const folderId = await this.findOrCreateVocabularyFolder();
      if (!folderId) return null;
      const response = await window.gapi.client.drive.files.list({
        q: `name='${this.BACKUP_FILE_NAME}' and parents in '${folderId}' and trashed=false`,
        spaces: "drive",
        fields: "files(id, name, modifiedTime, size, mimeType)"
      });
      if (response.result.files && response.result.files.length > 0) {
        return response.result.files[0];
      }
      return null;
    } catch (error) {
      console.error(" Failed to find vocabulary backup file:", error);
      return null;
    }
  }
  /**
   * Get vocabulary backup file info
   */
  async getVocabularyBackupInfo() {
    try {
      if (!await this.ensureAuthenticated()) {
        throw new Error("Authentication failed");
      }
      const backupFile = await this.findVocabularyBackupFile();
      return {
        exists: !!backupFile,
        file: backupFile || void 0
      };
    } catch (error) {
      return {
        exists: false,
        error: error.message
      };
    }
  }
  /**
   * Delete vocabulary backup file
   */
  async deleteVocabularyBackup() {
    try {
      if (!await this.ensureAuthenticated()) {
        throw new Error("Authentication failed");
      }
      const backupFile = await this.findVocabularyBackupFile();
      if (!backupFile) {
        return { success: true };
      }
      await window.gapi.client.drive.files.delete({
        fileId: backupFile.id
      });
      console.log(" Vocabulary backup file deleted successfully");
      return { success: true };
    } catch (error) {
      console.error(" Failed to delete vocabulary backup:", error);
      return {
        success: false,
        error: error.message
      };
    }
  }
  /**
   * Check if there are any conflicts between local and remote data
   */
  async checkForConflicts(localData) {
    try {
      const downloadResult = await this.downloadVocabularyData();
      if (!downloadResult.success) {
        return {
          hasConflicts: false,
          error: downloadResult.error
        };
      }
      const localModified = localData.exportDate || (/* @__PURE__ */ new Date()).toISOString();
      const remoteModified = downloadResult.lastModified;
      const hasConflicts = new Date(remoteModified) > new Date(localModified);
      return {
        hasConflicts,
        localModified,
        remoteModified,
        remoteData: downloadResult.data
      };
    } catch (error) {
      return {
        hasConflicts: false,
        error: error.message
      };
    }
  }
}
const useGoogleDriveApi = () => {
  const driveApi = GoogleDriveApi.getInstance();
  return {
    uploadVocabularyData: (data) => driveApi.uploadVocabularyData(data),
    downloadVocabularyData: () => driveApi.downloadVocabularyData(),
    getVocabularyBackupInfo: () => driveApi.getVocabularyBackupInfo(),
    deleteVocabularyBackup: () => driveApi.deleteVocabularyBackup(),
    checkForConflicts: (localData) => driveApi.checkForConflicts(localData)
  };
};
GoogleDriveApi.getInstance();

const ConfirmToast$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ConfirmToast),true              ?void 0:void 0));
function useVocabularySaving() {
  const { t } = useI18n();
  const vocabularyStore = useVocabularyStore();
  const toast = useToast();
  const googleAuth = useGoogleDriveAuth();
  const googleDriveApi = useGoogleDriveApi();
  const autoSaveEnabled = ref(true);
  const isSaving = ref(false);
  const lastSaveTime = ref("");
  const saveStatus = ref("idle");
  const autoSaveFileHandle = ref(null);
  const hasAutoSaveFile = ref(false);
  const hasGoogleDriveFile = ref(false);
  const storageType = ref("local");
  const autoSaveFileName = "vocabulary-auto-backup.json";
  let autoSaveTimer = null;
  let debounceTimer = null;
  const autoSaveFilePath = ref("");
  const DB_NAME = "vocabulary-file-handles";
  const DB_VERSION = 1;
  const STORE_NAME = "file-handles";
  const FILE_HANDLE_KEY = "auto-save-file-handle";
  const openDB = () => {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          db.createObjectStore(STORE_NAME);
        }
      };
    });
  };
  const saveFileHandleToIDB = async (fileHandle) => {
    try {
      const db = await openDB();
      const transaction = db.transaction([STORE_NAME], "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      await new Promise((resolve, reject) => {
        const request = store.put(fileHandle, FILE_HANDLE_KEY);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve();
      });
      console.log("File handle saved to IndexedDB");
    } catch (error) {
      console.error("Error saving file handle to IndexedDB:", error);
    }
  };
  const loadFileHandleFromIDB = async () => {
    try {
      const db = await openDB();
      const transaction = db.transaction([STORE_NAME], "readonly");
      const store = transaction.objectStore(STORE_NAME);
      return new Promise((resolve, reject) => {
        const request = store.get(FILE_HANDLE_KEY);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result || null);
      });
    } catch (error) {
      console.error("Error loading file handle from IndexedDB:", error);
      return null;
    }
  };
  const clearFileHandleFromIDB = async () => {
    try {
      const db = await openDB();
      const transaction = db.transaction([STORE_NAME], "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      await new Promise((resolve, reject) => {
        const request = store.delete(FILE_HANDLE_KEY);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve();
      });
      console.log("File handle cleared from IndexedDB");
    } catch (error) {
      console.error("Error clearing file handle from IndexedDB:", error);
    }
  };
  const getStoredValue = (key, defaultValue) => {
    try {
      const stored = localStorage.getItem(key);
      return stored !== null ? JSON.parse(stored) : defaultValue;
    } catch {
      return defaultValue;
    }
  };
  const setStoredValue = (key, value) => {
    localStorage.setItem(key, JSON.stringify(value));
  };
  autoSaveEnabled.value = getStoredValue("vocabulary-auto-save-enabled", true);
  hasAutoSaveFile.value = getStoredValue("vocabulary-has-auto-save-file", false);
  hasGoogleDriveFile.value = getStoredValue("vocabulary-has-google-drive-file", false);
  storageType.value = getStoredValue("vocabulary-storage-type", "local");
  lastSaveTime.value = getStoredValue("vocabulary-last-save-time", "");
  const initializeAutoSave = async () => {
    console.log(" Initializing auto-save, hasAutoSaveFile:", hasAutoSaveFile.value);
    if (hasAutoSaveFile.value && "showSaveFilePicker" in window) {
      try {
        console.log(" Attempting to restore file handle from IndexedDB...");
        const savedFileHandle = await loadFileHandleFromIDB();
        if (savedFileHandle) {
          console.log(" Found saved file handle in IndexedDB");
          try {
            const opts = { mode: "readwrite" };
            const permission = await savedFileHandle.queryPermission(opts);
            console.log(" File handle permission:", permission);
            if (permission === "granted" || permission === "prompt") {
              autoSaveFileHandle.value = savedFileHandle;
              console.log(" File handle restored to autoSaveFileHandle");
              try {
                const fileProps = await savedFileHandle.getFile();
                autoSaveFilePath.value = fileProps.name;
                console.log(" File handle restored successfully:", fileProps.name);
                if (permission === "prompt") {
                  console.log(" Requesting permission for file handle...");
                  await savedFileHandle.requestPermission(opts);
                }
              } catch (e) {
                console.log(" Could not get file properties, but handle seems valid:", e);
              }
            } else {
              console.log(" File handle permission denied, clearing stored handle");
              await clearFileHandleFromIDB();
              hasAutoSaveFile.value = false;
              setStoredValue("vocabulary-has-auto-save-file", false);
            }
          } catch (error) {
            console.log(" Saved file handle is invalid, clearing:", error);
            await clearFileHandleFromIDB();
            hasAutoSaveFile.value = false;
            setStoredValue("vocabulary-has-auto-save-file", false);
          }
        } else {
          console.log(" No file handle found in IndexedDB");
          hasAutoSaveFile.value = false;
          setStoredValue("vocabulary-has-auto-save-file", false);
        }
      } catch (error) {
        console.error(" Error initializing auto-save:", error);
        hasAutoSaveFile.value = false;
        setStoredValue("vocabulary-has-auto-save-file", false);
      }
    } else {
      console.log(" Auto-save not enabled or File System API not supported");
    }
  };
  const saveToFileSystem = async (data) => {
    try {
      const fileHandle = await window.showSaveFilePicker({
        suggestedName: `vocabulary-backup-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`,
        types: [{
          description: "JSON files",
          accept: { "application/json": [".json"] }
        }]
      });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(data, null, 2));
      await writable.close();
      autoSaveFileHandle.value = fileHandle;
      hasAutoSaveFile.value = true;
      setStoredValue("vocabulary-has-auto-save-file", true);
      await saveFileHandleToIDB(fileHandle);
    } catch (error) {
      if (error.name !== "AbortError") {
        await downloadJsonFile(data);
      }
    }
  };
  const downloadJsonFile = async (data) => {
    const jsonString = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonString], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `vocabulary-backup-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };
  const getVocabularyData = () => {
    const getGroupTopics = () => {
      try {
        const stored = localStorage.getItem("vocabulary-group-topics");
        return stored ? JSON.parse(stored) : {};
      } catch (error) {
        return {};
      }
    };
    const getVocabularyNotes = () => {
      try {
        const stored = localStorage.getItem("vocabulary-notes");
        return stored ? JSON.parse(stored) : {};
      } catch (error) {
        return {};
      }
    };
    const getMarkedWords = () => {
      try {
        const stored = localStorage.getItem("vocabulary-marked-words");
        return stored ? JSON.parse(stored) : {};
      } catch (error) {
        return {};
      }
    };
    const getGrammarRules = () => {
      try {
        const stored = localStorage.getItem("grammar-rules");
        return stored ? JSON.parse(stored) : [];
      } catch (error) {
        return [];
      }
    };
    const getPracticeHistory = () => {
      try {
        const stored = localStorage.getItem("flashcard-practice-history");
        return stored ? JSON.parse(stored) : [];
      } catch (error) {
        return [];
      }
    };
    const getCategoryName = (categoryKey) => {
      const customTopics = getCustomTopics();
      const customTopic = customTopics.find((topic) => topic.key === categoryKey);
      if (customTopic) {
        return customTopic.en;
      }
      const builtInCategories = {
        "technology": "Technology",
        "business": "Business",
        "travel": "Travel",
        "food": "Food",
        "health": "Health",
        "education": "Education",
        "sports": "Sports",
        "entertainment": "Entertainment",
        "science": "Science",
        "art": "Art",
        "music": "Music",
        "literature": "Literature",
        "politics": "Politics",
        "environment": "Environment",
        "fashion": "Fashion",
        "finance": "Finance"
      };
      return builtInCategories[categoryKey] || categoryKey.charAt(0).toUpperCase() + categoryKey.slice(1);
    };
    const enhancedVocabularies = vocabularyStore.allVocabularies.value.map((vocab) => ({
      ...vocab,
      categoryName: getCategoryName(vocab.category)
      // Add category name alongside category key
    }));
    return {
      vocabularies: enhancedVocabularies,
      customTopics: vocabularyStore.customTopics.value,
      groupTopics: getGroupTopics(),
      vocabularyNotes: getVocabularyNotes(),
      markedWords: getMarkedWords(),
      grammarRules: getGrammarRules(),
      // Include grammar rules in export
      practiceHistory: getPracticeHistory(),
      // Include practice history in export
      accordionState: JSON.parse(localStorage.getItem("vocabulary-accordion-state") || "{}"),
      useGrouping: JSON.parse(localStorage.getItem("vocabulary-use-grouping") || "false"),
      // Save grouping state
      exportDate: (/* @__PURE__ */ new Date()).toISOString(),
      version: "1.6",
      // Increment version to indicate practice history support
      totalCount: vocabularyStore.totalCount.value
    };
  };
  const manualSave = async () => {
    if (isSaving.value) return;
    isSaving.value = true;
    saveStatus.value = "saving";
    try {
      const vocabularyData = getVocabularyData();
      if ("showSaveFilePicker" in window) {
        await saveToFileSystem(vocabularyData);
      } else {
        await downloadJsonFile(vocabularyData);
      }
      vocabularyStore.saveToLocalStorage();
      const now = (/* @__PURE__ */ new Date()).toLocaleString("vi-VN");
      lastSaveTime.value = now;
      setStoredValue("vocabulary-last-save-time", now);
      saveStatus.value = "success";
      setTimeout(() => {
        if (saveStatus.value === "success") saveStatus.value = "idle";
      }, 2e3);
    } catch (error) {
      saveStatus.value = "error";
      setTimeout(() => {
        if (saveStatus.value === "error") saveStatus.value = "idle";
      }, 3e3);
    } finally {
      isSaving.value = false;
    }
  };
  const performAutoSave = async () => {
    if (!autoSaveEnabled.value) return;
    try {
      saveStatus.value = "saving";
      const vocabularyData = getVocabularyData();
      vocabularyStore.saveToLocalStorage();
      let saveSuccess = false;
      if (storageType.value === "google-drive") {
        saveSuccess = await tryAutoSaveToGoogleDrive(vocabularyData);
      } else if (storageType.value === "local" && hasAutoSaveFile.value) {
        saveSuccess = await tryAutoSaveToFile(vocabularyData);
      } else {
        saveSuccess = true;
      }
      const now = (/* @__PURE__ */ new Date()).toLocaleString("vi-VN");
      lastSaveTime.value = now;
      setStoredValue("vocabulary-last-save-time", now);
      if (saveSuccess) {
        saveStatus.value = "success";
        console.log(" Auto-save completed successfully");
        setTimeout(() => {
          if (saveStatus.value === "success") {
            saveStatus.value = "idle";
          }
        }, 1e3);
      } else {
        saveStatus.value = "error";
        console.error(" Auto-save failed");
        setTimeout(() => {
          if (saveStatus.value === "error") {
            saveStatus.value = "idle";
          }
        }, 2e3);
      }
      return saveSuccess;
    } catch (error) {
      console.error("Auto-save error:", error);
      saveStatus.value = "error";
      setTimeout(() => {
        if (saveStatus.value === "error") {
          saveStatus.value = "idle";
        }
      }, 2e3);
      return false;
    }
  };
  const tryAutoSaveToFile = async (data) => {
    if (!("showSaveFilePicker" in window)) {
      console.log("Browser doesn't support File System Access API");
      return false;
    }
    if (!autoSaveFileHandle.value) {
      console.log("No auto-save file handle available");
      return false;
    }
    try {
      console.log("Attempting to auto-save to file...", autoSaveFilePath.value);
      const opts = { mode: "readwrite" };
      const permission = await autoSaveFileHandle.value.queryPermission(opts);
      if (permission !== "granted") {
        console.log("Requesting permission to write to file...");
        const newPermission = await autoSaveFileHandle.value.requestPermission(opts);
        if (newPermission !== "granted") {
          console.error("Permission to write to file denied");
          toast.error(t("vocabulary.save.errors.permissionDenied", "Permission denied"));
          return false;
        }
      }
      console.log("Creating writable stream...");
      const writable = await autoSaveFileHandle.value.createWritable();
      const jsonString = JSON.stringify(data, null, 2);
      console.log(`Writing ${jsonString.length} characters to file...`);
      await writable.write(jsonString);
      console.log("Closing writable stream...");
      await writable.close();
      console.log("Auto-save to file completed successfully:", autoSaveFilePath.value);
      const now = (/* @__PURE__ */ new Date()).toLocaleString("vi-VN");
      lastSaveTime.value = now;
      setStoredValue("vocabulary-last-save-time", now);
      return true;
    } catch (error) {
      console.error("Error auto-saving to file:", error);
      if (error instanceof DOMException && error.name === "NotAllowedError") {
        toast.error(t("vocabulary.save.errors.permissionDenied", "Permission denied"));
      } else {
        toast.error(t("vocabulary.save.errors.autoSaveFileFailed", "Auto save file failed"));
      }
      if (!(error instanceof DOMException && error.name === "NotAllowedError")) {
        autoSaveFileHandle.value = null;
        hasAutoSaveFile.value = false;
        setStoredValue("vocabulary-has-auto-save-file", false);
        await clearFileHandleFromIDB();
      }
      return false;
    }
  };
  const debounceAutoSave = () => {
    if (!autoSaveEnabled.value) {
      console.log("Auto-save is disabled, skipping debounce");
      return;
    }
    console.log("Setting up debounce auto-save timer...");
    if (debounceTimer) {
      console.log("Clearing existing debounce timer");
      clearTimeout(debounceTimer);
      debounceTimer = null;
    }
    console.log("Creating new debounce timer");
    debounceTimer = setTimeout(async () => {
      console.log("Debounce timer triggered, performing auto-save...");
      if (storageType.value === "local" && !hasAutoSaveFile.value) {
        console.log("No auto-save file selected, saving to localStorage only");
        vocabularyStore.saveToLocalStorage();
        return;
      }
      if (storageType.value === "google-drive") {
        const isSignedIn = await googleAuth.isSignedIn();
        if (!isSignedIn) {
          console.log("Google Drive selected but not signed in or token invalid, saving to localStorage only");
          vocabularyStore.saveToLocalStorage();
          return;
        }
      }
      const result = await performAutoSave();
      console.log("Auto-save result:", result ? "Success" : "Failed");
      if (!result) {
        const retryMessage = storageType.value === "google-drive" ? t("vocabulary.save.googleDriveRetry", "Google Drive save failed. Check connection.") || "Google Drive save failed. Check connection." : t("vocabulary.save.autoSaveRetry", "Auto save failed. Click to select a new file.") || "Auto save failed. Click to select a new file.";
        toast.info(retryMessage, {
          timeout: 5e3,
          onClick: () => {
            if (storageType.value === "local") {
              setupAutoSaveFile();
            }
          }
        });
      }
    }, 500);
  };
  const scheduleAutoSave = () => {
    if (autoSaveTimer) clearTimeout(autoSaveTimer);
    autoSaveTimer = window.setTimeout(() => {
      if (autoSaveEnabled.value) {
        performAutoSave();
        scheduleAutoSave();
      }
    }, 1e4);
  };
  const setupAutoSaveFile = async () => {
    if ("showSaveFilePicker" in window) {
      try {
        console.log("Setting up auto-save file...");
        const fileHandle = await window.showSaveFilePicker({
          suggestedName: autoSaveFileName,
          types: [{ description: "JSON files", accept: { "application/json": [".json"] } }]
        });
        autoSaveFileHandle.value = fileHandle;
        await saveFileHandleToIDB(fileHandle);
        try {
          const fileProps = await fileHandle.getFile();
          autoSaveFilePath.value = fileProps.name;
          console.log("Selected auto-save file:", fileProps.name);
        } catch (e) {
          console.log("Could not get file properties:", e);
        }
        hasAutoSaveFile.value = true;
        setStoredValue("vocabulary-has-auto-save-file", true);
        const vocabularyData = getVocabularyData();
        console.log("Testing auto-save with file handle:", autoSaveFileHandle.value);
        const saveResult = await tryAutoSaveToFile(vocabularyData);
        if (saveResult) {
          toast.success(t("vocabulary.save.autoSaveFileSetup", "Auto save file setup"));
          console.log("Auto-save file setup successful!");
        } else {
          toast.error(t("vocabulary.save.errors.autoSaveFileFailed", "Auto save file failed"));
          console.error("Auto-save file setup failed!");
        }
      } catch (error) {
        if (error.name !== "AbortError") {
          console.error("Error setting up auto-save file:", error);
          toast.error(t("vocabulary.save.errors.fileSelectError", { error: error.message }) || `File selection error: ${error.message}`);
        }
      }
    } else {
      toast.error(t("vocabulary.save.errors.browserNotSupported", "Browser not supported"));
    }
  };
  const handleFileImport = (file) => {
    if (!file || !file.name.endsWith(".json")) {
      toast.error(t("vocabulary.save.errors.invalidFile", "Invalid file"));
      return;
    }
    const toastId = toast(
      {
        component: ConfirmToast$1,
        props: {
          message: t("vocabulary.save.import.confirmMessage", { filename: file.name }, `Import ${file.name}? This will replace all current vocabulary.`),
          confirmText: t("common.confirm", "Confirm"),
          cancelText: t("common.cancel", "Cancel"),
          onConfirm: () => {
            const reader = new FileReader();
            reader.onload = (e) => {
              isSaving.value = true;
              try {
                const text = e.target?.result;
                const data = JSON.parse(text);
                if (!data.vocabularies || !Array.isArray(data.vocabularies)) {
                  toast.error(t("vocabulary.save.errors.invalidFile", "Invalid file"));
                  isSaving.value = false;
                  return;
                }
                vocabularyStore.importVocabularies(data.vocabularies);
                if (data.customTopics && Array.isArray(data.customTopics)) {
                  localStorage.setItem("customTopics", JSON.stringify(data.customTopics));
                  vocabularyStore.refreshCustomTopics();
                  console.log("Imported custom topics:", data.customTopics);
                }
                if (data.topics && Array.isArray(data.topics)) {
                  localStorage.setItem("customTopics", JSON.stringify(data.topics));
                  vocabularyStore.refreshCustomTopics();
                  console.log("Imported legacy topics:", data.topics);
                }
                if (data.groupTopics && typeof data.groupTopics === "object") {
                  localStorage.setItem("vocabulary-group-topics", JSON.stringify(data.groupTopics));
                  console.log("Imported group topics:", data.groupTopics);
                }
                if (data.accordionState && typeof data.accordionState === "object") {
                  localStorage.setItem("vocabulary-accordion-state", JSON.stringify(data.accordionState));
                  console.log("Imported accordion state:", data.accordionState);
                }
                if (typeof data.useGrouping === "boolean") {
                  localStorage.setItem("vocabulary-use-grouping", JSON.stringify(data.useGrouping));
                  console.log("Imported grouping state:", data.useGrouping);
                }
                if (data.vocabularyNotes && typeof data.vocabularyNotes === "object") {
                  localStorage.setItem("vocabulary-notes", JSON.stringify(data.vocabularyNotes));
                  console.log("Imported vocabulary notes:", data.vocabularyNotes);
                }
                if (data.markedWords && typeof data.markedWords === "object") {
                  localStorage.setItem("vocabulary-marked-words", JSON.stringify(data.markedWords));
                  console.log("Imported marked words:", data.markedWords);
                }
                if (data.grammarRules && Array.isArray(data.grammarRules)) {
                  localStorage.setItem("grammar-rules", JSON.stringify(data.grammarRules));
                  console.log("Imported grammar rules:", data.grammarRules);
                }
                if (data.practiceHistory && Array.isArray(data.practiceHistory)) {
                  localStorage.setItem("flashcard-practice-history", JSON.stringify(data.practiceHistory));
                  console.log("Imported practice history:", data.practiceHistory);
                }
                isSaving.value = false;
                let importMessage = t("vocabulary.save.import.successMessage", { count: data.vocabularies.length }, `Successfully imported ${data.vocabularies.length} vocabulary words`);
                if (data.customTopics?.length > 0) {
                  importMessage += ` + ${data.customTopics.length} custom categories`;
                }
                if (data.groupTopics && Object.keys(data.groupTopics).length > 0) {
                  importMessage += ` + ${Object.keys(data.groupTopics).length} group topics`;
                }
                if (typeof data.useGrouping === "boolean") {
                  importMessage += ` + grouping preference`;
                }
                if (data.vocabularyNotes && Object.keys(data.vocabularyNotes).length > 0) {
                  importMessage += ` + ${Object.keys(data.vocabularyNotes).length} vocabulary notes`;
                }
                if (data.markedWords && Object.keys(data.markedWords).length > 0) {
                  let totalMarkedWords = 0;
                  Object.values(data.markedWords).forEach((words) => {
                    if (Array.isArray(words)) {
                      totalMarkedWords += words.length;
                    }
                  });
                  importMessage += ` + ${totalMarkedWords} marked words`;
                }
                if (data.grammarRules && data.grammarRules.length > 0) {
                  importMessage += ` + ${data.grammarRules.length} grammar rules`;
                }
                if (data.practiceHistory && data.practiceHistory.length > 0) {
                  importMessage += ` + ${data.practiceHistory.length} practice sessions`;
                }
                toast.success(importMessage);
                window.dispatchEvent(new CustomEvent("vocabularyImportComplete", {
                  detail: { useGrouping: data.useGrouping }
                }));
                if (autoSaveEnabled.value) {
                  debounceAutoSave();
                }
              } catch (error) {
                isSaving.value = false;
                console.error(t("vocabulary.save.errors.invalidFile"), error);
                toast.error(t("vocabulary.save.errors.invalidFile", "Invalid file"));
              }
            };
            reader.onerror = () => {
              isSaving.value = false;
              console.error("Error reading file");
              toast.error(t("vocabulary.save.errors.fileReadError", { error: reader.error?.message || "Unknown error" }) || `Error reading file: ${reader.error?.message || "Unknown error"}`);
            };
            reader.readAsText(file);
            toast.dismiss(toastId);
          },
          onCancel: () => {
            isSaving.value = false;
            toast.dismiss(toastId);
          }
        }
      },
      {
        position: POSITION.TOP_CENTER,
        timeout: false,
        closeButton: false,
        draggable: false,
        icon: false
      }
    );
  };
  const tryAutoSaveToGoogleDrive = async (data) => {
    try {
      const isSignedIn = await googleAuth.isSignedIn();
      if (!isSignedIn) {
        console.log(" Not signed in to Google Drive or token invalid");
        return false;
      }
      console.log(" Attempting to auto-save to Google Drive...");
      let lastError = null;
      const maxAttempts = 2;
      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          console.log(` Google Drive upload attempt ${attempt}/${maxAttempts}...`);
          const result = await googleDriveApi.uploadVocabularyData(data);
          if (result.success) {
            console.log(` Auto-save to Google Drive completed successfully (attempt ${attempt})`);
            hasGoogleDriveFile.value = true;
            setStoredValue("vocabulary-has-google-drive-file", true);
            return true;
          } else {
            lastError = result.error;
            console.error(` Google Drive save failed (attempt ${attempt}):`, result.error);
            if (result.error?.includes("timeout")) {
              console.log(" Upload timeout detected, stopping retries to avoid excessive wait");
              break;
            }
            if (result.error?.includes("401") || result.error?.includes("unauthorized")) {
              console.log(" Auth error detected, refreshing token...");
              const token = await googleAuth.getAccessToken();
              if (!token) {
                console.log(" Token refresh failed, stopping retries");
                break;
              }
            }
            if (attempt < maxAttempts) {
              console.log(` Waiting ${attempt * 2}s before retry...`);
              await new Promise((resolve) => setTimeout(resolve, 2e3 * attempt));
            }
          }
        } catch (apiError) {
          lastError = apiError;
          const errorMsg2 = apiError?.message || String(apiError);
          console.error(` Google Drive API error (attempt ${attempt}):`, errorMsg2);
          if (errorMsg2.includes("timeout")) {
            console.log(" API timeout detected, stopping retries");
            break;
          }
          if (attempt < maxAttempts) {
            console.log(` Waiting ${attempt * 2}s before retry...`);
            await new Promise((resolve) => setTimeout(resolve, 2e3 * attempt));
          }
        }
      }
      const errorMsg = lastError?.message || String(lastError);
      console.error(" All Google Drive auto-save attempts failed:", errorMsg);
      if (errorMsg?.includes("timeout")) {
        const dataSize = Math.round(JSON.stringify(data).length / 1024);
        console.warn(` Auto-save failed due to timeout for ${dataSize}KB file. Consider reducing vocabulary size or checking internet connection.`);
      }
      return false;
    } catch (error) {
      console.error(" Error saving to Google Drive:", error);
      return false;
    }
  };
  const setupGoogleDrive = async () => {
    try {
      console.log("Setting up Google Drive auto-save...");
      const isSignedIn = await googleAuth.isSignedIn();
      if (!isSignedIn) {
        const signInResult = await googleAuth.signIn();
        if (!signInResult) {
          toast.error(t("vocabulary.save.errors.googleSignInFailed", "Google sign-in failed") || "Google sign-in failed");
          return false;
        }
      }
      const vocabularyData = getVocabularyData();
      let lastError = null;
      for (let attempt = 1; attempt <= 2; attempt++) {
        try {
          const result = await googleDriveApi.uploadVocabularyData(vocabularyData);
          if (result.success) {
            hasGoogleDriveFile.value = true;
            setStoredValue("vocabulary-has-google-drive-file", true);
            toast.success(t("vocabulary.save.googleDriveSetup", "Google Drive setup successful") || "Google Drive setup successful");
            return true;
          } else {
            lastError = result.error;
            console.error(` Google Drive setup test failed (attempt ${attempt}):`, result.error);
            if (attempt < 2) {
              await new Promise((resolve) => setTimeout(resolve, 1e3));
            }
          }
        } catch (apiError) {
          lastError = apiError;
          console.error(` Google Drive setup API error (attempt ${attempt}):`, apiError);
          if (attempt < 2) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          }
        }
      }
      toast.error(t("vocabulary.save.errors.googleDriveSetupFailed", "Google Drive setup failed") || `Google Drive setup failed: ${lastError}`);
      return false;
    } catch (error) {
      console.error("Error setting up Google Drive:", error);
      toast.error(t("vocabulary.save.errors.googleDriveSetupFailed", "Google Drive setup failed") || "Google Drive setup failed");
      return false;
    }
  };
  const syncFromGoogleDrive = async () => {
    try {
      const isSignedIn = await googleAuth.isSignedIn();
      if (!isSignedIn) {
        toast.error(t("vocabulary.save.errors.notSignedIn", "Not signed in to Google") || "Not signed in to Google");
        return false;
      }
      console.log("Syncing from Google Drive...");
      let lastError = null;
      for (let attempt = 1; attempt <= 2; attempt++) {
        try {
          const result = await googleDriveApi.downloadVocabularyData();
          if (result.success && result.data) {
            if (result.data.vocabularies && Array.isArray(result.data.vocabularies)) {
              vocabularyStore.importVocabularies(result.data.vocabularies);
              if (result.data.customTopics && Array.isArray(result.data.customTopics)) {
                localStorage.setItem("customTopics", JSON.stringify(result.data.customTopics));
                vocabularyStore.refreshCustomTopics();
              }
              if (result.data.groupTopics && typeof result.data.groupTopics === "object") {
                localStorage.setItem("vocabulary-group-topics", JSON.stringify(result.data.groupTopics));
              }
              if (result.data.grammarRules && Array.isArray(result.data.grammarRules)) {
                localStorage.setItem("grammar-rules", JSON.stringify(result.data.grammarRules));
              }
              if (result.data.practiceHistory && Array.isArray(result.data.practiceHistory)) {
                localStorage.setItem("flashcard-practice-history", JSON.stringify(result.data.practiceHistory));
              }
              toast.success(t("vocabulary.save.syncFromDriveSuccess", "Successfully synced from Google Drive") || "Successfully synced from Google Drive");
              return true;
            }
          } else {
            lastError = result.error;
            console.error(` Google Drive sync failed (attempt ${attempt}):`, result.error);
            if (attempt < 2) {
              await new Promise((resolve) => setTimeout(resolve, 1e3));
            }
          }
        } catch (apiError) {
          lastError = apiError;
          console.error(` Google Drive sync API error (attempt ${attempt}):`, apiError);
          if (attempt < 2) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          }
        }
      }
      toast.error(lastError || t("vocabulary.save.errors.syncFailed", "Sync failed") || "Sync failed");
      return false;
    } catch (error) {
      console.error("Error syncing from Google Drive:", error);
      toast.error(t("vocabulary.save.errors.syncFailed", "Sync failed") || "Sync failed");
      return false;
    }
  };
  const handleGoogleSignIn = async () => {
    try {
      console.log("Initiating Google sign-in...");
      await googleAuth.initialize();
      const result = await googleAuth.signIn();
      if (result) {
        toast.success(t("vocabulary.save.googleSignInSuccess", "Successfully signed in to Google") || "Successfully signed in to Google");
        try {
          const backupInfo = await googleDriveApi.getVocabularyBackupInfo();
          if (backupInfo.exists) {
            hasGoogleDriveFile.value = true;
            setStoredValue("vocabulary-has-google-drive-file", true);
          }
        } catch (backupError) {
          console.warn(" Could not check backup status after sign-in:", backupError);
        }
      } else {
        toast.error(t("vocabulary.save.errors.googleSignInFailed", "Google sign-in failed") || "Google sign-in failed");
      }
      return result;
    } catch (error) {
      console.error("Google sign-in error:", error);
      toast.error(t("vocabulary.save.errors.googleSignInFailed", "Google sign-in failed") || "Google sign-in failed");
      return false;
    }
  };
  const handleGoogleSignOut = async () => {
    try {
      await googleAuth.signOut();
      hasGoogleDriveFile.value = false;
      setStoredValue("vocabulary-has-google-drive-file", false);
      toast.success(t("vocabulary.save.googleSignOutSuccess", "Successfully signed out from Google") || "Successfully signed out from Google");
    } catch (error) {
      console.error("Google sign-out error:", error);
      toast.error(t("vocabulary.save.errors.googleSignOutFailed", "Google sign-out failed") || "Google sign-out failed");
    }
  };
  const resetAutoSaveFile = async () => {
    autoSaveFileHandle.value = null;
    hasAutoSaveFile.value = false;
    setStoredValue("vocabulary-has-auto-save-file", false);
    autoSaveFilePath.value = "";
    await clearFileHandleFromIDB();
    console.log("Auto-save file reset completed");
  };
  const getSaveStatusColor = computed(() => {
    switch (saveStatus.value) {
      case "saving":
        return "bg-yellow-500";
      case "success":
        return "bg-green-500";
      case "error":
        return "bg-red-500";
      default:
        return "bg-gray-400";
    }
  });
  const getSaveStatusText = computed(() => {
    switch (saveStatus.value) {
      case "saving":
        return autoSaveEnabled.value ? t("vocabulary.save.status.autoSaving", "Auto Saving...") : t("vocabulary.save.status.saving", "Saving...");
      case "success":
        if (autoSaveEnabled.value) {
          if (storageType.value === "google-drive" && hasGoogleDriveFile.value) {
            return t("vocabulary.save.status.autoGoogleDrive", "Auto saved to Google Drive");
          } else if (storageType.value === "local" && hasAutoSaveFile.value) {
            return t("vocabulary.save.status.autoWithFile", "Auto saved to file");
          } else {
            return t("vocabulary.save.status.autoLocalStorage", "Auto saved locally");
          }
        }
        return t("vocabulary.save.status.fileSaved", "Saved to file");
      case "error":
        return t("vocabulary.save.status.error", "Save error");
      default:
        if (autoSaveEnabled.value) {
          if (storageType.value === "google-drive") {
            return googleAuth.isSignedInSync() ? t("vocabulary.save.status.googleDriveReady", "Google Drive ready") : t("vocabulary.save.status.googleDriveSignIn", "Sign in to Google Drive");
          } else {
            return hasAutoSaveFile.value ? t("vocabulary.save.status.autoFile", "Auto save ready") : t("vocabulary.save.status.autoNoFile", "Auto save (no file)");
          }
        }
        return t("vocabulary.save.manual", "Manual save");
    }
  });
  onMounted(async () => {
    console.log(" Component mounted, initializing auto-save...");
    await initializeAutoSave();
    console.log(" Initializing Google APIs...");
    try {
      await googleAuth.initialize();
      console.log(" Google APIs initialized");
      const isSignedIn = await googleAuth.isSignedIn();
      if (isSignedIn) {
        console.log(" Google Drive authentication restored and validated");
        try {
          const backupInfo = await googleDriveApi.getVocabularyBackupInfo();
          if (backupInfo.exists) {
            hasGoogleDriveFile.value = true;
            setStoredValue("vocabulary-has-google-drive-file", true);
            console.log(" Google Drive backup file found");
          }
        } catch (error) {
          console.warn(" Could not check Google Drive backup status:", error);
        }
      } else {
        console.log(" Google Drive authentication could not be restored");
      }
    } catch (error) {
      console.error(" Failed to initialize Google APIs:", error);
    }
  });
  onUnmounted(() => {
    if (autoSaveTimer) clearTimeout(autoSaveTimer);
    if (debounceTimer) clearTimeout(debounceTimer);
  });
  return {
    autoSaveEnabled,
    isSaving,
    lastSaveTime,
    hasAutoSaveFile,
    hasGoogleDriveFile,
    storageType,
    autoSaveFilePath,
    saveStatus,
    getSaveStatusColor,
    getSaveStatusText,
    manualSave,
    debounceAutoSave,
    scheduleAutoSave,
    setupAutoSaveFile,
    setupGoogleDrive,
    syncFromGoogleDrive,
    handleGoogleSignIn,
    handleGoogleSignOut,
    handleFileImport,
    resetAutoSaveFile,
    // Google auth states  
    isGoogleSignedIn: computed(() => googleAuth.isSignedInSync()),
    googleUserEmail: googleAuth.googleUserEmail,
    googleAuthError: googleAuth.authError
  };
}

function useMoveMode() {
  const { t, locale } = useI18n();
  const vocabularyStore = useVocabularyStore();
  const toast = useToast();
  const globalMoveMode = ref(getStoredMoveMode());
  const showMoveModal = ref(false);
  const wordToMove = ref(null);
  const selectedTargetDate = ref("");
  const availableDateGroups = ref([]);
  const currentSourceDate = ref("");
  function getStoredMoveMode() {
    try {
      const stored = localStorage.getItem("vocabulary-global-move-mode-enabled");
      return stored ? JSON.parse(stored) : false;
    } catch (error) {
      console.warn("Failed to parse stored move mode preference:", error);
      return false;
    }
  }
  function setStoredMoveMode(enabled) {
    try {
      localStorage.setItem("vocabulary-global-move-mode-enabled", JSON.stringify(enabled));
    } catch (error) {
      console.warn("Failed to store move mode preference:", error);
    }
  }
  const toggleMoveMode = (enabled) => {
    globalMoveMode.value = enabled;
    setStoredMoveMode(enabled);
  };
  const handleMoveVocabulary = (data) => {
    if (!data.targetDate) {
      wordToMove.value = {
        ...data.word,
        categoryName: data.word.category,
        isBatchMove: false
      };
      currentSourceDate.value = data.sourceDate || "";
      loadAvailableDateGroups(data.word.category);
      showMoveModal.value = true;
    } else {
      performMoveVocabulary(data);
    }
  };
  const loadAvailableDateGroups = (topic) => {
    const allDateGroups = groupVocabulariesByDate(vocabularyStore.allVocabularies.value);
    availableDateGroups.value = allDateGroups.filter((group) => group.date !== currentSourceDate.value).map((group) => ({
      date: group.date,
      count: group.vocabularies.length
    })).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
  };
  const performMoveVocabulary = async (data) => {
    try {
      const wordIndex = vocabularyStore.allVocabularies.value.findIndex((w) => w.id === data.word.id);
      if (wordIndex !== -1) {
        const updatedWord = {
          ...data.word,
          createdAt: data.targetDate,
          updatedAt: data.targetDate
        };
        vocabularyStore.allVocabularies.value[wordIndex] = updatedWord;
        toast.success(
          t(
            "vocabulary.moveSuccess",
            { word: data.word.word, date: formatDateForDisplay(data.targetDate) },
            `Successfully moved "${data.word.word}" to ${formatDateForDisplay(data.targetDate)}`
          ),
          { timeout: 3e3 }
        );
        console.log(`Moved vocabulary "${data.word.word}" to ${data.targetDate}`);
      } else {
        throw new Error("Word not found");
      }
    } catch (error) {
      console.error("Failed to move vocabulary:", error);
      toast.error(
        t(
          "vocabulary.moveError",
          { word: data.word.word, error: error.message },
          `Failed to move "${data.word.word}": ${error.message}`
        ),
        { timeout: 5e3 }
      );
    }
  };
  const formatDateForDisplay = (dateStr) => {
    const date = new Date(dateStr);
    return date.toLocaleDateString(locale.value, {
      year: "numeric",
      month: "short",
      day: "numeric"
    });
  };
  const closeMoveModal = () => {
    showMoveModal.value = false;
    wordToMove.value = null;
    selectedTargetDate.value = "";
    availableDateGroups.value = [];
    currentSourceDate.value = "";
  };
  const confirmMove = (data) => {
    if (data.word.isBatchMove) {
      performBatchMove(data.targetDate);
    } else {
      performMoveVocabulary(data);
    }
    closeMoveModal();
  };
  const handleBatchMoveCategory = (data) => {
    const batchWords = data.words;
    const categoryName = data.topic;
    wordToMove.value = {
      ...batchWords[0],
      isBatchMove: true,
      batchWords,
      categoryName
    };
    currentSourceDate.value = data.sourceDate;
    const allGroups = groupVocabulariesByDate(vocabularyStore.allVocabularies.value);
    availableDateGroups.value = allGroups.filter((group) => group.date !== data.sourceDate).map((group) => ({
      date: group.date,
      count: group.vocabularies.length
    })).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
    showMoveModal.value = true;
  };
  const performBatchMove = async (targetDate) => {
    try {
      const batchWords = wordToMove.value?.batchWords || [];
      const categoryName = wordToMove.value?.categoryName || "";
      batchWords.forEach((word) => {
        const wordIndex = vocabularyStore.allVocabularies.value.findIndex((w) => w.id === word.id);
        if (wordIndex !== -1) {
          const updatedWord = {
            ...word,
            createdAt: targetDate,
            updatedAt: targetDate
          };
          vocabularyStore.allVocabularies.value[wordIndex] = updatedWord;
        }
      });
      toast.success(
        t(
          "vocabulary.batchMoveSuccess",
          { count: batchWords.length, category: categoryName, date: formatDateForDisplay(targetDate) },
          `Successfully moved ${batchWords.length} words from "${categoryName}" to ${formatDateForDisplay(targetDate)}`
        ),
        { timeout: 3e3 }
      );
      console.log(`Batch moved ${batchWords.length} words from category "${categoryName}" to ${targetDate}`);
    } catch (error) {
      console.error("Failed to batch move vocabulary:", error);
      toast.error(
        t(
          "vocabulary.batchMoveError",
          { error: error.message },
          `Failed to batch move: ${error.message}`
        ),
        { timeout: 5e3 }
      );
    }
  };
  return {
    // State
    globalMoveMode,
    showMoveModal,
    wordToMove,
    selectedTargetDate,
    availableDateGroups,
    currentSourceDate,
    // Actions
    toggleMoveMode,
    handleMoveVocabulary,
    handleBatchMoveCategory,
    loadAvailableDateGroups,
    performMoveVocabulary,
    performBatchMove,
    closeMoveModal,
    confirmMove,
    formatDateForDisplay,
    // Helpers
    getStoredMoveMode,
    setStoredMoveMode
  };
}

const _hoisted_1$1q = { class: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative overflow-x-hidden" };
const _hoisted_2$1n = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto px-2 xs:px-3 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 pt-3 sm:pt-6" };
const _hoisted_3$1k = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6 mb-3 xs:mb-4 sm:mb-6" };
const _hoisted_4$1f = { class: "flex items-center mb-4" };
const _hoisted_5$1c = { class: "text-lg sm:text-xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 dark:from-blue-400 dark:to-indigo-400 bg-clip-text text-transparent" };
const _hoisted_6$19 = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto py-3 px-2 xs:py-4 xs:px-3 sm:py-6 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 overflow-x-hidden" };
const _hoisted_7$15 = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] mb-3 xs:mb-4 sm:mb-6 p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_8$13 = { class: "flex items-center mb-4" };
const _hoisted_9$12 = { class: "text-base sm:text-lg font-semibold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent" };
const _hoisted_10$11 = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] mb-3 xs:mb-4 sm:mb-6 p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_11$11 = { class: "flex items-center mb-4" };
const _hoisted_12$_ = { class: "text-base sm:text-lg font-semibold bg-gradient-to-r from-green-600 to-blue-600 dark:from-green-400 dark:to-blue-400 bg-clip-text text-transparent" };
const _hoisted_13$_ = { class: "space-y-4 sm:space-y-6" };
const _hoisted_14$Z = { class: "bg-white/60 dark:bg-[#0a0a0a]/60 backdrop-blur-sm rounded-xl border border-white/20 dark:border-white/10 p-3 sm:p-4 md:p-5" };
const _hoisted_15$T = { class: "flex items-center mb-3 sm:mb-4" };
const _hoisted_16$S = { class: "text-sm sm:text-base font-semibold bg-gradient-to-r from-purple-600 to-pink-600 dark:from-purple-400 dark:to-pink-400 bg-clip-text text-transparent" };
const _hoisted_17$R = { class: "bg-white/60 dark:bg-[#0a0a0a]/60 backdrop-blur-sm rounded-xl border border-white/20 dark:border-white/10 p-3 sm:p-4 md:p-5" };
const _hoisted_18$P = { class: "flex items-center mb-3 sm:mb-4" };
const _hoisted_19$P = { class: "text-sm sm:text-base font-semibold bg-gradient-to-r from-yellow-600 to-orange-600 dark:from-yellow-400 dark:to-orange-400 bg-clip-text text-transparent" };
const _hoisted_20$O = { class: "bg-white/60 dark:bg-[#0a0a0a]/60 backdrop-blur-sm rounded-xl border border-white/20 dark:border-white/10 p-3 sm:p-4 md:p-5" };
const _hoisted_21$O = { class: "flex items-center mb-3 sm:mb-4" };
const _hoisted_22$M = { class: "text-sm sm:text-base font-semibold bg-gradient-to-r from-cyan-600 to-blue-600 dark:from-cyan-400 dark:to-blue-400 bg-clip-text text-transparent" };
const _hoisted_23$M = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.003] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_24$K = { class: "fixed bottom-6 z-50 left-1/2 translate-x-4 md:translate-x-4 lg:left-auto lg:right-6 lg:translate-x-0" };
const _hoisted_25$K = {
  key: 0,
  class: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs font-medium text-white bg-gray-900 dark:bg-black dark:text-white dark:border dark:border-dark-bg-mute rounded shadow-lg whitespace-nowrap z-50"
};
const HOVER_EXPAND_STORAGE_KEY = "vocabulary-hover-expand-enabled";
const _sfc_main$1r = /* @__PURE__ */ defineComponent({
  __name: "VocabularyListView",
  setup(__props) {
    const LazyLoadComponent = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => LazyLoadComponent$1),true              ?void 0:void 0));
    const BaseAccordion = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => BaseAccordion$1),true              ?void 0:void 0));
    const GroupingToggle$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => GroupingToggle),true              ?void 0:void 0));
    const ConfirmToast$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ConfirmToast),true              ?void 0:void 0));
    const TopicManagerPanel$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => TopicManagerPanel),true              ?void 0:void 0));
    const SaveControlPanel$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => SaveControlPanel),true              ?void 0:void 0));
    const VocabularyHeader$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VocabularyHeader),true              ?void 0:void 0));
    const VocabularyFilters$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VocabularyFilters),true              ?void 0:void 0));
    const VocabularyList$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VocabularyList),true              ?void 0:void 0));
    const VocabularyFormDialog = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VocabularyFormDialog$1),true              ?void 0:void 0));
    const VocabularyDetailDialog = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VocabularyDetailDialog$1),true              ?void 0:void 0));
    const VocabularyNoteDialog = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VocabularyNoteDialog$1),true              ?void 0:void 0));
    const GrammarManagerModal = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => GrammarManagerModal$1),true              ?void 0:void 0));
    const MoveModal = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => MoveModal$1),true              ?void 0:void 0));
    const VoiceSelector$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VoiceSelector),true              ?void 0:void 0));
    const TopicManager = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => TopicManager$1),true              ?void 0:void 0));
    const DeleteAllVocabulariesPanel$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => DeleteAllVocabulariesPanel),true              ?void 0:void 0));
    const { t, locale } = useI18n();
    const toast = useToast();
    const vocabularyStore = useVocabularyStore();
    const voiceStore = useVoiceStore();
    const modalStore = useModalStore();
    const itemsPerPage = ref(5);
    const {
      searchQuery,
      selectedCategory,
      selectedLevel,
      showFavoritesOnly,
      updateShowFavoritesOnly,
      updateSearchQuery,
      updateSelectedCategory,
      updateSelectedLevel
    } = useVocabularyFilters();
    const {
      useGrouping,
      itemsPerPageGrouped,
      dateGroupPages,
      toggleGrouping,
      reloadGroupingState,
      dateGroupPrevious,
      dateGroupNext,
      dateGroupGoToPage
    } = useVocabularyGrouping();
    const getStoredHoverState = () => {
      try {
        const stored = localStorage.getItem(HOVER_EXPAND_STORAGE_KEY);
        return stored ? JSON.parse(stored) : false;
      } catch (error) {
        console.warn("Failed to load hover expand state from localStorage:", error);
        return false;
      }
    };
    const setStoredHoverState = (enabled) => {
      try {
        localStorage.setItem(HOVER_EXPAND_STORAGE_KEY, JSON.stringify(enabled));
      } catch (error) {
        console.warn("Failed to save hover expand state to localStorage:", error);
      }
    };
    const hoverToExpandEnabled = ref(getStoredHoverState());
    const {
      globalMoveMode,
      showMoveModal,
      wordToMove,
      availableDateGroups,
      currentSourceDate,
      toggleMoveMode,
      handleMoveVocabulary,
      handleBatchMoveCategory,
      closeMoveModal,
      confirmMove} = useMoveMode();
    const showNoteDialog = ref(false);
    const noteDialogDate = ref("");
    const noteDialogWords = ref([]);
    const filteredVocabulary = computed(() => {
      return vocabularyStore.allVocabularies.value.filter((word) => {
        const matchesSearch = !searchQuery.value || word.word.toLowerCase().includes(searchQuery.value.toLowerCase()) || word.meaning.toLowerCase().includes(searchQuery.value.toLowerCase());
        const matchesCategory = !selectedCategory.value || word.category === selectedCategory.value;
        const matchesLevel = !selectedLevel.value || word.level === selectedLevel.value;
        const matchesFavorite = !showFavoritesOnly.value || word.favorite === true;
        return matchesSearch && matchesCategory && matchesLevel && matchesFavorite;
      });
    });
    const {
      currentPage,
      totalPages,
      paginatedVocabulary,
      startIndex,
      endIndex,
      visiblePages,
      previousPage,
      nextPage,
      goToPage
    } = useVocabularyPagination(filteredVocabulary, useGrouping, itemsPerPage);
    const {
      showFormDialog,
      selectedVocabulary,
      showDetailDialog,
      selectedVocabularyForDetail,
      openAddDialog,
      openEditDialog,
      onVocabularySaved: originalOnVocabularySaved,
      openDetailsDialog,
      openEditFromDetail
    } = useVocabularyDialogs();
    const recentlyAddedCategory = ref(null);
    const onVocabularySaved = (data) => {
      originalOnVocabularySaved();
      targetDateForNewVocabulary.value = null;
      if (data?.category) {
        recentlyAddedCategory.value = data.category;
        console.log("Recently added category:", data.category);
      }
      if (autoSaveEnabled.value) {
        debounceAutoSave();
        console.log("Auto-save triggered from Add Word in date group");
      }
      if (useGrouping.value) {
        nextTick(() => {
          reloadGroupingState();
          console.log("Grouping state reloaded after vocabulary saved");
        });
      }
    };
    const {
      autoSaveEnabled,
      isSaving,
      lastSaveTime,
      hasAutoSaveFile,
      hasGoogleDriveFile,
      storageType,
      saveStatus,
      getSaveStatusColor,
      getSaveStatusText,
      manualSave,
      debounceAutoSave,
      scheduleAutoSave,
      setupAutoSaveFile,
      setupGoogleDrive,
      syncFromGoogleDrive,
      handleGoogleSignIn,
      handleGoogleSignOut,
      handleFileImport,
      resetAutoSaveFile,
      autoSaveFilePath,
      isGoogleSignedIn,
      googleUserEmail,
      googleAuthError
    } = useVocabularySaving();
    const {
      showTopicManager,
      openTopicManager,
      onTopicAdded,
      onTopicUpdated,
      onTopicDeleted
    } = useTopicManager(debounceAutoSave);
    const categories = computed(() => {
      const usedCategories = new Set(vocabularyStore.allVocabularies.value.map((vocab) => vocab.category));
      return Array.from(usedCategories).sort();
    });
    const categoryUsage = computed(() => vocabularyStore.getCategoryUsage.value);
    const showStickyButtonVisible = computed(() => {
      return showStickyButton.value && !showFormDialog.value && !modalStore.shouldHideAddNewWord;
    });
    const formattedSaveStatusForAccordion = computed(() => {
      if (!lastSaveTime.value) {
        return t("vocabulary.save.notSaved", "Not saved");
      }
      const statusText = getSaveStatusText.value;
      const timeText = lastSaveTime.value;
      const lastSaveLabel = t("vocabulary.save.lastSave", { time: timeText }, "Last saved: {time}");
      let finalText;
      if (lastSaveLabel && lastSaveLabel.includes("{time}")) {
        finalText = lastSaveLabel.replace("{time}", timeText);
      } else {
        finalText = lastSaveLabel || `Last saved: ${timeText}`;
      }
      return `${finalText} - ${statusText}`;
    });
    const deleteWord = (word) => {
      const toastId = toast(
        {
          component: ConfirmToast$1,
          props: {
            message: t("vocabulary.confirmDelete", { word: word.word }),
            confirmText: t("common.confirm"),
            cancelText: t("common.cancel"),
            onConfirm: () => {
              vocabularyStore.deleteVocabulary(word.id);
              debounceAutoSave();
              toast.dismiss(toastId);
              toast.success(t("vocabulary.deleteSuccess", { word: word.word }) || `Successfully deleted "${word.word}"`);
            },
            onCancel: () => {
              toast.dismiss(toastId);
            }
          }
        },
        {
          position: POSITION.TOP_CENTER,
          timeout: false,
          closeButton: false,
          draggable: false,
          icon: false
        }
      );
    };
    const toggleFavorite = (word) => {
      vocabularyStore.toggleFavorite(word.id);
      if (selectedVocabularyForDetail.value && selectedVocabularyForDetail.value.id === word.id) {
        selectedVocabularyForDetail.value.favorite = !selectedVocabularyForDetail.value.favorite;
      }
      debounceAutoSave();
    };
    const playAudio = async (word) => {
      try {
        const utterance = voiceStore.createUtterance(word);
        await new Promise((resolve, reject) => {
          utterance.onend = () => resolve();
          utterance.onerror = (event) => reject(event.error);
          if ("speechSynthesis" in window) {
            speechSynthesis.speak(utterance);
          } else {
            reject(new Error("Speech synthesis not supported"));
          }
        });
      } catch (error) {
        console.error("Error playing audio:", error);
        if ("speechSynthesis" in window) {
          const utterance = new SpeechSynthesisUtterance(word);
          utterance.lang = "en-US";
          speechSynthesis.speak(utterance);
        }
      }
    };
    watch(
      () => vocabularyStore.allVocabularies.value,
      (newVocabularies, oldVocabularies) => {
        const newCount = newVocabularies?.length || 0;
        const oldCount = oldVocabularies?.length || 0;
        if (autoSaveEnabled.value && newCount > 0 && oldCount !== void 0 && newCount !== oldCount) {
          saveStatus.value = "saving";
          debounceAutoSave();
        }
        if (useGrouping.value && newCount !== oldCount && newCount > 0) {
          nextTick(() => {
            reloadGroupingState();
            console.log("Grouping state reloaded due to vocabulary count change");
          });
        }
      },
      { deep: true, immediate: false }
    );
    watch(
      () => vocabularyStore.allVocabularies.value.map((v) => ({ id: v.id, favorite: v.favorite, word: v.word, meaning: v.meaning })),
      (newData, oldData) => {
        if (autoSaveEnabled.value && newData.length > 0 && oldData && JSON.stringify(newData) !== JSON.stringify(oldData)) {
          debounceAutoSave();
        }
      },
      { deep: true }
    );
    watch(
      hoverToExpandEnabled,
      (newValue) => {
        setStoredHoverState(newValue);
      }
    );
    watch(showNoteDialog, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        if (!showFormDialog.value) {
          document.body.classList.remove("modal-open");
        }
      }
      modalStore.setNoteDialog(newValue);
    });
    watch(showFormDialog, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
        showStickyTooltip.value = false;
      } else {
        if (!showNoteDialog.value) {
          document.body.classList.remove("modal-open");
        }
      }
      modalStore.setVocabularyForm(newValue);
    });
    onMounted(() => {
      vocabularyStore.initializeStore();
      if (autoSaveEnabled.value) {
        scheduleAutoSave();
      }
      window.addEventListener("vocabulary-notes-updated", () => {
        if (autoSaveEnabled.value) {
          debounceAutoSave();
        }
      });
      window.addEventListener("grammar-rules-updated", () => {
        if (autoSaveEnabled.value) {
          debounceAutoSave();
        }
      });
      window.addEventListener("scroll", handleScroll, { passive: true });
      handleScroll();
    });
    const handleFileImportWithReload = (file) => {
      const handleImportComplete = (event) => {
        nextTick(() => {
          reloadGroupingState();
          console.log("Grouping state reloaded after import");
        });
        window.removeEventListener("vocabularyImportComplete", handleImportComplete);
      };
      window.addEventListener("vocabularyImportComplete", handleImportComplete);
      handleFileImport(file);
    };
    const showStickyButton = ref(false);
    const showStickyTooltip = ref(false);
    const headerHeight = ref(0);
    ref(false);
    const lastScrollY = ref(0);
    const accordionState = ref(true);
    const handleScroll = () => {
      const scrollY = window.scrollY;
      const headerElement = document.querySelector("[data-vocabulary-header]") || document.querySelector("header");
      if (headerHeight.value === 0 && headerElement) {
        headerHeight.value = headerElement.offsetHeight;
      }
      const currentAccordionState = (() => {
        try {
          const stored = localStorage.getItem("accordion-vocabulary-header");
          return stored !== null ? JSON.parse(stored) : true;
        } catch {
          return true;
        }
      })();
      accordionState.value = currentAccordionState;
      const originalAddButton = document.querySelector("[data-original-add-button]");
      let originalButtonVisible = false;
      if (originalAddButton) {
        const rect = originalAddButton.getBoundingClientRect();
        const computedStyle = window.getComputedStyle(originalAddButton);
        originalButtonVisible = rect.height > 0 && rect.width > 0 && computedStyle.display !== "none" && computedStyle.visibility !== "hidden" && computedStyle.opacity !== "0";
      }
      const headerBottom = headerHeight.value || 120;
      let shouldShowSticky;
      if (!accordionState.value) {
        shouldShowSticky = true;
      } else if (originalButtonVisible) {
        shouldShowSticky = false;
      } else {
        shouldShowSticky = scrollY > headerBottom;
      }
      showStickyButton.value = shouldShowSticky;
      lastScrollY.value = scrollY;
    };
    const openNoteDialog = (date, words) => {
      noteDialogDate.value = date;
      noteDialogWords.value = words;
      showNoteDialog.value = true;
    };
    const targetDateForNewVocabulary = ref(null);
    const showGrammarManagerModal = ref(false);
    const grammarManagerDate = ref(null);
    const openAddVocabularyForDate = (date) => {
      targetDateForNewVocabulary.value = date;
      selectedVocabulary.value = null;
      showFormDialog.value = true;
      window.dispatchEvent(new CustomEvent("vocabulary-edit-word"));
    };
    const openGrammarManagerForDate = (date) => {
      console.log("Opening grammar manager for date:", date);
      grammarManagerDate.value = date;
      showGrammarManagerModal.value = true;
      modalStore.setGrammarManager(true);
      console.log("Modal state:", showGrammarManagerModal.value);
    };
    watch(showGrammarManagerModal, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        if (!showNoteDialog.value && !showFormDialog.value) {
          document.body.classList.remove("modal-open");
        }
      }
      modalStore.setGrammarManager(newValue);
    });
    const handleNoteSaved = (note, markedWords) => {
      toast.success(t("vocabulary.notes.saveSuccess", "Notes saved successfully"), {
        timeout: 2e3
      });
      if (autoSaveEnabled.value) {
        toast.info(t("vocabulary.notes.autoSaveNotice", "Notes will be included in auto-save"), {
          timeout: 3e3
        });
        debounceAutoSave();
      }
      console.log(`Note saved for ${noteDialogDate.value} with ${markedWords.length} marked words`);
    };
    const handleVocabulariesDeleted = () => {
      currentPage.value = 1;
      recentlyAddedCategory.value = null;
      if (useGrouping.value) {
        nextTick(() => {
          reloadGroupingState();
          console.log("Grouping state reloaded after delete all");
        });
      }
      if (autoSaveEnabled.value) {
        debounceAutoSave();
      }
    };
    const handleLocalStoreCleared = () => {
      currentPage.value = 1;
      recentlyAddedCategory.value = null;
      useGrouping.value = false;
      autoSaveEnabled.value = false;
      hoverToExpandEnabled.value = false;
      globalMoveMode.value = false;
      nextTick(() => {
        reloadGroupingState();
        console.log("Grouping state reloaded after local store clear");
      });
      toast.info(
        t("vocabulary.deleteAll.localStoreClearedInfo", "Application has been reset to initial state. All local preferences have been cleared."),
        { timeout: 5e3 }
      );
      console.log("Local store cleared, application reset to initial state");
    };
    watch(hoverToExpandEnabled, (newValue) => {
      setStoredHoverState(newValue);
    });
    watch(globalMoveMode, (newValue) => {
      toggleMoveMode(newValue);
    });
    const handleStorageChange = (e) => {
      if (e.key === "accordion-vocabulary-header") {
        setTimeout(() => handleScroll(), 50);
      }
    };
    onMounted(() => {
      document.addEventListener("scroll", handleScroll);
      window.addEventListener("storage", handleStorageChange);
      const accordionButton = document.querySelector("[data-vocabulary-header] button");
      if (accordionButton) {
        accordionButton.addEventListener("click", () => {
          setTimeout(() => handleScroll(), 100);
        });
      }
      handleScroll();
    });
    onUnmounted(() => {
      document.removeEventListener("scroll", handleScroll);
      window.removeEventListener("storage", handleStorageChange);
      document.body.classList.remove("modal-open");
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1q, [
        _cache[26] || (_cache[26] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0"><div class="floating-shapes"><div class="absolute top-20 left-10 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob"></div><div class="absolute top-40 right-10 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000"></div><div class="absolute -bottom-8 left-20 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000"></div><div class="hidden sm:block absolute top-10 left-1/2 -translate-x-1/2 w-40 h-40 bg-cyan-300 dark:bg-cyan-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-1000"></div><div class="hidden sm:block absolute bottom-24 right-24 w-52 h-52 bg-indigo-300 dark:bg-indigo-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-3000"></div><div class="hidden md:block absolute top-1/3 right-1/3 w-36 h-36 bg-emerald-300 dark:bg-emerald-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-1500"></div><div class="hidden md:block absolute -bottom-20 -right-10 w-96 h-96 bg-blue-200 dark:bg-blue-600 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-2xl opacity-20 animate-blob animation-delay-2500"></div><div class="hidden lg:block absolute top-1/2 -left-16 w-72 h-72 bg-fuchsia-300 dark:bg-fuchsia-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-3500"></div><div class="hidden xl:block absolute top-6 right-1/4 w-44 h-44 bg-teal-300 dark:bg-teal-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-500"></div><div class="hidden sm:block absolute top-1/4 left-6 w-24 h-24 bg-sky-300 dark:bg-sky-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-lg opacity-20 animate-blob animation-delay-4500"></div><div class="hidden sm:block absolute bottom-8 left-1/3 w-28 h-28 bg-rose-300 dark:bg-rose-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-lg opacity-20 animate-blob animation-delay-5500"></div><div class="hidden md:block absolute top-16 right-1/3 w-20 h-20 bg-violet-300 dark:bg-violet-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-lg opacity-20 animate-blob animation-delay-6500"></div><div class="hidden md:block absolute bottom-1/3 right-6 w-24 h-24 bg-lime-300 dark:bg-lime-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-lg opacity-20 animate-blob animation-delay-7500"></div><div class="hidden lg:block absolute top-3/4 left-1/4 w-32 h-32 bg-amber-300 dark:bg-amber-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-20 animate-blob animation-delay-8500"></div><div class="hidden lg:block absolute top-8 right-8 w-16 h-16 bg-orange-300 dark:bg-orange-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-md opacity-25 animate-blob animation-delay-1200"></div><div class="hidden xl:block absolute bottom-10 left-1/2 -translate-x-1/2 w-28 h-28 bg-cyan-200 dark:bg-cyan-600 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-15 animate-blob animation-delay-2200"></div><div class="hidden 2xl:block absolute top-1/5 right-1/5 w-40 h-40 bg-indigo-200 dark:bg-indigo-600 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-2xl opacity-15 animate-blob animation-delay-5200"></div><div class="hidden lg:block absolute -top-24 left-1/3 w-96 h-96 bg-blue-100 dark:bg-blue-700 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-3xl opacity-10 animate-blob animation-delay-900"></div><div class="hidden lg:block absolute bottom-[-120px] left-[-80px] w-[420px] h-[420px] bg-purple-100 dark:bg-purple-700 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-3xl opacity-10 animate-blob animation-delay-1900"></div><div class="hidden xl:block absolute top-1/3 left-[70%] w-48 h-48 bg-pink-200 dark:bg-pink-600 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-2xl opacity-15 animate-blob animation-delay-3300"></div><div class="hidden xl:block absolute bottom-1/4 right-[35%] w-32 h-32 bg-cyan-300 dark:bg-cyan-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-15 animate-blob animation-delay-6100"></div><div class="hidden 2xl:block absolute top-[12%] left-[12%] w-56 h-56 bg-emerald-200 dark:bg-emerald-600 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-2xl opacity-15 animate-blob animation-delay-7100"></div><div class="hidden 2xl:block absolute bottom-[8%] right-[12%] w-64 h-64 bg-teal-200 dark:bg-teal-600 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-2xl opacity-15 animate-blob animation-delay-9100"></div></div></div>', 1)),
        createBaseVNode("div", _hoisted_2$1n, [
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "fade-up",
            threshold: 0.1,
            "root-margin": "0px"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_3$1k, [
                createBaseVNode("div", _hoisted_4$1f, [
                  _cache[18] || (_cache[18] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                    createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-indigo-500 rounded-full mr-2.5" })
                  ], -1)),
                  createBaseVNode("h1", _hoisted_5$1c, toDisplayString$1(unref(t)("vocabulary.header.title", "Vocabulary")), 1)
                ]),
                createVNode(unref(VocabularyHeader$1), { onAddVocabulary: unref(openAddDialog) }, null, 8, ["onAddVocabulary"])
              ])
            ]),
            _: 1
          })
        ]),
        createBaseVNode("div", _hoisted_6$19, [
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "slide-left",
            threshold: 0.1,
            "root-margin": "-50px"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_7$15, [
                createBaseVNode("div", _hoisted_8$13, [
                  _cache[19] || (_cache[19] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                    createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full mr-2.5" })
                  ], -1)),
                  createBaseVNode("h3", _hoisted_9$12, toDisplayString$1(unref(t)("vocabulary.filters.title", "Filters")), 1)
                ]),
                createVNode(unref(VocabularyFilters$1), {
                  "search-query": unref(searchQuery),
                  "selected-category": unref(selectedCategory),
                  "selected-level": unref(selectedLevel),
                  categories: categories.value,
                  "show-favorites-only": unref(showFavoritesOnly),
                  "onUpdate:searchQuery": unref(updateSearchQuery),
                  "onUpdate:selectedCategory": unref(updateSelectedCategory),
                  "onUpdate:selectedLevel": unref(updateSelectedLevel),
                  "onUpdate:showFavoritesOnly": unref(updateShowFavoritesOnly)
                }, null, 8, ["search-query", "selected-category", "selected-level", "categories", "show-favorites-only", "onUpdate:searchQuery", "onUpdate:selectedCategory", "onUpdate:selectedLevel", "onUpdate:showFavoritesOnly"])
              ])
            ]),
            _: 1
          }),
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "slide-right",
            threshold: 0.1,
            "root-margin": "-50px"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_10$11, [
                createBaseVNode("div", _hoisted_11$11, [
                  _cache[20] || (_cache[20] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                    createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-green-400 to-blue-500 rounded-full mr-2.5" })
                  ], -1)),
                  createBaseVNode("h3", _hoisted_12$_, toDisplayString$1(unref(t)("vocabulary.grouping.title", "Grouping & Move Mode")), 1)
                ]),
                createVNode(unref(GroupingToggle$1), {
                  "model-value": unref(useGrouping),
                  "hover-enabled": hoverToExpandEnabled.value,
                  "move-mode": unref(globalMoveMode),
                  "onUpdate:modelValue": unref(toggleGrouping),
                  "onUpdate:hoverEnabled": _cache[0] || (_cache[0] = ($event) => hoverToExpandEnabled.value = $event),
                  "onUpdate:moveMode": _cache[1] || (_cache[1] = ($event) => globalMoveMode.value = $event)
                }, null, 8, ["model-value", "hover-enabled", "move-mode", "onUpdate:modelValue"])
              ])
            ]),
            _: 1
          }),
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "scale",
            threshold: 0.1,
            "root-margin": "-50px"
          }, {
            default: withCtx(() => [
              createVNode(unref(BaseAccordion), {
                title: unref(t)("vocabulary.tools.accordionTitle", "Tools & Settings"),
                description: unref(t)("vocabulary.tools.accordionDescription", "Voice settings, topic manager, and save & sync options"),
                icon: "settings",
                "default-open": true,
                "persist-key": "vocabulary-tools",
                "status-text": formattedSaveStatusForAccordion.value,
                "status-color": unref(getSaveStatusColor),
                "show-status-when-closed": true,
                class: "mb-3 xs:mb-4 sm:mb-6"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_13$_, [
                    createBaseVNode("div", _hoisted_14$Z, [
                      createBaseVNode("div", _hoisted_15$T, [
                        _cache[21] || (_cache[21] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                          createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-purple-400 to-pink-500 rounded-full mr-2.5" })
                        ], -1)),
                        createBaseVNode("h3", _hoisted_16$S, toDisplayString$1(unref(t)("voice.settings.title", "Voice Settings")), 1)
                      ]),
                      createVNode(unref(VoiceSelector$1), { "show-voice-info": true })
                    ]),
                    createBaseVNode("div", _hoisted_17$R, [
                      createBaseVNode("div", _hoisted_18$P, [
                        _cache[22] || (_cache[22] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                          createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-yellow-400 to-orange-500 rounded-full mr-2.5" })
                        ], -1)),
                        createBaseVNode("h3", _hoisted_19$P, toDisplayString$1(unref(t)("vocabulary.topicManager.title", "Topic Manager")), 1)
                      ]),
                      createVNode(unref(TopicManagerPanel$1), { onOpen: unref(openTopicManager) }, null, 8, ["onOpen"])
                    ]),
                    createBaseVNode("div", _hoisted_20$O, [
                      createBaseVNode("div", _hoisted_21$O, [
                        _cache[23] || (_cache[23] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                          createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-cyan-400 to-blue-500 rounded-full mr-2.5" })
                        ], -1)),
                        createBaseVNode("h3", _hoisted_22$M, toDisplayString$1(unref(t)("vocabulary.save.title", "Save & Sync")), 1)
                      ]),
                      createVNode(unref(SaveControlPanel$1), {
                        "auto-save-enabled": unref(autoSaveEnabled),
                        "onUpdate:autoSaveEnabled": _cache[2] || (_cache[2] = ($event) => autoSaveEnabled.value = $event),
                        "is-saving": unref(isSaving),
                        "has-auto-save-file": unref(hasAutoSaveFile),
                        "onUpdate:hasAutoSaveFile": _cache[3] || (_cache[3] = ($event) => hasAutoSaveFile.value = $event),
                        "has-google-drive-file": unref(hasGoogleDriveFile),
                        "onUpdate:hasGoogleDriveFile": _cache[4] || (_cache[4] = ($event) => hasGoogleDriveFile.value = $event),
                        "storage-type": unref(storageType),
                        "onUpdate:storageType": _cache[5] || (_cache[5] = ($event) => storageType.value = $event),
                        "is-google-signed-in": unref(isGoogleSignedIn),
                        "onUpdate:isGoogleSignedIn": _cache[6] || (_cache[6] = ($event) => isGoogleSignedIn.value = $event),
                        "google-user-email": unref(googleUserEmail),
                        "google-auth-error": unref(googleAuthError),
                        "auto-save-file-path": unref(autoSaveFilePath),
                        "onUpdate:autoSaveFilePath": _cache[7] || (_cache[7] = ($event) => autoSaveFilePath.value = $event),
                        "last-save-time": unref(lastSaveTime),
                        "save-status-color": unref(getSaveStatusColor),
                        "save-status-text": unref(getSaveStatusText),
                        onManualSave: unref(manualSave),
                        onSetupAutoSave: unref(setupAutoSaveFile),
                        onSetupGoogleDrive: unref(setupGoogleDrive),
                        onGoogleSignIn: unref(handleGoogleSignIn),
                        onGoogleSignOut: unref(handleGoogleSignOut),
                        onSyncFromGoogleDrive: unref(syncFromGoogleDrive),
                        onResetAutoSave: unref(resetAutoSaveFile),
                        onImportFile: handleFileImportWithReload
                      }, null, 8, ["auto-save-enabled", "is-saving", "has-auto-save-file", "has-google-drive-file", "storage-type", "is-google-signed-in", "google-user-email", "google-auth-error", "auto-save-file-path", "last-save-time", "save-status-color", "save-status-text", "onManualSave", "onSetupAutoSave", "onSetupGoogleDrive", "onGoogleSignIn", "onGoogleSignOut", "onSyncFromGoogleDrive", "onResetAutoSave"])
                    ]),
                    createVNode(unref(DeleteAllVocabulariesPanel$1), {
                      "total-count": filteredVocabulary.value.length,
                      "auto-save-enabled": unref(autoSaveEnabled),
                      "use-grouping": unref(useGrouping),
                      onVocabulariesDeleted: handleVocabulariesDeleted,
                      onLocalStoreCleared: handleLocalStoreCleared
                    }, null, 8, ["total-count", "auto-save-enabled", "use-grouping"])
                  ])
                ]),
                _: 1
              }, 8, ["title", "description", "status-text", "status-color"])
            ]),
            _: 1
          }),
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "slide-left",
            threshold: 0.05,
            "root-margin": "-50px"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_23$M, [
                createVNode(unref(VocabularyList$1), {
                  "paginated-words": unref(useGrouping) ? [] : unref(paginatedVocabulary),
                  "current-page": unref(currentPage),
                  "total-pages": unref(totalPages),
                  "total-count": filteredVocabulary.value.length,
                  "start-index": unref(startIndex),
                  "end-index": unref(endIndex),
                  "visible-pages": unref(visiblePages),
                  "use-grouping": unref(useGrouping),
                  "all-words": unref(useGrouping) ? filteredVocabulary.value : void 0,
                  "date-group-pages": unref(dateGroupPages),
                  "items-per-page-grouped": unref(itemsPerPageGrouped),
                  "hover-to-expand-enabled": hoverToExpandEnabled.value,
                  "global-move-mode": unref(globalMoveMode),
                  "recently-added-category": recentlyAddedCategory.value,
                  onPlayAudio: playAudio,
                  onEditWord: unref(openEditDialog),
                  onDeleteWord: deleteWord,
                  onToggleFavorite: toggleFavorite,
                  onViewDetails: unref(openDetailsDialog),
                  onPreviousPage: unref(previousPage),
                  onNextPage: unref(nextPage),
                  onGoToPage: unref(goToPage),
                  onDateGroupPrevious: _cache[8] || (_cache[8] = (date) => unref(dateGroupPrevious)(date, filteredVocabulary.value)),
                  onDateGroupNext: _cache[9] || (_cache[9] = (date) => unref(dateGroupNext)(date, filteredVocabulary.value)),
                  onDateGroupGoToPage: unref(dateGroupGoToPage),
                  onMoveVocabulary: unref(handleMoveVocabulary),
                  onOpenNoteDialog: openNoteDialog,
                  onOpenAddVocabularyDialog: openAddVocabularyForDate,
                  onOpenGrammarManager: openGrammarManagerForDate,
                  onBatchMoveCategory: unref(handleBatchMoveCategory)
                }, null, 8, ["paginated-words", "current-page", "total-pages", "total-count", "start-index", "end-index", "visible-pages", "use-grouping", "all-words", "date-group-pages", "items-per-page-grouped", "hover-to-expand-enabled", "global-move-mode", "recently-added-category", "onEditWord", "onViewDetails", "onPreviousPage", "onNextPage", "onGoToPage", "onDateGroupGoToPage", "onMoveVocabulary", "onBatchMoveCategory"])
              ])
            ]),
            _: 1
          })
        ]),
        createVNode(unref(VocabularyFormDialog), {
          modelValue: unref(showFormDialog),
          "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => isRef(showFormDialog) ? showFormDialog.value = $event : null),
          vocabulary: unref(selectedVocabulary),
          "target-date": targetDateForNewVocabulary.value,
          onVocabularySaved
        }, null, 8, ["modelValue", "vocabulary", "target-date"]),
        createVNode(unref(VocabularyDetailDialog), {
          modelValue: unref(showDetailDialog),
          "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => isRef(showDetailDialog) ? showDetailDialog.value = $event : null),
          vocabulary: unref(selectedVocabularyForDetail),
          onEditVocabulary: unref(openEditFromDetail),
          onToggleFavorite: toggleFavorite
        }, null, 8, ["modelValue", "vocabulary", "onEditVocabulary"]),
        createVNode(unref(TopicManager), {
          modelValue: unref(showTopicManager),
          "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => isRef(showTopicManager) ? showTopicManager.value = $event : null),
          "vocabulary-usage": categoryUsage.value,
          onTopicAdded: unref(onTopicAdded),
          onTopicUpdated: unref(onTopicUpdated),
          onTopicDeleted: unref(onTopicDeleted)
        }, null, 8, ["modelValue", "vocabulary-usage", "onTopicAdded", "onTopicUpdated", "onTopicDeleted"]),
        createVNode(unref(VocabularyNoteDialog), {
          modelValue: showNoteDialog.value,
          "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => showNoteDialog.value = $event),
          date: noteDialogDate.value,
          "today-words": noteDialogWords.value,
          onSaveNote: handleNoteSaved
        }, null, 8, ["modelValue", "date", "today-words"]),
        createVNode(unref(GrammarManagerModal), {
          modelValue: showGrammarManagerModal.value,
          "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => showGrammarManagerModal.value = $event),
          selectedDate: grammarManagerDate.value
        }, null, 8, ["modelValue", "selectedDate"]),
        createVNode(Transition, { name: "fade-scale" }, {
          default: withCtx(() => [
            withDirectives(createBaseVNode("div", _hoisted_24$K, [
              createBaseVNode("button", {
                onClick: _cache[15] || (_cache[15] = //@ts-ignore
                (...args) => unref(openAddDialog) && unref(openAddDialog)(...args)),
                onMouseenter: _cache[16] || (_cache[16] = ($event) => showStickyTooltip.value = true),
                onMouseleave: _cache[17] || (_cache[17] = ($event) => showStickyTooltip.value = false),
                class: "relative bg-blue-500 hover:bg-blue-600 text-white font-medium w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 rounded-full shadow-lg hover:shadow-xl transition-all duration-300 transform hover:scale-105 flex items-center justify-center"
              }, [
                _cache[25] || (_cache[25] = createBaseVNode("svg", {
                  class: "w-6 h-6 sm:w-7 sm:h-7 md:w-8 md:h-8",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                    "clip-rule": "evenodd"
                  })
                ], -1)),
                showStickyTooltip.value ? (openBlock(), createElementBlock("div", _hoisted_25$K, [
                  createTextVNode(toDisplayString$1(unref(t)("vocabulary.addNew", "Add New Word")) + " ", 1),
                  _cache[24] || (_cache[24] = createBaseVNode("div", { class: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900 dark:border-t-black" }, null, -1))
                ])) : createCommentVNode("", true)
              ], 32)
            ], 512), [
              [vShow, showStickyButtonVisible.value]
            ])
          ]),
          _: 1
        }),
        createVNode(unref(MoveModal), {
          "show-modal": unref(showMoveModal),
          "word-to-move": unref(wordToMove),
          "available-date-groups": unref(availableDateGroups),
          "source-date": unref(currentSourceDate),
          "all-vocabularies": unref(vocabularyStore).allVocabularies.value,
          onClose: unref(closeMoveModal),
          onConfirmMove: unref(confirmMove)
        }, null, 8, ["show-modal", "word-to-move", "available-date-groups", "source-date", "all-vocabularies", "onClose", "onConfirmMove"])
      ]);
    };
  }
});

const _hoisted_1$1p = { class: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative overflow-x-hidden" };
const _hoisted_2$1m = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto px-2 xs:px-3 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 pt-3 sm:pt-6" };
const _hoisted_3$1j = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6 mb-3 xs:mb-4 sm:mb-6" };
const _hoisted_4$1e = { class: "flex items-center justify-between mb-4" };
const _hoisted_5$1b = { class: "flex items-center" };
const _hoisted_6$18 = { class: "text-lg sm:text-xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 dark:from-blue-400 dark:to-indigo-400 bg-clip-text text-transparent mb-2" };
const _hoisted_7$14 = { class: "text-sm sm:text-base text-gray-600 dark:text-gray-300" };
const _hoisted_8$12 = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto py-3 px-2 xs:py-4 xs:px-3 sm:py-6 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 overflow-x-hidden" };
const _hoisted_9$11 = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] mb-3 xs:mb-4 sm:mb-6 p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_10$10 = { class: "flex items-center mb-4" };
const _hoisted_11$10 = { class: "text-base sm:text-lg font-semibold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent" };
const _hoisted_12$Z = { class: "grid grid-cols-1 md:grid-cols-3 gap-4" };
const _hoisted_13$Z = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_14$Y = ["placeholder"];
const _hoisted_15$S = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_16$R = { value: "" };
const _hoisted_17$Q = ["value"];
const _hoisted_18$O = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_19$O = { value: "" };
const _hoisted_20$N = { value: "multiple-choice" };
const _hoisted_21$N = { value: "fill-blank" };
const _hoisted_22$L = { value: "true-false" };
const _hoisted_23$L = { value: "short-answer" };
const _hoisted_24$J = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto py-3 px-2 xs:py-4 xs:px-3 sm:py-6 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 overflow-x-hidden" };
const _hoisted_25$J = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_26$H = { class: "flex items-center mb-4" };
const _hoisted_27$G = { class: "text-base sm:text-lg font-semibold bg-gradient-to-r from-green-600 to-blue-600 dark:from-green-400 dark:to-blue-400 bg-clip-text text-transparent" };
const _hoisted_28$E = { class: "space-y-4" };
const _hoisted_29$C = {
  key: 0,
  class: "text-center py-8"
};
const _hoisted_30$A = { class: "text-gray-500 dark:text-gray-400" };
const _hoisted_31$z = { class: "flex items-start justify-between" };
const _hoisted_32$w = { class: "flex-1" };
const _hoisted_33$v = { class: "flex items-center gap-3 mb-3" };
const _hoisted_34$s = {
  key: 1,
  class: "text-sm text-gray-600 dark:text-gray-400"
};
const _hoisted_35$s = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-2" };
const _hoisted_36$r = {
  key: 0,
  class: "mb-3"
};
const _hoisted_37$q = { class: "grid grid-cols-1 sm:grid-cols-2 gap-2" };
const _hoisted_38$q = {
  key: 1,
  class: "mb-3"
};
const _hoisted_39$o = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_40$o = { class: "ml-2 px-2 py-1 bg-green-50/50 dark:bg-green-900/20 text-green-700 dark:text-green-400 rounded" };
const _hoisted_41$n = {
  key: 2,
  class: "mb-3"
};
const _hoisted_42$l = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_43$k = { class: "text-xs text-gray-500 dark:text-gray-400" };
const _hoisted_44$j = { class: "flex items-center gap-2 ml-4" };
const _hoisted_45$i = ["onClick"];
const _hoisted_46$i = ["onClick"];
const _sfc_main$1q = /* @__PURE__ */ defineComponent({
  __name: "VocabularyQuestionsView",
  setup(__props) {
    const QuestionFormDialog$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => QuestionFormDialog),true              ?void 0:void 0));
    const { t } = useI18n();
    const vocabularyStore = useVocabularyStore();
    const questions = ref([]);
    const showCreateDialog = ref(false);
    const showEditDialog = ref(false);
    const currentQuestion = ref(null);
    const searchTerm = ref("");
    const selectedVocabulary = ref("");
    const selectedType = ref("");
    const vocabularyList = computed(() => vocabularyStore.allVocabularies.value.map((v) => ({ id: v.id.toString(), word: v.word, meaning: v.meaning })));
    const filteredQuestions = computed(() => {
      let filtered = questions.value;
      if (searchTerm.value) {
        const term = searchTerm.value.toLowerCase();
        filtered = filtered.filter(
          (q) => q.question.toLowerCase().includes(term) || q.vocabulary?.word.toLowerCase().includes(term)
        );
      }
      if (selectedVocabulary.value) {
        filtered = filtered.filter((q) => q.vocabularyId === selectedVocabulary.value);
      }
      if (selectedType.value) {
        filtered = filtered.filter((q) => q.type === selectedType.value);
      }
      return filtered;
    });
    const loadQuestions = () => {
      const stored = localStorage.getItem("vocabulary-questions");
      if (stored) {
        questions.value = JSON.parse(stored);
        questions.value.forEach((question) => {
          const vocab = vocabularyList.value.find((v) => v.id === question.vocabularyId);
          if (vocab) {
            question.vocabulary = { id: vocab.id, word: vocab.word };
          }
        });
      }
    };
    const saveQuestionsToStorage = () => {
      localStorage.setItem("vocabulary-questions", JSON.stringify(questions.value));
    };
    const editQuestion = (question) => {
      currentQuestion.value = { ...question };
      showEditDialog.value = true;
    };
    const deleteQuestion = (question) => {
      if (confirm(t("vocabulary.questions.confirmDelete", "Are you sure you want to delete this question?"))) {
        questions.value = questions.value.filter((q) => q.id !== question.id);
        saveQuestionsToStorage();
      }
    };
    const saveQuestion = (questionData) => {
      if (currentQuestion.value && showEditDialog.value) {
        const index = questions.value.findIndex((q) => q.id === currentQuestion.value.id);
        if (index !== -1) {
          questions.value[index] = {
            ...questions.value[index],
            vocabularyId: questionData.vocabularyId || questions.value[index].vocabularyId,
            question: questionData.question || questions.value[index].question,
            type: questionData.type || questions.value[index].type,
            options: questionData.options || questions.value[index].options,
            correctAnswer: questionData.correctAnswer || questions.value[index].correctAnswer,
            difficulty: questionData.difficulty || questions.value[index].difficulty,
            explanation: questionData.explanation || questions.value[index].explanation,
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          const vocab = vocabularyList.value.find((v) => v.id === questions.value[index].vocabularyId);
          if (vocab) {
            questions.value[index].vocabulary = { id: vocab.id, word: vocab.word };
          }
        }
      } else {
        const newQuestion = {
          id: Date.now().toString(),
          vocabularyId: questionData.vocabularyId,
          question: questionData.question,
          type: questionData.type,
          options: questionData.options,
          correctAnswer: questionData.correctAnswer,
          difficulty: questionData.difficulty || "medium",
          explanation: questionData.explanation,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        const vocab = vocabularyList.value.find((v) => v.id === newQuestion.vocabularyId);
        if (vocab) {
          newQuestion.vocabulary = { id: vocab.id, word: vocab.word };
        }
        questions.value.push(newQuestion);
      }
      saveQuestionsToStorage();
      closeDialog();
    };
    const openCreateDialog = () => {
      currentQuestion.value = null;
      showCreateDialog.value = true;
    };
    const closeDialog = () => {
      showCreateDialog.value = false;
      showEditDialog.value = false;
      currentQuestion.value = null;
    };
    const getTypeLabel = (type) => {
      const labels = {
        "multiple-choice": t("vocabulary.questions.types.multipleChoice", "Multiple Choice"),
        "fill-blank": t("vocabulary.questions.types.fillBlank", "Fill in the Blank"),
        "true-false": t("vocabulary.questions.types.trueFalse", "True/False"),
        "short-answer": t("vocabulary.questions.types.shortAnswer", "Short Answer")
      };
      return labels[type] || type;
    };
    const getTypeColorClass = (type) => {
      const classes = {
        "multiple-choice": "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300",
        "fill-blank": "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300",
        "true-false": "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300",
        "short-answer": "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-300"
      };
      return classes[type] || "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300";
    };
    const getDifficultyLabel = (difficulty) => {
      if (!difficulty) return "";
      const labels = {
        "easy": t("common.easy", "Easy"),
        "medium": t("vocabulary.questions.difficulty.medium", "Medium"),
        "hard": t("common.difficult", "Difficult")
      };
      return labels[difficulty] || difficulty;
    };
    const getDifficultyColorClass = (difficulty) => {
      const classes = {
        "easy": "text-green-600 dark:text-green-400",
        "medium": "text-yellow-600 dark:text-yellow-400",
        "hard": "text-red-600 dark:text-red-400"
      };
      return classes[difficulty] || "text-gray-600 dark:text-gray-400";
    };
    const formatDate = (dateString) => {
      return new Date(dateString).toLocaleDateString();
    };
    onMounted(() => {
      loadQuestions();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1p, [
        _cache[7] || (_cache[7] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0"><div class="floating-shapes"><div class="absolute top-20 left-10 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob"></div><div class="absolute top-40 right-10 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000"></div><div class="absolute -bottom-8 left-20 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000"></div><div class="hidden sm:block absolute top-10 left-1/2 -translate-x-1/2 w-40 h-40 bg-cyan-300 dark:bg-cyan-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-1000"></div><div class="hidden sm:block absolute bottom-24 right-24 w-52 h-52 bg-indigo-300 dark:bg-indigo-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-3000"></div></div></div>', 1)),
        createBaseVNode("div", _hoisted_2$1m, [
          createBaseVNode("div", _hoisted_3$1j, [
            createBaseVNode("div", _hoisted_4$1e, [
              createBaseVNode("div", _hoisted_5$1b, [
                _cache[3] || (_cache[3] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                  createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-indigo-500 rounded-full mr-2.5" })
                ], -1)),
                createBaseVNode("div", null, [
                  createBaseVNode("h1", _hoisted_6$18, toDisplayString$1(unref(t)("vocabulary.questions.title", "Question Manager")), 1),
                  createBaseVNode("p", _hoisted_7$14, toDisplayString$1(unref(t)("vocabulary.questions.description", "Create and manage questions based on your vocabulary words")), 1)
                ])
              ]),
              createBaseVNode("button", {
                onClick: openCreateDialog,
                class: "px-4 sm:px-6 py-2 sm:py-3 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white rounded-lg font-medium transition-all duration-300 shadow-lg hover:shadow-xl"
              }, toDisplayString$1(unref(t)("vocabulary.questions.addQuestion", "Add New Question")), 1)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_8$12, [
          createBaseVNode("div", _hoisted_9$11, [
            createBaseVNode("div", _hoisted_10$10, [
              _cache[4] || (_cache[4] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full mr-2.5" })
              ], -1)),
              createBaseVNode("h3", _hoisted_11$10, toDisplayString$1(unref(t)("vocabulary.filters.title", "Filters")), 1)
            ]),
            createBaseVNode("div", _hoisted_12$Z, [
              createBaseVNode("div", null, [
                createBaseVNode("label", _hoisted_13$Z, toDisplayString$1(unref(t)("vocabulary.questions.searchQuestions", "Search questions...")), 1),
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchTerm.value = $event),
                  type: "text",
                  placeholder: unref(t)("vocabulary.questions.searchQuestions", "Search questions..."),
                  class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white/50 dark:bg-[#0a0a0a]/50 backdrop-blur-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900 dark:text-white transition-all duration-300"
                }, null, 8, _hoisted_14$Y), [
                  [vModelText, searchTerm.value]
                ])
              ]),
              createBaseVNode("div", null, [
                createBaseVNode("label", _hoisted_15$S, toDisplayString$1(unref(t)("vocabulary.questions.filterByVocabulary", "Filter by vocabulary")), 1),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedVocabulary.value = $event),
                  class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white/50 dark:bg-[#0a0a0a]/50 backdrop-blur-sm text-gray-900 dark:text-white transition-all duration-300"
                }, [
                  createBaseVNode("option", _hoisted_16$R, toDisplayString$1(unref(t)("vocabulary.questions.allVocabulary", "All Vocabulary")), 1),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(vocabularyList.value, (vocab) => {
                    return openBlock(), createElementBlock("option", {
                      key: vocab.id,
                      value: vocab.id
                    }, toDisplayString$1(vocab.word) + " - " + toDisplayString$1(vocab.meaning), 9, _hoisted_17$Q);
                  }), 128))
                ], 512), [
                  [vModelSelect, selectedVocabulary.value]
                ])
              ]),
              createBaseVNode("div", null, [
                createBaseVNode("label", _hoisted_18$O, toDisplayString$1(unref(t)("vocabulary.questions.filterByType", "Filter by type")), 1),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => selectedType.value = $event),
                  class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white/50 dark:bg-[#0a0a0a]/50 backdrop-blur-sm text-gray-900 dark:text-white transition-all duration-300"
                }, [
                  createBaseVNode("option", _hoisted_19$O, toDisplayString$1(unref(t)("vocabulary.questions.allTypes", "All Types")), 1),
                  createBaseVNode("option", _hoisted_20$N, toDisplayString$1(unref(t)("vocabulary.questions.multipleChoice", "Multiple Choice")), 1),
                  createBaseVNode("option", _hoisted_21$N, toDisplayString$1(unref(t)("vocabulary.questions.fillBlank", "Fill in the Blank")), 1),
                  createBaseVNode("option", _hoisted_22$L, toDisplayString$1(unref(t)("vocabulary.questions.trueFalse", "True/False")), 1),
                  createBaseVNode("option", _hoisted_23$L, toDisplayString$1(unref(t)("vocabulary.questions.shortAnswer", "Short Answer")), 1)
                ], 512), [
                  [vModelSelect, selectedType.value]
                ])
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_24$J, [
          createBaseVNode("div", _hoisted_25$J, [
            createBaseVNode("div", _hoisted_26$H, [
              _cache[5] || (_cache[5] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-green-400 to-blue-500 rounded-full mr-2.5" })
              ], -1)),
              createBaseVNode("h3", _hoisted_27$G, toDisplayString$1(unref(t)("vocabulary.questions.title", "Questions List")), 1)
            ]),
            createBaseVNode("div", _hoisted_28$E, [
              filteredQuestions.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_29$C, [
                _cache[6] || (_cache[6] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                  createBaseVNode("div", { class: "w-3 h-3 bg-gradient-to-r from-gray-400 to-gray-500 rounded-full mx-auto mb-3" })
                ], -1)),
                createBaseVNode("p", _hoisted_30$A, toDisplayString$1(unref(t)("vocabulary.questions.noQuestions", "No questions found")), 1)
              ])) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredQuestions.value, (question) => {
                return openBlock(), createElementBlock("div", {
                  key: question.id,
                  class: "bg-white/60 dark:bg-[#0a0a0a]/60 backdrop-blur-sm rounded-xl border border-white/20 dark:border-white/10 p-3 sm:p-4 md:p-5 hover:shadow-lg transition-all duration-300 hover:scale-[1.002]"
                }, [
                  createBaseVNode("div", _hoisted_31$z, [
                    createBaseVNode("div", _hoisted_32$w, [
                      createBaseVNode("div", _hoisted_33$v, [
                        createBaseVNode("span", {
                          class: normalizeClass(["px-2 py-1 text-xs font-medium rounded-full", getTypeColorClass(question.type)])
                        }, toDisplayString$1(getTypeLabel(question.type)), 3),
                        question.difficulty ? (openBlock(), createElementBlock("span", {
                          key: 0,
                          class: normalizeClass(["px-2 py-1 text-xs font-medium rounded-full", getDifficultyColorClass(question.difficulty)])
                        }, toDisplayString$1(getDifficultyLabel(question.difficulty)), 3)) : createCommentVNode("", true),
                        question.vocabulary ? (openBlock(), createElementBlock("span", _hoisted_34$s, toDisplayString$1(question.vocabulary.word), 1)) : createCommentVNode("", true)
                      ]),
                      createBaseVNode("h3", _hoisted_35$s, toDisplayString$1(question.question), 1),
                      question.options && question.type === "multiple-choice" ? (openBlock(), createElementBlock("div", _hoisted_36$r, [
                        createBaseVNode("div", _hoisted_37$q, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(question.options, (option, index) => {
                            return openBlock(), createElementBlock("div", {
                              key: index,
                              class: normalizeClass(["px-3 py-2 bg-white/50 dark:bg-[#0a0a0a]/50 backdrop-blur-sm rounded border border-gray-200 dark:border-white/10", { "border-green-500 bg-green-50/50 dark:bg-green-900/20": index === Number(question.correctAnswer) }])
                            }, toDisplayString$1(option), 3);
                          }), 128))
                        ])
                      ])) : (openBlock(), createElementBlock("div", _hoisted_38$q, [
                        createBaseVNode("p", _hoisted_39$o, [
                          createBaseVNode("strong", null, toDisplayString$1(unref(t)("vocabulary.questions.correctAnswer", "Correct Answer")) + ":", 1),
                          createBaseVNode("span", _hoisted_40$o, toDisplayString$1(question.correctAnswer), 1)
                        ])
                      ])),
                      question.explanation ? (openBlock(), createElementBlock("div", _hoisted_41$n, [
                        createBaseVNode("p", _hoisted_42$l, [
                          createBaseVNode("strong", null, toDisplayString$1(unref(t)("vocabulary.questions.explanation", "Explanation")) + ":", 1),
                          createTextVNode(" " + toDisplayString$1(question.explanation), 1)
                        ])
                      ])) : createCommentVNode("", true),
                      createBaseVNode("p", _hoisted_43$k, toDisplayString$1(unref(t)("vocabulary.questions.createdAt", "Created At")) + ": " + toDisplayString$1(formatDate(question.createdAt)), 1)
                    ]),
                    createBaseVNode("div", _hoisted_44$j, [
                      createBaseVNode("button", {
                        onClick: ($event) => editQuestion(question),
                        class: "px-3 py-2 text-blue-600 hover:text-blue-700 hover:bg-blue-50/50 dark:text-blue-400 dark:hover:text-blue-300 dark:hover:bg-blue-900/20 rounded-lg transition-all duration-300"
                      }, toDisplayString$1(unref(t)("common.edit", "Edit")), 9, _hoisted_45$i),
                      createBaseVNode("button", {
                        onClick: ($event) => deleteQuestion(question),
                        class: "px-3 py-2 text-red-600 hover:text-red-700 hover:bg-red-50/50 dark:text-red-400 dark:hover:text-red-300 dark:hover:bg-red-900/20 rounded-lg transition-all duration-300"
                      }, toDisplayString$1(unref(t)("common.delete", "Delete")), 9, _hoisted_46$i)
                    ])
                  ])
                ]);
              }), 128))
            ])
          ])
        ]),
        showCreateDialog.value || showEditDialog.value ? (openBlock(), createBlock(unref(QuestionFormDialog$1), {
          key: 0,
          show: showCreateDialog.value || showEditDialog.value,
          question: currentQuestion.value,
          "vocabulary-list": vocabularyList.value,
          onClose: closeDialog,
          onSave: saveQuestion
        }, null, 8, ["show", "question", "vocabulary-list"])) : createCommentVNode("", true)
      ]);
    };
  }
});

class AudioSystem {
  voiceStore = useVoiceStore();
  createAudioContext() {
    try {
      return new (window.AudioContext || window.webkitAudioContext)();
    } catch (error) {
      console.log("Audio context not available");
      return null;
    }
  }
  playImpactSound() {
    const audioContext = this.createAudioContext();
    if (!audioContext) return;
    try {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
      gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
      oscillator.type = "sine";
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.15);
    } catch (error) {
      console.log("Impact sound failed:", error);
    }
  }
  playExplosionSound() {
    const audioContext = this.createAudioContext();
    if (!audioContext) return;
    try {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      const filterNode = audioContext.createBiquadFilter();
      oscillator.connect(filterNode);
      filterNode.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.3);
      filterNode.frequency.setValueAtTime(2e3, audioContext.currentTime);
      filterNode.frequency.exponentialRampToValueAtTime(500, audioContext.currentTime + 0.3);
      filterNode.Q.setValueAtTime(3, audioContext.currentTime);
      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      oscillator.type = "sawtooth";
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.3);
    } catch (error) {
      console.log("Explosion sound failed:", error);
    }
  }
  playBounceSound() {
    const audioContext = this.createAudioContext();
    if (!audioContext) return;
    try {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.08);
      gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
      oscillator.type = "triangle";
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.08);
    } catch (error) {
      console.log("Bounce sound failed:", error);
    }
  }
  playVocabularySound(text, language = "en") {
    try {
      if (!("speechSynthesis" in window)) {
        console.log("Speech Synthesis not supported");
        return;
      }
      window.speechSynthesis.cancel();
      const utterance = this.voiceStore.createUtterance(text);
      if (language === "vi") {
        utterance.lang = "vi-VN";
        const vietnameseVoices = window.speechSynthesis.getVoices().filter(
          (voice) => voice.lang.startsWith("vi")
        );
        if (vietnameseVoices.length > 0) {
          utterance.voice = vietnameseVoices[0];
        }
      } else if (language === "ko") {
        utterance.lang = "ko-KR";
        const koreanVoices = window.speechSynthesis.getVoices().filter(
          (voice) => voice.lang.startsWith("ko")
        );
        if (koreanVoices.length > 0) {
          utterance.voice = koreanVoices[0];
        }
      }
      window.speechSynthesis.speak(utterance);
    } catch (error) {
      console.log("Vocabulary sound failed:", error);
    }
  }
}
const useAudioSystem = () => {
  return new AudioSystem();
};

const _hoisted_1$1o = { class: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative overflow-x-hidden" };
const _hoisted_2$1l = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto px-2 xs:px-3 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 pt-3 sm:pt-6" };
const _hoisted_3$1i = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6 mb-3 xs:mb-4 sm:mb-6" };
const _hoisted_4$1d = { class: "flex flex-col xs:flex-col sm:flex-row items-start xs:items-start sm:items-center justify-between mb-3 xs:mb-3 sm:mb-4 gap-3 xs:gap-3 sm:gap-4" };
const _hoisted_5$1a = { class: "flex items-center" };
const _hoisted_6$17 = { class: "text-base xs:text-lg sm:text-xl md:text-xl font-bold bg-gradient-to-r from-green-600 to-emerald-600 dark:from-green-400 dark:to-emerald-400 bg-clip-text text-transparent mb-1 xs:mb-1 sm:mb-2" };
const _hoisted_7$13 = { class: "text-xs xs:text-sm sm:text-base md:text-base text-gray-600 dark:text-gray-300" };
const _hoisted_8$11 = { class: "flex items-center space-x-2 xs:space-x-3 sm:space-x-4" };
const _hoisted_9$10 = { class: "flex items-center space-x-2 xs:space-x-2 sm:space-x-3" };
const _hoisted_10$$ = { class: "text-xs xs:text-sm sm:text-sm md:text-sm font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_11$$ = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto py-3 px-2 xs:py-4 xs:px-3 sm:py-6 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 overflow-x-hidden" };
const _hoisted_12$Y = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] mb-3 xs:mb-4 sm:mb-6 p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_13$Y = { class: "flex items-center mb-3 xs:mb-3 sm:mb-4" };
const _hoisted_14$X = { class: "text-sm xs:text-base sm:text-lg md:text-lg font-semibold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent" };
const _hoisted_15$R = { class: "relative" };
const _hoisted_16$Q = ["placeholder"];
const _hoisted_17$P = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto py-3 px-2 xs:py-4 xs:px-3 sm:py-6 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 overflow-x-hidden" };
const _hoisted_18$N = { class: "space-y-6" };
const _hoisted_19$N = {
  key: 0,
  class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6"
};
const _hoisted_20$M = { class: "text-center py-6 xs:py-6 sm:py-8" };
const _hoisted_21$M = { class: "text-base xs:text-lg sm:text-lg md:text-lg font-medium text-gray-900 dark:text-white mb-1 xs:mb-1 sm:mb-2" };
const _hoisted_22$K = { class: "text-xs xs:text-sm sm:text-base md:text-base text-gray-600 dark:text-gray-300" };
const _hoisted_23$K = ["onClick"];
const _hoisted_24$I = { class: "flex items-start space-x-2 xs:space-x-2 sm:space-x-3 flex-1" };
const _hoisted_25$I = { class: "flex-1 min-w-0" };
const _hoisted_26$G = { class: "flex items-center space-x-1 xs:space-x-1 sm:space-x-2 mb-1" };
const _hoisted_27$F = { class: "text-base xs:text-lg sm:text-lg md:text-lg font-bold text-gray-900 dark:text-white truncate" };
const _hoisted_28$D = ["onClick", "title"];
const _hoisted_29$B = ["onClick", "title"];
const _hoisted_30$z = { class: "text-xs xs:text-sm sm:text-sm md:text-sm text-gray-600 dark:text-gray-300 mb-1 xs:mb-1 sm:mb-2" };
const _hoisted_31$y = { class: "flex items-center space-x-1 xs:space-x-1 sm:space-x-2" };
const _hoisted_32$v = { class: "inline-flex items-center px-1.5 xs:px-2 sm:px-2.5 py-0.5 rounded-full text-2xs xs:text-xs sm:text-xs font-medium bg-blue-100 text-blue-800 dark:bg-blue-900/20 dark:text-blue-300" };
const _hoisted_33$u = { class: "text-2xs xs:text-xs sm:text-xs text-gray-500 dark:text-gray-400" };
const _hoisted_34$r = ["onClick"];
const _hoisted_35$r = { class: "hidden xs:inline sm:inline" };
const _hoisted_36$q = { class: "xs:hidden sm:hidden" };
const _hoisted_37$p = {
  key: 0,
  class: "border-t border-slate-200 dark:border-dark-bg-mute bg-slate-50 dark:bg-dark-bg-mute"
};
const _hoisted_38$p = {
  key: 0,
  class: "p-3 xs:p-4 sm:p-6 text-center text-slate-500 dark:text-slate-400"
};
const _hoisted_39$n = { class: "text-xs xs:text-sm sm:text-base" };
const _hoisted_40$n = { key: 1 };
const _hoisted_41$m = { class: "p-2 xs:p-3 sm:p-4 space-y-2 xs:space-y-3 sm:space-y-4" };
const _hoisted_42$k = { class: "flex flex-col sm:flex-row sm:items-start sm:justify-between gap-2 xs:gap-2 sm:gap-3" };
const _hoisted_43$j = { class: "flex-1 min-w-0" };
const _hoisted_44$i = { class: "flex items-center gap-1 xs:gap-1 sm:gap-2 mb-1 xs:mb-1 sm:mb-2" };
const _hoisted_45$h = { class: "text-xs xs:text-sm sm:text-sm md:text-sm font-medium text-slate-900 dark:text-slate-100 truncate flex-1" };
const _hoisted_46$h = ["onClick", "title"];
const _hoisted_47$h = { class: "text-slate-700 dark:text-slate-300 text-xs xs:text-sm sm:text-sm md:text-sm mb-1 xs:mb-1 sm:mb-2 leading-relaxed" };
const _hoisted_48$h = { class: "flex flex-wrap gap-1 xs:gap-1 sm:gap-2 text-2xs xs:text-xs sm:text-xs" };
const _hoisted_49$g = { class: "px-1.5 xs:px-2 sm:px-2 py-0.5 bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200 rounded-full capitalize" };
const _hoisted_50$f = {
  key: 0,
  class: "px-1.5 xs:px-2 sm:px-2 py-0.5 bg-orange-100 dark:bg-orange-900/30 text-orange-800 dark:text-orange-200 rounded-full capitalize"
};
const _hoisted_51$e = {
  key: 1,
  class: "px-1.5 xs:px-2 sm:px-2 py-0.5 bg-purple-100 dark:bg-purple-900/30 text-purple-800 dark:text-purple-200 rounded-full"
};
const _hoisted_52$d = { class: "flex flex-row xs:flex-row sm:flex-row gap-1 xs:gap-1 sm:gap-2 flex-shrink-0 mt-2 xs:mt-0 sm:mt-0" };
const _hoisted_53$d = ["onClick"];
const _hoisted_54$d = { class: "hidden xs:inline sm:inline" };
const _hoisted_55$d = ["onClick"];
const _hoisted_56$c = { class: "hidden xs:inline sm:inline" };
const _hoisted_57$c = {
  key: 0,
  class: "border-t border-slate-200 dark:border-dark-bg-mute px-2 xs:px-3 sm:px-4 py-2 xs:py-2 sm:py-3"
};
const _hoisted_58$c = { class: "flex items-center justify-between" };
const _hoisted_59$b = { class: "flex sm:hidden items-center gap-1 xs:gap-1 sm:gap-2" };
const _hoisted_60$b = ["onClick", "disabled"];
const _hoisted_61$a = { class: "text-2xs xs:text-xs text-slate-600 dark:text-slate-400 px-1" };
const _hoisted_62$a = ["onClick", "disabled"];
const _hoisted_63$8 = { class: "hidden sm:flex items-center gap-2" };
const _hoisted_64$8 = ["onClick", "disabled"];
const _hoisted_65$8 = { class: "flex gap-1" };
const _hoisted_66$8 = ["onClick"];
const _hoisted_67$7 = ["onClick", "disabled"];
const _hoisted_68$6 = { class: "text-2xs xs:text-xs sm:text-xs text-slate-500 dark:text-slate-400" };
const _hoisted_69$6 = {
  key: 0,
  class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-4"
};
const _hoisted_70$6 = { class: "flex items-center justify-between" };
const _hoisted_71$6 = { class: "flex-1 flex justify-between sm:hidden" };
const _hoisted_72$6 = ["disabled"];
const _hoisted_73$6 = { class: "flex items-center px-2" };
const _hoisted_74$6 = { class: "text-2xs xs:text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_75$5 = ["disabled"];
const _hoisted_76$5 = { class: "hidden sm:flex-1 sm:flex sm:items-center sm:justify-between" };
const _hoisted_77$5 = { class: "text-xs xs:text-sm sm:text-sm md:text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_78$4 = { class: "relative z-0 inline-flex rounded-md shadow-sm -space-x-px" };
const _hoisted_79$4 = ["disabled"];
const _hoisted_80$4 = { class: "sr-only" };
const _hoisted_81$4 = ["onClick"];
const _hoisted_82$4 = ["disabled"];
const _hoisted_83$4 = { class: "sr-only" };
const _sfc_main$1p = /* @__PURE__ */ defineComponent({
  __name: "VocabularyExamplesView",
  setup(__props) {
    const TopicGroupAccordion = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => TopicGroupAccordion$1),true              ?void 0:void 0));
    const ExampleFormDialog$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ExampleFormDialog),true              ?void 0:void 0));
    const ConfirmToast$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ConfirmToast),true              ?void 0:void 0));
    const { t } = useI18n();
    const toast = useToast();
    const vocabularyStore = useVocabularyStore();
    const audioSystem = useAudioSystem();
    const examples = ref([]);
    const showCreateDialog = ref(false);
    const showEditDialog = ref(false);
    const currentExample = ref(null);
    const searchTerm = ref("");
    const selectedVocabulary = ref("");
    const selectedType = ref("");
    const groupByTopic = ref(false);
    const currentPage = ref(1);
    const itemsPerPage = ref(5);
    const expandedExamples = ref({});
    const examplePages = ref({});
    const examplesPerPage = ref(5);
    const vocabularyList = computed(() => vocabularyStore.allVocabularies.value.map((v) => ({
      id: v.id.toString(),
      word: v.word,
      meaning: v.meaning,
      partOfSpeech: v.partOfSpeech || "unknown",
      category: v.category || "uncategorized",
      level: v.level || "unknown"
    })));
    const filteredVocabulary = computed(() => {
      let filtered = vocabularyList.value;
      if (searchTerm.value) {
        const term = searchTerm.value.toLowerCase();
        filtered = filtered.filter(
          (v) => v.word.toLowerCase().includes(term) || v.meaning.toLowerCase().includes(term)
        );
      }
      return filtered;
    });
    const totalPages = computed(() => {
      if (groupByTopic.value) return 1;
      return Math.ceil(filteredVocabulary.value.length / itemsPerPage.value);
    });
    const paginatedVocabulary = computed(() => {
      if (groupByTopic.value) return filteredVocabulary.value;
      const start = (currentPage.value - 1) * itemsPerPage.value;
      const end = start + itemsPerPage.value;
      return filteredVocabulary.value.slice(start, end);
    });
    const startIndex = computed(() => {
      if (groupByTopic.value) return 1;
      return (currentPage.value - 1) * itemsPerPage.value + 1;
    });
    const endIndex = computed(() => {
      if (groupByTopic.value) return filteredVocabulary.value.length;
      return Math.min(currentPage.value * itemsPerPage.value, filteredVocabulary.value.length);
    });
    const visiblePages = computed(() => {
      const pages = [];
      const maxVisible = 5;
      const totalP = totalPages.value;
      if (totalP <= maxVisible) {
        for (let i = 1; i <= totalP; i++) {
          pages.push(i);
        }
      } else {
        const start = Math.max(1, currentPage.value - Math.floor(maxVisible / 2));
        const end = Math.min(totalP, start + maxVisible - 1);
        for (let i = start; i <= end; i++) {
          pages.push(i);
        }
      }
      return pages;
    });
    computed(() => {
      let filtered = examples.value;
      if (searchTerm.value) {
        const term = searchTerm.value.toLowerCase();
        filtered = filtered.filter(
          (e) => e.title.toLowerCase().includes(term) || e.content.toLowerCase().includes(term) || e.vocabulary?.word.toLowerCase().includes(term)
        );
      }
      if (selectedVocabulary.value) {
        filtered = filtered.filter((e) => e.vocabularyId === selectedVocabulary.value);
      }
      if (selectedType.value) {
        filtered = filtered.filter((e) => e.type === selectedType.value);
      }
      return filtered;
    });
    const loadExamples = () => {
      const stored = localStorage.getItem("vocabulary-examples");
      if (stored) {
        examples.value = JSON.parse(stored);
        examples.value.forEach((example) => {
          const vocab = vocabularyList.value.find((v) => v.id === example.vocabularyId);
          if (vocab) {
            example.vocabulary = { id: vocab.id, word: vocab.word };
          }
        });
      }
    };
    const saveExamplesToStorage = () => {
      localStorage.setItem("vocabulary-examples", JSON.stringify(examples.value));
    };
    const getVocabExamples = (vocabId) => {
      return examples.value.filter((e) => e.vocabularyId === vocabId);
    };
    const getPaginatedVocabExamples = (vocabId) => {
      const allExamples = getVocabExamples(vocabId);
      const currentPage2 = examplePages.value[vocabId] || 1;
      const start = (currentPage2 - 1) * examplesPerPage.value;
      const end = start + examplesPerPage.value;
      return allExamples.slice(start, end);
    };
    const getVocabExamplePages = (vocabId) => {
      const totalExamples = getVocabExamples(vocabId).length;
      return Math.ceil(totalExamples / examplesPerPage.value);
    };
    const goToExamplePage = (vocabId, page) => {
      const totalPages2 = getVocabExamplePages(vocabId);
      if (page >= 1 && page <= totalPages2) {
        examplePages.value[vocabId] = page;
        saveExamplePagesState();
      }
    };
    const previousExamplePage = (vocabId) => {
      const currentPage2 = examplePages.value[vocabId] || 1;
      if (currentPage2 > 1) {
        goToExamplePage(vocabId, currentPage2 - 1);
      }
    };
    const nextExamplePage = (vocabId) => {
      const currentPage2 = examplePages.value[vocabId] || 1;
      const totalPages2 = getVocabExamplePages(vocabId);
      if (currentPage2 < totalPages2) {
        goToExamplePage(vocabId, currentPage2 + 1);
      }
    };
    const getExamplePaginationInfo = (vocabId) => {
      const totalExamples = getVocabExamples(vocabId).length;
      const currentPage2 = examplePages.value[vocabId] || 1;
      const totalPages2 = getVocabExamplePages(vocabId);
      const start = (currentPage2 - 1) * examplesPerPage.value + 1;
      const end = Math.min(currentPage2 * examplesPerPage.value, totalExamples);
      return {
        totalExamples,
        totalPages: totalPages2,
        currentPage: currentPage2,
        start,
        end,
        hasNext: currentPage2 < totalPages2,
        hasPrevious: currentPage2 > 1
      };
    };
    const getVocabExampleCount = (vocabId) => {
      return examples.value.filter((e) => e.vocabularyId === vocabId).length;
    };
    const openCreateDialogForVocab = (vocab) => {
      currentExample.value = null;
      selectedVocabulary.value = vocab.id;
      showCreateDialog.value = true;
    };
    const editExample = (example) => {
      currentExample.value = { ...example };
      showEditDialog.value = true;
    };
    const deleteExample = (example) => {
      const toastId = toast(
        {
          component: ConfirmToast$1,
          props: {
            message: t("vocabulary.examples.confirmDelete", "Are you sure you want to delete this example?"),
            confirmText: t("common.confirm", "Confirm"),
            cancelText: t("common.cancel", "Cancel"),
            onConfirm: () => {
              examples.value = examples.value.filter((e) => e.id !== example.id);
              saveExamplesToStorage();
              toast.dismiss(toastId);
              toast.success(t("vocabulary.examples.deleteSuccess", "Example deleted successfully"));
            },
            onCancel: () => {
              toast.dismiss(toastId);
            }
          }
        },
        {
          position: POSITION.TOP_CENTER,
          timeout: false,
          closeButton: false,
          draggable: false,
          icon: false
        }
      );
    };
    const saveExample = (exampleData) => {
      if (currentExample.value && showEditDialog.value) {
        const index = examples.value.findIndex((e) => e.id === currentExample.value.id);
        if (index !== -1) {
          examples.value[index] = {
            ...examples.value[index],
            ...exampleData,
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          const vocab = vocabularyList.value.find((v) => v.id === examples.value[index].vocabularyId);
          if (vocab) {
            examples.value[index].vocabulary = { id: vocab.id, word: vocab.word };
          }
        }
      } else {
        const newExample = {
          id: Date.now().toString(),
          vocabularyId: exampleData.vocabularyId,
          title: exampleData.title,
          content: exampleData.content,
          translation: exampleData.translation,
          context: exampleData.context,
          type: exampleData.type,
          difficulty: exampleData.difficulty,
          tags: exampleData.tags,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        const vocab = vocabularyList.value.find((v) => v.id === newExample.vocabularyId);
        if (vocab) {
          newExample.vocabulary = { id: vocab.id, word: vocab.word };
        }
        examples.value.push(newExample);
      }
      saveExamplesToStorage();
      closeDialog();
    };
    const closeDialog = () => {
      showCreateDialog.value = false;
      showEditDialog.value = false;
      currentExample.value = null;
    };
    const playVocabularyAudio = (word) => {
      audioSystem.playVocabularySound(word, "en");
    };
    const previousPage = () => {
      if (currentPage.value > 1) {
        currentPage.value--;
      }
    };
    const nextPage = () => {
      if (currentPage.value < totalPages.value) {
        currentPage.value++;
      }
    };
    const goToPage = (page) => {
      if (page >= 1 && page <= totalPages.value) {
        currentPage.value = page;
      }
    };
    const toggleVocabExamples = (vocabId) => {
      expandedExamples.value[vocabId] = !expandedExamples.value[vocabId];
      saveExpandedExamplesState();
    };
    const loadExpandedExamplesState = () => {
      try {
        const saved = localStorage.getItem("vocabulary-examples-expanded-vocab");
        if (saved) {
          const parsed = JSON.parse(saved);
          expandedExamples.value = { ...parsed };
        }
      } catch (error) {
        console.error("Error loading expanded examples state:", error);
      }
    };
    const saveExpandedExamplesState = () => {
      try {
        localStorage.setItem("vocabulary-examples-expanded-vocab", JSON.stringify(expandedExamples.value));
      } catch (error) {
        console.error("Error saving expanded examples state:", error);
      }
    };
    const loadExamplePagesState = () => {
      try {
        const saved = localStorage.getItem("vocabulary-examples-pages");
        if (saved) {
          const parsed = JSON.parse(saved);
          examplePages.value = { ...parsed };
        }
      } catch (error) {
        console.error("Error loading example pages state:", error);
      }
    };
    const saveExamplePagesState = () => {
      try {
        localStorage.setItem("vocabulary-examples-pages", JSON.stringify(examplePages.value));
      } catch (error) {
        console.error("Error saving example pages state:", error);
      }
    };
    const initializeExpandedExamplesState = () => {
      let hasChanges = false;
      paginatedVocabulary.value.forEach((vocab) => {
        if (expandedExamples.value[vocab.id] === void 0) {
          expandedExamples.value[vocab.id] = false;
          hasChanges = true;
        }
        if (examplePages.value[vocab.id] === void 0) {
          examplePages.value[vocab.id] = 1;
          hasChanges = true;
        }
      });
      if (hasChanges) {
        saveExpandedExamplesState();
        saveExamplePagesState();
      }
    };
    const cleanupOldVocabularyStates = () => {
      try {
        const currentVocabIds = new Set(vocabularyList.value.map((v) => v.id));
        const expandedKeys = Object.keys(expandedExamples.value);
        let expandedChanged = false;
        expandedKeys.forEach((vocabId) => {
          if (!currentVocabIds.has(vocabId)) {
            delete expandedExamples.value[vocabId];
            expandedChanged = true;
          }
        });
        const pagesKeys = Object.keys(examplePages.value);
        let pagesChanged = false;
        pagesKeys.forEach((vocabId) => {
          if (!currentVocabIds.has(vocabId)) {
            delete examplePages.value[vocabId];
            pagesChanged = true;
          }
        });
        if (expandedChanged) {
          saveExpandedExamplesState();
        }
        if (pagesChanged) {
          saveExamplePagesState();
        }
      } catch (error) {
        console.error("Error cleaning up old vocabulary states:", error);
      }
    };
    const examplesEnter = (el) => {
      const element = el;
      element.style.height = "0";
      element.style.overflow = "hidden";
    };
    const examplesAfterEnter = (el) => {
      const element = el;
      element.style.height = "auto";
      element.style.overflow = "visible";
    };
    const examplesEnterCancelled = (el) => {
      const element = el;
      element.style.height = "auto";
      element.style.overflow = "visible";
    };
    const examplesBeforeLeave = (el) => {
      const element = el;
      element.style.height = element.scrollHeight + "px";
      element.style.overflow = "hidden";
    };
    const examplesLeave = (el) => {
      const element = el;
      element.style.height = element.scrollHeight + "px";
      element.style.overflow = "hidden";
      element.offsetHeight;
      element.style.height = "0";
    };
    const examplesAfterLeave = (el) => {
      const element = el;
      element.style.height = "auto";
      element.style.overflow = "visible";
    };
    const toggleGrouping = () => {
      groupByTopic.value = !groupByTopic.value;
      localStorage.setItem("vocabulary-examples-group-by-topic", JSON.stringify(groupByTopic.value));
    };
    const loadGroupingPreference = () => {
      try {
        const saved = localStorage.getItem("vocabulary-examples-group-by-topic");
        if (saved) {
          groupByTopic.value = JSON.parse(saved);
        }
      } catch (error) {
        console.error("Error loading grouping preference:", error);
        groupByTopic.value = false;
      }
    };
    watch(() => paginatedVocabulary.value, () => {
      initializeExpandedExamplesState();
    }, { immediate: true });
    watch(() => vocabularyList.value, () => {
      cleanupOldVocabularyStates();
    }, { deep: true });
    watch(() => expandedExamples.value, () => {
      saveExpandedExamplesState();
    }, { deep: true });
    watch(() => examplePages.value, () => {
      saveExamplePagesState();
    }, { deep: true });
    onMounted(() => {
      loadExamples();
      loadGroupingPreference();
      loadExpandedExamplesState();
      loadExamplePagesState();
      setTimeout(() => {
        cleanupOldVocabularyStates();
      }, 100);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1o, [
        _cache[15] || (_cache[15] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0" data-v-42779dea><div class="floating-shapes" data-v-42779dea><div class="absolute top-20 left-10 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob" data-v-42779dea></div><div class="absolute top-40 right-10 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000" data-v-42779dea></div><div class="absolute -bottom-8 left-20 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000" data-v-42779dea></div><div class="hidden sm:block absolute top-10 left-1/2 -translate-x-1/2 w-40 h-40 bg-cyan-300 dark:bg-cyan-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-1000" data-v-42779dea></div><div class="hidden sm:block absolute bottom-24 right-24 w-52 h-52 bg-indigo-300 dark:bg-indigo-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-25 animate-blob animation-delay-3000" data-v-42779dea></div></div></div>', 1)),
        createBaseVNode("div", _hoisted_2$1l, [
          createBaseVNode("div", _hoisted_3$1i, [
            createBaseVNode("div", _hoisted_4$1d, [
              createBaseVNode("div", _hoisted_5$1a, [
                _cache[1] || (_cache[1] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                  createBaseVNode("div", { class: "w-2 xs:w-2.5 sm:w-2.5 h-2 xs:h-2.5 sm:h-2.5 bg-gradient-to-r from-green-400 to-emerald-500 rounded-full mr-2 xs:mr-2.5 sm:mr-2.5" })
                ], -1)),
                createBaseVNode("div", null, [
                  createBaseVNode("h1", _hoisted_6$17, toDisplayString$1(unref(t)("vocabulary.examples.title", "Example Manager")), 1),
                  createBaseVNode("p", _hoisted_7$13, toDisplayString$1(unref(t)("vocabulary.examples.description", "Create and manage example sentences based on your vocabulary words")), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_8$11, [
                createBaseVNode("div", _hoisted_9$10, [
                  createBaseVNode("span", _hoisted_10$$, toDisplayString$1(unref(t)("vocabulary.examples.groupByTopic", "Group by Topic")), 1),
                  createBaseVNode("button", {
                    onClick: toggleGrouping,
                    class: normalizeClass(["relative inline-flex h-5 xs:h-6 sm:h-6 w-9 xs:w-11 sm:w-11 items-center rounded-full transition-colors duration-300", groupByTopic.value ? "bg-gradient-to-r from-green-600 to-emerald-600" : "bg-gray-200 dark:bg-[#0a0a0a]"])
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(["inline-block h-3 xs:h-4 sm:h-4 w-3 xs:w-4 sm:w-4 transform rounded-full bg-white transition-transform duration-300 shadow-lg", groupByTopic.value ? "translate-x-5 xs:translate-x-6 sm:translate-x-6" : "translate-x-1"])
                    }, null, 2)
                  ], 2)
                ])
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_11$$, [
          createBaseVNode("div", _hoisted_12$Y, [
            createBaseVNode("div", _hoisted_13$Y, [
              _cache[2] || (_cache[2] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                createBaseVNode("div", { class: "w-2 xs:w-2.5 sm:w-2.5 h-2 xs:h-2.5 sm:h-2.5 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full mr-2 xs:mr-2.5 sm:mr-2.5" })
              ], -1)),
              createBaseVNode("h3", _hoisted_14$X, toDisplayString$1(unref(t)("common.search", "Search")), 1)
            ]),
            createBaseVNode("div", _hoisted_15$R, [
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchTerm.value = $event),
                type: "text",
                placeholder: unref(t)("vocabulary.examples.searchVocabulary", "Search vocabulary words..."),
                class: "w-full pl-8 xs:pl-9 sm:pl-10 md:pl-10 pr-3 xs:pr-4 sm:pr-4 py-1.5 xs:py-2 sm:py-2 md:py-2 text-sm xs:text-sm sm:text-base md:text-base border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white/50 dark:bg-[#0a0a0a]/50 backdrop-blur-sm focus:ring-2 focus:ring-green-500 focus:border-transparent text-gray-900 dark:text-white transition-all duration-300"
              }, null, 8, _hoisted_16$Q), [
                [vModelText, searchTerm.value]
              ]),
              _cache[3] || (_cache[3] = createBaseVNode("svg", {
                class: "absolute left-2 xs:left-2.5 sm:left-3 top-1.5 xs:top-2 sm:top-2.5 h-4 xs:h-4 sm:h-5 w-4 xs:w-4 sm:w-5 text-gray-400",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                })
              ], -1))
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_17$P, [
          createBaseVNode("div", _hoisted_18$N, [
            filteredVocabulary.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_19$N, [
              createBaseVNode("div", _hoisted_20$M, [
                _cache[4] || (_cache[4] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                  createBaseVNode("div", { class: "w-2.5 xs:w-3 sm:w-3 h-2.5 xs:h-3 sm:h-3 bg-gradient-to-r from-gray-400 to-gray-500 rounded-full mx-auto mb-2 xs:mb-2 sm:mb-3" })
                ], -1)),
                _cache[5] || (_cache[5] = createBaseVNode("svg", {
                  class: "mx-auto h-8 xs:h-10 sm:h-12 w-8 xs:w-10 sm:w-12 text-gray-400 mb-3 xs:mb-3 sm:mb-4",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                  })
                ], -1)),
                createBaseVNode("h3", _hoisted_21$M, toDisplayString$1(unref(t)("vocabulary.examples.noVocabulary", "No vocabulary words found")), 1),
                createBaseVNode("p", _hoisted_22$K, toDisplayString$1(unref(t)("vocabulary.examples.noVocabularyDescription", "Add some vocabulary words first to create examples for them.")), 1)
              ])
            ])) : !groupByTopic.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(paginatedVocabulary.value, (vocab) => {
                return openBlock(), createElementBlock("div", {
                  key: vocab.id,
                  class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6"
                }, [
                  createBaseVNode("div", {
                    onClick: ($event) => toggleVocabExamples(vocab.id),
                    class: "flex flex-col xs:flex-col sm:flex-row items-start justify-between mb-3 xs:mb-3 sm:mb-4 pb-2 xs:pb-2 sm:pb-3 border-b border-gray-200/50 dark:border-gray-700/50 gap-3 xs:gap-3 sm:gap-0"
                  }, [
                    createBaseVNode("div", _hoisted_24$I, [
                      _cache[8] || (_cache[8] = createBaseVNode("div", { class: "animate-pulse-slow mt-1" }, [
                        createBaseVNode("div", { class: "w-2 xs:w-2.5 sm:w-2.5 h-2 xs:h-2.5 sm:h-2.5 bg-gradient-to-r from-green-400 to-blue-500 rounded-full" })
                      ], -1)),
                      createBaseVNode("div", _hoisted_25$I, [
                        createBaseVNode("div", _hoisted_26$G, [
                          createBaseVNode("h3", _hoisted_27$F, toDisplayString$1(vocab.word), 1),
                          createBaseVNode("button", {
                            onClick: withModifiers(($event) => playVocabularyAudio(vocab.word), ["stop"]),
                            class: "p-1 xs:p-1.5 sm:p-1.5 text-blue-600 hover:text-blue-700 hover:bg-blue-50/50 dark:text-blue-400 dark:hover:text-blue-300 dark:hover:bg-blue-900/20 rounded-lg transition-all duration-300 group flex-shrink-0",
                            title: unref(t)("vocabulary.examples.playPronunciation", "Play pronunciation")
                          }, _cache[6] || (_cache[6] = [
                            createBaseVNode("svg", {
                              class: "w-3 xs:w-4 sm:w-4 h-3 xs:h-4 sm:h-4 group-hover:scale-110 transition-transform duration-200",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M15.536 8.464a5 5 0 010 7.072m2.464-9.536a9 9 0 010 12.728M9 9l3-3v6l-3-3H4a1 1 0 01-1-1V10a1 1 0 011-1h5z"
                              })
                            ], -1)
                          ]), 8, _hoisted_28$D),
                          getVocabExampleCount(vocab.id) > 0 ? (openBlock(), createElementBlock("button", {
                            key: 0,
                            onClick: withModifiers(($event) => toggleVocabExamples(vocab.id), ["stop"]),
                            class: "p-1 xs:p-1.5 sm:p-1.5 text-gray-600 hover:text-gray-700 hover:bg-gray-50/50 dark:text-gray-400 dark:hover:text-gray-300 dark:hover:bg-[#0a0a0a]/20 rounded-lg transition-all duration-300 group flex-shrink-0",
                            title: expandedExamples.value[vocab.id] ? unref(t)("vocabulary.examples.hideExamples", "Hide examples") : unref(t)("vocabulary.examples.showExamples", "Show examples")
                          }, [
                            (openBlock(), createElementBlock("svg", {
                              class: normalizeClass(["w-3 xs:w-4 sm:w-4 h-3 xs:h-4 sm:h-4 group-hover:scale-110 transition-all duration-200", { "rotate-180": expandedExamples.value[vocab.id] }]),
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, _cache[7] || (_cache[7] = [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M19 9l-7 7-7-7"
                              }, null, -1)
                            ]), 2))
                          ], 8, _hoisted_29$B)) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("p", _hoisted_30$z, toDisplayString$1(vocab.meaning), 1),
                        createBaseVNode("div", _hoisted_31$y, [
                          createBaseVNode("span", _hoisted_32$v, toDisplayString$1(vocab.partOfSpeech), 1),
                          createBaseVNode("span", _hoisted_33$u, toDisplayString$1(getVocabExampleCount(vocab.id)) + " " + toDisplayString$1(getVocabExampleCount(vocab.id) === 1 ? "example" : "examples"), 1)
                        ])
                      ])
                    ]),
                    createBaseVNode("button", {
                      onClick: withModifiers(($event) => openCreateDialogForVocab(vocab), ["stop"]),
                      class: "px-2 xs:px-2.5 sm:px-3 py-1.5 xs:py-1.5 sm:py-2 text-xs xs:text-xs sm:text-sm bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 text-white rounded-lg font-medium transition-all duration-300 shadow-lg hover:shadow-xl flex items-center space-x-1 xs:space-x-1 sm:space-x-2 flex-shrink-0"
                    }, [
                      _cache[9] || (_cache[9] = createBaseVNode("svg", {
                        class: "w-3 xs:w-3 sm:w-4 h-3 xs:h-3 sm:h-4",
                        fill: "none",
                        stroke: "currentColor",
                        viewBox: "0 0 24 24"
                      }, [
                        createBaseVNode("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M12 4v16m8-8H4"
                        })
                      ], -1)),
                      createBaseVNode("span", _hoisted_35$r, toDisplayString$1(unref(t)("vocabulary.examples.addExample", "Add Example")), 1),
                      createBaseVNode("span", _hoisted_36$q, toDisplayString$1(unref(t)("common.add", "Add")), 1)
                    ], 8, _hoisted_34$r)
                  ], 8, _hoisted_23$K),
                  createVNode(Transition, {
                    name: "examples-accordion",
                    onEnter: examplesEnter,
                    onAfterEnter: examplesAfterEnter,
                    onEnterCancelled: examplesEnterCancelled,
                    onBeforeLeave: examplesBeforeLeave,
                    onLeave: examplesLeave,
                    onAfterLeave: examplesAfterLeave
                  }, {
                    default: withCtx(() => [
                      expandedExamples.value[vocab.id] ? (openBlock(), createElementBlock("div", _hoisted_37$p, [
                        getVocabExamples(vocab.id).length === 0 ? (openBlock(), createElementBlock("div", _hoisted_38$p, [
                          createBaseVNode("p", _hoisted_39$n, toDisplayString$1(unref(t)("vocabulary.examples.noExamples", "No examples found for this vocabulary.")), 1)
                        ])) : (openBlock(), createElementBlock("div", _hoisted_40$n, [
                          createBaseVNode("div", _hoisted_41$m, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(getPaginatedVocabExamples(vocab.id), (example) => {
                              return openBlock(), createElementBlock("div", {
                                key: example.id,
                                class: "bg-white dark:bg-dark-bg border border-slate-200 dark:border-dark-bg-mute rounded-lg p-2 xs:p-3 sm:p-4 md:p-4 shadow-sm hover:shadow-md transition-shadow duration-200"
                              }, [
                                createBaseVNode("div", _hoisted_42$k, [
                                  createBaseVNode("div", _hoisted_43$j, [
                                    createBaseVNode("div", _hoisted_44$i, [
                                      createBaseVNode("h4", _hoisted_45$h, toDisplayString$1(example.title), 1),
                                      createBaseVNode("button", {
                                        onClick: ($event) => unref(audioSystem).playVocabularySound(example.content, "en"),
                                        class: "flex-shrink-0 p-1 xs:p-1.5 sm:p-1.5 text-emerald-600 hover:text-emerald-700 dark:text-emerald-400 dark:hover:text-emerald-300 bg-emerald-50 dark:bg-emerald-900/20 rounded-full hover:bg-emerald-100 dark:hover:bg-emerald-900/30 transition-all duration-200 transform hover:scale-110",
                                        title: unref(t)("vocabulary.examples.playExample", "Play example pronunciation")
                                      }, _cache[10] || (_cache[10] = [
                                        createBaseVNode("svg", {
                                          class: "w-3 xs:w-4 sm:w-4 h-3 xs:h-4 sm:h-4",
                                          fill: "none",
                                          stroke: "currentColor",
                                          viewBox: "0 0 24 24"
                                        }, [
                                          createBaseVNode("path", {
                                            "stroke-linecap": "round",
                                            "stroke-linejoin": "round",
                                            "stroke-width": "2",
                                            d: "M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 14.142M9 9l3-3v12l-3-3H5a2 2 0 01-2-2V9a2 2 0 012-2h4z"
                                          })
                                        ], -1)
                                      ]), 8, _hoisted_46$h)
                                    ]),
                                    createBaseVNode("p", _hoisted_47$h, toDisplayString$1(example.content), 1),
                                    createBaseVNode("div", _hoisted_48$h, [
                                      createBaseVNode("span", _hoisted_49$g, toDisplayString$1(example.type), 1),
                                      example.difficulty ? (openBlock(), createElementBlock("span", _hoisted_50$f, toDisplayString$1(example.difficulty), 1)) : createCommentVNode("", true),
                                      example.context ? (openBlock(), createElementBlock("span", _hoisted_51$e, toDisplayString$1(example.context), 1)) : createCommentVNode("", true)
                                    ])
                                  ]),
                                  createBaseVNode("div", _hoisted_52$d, [
                                    createBaseVNode("button", {
                                      onClick: ($event) => editExample(example),
                                      class: "px-2 xs:px-2.5 sm:px-3 py-1 xs:py-1 sm:py-1.5 text-2xs xs:text-xs sm:text-xs bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors duration-200 flex items-center gap-1"
                                    }, [
                                      _cache[11] || (_cache[11] = createBaseVNode("svg", {
                                        class: "w-2.5 xs:w-3 sm:w-3 h-2.5 xs:h-3 sm:h-3",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                                        })
                                      ], -1)),
                                      createBaseVNode("span", _hoisted_54$d, toDisplayString$1(unref(t)("common.edit", "Edit")), 1)
                                    ], 8, _hoisted_53$d),
                                    createBaseVNode("button", {
                                      onClick: ($event) => deleteExample(example),
                                      class: "px-2 xs:px-2.5 sm:px-3 py-1 xs:py-1 sm:py-1.5 text-2xs xs:text-xs sm:text-xs bg-red-600 hover:bg-red-700 text-white rounded-md transition-colors duration-200 flex items-center gap-1"
                                    }, [
                                      _cache[12] || (_cache[12] = createBaseVNode("svg", {
                                        class: "w-2.5 xs:w-3 sm:w-3 h-2.5 xs:h-3 sm:h-3",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                                        })
                                      ], -1)),
                                      createBaseVNode("span", _hoisted_56$c, toDisplayString$1(unref(t)("common.delete", "Delete")), 1)
                                    ], 8, _hoisted_55$d)
                                  ])
                                ])
                              ]);
                            }), 128))
                          ]),
                          getVocabExamplePages(vocab.id) > 1 ? (openBlock(), createElementBlock("div", _hoisted_57$c, [
                            createBaseVNode("div", _hoisted_58$c, [
                              createBaseVNode("div", _hoisted_59$b, [
                                createBaseVNode("button", {
                                  onClick: ($event) => previousExamplePage(vocab.id),
                                  disabled: !getExamplePaginationInfo(vocab.id).hasPrevious,
                                  class: "px-1.5 xs:px-2 py-0.5 xs:py-1 text-2xs xs:text-xs bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                }, toDisplayString$1(unref(t)("common.previous", "Prev")), 9, _hoisted_60$b),
                                createBaseVNode("span", _hoisted_61$a, toDisplayString$1(getExamplePaginationInfo(vocab.id).currentPage) + " / " + toDisplayString$1(getExamplePaginationInfo(vocab.id).totalPages), 1),
                                createBaseVNode("button", {
                                  onClick: ($event) => nextExamplePage(vocab.id),
                                  disabled: !getExamplePaginationInfo(vocab.id).hasNext,
                                  class: "px-1.5 xs:px-2 py-0.5 xs:py-1 text-2xs xs:text-xs bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_62$a)
                              ]),
                              createBaseVNode("div", _hoisted_63$8, [
                                createBaseVNode("button", {
                                  onClick: ($event) => previousExamplePage(vocab.id),
                                  disabled: !getExamplePaginationInfo(vocab.id).hasPrevious,
                                  class: "px-3 py-1.5 text-sm bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_64$8),
                                createBaseVNode("div", _hoisted_65$8, [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(Math.min(getExamplePaginationInfo(vocab.id).totalPages, 5), (page) => {
                                    return openBlock(), createElementBlock("button", {
                                      key: page,
                                      onClick: ($event) => goToExamplePage(vocab.id, page),
                                      class: normalizeClass([
                                        "px-3 py-1.5 text-sm rounded transition-colors",
                                        getExamplePaginationInfo(vocab.id).currentPage === page ? "bg-blue-600 text-white" : "bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600"
                                      ])
                                    }, toDisplayString$1(page), 11, _hoisted_66$8);
                                  }), 128))
                                ]),
                                createBaseVNode("button", {
                                  onClick: ($event) => nextExamplePage(vocab.id),
                                  disabled: !getExamplePaginationInfo(vocab.id).hasNext,
                                  class: "px-3 py-1.5 text-sm bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_67$7)
                              ]),
                              createBaseVNode("div", _hoisted_68$6, toDisplayString$1(unref(t)("vocabulary.examples.showingExamples", { start: getExamplePaginationInfo(vocab.id).start, end: getExamplePaginationInfo(vocab.id).end, total: getExamplePaginationInfo(vocab.id).totalExamples }, "Showing {start} to {end} of {total} examples")), 1)
                            ])
                          ])) : createCommentVNode("", true)
                        ]))
                      ])) : createCommentVNode("", true)
                    ]),
                    _: 2
                  }, 1024)
                ]);
              }), 128)),
              totalPages.value > 1 ? (openBlock(), createElementBlock("div", _hoisted_69$6, [
                createBaseVNode("div", _hoisted_70$6, [
                  createBaseVNode("div", _hoisted_71$6, [
                    createBaseVNode("button", {
                      onClick: previousPage,
                      disabled: currentPage.value === 1,
                      class: "relative inline-flex items-center px-2 xs:px-3 py-1 xs:py-1.5 border border-gray-300 dark:border-gray-600 text-xs xs:text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, toDisplayString$1(unref(t)("common.previous", "Prev")), 9, _hoisted_72$6),
                    createBaseVNode("div", _hoisted_73$6, [
                      createBaseVNode("span", _hoisted_74$6, toDisplayString$1(currentPage.value) + " / " + toDisplayString$1(totalPages.value), 1)
                    ]),
                    createBaseVNode("button", {
                      onClick: nextPage,
                      disabled: currentPage.value === totalPages.value,
                      class: "relative inline-flex items-center px-2 xs:px-3 py-1 xs:py-1.5 border border-gray-300 dark:border-gray-600 text-xs xs:text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_75$5)
                  ]),
                  createBaseVNode("div", _hoisted_76$5, [
                    createBaseVNode("div", null, [
                      createBaseVNode("p", _hoisted_77$5, toDisplayString$1(unref(t)("vocabulary.examples.showingVocabulary", {
                        start: startIndex.value,
                        end: endIndex.value,
                        total: filteredVocabulary.value.length
                      }, `Showing ${startIndex.value} to ${endIndex.value} of ${filteredVocabulary.value.length} vocabulary words`)), 1)
                    ]),
                    createBaseVNode("nav", _hoisted_78$4, [
                      createBaseVNode("button", {
                        onClick: previousPage,
                        disabled: currentPage.value === 1,
                        class: "relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                      }, [
                        createBaseVNode("span", _hoisted_80$4, toDisplayString$1(unref(t)("common.previous", "Previous")), 1),
                        _cache[13] || (_cache[13] = createBaseVNode("svg", {
                          class: "h-5 w-5",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                            "clip-rule": "evenodd"
                          })
                        ], -1))
                      ], 8, _hoisted_79$4),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(visiblePages.value, (page) => {
                        return openBlock(), createElementBlock("button", {
                          key: page,
                          onClick: ($event) => goToPage(page),
                          class: normalizeClass([
                            page === currentPage.value ? "z-10 bg-blue-50 dark:bg-blue-900 border-blue-500 dark:border-blue-400 text-blue-600 dark:text-blue-300" : "bg-white dark:bg-[#0a0a0a] border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600",
                            "relative inline-flex items-center px-4 py-2 border text-sm font-medium"
                          ])
                        }, toDisplayString$1(page), 11, _hoisted_81$4);
                      }), 128)),
                      createBaseVNode("button", {
                        onClick: nextPage,
                        disabled: currentPage.value === totalPages.value,
                        class: "relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                      }, [
                        createBaseVNode("span", _hoisted_83$4, toDisplayString$1(unref(t)("common.next", "Next")), 1),
                        _cache[14] || (_cache[14] = createBaseVNode("svg", {
                          class: "h-5 w-5",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                            "clip-rule": "evenodd"
                          })
                        ], -1))
                      ], 8, _hoisted_82$4)
                    ])
                  ])
                ])
              ])) : createCommentVNode("", true)
            ], 64)) : (openBlock(), createBlock(unref(TopicGroupAccordion), {
              key: 2,
              "vocabulary-list": filteredVocabulary.value,
              examples: examples.value,
              onAddExample: openCreateDialogForVocab,
              onEditExample: editExample,
              onDeleteExample: deleteExample
            }, null, 8, ["vocabulary-list", "examples"]))
          ])
        ]),
        showCreateDialog.value || showEditDialog.value ? (openBlock(), createBlock(unref(ExampleFormDialog$1), {
          key: 0,
          show: showCreateDialog.value || showEditDialog.value,
          example: currentExample.value,
          "vocabulary-id": selectedVocabulary.value,
          "vocabulary-list": vocabularyList.value,
          onClose: closeDialog,
          onSave: saveExample
        }, null, 8, ["show", "example", "vocabulary-id", "vocabulary-list"])) : createCommentVNode("", true)
      ]);
    };
  }
});

const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

const VocabularyExamplesView = /* @__PURE__ */ _export_sfc(_sfc_main$1p, [["__scopeId", "data-v-42779dea"]]);

const _hoisted_1$1n = { class: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative overflow-x-hidden" };
const _hoisted_2$1k = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto px-2 xs:px-3 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 pt-3 sm:pt-6" };
const _hoisted_3$1h = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6 mb-3 xs:mb-4 sm:mb-6" };
const _hoisted_4$1c = { class: "flex items-center mb-4" };
const _hoisted_5$19 = { class: "text-lg sm:text-xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 dark:from-purple-400 dark:to-pink-400 bg-clip-text text-transparent" };
const _hoisted_6$16 = { class: "text-sm sm:text-base text-gray-600 dark:text-gray-300 mb-4" };
const _hoisted_7$12 = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto py-3 px-2 xs:py-4 xs:px-3 sm:py-6 sm:px-4 md:px-6 lg:px-8 xl:px-10 2xl:px-12 overflow-x-hidden" };
const _hoisted_8$10 = { class: "grid gap-6 md:grid-cols-2 lg:grid-cols-3 mb-6" };
const _hoisted_9$$ = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.02] p-4 sm:p-6" };
const _hoisted_10$_ = { class: "flex items-center mb-4" };
const _hoisted_11$_ = { class: "text-base sm:text-lg font-semibold text-gray-800 dark:text-white" };
const _hoisted_12$X = { class: "text-sm text-gray-600 dark:text-gray-300 mb-4" };
const _hoisted_13$X = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.02] p-4 sm:p-6" };
const _hoisted_14$W = { class: "flex items-center mb-4" };
const _hoisted_15$Q = { class: "text-base sm:text-lg font-semibold text-gray-800 dark:text-white" };
const _hoisted_16$P = { class: "text-sm text-gray-600 dark:text-gray-300 mb-4" };
const _hoisted_17$O = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.02] p-4 sm:p-6" };
const _hoisted_18$M = { class: "flex items-center mb-4" };
const _hoisted_19$M = { class: "text-base sm:text-lg font-semibold text-gray-800 dark:text-white" };
const _hoisted_20$L = { class: "text-sm text-gray-600 dark:text-gray-300 mb-4" };
const _hoisted_21$L = {
  key: 0,
  class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-4 sm:p-6 mb-6"
};
const _hoisted_22$J = {
  key: 0,
  class: "space-y-6"
};
const _hoisted_23$J = { class: "flex items-center mb-4" };
const _hoisted_24$H = { class: "text-lg font-semibold text-gray-800 dark:text-white" };
const _hoisted_25$H = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_26$F = ["placeholder", "disabled"];
const _hoisted_27$E = { class: "grid gap-4 md:grid-cols-2" };
const _hoisted_28$C = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_29$A = ["disabled"];
const _hoisted_30$y = { value: "beginner" };
const _hoisted_31$x = { value: "intermediate" };
const _hoisted_32$u = { value: "advanced" };
const _hoisted_33$t = { value: "mixed" };
const _hoisted_34$q = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_35$q = ["disabled"];
const _hoisted_36$p = { class: "flex justify-end mt-6" };
const _hoisted_37$o = ["disabled"];
const _hoisted_38$o = {
  key: 0,
  class: "animate-spin w-5 h-5",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _hoisted_39$m = {
  key: 1,
  class: "w-5 h-5",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_40$m = {
  key: 1,
  class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-4 sm:p-6"
};
const _hoisted_41$l = { class: "flex items-center justify-between mb-6" };
const _hoisted_42$j = { class: "flex items-center" };
const _hoisted_43$i = { class: "text-lg font-semibold text-gray-800 dark:text-white" };
const _hoisted_44$h = { class: "flex space-x-2" };
const _hoisted_45$g = ["disabled"];
const _hoisted_46$g = { class: "grid gap-4 md:grid-cols-2 lg:grid-cols-3" };
const _hoisted_47$g = { class: "flex items-start justify-between mb-2" };
const _hoisted_48$g = { class: "font-semibold text-gray-800 dark:text-white text-lg" };
const _hoisted_49$f = { class: "text-xs px-2 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400 rounded-full" };
const _hoisted_50$e = { class: "text-sm text-gray-600 dark:text-gray-300 mb-3" };
const _hoisted_51$d = {
  key: 0,
  class: "text-xs text-gray-500 dark:text-gray-400 italic border-l-2 border-gray-300 dark:border-gray-600 pl-2"
};
const _sfc_main$1o = /* @__PURE__ */ defineComponent({
  __name: "AutoGeneratorView",
  setup(__props) {
    const { t } = useI18n();
    const vocabularyStore = useVocabularyStore();
    const toast = useToast();
    const selectedMethod = ref(null);
    const textInput = ref("");
    const selectedTopic = ref("");
    const aiPreferences = ref("");
    const difficultyLevel = ref("intermediate");
    const maxWords = ref("20");
    ref("vocabulary");
    const isGenerating = ref(false);
    const isSaving = ref(false);
    const generatedWords = ref([]);
    const canGenerate = computed(() => {
      if (selectedMethod.value === "text") {
        return textInput.value.trim().length > 10;
      } else if (selectedMethod.value === "topic") {
        return selectedTopic.value !== "";
      } else if (selectedMethod.value === "ai") {
        return aiPreferences.value.trim().length > 5;
      }
      return false;
    });
    const generateVocabulary = async () => {
      if (!canGenerate.value || isGenerating.value) return;
      isGenerating.value = true;
      try {
        await new Promise((resolve) => setTimeout(resolve, 2e3));
        generatedWords.value = generateMockWords();
      } catch (error) {
        console.error("Error generating vocabulary:", error);
      } finally {
        isGenerating.value = false;
      }
    };
    const generateMockWords = () => {
      const mockWords = [
        { word: "Articulate", meaning: "Having or showing the ability to speak fluently and coherently", type: "Adjective", example: "She gave an articulate presentation to the board." },
        { word: "Resilience", meaning: "The capacity to recover quickly from difficulties", type: "Noun", example: "His resilience helped him overcome many challenges." },
        { word: "Innovative", meaning: "Featuring new methods; advanced and original", type: "Adjective", example: "The company is known for its innovative products." },
        { word: "Collaborate", meaning: "Work jointly on an activity", type: "Verb", example: "We need to collaborate to complete this project." },
        { word: "Efficient", meaning: "Achieving maximum productivity with minimum effort", type: "Adjective", example: "The new system is more efficient than the old one." }
      ];
      const count = Math.min(parseInt(maxWords.value), 10);
      return mockWords.slice(0, count);
    };
    const saveAllWords = async () => {
      if (generatedWords.value.length === 0) return;
      isSaving.value = true;
      try {
        let savedCount = 0;
        for (const word of generatedWords.value) {
          const vocabularyData = {
            word: word.word,
            pronunciation: "",
            // Would be generated by TTS or manual input
            partOfSpeech: word.type,
            meaning: word.meaning,
            example: word.example || "",
            category: selectedTopic.value || "uncategorized",
            level: difficultyLevel.value,
            synonyms: [],
            antonyms: [],
            notes: `Generated via ${selectedMethod.value} method`,
            favorite: false,
            image: void 0
          };
          const result = vocabularyStore.addVocabulary(vocabularyData);
          if (result) {
            savedCount++;
          }
        }
        toast.success(
          t("autoGenerator.saveSuccess", `Successfully saved ${savedCount} words to your vocabulary list`),
          {
            position: POSITION.TOP_RIGHT,
            timeout: 3e3
          }
        );
        generatedWords.value = [];
        selectedMethod.value = null;
        textInput.value = "";
        selectedTopic.value = "";
        aiPreferences.value = "";
      } catch (error) {
        console.error("Error saving vocabulary:", error);
        toast.error(
          t("autoGenerator.saveError", "Failed to save vocabulary words"),
          {
            position: POSITION.TOP_RIGHT,
            timeout: 3e3
          }
        );
      } finally {
        isSaving.value = false;
      }
    };
    const clearGenerated = () => {
      generatedWords.value = [];
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1n, [
        _cache[16] || (_cache[16] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0" data-v-c4401a47><div class="floating-shapes" data-v-c4401a47><div class="absolute top-20 left-10 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob" data-v-c4401a47></div><div class="absolute top-40 right-10 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000" data-v-c4401a47></div><div class="absolute -bottom-8 left-20 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000" data-v-c4401a47></div></div></div>', 1)),
        createBaseVNode("div", _hoisted_2$1k, [
          createBaseVNode("div", _hoisted_3$1h, [
            createBaseVNode("div", _hoisted_4$1c, [
              _cache[6] || (_cache[6] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-purple-400 to-pink-500 rounded-full mr-2.5" })
              ], -1)),
              createBaseVNode("h1", _hoisted_5$19, toDisplayString$1(unref(t)("autoGenerator.title", "Auto Generator")), 1)
            ]),
            createBaseVNode("p", _hoisted_6$16, toDisplayString$1(unref(t)("autoGenerator.description", "Generate vocabulary words automatically from text, topics, or AI suggestions")), 1)
          ])
        ]),
        createBaseVNode("div", _hoisted_7$12, [
          createBaseVNode("div", _hoisted_8$10, [
            createBaseVNode("div", _hoisted_9$$, [
              createBaseVNode("div", _hoisted_10$_, [
                _cache[7] || (_cache[7] = createBaseVNode("div", { class: "w-12 h-12 bg-gradient-to-r from-blue-500 to-cyan-500 rounded-full flex items-center justify-center mr-3" }, [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 text-white",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M4 4a2 2 0 012-2h8a2 2 0 012 2v12a1 1 0 110 2h-3a1 1 0 01-1-1v-2a1 1 0 00-1-1H9a1 1 0 00-1 1v2a1 1 0 01-1 1H4a1 1 0 110-2V4zm3 1h2v2H7V5zm2 4H7v2h2V9zm2-4h2v2h-2V5zm2 4h-2v2h2V9z",
                      "clip-rule": "evenodd"
                    })
                  ])
                ], -1)),
                createBaseVNode("h3", _hoisted_11$_, toDisplayString$1(unref(t)("autoGenerator.methods.textAnalysis", "Text Analysis")), 1)
              ]),
              createBaseVNode("p", _hoisted_12$X, toDisplayString$1(unref(t)("autoGenerator.methods.textAnalysisDesc", "Extract vocabulary from articles, books, or any text content")), 1),
              createBaseVNode("button", {
                onClick: _cache[0] || (_cache[0] = ($event) => selectedMethod.value = "text"),
                class: normalizeClass([
                  "w-full py-2 px-4 rounded-lg font-medium transition-all duration-200",
                  selectedMethod.value === "text" ? "bg-gradient-to-r from-blue-500 to-cyan-500 text-white shadow-lg" : "bg-gray-100 dark:bg-dark-bg-mute text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-dark-bg-soft"
                ])
              }, toDisplayString$1(unref(t)("common.select", "Select")), 3)
            ]),
            createBaseVNode("div", _hoisted_13$X, [
              createBaseVNode("div", _hoisted_14$W, [
                _cache[8] || (_cache[8] = createBaseVNode("div", { class: "w-12 h-12 bg-gradient-to-r from-green-500 to-teal-500 rounded-full flex items-center justify-center mr-3" }, [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 text-white",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", { d: "M7 3a1 1 0 000 2h6a1 1 0 100-2H7zM4 7a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zM2 11a2 2 0 012-2h12a2 2 0 012 2v4a2 2 0 01-2 2H4a2 2 0 01-2-2v-4z" })
                  ])
                ], -1)),
                createBaseVNode("h3", _hoisted_15$Q, toDisplayString$1(unref(t)("autoGenerator.methods.topicBased", "Topic-based")), 1)
              ]),
              createBaseVNode("p", _hoisted_16$P, toDisplayString$1(unref(t)("autoGenerator.methods.topicBasedDesc", "Generate words based on specific topics or categories")), 1),
              createBaseVNode("button", {
                onClick: _cache[1] || (_cache[1] = ($event) => selectedMethod.value = "topic"),
                class: normalizeClass([
                  "w-full py-2 px-4 rounded-lg font-medium transition-all duration-200",
                  selectedMethod.value === "topic" ? "bg-gradient-to-r from-green-500 to-teal-500 text-white shadow-lg" : "bg-gray-100 dark:bg-dark-bg-mute text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-dark-bg-soft"
                ])
              }, toDisplayString$1(unref(t)("common.select", "Select")), 3)
            ]),
            createBaseVNode("div", _hoisted_17$O, [
              createBaseVNode("div", _hoisted_18$M, [
                _cache[9] || (_cache[9] = createBaseVNode("div", { class: "w-12 h-12 bg-gradient-to-r from-purple-500 to-pink-500 rounded-full flex items-center justify-center mr-3" }, [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 text-white",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z",
                      "clip-rule": "evenodd"
                    })
                  ])
                ], -1)),
                createBaseVNode("h3", _hoisted_19$M, toDisplayString$1(unref(t)("autoGenerator.methods.aiSuggestions", "AI Suggestions")), 1)
              ]),
              createBaseVNode("p", _hoisted_20$L, toDisplayString$1(unref(t)("autoGenerator.methods.aiSuggestionsDesc", "Get intelligent word suggestions based on your learning level")), 1),
              createBaseVNode("button", {
                onClick: _cache[2] || (_cache[2] = ($event) => selectedMethod.value = "ai"),
                class: normalizeClass([
                  "w-full py-2 px-4 rounded-lg font-medium transition-all duration-200",
                  selectedMethod.value === "ai" ? "bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-lg" : "bg-gray-100 dark:bg-dark-bg-mute text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-dark-bg-soft"
                ])
              }, toDisplayString$1(unref(t)("common.select", "Select")), 3)
            ])
          ]),
          selectedMethod.value ? (openBlock(), createElementBlock("div", _hoisted_21$L, [
            selectedMethod.value === "text" ? (openBlock(), createElementBlock("div", _hoisted_22$J, [
              createBaseVNode("div", _hoisted_23$J, [
                _cache[10] || (_cache[10] = createBaseVNode("div", { class: "w-8 h-8 bg-gradient-to-r from-blue-500 to-cyan-500 rounded-full flex items-center justify-center mr-3" }, [
                  createBaseVNode("svg", {
                    class: "w-4 h-4 text-white",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M4 4a2 2 0 012-2h8a2 2 0 012 2v12a1 1 0 110 2h-3a1 1 0 01-1-1v-2a1 1 0 00-1-1H9a1 1 0 00-1 1v2a1 1 0 01-1 1H4a1 1 0 110-2V4zm3 1h2v2H7V5zm2 4H7v2h2V9zm2-4h2v2h-2V5zm2 4h-2v2h2V9z",
                      "clip-rule": "evenodd"
                    })
                  ])
                ], -1)),
                createBaseVNode("h3", _hoisted_24$H, toDisplayString$1(unref(t)("autoGenerator.forms.textAnalysis.title", "Analyze Text Content")), 1)
              ]),
              createBaseVNode("div", null, [
                createBaseVNode("label", _hoisted_25$H, toDisplayString$1(unref(t)("autoGenerator.forms.textAnalysis.inputLabel", "Paste your text content here:")), 1),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => textInput.value = $event),
                  placeholder: unref(t)("autoGenerator.forms.textAnalysis.placeholder", "Paste article, book excerpt, or any English text..."),
                  class: "w-full h-40 px-4 py-3 border border-gray-300 dark:border-dark-bg-mute rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white resize-none",
                  disabled: isGenerating.value
                }, null, 8, _hoisted_26$F), [
                  [vModelText, textInput.value]
                ])
              ]),
              createBaseVNode("div", _hoisted_27$E, [
                createBaseVNode("div", null, [
                  createBaseVNode("label", _hoisted_28$C, toDisplayString$1(unref(t)("autoGenerator.forms.common.difficultyLevel", "Difficulty Level")), 1),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => difficultyLevel.value = $event),
                    class: "w-full px-4 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white",
                    disabled: isGenerating.value
                  }, [
                    createBaseVNode("option", _hoisted_30$y, toDisplayString$1(unref(t)("autoGenerator.levels.beginner", "Beginner")), 1),
                    createBaseVNode("option", _hoisted_31$x, toDisplayString$1(unref(t)("autoGenerator.levels.intermediate", "Intermediate")), 1),
                    createBaseVNode("option", _hoisted_32$u, toDisplayString$1(unref(t)("autoGenerator.levels.advanced", "Advanced")), 1),
                    createBaseVNode("option", _hoisted_33$t, toDisplayString$1(unref(t)("autoGenerator.levels.mixed", "Mixed Levels")), 1)
                  ], 8, _hoisted_29$A), [
                    [vModelSelect, difficultyLevel.value]
                  ])
                ]),
                createBaseVNode("div", null, [
                  createBaseVNode("label", _hoisted_34$q, toDisplayString$1(unref(t)("autoGenerator.forms.common.maxWords", "Maximum Words")), 1),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => maxWords.value = $event),
                    class: "w-full px-4 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white",
                    disabled: isGenerating.value
                  }, _cache[11] || (_cache[11] = [
                    createBaseVNode("option", { value: "10" }, "10", -1),
                    createBaseVNode("option", { value: "20" }, "20", -1),
                    createBaseVNode("option", { value: "30" }, "30", -1),
                    createBaseVNode("option", { value: "50" }, "50", -1)
                  ]), 8, _hoisted_35$q), [
                    [vModelSelect, maxWords.value]
                  ])
                ])
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_36$p, [
              createBaseVNode("button", {
                onClick: generateVocabulary,
                disabled: !canGenerate.value || isGenerating.value,
                class: normalizeClass([
                  "px-6 py-3 rounded-lg font-semibold transition-all duration-200 flex items-center space-x-2",
                  canGenerate.value && !isGenerating.value ? "bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white shadow-lg hover:shadow-xl transform hover:scale-105" : "bg-gray-300 dark:bg-dark-bg-mute text-gray-500 dark:text-gray-400 cursor-not-allowed"
                ])
              }, [
                isGenerating.value ? (openBlock(), createElementBlock("svg", _hoisted_38$o, _cache[12] || (_cache[12] = [
                  createBaseVNode("circle", {
                    class: "opacity-25",
                    cx: "12",
                    cy: "12",
                    r: "10",
                    stroke: "currentColor",
                    "stroke-width": "4"
                  }, null, -1),
                  createBaseVNode("path", {
                    class: "opacity-75",
                    fill: "currentColor",
                    d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 002 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                  }, null, -1)
                ]))) : (openBlock(), createElementBlock("svg", _hoisted_39$m, _cache[13] || (_cache[13] = [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                    "clip-rule": "evenodd"
                  }, null, -1)
                ]))),
                createBaseVNode("span", null, toDisplayString$1(isGenerating.value ? unref(t)("autoGenerator.generating", "Generating...") : unref(t)("autoGenerator.generate", "Generate Vocabulary")), 1)
              ], 10, _hoisted_37$o)
            ])
          ])) : createCommentVNode("", true),
          generatedWords.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_40$m, [
            createBaseVNode("div", _hoisted_41$l, [
              createBaseVNode("div", _hoisted_42$j, [
                _cache[14] || (_cache[14] = createBaseVNode("div", { class: "w-8 h-8 bg-gradient-to-r from-green-500 to-blue-500 rounded-full flex items-center justify-center mr-3" }, [
                  createBaseVNode("svg", {
                    class: "w-4 h-4 text-white",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                      "clip-rule": "evenodd"
                    })
                  ])
                ], -1)),
                createBaseVNode("h3", _hoisted_43$i, toDisplayString$1(unref(t)("autoGenerator.preview.title", "Generated Vocabulary")), 1)
              ]),
              createBaseVNode("div", _hoisted_44$h, [
                createBaseVNode("button", {
                  onClick: saveAllWords,
                  disabled: isSaving.value,
                  class: normalizeClass([
                    "px-4 py-2 rounded-lg font-medium transition-all duration-200 flex items-center space-x-2",
                    "bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white shadow-lg hover:shadow-xl transform hover:scale-105"
                  ])
                }, [
                  _cache[15] || (_cache[15] = createBaseVNode("svg", {
                    class: "w-4 h-4",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)),
                  createBaseVNode("span", null, toDisplayString$1(unref(t)("autoGenerator.saveAll", "Save All")), 1)
                ], 8, _hoisted_45$g),
                createBaseVNode("button", {
                  onClick: clearGenerated,
                  class: "px-4 py-2 rounded-lg font-medium text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20 transition-all duration-200"
                }, toDisplayString$1(unref(t)("common.clear", "Clear")), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_46$g, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(generatedWords.value, (word, index) => {
                return openBlock(), createElementBlock("div", {
                  key: index,
                  class: "bg-gray-50 dark:bg-dark-bg-mute rounded-lg p-4 hover:shadow-md transition-shadow duration-200"
                }, [
                  createBaseVNode("div", _hoisted_47$g, [
                    createBaseVNode("h4", _hoisted_48$g, toDisplayString$1(word.word), 1),
                    createBaseVNode("span", _hoisted_49$f, toDisplayString$1(word.type), 1)
                  ]),
                  createBaseVNode("p", _hoisted_50$e, toDisplayString$1(word.meaning), 1),
                  word.example ? (openBlock(), createElementBlock("div", _hoisted_51$d, ' "' + toDisplayString$1(word.example) + '" ', 1)) : createCommentVNode("", true)
                ]);
              }), 128))
            ])
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const AutoGeneratorView = /* @__PURE__ */ _export_sfc(_sfc_main$1o, [["__scopeId", "data-v-c4401a47"]]);

const grammarLessons = ref([
  {
    id: "1",
    title: "Present Perfect Tense",
    description: "Hc cch s dng th hin ti hon thnh trong ting Anh vi cc v d thc t v bi tp.",
    level: "intermediate",
    category: "Tenses",
    duration: 30,
    rating: 4.8,
    progress: 75,
    exercises: 15,
    theory: `
      <h3>Cu trc Present Perfect</h3>
      <p><strong>Khng nh:</strong> S + have/has + V3/ed</p>
      <p><strong>Ph nh:</strong> S + have/has + not + V3/ed</p>
      <p><strong>Nghi vn:</strong> Have/Has + S + V3/ed?</p>
      
      <h3>Cch s dng</h3>
      <p>Th hin ti hon thnh c s dng :</p>
      <ul>
        <li>Din t hnh ng  xy ra trong qu kh nhng khng r thi gian</li>
        <li>Din t hnh ng bt u trong qu kh v tip tc n hin ti</li>
        <li>Din t kinh nghim sng</li>
      </ul>
    `,
    structure: "Subject + have/has + past participle",
    examples: [
      {
        id: 1,
        text: "I have lived in this city for 5 years.",
        translation: "Ti  sng  thnh ph ny c 5 nm.",
        note: "Hnh ng bt u trong qu kh v tip tc n hin ti"
      },
      {
        id: 2,
        text: "She has just finished her homework.",
        translation: "C y va mi hon thnh bi tp v nh.",
        note: "Hnh ng va mi hon thnh"
      }
    ],
    rules: [
      {
        id: 1,
        title: "S dng vi 'for' v 'since'",
        description: "'For' + khong thi gian, 'since' + mc thi gian"
      },
      {
        id: 2,
        title: "S dng vi 'already', 'yet', 'just'",
        description: "Cc trng t ny thng i km vi th hin ti hon thnh"
      }
    ],
    usageRules: [
      { title: "S dng vi 'for' v 'since'", description: "'For' + khong thi gian, 'since' + mc thi gian" },
      { title: "S dng vi 'already', 'yet', 'just'", description: "Cc trng t ny thng i km vi th hin ti hon thnh" }
    ],
    commonMistakes: [
      {
        id: 1,
        wrong: "I have seen him yesterday.",
        correct: "I saw him yesterday.",
        explanation: "Khng dng Present Perfect vi thi gian c th trong qu kh"
      }
    ]
  }
]);
const useGrammarStore = () => {
  const allLessons = computed(() => grammarLessons.value);
  const getLesson = (id) => {
    return grammarLessons.value.find((lesson) => lesson.id === id);
  };
  const updateLesson = (id, updates) => {
    const index = grammarLessons.value.findIndex((lesson) => lesson.id === id);
    if (index !== -1) {
      grammarLessons.value[index] = { ...grammarLessons.value[index], ...updates };
    }
  };
  const addLesson = (lesson) => {
    grammarLessons.value.push(lesson);
  };
  const deleteLesson = (id) => {
    const index = grammarLessons.value.findIndex((lesson) => lesson.id === id);
    if (index !== -1) {
      grammarLessons.value.splice(index, 1);
    }
  };
  const getRelatedLessons = (currentId, category) => {
    return grammarLessons.value.filter((lesson) => lesson.id !== currentId && lesson.category === category).slice(0, 3).map((lesson) => ({
      id: lesson.id,
      title: lesson.title,
      category: lesson.category
    }));
  };
  return {
    allLessons,
    getLesson,
    updateLesson,
    addLesson,
    deleteLesson,
    getRelatedLessons
  };
};

const _hoisted_1$1m = { class: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative overflow-x-hidden" };
const _hoisted_2$1j = { class: "relative z-10 max-w-7xl mx-auto py-6 px-4 sm:px-6 lg:px-8" };
const _hoisted_3$1g = {
  key: 0,
  class: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
};
const _sfc_main$1n = /* @__PURE__ */ defineComponent({
  __name: "GrammarListView",
  setup(__props) {
    const LazyLoadComponent = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => LazyLoadComponent$1),true              ?void 0:void 0));
    const GrammarHeader$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => GrammarHeader),true              ?void 0:void 0))
    );
    const GrammarFilters$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => GrammarFilters),true              ?void 0:void 0))
    );
    const GrammarCard$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => GrammarCard),true              ?void 0:void 0))
    );
    const GrammarEmptyState$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => GrammarEmptyState),true              ?void 0:void 0))
    );
    const GrammarFormDialog = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => GrammarFormDialog$1),true              ?void 0:void 0))
    );
    const router = useRouter();
    const { t } = useI18n();
    const grammarStore = useGrammarStore();
    const showFormDialog = ref(false);
    const currentEditId = ref("");
    const searchQuery = ref("");
    const selectedLevel = ref("");
    const selectedCategory = ref("");
    const categories = ref([
      "Tenses",
      "Conditionals",
      "Passive Voice",
      "Modal Verbs",
      "Reported Speech",
      "Articles",
      "Prepositions",
      "Adjectives & Adverbs",
      "Phrasal Verbs",
      "Gerunds & Infinitives"
    ]);
    const filteredLessons = computed(() => {
      return grammarStore.allLessons.value.filter((lesson) => {
        const matchesSearch = lesson.title.toLowerCase().includes(searchQuery.value.toLowerCase()) || lesson.description.toLowerCase().includes(searchQuery.value.toLowerCase());
        const matchesLevel = !selectedLevel.value || lesson.level === selectedLevel.value;
        const matchesCategory = !selectedCategory.value || lesson.category === selectedCategory.value;
        return matchesSearch && matchesLevel && matchesCategory;
      });
    });
    const openAddDialog = () => {
      currentEditId.value = "";
      showFormDialog.value = true;
    };
    const openEditDialog = (lesson) => {
      currentEditId.value = lesson.id;
      showFormDialog.value = true;
    };
    const onLessonSaved = (lesson) => {
      console.log("Lesson saved:", lesson);
    };
    const viewLesson = (lesson) => {
      router.push(`/grammar/${lesson.id}`);
    };
    const practiceLesson = (lesson) => {
      router.push(`/grammar/${lesson.id}/practice`);
    };
    const deleteLesson = (lesson) => {
      if (confirm(t("grammar.confirmDelete", { title: lesson.title }) || `Delete lesson "${lesson.title}"?`)) {
        grammarStore.deleteLesson(lesson.id);
      }
    };
    onMounted(() => {
      console.log("Grammar list mounted");
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1m, [
        _cache[4] || (_cache[4] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0" data-v-41de1874><div class="floating-shapes" data-v-41de1874><div class="absolute top-20 left-10 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob" data-v-41de1874></div><div class="absolute top-40 right-10 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000" data-v-41de1874></div><div class="absolute -bottom-8 left-20 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000" data-v-41de1874></div></div></div>', 1)),
        createVNode(unref(LazyLoadComponent), { "animation-type": "fade-up" }, {
          default: withCtx(() => [
            createVNode(unref(GrammarHeader$1), { onAddLesson: openAddDialog })
          ]),
          _: 1
        }),
        createBaseVNode("div", _hoisted_2$1j, [
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "slide-left",
            threshold: 0.2,
            "root-margin": "100px"
          }, {
            default: withCtx(() => [
              createVNode(unref(GrammarFilters$1), {
                searchQuery: searchQuery.value,
                selectedLevel: selectedLevel.value,
                selectedCategory: selectedCategory.value,
                categories: categories.value,
                "onUpdate:searchQuery": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
                "onUpdate:selectedLevel": _cache[1] || (_cache[1] = ($event) => selectedLevel.value = $event),
                "onUpdate:selectedCategory": _cache[2] || (_cache[2] = ($event) => selectedCategory.value = $event)
              }, null, 8, ["searchQuery", "selectedLevel", "selectedCategory", "categories"])
            ]),
            _: 1
          }),
          createVNode(unref(LazyLoadComponent), {
            "animation-type": "scale",
            threshold: 0.2,
            "root-margin": "150px"
          }, {
            default: withCtx(() => [
              filteredLessons.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$1g, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(filteredLessons.value, (lesson) => {
                  return openBlock(), createBlock(unref(GrammarCard$1), {
                    key: lesson.id,
                    lesson,
                    onViewLesson: viewLesson,
                    onPracticeLesson: practiceLesson,
                    onEditLesson: openEditDialog,
                    onDeleteLesson: deleteLesson
                  }, null, 8, ["lesson"]);
                }), 128))
              ])) : (openBlock(), createBlock(unref(GrammarEmptyState$1), {
                key: 1,
                onAddLesson: openAddDialog
              }))
            ]),
            _: 1
          })
        ]),
        createVNode(unref(GrammarFormDialog), {
          modelValue: showFormDialog.value,
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => showFormDialog.value = $event),
          "edit-id": currentEditId.value,
          onSaved: onLessonSaved
        }, null, 8, ["modelValue", "edit-id"])
      ]);
    };
  }
});

const GrammarListView = /* @__PURE__ */ _export_sfc(_sfc_main$1n, [["__scopeId", "data-v-41de1874"]]);

const _hoisted_1$1l = { class: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative overflow-x-hidden" };
const _hoisted_2$1i = {
  key: 0,
  class: "relative z-10 max-w-4xl mx-auto py-6 px-4 sm:px-6 lg:px-8"
};
const _hoisted_3$1f = {
  key: 1,
  class: "relative z-10 max-w-4xl mx-auto py-6 px-4 sm:px-6 lg:px-8"
};
const _hoisted_4$1b = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 p-6 mb-6 transition-all duration-500" };
const _hoisted_5$18 = { class: "flex items-center justify-between mb-4" };
const _hoisted_6$15 = { class: "flex space-x-2" };
const _hoisted_7$11 = { class: "flex items-center justify-between" };
const _hoisted_8$$ = { class: "flex items-center mb-1" };
const _hoisted_9$_ = { class: "text-2xl sm:text-3xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 dark:from-blue-400 dark:to-indigo-400 bg-clip-text text-transparent" };
const _hoisted_10$Z = { class: "mt-2 text-gray-700 dark:text-white/80" };
const _hoisted_11$Z = { class: "text-right" };
const _hoisted_12$W = { class: "text-sm text-gray-500 dark:text-white/60 mt-2" };
const _hoisted_13$W = { class: "mt-6" };
const _hoisted_14$V = { class: "flex justify-between text-sm text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_15$P = { class: "w-full bg-gray-200 dark:bg-dark-bg-mute rounded-full h-3" };
const _hoisted_16$O = { class: "grid grid-cols-1 lg:grid-cols-3 gap-6" };
const _hoisted_17$N = { class: "lg:col-span-2 space-y-6" };
const _hoisted_18$L = { class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6" };
const _hoisted_19$L = { class: "text-xl font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_20$K = { class: "prose dark:prose-invert max-w-none" };
const _hoisted_21$K = ["innerHTML"];
const _hoisted_22$I = { class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6" };
const _hoisted_23$I = { class: "text-xl font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_24$G = { class: "space-y-4" };
const _hoisted_25$G = { class: "text-gray-900 dark:text-white font-medium" };
const _hoisted_26$E = { class: "text-gray-600 dark:text-white/80 text-sm mt-1" };
const _hoisted_27$D = {
  key: 0,
  class: "text-gray-500 dark:text-white/60 text-xs mt-1"
};
const _hoisted_28$B = { class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6" };
const _hoisted_29$z = { class: "text-xl font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_30$x = { class: "space-y-3" };
const _hoisted_31$w = { class: "flex-shrink-0 w-6 h-6 bg-blue-100 dark:bg-dark-bg-mute rounded-full flex items-center justify-center" };
const _hoisted_32$t = { class: "text-blue-600 dark:text-blue-400 text-sm font-medium" };
const _hoisted_33$s = { class: "text-gray-900 dark:text-white" };
const _hoisted_34$p = { class: "text-gray-600 dark:text-white/80 text-sm" };
const _hoisted_35$p = {
  key: 0,
  class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6"
};
const _hoisted_36$o = { class: "text-xl font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_37$n = { class: "space-y-4" };
const _hoisted_38$n = { class: "flex items-start space-x-3" };
const _hoisted_39$l = { class: "text-red-800 dark:text-red-400 font-medium" };
const _hoisted_40$l = { class: "text-green-800 dark:text-green-400 font-medium mt-1" };
const _hoisted_41$k = { class: "text-gray-600 dark:text-white/80 text-sm mt-1" };
const _hoisted_42$i = { class: "space-y-6" };
const _hoisted_43$h = { class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6" };
const _hoisted_44$g = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_45$f = { class: "space-y-3" };
const _hoisted_46$f = { class: "flex justify-between" };
const _hoisted_47$f = { class: "text-gray-600 dark:text-white/60" };
const _hoisted_48$f = { class: "text-gray-900 dark:text-white" };
const _hoisted_49$e = { class: "flex justify-between" };
const _hoisted_50$d = { class: "text-gray-600 dark:text-white/60" };
const _hoisted_51$c = { class: "text-gray-900 dark:text-white" };
const _hoisted_52$c = { class: "flex justify-between" };
const _hoisted_53$c = { class: "text-gray-600 dark:text-white/60" };
const _hoisted_54$c = { class: "text-gray-900 dark:text-white" };
const _hoisted_55$c = { class: "flex justify-between" };
const _hoisted_56$b = { class: "text-gray-600 dark:text-white/60" };
const _hoisted_57$b = { class: "flex items-center" };
const _hoisted_58$b = { class: "text-gray-900 dark:text-white" };
const _hoisted_59$a = { class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6" };
const _hoisted_60$a = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_61$9 = { class: "space-y-3" };
const _hoisted_62$9 = ["onClick"];
const _hoisted_63$7 = { class: "text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_64$7 = { class: "text-xs text-gray-500 dark:text-white/60" };
const _hoisted_65$7 = { class: "bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6" };
const _hoisted_66$7 = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_67$6 = { class: "space-y-3" };
const _sfc_main$1m = /* @__PURE__ */ defineComponent({
  __name: "GrammarDetailView",
  setup(__props) {
    const GrammarFormDialog = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => GrammarFormDialog$1),true              ?void 0:void 0))
    );
    const router = useRouter();
    const route = useRoute();
    const grammarStore = useGrammarStore();
    const { t } = useI18n();
    const showEditDialog = ref(false);
    const currentLessonId = ref("");
    const isLoading = ref(true);
    const lesson = ref({});
    const relatedLessons = ref([]);
    const loadLesson = async () => {
      const id = route.params.id;
      currentLessonId.value = id;
      try {
        await new Promise((resolve) => setTimeout(resolve, 500));
        const grammarLesson = grammarStore.getLesson(id);
        if (grammarLesson) {
          lesson.value = {
            id: grammarLesson.id,
            title: grammarLesson.title,
            description: grammarLesson.description,
            level: grammarLesson.level,
            category: grammarLesson.category,
            duration: grammarLesson.duration,
            rating: grammarLesson.rating,
            progress: grammarLesson.progress,
            exercises: grammarLesson.exercises,
            theory: grammarLesson.theory,
            examples: grammarLesson.examples.map((ex) => ({
              id: ex.id,
              sentence: ex.text,
              translation: ex.translation,
              note: ex.note
            })),
            rules: grammarLesson.rules,
            commonMistakes: grammarLesson.commonMistakes || []
          };
          const related = grammarStore.getRelatedLessons(id, grammarLesson.category);
          relatedLessons.value = related.map((rel) => ({
            id: parseInt(rel.id),
            title: rel.title,
            category: rel.category
          }));
        } else {
          console.error("Lesson not found:", id);
        }
      } catch (error) {
        console.error("Error loading lesson:", error);
      } finally {
        isLoading.value = false;
      }
    };
    const goBack = () => {
      router.back();
    };
    const practiceLesson = () => {
      router.push(`/grammar/${route.params.id}/practice`);
    };
    const openEditDialog = () => {
      showEditDialog.value = true;
    };
    const onLessonUpdated = () => {
      loadLesson();
    };
    const viewRelatedLesson = (relatedLesson) => {
      router.push(`/grammar/${relatedLesson.id}`);
    };
    const markAsCompleted = () => {
      lesson.value.progress = 100;
      grammarStore.updateLesson(currentLessonId.value, { progress: 100 });
    };
    const addToFavorites = () => {
      alert(t("grammar.detail.addedToFavorites", "Added to favorites"));
    };
    const shareLesson = () => {
      if (navigator.share) {
        navigator.share({
          title: lesson.value.title,
          text: lesson.value.description,
          url: window.location.href
        });
      } else {
        navigator.clipboard.writeText(window.location.href);
        alert(t("grammar.detail.linkCopied", "Link copied to clipboard"));
      }
    };
    const getLevelColor = (level) => {
      switch (level) {
        case "beginner":
          return "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300";
        case "intermediate":
          return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300";
        case "advanced":
          return "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300";
        default:
          return "bg-gray-100 text-gray-800 dark:bg-dark-bg-mute dark:text-white/80";
      }
    };
    const getLevelText = (level) => {
      const fallbackMap = {
        beginner: "Beginner",
        intermediate: "Intermediate",
        advanced: "Advanced"
      };
      return t(`grammar.levels.${level}`, fallbackMap[level] || "Level");
    };
    onMounted(() => {
      loadLesson();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1l, [
        _cache[8] || (_cache[8] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0" data-v-4d2c13f2><div class="floating-shapes" data-v-4d2c13f2><div class="absolute top-20 left-10 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob" data-v-4d2c13f2></div><div class="absolute top-40 right-10 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000" data-v-4d2c13f2></div><div class="absolute -bottom-8 left-20 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000" data-v-4d2c13f2></div></div></div>', 1)),
        isLoading.value ? (openBlock(), createElementBlock("div", _hoisted_2$1i, _cache[1] || (_cache[1] = [
          createStaticVNode('<div class="bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl rounded-2xl border border-white/20 dark:border-white/10 p-6" data-v-4d2c13f2><div class="animate-pulse" data-v-4d2c13f2><div class="h-8 bg-gray-200 dark:bg-dark-bg-mute rounded w-1/2 mb-4" data-v-4d2c13f2></div><div class="space-y-3" data-v-4d2c13f2><div class="h-4 bg-gray-200 dark:bg-dark-bg-mute rounded" data-v-4d2c13f2></div><div class="h-4 bg-gray-200 dark:bg-dark-bg-mute rounded w-5/6" data-v-4d2c13f2></div><div class="h-4 bg-gray-200 dark:bg-dark-bg-mute rounded w-3/4" data-v-4d2c13f2></div></div></div></div>', 1)
        ]))) : (openBlock(), createElementBlock("div", _hoisted_3$1f, [
          createBaseVNode("div", _hoisted_4$1b, [
            createBaseVNode("div", _hoisted_5$18, [
              createBaseVNode("button", {
                onClick: goBack,
                class: "p-2 rounded-lg text-gray-600 dark:text-white/70 hover:text-gray-800 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-[#0f0f0f] transition-colors"
              }, _cache[2] || (_cache[2] = [
                createBaseVNode("svg", {
                  class: "w-6 h-6",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                    "clip-rule": "evenodd"
                  })
                ], -1)
              ])),
              createBaseVNode("div", _hoisted_6$15, [
                createBaseVNode("button", {
                  onClick: practiceLesson,
                  class: "bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                }, [
                  _cache[3] || (_cache[3] = createBaseVNode("svg", {
                    class: "w-5 h-5 inline mr-2",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)),
                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.practice.title", "Practice")), 1)
                ]),
                createBaseVNode("button", {
                  onClick: openEditDialog,
                  class: "bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                }, [
                  _cache[4] || (_cache[4] = createBaseVNode("svg", {
                    class: "w-5 h-5 inline mr-2",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
                  ], -1)),
                  createTextVNode(" " + toDisplayString$1(unref(t)("common.edit", "Edit")), 1)
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_7$11, [
              createBaseVNode("div", null, [
                createBaseVNode("div", _hoisted_8$$, [
                  _cache[5] || (_cache[5] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                    createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-indigo-500 rounded-full mr-2.5" })
                  ], -1)),
                  createBaseVNode("h1", _hoisted_9$_, toDisplayString$1(lesson.value.title), 1)
                ]),
                createBaseVNode("p", _hoisted_10$Z, toDisplayString$1(lesson.value.description), 1)
              ]),
              createBaseVNode("div", _hoisted_11$Z, [
                createBaseVNode("span", {
                  class: normalizeClass([getLevelColor(lesson.value.level), "px-3 py-1 text-sm font-medium rounded-full"])
                }, toDisplayString$1(getLevelText(lesson.value.level)), 3),
                createBaseVNode("p", _hoisted_12$W, toDisplayString$1(lesson.value.duration) + " " + toDisplayString$1(unref(t)("grammar.duration", "mins")), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_13$W, [
              createBaseVNode("div", _hoisted_14$V, [
                createBaseVNode("span", null, toDisplayString$1(unref(t)("grammar.progress", "Progress")), 1),
                createBaseVNode("span", null, toDisplayString$1(lesson.value.progress) + "%", 1)
              ]),
              createBaseVNode("div", _hoisted_15$P, [
                createBaseVNode("div", {
                  class: "bg-blue-500 h-3 rounded-full transition-all duration-300",
                  style: normalizeStyle({ width: lesson.value.progress + "%" })
                }, null, 4)
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_16$O, [
            createBaseVNode("div", _hoisted_17$N, [
              createBaseVNode("div", _hoisted_18$L, [
                createBaseVNode("h2", _hoisted_19$L, toDisplayString$1(unref(t)("grammar.detail.theory", "Theory")), 1),
                createBaseVNode("div", _hoisted_20$K, [
                  createBaseVNode("div", {
                    innerHTML: lesson.value.theory
                  }, null, 8, _hoisted_21$K)
                ])
              ]),
              createBaseVNode("div", _hoisted_22$I, [
                createBaseVNode("h2", _hoisted_23$I, toDisplayString$1(unref(t)("grammar.detail.examples", "Examples")), 1),
                createBaseVNode("div", _hoisted_24$G, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(lesson.value.examples, (example) => {
                    return openBlock(), createElementBlock("div", {
                      key: example.id,
                      class: "border-l-4 border-blue-500 pl-4"
                    }, [
                      createBaseVNode("p", _hoisted_25$G, toDisplayString$1(example.sentence), 1),
                      createBaseVNode("p", _hoisted_26$E, toDisplayString$1(example.translation), 1),
                      example.note ? (openBlock(), createElementBlock("p", _hoisted_27$D, toDisplayString$1(example.note), 1)) : createCommentVNode("", true)
                    ]);
                  }), 128))
                ])
              ]),
              createBaseVNode("div", _hoisted_28$B, [
                createBaseVNode("h2", _hoisted_29$z, toDisplayString$1(unref(t)("grammar.detail.usageRules", "Usage Rules")), 1),
                createBaseVNode("div", _hoisted_30$x, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(lesson.value.rules, (rule) => {
                    return openBlock(), createElementBlock("div", {
                      key: rule.id,
                      class: "flex items-start space-x-3"
                    }, [
                      createBaseVNode("div", _hoisted_31$w, [
                        createBaseVNode("span", _hoisted_32$t, toDisplayString$1(rule.id), 1)
                      ]),
                      createBaseVNode("div", null, [
                        createBaseVNode("p", _hoisted_33$s, toDisplayString$1(rule.title), 1),
                        createBaseVNode("p", _hoisted_34$p, toDisplayString$1(rule.description), 1)
                      ])
                    ]);
                  }), 128))
                ])
              ]),
              lesson.value.commonMistakes && lesson.value.commonMistakes.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_35$p, [
                createBaseVNode("h2", _hoisted_36$o, toDisplayString$1(unref(t)("grammar.detail.commonMistakes", "Common Mistakes")), 1),
                createBaseVNode("div", _hoisted_37$n, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(lesson.value.commonMistakes, (mistake) => {
                    return openBlock(), createElementBlock("div", {
                      key: mistake.id,
                      class: "bg-red-50 dark:bg-dark-bg-mute border border-red-200 dark:border-red-900 rounded-lg p-4"
                    }, [
                      createBaseVNode("div", _hoisted_38$n, [
                        _cache[6] || (_cache[6] = createBaseVNode("svg", {
                          class: "w-5 h-5 text-red-500 dark:text-red-400 mt-0.5",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z",
                            "clip-rule": "evenodd"
                          })
                        ], -1)),
                        createBaseVNode("div", null, [
                          createBaseVNode("p", _hoisted_39$l, " " + toDisplayString$1(mistake.wrong), 1),
                          createBaseVNode("p", _hoisted_40$l, " " + toDisplayString$1(mistake.correct), 1),
                          createBaseVNode("p", _hoisted_41$k, toDisplayString$1(mistake.explanation), 1)
                        ])
                      ])
                    ]);
                  }), 128))
                ])
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_42$i, [
              createBaseVNode("div", _hoisted_43$h, [
                createBaseVNode("h3", _hoisted_44$g, toDisplayString$1(unref(t)("grammar.detail.info", "Info")), 1),
                createBaseVNode("div", _hoisted_45$f, [
                  createBaseVNode("div", _hoisted_46$f, [
                    createBaseVNode("span", _hoisted_47$f, toDisplayString$1(unref(t)("grammar.detail.topic", "Topic")) + ":", 1),
                    createBaseVNode("span", _hoisted_48$f, toDisplayString$1(lesson.value.category), 1)
                  ]),
                  createBaseVNode("div", _hoisted_49$e, [
                    createBaseVNode("span", _hoisted_50$d, toDisplayString$1(unref(t)("grammar.detail.duration", "Duration")) + ":", 1),
                    createBaseVNode("span", _hoisted_51$c, toDisplayString$1(lesson.value.duration) + " " + toDisplayString$1(unref(t)("grammar.duration", "mins")), 1)
                  ]),
                  createBaseVNode("div", _hoisted_52$c, [
                    createBaseVNode("span", _hoisted_53$c, toDisplayString$1(unref(t)("grammar.detail.exercises", "Exercises")) + ":", 1),
                    createBaseVNode("span", _hoisted_54$c, toDisplayString$1(lesson.value.exercises), 1)
                  ]),
                  createBaseVNode("div", _hoisted_55$c, [
                    createBaseVNode("span", _hoisted_56$b, toDisplayString$1(unref(t)("grammar.detail.rating", "Rating")) + ":", 1),
                    createBaseVNode("div", _hoisted_57$b, [
                      _cache[7] || (_cache[7] = createBaseVNode("svg", {
                        class: "w-4 h-4 text-yellow-400 mr-1",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" })
                      ], -1)),
                      createBaseVNode("span", _hoisted_58$b, toDisplayString$1(lesson.value.rating), 1)
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_59$a, [
                createBaseVNode("h3", _hoisted_60$a, toDisplayString$1(unref(t)("grammar.detail.relatedLessons", "Related Lessons")), 1),
                createBaseVNode("div", _hoisted_61$9, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(relatedLessons.value, (related) => {
                    return openBlock(), createElementBlock("div", {
                      key: related.id,
                      class: "border border-white/20 dark:border-white/10 rounded-lg p-3 hover:bg-white/60 dark:hover:bg-[#0f0f0f] transition-colors cursor-pointer",
                      onClick: ($event) => viewRelatedLesson(related)
                    }, [
                      createBaseVNode("p", _hoisted_63$7, toDisplayString$1(related.title), 1),
                      createBaseVNode("p", _hoisted_64$7, toDisplayString$1(related.category), 1)
                    ], 8, _hoisted_62$9);
                  }), 128))
                ])
              ]),
              createBaseVNode("div", _hoisted_65$7, [
                createBaseVNode("h3", _hoisted_66$7, toDisplayString$1(unref(t)("common.actions", "Actions")), 1),
                createBaseVNode("div", _hoisted_67$6, [
                  createBaseVNode("button", {
                    onClick: markAsCompleted,
                    class: "w-full bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                  }, toDisplayString$1(unref(t)("grammar.detail.markCompleted", "Mark as Completed")), 1),
                  createBaseVNode("button", {
                    onClick: addToFavorites,
                    class: "w-full bg-yellow-500 hover:bg-yellow-600 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                  }, toDisplayString$1(unref(t)("grammar.detail.addToFavorites", "Add to Favorites")), 1),
                  createBaseVNode("button", {
                    onClick: shareLesson,
                    class: "w-full bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                  }, toDisplayString$1(unref(t)("grammar.detail.shareLesson", "Share Lesson")), 1)
                ])
              ])
            ])
          ])
        ])),
        createVNode(unref(GrammarFormDialog), {
          modelValue: showEditDialog.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showEditDialog.value = $event),
          "edit-id": currentLessonId.value,
          onSaved: onLessonUpdated
        }, null, 8, ["modelValue", "edit-id"])
      ]);
    };
  }
});

const GrammarDetailView = /* @__PURE__ */ _export_sfc(_sfc_main$1m, [["__scopeId", "data-v-4d2c13f2"]]);

const _hoisted_1$1k = { class: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-[#0a0a0a] dark:to-[#0f0f0f] relative overflow-x-hidden" };
const _hoisted_2$1h = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-3 sm:pt-6" };
const _hoisted_3$1e = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_4$1a = { class: "flex items-center justify-between" };
const _hoisted_5$17 = { class: "flex items-center space-x-4" };
const _hoisted_6$14 = { class: "flex items-center mb-1" };
const _hoisted_7$10 = { class: "text-xl sm:text-2xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 dark:from-blue-400 dark:to-indigo-400 bg-clip-text text-transparent" };
const _hoisted_8$_ = { class: "text-sm text-gray-600 dark:text-white/70" };
const _hoisted_9$Z = { class: "flex items-center space-x-4" };
const _hoisted_10$Y = { class: "text-sm text-gray-600 dark:text-white/70" };
const _hoisted_11$Y = { class: "font-medium text-blue-600 dark:text-blue-400" };
const _hoisted_12$V = ["title"];
const _hoisted_13$V = ["title"];
const _hoisted_14$U = { class: "relative z-10 max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8" };
const _hoisted_15$O = {
  key: 0,
  class: "space-y-6"
};
const _hoisted_16$N = { class: "text-center" };
const _hoisted_17$M = { class: "text-2xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 dark:from-blue-400 dark:to-indigo-400 bg-clip-text text-transparent mb-4" };
const _hoisted_18$K = { class: "text-gray-700 dark:text-white/70 mb-8" };
const _hoisted_19$K = { class: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6" };
const _hoisted_20$J = ["onClick"];
const _hoisted_21$J = { class: "text-center" };
const _hoisted_22$H = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-2" };
const _hoisted_23$H = { class: "text-sm text-gray-600 dark:text-white/70 mb-4" };
const _hoisted_24$F = { class: "flex items-center justify-center space-x-4 text-xs text-gray-500 dark:text-white/60" };
const _hoisted_25$F = {
  key: 1,
  class: "space-y-6"
};
const _hoisted_26$D = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-gray-700 p-6" };
const _hoisted_27$C = { class: "flex items-center justify-between" };
const _hoisted_28$A = { class: "flex items-center space-x-4" };
const _hoisted_29$y = { class: "text-xl font-semibold text-gray-900 dark:text-white" };
const _hoisted_30$w = { class: "text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_31$v = { class: "flex items-center space-x-4" };
const _hoisted_32$s = { class: "w-32 bg-gray-200 dark:bg-mute rounded-full h-2" };
const _hoisted_33$r = { class: "text-sm font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_34$o = {
  key: 0,
  class: "fixed inset-0 bg-black/50 dark:bg-black/60 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_35$o = { class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-dark-bg-mute flex flex-col h-full overflow-hidden transform" };
const _hoisted_36$n = { class: "px-6 py-4 border-b border-gray-200 dark:border-dark-bg-mute flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_37$m = { class: "flex items-center justify-between" };
const _hoisted_38$m = { class: "text-lg sm:text-xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_39$k = { class: "px-6 py-4 flex-1 overflow-y-auto min-h-0 space-y-4" };
const _hoisted_40$k = { class: "block text-sm font-medium text-gray-700 dark:text-white mb-2" };
const _hoisted_41$j = { value: "easy" };
const _hoisted_42$h = { value: "medium" };
const _hoisted_43$g = { value: "hard" };
const _hoisted_44$f = { class: "flex items-center justify-between" };
const _hoisted_45$e = { class: "text-sm font-medium text-gray-700 dark:text-white" };
const _hoisted_46$e = { class: "flex items-center justify-between" };
const _hoisted_47$e = { class: "text-sm font-medium text-gray-700 dark:text-white" };
const _hoisted_48$e = { class: "px-6 py-4 border-t border-gray-200 dark:border-dark-bg-mute flex-shrink-0 bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_49$d = { class: "flex justify-end space-x-3" };
const _hoisted_50$c = {
  key: 0,
  class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
};
const _hoisted_51$b = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-gray-700 p-6 max-w-lg w-full mx-4" };
const _hoisted_52$b = { class: "text-center" };
const _hoisted_53$b = { class: "text-2xl font-bold text-gray-900 dark:text-white mb-2" };
const _hoisted_54$b = { class: "space-y-4 mb-6" };
const _hoisted_55$b = { class: "grid grid-cols-3 gap-4 text-center" };
const _hoisted_56$a = { class: "bg-blue-50 dark:bg-blue-900/30 rounded-lg p-4" };
const _hoisted_57$a = { class: "text-2xl font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_58$a = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_59$9 = { class: "bg-red-50 dark:bg-red-900/30 rounded-lg p-4" };
const _hoisted_60$9 = { class: "text-2xl font-bold text-red-600 dark:text-red-400" };
const _hoisted_61$8 = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_62$8 = { class: "bg-green-50 dark:bg-green-900/30 rounded-lg p-4" };
const _hoisted_63$6 = { class: "text-2xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_64$6 = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_65$6 = { class: "flex justify-center space-x-4" };
const _hoisted_66$6 = {
  key: 1,
  class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
};
const _hoisted_67$5 = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-gray-700 p-6 max-w-6xl w-full mx-4 max-h-[90vh] overflow-y-auto" };
const _hoisted_68$5 = { class: "flex items-center justify-between mb-6" };
const _hoisted_69$5 = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_70$5 = { class: "space-y-6" };
const _hoisted_71$5 = { class: "bg-gray-50 dark:bg-gray-800/30 border border-gray-200 dark:border-gray-600 rounded-lg p-4" };
const _hoisted_72$5 = { class: "text-md font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_73$5 = {
  key: 0,
  class: "space-y-4"
};
const _hoisted_74$5 = { class: "grid grid-cols-1 md:grid-cols-2 gap-4" };
const _hoisted_75$4 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_76$4 = { value: "essay" };
const _hoisted_77$4 = { value: "email" };
const _hoisted_78$3 = { value: "letter" };
const _hoisted_79$3 = { value: "paragraph" };
const _hoisted_80$3 = { class: "grid grid-cols-2 gap-2" };
const _hoisted_81$3 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_82$3 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_83$3 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_84$3 = ["placeholder"];
const _hoisted_85$3 = { class: "flex items-center justify-between mb-2" };
const _hoisted_86$2 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_87$2 = { class: "space-y-2" };
const _hoisted_88$2 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_89$2 = ["onClick", "disabled"];
const _hoisted_90$2 = {
  key: 1,
  class: "space-y-4"
};
const _hoisted_91$2 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_92$2 = ["placeholder"];
const _hoisted_93$2 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_94$2 = { class: "space-y-2" };
const _hoisted_95$2 = { class: "text-sm font-medium text-gray-500 dark:text-gray-400 w-6" };
const _hoisted_96$2 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_97$2 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_98$2 = ["value"];
const _hoisted_99$2 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_100$1 = ["placeholder"];
const _hoisted_101$1 = {
  key: 2,
  class: "space-y-4"
};
const _hoisted_102$1 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_103$1 = { class: "relative" };
const _hoisted_104$1 = ["placeholder"];
const _hoisted_105$1 = { class: "mt-2 text-xs text-gray-500 dark:text-gray-400" };
const _hoisted_106$1 = {
  key: 0,
  class: "mt-3 p-3 bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded-lg"
};
const _hoisted_107$1 = { class: "flex items-center space-x-2 text-sm text-blue-800 dark:text-blue-200" };
const _hoisted_108$1 = { class: "mt-2 text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_109$1 = { class: "grid grid-cols-1 md:grid-cols-3 gap-4" };
const _hoisted_110$1 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_111$1 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_112 = { value: "easy" };
const _hoisted_113 = { value: "medium" };
const _hoisted_114 = { value: "hard" };
const _hoisted_115 = { class: "flex items-center" };
const _hoisted_116 = { class: "flex items-center space-x-2 cursor-pointer" };
const _hoisted_117 = { class: "text-sm font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_118 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_119 = ["placeholder"];
const _hoisted_120 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_121 = { class: "space-y-3" };
const _hoisted_122 = { class: "flex items-center justify-between mb-2" };
const _hoisted_123 = { class: "text-sm font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_124 = ["onClick", "disabled"];
const _hoisted_125 = { class: "space-y-2" };
const _hoisted_126 = ["onUpdate:modelValue"];
const _hoisted_127 = { value: "multiple-choice" };
const _hoisted_128 = { value: "fill-blank" };
const _hoisted_129 = { value: "ordering" };
const _hoisted_130 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_131 = {
  key: 0,
  class: "space-y-1"
};
const _hoisted_132 = { class: "text-xs font-medium text-gray-500 dark:text-gray-400 w-4" };
const _hoisted_133 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_134 = ["onUpdate:modelValue"];
const _hoisted_135 = { value: "" };
const _hoisted_136 = ["value"];
const _hoisted_137 = { key: 1 };
const _hoisted_138 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_139 = {
  key: 3,
  class: "space-y-4"
};
const _hoisted_140 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_141 = ["placeholder"];
const _hoisted_142 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_143 = ["placeholder"];
const _hoisted_144 = { class: "flex justify-end mt-4" };
const _hoisted_145 = { key: 0 };
const _hoisted_146 = { class: "text-md font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_147 = { class: "space-y-4 max-h-96 overflow-y-auto" };
const _hoisted_148 = { class: "flex items-start justify-between" };
const _hoisted_149 = { class: "flex-1" };
const _hoisted_150 = { class: "mb-2" };
const _hoisted_151 = { class: "inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200" };
const _hoisted_152 = {
  key: 0,
  class: "ml-2 inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200"
};
const _hoisted_153 = { class: "text-sm text-gray-900 dark:text-white mb-2" };
const _hoisted_154 = { class: "mt-1" };
const _hoisted_155 = {
  key: 0,
  class: "text-xs text-gray-600 dark:text-gray-400"
};
const _hoisted_156 = { class: "list-disc list-inside mt-1" };
const _hoisted_157 = {
  key: 1,
  class: "text-xs text-gray-600 dark:text-gray-400 mt-2"
};
const _hoisted_158 = { class: "flex items-center space-x-2 ml-4" };
const _hoisted_159 = ["onClick", "title"];
const _hoisted_160 = ["onClick", "title"];
const _hoisted_161 = {
  key: 1,
  class: "text-center py-8"
};
const _hoisted_162 = { class: "text-gray-500 dark:text-gray-400" };
const _hoisted_163 = { class: "text-sm mt-1" };
const _hoisted_164 = { class: "flex justify-end space-x-4 mt-6" };
const _sfc_main$1l = /* @__PURE__ */ defineComponent({
  __name: "GrammarPracticeView",
  setup(__props) {
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      const translated = params ? t(key, params) : t(key);
      const text = typeof translated === "string" ? translated : String(translated);
      if (text === key) return fallback;
      return text;
    };
    const route = useRoute();
    const router = useRouter();
    const { playAudio } = useVoiceStore();
    const MultipleChoiceExercise$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => MultipleChoiceExercise),true              ?void 0:void 0));
    const FillBlankExercise$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FillBlankExercise),true              ?void 0:void 0));
    const PronunciationExercise$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => PronunciationExercise),true              ?void 0:void 0));
    const ReadingExercise$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ReadingExercise),true              ?void 0:void 0));
    const ListeningExercise$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ListeningExercise),true              ?void 0:void 0));
    const WritingExercise$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => WritingExercise),true              ?void 0:void 0));
    const ExerciseManager$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ExerciseManager),true              ?void 0:void 0));
    const BookOpenIcon = () => h("svg", { class: "w-8 h-8 text-white", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" }, [
      h("path", { "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C20.168 18.477 18.582 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" })
    ]);
    const PencilIcon = () => h("svg", { class: "w-8 h-8 text-white", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" }, [
      h("path", { "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" })
    ]);
    const SpeakerWaveIcon = () => h("svg", { class: "w-8 h-8 text-white", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" }, [
      h("path", { "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5.25 5.25 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.59-.71-1.59-1.59V9.84c0-.88.71-1.59 1.59-1.59h2.24z" })
    ]);
    const MicrophoneIcon = () => h("svg", { class: "w-8 h-8 text-white", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" }, [
      h("path", { "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3zM19 10v2a7 7 0 0 1-14 0v-2M12 19v4M8 23h8" })
    ]);
    const EyeIcon = () => h("svg", { class: "w-8 h-8 text-white", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" }, [
      h("path", { "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z" }),
      h("path", { "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" })
    ]);
    const EditIcon = () => h("svg", { class: "w-8 h-8 text-white", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" }, [
      h("path", { "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", d: "M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" })
    ]);
    computed(() => route.params.id);
    const selectedExercise = ref(null);
    const currentQuestionIndex = ref(0);
    const totalQuestions = ref(10);
    const currentQuestion = ref(null);
    const exerciseResults = ref({
      correct: 0,
      incorrect: 0,
      percentage: 0,
      answers: []
    });
    const showSettings = ref(false);
    const showResults = ref(false);
    const showExerciseManager = ref(false);
    const totalScore = ref(0);
    const newExercise = ref({
      type: "",
      title: "",
      description: "",
      difficulty: "medium",
      duration: ""
    });
    const exerciseQuestions = ref({});
    const showQuestionManager = ref(false);
    const selectedExerciseTypeForQuestions = ref("");
    const newQuestion = ref({
      id: "",
      type: "",
      question: "",
      options: ["", "", "", ""],
      correctAnswer: "",
      explanation: "",
      difficulty: "medium",
      // Writing specific fields
      taskType: "essay",
      prompt: "",
      requirements: [""],
      minWords: 100,
      timeLimit: 20,
      // Listening specific fields
      audioUrl: "",
      originalUrl: "",
      maxPlays: 3,
      allowNotes: false,
      transcript: "",
      questions: []
    });
    const editingQuestionIndex = ref(-1);
    const settings = ref({
      difficulty: "medium",
      autoPlayAudio: true,
      showExplanations: true
    });
    const exerciseTypes = ref([
      {
        type: "multiple-choice",
        title: "Multiple Choice",
        description: "Choose the correct answer from multiple options",
        icon: BookOpenIcon,
        colorClass: "bg-gray-500",
        duration: "10-15 min",
        difficulty: "Easy"
      },
      {
        type: "fill-blank",
        title: "Fill in the Blanks",
        description: "Complete sentences by filling in missing words",
        icon: PencilIcon,
        colorClass: "bg-green-500",
        duration: "15-20 min",
        difficulty: "Medium"
      },
      {
        type: "pronunciation",
        title: "Pronunciation Practice",
        description: "Practice speaking and pronunciation skills",
        icon: MicrophoneIcon,
        colorClass: "bg-purple-500",
        duration: "10-15 min",
        difficulty: "Medium"
      },
      {
        type: "reading",
        title: "Reading Comprehension",
        description: "Read passages and answer comprehension questions",
        icon: EyeIcon,
        colorClass: "bg-orange-500",
        duration: "20-25 min",
        difficulty: "Hard"
      },
      {
        type: "listening",
        title: "Listening Exercise",
        description: "Listen to audio and answer related questions",
        icon: SpeakerWaveIcon,
        colorClass: "bg-indigo-500",
        duration: "15-20 min",
        difficulty: "Medium"
      },
      {
        type: "writing",
        title: "Writing Practice",
        description: "Practice writing skills with various prompts",
        icon: EditIcon,
        colorClass: "bg-red-500",
        duration: "25-30 min",
        difficulty: "Hard"
      }
    ]);
    const currentExerciseComponent = computed(() => {
      const componentMap = {
        "multiple-choice": MultipleChoiceExercise$1,
        "fill-blank": FillBlankExercise$1,
        "pronunciation": PronunciationExercise$1,
        "reading": ReadingExercise$1,
        "listening": ListeningExercise$1,
        "writing": WritingExercise$1
      };
      return selectedExercise.value ? componentMap[selectedExercise.value] || null : null;
    });
    const startExercise = (exerciseType) => {
      selectedExercise.value = exerciseType;
      currentQuestionIndex.value = 0;
      exerciseResults.value = {
        correct: 0,
        incorrect: 0,
        percentage: 0,
        answers: []
      };
      generateQuestions();
      const newQuery = { ...route.query, exercise: exerciseType };
      router.replace({ query: newQuery });
    };
    const generateQuestions = () => {
      if (!selectedExercise.value) return;
      const savedQuestions = exerciseQuestions.value[selectedExercise.value] || [];
      if (savedQuestions.length > 0) {
        const questionIndex = currentQuestionIndex.value % savedQuestions.length;
        currentQuestion.value = savedQuestions[questionIndex];
      } else {
        generateDefaultQuestions();
      }
    };
    const generateDefaultQuestions = () => {
      if (selectedExercise.value === "writing") {
        const writingTasks = [
          {
            id: 1,
            type: "writing",
            taskType: "essay",
            prompt: "Write an essay about the importance of learning English in today's globalized world. Discuss how English proficiency can benefit individuals in their personal and professional lives.",
            requirements: [
              "Write at least 250 words",
              "Include an introduction, body paragraphs, and conclusion",
              "Use specific examples to support your points",
              "Demonstrate proper grammar and vocabulary usage"
            ],
            minWords: 250,
            timeLimit: 30
          },
          {
            id: 2,
            type: "writing",
            taskType: "email",
            prompt: "Write a formal email to your manager requesting time off for a family vacation. Include the dates, reason, and any work arrangements you have made.",
            requirements: [
              "Use formal email format",
              "Include appropriate subject line",
              "Be polite and professional",
              "Provide all necessary details"
            ],
            minWords: 150,
            timeLimit: 20
          },
          {
            id: 3,
            type: "writing",
            taskType: "letter",
            prompt: "Write a letter to a friend describing your recent trip to a new city. Share your experiences, what you liked most, and recommend places to visit.",
            requirements: [
              "Use informal, friendly tone",
              "Include specific details about places visited",
              "Share personal experiences and feelings",
              "Make recommendations"
            ],
            minWords: 200,
            timeLimit: 25
          }
        ];
        const taskIndex = currentQuestionIndex.value % writingTasks.length;
        currentQuestion.value = writingTasks[taskIndex];
      } else if (selectedExercise.value === "multiple-choice") {
        const mcQuestions = [
          {
            id: 1,
            type: "multiple-choice",
            question: 'Choose the correct form of the verb: "She _____ to the store yesterday."',
            options: ["go", "goes", "went", "going"],
            correctAnswer: "went",
            explanation: "Past tense is used for actions completed in the past."
          },
          {
            id: 2,
            type: "multiple-choice",
            question: "Which sentence is grammatically correct?",
            options: [
              "I have been living here since 5 years.",
              "I have been living here for 5 years.",
              "I am living here since 5 years.",
              "I live here since 5 years."
            ],
            correctAnswer: "I have been living here for 5 years.",
            explanation: 'Use "for" with duration and present perfect continuous for ongoing actions.'
          }
        ];
        const questionIndex = currentQuestionIndex.value % mcQuestions.length;
        currentQuestion.value = mcQuestions[questionIndex];
      } else if (selectedExercise.value === "fill-blank") {
        const fillBlankQuestions = [
          {
            id: 1,
            type: "fill-blank",
            question: 'Complete the sentence: "I _____ been studying English _____ three years."',
            blanks: ["have", "for"],
            sentence: "I _____ been studying English _____ three years.",
            explanation: 'Present perfect continuous with "have" and duration with "for".'
          }
        ];
        const questionIndex = currentQuestionIndex.value % fillBlankQuestions.length;
        currentQuestion.value = fillBlankQuestions[questionIndex];
      } else {
        currentQuestion.value = {
          id: 1,
          type: selectedExercise.value,
          question: `Sample ${selectedExercise.value} question`,
          options: ["Option A", "Option B", "Option C", "Option D"],
          correctAnswer: "Option A",
          explanation: "This is the correct answer because..."
        };
      }
    };
    const handleAnswer = (answer) => {
      const isCorrect = answer.isCorrect;
      if (isCorrect) {
        exerciseResults.value.correct++;
      } else {
        exerciseResults.value.incorrect++;
      }
      exerciseResults.value.answers.push({
        questionIndex: currentQuestionIndex.value,
        userAnswer: answer.userAnswer,
        correctAnswer: answer.correctAnswer,
        isCorrect
      });
    };
    const nextQuestion = () => {
      if (currentQuestionIndex.value < totalQuestions.value - 1) {
        currentQuestionIndex.value++;
        generateQuestions();
      } else {
        completeExercise();
      }
    };
    const completeExercise = () => {
      const total = exerciseResults.value.correct + exerciseResults.value.incorrect;
      exerciseResults.value.percentage = total > 0 ? Math.round(exerciseResults.value.correct / total * 100) : 0;
      totalScore.value += exerciseResults.value.correct * 10;
      showResults.value = true;
    };
    const restartExercise = () => {
      showResults.value = false;
      currentQuestionIndex.value = 0;
      exerciseResults.value = {
        correct: 0,
        incorrect: 0,
        percentage: 0,
        answers: []
      };
      generateQuestions();
    };
    const goBackToSelection = () => {
      selectedExercise.value = null;
      showResults.value = false;
      currentQuestionIndex.value = 0;
      const newQuery = { ...route.query };
      delete newQuery.exercise;
      router.replace({ query: newQuery });
    };
    const saveSettings = () => {
      localStorage.setItem("grammarPracticeSettings", JSON.stringify(settings.value));
      showSettings.value = false;
    };
    const goBackToGrammarDetail = () => {
      const grammarId2 = route.params.id;
      if (grammarId2) {
        router.push(`/grammar/${grammarId2}`);
      } else {
        router.push("/grammar");
      }
    };
    const addExerciseType = () => {
      if (!newExercise.value.type || !newExercise.value.title) {
        return;
      }
      const exerciseToAdd = {
        type: newExercise.value.type,
        title: newExercise.value.title,
        description: newExercise.value.description,
        difficulty: newExercise.value.difficulty,
        duration: newExercise.value.duration,
        icon: BookOpenIcon,
        colorClass: "bg-blue-500"
      };
      exerciseTypes.value.push(exerciseToAdd);
      newExercise.value = {
        type: "",
        title: "",
        description: "",
        difficulty: "medium",
        duration: ""
      };
    };
    const editExerciseType = (index) => {
      const exercise = exerciseTypes.value[index];
      newExercise.value = {
        type: exercise.type,
        title: exercise.title,
        description: exercise.description,
        difficulty: exercise.difficulty,
        duration: exercise.duration
      };
      exerciseTypes.value.splice(index, 1);
    };
    const deleteExerciseType = (index) => {
      if (confirm(t("common.confirmDelete", "Are you sure you want to delete this?"))) {
        exerciseTypes.value.splice(index, 1);
      }
    };
    const saveExerciseTypes = () => {
      localStorage.setItem("grammarExerciseTypes", JSON.stringify(exerciseTypes.value));
      showExerciseManager.value = false;
    };
    const openQuestionManager = (exerciseType) => {
      selectedExerciseTypeForQuestions.value = exerciseType;
      showQuestionManager.value = true;
      resetNewQuestionForm();
    };
    const closeQuestionManager = () => {
      showQuestionManager.value = false;
      selectedExerciseTypeForQuestions.value = "";
      resetNewQuestionForm();
      editingQuestionIndex.value = -1;
    };
    const resetNewQuestionForm = () => {
      if (selectedExerciseTypeForQuestions.value === "listening") {
        newQuestion.value = {
          id: "",
          type: "listening",
          audioUrl: "",
          maxPlays: 3,
          allowNotes: true,
          difficulty: "medium",
          transcript: "",
          questions: [{
            question: "",
            type: "multiple-choice",
            options: ["", "", "", ""],
            correctAnswer: ""
          }]
        };
      } else if (selectedExerciseTypeForQuestions.value === "writing") {
        newQuestion.value = {
          id: "",
          type: "writing",
          question: "",
          options: ["", "", "", ""],
          correctAnswer: "",
          explanation: "",
          difficulty: "medium",
          // Writing specific fields
          taskType: "essay",
          prompt: "",
          requirements: [""],
          minWords: 100,
          timeLimit: 20,
          // Listening specific fields (default values)
          audioUrl: "",
          originalUrl: "",
          maxPlays: 3,
          allowNotes: false,
          transcript: "",
          questions: []
        };
      } else {
        newQuestion.value = {
          id: "",
          type: selectedExerciseTypeForQuestions.value || "",
          question: "",
          options: ["", "", "", ""],
          correctAnswer: "",
          explanation: "",
          difficulty: "medium",
          // Add missing properties to satisfy TypeScript
          taskType: "essay",
          prompt: "",
          requirements: [""],
          minWords: 100,
          timeLimit: 20,
          // Listening specific fields (default values)
          audioUrl: "",
          originalUrl: "",
          maxPlays: 3,
          allowNotes: false,
          transcript: "",
          questions: []
        };
      }
    };
    const addQuestion = () => {
      const exerciseType = selectedExerciseTypeForQuestions.value;
      if (!exerciseType) return;
      const id = Date.now().toString();
      const questionToAdd = {
        ...newQuestion.value,
        id,
        type: exerciseType
      };
      if (exerciseType === "writing") {
        questionToAdd.requirements = questionToAdd.requirements.filter((req) => req.trim() !== "");
      }
      if (!exerciseQuestions.value[exerciseType]) {
        exerciseQuestions.value[exerciseType] = [];
      }
      if (editingQuestionIndex.value >= 0) {
        exerciseQuestions.value[exerciseType][editingQuestionIndex.value] = questionToAdd;
        editingQuestionIndex.value = -1;
      } else {
        exerciseQuestions.value[exerciseType].push(questionToAdd);
      }
      saveQuestionsToStorage();
      resetNewQuestionForm();
    };
    const editQuestion = (index) => {
      const exerciseType = selectedExerciseTypeForQuestions.value;
      const question = exerciseQuestions.value[exerciseType][index];
      newQuestion.value = { ...question };
      editingQuestionIndex.value = index;
    };
    const deleteQuestion = (index) => {
      if (confirm(t("common.confirmDelete", "Are you sure you want to delete this?"))) {
        const exerciseType = selectedExerciseTypeForQuestions.value;
        exerciseQuestions.value[exerciseType].splice(index, 1);
        saveQuestionsToStorage();
      }
    };
    const addRequirement = () => {
      newQuestion.value.requirements.push("");
    };
    const removeRequirement = (index) => {
      if (newQuestion.value.requirements.length > 1) {
        newQuestion.value.requirements.splice(index, 1);
      }
    };
    const addListeningQuestion = () => {
      const listeningQuestion = newQuestion.value;
      if (listeningQuestion.questions) {
        listeningQuestion.questions.push({
          question: "",
          type: "multiple-choice",
          options: ["", "", "", ""],
          correctAnswer: ""
        });
      }
    };
    const removeListeningQuestion = (index) => {
      const listeningQuestion = newQuestion.value;
      if (listeningQuestion.questions && listeningQuestion.questions.length > 1) {
        listeningQuestion.questions.splice(index, 1);
      }
    };
    const isYouTubeUrl = (url) => {
      if (!url) return false;
      const youtubeRegex = /^(https?\:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/.+/;
      return youtubeRegex.test(url);
    };
    const extractYouTubeVideoId = (url) => {
      const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
      const match = url.match(regex);
      return match ? match[1] : null;
    };
    const convertYouTubeToAudioUrl = (url) => {
      const videoId = extractYouTubeVideoId(url);
      if (videoId) {
        return `youtube:${videoId}`;
      }
      return url;
    };
    const handleAudioUrlChange = () => {
      if (isYouTubeUrl(newQuestion.value.audioUrl)) {
        const convertedUrl = convertYouTubeToAudioUrl(newQuestion.value.audioUrl);
        newQuestion.value.originalUrl = newQuestion.value.audioUrl;
        newQuestion.value.audioUrl = convertedUrl;
      }
    };
    const handleUrlPaste = (event) => {
      const pastedText = event.clipboardData?.getData("text") || "";
      if (pastedText) {
        let cleanUrl = pastedText.trim();
        if (cleanUrl.includes("youtube.com") || cleanUrl.includes("youtu.be")) {
          const url = new URL(cleanUrl);
          if (url.hostname.includes("youtube.com")) {
            const videoId = url.searchParams.get("v");
            if (videoId) {
              cleanUrl = `https://www.youtube.com/watch?v=${videoId}`;
            }
          } else if (url.hostname.includes("youtu.be")) {
            const videoId = url.pathname.slice(1);
            if (videoId) {
              cleanUrl = `https://youtu.be/${videoId}`;
            }
          }
        }
        newQuestion.value.audioUrl = cleanUrl;
        event.preventDefault();
        handleAudioUrlChange();
      }
    };
    const clearAudioUrl = () => {
      newQuestion.value.audioUrl = "";
      newQuestion.value.originalUrl = "";
    };
    const saveQuestionsToStorage = () => {
      localStorage.setItem("grammarExerciseQuestions", JSON.stringify(exerciseQuestions.value));
    };
    const loadQuestionsFromStorage = () => {
      const saved = localStorage.getItem("grammarExerciseQuestions");
      if (saved) {
        exerciseQuestions.value = JSON.parse(saved);
      }
    };
    const initializeFromUrl = () => {
      const exerciseFromUrl = route.query.exercise;
      if (exerciseFromUrl && exerciseTypes.value.some((ex) => ex.type === exerciseFromUrl)) {
        selectedExercise.value = exerciseFromUrl;
        generateQuestions();
      } else {
        selectedExercise.value = null;
      }
    };
    watch(() => route.query.exercise, (newExercise2) => {
      if (newExercise2 && exerciseTypes.value.some((ex) => ex.type === newExercise2)) {
        if (selectedExercise.value !== newExercise2) {
          selectedExercise.value = newExercise2;
          currentQuestionIndex.value = 0;
          exerciseResults.value = {
            correct: 0,
            incorrect: 0,
            percentage: 0,
            answers: []
          };
          generateQuestions();
        }
      } else {
        selectedExercise.value = null;
      }
    });
    watch([showQuestionManager, showSettings, showResults, showExerciseManager], ([questionManager, settings2, results, exerciseManager]) => {
      const anyModalOpen = questionManager || settings2 || results || exerciseManager;
      if (anyModalOpen) {
        document.body.style.overflow = "hidden";
      } else {
        document.body.style.overflow = "";
      }
    });
    onMounted(() => {
      const savedSettings = localStorage.getItem("grammarPracticeSettings");
      if (savedSettings) {
        settings.value = { ...settings.value, ...JSON.parse(savedSettings) };
      }
      const savedScore = localStorage.getItem("grammarPracticeScore");
      if (savedScore) {
        totalScore.value = parseInt(savedScore);
      }
      loadQuestionsFromStorage();
      initializeFromUrl();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1k, [
        _cache[40] || (_cache[40] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none z-0"><div class="floating-shapes"><div class="absolute top-16 left-8 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob"></div><div class="absolute top-36 right-8 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000"></div><div class="absolute -bottom-10 left-24 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000"></div></div></div>', 1)),
        createBaseVNode("div", _hoisted_2$1h, [
          createBaseVNode("div", _hoisted_3$1e, [
            createBaseVNode("div", _hoisted_4$1a, [
              createBaseVNode("div", _hoisted_5$17, [
                createBaseVNode("button", {
                  onClick: goBackToGrammarDetail,
                  class: "p-2 rounded-lg text-gray-600 dark:text-white/70 hover:text-gray-800 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-[#0f0f0f] transition-colors"
                }, _cache[23] || (_cache[23] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M15 19l-7-7 7-7"
                    })
                  ], -1)
                ])),
                createBaseVNode("div", null, [
                  createBaseVNode("div", _hoisted_6$14, [
                    _cache[24] || (_cache[24] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                      createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-indigo-500 rounded-full mr-2.5" })
                    ], -1)),
                    createBaseVNode("h1", _hoisted_7$10, toDisplayString$1(unref(t)("grammar.practice.title", "Practice")), 1)
                  ]),
                  createBaseVNode("p", _hoisted_8$_, toDisplayString$1(unref(t)("grammar.practice.subtitle", "Choose a mode to practice grammar with interactive exercises")), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_9$Z, [
                createBaseVNode("div", _hoisted_10$Y, [
                  createTextVNode(toDisplayString$1(unref(t)("grammar.practice.score", "Score")) + ": ", 1),
                  createBaseVNode("span", _hoisted_11$Y, toDisplayString$1(totalScore.value), 1)
                ]),
                createBaseVNode("button", {
                  onClick: _cache[0] || (_cache[0] = ($event) => showExerciseManager.value = true),
                  class: "p-2 rounded-lg text-gray-600 dark:text-white/70 hover:text-gray-800 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-[#0f0f0f] transition-colors",
                  title: unref(t)("grammar.practice.exerciseManager.title", "Manage exercises")
                }, _cache[25] || (_cache[25] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 100 4m0-4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 100 4m0-4v2m0-6V4"
                    })
                  ], -1)
                ]), 8, _hoisted_12$V),
                createBaseVNode("button", {
                  onClick: _cache[1] || (_cache[1] = ($event) => showSettings.value = true),
                  class: "p-2 rounded-lg text-gray-600 dark:text-white/70 hover:text-gray-800 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-[#0f0f0f] transition-colors",
                  title: unref(t)("grammar.practice.settings.title", "Settings")
                }, _cache[26] || (_cache[26] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"
                    }),
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                    })
                  ], -1)
                ]), 8, _hoisted_13$V)
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_14$U, [
          !selectedExercise.value ? (openBlock(), createElementBlock("div", _hoisted_15$O, [
            createBaseVNode("div", _hoisted_16$N, [
              createBaseVNode("h2", _hoisted_17$M, toDisplayString$1(unref(t)("grammar.practice.chooseExercise", "Choose an exercise")), 1),
              createBaseVNode("p", _hoisted_18$K, toDisplayString$1(unref(t)("grammar.practice.chooseDescription", "Select a practice type below to get started")), 1)
            ]),
            createBaseVNode("div", _hoisted_19$K, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(exerciseTypes.value, (exercise) => {
                return openBlock(), createElementBlock("div", {
                  key: exercise.type,
                  onClick: ($event) => startExercise(exercise.type),
                  class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md rounded-2xl shadow-xl border border-white/20 dark:border-white/10 p-6 cursor-pointer hover:shadow-2xl hover:scale-[1.03] transition-all duration-300"
                }, [
                  createBaseVNode("div", _hoisted_21$J, [
                    createBaseVNode("div", {
                      class: normalizeClass(["w-16 h-16 mx-auto mb-4 rounded-full flex items-center justify-center", exercise.colorClass])
                    }, [
                      (openBlock(), createBlock(resolveDynamicComponent(exercise.icon), { class: "w-8 h-8 text-white" }))
                    ], 2),
                    createBaseVNode("h3", _hoisted_22$H, toDisplayString$1(tf(`grammar.practice.exercises.${exercise.type}.title`, exercise.title)), 1),
                    createBaseVNode("p", _hoisted_23$H, toDisplayString$1(tf(`grammar.practice.exercises.${exercise.type}.description`, exercise.description)), 1),
                    createBaseVNode("div", _hoisted_24$F, [
                      createBaseVNode("span", null, toDisplayString$1(exercise.duration), 1),
                      _cache[27] || (_cache[27] = createBaseVNode("span", null, "", -1)),
                      createBaseVNode("span", null, toDisplayString$1(exercise.difficulty), 1)
                    ])
                  ])
                ], 8, _hoisted_20$J);
              }), 128))
            ])
          ])) : (openBlock(), createElementBlock("div", _hoisted_25$F, [
            createBaseVNode("div", _hoisted_26$D, [
              createBaseVNode("div", _hoisted_27$C, [
                createBaseVNode("div", _hoisted_28$A, [
                  createBaseVNode("button", {
                    onClick: goBackToSelection,
                    class: "p-2 rounded-lg text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
                  }, _cache[28] || (_cache[28] = [
                    createBaseVNode("svg", {
                      class: "w-5 h-5",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M15 19l-7-7 7-7"
                      })
                    ], -1)
                  ])),
                  createBaseVNode("div", null, [
                    createBaseVNode("h2", _hoisted_29$y, toDisplayString$1(tf(`grammar.practice.exercises.${selectedExercise.value}.title`, "Exercise")), 1),
                    createBaseVNode("p", _hoisted_30$w, toDisplayString$1(unref(t)("grammar.practice.question", "Question")) + " " + toDisplayString$1(currentQuestionIndex.value + 1) + " / " + toDisplayString$1(totalQuestions.value), 1)
                  ])
                ]),
                createBaseVNode("div", _hoisted_31$v, [
                  createBaseVNode("div", _hoisted_32$s, [
                    createBaseVNode("div", {
                      class: "bg-blue-600 h-2 rounded-full transition-all duration-300",
                      style: normalizeStyle({ width: `${currentQuestionIndex.value / totalQuestions.value * 100}%` })
                    }, null, 4)
                  ]),
                  createBaseVNode("span", _hoisted_33$r, toDisplayString$1(Math.round(currentQuestionIndex.value / totalQuestions.value * 100)) + "% ", 1)
                ])
              ])
            ]),
            (openBlock(), createBlock(resolveDynamicComponent(currentExerciseComponent.value), {
              question: currentQuestion.value,
              "question-index": currentQuestionIndex.value,
              "total-questions": totalQuestions.value,
              difficulty: settings.value.difficulty,
              onAnswer: handleAnswer,
              onNext: nextQuestion,
              onComplete: completeExercise
            }, null, 40, ["question", "question-index", "total-questions", "difficulty"]))
          ]))
        ]),
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            showSettings.value ? (openBlock(), createElementBlock("div", _hoisted_34$o, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: "w-full max-h-[90vh] flex flex-col max-w-md sm:max-w-md md:max-w-lg",
                    onClick: _cache[7] || (_cache[7] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("div", _hoisted_35$o, [
                      createBaseVNode("div", _hoisted_36$n, [
                        createBaseVNode("div", _hoisted_37$m, [
                          createBaseVNode("h3", _hoisted_38$m, [
                            _cache[29] || (_cache[29] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("grammar.practice.settings.title", "Settings")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: _cache[2] || (_cache[2] = ($event) => showSettings.value = false),
                            class: "text-gray-400 dark:text-white hover:text-gray-600 dark:hover:text-white transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-dark-bg-mute"
                          }, _cache[30] || (_cache[30] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_39$k, [
                        createBaseVNode("div", null, [
                          createBaseVNode("label", _hoisted_40$k, toDisplayString$1(unref(t)("grammar.practice.settings.difficulty", "Difficulty")), 1),
                          withDirectives(createBaseVNode("select", {
                            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => settings.value.difficulty = $event),
                            class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:focus:border-blue-500"
                          }, [
                            createBaseVNode("option", _hoisted_41$j, toDisplayString$1(unref(t)("grammar.practice.settings.levels.easy", "Easy")), 1),
                            createBaseVNode("option", _hoisted_42$h, toDisplayString$1(unref(t)("grammar.practice.settings.levels.medium", "Medium")), 1),
                            createBaseVNode("option", _hoisted_43$g, toDisplayString$1(unref(t)("grammar.practice.settings.levels.hard", "Hard")), 1)
                          ], 512), [
                            [vModelSelect, settings.value.difficulty]
                          ])
                        ]),
                        createBaseVNode("div", _hoisted_44$f, [
                          createBaseVNode("label", _hoisted_45$e, toDisplayString$1(unref(t)("grammar.practice.settings.autoPlay", "Auto-play audio")), 1),
                          createBaseVNode("button", {
                            onClick: _cache[4] || (_cache[4] = ($event) => settings.value.autoPlayAudio = !settings.value.autoPlayAudio),
                            class: normalizeClass([
                              "relative inline-flex h-6 w-11 items-center rounded-full transition-colors",
                              settings.value.autoPlayAudio ? "bg-blue-600" : "bg-gray-200 dark:bg-dark-bg-mute"
                            ])
                          }, [
                            createBaseVNode("span", {
                              class: normalizeClass([
                                "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                                settings.value.autoPlayAudio ? "translate-x-6" : "translate-x-1"
                              ])
                            }, null, 2)
                          ], 2)
                        ]),
                        createBaseVNode("div", _hoisted_46$e, [
                          createBaseVNode("label", _hoisted_47$e, toDisplayString$1(unref(t)("grammar.practice.settings.showExplanations", "Show explanations")), 1),
                          createBaseVNode("button", {
                            onClick: _cache[5] || (_cache[5] = ($event) => settings.value.showExplanations = !settings.value.showExplanations),
                            class: normalizeClass([
                              "relative inline-flex h-6 w-11 items-center rounded-full transition-colors",
                              settings.value.showExplanations ? "bg-blue-600" : "bg-gray-200 dark:bg-dark-bg-mute"
                            ])
                          }, [
                            createBaseVNode("span", {
                              class: normalizeClass([
                                "inline-block h-4 w-4 transform rounded-full bg-white transition-transform",
                                settings.value.showExplanations ? "translate-x-6" : "translate-x-1"
                              ])
                            }, null, 2)
                          ], 2)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_48$e, [
                        createBaseVNode("div", _hoisted_49$d, [
                          createBaseVNode("button", {
                            onClick: _cache[6] || (_cache[6] = ($event) => showSettings.value = false),
                            class: "px-6 py-2 text-gray-700 dark:text-white bg-gray-100 dark:bg-dark-bg-mute hover:bg-gray-200 dark:hover:bg-dark-bg-soft rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium"
                          }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                          createBaseVNode("button", {
                            onClick: saveSettings,
                            class: "px-6 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg hover:from-blue-600 hover:to-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium"
                          }, toDisplayString$1(unref(t)("common.save", "Save")), 1)
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        }),
        showResults.value ? (openBlock(), createElementBlock("div", _hoisted_50$c, [
          createBaseVNode("div", _hoisted_51$b, [
            createBaseVNode("div", _hoisted_52$b, [
              _cache[31] || (_cache[31] = createBaseVNode("div", { class: "w-20 h-20 mx-auto mb-4 rounded-full bg-green-100 dark:bg-green-900/30 flex items-center justify-center" }, [
                createBaseVNode("svg", {
                  class: "w-10 h-10 text-green-600 dark:text-green-400",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
                  })
                ])
              ], -1)),
              createBaseVNode("h3", _hoisted_53$b, toDisplayString$1(unref(t)("grammar.practice.results.title", "Great job!")), 1),
              createBaseVNode("div", _hoisted_54$b, [
                createBaseVNode("div", _hoisted_55$b, [
                  createBaseVNode("div", _hoisted_56$a, [
                    createBaseVNode("div", _hoisted_57$a, toDisplayString$1(exerciseResults.value.correct), 1),
                    createBaseVNode("div", _hoisted_58$a, toDisplayString$1(unref(t)("grammar.practice.results.correct", "Correct")), 1)
                  ]),
                  createBaseVNode("div", _hoisted_59$9, [
                    createBaseVNode("div", _hoisted_60$9, toDisplayString$1(exerciseResults.value.incorrect), 1),
                    createBaseVNode("div", _hoisted_61$8, toDisplayString$1(unref(t)("grammar.practice.results.incorrect", "Incorrect")), 1)
                  ]),
                  createBaseVNode("div", _hoisted_62$8, [
                    createBaseVNode("div", _hoisted_63$6, toDisplayString$1(exerciseResults.value.percentage) + "%", 1),
                    createBaseVNode("div", _hoisted_64$6, toDisplayString$1(unref(t)("grammar.practice.results.accuracy", "Accuracy")), 1)
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_65$6, [
                createBaseVNode("button", {
                  onClick: restartExercise,
                  class: "px-6 py-3 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
                }, toDisplayString$1(unref(t)("grammar.practice.results.tryAgain", "Try again")), 1),
                createBaseVNode("button", {
                  onClick: goBackToSelection,
                  class: "px-6 py-3 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700 transition-colors"
                }, toDisplayString$1(unref(t)("grammar.practice.results.chooseAnother", "Choose another exercise")), 1)
              ])
            ])
          ])
        ])) : createCommentVNode("", true),
        createVNode(unref(ExerciseManager$1), {
          modelValue: showExerciseManager.value,
          "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => showExerciseManager.value = $event),
          "exercise-types": exerciseTypes.value,
          onAddExercise: addExerciseType,
          onEditExercise: editExerciseType,
          onDeleteExercise: deleteExerciseType,
          onSaveExercises: saveExerciseTypes,
          onOpenQuestionManager: openQuestionManager
        }, null, 8, ["modelValue", "exercise-types"]),
        showQuestionManager.value ? (openBlock(), createElementBlock("div", _hoisted_66$6, [
          createBaseVNode("div", _hoisted_67$5, [
            createBaseVNode("div", _hoisted_68$5, [
              createBaseVNode("h3", _hoisted_69$5, toDisplayString$1(unref(t)("grammar.practice.questionManager.title")) + ": " + toDisplayString$1(unref(t)(`grammar.practice.exercises.${selectedExerciseTypeForQuestions.value}.title`)), 1),
              createBaseVNode("button", {
                onClick: closeQuestionManager,
                class: "p-2 rounded-lg text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
              }, _cache[32] || (_cache[32] = [
                createBaseVNode("svg", {
                  class: "w-5 h-5",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M6 18L18 6M6 6l12 12"
                  })
                ], -1)
              ]))
            ]),
            createBaseVNode("div", _hoisted_70$5, [
              createBaseVNode("div", _hoisted_71$5, [
                createBaseVNode("h4", _hoisted_72$5, toDisplayString$1(editingQuestionIndex.value >= 0 ? unref(t)("grammar.practice.questionManager.editQuestion") : unref(t)("grammar.practice.questionManager.addNew")), 1),
                selectedExerciseTypeForQuestions.value === "writing" ? (openBlock(), createElementBlock("div", _hoisted_73$5, [
                  createBaseVNode("div", _hoisted_74$5, [
                    createBaseVNode("div", null, [
                      createBaseVNode("label", _hoisted_75$4, toDisplayString$1(unref(t)("grammar.practice.questionManager.taskType")), 1),
                      withDirectives(createBaseVNode("select", {
                        "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => newQuestion.value.taskType = $event),
                        class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                      }, [
                        createBaseVNode("option", _hoisted_76$4, toDisplayString$1(unref(t)("grammar.practice.exercises.writing.essay")), 1),
                        createBaseVNode("option", _hoisted_77$4, toDisplayString$1(unref(t)("grammar.practice.exercises.writing.email")), 1),
                        createBaseVNode("option", _hoisted_78$3, toDisplayString$1(unref(t)("grammar.practice.exercises.writing.letter")), 1),
                        createBaseVNode("option", _hoisted_79$3, toDisplayString$1(unref(t)("grammar.practice.exercises.writing.paragraph")), 1)
                      ], 512), [
                        [vModelSelect, newQuestion.value.taskType]
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_80$3, [
                      createBaseVNode("div", null, [
                        createBaseVNode("label", _hoisted_81$3, toDisplayString$1(unref(t)("grammar.practice.questionManager.minWords")), 1),
                        withDirectives(createBaseVNode("input", {
                          "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => newQuestion.value.minWords = $event),
                          type: "number",
                          min: "50",
                          class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        }, null, 512), [
                          [
                            vModelText,
                            newQuestion.value.minWords,
                            void 0,
                            { number: true }
                          ]
                        ])
                      ]),
                      createBaseVNode("div", null, [
                        createBaseVNode("label", _hoisted_82$3, toDisplayString$1(unref(t)("grammar.practice.questionManager.timeLimit")), 1),
                        withDirectives(createBaseVNode("input", {
                          "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => newQuestion.value.timeLimit = $event),
                          type: "number",
                          min: "5",
                          class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        }, null, 512), [
                          [
                            vModelText,
                            newQuestion.value.timeLimit,
                            void 0,
                            { number: true }
                          ]
                        ])
                      ])
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_83$3, toDisplayString$1(unref(t)("grammar.practice.questionManager.prompt")), 1),
                    withDirectives(createBaseVNode("textarea", {
                      "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => newQuestion.value.prompt = $event),
                      rows: "3",
                      class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                      placeholder: unref(t)("grammar.practice.questionManager.promptPlaceholder")
                    }, null, 8, _hoisted_84$3), [
                      [vModelText, newQuestion.value.prompt]
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("div", _hoisted_85$3, [
                      createBaseVNode("label", _hoisted_86$2, toDisplayString$1(unref(t)("grammar.practice.questionManager.requirements")), 1),
                      createBaseVNode("button", {
                        onClick: addRequirement,
                        class: "text-sm text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300"
                      }, " + " + toDisplayString$1(unref(t)("grammar.practice.questionManager.addRequirement")), 1)
                    ]),
                    createBaseVNode("div", _hoisted_87$2, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(newQuestion.value.requirements, (requirement, index) => {
                        return openBlock(), createElementBlock("div", {
                          key: index,
                          class: "flex items-center space-x-2"
                        }, [
                          withDirectives(createBaseVNode("input", {
                            "onUpdate:modelValue": ($event) => newQuestion.value.requirements[index] = $event,
                            type: "text",
                            class: "flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                            placeholder: unref(t)("grammar.practice.questionManager.requirementPlaceholder")
                          }, null, 8, _hoisted_88$2), [
                            [vModelText, newQuestion.value.requirements[index]]
                          ]),
                          createBaseVNode("button", {
                            onClick: ($event) => removeRequirement(index),
                            class: "p-2 text-red-600 dark:text-red-400 hover:bg-red-100 dark:hover:bg-red-900/30 rounded",
                            disabled: newQuestion.value.requirements.length === 1
                          }, _cache[33] || (_cache[33] = [
                            createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                              })
                            ], -1)
                          ]), 8, _hoisted_89$2)
                        ]);
                      }), 128))
                    ])
                  ])
                ])) : selectedExerciseTypeForQuestions.value === "multiple-choice" ? (openBlock(), createElementBlock("div", _hoisted_90$2, [
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_91$2, toDisplayString$1(unref(t)("grammar.practice.questionManager.question")), 1),
                    withDirectives(createBaseVNode("textarea", {
                      "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => newQuestion.value.question = $event),
                      rows: "2",
                      class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                      placeholder: unref(t)("grammar.practice.questionManager.questionPlaceholder")
                    }, null, 8, _hoisted_92$2), [
                      [vModelText, newQuestion.value.question]
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_93$2, toDisplayString$1(unref(t)("grammar.practice.questionManager.options")), 1),
                    createBaseVNode("div", _hoisted_94$2, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(newQuestion.value.options, (option, index) => {
                        return openBlock(), createElementBlock("div", {
                          key: index,
                          class: "flex items-center space-x-2"
                        }, [
                          createBaseVNode("span", _hoisted_95$2, toDisplayString$1(String.fromCharCode(65 + index)) + ".", 1),
                          withDirectives(createBaseVNode("input", {
                            "onUpdate:modelValue": ($event) => newQuestion.value.options[index] = $event,
                            type: "text",
                            class: "flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                            placeholder: unref(t)("grammar.practice.questionManager.optionPlaceholder")
                          }, null, 8, _hoisted_96$2), [
                            [vModelText, newQuestion.value.options[index]]
                          ])
                        ]);
                      }), 128))
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_97$2, toDisplayString$1(unref(t)("grammar.practice.questionManager.correctAnswer")), 1),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => newQuestion.value.correctAnswer = $event),
                      class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(newQuestion.value.options, (option, index) => {
                        return openBlock(), createElementBlock("option", {
                          key: index,
                          value: option
                        }, toDisplayString$1(String.fromCharCode(65 + index)) + ". " + toDisplayString$1(option), 9, _hoisted_98$2);
                      }), 128))
                    ], 512), [
                      [vModelSelect, newQuestion.value.correctAnswer]
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_99$2, toDisplayString$1(unref(t)("grammar.practice.questionManager.explanation")), 1),
                    withDirectives(createBaseVNode("textarea", {
                      "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => newQuestion.value.explanation = $event),
                      rows: "2",
                      class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                      placeholder: unref(t)("grammar.practice.questionManager.explanationPlaceholder")
                    }, null, 8, _hoisted_100$1), [
                      [vModelText, newQuestion.value.explanation]
                    ])
                  ])
                ])) : selectedExerciseTypeForQuestions.value === "listening" ? (openBlock(), createElementBlock("div", _hoisted_101$1, [
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_102$1, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.audioUrl")), 1),
                    createBaseVNode("div", _hoisted_103$1, [
                      withDirectives(createBaseVNode("input", {
                        "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => newQuestion.value.audioUrl = $event),
                        type: "text",
                        onInput: handleAudioUrlChange,
                        onPaste: handleUrlPaste,
                        class: "w-full px-3 py-2 pr-20 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                        placeholder: unref(t)("grammar.practice.exercises.listening.audioUrlPlaceholder")
                      }, null, 40, _hoisted_104$1), [
                        [vModelText, newQuestion.value.audioUrl]
                      ]),
                      newQuestion.value.audioUrl ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        onClick: clearAudioUrl,
                        type: "button",
                        class: "absolute right-2 top-1/2 transform -translate-y-1/2 p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors"
                      }, _cache[34] || (_cache[34] = [
                        createBaseVNode("svg", {
                          class: "w-4 h-4",
                          fill: "none",
                          stroke: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          createBaseVNode("path", {
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            "stroke-width": "2",
                            d: "M6 18L18 6M6 6l12 12"
                          })
                        ], -1)
                      ]))) : createCommentVNode("", true)
                    ]),
                    createBaseVNode("div", _hoisted_105$1, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.audioUrlHint")), 1),
                    isYouTubeUrl(newQuestion.value.audioUrl) ? (openBlock(), createElementBlock("div", _hoisted_106$1, [
                      createBaseVNode("div", _hoisted_107$1, [
                        _cache[35] || (_cache[35] = createBaseVNode("svg", {
                          class: "w-4 h-4",
                          fill: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          createBaseVNode("path", { d: "M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z" })
                        ], -1)),
                        createBaseVNode("span", null, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.youtubeDetected")), 1)
                      ]),
                      createBaseVNode("div", _hoisted_108$1, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.youtubeNote")), 1)
                    ])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_109$1, [
                    createBaseVNode("div", null, [
                      createBaseVNode("label", _hoisted_110$1, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.maxPlays")), 1),
                      withDirectives(createBaseVNode("input", {
                        "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => newQuestion.value.maxPlays = $event),
                        type: "number",
                        min: "1",
                        max: "10",
                        class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                      }, null, 512), [
                        [
                          vModelText,
                          newQuestion.value.maxPlays,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("div", null, [
                      createBaseVNode("label", _hoisted_111$1, toDisplayString$1(unref(t)("grammar.practice.settings.difficulty")), 1),
                      withDirectives(createBaseVNode("select", {
                        "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => newQuestion.value.difficulty = $event),
                        class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                      }, [
                        createBaseVNode("option", _hoisted_112, toDisplayString$1(unref(t)("grammar.practice.settings.levels.easy")), 1),
                        createBaseVNode("option", _hoisted_113, toDisplayString$1(unref(t)("grammar.practice.settings.levels.medium")), 1),
                        createBaseVNode("option", _hoisted_114, toDisplayString$1(unref(t)("grammar.practice.settings.levels.hard")), 1)
                      ], 512), [
                        [vModelSelect, newQuestion.value.difficulty]
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_115, [
                      createBaseVNode("label", _hoisted_116, [
                        withDirectives(createBaseVNode("input", {
                          "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => newQuestion.value.allowNotes = $event),
                          type: "checkbox",
                          class: "w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                        }, null, 512), [
                          [vModelCheckbox, newQuestion.value.allowNotes]
                        ]),
                        createBaseVNode("span", _hoisted_117, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.allowNotes")), 1)
                      ])
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_118, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.transcript")), 1),
                    withDirectives(createBaseVNode("textarea", {
                      "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => newQuestion.value.transcript = $event),
                      rows: "3",
                      class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                      placeholder: unref(t)("grammar.practice.exercises.listening.transcriptPlaceholder")
                    }, null, 8, _hoisted_119), [
                      [vModelText, newQuestion.value.transcript]
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_120, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.questions")), 1),
                    createBaseVNode("div", _hoisted_121, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(newQuestion.value.questions, (question, qIndex) => {
                        return openBlock(), createElementBlock("div", {
                          key: qIndex,
                          class: "border border-gray-200 dark:border-gray-600 rounded-lg p-3"
                        }, [
                          createBaseVNode("div", _hoisted_122, [
                            createBaseVNode("span", _hoisted_123, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.question")) + " " + toDisplayString$1(qIndex + 1), 1),
                            createBaseVNode("button", {
                              onClick: ($event) => removeListeningQuestion(qIndex),
                              class: "p-1 text-red-600 dark:text-red-400 hover:bg-red-100 dark:hover:bg-red-900/30 rounded",
                              disabled: newQuestion.value.questions.length === 1
                            }, _cache[36] || (_cache[36] = [
                              createBaseVNode("svg", {
                                class: "w-4 h-4",
                                fill: "none",
                                stroke: "currentColor",
                                viewBox: "0 0 24 24"
                              }, [
                                createBaseVNode("path", {
                                  "stroke-linecap": "round",
                                  "stroke-linejoin": "round",
                                  "stroke-width": "2",
                                  d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                                })
                              ], -1)
                            ]), 8, _hoisted_124)
                          ]),
                          createBaseVNode("div", _hoisted_125, [
                            createBaseVNode("div", null, [
                              withDirectives(createBaseVNode("select", {
                                "onUpdate:modelValue": ($event) => question.type = $event,
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
                              }, [
                                createBaseVNode("option", _hoisted_127, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.multipleChoice")), 1),
                                createBaseVNode("option", _hoisted_128, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.fillBlank")), 1),
                                createBaseVNode("option", _hoisted_129, toDisplayString$1(unref(t)("grammar.practice.exercises.listening.ordering")), 1)
                              ], 8, _hoisted_126), [
                                [vModelSelect, question.type]
                              ])
                            ]),
                            createBaseVNode("div", null, [
                              withDirectives(createBaseVNode("textarea", {
                                "onUpdate:modelValue": ($event) => question.question = $event,
                                rows: "2",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm",
                                placeholder: unref(t)("grammar.practice.questionManager.questionPlaceholder")
                              }, null, 8, _hoisted_130), [
                                [vModelText, question.question]
                              ])
                            ]),
                            question.type === "multiple-choice" ? (openBlock(), createElementBlock("div", _hoisted_131, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(question.options, (option, oIndex) => {
                                return openBlock(), createElementBlock("div", {
                                  key: oIndex,
                                  class: "flex items-center space-x-2"
                                }, [
                                  createBaseVNode("span", _hoisted_132, toDisplayString$1(String.fromCharCode(65 + oIndex)) + ".", 1),
                                  withDirectives(createBaseVNode("input", {
                                    "onUpdate:modelValue": ($event) => question.options[oIndex] = $event,
                                    type: "text",
                                    class: "flex-1 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-1 focus:ring-blue-500 focus:border-transparent text-sm",
                                    placeholder: unref(t)("grammar.practice.questionManager.optionPlaceholder")
                                  }, null, 8, _hoisted_133), [
                                    [vModelText, question.options[oIndex]]
                                  ])
                                ]);
                              }), 128)),
                              createBaseVNode("div", null, [
                                withDirectives(createBaseVNode("select", {
                                  "onUpdate:modelValue": ($event) => question.correctAnswer = $event,
                                  class: "w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-1 focus:ring-blue-500 focus:border-transparent text-sm"
                                }, [
                                  createBaseVNode("option", _hoisted_135, toDisplayString$1(unref(t)("grammar.practice.questionManager.selectCorrectAnswer")), 1),
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(question.options, (option, oIndex) => {
                                    return openBlock(), createElementBlock("option", {
                                      key: oIndex,
                                      value: oIndex
                                    }, toDisplayString$1(String.fromCharCode(65 + oIndex)) + ". " + toDisplayString$1(option), 9, _hoisted_136);
                                  }), 128))
                                ], 8, _hoisted_134), [
                                  [vModelSelect, question.correctAnswer]
                                ])
                              ])
                            ])) : question.type === "fill-blank" ? (openBlock(), createElementBlock("div", _hoisted_137, [
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": ($event) => question.correctAnswer = $event,
                                type: "text",
                                class: "w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-1 focus:ring-blue-500 focus:border-transparent text-sm",
                                placeholder: unref(t)("grammar.practice.exercises.listening.correctAnswerPlaceholder")
                              }, null, 8, _hoisted_138), [
                                [vModelText, question.correctAnswer]
                              ])
                            ])) : createCommentVNode("", true)
                          ])
                        ]);
                      }), 128)),
                      createBaseVNode("button", {
                        onClick: addListeningQuestion,
                        class: "w-full px-3 py-2 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg text-gray-500 dark:text-gray-400 hover:border-blue-400 hover:text-blue-500 transition-colors text-sm"
                      }, " + " + toDisplayString$1(unref(t)("grammar.practice.exercises.listening.addQuestion")), 1)
                    ])
                  ])
                ])) : (openBlock(), createElementBlock("div", _hoisted_139, [
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_140, toDisplayString$1(unref(t)("grammar.practice.questionManager.question")), 1),
                    withDirectives(createBaseVNode("textarea", {
                      "onUpdate:modelValue": _cache[21] || (_cache[21] = ($event) => newQuestion.value.question = $event),
                      rows: "3",
                      class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                      placeholder: unref(t)("grammar.practice.questionManager.questionPlaceholder")
                    }, null, 8, _hoisted_141), [
                      [vModelText, newQuestion.value.question]
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    createBaseVNode("label", _hoisted_142, toDisplayString$1(unref(t)("grammar.practice.questionManager.explanation")), 1),
                    withDirectives(createBaseVNode("textarea", {
                      "onUpdate:modelValue": _cache[22] || (_cache[22] = ($event) => newQuestion.value.explanation = $event),
                      rows: "2",
                      class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                      placeholder: unref(t)("grammar.practice.questionManager.explanationPlaceholder")
                    }, null, 8, _hoisted_143), [
                      [vModelText, newQuestion.value.explanation]
                    ])
                  ])
                ])),
                createBaseVNode("div", _hoisted_144, [
                  createBaseVNode("button", {
                    onClick: addQuestion,
                    class: "px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700 transition-colors"
                  }, toDisplayString$1(editingQuestionIndex.value >= 0 ? unref(t)("common.update") : unref(t)("grammar.practice.questionManager.addQuestion")), 1)
                ])
              ]),
              exerciseQuestions.value[selectedExerciseTypeForQuestions.value]?.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_145, [
                createBaseVNode("h4", _hoisted_146, toDisplayString$1(unref(t)("grammar.practice.questionManager.existingQuestions")) + " (" + toDisplayString$1(exerciseQuestions.value[selectedExerciseTypeForQuestions.value].length) + ") ", 1),
                createBaseVNode("div", _hoisted_147, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(exerciseQuestions.value[selectedExerciseTypeForQuestions.value], (question, index) => {
                    return openBlock(), createElementBlock("div", {
                      key: question.id,
                      class: "bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-4"
                    }, [
                      createBaseVNode("div", _hoisted_148, [
                        createBaseVNode("div", _hoisted_149, [
                          createBaseVNode("div", _hoisted_150, [
                            createBaseVNode("span", _hoisted_151, " #" + toDisplayString$1(index + 1), 1),
                            selectedExerciseTypeForQuestions.value === "writing" ? (openBlock(), createElementBlock("span", _hoisted_152, toDisplayString$1(unref(t)(`grammar.practice.exercises.writing.${question.taskType}`)), 1)) : createCommentVNode("", true)
                          ]),
                          createBaseVNode("div", _hoisted_153, [
                            createBaseVNode("strong", null, toDisplayString$1(selectedExerciseTypeForQuestions.value === "writing" ? unref(t)("grammar.practice.questionManager.prompt") : unref(t)("grammar.practice.questionManager.question")) + ":", 1),
                            createBaseVNode("p", _hoisted_154, toDisplayString$1(selectedExerciseTypeForQuestions.value === "writing" ? question.prompt : question.question), 1)
                          ]),
                          selectedExerciseTypeForQuestions.value === "writing" && question.requirements?.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_155, [
                            createBaseVNode("strong", null, toDisplayString$1(unref(t)("grammar.practice.questionManager.requirements")) + ":", 1),
                            createBaseVNode("ul", _hoisted_156, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(question.requirements, (req) => {
                                return openBlock(), createElementBlock("li", { key: req }, toDisplayString$1(req), 1);
                              }), 128))
                            ])
                          ])) : createCommentVNode("", true),
                          selectedExerciseTypeForQuestions.value === "multiple-choice" && question.options ? (openBlock(), createElementBlock("div", _hoisted_157, [
                            createBaseVNode("strong", null, toDisplayString$1(unref(t)("grammar.practice.questionManager.correctAnswer")) + ":", 1),
                            createTextVNode(" " + toDisplayString$1(question.correctAnswer), 1)
                          ])) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("div", _hoisted_158, [
                          createBaseVNode("button", {
                            onClick: ($event) => editQuestion(index),
                            class: "p-1 rounded text-blue-600 dark:text-blue-400 hover:bg-blue-100 dark:hover:bg-blue-900/30 transition-colors",
                            title: unref(t)("common.edit")
                          }, _cache[37] || (_cache[37] = [
                            createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                              })
                            ], -1)
                          ]), 8, _hoisted_159),
                          createBaseVNode("button", {
                            onClick: ($event) => deleteQuestion(index),
                            class: "p-1 rounded text-red-600 dark:text-red-400 hover:bg-red-100 dark:hover:bg-red-900/30 transition-colors",
                            title: unref(t)("common.delete")
                          }, _cache[38] || (_cache[38] = [
                            createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                              })
                            ], -1)
                          ]), 8, _hoisted_160)
                        ])
                      ])
                    ]);
                  }), 128))
                ])
              ])) : (openBlock(), createElementBlock("div", _hoisted_161, [
                createBaseVNode("div", _hoisted_162, [
                  _cache[39] || (_cache[39] = createBaseVNode("svg", {
                    class: "w-12 h-12 mx-auto mb-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                    })
                  ], -1)),
                  createBaseVNode("p", null, toDisplayString$1(unref(t)("grammar.practice.questionManager.noQuestions")), 1),
                  createBaseVNode("p", _hoisted_163, toDisplayString$1(unref(t)("grammar.practice.questionManager.addFirstQuestion")), 1)
                ])
              ]))
            ]),
            createBaseVNode("div", _hoisted_164, [
              createBaseVNode("button", {
                onClick: closeQuestionManager,
                class: "px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-[#0a0a0a] rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
              }, toDisplayString$1(unref(t)("common.close")), 1)
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const LazyLoadComponent$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => LazyLoadComponent$1),true              ?void 0:void 0));
const VoiceSelector$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VoiceSelector),true              ?void 0:void 0));
const FlashcardHeader$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardHeader),true              ?void 0:void 0));
const FlashcardProgress$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardProgress),true              ?void 0:void 0));
const FlashcardDateFilter$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardDateFilter),true              ?void 0:void 0));
const FlashcardCard$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardCard$1),true              ?void 0:void 0));
const FlashcardQuiz$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardQuiz),true              ?void 0:void 0));
const FlashcardTyping$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardTyping),true              ?void 0:void 0));
const FlashcardImage$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardImage),true              ?void 0:void 0));
const FlashcardControls$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardControls),true              ?void 0:void 0));
const PracticeTimer$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => PracticeTimer$1),true              ?void 0:void 0));
const ExitWarningModal$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ExitWarningModal),true              ?void 0:void 0));
const CompletionModal$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => CompletionModal$1),true              ?void 0:void 0));
const HistoryModal$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => HistoryModal),true              ?void 0:void 0));
const SessionDetailModal$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => SessionDetailModal),true              ?void 0:void 0));
const SettingsModal$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => SettingsModal),true              ?void 0:void 0));
const PronunciationMode$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => PronunciationMode),true              ?void 0:void 0));
const ListeningMode$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ListeningMode$1),true              ?void 0:void 0));
const PracticeStats$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => PracticeStats),true              ?void 0:void 0));
const FlashcardEmptyState$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlashcardEmptyState),true              ?void 0:void 0));
const PictionaryMode$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => PictionaryMode$1),true              ?void 0:void 0));
const FlipTileMode$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FlipTileMode$1),true              ?void 0:void 0));
const BubbleShooterMode$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => BubbleShooterMode$1),true              ?void 0:void 0));
const SnakeGameMode$2 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => SnakeGameMode$1),true              ?void 0:void 0));
const AsyncComponents = {
  LazyLoadComponent: LazyLoadComponent$2,
  VoiceSelector: VoiceSelector$1,
  FlashcardHeader: FlashcardHeader$1,
  FlashcardProgress: FlashcardProgress$1,
  FlashcardDateFilter: FlashcardDateFilter$1,
  FlashcardCard: FlashcardCard$2,
  FlashcardQuiz: FlashcardQuiz$1,
  FlashcardTyping: FlashcardTyping$1,
  FlashcardImage: FlashcardImage$1,
  FlashcardControls: FlashcardControls$1,
  PracticeTimer: PracticeTimer$2,
  ExitWarningModal: ExitWarningModal$1,
  CompletionModal: CompletionModal$2,
  HistoryModal: HistoryModal$1,
  SessionDetailModal: SessionDetailModal$1,
  SettingsModal: SettingsModal$1,
  PronunciationMode: PronunciationMode$1,
  ListeningMode: ListeningMode$2,
  PracticeStats: PracticeStats$1,
  FlashcardEmptyState: FlashcardEmptyState$1,
  PictionaryMode: PictionaryMode$2,
  FlipTileMode: FlipTileMode$2,
  BubbleShooterMode: BubbleShooterMode$2,
  SnakeGameMode: SnakeGameMode$2
};

function useFlashcardGame(flashcards) {
  const router = useRouter();
  const PRACTICE_MODE_STORAGE_KEY = "flashcard-practice-mode";
  const loadPracticeModeFromStorage = () => {
    try {
      const saved = localStorage.getItem(PRACTICE_MODE_STORAGE_KEY);
      if (saved && ["flashcard", "quiz", "typing", "image", "listening", "pronunciation", "pictionary", "flip-tile", "bubble-shooter", "snake-game"].includes(saved)) {
        return saved;
      }
    } catch (error) {
      console.error("Error loading practice mode from localStorage:", error);
    }
    return "flashcard";
  };
  const savePracticeModeToStorage = (mode) => {
    try {
      localStorage.setItem(PRACTICE_MODE_STORAGE_KEY, mode);
    } catch (error) {
      console.error("Error saving practice mode to localStorage:", error);
    }
  };
  const currentIndex = ref(0);
  const isFlipped = ref(false);
  const practiceMode = ref(loadPracticeModeFromStorage());
  const showSettings = ref(false);
  const showCompletionModal = ref(false);
  const isCompleted = ref(false);
  const settings = ref({
    cardCount: 20,
    difficulty: "all",
    autoFlip: false,
    flipDelay: 3,
    showDefinition: true,
    showExample: true,
    showPronunciation: true,
    shuffleCards: false,
    voiceType: "female",
    practiceMode: loadPracticeModeFromStorage()
  });
  const stats = ref({
    easy: 0,
    difficult: 0,
    reviewed: 0,
    correct: 0,
    incorrect: 0,
    total: 0,
    startTime: /* @__PURE__ */ new Date(),
    endTime: null,
    mode: "flashcard"
  });
  stats.value.mode = practiceMode.value;
  watch(practiceMode, (mode) => {
    stats.value.mode = mode;
  });
  const currentCard = computed(() => {
    if (flashcards.value.length === 0) return null;
    return flashcards.value[currentIndex.value];
  });
  const nextCard = () => {
    if (currentIndex.value < flashcards.value.length - 1) {
      currentIndex.value++;
      resetCurrentCard();
    } else {
      completeSession();
    }
  };
  const previousCard = () => {
    if (currentIndex.value > 0) {
      currentIndex.value--;
      resetCurrentCard();
    }
  };
  const flipCard = () => {
    isFlipped.value = !isFlipped.value;
  };
  const resetCurrentCard = () => {
    isFlipped.value = false;
  };
  const completeSession = () => {
    isCompleted.value = true;
    stats.value.endTime = /* @__PURE__ */ new Date();
    showCompletionModal.value = true;
  };
  const restartSession = () => {
    currentIndex.value = 0;
    isCompleted.value = false;
    showCompletionModal.value = false;
    stats.value = {
      easy: 0,
      difficult: 0,
      reviewed: 0,
      correct: 0,
      incorrect: 0,
      total: 0,
      startTime: /* @__PURE__ */ new Date(),
      endTime: null,
      mode: practiceMode.value
    };
    resetCurrentCard();
  };
  const changePracticeMode = (mode) => {
    practiceMode.value = mode;
    settings.value.practiceMode = mode;
    savePracticeModeToStorage(mode);
    resetCurrentCard();
  };
  const applySettings = () => {
    showSettings.value = false;
  };
  const goBack = () => {
    router.push("/");
  };
  const goToVocabulary = () => {
    router.push("/practice/flashcard");
  };
  const markEasy = () => {
    nextCard();
  };
  const markDifficult = () => {
    nextCard();
  };
  let autoFlipTimer = null;
  watch([currentIndex, isFlipped], () => {
    if (autoFlipTimer) {
      clearTimeout(autoFlipTimer);
    }
    if (settings.value.autoFlip && !isFlipped.value) {
      autoFlipTimer = window.setTimeout(() => {
        if (!isFlipped.value) {
          flipCard();
        }
      }, settings.value.flipDelay * 1e3);
    }
  });
  const cleanup = () => {
    if (autoFlipTimer) {
      clearTimeout(autoFlipTimer);
    }
  };
  return {
    // State
    currentIndex,
    isFlipped,
    practiceMode,
    showSettings,
    showCompletionModal,
    isCompleted,
    settings,
    stats,
    // Computed
    flashcards,
    currentCard,
    // Methods
    nextCard,
    previousCard,
    flipCard,
    resetCurrentCard,
    completeSession,
    restartSession,
    changePracticeMode,
    applySettings,
    goBack,
    goToVocabulary,
    markEasy,
    markDifficult,
    cleanup
  };
}

function useFlashcardModes(currentCard, flashcards, allVocabularies, onCorrectAnswer, onIncorrectAnswer) {
  const { playAudio: playVoiceAudio } = useVoiceStore();
  const quizOptions = ref([]);
  const selectedAnswer = ref("");
  const quizAnswered = ref(false);
  const typingAnswer = ref("");
  const typingAnswered = ref(false);
  const typingCorrect = ref(false);
  const typingQuizEnabled = ref(false);
  const typingQuizOptions = ref([]);
  const typingQuizSelected = ref("");
  const typingQuizAnswered = ref(false);
  const listeningAnswer = ref("");
  const listeningAnswered = ref(false);
  const listeningCorrect = ref(false);
  const listeningQuizEnabled = ref(false);
  const listeningQuizOptions = ref([]);
  const listeningQuizSelected = ref("");
  const listeningQuizAnswered = ref(false);
  const imageAnswer = ref("");
  const imageAnswered = ref(false);
  const imageCorrect = ref(false);
  const imageQuizEnabled = ref(false);
  const imageQuizOptions = ref([]);
  const imageQuizSelected = ref("");
  const imageQuizAnswered = ref(false);
  const pictionaryAnswer = ref("");
  const pictionaryAnswered = ref(false);
  const pictionaryCorrect = ref(false);
  const flipTileAnswer = ref("");
  const flipTileAnswered = ref(false);
  const flipTileCorrect = ref(false);
  const bubbleShooterVietnameseMode = ref(false);
  const STORAGE_KEYS = {
    image: "pe_imageQuizEnabled",
    listening: "pe_listeningQuizEnabled",
    typing: "pe_typingQuizEnabled",
    bubbleShooterVietnamese: "pe_bubbleShooterVietnameseMode",
    imagePos: "pe_imageQuiz_correct_pos",
    listeningPos: "pe_listeningQuiz_correct_pos",
    typingPos: "pe_typingQuiz_correct_pos"
  };
  const readBool = (key, def = false) => {
    try {
      const v = localStorage.getItem(key);
      return v === null ? def : v === "true";
    } catch {
      return def;
    }
  };
  imageQuizEnabled.value = readBool(STORAGE_KEYS.image, false);
  listeningQuizEnabled.value = readBool(STORAGE_KEYS.listening, false);
  typingQuizEnabled.value = readBool(STORAGE_KEYS.typing, false);
  bubbleShooterVietnameseMode.value = readBool(STORAGE_KEYS.bubbleShooterVietnamese, false);
  const writeBool = (key, val) => {
    try {
      localStorage.setItem(key, String(val));
    } catch {
    }
  };
  const readNumber = (key, def = 0) => {
    try {
      const v = localStorage.getItem(key);
      const n = v === null ? def : Number(v);
      return Number.isFinite(n) && n >= 0 ? n : def;
    } catch {
      return def;
    }
  };
  const writeNumber = (key, val) => {
    try {
      localStorage.setItem(key, String(val));
    } catch {
    }
  };
  watch(imageQuizEnabled, (v) => writeBool(STORAGE_KEYS.image, v));
  watch(listeningQuizEnabled, (v) => writeBool(STORAGE_KEYS.listening, v));
  watch(typingQuizEnabled, (v) => writeBool(STORAGE_KEYS.typing, v));
  watch(bubbleShooterVietnameseMode, (v) => writeBool(STORAGE_KEYS.bubbleShooterVietnamese, v));
  const imageCorrectPos = ref(readNumber(STORAGE_KEYS.imagePos, Math.floor(Math.random() * 4)));
  const listeningCorrectPos = ref(readNumber(STORAGE_KEYS.listeningPos, Math.floor(Math.random() * 4)));
  const typingCorrectPos = ref(readNumber(STORAGE_KEYS.typingPos, Math.floor(Math.random() * 4)));
  watch(imageCorrectPos, (n) => writeNumber(STORAGE_KEYS.imagePos, n));
  watch(listeningCorrectPos, (n) => writeNumber(STORAGE_KEYS.listeningPos, n));
  watch(typingCorrectPos, (n) => writeNumber(STORAGE_KEYS.typingPos, n));
  const placeWithRotation = (correct, wrongs, posRef) => {
    const options = new Array(4);
    const idx = posRef.value % 4;
    options[idx] = correct;
    const shuffledWrongs = [...wrongs].sort(() => Math.random() - 0.5);
    let wi = 0;
    for (let i = 0; i < 4; i++) {
      if (i === idx) continue;
      options[i] = shuffledWrongs[wi++] ?? "";
    }
    posRef.value = (posRef.value + 1) % 4;
    return options;
  };
  const isRecording = ref(false);
  const pronunciationResult = ref("");
  const pronunciationAnswered = ref(false);
  const pronunciationCorrect = ref(false);
  let recognition = null;
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const isSpeechRecognitionSupported = !!SpeechRecognition;
  if (isSpeechRecognitionSupported) {
    recognition = new SpeechRecognition();
    recognition.continuous = false;
    recognition.lang = "en-US";
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;
    recognition.onresult = (event) => {
      const transcript = event.results[0][0].transcript;
      pronunciationResult.value = transcript;
      checkPronunciationAnswer(transcript);
    };
    recognition.onerror = (event) => {
      console.error("Speech recognition error", event.error);
      isRecording.value = false;
    };
    recognition.onend = () => {
      isRecording.value = false;
    };
  }
  const startRecording = () => {
    if (isRecording.value || !isSpeechRecognitionSupported) return;
    pronunciationResult.value = "";
    pronunciationAnswered.value = false;
    pronunciationCorrect.value = false;
    isRecording.value = true;
    recognition.start();
  };
  const checkPronunciationAnswer = (transcript) => {
    if (!currentCard.value) return false;
    pronunciationAnswered.value = true;
    const userAnswer = transcript.toLowerCase().trim().replace(/[.,/#!$%^&*;:{}=\-_`~()]/g, "");
    const correctAnswer = currentCard.value.word.toLowerCase().trim().replace(/[.,/#!$%^&*;:{}=\-_`~()]/g, "");
    pronunciationCorrect.value = userAnswer === correctAnswer;
    if (pronunciationCorrect.value) ;
    return pronunciationCorrect.value;
  };
  const generateQuizOptions = () => {
    if (!currentCard.value) return;
    const correctAnswer = getShortMeaning(currentCard.value.meaning);
    const allOptions = allVocabularies.value.filter((card) => card.id !== currentCard.value?.id).map((card) => getShortMeaning(card.meaning)).filter((meaning) => meaning !== correctAnswer).sort(() => Math.random() - 0.5).slice(0, 3);
    const wrongOptions = allOptions.length >= 3 ? allOptions.slice(0, 3) : allOptions;
    quizOptions.value = [correctAnswer, ...wrongOptions].sort(() => Math.random() - 0.5);
  };
  const selectQuizAnswer = (answer) => {
    if (quizAnswered.value) return;
    selectedAnswer.value = answer;
    quizAnswered.value = true;
    const correctAnswer = currentCard.value ? getShortMeaning(currentCard.value.meaning) : "";
    const isCorrect = answer === correctAnswer;
    return isCorrect;
  };
  const generateImageQuizOptions = () => {
    if (!currentCard.value) return;
    const correctWord = currentCard.value.word.trim();
    const allWrong = allVocabularies.value.filter((card) => card.id !== currentCard.value?.id).map((card) => card.word.trim()).filter((word) => word.toLowerCase() !== correctWord.toLowerCase()).sort(() => Math.random() - 0.5).slice(0, 3);
    const wrongOptions = allWrong.length >= 3 ? allWrong.slice(0, 3) : allWrong;
    const paddedWrongs = [...new Set(wrongOptions)];
    while (paddedWrongs.length < 3) paddedWrongs.push("");
    imageQuizOptions.value = placeWithRotation(correctWord, paddedWrongs, imageCorrectPos);
  };
  const selectImageQuizAnswer = (answer) => {
    if (imageQuizAnswered.value) return;
    imageQuizSelected.value = answer;
    imageQuizAnswered.value = true;
    const correctWord = currentCard.value ? currentCard.value.word.trim().toLowerCase() : "";
    const isCorrect = answer.trim().toLowerCase() === correctWord;
    imageAnswered.value = true;
    imageCorrect.value = isCorrect;
    return isCorrect;
  };
  const checkTypingAnswer = () => {
    if (!currentCard.value || typingAnswered.value) return;
    typingAnswered.value = true;
    const userAnswer = typingAnswer.value.toLowerCase().trim();
    const correctAnswer = currentCard.value.word.toLowerCase().trim();
    typingCorrect.value = userAnswer === correctAnswer;
    if (typingCorrect.value) ;
    return typingCorrect.value;
  };
  const generateTypingQuizOptions = () => {
    if (!currentCard.value) return;
    const correctWord = currentCard.value.word.trim();
    const allWrong = allVocabularies.value.filter((card) => card.id !== currentCard.value?.id).map((card) => card.word.trim()).filter((word) => word.toLowerCase() !== correctWord.toLowerCase()).sort(() => Math.random() - 0.5).slice(0, 3);
    const wrongOptions = allWrong.length >= 3 ? allWrong.slice(0, 3) : allWrong;
    const paddedWrongs = [...new Set(wrongOptions)];
    while (paddedWrongs.length < 3) paddedWrongs.push("");
    typingQuizOptions.value = placeWithRotation(correctWord, paddedWrongs, typingCorrectPos);
  };
  const selectTypingQuizAnswer = (answer) => {
    if (typingQuizAnswered.value) return;
    typingQuizSelected.value = answer;
    typingQuizAnswered.value = true;
    const correctWord = currentCard.value ? currentCard.value.word.trim().toLowerCase() : "";
    const isCorrect = answer.trim().toLowerCase() === correctWord;
    typingAnswered.value = true;
    typingCorrect.value = isCorrect;
    return isCorrect;
  };
  const checkListeningAnswer = () => {
    if (!currentCard.value || listeningAnswered.value) return;
    listeningAnswered.value = true;
    const userAnswer = listeningAnswer.value.toLowerCase().trim();
    const correctAnswer = currentCard.value.word.toLowerCase().trim();
    listeningCorrect.value = userAnswer === correctAnswer;
    if (listeningCorrect.value) ;
    return listeningCorrect.value;
  };
  const generateListeningQuizOptions = () => {
    if (!currentCard.value) return;
    const correctWord = currentCard.value.word.trim();
    const allWrong = allVocabularies.value.filter((card) => card.id !== currentCard.value?.id).map((card) => card.word.trim()).filter((word) => word.toLowerCase() !== correctWord.toLowerCase()).sort(() => Math.random() - 0.5).slice(0, 3);
    const wrongOptions = allWrong.length >= 3 ? allWrong.slice(0, 3) : allWrong;
    const paddedWrongs = [...new Set(wrongOptions)];
    while (paddedWrongs.length < 3) paddedWrongs.push("");
    listeningQuizOptions.value = placeWithRotation(correctWord, paddedWrongs, listeningCorrectPos);
  };
  const selectListeningQuizAnswer = (answer) => {
    if (listeningQuizAnswered.value) return;
    listeningQuizSelected.value = answer;
    listeningQuizAnswered.value = true;
    const correctWord = currentCard.value ? currentCard.value.word.trim().toLowerCase() : "";
    const isCorrect = answer.trim().toLowerCase() === correctWord;
    listeningAnswered.value = true;
    listeningCorrect.value = isCorrect;
    return isCorrect;
  };
  const checkImageAnswer = () => {
    if (!currentCard.value || imageAnswered.value) return;
    imageAnswered.value = true;
    const userAnswer = imageAnswer.value.toLowerCase().trim();
    const correctAnswer = currentCard.value.word.toLowerCase().trim();
    imageCorrect.value = userAnswer === correctAnswer;
    if (imageCorrect.value) ;
    return imageCorrect.value;
  };
  const checkPictionaryAnswer = () => {
    if (!currentCard.value || pictionaryAnswered.value) return;
    pictionaryAnswered.value = true;
    const userAnswer = pictionaryAnswer.value.toLowerCase().trim();
    const correctAnswer = currentCard.value.word.toLowerCase().trim();
    pictionaryCorrect.value = userAnswer === correctAnswer;
    if (pictionaryCorrect.value) ;
    return pictionaryCorrect.value;
  };
  const checkFlipTileAnswer = () => {
    if (!currentCard.value || flipTileAnswered.value) return;
    flipTileAnswered.value = true;
    const userAnswer = flipTileAnswer.value.toLowerCase().trim();
    const correctAnswer = currentCard.value.word.toLowerCase().trim();
    flipTileCorrect.value = userAnswer === correctAnswer;
    if (flipTileCorrect.value) ;
    return flipTileCorrect.value;
  };
  const playAudio = async () => {
    if (!currentCard.value) return;
    try {
      await playVoiceAudio(currentCard.value.word);
    } catch (error) {
      console.error("Error playing audio:", error);
      const utterance = new SpeechSynthesisUtterance(currentCard.value.word);
      utterance.lang = "en-US";
      utterance.rate = 0.8;
      speechSynthesis.speak(utterance);
    }
  };
  const resetQuizMode = () => {
    quizOptions.value = [];
    selectedAnswer.value = "";
    quizAnswered.value = false;
  };
  const resetTypingMode = () => {
    typingAnswer.value = "";
    typingAnswered.value = false;
    typingCorrect.value = false;
    typingQuizOptions.value = [];
    typingQuizSelected.value = "";
    typingQuizAnswered.value = false;
  };
  const resetListeningMode = () => {
    listeningAnswer.value = "";
    listeningAnswered.value = false;
    listeningCorrect.value = false;
    listeningQuizOptions.value = [];
    listeningQuizSelected.value = "";
    listeningQuizAnswered.value = false;
  };
  const resetImageMode = () => {
    imageAnswer.value = "";
    imageAnswered.value = false;
    imageCorrect.value = false;
    imageQuizOptions.value = [];
    imageQuizSelected.value = "";
    imageQuizAnswered.value = false;
  };
  const resetPictionaryMode = () => {
    pictionaryAnswer.value = "";
    pictionaryAnswered.value = false;
    pictionaryCorrect.value = false;
  };
  const resetFlipTileMode = () => {
    flipTileAnswer.value = "";
    flipTileAnswered.value = false;
    flipTileCorrect.value = false;
  };
  const resetPronunciationMode = () => {
    if (recognition && isRecording.value) {
      recognition.stop();
    }
    isRecording.value = false;
    pronunciationResult.value = "";
    pronunciationAnswered.value = false;
    pronunciationCorrect.value = false;
  };
  const resetAllModes = () => {
    resetQuizMode();
    resetTypingMode();
    resetListeningMode();
    resetImageMode();
    resetPronunciationMode();
    resetPictionaryMode();
    resetFlipTileMode();
  };
  const getCanProceed = () => {
    return {
      flashcard: true,
      quiz: quizAnswered.value,
      typing: typingAnswered.value,
      listening: listeningAnswered.value,
      image: imageAnswered.value,
      pronunciation: pronunciationAnswered.value,
      pictionary: pictionaryAnswered.value,
      "flip-tile": flipTileAnswered.value,
      "snake-game": true,
      "bubble-shooter": true
    };
  };
  const getShortMeaning = (meaning) => {
    return meaning.split(" - ")[0].trim();
  };
  return {
    // Quiz mode
    quizOptions,
    selectedAnswer,
    quizAnswered,
    generateQuizOptions,
    selectQuizAnswer,
    resetQuizMode,
    // Typing mode
    typingAnswer,
    typingAnswered,
    typingCorrect,
    checkTypingAnswer,
    resetTypingMode,
    // Typing-Quiz (within Typing mode)
    typingQuizEnabled,
    typingQuizOptions,
    typingQuizSelected,
    typingQuizAnswered,
    generateTypingQuizOptions,
    selectTypingQuizAnswer,
    // Listening mode
    listeningAnswer,
    listeningAnswered,
    listeningCorrect,
    checkListeningAnswer,
    playAudio,
    resetListeningMode,
    // Listening-Quiz (within Listening mode)
    listeningQuizEnabled,
    listeningQuizOptions,
    listeningQuizSelected,
    listeningQuizAnswered,
    generateListeningQuizOptions,
    selectListeningQuizAnswer,
    // Image mode
    imageAnswer,
    imageAnswered,
    imageCorrect,
    checkImageAnswer,
    resetImageMode,
    // Image-Quiz (within Image mode)
    imageQuizEnabled,
    imageQuizOptions,
    imageQuizSelected,
    imageQuizAnswered,
    generateImageQuizOptions,
    selectImageQuizAnswer,
    // Pictionary mode
    pictionaryAnswer,
    pictionaryAnswered,
    pictionaryCorrect,
    checkPictionaryAnswer,
    resetPictionaryMode,
    // Flip tile mode
    flipTileAnswer,
    flipTileAnswered,
    flipTileCorrect,
    checkFlipTileAnswer,
    resetFlipTileMode,
    // Bubble Shooter mode
    bubbleShooterVietnameseMode,
    // Pronunciation mode
    isRecording,
    pronunciationResult,
    pronunciationAnswered,
    pronunciationCorrect,
    isSpeechRecognitionSupported,
    startRecording,
    resetPronunciationMode,
    // General
    resetAllModes,
    getCanProceed,
    getShortMeaning
  };
}

function useFlashcardHistory() {
  const showHistory = ref(false);
  const practiceHistory = ref([]);
  const { t, locale } = useI18n();
  const loadPracticeHistory = () => {
    const saved = localStorage.getItem("flashcard-practice-history");
    if (saved) {
      const parsed = JSON.parse(saved);
      practiceHistory.value = parsed.map((item) => {
        if (item.hasDetails === void 0) {
          const has = !!localStorage.getItem(`flashcard-session-details:${item.id}`);
          return { ...item, hasDetails: has };
        }
        return item;
      });
      savePracticeHistory();
    }
  };
  const savePracticeHistory = () => {
    localStorage.setItem("flashcard-practice-history", JSON.stringify(practiceHistory.value));
  };
  const saveSessionToHistory = (stats, totalCards, sessionId) => {
    const duration = stats.endTime && stats.startTime ? Math.round((stats.endTime.getTime() - stats.startTime.getTime()) / 1e3) : 0;
    const total = stats.correct + stats.incorrect;
    const accuracy = total > 0 ? Math.round(stats.correct / total * 100) : 0;
    const score = Math.round(accuracy * (totalCards / 100));
    const id = sessionId || Date.now().toString();
    const historyItem = {
      id,
      date: (/* @__PURE__ */ new Date()).toISOString(),
      mode: stats.mode,
      totalCards,
      correctAnswers: stats.correct,
      incorrectAnswers: stats.incorrect,
      accuracy,
      duration,
      score,
      categories: stats.categories || [],
      hasDetails: true
    };
    practiceHistory.value.unshift(historyItem);
    if (practiceHistory.value.length > 50) {
      practiceHistory.value = practiceHistory.value.slice(0, 50);
    }
    savePracticeHistory();
    return id;
  };
  const getModeColor = (mode) => {
    switch (mode) {
      case "flashcard":
        return "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200";
      case "quiz":
        return "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200";
      case "typing":
        return "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200";
      case "listening":
        return "bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200";
      case "image":
        return "bg-pink-100 text-pink-800 dark:bg-pink-900 dark:text-pink-200";
      case "pictionary":
        return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200";
      case "pronunciation":
        return "bg-indigo-100 text-indigo-800 dark:bg-indigo-900 dark:text-indigo-200";
      case "bubble-shooter":
        return "bg-teal-100 text-teal-800 dark:bg-teal-900 dark:text-teal-200";
      case "snake-game":
        return "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200";
      default:
        return "bg-cyan-100 text-cyan-800 dark:bg-cyan-900 dark:text-cyan-200";
    }
  };
  const getModeText = (mode) => {
    switch (mode) {
      case "flashcard":
        return t("flashcard.modes.flashcard", "Flashcard");
      case "quiz":
        return t("flashcard.modes.quiz", "Quiz");
      case "typing":
        return t("flashcard.modes.typing", "Typing");
      case "listening":
        return t("flashcard.modes.listening", "Listening");
      case "image":
        return t("flashcard.modes.image", "Image");
      case "pictionary":
        return t("flashcard.modes.pictionary", "Pictionary");
      case "pronunciation":
        return t("flashcard.modes.pronunciation", "Pronunciation");
      case "bubble-shooter":
        return t("flashcard.modes.bubbleShooter", "Bubble Shooter");
      case "snake-game":
        return t("flashcard.modes.snakeGame", "Snake Hunt");
      default:
        return "Unknown";
    }
  };
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    const now = /* @__PURE__ */ new Date();
    const diffTime = now.getTime() - date.getTime();
    const diffDays = Math.floor(diffTime / (1e3 * 60 * 60 * 24));
    const currentLocale = locale.value === "en" ? "en-US" : "vi-VN";
    if (diffDays === 0) {
      return locale.value === "en" ? "Today" : "Hm nay";
    } else if (diffDays === 1) {
      return locale.value === "en" ? "Yesterday" : "Hm qua";
    } else if (diffDays < 7) {
      return locale.value === "en" ? `${diffDays} days ago` : `${diffDays} ngy trc`;
    } else {
      return date.toLocaleDateString(currentLocale);
    }
  };
  const formatDuration = (seconds) => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
  };
  const clearHistory = () => {
    practiceHistory.value = [];
    savePracticeHistory();
    Object.keys(localStorage).forEach((key) => {
      if (key.startsWith("flashcard-session-details:")) {
        localStorage.removeItem(key);
      }
    });
  };
  const deleteSession = (sessionId) => {
    practiceHistory.value = practiceHistory.value.filter((item) => item.id !== sessionId);
    savePracticeHistory();
    localStorage.removeItem(`flashcard-session-details:${sessionId}`);
  };
  const getHistoryStats = () => {
    if (practiceHistory.value.length === 0) {
      return {
        totalSessions: 0,
        averageAccuracy: 0,
        totalCards: 0,
        totalTime: 0,
        bestScore: 0,
        favoriteMode: ""
      };
    }
    const totalSessions = practiceHistory.value.length;
    const totalCards = practiceHistory.value.reduce((sum, item) => sum + item.totalCards, 0);
    const totalTime = practiceHistory.value.reduce((sum, item) => sum + item.duration, 0);
    const averageAccuracy = Math.round(
      practiceHistory.value.reduce((sum, item) => sum + item.accuracy, 0) / totalSessions
    );
    const bestScore = Math.max(...practiceHistory.value.map((item) => item.score));
    const modeCount = practiceHistory.value.reduce((acc, item) => {
      acc[item.mode] = (acc[item.mode] || 0) + 1;
      return acc;
    }, {});
    const favoriteMode = Object.entries(modeCount).sort(([, a], [, b]) => b - a)[0]?.[0] || "";
    return {
      totalSessions,
      averageAccuracy,
      totalCards,
      totalTime,
      bestScore,
      favoriteMode
    };
  };
  onMounted(() => {
    loadPracticeHistory();
  });
  return {
    showHistory,
    practiceHistory,
    saveSessionToHistory,
    getModeColor,
    getModeText,
    formatDate,
    formatDuration,
    clearHistory,
    deleteSession,
    getHistoryStats
  };
}

function useFlashcardSettings() {
  const showSettings = ref(false);
  const defaultSettings = {
    cardCount: 20,
    difficulty: "all",
    autoFlip: false,
    flipDelay: 3,
    showDefinition: true,
    showExample: true,
    showPronunciation: true,
    shuffleCards: false,
    voiceType: "female",
    practiceMode: "flashcard",
    category: "",
    level: "",
    useFlipTileHints: true
  };
  const settings = ref({ ...defaultSettings });
  const localSettings = ref({ ...defaultSettings });
  const loadSettings = () => {
    const saved = localStorage.getItem("flashcard-settings");
    if (saved) {
      try {
        const parsedSettings = JSON.parse(saved);
        settings.value = { ...defaultSettings, ...parsedSettings };
        localSettings.value = { ...settings.value };
      } catch (error) {
        console.error("Error loading settings:", error);
        settings.value = { ...defaultSettings };
        localSettings.value = { ...defaultSettings };
      }
    }
  };
  const saveSettings = () => {
    localStorage.setItem("flashcard-settings", JSON.stringify(settings.value));
  };
  const applySettings = () => {
    settings.value = { ...localSettings.value };
    saveSettings();
    showSettings.value = false;
  };
  const resetSettings = () => {
    settings.value = { ...defaultSettings };
    localSettings.value = { ...defaultSettings };
    saveSettings();
  };
  const cancelSettings = () => {
    localSettings.value = { ...settings.value };
    showSettings.value = false;
  };
  const openSettings = () => {
    localSettings.value = { ...settings.value };
    showSettings.value = true;
  };
  const validateSettings = (settingsToValidate) => {
    const errors = [];
    if (settingsToValidate.cardCount < 1 || settingsToValidate.cardCount > 100) {
      errors.push("S lng th phi t 1 n 100");
    }
    if (settingsToValidate.flipDelay < 1 || settingsToValidate.flipDelay > 10) {
      errors.push("Thi gian lt th phi t 1 n 10 giy");
    }
    return errors;
  };
  const getDifficultyLevels = () => {
    return [
      { value: "all", label: "Tt c" },
      { value: "easy", label: "D" },
      { value: "medium", label: "Trung bnh" },
      { value: "hard", label: "Kh" }
    ];
  };
  const getFlipDelayOptions = () => {
    return [
      { value: 1, label: "1 giy" },
      { value: 2, label: "2 giy" },
      { value: 3, label: "3 giy" },
      { value: 4, label: "4 giy" },
      { value: 5, label: "5 giy" },
      { value: 10, label: "10 giy" }
    ];
  };
  const getCardCountOptions = () => {
    return [
      { value: 10, label: "10 th" },
      { value: 20, label: "20 th" },
      { value: 30, label: "30 th" },
      { value: 50, label: "50 th" },
      { value: 100, label: "100 th" }
    ];
  };
  const getVoiceTypeOptions = () => {
    return [
      { value: "female", label: "Ging n", icon: "" },
      { value: "male", label: "Ging nam", icon: "" }
    ];
  };
  const getSettingsPresets = () => {
    return {
      beginner: {
        ...defaultSettings,
        cardCount: 10,
        difficulty: "easy",
        autoFlip: true,
        flipDelay: 5,
        showDefinition: true,
        showExample: true,
        showPronunciation: true
      },
      intermediate: {
        ...defaultSettings,
        cardCount: 20,
        difficulty: "medium",
        autoFlip: false,
        showDefinition: true,
        showExample: true,
        showPronunciation: false
      },
      advanced: {
        ...defaultSettings,
        cardCount: 50,
        difficulty: "hard",
        autoFlip: false,
        showDefinition: false,
        showExample: false,
        showPronunciation: false
      }
    };
  };
  const applyPreset = (presetName) => {
    const presets = getSettingsPresets();
    localSettings.value = { ...presets[presetName] };
  };
  watch(settings, () => {
    saveSettings();
  }, { deep: true });
  onMounted(() => {
    loadSettings();
  });
  return {
    showSettings,
    settings,
    localSettings,
    applySettings,
    resetSettings,
    cancelSettings,
    openSettings,
    validateSettings,
    getDifficultyLevels,
    getFlipDelayOptions,
    getCardCountOptions,
    getVoiceTypeOptions,
    getSettingsPresets,
    applyPreset
  };
}

function useFlashcardStats(stats) {
  const sessionStats = ref({
    totalCards: 0,
    currentCard: 0,
    correctAnswers: 0,
    incorrectAnswers: 0,
    accuracy: 0,
    streak: 0,
    maxStreak: 0,
    timeSpent: 0,
    averageTimePerCard: 0,
    score: 0
  });
  const currentStreak = ref(0);
  const maxStreak = ref(0);
  const cardStartTime = ref(null);
  const cardTimes = ref([]);
  const initializeStats = (totalCards) => {
    sessionStats.value = {
      totalCards,
      currentCard: 0,
      correctAnswers: 0,
      incorrectAnswers: 0,
      accuracy: 0,
      streak: 0,
      maxStreak: 0,
      timeSpent: 0,
      averageTimePerCard: 0,
      score: 0
    };
    currentStreak.value = 0;
    maxStreak.value = 0;
    cardTimes.value = [];
    cardStartTime.value = /* @__PURE__ */ new Date();
  };
  const recordAnswer = (isCorrect) => {
    if (isCorrect) {
      sessionStats.value.correctAnswers++;
      stats.value.correct++;
      currentStreak.value++;
      if (currentStreak.value > maxStreak.value) {
        maxStreak.value = currentStreak.value;
      }
    } else {
      sessionStats.value.incorrectAnswers++;
      stats.value.incorrect++;
      currentStreak.value = 0;
    }
    stats.value.total++;
    if (cardStartTime.value) {
      const timeSpent = (/* @__PURE__ */ new Date()).getTime() - cardStartTime.value.getTime();
      cardTimes.value.push(timeSpent);
      cardStartTime.value = /* @__PURE__ */ new Date();
    }
    nextCardStats();
  };
  const nextCardStats = () => {
    stats.value.reviewed++;
    sessionStats.value.currentCard++;
    cardStartTime.value = /* @__PURE__ */ new Date();
  };
  const getPerformanceLevel = computed(() => {
    const accuracy = sessionStats.value.accuracy;
    if (accuracy >= 90) return { level: "Xut sc", color: "text-green-600 dark:text-green-400" };
    if (accuracy >= 80) return { level: "Tt", color: "text-blue-600 dark:text-blue-400" };
    if (accuracy >= 70) return { level: "Kh", color: "text-yellow-600 dark:text-yellow-400" };
    if (accuracy >= 60) return { level: "Trung bnh", color: "text-orange-600 dark:text-orange-400" };
    return { level: "Cn ci thin", color: "text-red-600 dark:text-red-400" };
  });
  const getStreakMessage = computed(() => {
    const streak = currentStreak.value;
    if (streak === 0) return "";
    if (streak < 3) return "Bt u tt!";
    if (streak < 5) return "ang tin b!";
    if (streak < 10) return "Tuyt vi!";
    return "Xut sc!";
  });
  const getSpeedRating = computed(() => {
    const avgTime = sessionStats.value.averageTimePerCard / 1e3;
    if (avgTime === 0) return { rating: "", color: "" };
    if (avgTime < 2) return { rating: "Rt nhanh", color: "text-green-600 dark:text-green-400" };
    if (avgTime < 4) return { rating: "Nhanh", color: "text-blue-600 dark:text-blue-400" };
    if (avgTime < 6) return { rating: "Trung bnh", color: "text-yellow-600 dark:text-yellow-400" };
    if (avgTime < 10) return { rating: "Chm", color: "text-orange-600 dark:text-orange-400" };
    return { rating: "Rt chm", color: "text-red-600 dark:text-red-400" };
  });
  const formatTime = (milliseconds) => {
    const seconds = Math.floor(milliseconds / 1e3);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    if (minutes > 0) {
      return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
    }
    return `${remainingSeconds}s`;
  };
  const getDetailedStats = computed(() => {
    return {
      ...sessionStats.value,
      performanceLevel: getPerformanceLevel.value,
      streakMessage: getStreakMessage.value,
      speedRating: getSpeedRating.value,
      timeSpentFormatted: formatTime(sessionStats.value.timeSpent),
      averageTimeFormatted: formatTime(sessionStats.value.averageTimePerCard),
      completion: sessionStats.value.totalCards > 0 ? Math.round(sessionStats.value.currentCard / sessionStats.value.totalCards * 100) : 0
    };
  });
  return {
    sessionStats,
    currentStreak,
    maxStreak,
    initializeStats,
    recordAnswer,
    nextCardStats,
    getPerformanceLevel,
    getStreakMessage,
    getSpeedRating,
    formatTime,
    getDetailedStats
  };
}

const makeKey = (sessionId) => `flashcard-session-details:${sessionId}`;
function usePracticeSessionDetails() {
  const currentSessionId = ref(null);
  const currentMode = ref("");
  const startSessionDetails = (sessionId, mode) => {
    currentSessionId.value = sessionId;
    currentMode.value = mode;
    const initial = {
      sessionId,
      mode,
      total: 0,
      correct: 0,
      incorrect: 0,
      entries: []
    };
    try {
      localStorage.setItem(makeKey(sessionId), JSON.stringify(initial));
    } catch {
    }
  };
  const appendAnswer = (payload) => {
    if (!currentSessionId.value) return;
    const key = makeKey(currentSessionId.value);
    let data = null;
    try {
      const raw = localStorage.getItem(key);
      data = raw ? JSON.parse(raw) : null;
    } catch {
    }
    if (!data) {
      data = {
        sessionId: currentSessionId.value,
        mode: currentMode.value,
        total: 0,
        correct: 0,
        incorrect: 0,
        entries: []
      };
    }
    const entry = {
      ...payload,
      timestamp: payload.timestamp || (/* @__PURE__ */ new Date()).toISOString()
    };
    data.entries.push(entry);
    data.total += 1;
    if (entry.isCorrect) data.correct += 1;
    else data.incorrect += 1;
    try {
      localStorage.setItem(key, JSON.stringify(data));
    } catch {
    }
  };
  const loadDetails = (sessionId) => {
    try {
      const raw = localStorage.getItem(makeKey(sessionId));
      return raw ? JSON.parse(raw) : null;
    } catch {
      return null;
    }
  };
  const clearDetails = (sessionId) => {
    try {
      localStorage.removeItem(makeKey(sessionId));
    } catch {
    }
  };
  return {
    currentSessionId,
    currentMode,
    startSessionDetails,
    appendAnswer,
    loadDetails,
    clearDetails
  };
}

const _hoisted_1$1j = { class: "min-h-screen overflow-x-hidden bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-dark-bg-soft dark:to-dark-bg-mute relative" };
const _hoisted_2$1g = { class: "max-w-4xl mx-auto px-3 sm:px-4 md:px-6 py-2 sm:py-3 md:py-4" };
const _hoisted_3$1d = { class: "group bg-white/80 dark:bg-dark-bg-soft/80 backdrop-blur-md rounded-2xl shadow-xl hover:shadow-2xl border border-white/20 dark:border-dark-bg-mute transition-all duration-500 hover:scale-[1.01] hover:-translate-y-0.5 p-3 sm:p-4 md:p-5" };
const _hoisted_4$19 = { class: "max-w-4xl mx-auto px-3 sm:px-4 md:px-6 py-2 sm:py-3 md:py-4" };
const _hoisted_5$16 = { class: "group relative overflow-visible bg-white/80 dark:bg-dark-bg-soft/80 backdrop-blur-md rounded-2xl shadow-xl hover:shadow-2xl border border-white/20 dark:border-dark-bg-mute transition-all duration-500 hover:scale-[1.01] hover:-translate-y-0.5 p-3 sm:p-4 md:p-5" };
const _hoisted_6$13 = { class: "max-w-4xl mx-auto px-3 sm:px-4 md:px-6 py-4 sm:py-6 md:py-8" };
const _hoisted_7$$ = {
  key: 0,
  class: "relative"
};
const _hoisted_8$Z = { class: "group relative overflow-hidden bg-white/80 dark:bg-dark-bg-soft/80 backdrop-blur-md rounded-2xl shadow-xl hover:shadow-2xl border border-white/20 dark:border-dark-bg-mute transition-all duration-500 p-3 sm:p-4 md:p-6" };
const _hoisted_9$Y = { class: "space-y-4 sm:space-y-5 md:space-y-6" };
const _hoisted_10$X = { class: "flex justify-center max-w-md mx-auto" };
const _hoisted_11$X = { key: 0 };
const STORAGE_KEY = "flashcard-date-filter";
const _sfc_main$1k = /* @__PURE__ */ defineComponent({
  ...{ components: AsyncComponents },
  __name: "FlashcardView",
  setup(__props) {
    const ConfirmToast$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ConfirmToast),true              ?void 0:void 0));
    const { t } = useI18n();
    const router = useRouter();
    const toast = useToast();
    const { allVocabularies } = useVocabularyStore();
    const modalStore = useModalStore();
    const {
      startSessionDetails,
      appendAnswer,
      loadDetails
    } = usePracticeSessionDetails();
    const activeSessionId = ref(null);
    const showSessionDetail = ref(false);
    const selectedSessionDetails = ref(null);
    const latestPictionarySnapshot = ref(null);
    const onPictionarySnapshot = (payload) => {
      latestPictionarySnapshot.value = payload;
    };
    const openHistoryDetails = (sessionId) => {
      const details = loadDetails(sessionId);
      selectedSessionDetails.value = details;
      showSessionDetail.value = true;
    };
    const handleDeleteSession = (sessionId) => {
      const toastId = toast(
        {
          component: ConfirmToast$1,
          props: {
            message: t("flashcard.history.confirmDelete.message", "Are you sure you want to delete this practice session? This action cannot be undone."),
            confirmText: t("flashcard.history.confirmDelete.confirm", "Delete"),
            cancelText: t("flashcard.history.confirmDelete.cancel", "Cancel"),
            onConfirm: () => {
              deleteSession(sessionId);
              toast.success(t("flashcard.history.confirmDelete.success", "Session deleted successfully"));
              toast.dismiss(toastId);
            },
            onCancel: () => {
              toast.dismiss(toastId);
            }
          }
        },
        {
          timeout: 0,
          closeOnClick: false,
          showCloseButtonOnHover: false,
          hideProgressBar: true
        }
      );
    };
    const loadDateFilterState = () => {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const parsed = JSON.parse(saved);
          return {
            selectedDate: parsed.selectedDate || ""
          };
        }
      } catch (error) {
        console.error("Error loading date filter state:", error);
      }
      return { selectedDate: "" };
    };
    const saveDateFilterState = () => {
      try {
        const state = { selectedDate: selectedDate.value };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (error) {
        console.error("Error saving date filter state:", error);
      }
    };
    const initialState = loadDateFilterState();
    const dateFilterEnabled = ref(true);
    const selectedDate = ref(initialState.selectedDate);
    watch(selectedDate, () => {
      saveDateFilterState();
    });
    const bubbleShooterVietnameseMode = ref(false);
    const snakeDoubleBaitMode = ref(false);
    const pictionaryDefinitionMode = ref(false);
    const scrambleWordsEnabled = ref(false);
    const wordsCrushEnabled = ref(false);
    const loadBubbleShooterVietnameseModeFromStorage = () => {
      try {
        const saved = localStorage.getItem("pe_bubbleShooterVietnameseMode");
        return saved === null ? false : saved === "true";
      } catch {
        return false;
      }
    };
    const saveBubbleShooterVietnameseModeToStorage = (enabled) => {
      try {
        localStorage.setItem("pe_bubbleShooterVietnameseMode", String(enabled));
      } catch {
      }
    };
    const loadSnakeDoubleBaitModeFromStorage = () => {
      try {
        const saved = localStorage.getItem("pe_snakeDoubleBaitMode");
        return saved === null ? false : saved === "true";
      } catch {
        return false;
      }
    };
    const saveSnakeDoubleBaitModeToStorage = (enabled) => {
      try {
        localStorage.setItem("pe_snakeDoubleBaitMode", String(enabled));
      } catch {
      }
    };
    const loadPictionaryDefinitionModeFromStorage = () => {
      try {
        const saved = localStorage.getItem("pe_pictionaryDefinitionMode");
        return saved === null ? false : saved === "true";
      } catch {
        return false;
      }
    };
    const savePictionaryDefinitionModeToStorage = (enabled) => {
      try {
        localStorage.setItem("pe_pictionaryDefinitionMode", String(enabled));
      } catch {
      }
    };
    const loadScrambleWordsModeFromStorage = () => {
      try {
        const saved = localStorage.getItem("pe_scrambleWordsEnabled");
        return saved === null ? false : saved === "true";
      } catch {
        return false;
      }
    };
    const saveScrambleWordsModeToStorage = (enabled) => {
      try {
        localStorage.setItem("pe_scrambleWordsEnabled", String(enabled));
      } catch {
      }
    };
    const loadWordsCrushModeFromStorage = () => {
      try {
        const saved = localStorage.getItem("pe_wordsCrushEnabled");
        return saved === null ? false : saved === "true";
      } catch {
        return false;
      }
    };
    const saveWordsCrushModeToStorage = (enabled) => {
      try {
        localStorage.setItem("pe_wordsCrushEnabled", String(enabled));
      } catch {
      }
    };
    bubbleShooterVietnameseMode.value = loadBubbleShooterVietnameseModeFromStorage();
    snakeDoubleBaitMode.value = loadSnakeDoubleBaitModeFromStorage();
    pictionaryDefinitionMode.value = loadPictionaryDefinitionModeFromStorage();
    scrambleWordsEnabled.value = loadScrambleWordsModeFromStorage();
    wordsCrushEnabled.value = loadWordsCrushModeFromStorage();
    watch(bubbleShooterVietnameseMode, (newVal) => {
      saveBubbleShooterVietnameseModeToStorage(newVal);
    });
    watch(snakeDoubleBaitMode, (newVal) => {
      saveSnakeDoubleBaitModeToStorage(newVal);
    });
    watch(pictionaryDefinitionMode, (newVal) => {
      savePictionaryDefinitionModeToStorage(newVal);
    });
    watch(scrambleWordsEnabled, (newVal) => {
      saveScrambleWordsModeToStorage(newVal);
    });
    watch(wordsCrushEnabled, (newVal) => {
      saveWordsCrushModeToStorage(newVal);
    });
    const {
      showSettings: showSettingsDialog,
      settings: flashcardSettings,
      localSettings,
      applySettings: applyGameSettings,
      cancelSettings} = useFlashcardSettings();
    const filteredVocabularies = computed(() => {
      let vocabularies = allVocabularies.value;
      if (selectedDate.value) {
        vocabularies = vocabularies.filter((vocab) => {
          const vocabDateKey = getDateKey(vocab.createdAt);
          return vocabDateKey === selectedDate.value;
        });
      }
      if (flashcardSettings.value.category) {
        vocabularies = vocabularies.filter((vocab) => vocab.category === flashcardSettings.value.category);
      }
      return vocabularies;
    });
    const baseFlashcards = computed(() => {
      return filteredVocabularies.value.filter((vocab) => {
        const category = flashcardSettings.value.category;
        const difficulty = flashcardSettings.value.difficulty;
        const categoryMatch = !category || vocab.category === category;
        const levelMatch = !difficulty || difficulty === "all" || vocab.level === difficulty;
        return categoryMatch && levelMatch;
      });
    });
    const imageModeAvailable = computed(() => {
      const cards = baseFlashcards.value;
      if (cards.length === 0) return false;
      return cards.every((v) => {
        const img = v.image;
        if (img == null) return false;
        const s = typeof img === "string" ? img : String(img);
        return s.trim().length > 0;
      });
    });
    const pictionaryModeAvailable = computed(() => {
      const cards = baseFlashcards.value;
      if (cards.length === 0) return false;
      return cards.every((v) => {
        const img = v.image;
        if (img == null) return false;
        const s = typeof img === "string" ? img : String(img);
        return s.trim().length > 0;
      });
    });
    const flipTileModeAvailable = computed(() => {
      const cards = baseFlashcards.value;
      if (cards.length === 0) return false;
      return cards.every((v) => {
        const img = v.image;
        if (img == null) return false;
        const s = typeof img === "string" ? img : String(img);
        return s.trim().length > 0;
      });
    });
    const bubbleShooterModeAvailable = computed(() => {
      if (!selectedDate.value) {
        return filteredVocabularies.value.length <= 8;
      }
      const dateFilteredVocabs = allVocabularies.value.filter((vocab) => {
        const vocabDateKey = getDateKey(vocab.createdAt);
        return vocabDateKey === selectedDate.value;
      });
      return dateFilteredVocabs.length <= 8;
    });
    const practiceStarted = ref(false);
    const practiceTimerRef = ref();
    const showExitWarning = ref(false);
    const allowExit = ref(false);
    const handlePracticeStart = () => {
      practiceStarted.value = true;
      console.log("Practice started!");
      activeSessionId.value = `${Date.now()}`;
      startSessionDetails(activeSessionId.value, practiceMode.value);
    };
    const handleExitPractice = () => {
      if (practiceStarted.value && !allowExit.value) {
        showExitWarning.value = true;
      } else {
        router.push("/practice/flashcard");
      }
    };
    const handleTimeout = () => {
      console.log("Time out for current card!");
    };
    const handleTimerRestart = () => {
      console.log("Timer restarted: restarting from the first card");
      practiceStarted.value = true;
      if (flashcardSettings.value.shuffleCards && baseFlashcards.value.length > 0) {
        shuffleFlashcards();
      }
      cardStateStorage.value = {};
      currentIndex.value = 0;
      resetAndRestoreCard();
      if (practiceTimerRef.value) {
        practiceTimerRef.value.startTimer();
      }
    };
    const handleSkip = () => {
      console.log("Skip current card");
      practiceStarted.value = false;
      if (practiceTimerRef.value) {
        practiceTimerRef.value.resetPractice();
      }
      restartSession();
      router.push("/practice/flashcard");
    };
    const continueSession = () => {
      showExitWarning.value = false;
    };
    const confirmExit = () => {
      allowExit.value = true;
      showExitWarning.value = false;
      practiceStarted.value = false;
      if (practiceTimerRef.value) {
        practiceTimerRef.value.resetPractice();
      }
      removeNavigationGuard();
      router.push("/practice/flashcard");
    };
    let unregisterGuard = null;
    const setupNavigationGuard = () => {
      if (unregisterGuard) {
        unregisterGuard();
      }
      unregisterGuard = router.beforeEach((to, from, next) => {
        if (practiceStarted.value && !allowExit.value && from.path.includes("/practice/flashcard")) {
          showExitWarning.value = true;
          return false;
        }
        next();
      });
    };
    const removeNavigationGuard = () => {
      if (unregisterGuard) {
        unregisterGuard();
        unregisterGuard = null;
      }
    };
    const handleImageAnswer = () => {
      checkImageAnswer();
      recordAnswer(imageCorrect.value);
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handleBeforeUnload = (event) => {
      if (practiceStarted.value && !allowExit.value) {
        event.preventDefault();
        event.returnValue = "";
        return "";
      }
    };
    const {
      showHistory,
      practiceHistory,
      saveSessionToHistory,
      getModeColor,
      getModeText,
      formatDate,
      formatDuration,
      deleteSession
    } = useFlashcardHistory();
    const {
      currentIndex,
      isFlipped,
      practiceMode,
      showCompletionModal,
      settings,
      stats,
      flashcards,
      nextCard,
      flipCard,
      completeSession,
      restartSession,
      changePracticeMode,
      goBack,
      goToVocabulary,
      cleanup
    } = useFlashcardGame(baseFlashcards);
    watch(imageModeAvailable, (available) => {
      if (practiceMode.value === "image" && !available) {
        if (practiceStarted.value) {
          console.log("[Flashcard] Image mode became unavailable but practice is active; not switching mode.");
          return;
        }
        console.log("[Flashcard] Image mode unavailable for current filter; switching to flashcard mode.");
        changePracticeMode("flashcard");
      }
    }, { immediate: true });
    watch(pictionaryModeAvailable, (available) => {
      if (practiceMode.value === "pictionary" && !available) {
        if (practiceStarted.value) {
          console.log("[Flashcard] Pictionary mode became unavailable but practice is active; not switching mode.");
          return;
        }
        console.log("[Flashcard] Pictionary mode unavailable for current filter; switching to flashcard mode.");
        changePracticeMode("flashcard");
      }
    }, { immediate: true });
    const {
      initializeStats,
      recordAnswer} = useFlashcardStats(stats);
    const currentFlashcards = computed(() => {
      if (flashcardSettings.value.shuffleCards && shuffledFlashcards.value.length > 0) {
        return shuffledFlashcards.value;
      }
      return baseFlashcards.value;
    });
    const currentShuffledCard = computed(() => {
      if (currentFlashcards.value.length === 0) return null;
      return currentFlashcards.value[currentIndex.value];
    });
    const currentProgressPercentage = computed(() => {
      if (currentFlashcards.value.length === 0) return 0;
      if (typeof currentIndex.value !== "number" || isNaN(currentIndex.value)) return 0;
      if (currentIndex.value >= currentFlashcards.value.length) return 100;
      return (currentIndex.value + 1) / currentFlashcards.value.length * 100;
    });
    const shuffleEnabled = computed(() => flashcardSettings.value.shuffleCards);
    const shuffledFlashcards = ref([]);
    const shuffleFlashcards = (cards = baseFlashcards.value) => {
      const shuffled = [...cards];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      shuffledFlashcards.value = shuffled;
    };
    const {
      quizOptions,
      selectedAnswer,
      quizAnswered,
      generateQuizOptions,
      selectQuizAnswer,
      typingAnswer,
      typingAnswered,
      typingCorrect,
      checkTypingAnswer,
      // Typing-quiz
      typingQuizEnabled,
      typingQuizOptions,
      typingQuizSelected,
      typingQuizAnswered,
      generateTypingQuizOptions,
      selectTypingQuizAnswer,
      listeningAnswer,
      listeningAnswered,
      listeningCorrect,
      checkListeningAnswer,
      playAudio,
      imageAnswer,
      imageAnswered,
      imageCorrect,
      checkImageAnswer,
      resetImageMode,
      // Pictionary mode
      pictionaryAnswer,
      pictionaryAnswered,
      pictionaryCorrect,
      checkPictionaryAnswer,
      // Flip tile mode
      flipTileAnswer,
      flipTileAnswered,
      flipTileCorrect,
      checkFlipTileAnswer,
      imageQuizEnabled,
      imageQuizOptions,
      imageQuizSelected,
      imageQuizAnswered,
      generateImageQuizOptions,
      selectImageQuizAnswer,
      resetAllModes,
      getCanProceed,
      getShortMeaning,
      // Pronunciation mode
      isRecording,
      pronunciationResult,
      pronunciationAnswered,
      pronunciationCorrect,
      isSpeechRecognitionSupported,
      startRecording,
      listeningQuizEnabled,
      listeningQuizOptions,
      listeningQuizSelected,
      listeningQuizAnswered,
      generateListeningQuizOptions,
      selectListeningQuizAnswer
    } = useFlashcardModes(currentShuffledCard, currentFlashcards, allVocabularies);
    const cardStateStorage = ref({});
    const saveCurrentCardState = () => {
      if (!currentShuffledCard.value) return;
      const cardId = currentShuffledCard.value.id;
      cardStateStorage.value[cardId] = {
        // Quiz mode
        quizAnswer: selectedAnswer.value,
        quizAnswered: quizAnswered.value,
        quizOptions: quizOptions.value,
        // Typing mode
        typingAnswer: typingAnswer.value || void 0,
        typingAnswered: typingAnswered.value || void 0,
        typingCorrect: typingCorrect.value || void 0,
        // Typing-quiz
        typingQuizOptions: typingQuizOptions.value || void 0,
        typingQuizSelected: typingQuizSelected.value || void 0,
        typingQuizAnswered: typingQuizAnswered.value || void 0,
        // Listening mode
        listeningAnswer: listeningAnswer.value || void 0,
        listeningAnswered: listeningAnswered.value || void 0,
        listeningCorrect: listeningCorrect.value || void 0,
        // Listening-quiz
        listeningQuizOptions: listeningQuizOptions.value || void 0,
        listeningQuizSelected: listeningQuizSelected.value || void 0,
        listeningQuizAnswered: listeningQuizAnswered.value || void 0,
        // Image mode
        imageAnswer: imageAnswer.value || void 0,
        imageAnswered: imageAnswered.value || void 0,
        imageCorrect: imageCorrect.value || void 0,
        imageQuizOptions: imageQuizOptions.value && imageQuizOptions.value.length ? imageQuizOptions.value : void 0,
        imageQuizSelected: imageQuizSelected.value || void 0,
        imageQuizAnswered: imageQuizAnswered.value || void 0,
        // Pronunciation mode
        pronunciationResult: pronunciationResult.value || void 0,
        pronunciationAnswered: pronunciationAnswered.value || void 0,
        pronunciationCorrect: pronunciationCorrect.value || void 0,
        // Pictionary mode
        pictionaryAnswer: pictionaryAnswer.value || void 0,
        pictionaryAnswered: pictionaryAnswered.value || void 0,
        pictionaryCorrect: pictionaryCorrect.value || void 0,
        // Flip tile mode
        flipTileAnswer: flipTileAnswer.value || void 0,
        flipTileAnswered: flipTileAnswered.value || void 0,
        flipTileCorrect: flipTileCorrect.value || void 0
      };
    };
    const restoreCardState = () => {
      if (!currentShuffledCard.value) return;
      const cardId = currentShuffledCard.value.id;
      const savedState = cardStateStorage.value[cardId];
      if (savedState) {
        if (savedState.quizOptions) {
          quizOptions.value = savedState.quizOptions;
        }
        if (savedState.quizAnswer !== void 0) {
          selectedAnswer.value = savedState.quizAnswer;
        }
        if (savedState.quizAnswered !== void 0) {
          quizAnswered.value = savedState.quizAnswered;
        }
        if (savedState.typingAnswer !== void 0) {
          typingAnswer.value = savedState.typingAnswer;
        }
        if (savedState.typingAnswered !== void 0) {
          typingAnswered.value = savedState.typingAnswered;
        }
        if (savedState.typingCorrect !== void 0) {
          typingCorrect.value = savedState.typingCorrect;
        }
        if (savedState.typingQuizOptions !== void 0) {
          typingQuizOptions.value = savedState.typingQuizOptions;
        }
        if (savedState.typingQuizSelected !== void 0) {
          typingQuizSelected.value = savedState.typingQuizSelected;
        }
        if (savedState.typingQuizAnswered !== void 0) {
          typingQuizAnswered.value = savedState.typingQuizAnswered;
        }
        if (savedState.listeningAnswer !== void 0) {
          listeningAnswer.value = savedState.listeningAnswer;
        }
        if (savedState.listeningAnswered !== void 0) {
          listeningAnswered.value = savedState.listeningAnswered;
        }
        if (savedState.listeningCorrect !== void 0) {
          listeningCorrect.value = savedState.listeningCorrect;
        }
        if (savedState.listeningQuizOptions !== void 0) {
          listeningQuizOptions.value = savedState.listeningQuizOptions;
        }
        if (savedState.listeningQuizSelected !== void 0) {
          listeningQuizSelected.value = savedState.listeningQuizSelected;
        }
        if (savedState.listeningQuizAnswered !== void 0) {
          listeningQuizAnswered.value = savedState.listeningQuizAnswered;
        }
        if (savedState.imageAnswer !== void 0) {
          imageAnswer.value = savedState.imageAnswer;
        }
        if (savedState.imageAnswered !== void 0) {
          imageAnswered.value = savedState.imageAnswered;
        }
        if (savedState.imageCorrect !== void 0) {
          imageCorrect.value = savedState.imageCorrect;
        }
        if (savedState.imageQuizOptions !== void 0) {
          imageQuizOptions.value = savedState.imageQuizOptions;
        }
        if (savedState.imageQuizSelected !== void 0) {
          imageQuizSelected.value = savedState.imageQuizSelected;
        }
        if (savedState.imageQuizAnswered !== void 0) {
          imageQuizAnswered.value = savedState.imageQuizAnswered;
        }
        if (savedState.pronunciationResult !== void 0) {
          pronunciationResult.value = savedState.pronunciationResult;
        }
        if (savedState.pronunciationAnswered !== void 0) {
          pronunciationAnswered.value = savedState.pronunciationAnswered;
        }
        if (savedState.pronunciationCorrect !== void 0) {
          pronunciationCorrect.value = savedState.pronunciationCorrect;
        }
        if (savedState.pictionaryAnswer !== void 0) {
          pictionaryAnswer.value = savedState.pictionaryAnswer;
        }
        if (savedState.pictionaryAnswered !== void 0) {
          pictionaryAnswered.value = savedState.pictionaryAnswered;
        }
        if (savedState.pictionaryCorrect !== void 0) {
          pictionaryCorrect.value = savedState.pictionaryCorrect;
        }
        if (savedState.flipTileAnswer !== void 0) {
          flipTileAnswer.value = savedState.flipTileAnswer;
        }
        if (savedState.flipTileAnswered !== void 0) {
          flipTileAnswered.value = savedState.flipTileAnswered;
        }
        if (savedState.flipTileCorrect !== void 0) {
          flipTileCorrect.value = savedState.flipTileCorrect;
        }
      }
    };
    const handleQuizAnswer = (answer) => {
      const isCorrect = selectQuizAnswer(answer);
      recordAnswer(!!isCorrect);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: answer,
          correctAnswer: getShortMeaning(currentShuffledCard.value.meaning),
          isCorrect: !!isCorrect,
          mode: "quiz"
        });
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handleTypingAnswer = () => {
      checkTypingAnswer();
      recordAnswer(typingCorrect.value);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: typingAnswer.value,
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: !!typingCorrect.value,
          mode: "typing"
        });
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handleTypingQuizAnswer = (answer) => {
      const isCorrect = selectTypingQuizAnswer(answer);
      recordAnswer(!!isCorrect);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: answer,
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: !!isCorrect,
          mode: "typing-quiz"
        });
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handleListeningAnswer = () => {
      checkListeningAnswer();
      recordAnswer(listeningCorrect.value);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: listeningAnswer.value,
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: !!listeningCorrect.value,
          mode: "listening"
        });
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handleListeningQuizAnswer = (answer) => {
      const isCorrect = selectListeningQuizAnswer(answer);
      recordAnswer(!!isCorrect);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: answer,
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: !!isCorrect,
          mode: "listening-quiz"
        });
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const onToggleImageQuiz = (enabled) => {
      imageQuizEnabled.value = enabled;
      resetImageMode();
      if (enabled) {
        generateImageQuizOptions();
      }
    };
    const handleImageQuizAnswer = (answer) => {
      const isCorrect = selectImageQuizAnswer(answer);
      recordAnswer(!!isCorrect);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: answer,
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: !!isCorrect,
          mode: "image-quiz"
        });
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handleFlipTileAnswer = () => {
      checkFlipTileAnswer();
      recordAnswer(flipTileCorrect.value);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: flipTileAnswer.value || "",
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: !!flipTileCorrect.value,
          mode: "flip-tile"
        });
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handlePictionaryAnswer = () => {
      checkPictionaryAnswer();
      recordAnswer(pictionaryCorrect.value);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: pictionaryAnswer.value || "",
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: !!pictionaryCorrect.value,
          mode: "pictionary",
          extra: {
            pictionary: {
              image: currentShuffledCard.value.image,
              slots: latestPictionarySnapshot.value?.slots || []
            }
          }
        });
        latestPictionarySnapshot.value = null;
      }
      if (practiceStarted.value && typeof window !== "undefined" && window.innerWidth < 768) {
        setTimeout(() => {
          enhancedNextCard();
        }, 2100);
      }
    };
    const handleScrambleAnswer = (isCorrect) => {
      recordAnswer(isCorrect);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: "scrambled",
          // User assembled the scrambled word
          correctAnswer: currentShuffledCard.value.word,
          isCorrect,
          mode: "scramble-words"
        });
      }
    };
    const handleBubbleShooterComplete = () => {
      recordAnswer(true);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: "completed",
          correctAnswer: currentShuffledCard.value.word,
          isCorrect: true,
          mode: "bubble-shooter"
        });
      }
      handleSessionComplete();
    };
    const handleWordsCrushCompleted = (isCorrect) => {
      recordAnswer(isCorrect);
      if (currentShuffledCard.value && activeSessionId.value) {
        appendAnswer({
          cardId: currentShuffledCard.value.id,
          word: currentShuffledCard.value.word,
          meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
          userAnswer: isCorrect ? currentShuffledCard.value.word : "incomplete",
          correctAnswer: currentShuffledCard.value.word,
          isCorrect,
          mode: "words-crush"
        });
      }
      pronunciationAnswered.value = true;
      pronunciationCorrect.value = isCorrect;
      const isSmallScreen = window.innerWidth < 768;
      if (isSmallScreen) {
        setTimeout(() => {
          nextCard();
        }, 2e3);
      }
    };
    const resetAndRestoreCard = () => {
      resetAllModes();
      restoreCardState();
      if (practiceMode.value === "quiz" && currentShuffledCard.value) {
        const cardId = currentShuffledCard.value.id;
        const savedState = cardStateStorage.value[cardId];
        if (!savedState || savedState.quizAnswer === void 0) {
          generateQuizOptions();
        }
      }
      if (practiceMode.value === "image" && imageQuizEnabled.value && currentShuffledCard.value) {
        if (!imageQuizOptions.value || imageQuizOptions.value.length === 0) {
          generateImageQuizOptions();
        }
      }
      if (practiceMode.value === "typing" && typingQuizEnabled.value && currentShuffledCard.value) {
        if (!typingQuizOptions.value || typingQuizOptions.value.length === 0) {
          generateTypingQuizOptions();
        }
      }
      if (practiceMode.value === "listening" && listeningQuizEnabled.value && currentShuffledCard.value) {
        if (!listeningQuizOptions.value || listeningQuizOptions.value.length === 0) {
          generateListeningQuizOptions();
        }
      }
    };
    const toggleShuffle = () => {
      flashcardSettings.value.shuffleCards = !flashcardSettings.value.shuffleCards;
      if (flashcardSettings.value.shuffleCards) {
        shuffleFlashcards();
      } else {
        shuffledFlashcards.value = [];
      }
      cardStateStorage.value = {};
      currentIndex.value = 0;
      resetAndRestoreCard();
    };
    const enhancedNextCard = () => {
      saveCurrentCardState();
      if (practiceMode.value === "pronunciation" && pronunciationAnswered.value) {
        recordAnswer(pronunciationCorrect.value);
        if (currentShuffledCard.value && activeSessionId.value) {
          appendAnswer({
            cardId: currentShuffledCard.value.id,
            word: currentShuffledCard.value.word,
            meaningShort: getShortMeaning(currentShuffledCard.value.meaning),
            userAnswer: pronunciationResult.value,
            correctAnswer: currentShuffledCard.value.word,
            isCorrect: !!pronunciationCorrect.value,
            mode: "pronunciation"
          });
        }
      }
      if (currentIndex.value < currentFlashcards.value.length - 1) {
        currentIndex.value++;
        resetAndRestoreCard();
        if (practiceStarted.value && practiceTimerRef.value) {
          practiceTimerRef.value.nextCard();
        }
      } else {
        handleSessionComplete();
      }
    };
    const enhancedPreviousCard = () => {
      saveCurrentCardState();
      if (currentIndex.value > 0) {
        currentIndex.value--;
        resetAndRestoreCard();
        if (practiceStarted.value && practiceTimerRef.value) {
          practiceTimerRef.value.stopTimer();
        }
      }
    };
    const enhancedMarkEasy = () => {
      recordAnswer(true);
      enhancedNextCard();
    };
    const enhancedMarkDifficult = () => {
      recordAnswer(false);
      enhancedNextCard();
    };
    const handleSessionComplete = () => {
      completeSession();
      const totalCards = currentFlashcards.value.length;
      const id = saveSessionToHistory(stats.value, totalCards, activeSessionId.value || void 0);
      if (!activeSessionId.value) {
        activeSessionId.value = id;
      }
    };
    const handleRestartSession = () => {
      restartSession();
      practiceStarted.value = false;
      cardStateStorage.value = {};
      modalStore.setCompletionModal(false);
      if (flashcardSettings.value.shuffleCards && baseFlashcards.value.length > 0) {
        shuffleFlashcards();
      }
      resetAndRestoreCard();
      if (practiceTimerRef.value) {
        practiceTimerRef.value.resetPractice();
      }
    };
    const handleCompletionGoBack = () => {
      modalStore.setCompletionModal(false);
      goBack();
    };
    const handleSnakeGameComplete = () => {
      const expectedCorrect = currentFlashcards.value.length;
      const actualCorrect = stats.value.correct;
      if (actualCorrect < expectedCorrect) {
        recordAnswer(true);
      }
      handleSessionComplete();
    };
    const handleSnakeCorrectFoodEaten = (details) => {
      console.log("[DEBUG] Snake correct food eaten, recording answer true");
      console.log("[DEBUG] Stats before:", { correct: stats.value.correct, incorrect: stats.value.incorrect, total: stats.value.total });
      recordAnswer(true);
      console.log("[DEBUG] Stats after:", { correct: stats.value.correct, incorrect: stats.value.incorrect, total: stats.value.total });
      if (details && activeSessionId.value) {
        console.log("[DEBUG] FlashcardView - Recording snake correct food:", details);
        console.log("[DEBUG] FlashcardView - Snake body to save:", details.snakeBody);
        console.log("[DEBUG] FlashcardView - Snake direction to save:", details.direction);
        appendAnswer({
          cardId: Date.now(),
          // Unique numeric ID for snake game food eaten
          word: details.word,
          meaningShort: details.meaningShort,
          userAnswer: details.word,
          // Correct food eaten
          correctAnswer: details.word,
          isCorrect: true,
          mode: "snake-game",
          extra: {
            snakeGame: {
              position: details.position,
              wasCorrect: true,
              foodType: "primary",
              // Correct food is always primary target
              snakeLength: details.snakeLength,
              gameScore: details.gameScore,
              wordsCompleted: details.wordsCompleted,
              wrongEatenCount: details.wrongEatenCount,
              snakeBody: details.snakeBody,
              direction: details.direction,
              timelineFrames: details.timelineFrames
            }
          }
        });
      }
    };
    const handleSnakeWrongFoodEaten = (details) => {
      recordAnswer(false);
      if (details && activeSessionId.value) {
        appendAnswer({
          cardId: Date.now(),
          // Unique numeric ID for snake game food eaten
          word: details.word,
          meaningShort: details.meaningShort,
          userAnswer: details.word,
          // Wrong food eaten
          correctAnswer: "",
          // No specific correct answer for wrong food
          isCorrect: false,
          mode: "snake-game",
          extra: {
            snakeGame: {
              position: details.position,
              wasCorrect: false,
              foodType: "secondary",
              // Wrong food is secondary/decoy
              snakeLength: details.snakeLength,
              gameScore: details.gameScore,
              wordsCompleted: details.wordsCompleted,
              wrongEatenCount: details.wrongEatenCount,
              snakeBody: details.snakeBody,
              direction: details.direction,
              timelineFrames: details.timelineFrames
            }
          }
        });
      }
    };
    let autoFlipTimer = null;
    watch([currentIndex, isFlipped], () => {
      if (autoFlipTimer) {
        clearTimeout(autoFlipTimer);
      }
      if (flashcardSettings.value.autoFlip && !isFlipped.value) {
        autoFlipTimer = setTimeout(() => {
          isFlipped.value = true;
        }, 3e3);
      }
    });
    watch(practiceMode, () => {
      resetAndRestoreCard();
      if (flashcardSettings.value.shuffleCards && shuffledFlashcards.value.length === 0) {
        shuffleFlashcards();
      }
    });
    watch(showCompletionModal, (newValue) => {
      if (newValue) {
        if (practiceTimerRef.value) {
          practiceTimerRef.value.stopTimer();
        }
        modalStore.setCompletionModal(true);
      } else {
        modalStore.setCompletionModal(false);
      }
    });
    watch(showHistory, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        document.body.classList.remove("modal-open");
      }
    });
    watch(showSessionDetail, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        document.body.classList.remove("modal-open");
      }
    });
    watch(showSettingsDialog, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        document.body.classList.remove("modal-open");
      }
    });
    watch(dateFilterEnabled, () => {
      saveDateFilterState();
    });
    watch(selectedDate, () => {
      saveDateFilterState();
    });
    watch(baseFlashcards, (newCards) => {
      if (flashcardSettings.value.shuffleCards && newCards.length > 0) {
        shuffleFlashcards(newCards);
        currentIndex.value = 0;
        resetAndRestoreCard();
      } else if (flashcardSettings.value.shuffleCards && newCards.length === 0) {
        shuffledFlashcards.value = [];
        currentIndex.value = 0;
      }
    }, { immediate: false });
    const handleFlipTileHintsToggle = (enabled) => {
      flashcardSettings.value.useFlipTileHints = enabled;
    };
    onMounted(() => {
      console.log("FlashcardView mounted");
      initializeStats(currentFlashcards.value.length);
      if (practiceMode.value === "quiz") {
        generateQuizOptions();
      }
      if (flashcardSettings.value.shuffleCards) {
        shuffleFlashcards();
      }
      setupNavigationGuard();
      window.addEventListener("beforeunload", handleBeforeUnload);
    });
    onUnmounted(() => {
      document.body.classList.remove("modal-open");
      cleanup();
      removeNavigationGuard();
      window.removeEventListener("beforeunload", handleBeforeUnload);
    });
    return (_ctx, _cache) => {
      const _component_FlashcardHeader = resolveComponent("FlashcardHeader");
      const _component_FlashcardProgress = resolveComponent("FlashcardProgress");
      const _component_LazyLoadComponent = resolveComponent("LazyLoadComponent");
      const _component_VoiceSelector = resolveComponent("VoiceSelector");
      const _component_FlashcardDateFilter = resolveComponent("FlashcardDateFilter");
      const _component_PracticeTimer = resolveComponent("PracticeTimer");
      const _component_FlashcardCard = resolveComponent("FlashcardCard");
      const _component_PictionaryMode = resolveComponent("PictionaryMode");
      const _component_FlashcardQuiz = resolveComponent("FlashcardQuiz");
      const _component_FlashcardTyping = resolveComponent("FlashcardTyping");
      const _component_FlashcardImage = resolveComponent("FlashcardImage");
      const _component_ListeningMode = resolveComponent("ListeningMode");
      const _component_PronunciationMode = resolveComponent("PronunciationMode");
      const _component_BubbleShooterMode = resolveComponent("BubbleShooterMode");
      const _component_SnakeGameMode = resolveComponent("SnakeGameMode");
      const _component_FlipTileMode = resolveComponent("FlipTileMode");
      const _component_FlashcardControls = resolveComponent("FlashcardControls");
      const _component_PracticeStats = resolveComponent("PracticeStats");
      const _component_FlashcardEmptyState = resolveComponent("FlashcardEmptyState");
      const _component_SettingsModal = resolveComponent("SettingsModal");
      const _component_HistoryModal = resolveComponent("HistoryModal");
      const _component_SessionDetailModal = resolveComponent("SessionDetailModal");
      const _component_CompletionModal = resolveComponent("CompletionModal");
      const _component_ExitWarningModal = resolveComponent("ExitWarningModal");
      return openBlock(), createElementBlock("div", _hoisted_1$1j, [
        _cache[24] || (_cache[24] = createStaticVNode('<div class="absolute inset-0 overflow-hidden pointer-events-none" data-v-b1cf9130><div class="floating-shapes" data-v-b1cf9130><div class="absolute top-24 left-8 w-64 h-64 bg-blue-300 dark:bg-blue-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob" data-v-b1cf9130></div><div class="absolute top-40 right-10 w-72 h-72 bg-purple-300 dark:bg-purple-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-2000" data-v-b1cf9130></div><div class="absolute -bottom-10 left-24 w-80 h-80 bg-pink-300 dark:bg-pink-500 rounded-full mix-blend-multiply dark:mix-blend-normal filter blur-xl opacity-30 animate-blob animation-delay-4000" data-v-b1cf9130></div></div></div>', 1)),
        createVNode(_component_FlashcardHeader, {
          "current-index": unref(currentIndex),
          "total-cards": currentFlashcards.value.length,
          "practice-mode": unref(practiceMode),
          "shuffle-enabled": shuffleEnabled.value,
          "practice-started": practiceStarted.value,
          "image-quiz-enabled": unref(imageQuizEnabled),
          "listening-quiz-enabled": unref(listeningQuizEnabled),
          "typing-quiz-enabled": unref(typingQuizEnabled),
          "image-mode-available": imageModeAvailable.value,
          "pictionary-mode-available": pictionaryModeAvailable.value,
          "flip-tile-mode-available": flipTileModeAvailable.value,
          "bubble-shooter-mode-available": bubbleShooterModeAvailable.value,
          "bubble-shooter-vietnamese-mode": bubbleShooterVietnameseMode.value,
          "snake-double-bait-enabled": snakeDoubleBaitMode.value,
          "pictionary-definition-mode": pictionaryDefinitionMode.value,
          "scramble-words-enabled": scrambleWordsEnabled.value,
          "words-crush-enabled": wordsCrushEnabled.value,
          "use-flip-tile-hints": unref(flashcardSettings).useFlipTileHints,
          onGoBack: unref(goBack),
          onShowHistory: _cache[0] || (_cache[0] = ($event) => showHistory.value = true),
          onChangePracticeMode: _cache[1] || (_cache[1] = ($event) => unref(changePracticeMode)($event)),
          onShowSettings: _cache[2] || (_cache[2] = ($event) => showSettingsDialog.value = true),
          onToggleShuffle: toggleShuffle,
          "onUpdate:imageQuizEnabled": _cache[3] || (_cache[3] = ($event) => imageQuizEnabled.value = $event),
          "onUpdate:listeningQuizEnabled": _cache[4] || (_cache[4] = ($event) => listeningQuizEnabled.value = $event),
          "onUpdate:typingQuizEnabled": _cache[5] || (_cache[5] = ($event) => typingQuizEnabled.value = $event),
          "onUpdate:bubbleShooterVietnameseMode": _cache[6] || (_cache[6] = ($event) => bubbleShooterVietnameseMode.value = $event),
          "onUpdate:snakeDoubleBaitEnabled": _cache[7] || (_cache[7] = ($event) => snakeDoubleBaitMode.value = $event),
          "onUpdate:pictionaryDefinitionMode": _cache[8] || (_cache[8] = ($event) => pictionaryDefinitionMode.value = $event),
          "onUpdate:scrambleWordsEnabled": _cache[9] || (_cache[9] = ($event) => scrambleWordsEnabled.value = $event),
          "onUpdate:wordsCrushEnabled": _cache[10] || (_cache[10] = ($event) => wordsCrushEnabled.value = $event),
          "onUpdate:useFlipTileHints": handleFlipTileHintsToggle
        }, null, 8, ["current-index", "total-cards", "practice-mode", "shuffle-enabled", "practice-started", "image-quiz-enabled", "listening-quiz-enabled", "typing-quiz-enabled", "image-mode-available", "pictionary-mode-available", "flip-tile-mode-available", "bubble-shooter-mode-available", "bubble-shooter-vietnamese-mode", "snake-double-bait-enabled", "pictionary-definition-mode", "scramble-words-enabled", "words-crush-enabled", "use-flip-tile-hints", "onGoBack"]),
        createVNode(_component_LazyLoadComponent, {
          "animation-type": "slide-left",
          threshold: 0.1,
          "root-margin": "-50px"
        }, {
          default: withCtx(() => [
            createVNode(_component_FlashcardProgress, { "progress-percentage": currentProgressPercentage.value }, null, 8, ["progress-percentage"])
          ]),
          _: 1
        }),
        createVNode(_component_LazyLoadComponent, {
          "animation-type": "scale",
          threshold: 0.1,
          "root-margin": "-50px"
        }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_2$1g, [
              createBaseVNode("div", _hoisted_3$1d, [
                createVNode(_component_VoiceSelector, { "show-voice-info": false })
              ])
            ])
          ]),
          _: 1
        }),
        createVNode(_component_LazyLoadComponent, {
          "animation-type": "slide-right",
          threshold: 0.1,
          "root-margin": "-50px"
        }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_4$19, [
              createBaseVNode("div", _hoisted_5$16, [
                createVNode(_component_FlashcardDateFilter, {
                  vocabularies: unref(allVocabularies),
                  selectedDate: selectedDate.value,
                  "practice-started": practiceStarted.value,
                  "onUpdate:selectedDate": _cache[11] || (_cache[11] = ($event) => selectedDate.value = $event)
                }, null, 8, ["vocabularies", "selectedDate", "practice-started"])
              ])
            ])
          ]),
          _: 1
        }),
        createBaseVNode("div", _hoisted_6$13, [
          currentFlashcards.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_7$$, [
            createBaseVNode("div", _hoisted_8$Z, [
              createBaseVNode("div", _hoisted_9$Y, [
                createVNode(_component_LazyLoadComponent, {
                  "animation-type": "fade-up",
                  threshold: 0.1,
                  "root-margin": "-50px"
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_10$X, [
                      unref(practiceMode) === "bubble-shooter" || unref(practiceMode) === "snake-game" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        !practiceStarted.value ? (openBlock(), createElementBlock("button", {
                          key: 0,
                          onClick: handlePracticeStart,
                          class: "px-8 py-4 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 dark:from-purple-700 dark:to-pink-700 dark:hover:from-purple-800 dark:hover:to-pink-800 text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200"
                        }, toDisplayString$1(unref(t)("practice.startGame", "Start Game")), 1)) : createCommentVNode("", true)
                      ], 64)) : (openBlock(), createBlock(_component_PracticeTimer, {
                        key: 1,
                        ref_key: "practiceTimerRef",
                        ref: practiceTimerRef,
                        "max-time": 30,
                        onStart: handlePracticeStart,
                        onTimeout: handleTimeout,
                        onRestart: handleTimerRestart,
                        onSkip: handleSkip
                      }, null, 512))
                    ])
                  ]),
                  _: 1
                }),
                practiceStarted.value ? (openBlock(), createElementBlock("div", _hoisted_11$X, [
                  createVNode(_component_LazyLoadComponent, {
                    "animation-type": "scale",
                    threshold: 0.1,
                    "root-margin": "-50px"
                  }, {
                    default: withCtx(() => [
                      unref(practiceMode) === "flashcard" ? (openBlock(), createBlock(_component_FlashcardCard, {
                        key: 0,
                        "current-card": currentShuffledCard.value,
                        "is-flipped": unref(isFlipped),
                        "scramble-words-enabled": scrambleWordsEnabled.value,
                        "current-index": unref(currentIndex),
                        "total-cards": currentFlashcards.value.length,
                        onFlipCard: unref(flipCard),
                        onNextCard: enhancedNextCard,
                        onShowResults: unref(completeSession),
                        onScrambleAnswer: handleScrambleAnswer
                      }, null, 8, ["current-card", "is-flipped", "scramble-words-enabled", "current-index", "total-cards", "onFlipCard", "onShowResults"])) : unref(practiceMode) === "pictionary" ? (openBlock(), createBlock(_component_PictionaryMode, {
                        key: 1,
                        card: currentShuffledCard.value,
                        "pictionary-answer": unref(pictionaryAnswer),
                        "pictionary-answered": unref(pictionaryAnswered),
                        "pictionary-correct": unref(pictionaryCorrect),
                        "definition-mode": pictionaryDefinitionMode.value,
                        "get-topic-name": unref(getTopicName),
                        "onUpdate:pictionaryAnswer": _cache[12] || (_cache[12] = ($event) => pictionaryAnswer.value = $event),
                        onCheckAnswer: handlePictionaryAnswer,
                        onPictionarySnapshot
                      }, null, 8, ["card", "pictionary-answer", "pictionary-answered", "pictionary-correct", "definition-mode", "get-topic-name"])) : unref(practiceMode) === "quiz" ? (openBlock(), createBlock(_component_FlashcardQuiz, {
                        key: 2,
                        "current-card": currentShuffledCard.value,
                        "quiz-options": unref(quizOptions),
                        "selected-answer": unref(selectedAnswer),
                        "quiz-answered": unref(quizAnswered),
                        onSelectAnswer: handleQuizAnswer
                      }, null, 8, ["current-card", "quiz-options", "selected-answer", "quiz-answered"])) : unref(practiceMode) === "typing" ? (openBlock(), createBlock(_component_FlashcardTyping, {
                        key: 3,
                        "current-card": currentShuffledCard.value,
                        "typing-answer": unref(typingAnswer),
                        "typing-answered": unref(typingAnswered),
                        "typing-correct": unref(typingCorrect),
                        "typing-quiz-enabled": unref(typingQuizEnabled),
                        "typing-quiz-options": unref(typingQuizOptions),
                        "typing-quiz-selected": unref(typingQuizSelected),
                        "typing-quiz-answered": unref(typingQuizAnswered),
                        "onUpdate:typingAnswer": _cache[13] || (_cache[13] = ($event) => typingAnswer.value = $event),
                        onCheckAnswer: handleTypingAnswer,
                        onSelectTypingQuizAnswer: _cache[14] || (_cache[14] = ($event) => handleTypingQuizAnswer($event))
                      }, null, 8, ["current-card", "typing-answer", "typing-answered", "typing-correct", "typing-quiz-enabled", "typing-quiz-options", "typing-quiz-selected", "typing-quiz-answered"])) : unref(practiceMode) === "image" ? (openBlock(), createBlock(_component_FlashcardImage, {
                        key: 4,
                        "current-card": currentShuffledCard.value,
                        "image-answer": unref(imageAnswer),
                        "image-answered": unref(imageAnswered),
                        "image-correct": unref(imageCorrect),
                        "image-quiz-enabled": unref(imageQuizEnabled),
                        "image-quiz-options": unref(imageQuizOptions),
                        "image-quiz-selected": unref(imageQuizSelected),
                        "image-quiz-answered": unref(imageQuizAnswered),
                        "onUpdate:imageAnswer": _cache[15] || (_cache[15] = ($event) => imageAnswer.value = $event),
                        onCheckAnswer: handleImageAnswer,
                        "onUpdate:imageQuizEnabled": _cache[16] || (_cache[16] = ($event) => onToggleImageQuiz($event)),
                        onSelectImageQuizAnswer: _cache[17] || (_cache[17] = ($event) => handleImageQuizAnswer($event))
                      }, null, 8, ["current-card", "image-answer", "image-answered", "image-correct", "image-quiz-enabled", "image-quiz-options", "image-quiz-selected", "image-quiz-answered"])) : unref(practiceMode) === "listening" ? (openBlock(), createBlock(_component_ListeningMode, {
                        key: 5,
                        card: currentShuffledCard.value,
                        "listening-answer": unref(listeningAnswer),
                        "onUpdate:listeningAnswer": _cache[18] || (_cache[18] = ($event) => listeningAnswer.value = $event),
                        "listening-answered": unref(listeningAnswered),
                        "listening-correct": unref(listeningCorrect),
                        "listening-quiz-enabled": unref(listeningQuizEnabled),
                        "listening-quiz-options": unref(listeningQuizOptions),
                        "listening-quiz-selected": unref(listeningQuizSelected),
                        "listening-quiz-answered": unref(listeningQuizAnswered),
                        "get-topic-name": unref(getTopicName),
                        onCheckAnswer: handleListeningAnswer,
                        onPlayAudio: unref(playAudio),
                        onSelectListeningQuizAnswer: _cache[19] || (_cache[19] = ($event) => handleListeningQuizAnswer($event))
                      }, null, 8, ["card", "listening-answer", "listening-answered", "listening-correct", "listening-quiz-enabled", "listening-quiz-options", "listening-quiz-selected", "listening-quiz-answered", "get-topic-name", "onPlayAudio"])) : unref(practiceMode) === "pronunciation" ? (openBlock(), createBlock(_component_PronunciationMode, {
                        key: 6,
                        card: currentShuffledCard.value,
                        "is-recording": unref(isRecording),
                        "pronunciation-result": unref(pronunciationResult),
                        "pronunciation-answered": unref(pronunciationAnswered),
                        "pronunciation-correct": unref(pronunciationCorrect),
                        "is-speech-recognition-supported": unref(isSpeechRecognitionSupported),
                        "get-topic-name": unref(getTopicName),
                        "words-crush-enabled": wordsCrushEnabled.value,
                        onStartRecording: unref(startRecording),
                        onGameCompleted: handleWordsCrushCompleted,
                        onPlayAudio: unref(playAudio)
                      }, null, 8, ["card", "is-recording", "pronunciation-result", "pronunciation-answered", "pronunciation-correct", "is-speech-recognition-supported", "get-topic-name", "words-crush-enabled", "onStartRecording", "onPlayAudio"])) : unref(practiceMode) === "bubble-shooter" ? (openBlock(), createBlock(_component_BubbleShooterMode, {
                        key: 7,
                        words: currentFlashcards.value,
                        "vietnamese-mode": bubbleShooterVietnameseMode.value,
                        onGameComplete: handleBubbleShooterComplete
                      }, null, 8, ["words", "vietnamese-mode"])) : unref(practiceMode) === "snake-game" ? (openBlock(), createBlock(_component_SnakeGameMode, {
                        key: 8,
                        words: currentFlashcards.value,
                        "vietnamese-mode": bubbleShooterVietnameseMode.value,
                        "double-bait-mode": snakeDoubleBaitMode.value,
                        "record-timeline": true,
                        onGameComplete: handleSnakeGameComplete,
                        onCorrectFoodEaten: handleSnakeCorrectFoodEaten,
                        onWrongFoodEaten: handleSnakeWrongFoodEaten
                      }, null, 8, ["words", "vietnamese-mode", "double-bait-mode"])) : unref(practiceMode) === "flip-tile" ? (openBlock(), createBlock(_component_FlipTileMode, {
                        key: 9,
                        card: currentShuffledCard.value,
                        "flip-tile-answer": unref(flipTileAnswer),
                        "flip-tile-answered": unref(flipTileAnswered),
                        "flip-tile-correct": unref(flipTileCorrect),
                        "get-topic-name": unref(getTopicName),
                        "use-hints": unref(flashcardSettings).useFlipTileHints,
                        "onUpdate:flipTileAnswer": _cache[20] || (_cache[20] = ($event) => flipTileAnswer.value = $event),
                        onCheckAnswer: handleFlipTileAnswer
                      }, null, 8, ["card", "flip-tile-answer", "flip-tile-answered", "flip-tile-correct", "get-topic-name", "use-hints"])) : createCommentVNode("", true)
                    ]),
                    _: 1
                  }),
                  createVNode(_component_LazyLoadComponent, {
                    "animation-type": "slide-left",
                    threshold: 0.1,
                    "root-margin": "-50px"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_FlashcardControls, {
                        "practice-mode": unref(practiceMode),
                        "current-index": unref(currentIndex),
                        "total-cards": currentFlashcards.value.length,
                        "can-proceed": unref(getCanProceed)()[unref(practiceMode)],
                        "practice-started": practiceStarted.value,
                        "scramble-words-enabled": scrambleWordsEnabled.value,
                        "typing-answer": unref(typingAnswer),
                        "typing-answered": unref(typingAnswered),
                        "listening-answer": unref(listeningAnswer),
                        "listening-answered": unref(listeningAnswered),
                        "image-answer": unref(imageAnswer),
                        "image-answered": unref(imageAnswered),
                        onMarkDifficult: enhancedMarkDifficult,
                        onMarkEasy: enhancedMarkEasy,
                        onPreviousCard: enhancedPreviousCard,
                        onNextCard: enhancedNextCard,
                        onCheckTypingAnswer: handleTypingAnswer,
                        onCheckListeningAnswer: handleListeningAnswer,
                        onCheckImageAnswer: handleImageAnswer,
                        onExitPractice: handleExitPractice
                      }, null, 8, ["practice-mode", "current-index", "total-cards", "can-proceed", "practice-started", "scramble-words-enabled", "typing-answer", "typing-answered", "listening-answer", "listening-answered", "image-answer", "image-answered"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_LazyLoadComponent, {
                    "animation-type": "scale",
                    threshold: 0.1,
                    "root-margin": "-50px"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_PracticeStats, {
                        stats: unref(stats),
                        mode: unref(practiceMode)
                      }, null, 8, ["stats", "mode"])
                    ]),
                    _: 1
                  })
                ])) : createCommentVNode("", true)
              ])
            ])
          ])) : createCommentVNode("", true),
          createVNode(_component_LazyLoadComponent, {
            "animation-type": "fade-up",
            threshold: 0.1,
            "root-margin": "-50px"
          }, {
            default: withCtx(() => [
              currentFlashcards.value.length === 0 ? (openBlock(), createBlock(_component_FlashcardEmptyState, {
                key: 0,
                onGoToVocabulary: unref(goToVocabulary)
              }, null, 8, ["onGoToVocabulary"])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ]),
        createVNode(_component_SettingsModal, {
          show: unref(showSettingsDialog),
          settings: unref(settings),
          "local-settings": unref(localSettings),
          "date-filter-enabled": dateFilterEnabled.value,
          "selected-date": selectedDate.value,
          "onUpdate:localSettings": _cache[21] || (_cache[21] = ($event) => localSettings.value = $event),
          onCancel: unref(cancelSettings),
          onApply: unref(applyGameSettings)
        }, null, 8, ["show", "settings", "local-settings", "date-filter-enabled", "selected-date", "onCancel", "onApply"]),
        createVNode(_component_HistoryModal, {
          show: unref(showHistory),
          history: unref(practiceHistory),
          "get-mode-color": unref(getModeColor),
          "get-mode-text": unref(getModeText),
          "format-date": unref(formatDate),
          "format-duration": unref(formatDuration),
          onClose: _cache[22] || (_cache[22] = ($event) => showHistory.value = false),
          onOpenDetails: openHistoryDetails,
          onDeleteSession: handleDeleteSession
        }, null, 8, ["show", "history", "get-mode-color", "get-mode-text", "format-date", "format-duration"]),
        createVNode(_component_SessionDetailModal, {
          show: showSessionDetail.value,
          details: selectedSessionDetails.value,
          onClose: _cache[23] || (_cache[23] = ($event) => showSessionDetail.value = false)
        }, null, 8, ["show", "details"]),
        createVNode(_component_CompletionModal, {
          show: unref(showCompletionModal),
          stats: unref(stats),
          "card-count": unref(flashcards).length,
          onRestart: handleRestartSession,
          onGoBack: handleCompletionGoBack
        }, null, 8, ["show", "stats", "card-count"]),
        createVNode(_component_ExitWarningModal, {
          show: showExitWarning.value,
          onContinue: continueSession,
          onConfirm: confirmExit
        }, null, 8, ["show"])
      ]);
    };
  }
});

const FlashcardView = /* @__PURE__ */ _export_sfc(_sfc_main$1k, [["__scopeId", "data-v-b1cf9130"]]);

const _hoisted_1$1i = { class: "min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 dark:from-gray-900 dark:to-[#0a0a0a]" };
const _hoisted_2$1f = { class: "max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8" };
const _sfc_main$1j = /* @__PURE__ */ defineComponent({
  __name: "QuizView",
  setup(__props) {
    const QuizHeader$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => QuizHeader),true              ?void 0:void 0))
    );
    const QuizProgress$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => QuizProgress),true              ?void 0:void 0))
    );
    const QuizSetup$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => QuizSetup),true              ?void 0:void 0))
    );
    const QuizQuestion$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => QuizQuestion),true              ?void 0:void 0))
    );
    const QuizResults$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => QuizResults),true              ?void 0:void 0))
    );
    const router = useRouter();
    const vocabularyStore = useVocabularyStore();
    const quizStarted = ref(false);
    const quizCompleted = ref(false);
    const currentQuestionIndex = ref(0);
    const selectedAnswer = ref(null);
    const userAnswers = ref([]);
    const score = ref(0);
    const timeRemaining = ref(0);
    let timer = null;
    const quizSettings = ref({
      type: "vocabulary",
      level: "",
      questionCount: "10",
      timeLimit: "10"
    });
    const questions = ref([]);
    const generateQuestionsFromVocabulary = (vocabularies) => {
      console.log("Generating questions from", vocabularies.length, "vocabularies");
      if (vocabularies.length === 0) return [];
      const vocabQuestions = vocabularies.map((vocab, index) => {
        const otherVocabs = vocabularies.filter((v) => v.id !== vocab.id);
        let incorrectOptions = [];
        if (otherVocabs.length > 0) {
          incorrectOptions = otherVocabs.slice(0, 3).map((v) => v.meaning.split(" - ")[0]);
        }
        const genericOptions = ["Khng c ngha", "T khc", "Khi nim khc", "Ngha khc", " ngha khc"];
        while (incorrectOptions.length < 3) {
          const randomGeneric = genericOptions[Math.floor(Math.random() * genericOptions.length)];
          if (!incorrectOptions.includes(randomGeneric)) {
            incorrectOptions.push(randomGeneric);
          }
        }
        const correctMeaning = vocab.meaning.split(" - ")[0];
        const allOptions = [correctMeaning, ...incorrectOptions.slice(0, 3)];
        const shuffledOptions = allOptions.sort(() => Math.random() - 0.5);
        const correctAnswer = shuffledOptions.indexOf(correctMeaning);
        return {
          id: vocab.id,
          type: "vocabulary",
          level: vocab.level,
          question: `What does "${vocab.word}" mean?`,
          options: shuffledOptions,
          correctAnswer,
          explanation: `"${vocab.word}" c ngha l: ${vocab.meaning}`
        };
      });
      return vocabQuestions.sort(() => Math.random() - 0.5);
    };
    const updateQuestions = () => {
      const vocabularies = vocabularyStore.allVocabularies.value;
      console.log("Updating questions from", vocabularies.length, "total vocabularies");
      const filteredVocabs = vocabularies.filter((vocab) => {
        if (quizSettings.value.level && vocab.level !== quizSettings.value.level) {
          return false;
        }
        return true;
      });
      console.log("Filtered to", filteredVocabs.length, "vocabularies for quiz");
      const generatedQuestions = generateQuestionsFromVocabulary(filteredVocabs);
      const questionCount = parseInt(quizSettings.value.questionCount);
      questions.value = generatedQuestions.slice(0, questionCount);
      console.log("Generated", questions.value.length, "questions");
    };
    const availableLevels = computed(() => {
      return vocabularyStore.getLevels.value;
    });
    const currentQuestion = computed(() => questions.value[currentQuestionIndex.value] || {});
    const progressPercentage = computed(() => (currentQuestionIndex.value + 1) / questions.value.length * 100);
    const correctAnswers = computed(() => {
      return userAnswers.value.filter((answer, index) => answer === questions.value[index].correctAnswer).length;
    });
    const accuracy = computed(() => correctAnswers.value / questions.value.length * 100);
    const startQuiz = (settings) => {
      if (settings) {
        quizSettings.value = { ...settings };
      }
      if (questions.value.length === 0) {
        updateQuestions();
      }
      if (questions.value.length === 0) {
        alert("Khng c t vng no  luyn tp. Vui lng thm t vng trc!");
        return;
      }
      quizStarted.value = true;
      if (quizSettings.value.timeLimit !== "0") {
        timeRemaining.value = parseInt(quizSettings.value.timeLimit) * 60;
        startTimer();
      }
      userAnswers.value = new Array(questions.value.length).fill(-1);
    };
    const startTimer = () => {
      timer = setInterval(() => {
        timeRemaining.value--;
        if (timeRemaining.value <= 0) {
          completeQuiz();
        }
      }, 1e3);
    };
    const selectAnswer = (index) => {
      selectedAnswer.value = index;
    };
    const nextQuestion = () => {
      if (selectedAnswer.value !== null) {
        userAnswers.value[currentQuestionIndex.value] = selectedAnswer.value;
        if (currentQuestionIndex.value === questions.value.length - 1) {
          completeQuiz();
        } else {
          currentQuestionIndex.value++;
          selectedAnswer.value = userAnswers.value[currentQuestionIndex.value] !== -1 ? userAnswers.value[currentQuestionIndex.value] : null;
        }
      }
    };
    const previousQuestion = () => {
      if (currentQuestionIndex.value > 0) {
        userAnswers.value[currentQuestionIndex.value] = selectedAnswer.value || -1;
        currentQuestionIndex.value--;
        selectedAnswer.value = userAnswers.value[currentQuestionIndex.value] !== -1 ? userAnswers.value[currentQuestionIndex.value] : null;
      }
    };
    const completeQuiz = () => {
      if (selectedAnswer.value !== null) {
        userAnswers.value[currentQuestionIndex.value] = selectedAnswer.value;
      }
      score.value = correctAnswers.value * 10;
      quizCompleted.value = true;
      if (timer) {
        clearInterval(timer);
      }
    };
    const restartQuiz = () => {
      quizStarted.value = false;
      quizCompleted.value = false;
      currentQuestionIndex.value = 0;
      selectedAnswer.value = null;
      userAnswers.value = [];
      score.value = 0;
      timeRemaining.value = 0;
      updateQuestions();
      if (timer) {
        clearInterval(timer);
      }
    };
    const goBack = () => {
      router.back();
    };
    onMounted(async () => {
      const isReady = vocabularyStore.initializeStore();
      if (!isReady.value) {
        await new Promise(
          (resolve) => watch(isReady, (ready) => {
            if (ready) resolve(true);
          }, { immediate: true })
        );
      }
      updateQuestions();
      console.log("Quiz view mounted", vocabularyStore.allVocabularies.value.length, "vocabularies loaded");
    });
    watch(
      () => vocabularyStore.isStoreReady.value,
      (isReady) => {
        if (isReady) {
          updateQuestions();
        }
      },
      { immediate: true }
    );
    watch(
      () => vocabularyStore.allVocabularies.value,
      () => {
        if (vocabularyStore.isStoreReady.value) {
          updateQuestions();
        }
      },
      { deep: true }
    );
    watch(
      () => quizSettings.value,
      () => {
        updateQuestions();
      },
      { deep: true }
    );
    onUnmounted(() => {
      if (timer) {
        clearInterval(timer);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1i, [
        createVNode(unref(QuizHeader$1), {
          "time-remaining": timeRemaining.value,
          score: score.value,
          onGoBack: goBack
        }, null, 8, ["time-remaining", "score"]),
        createVNode(unref(QuizProgress$1), {
          "current-question-index": currentQuestionIndex.value,
          "total-questions": questions.value.length,
          "progress-percentage": progressPercentage.value
        }, null, 8, ["current-question-index", "total-questions", "progress-percentage"]),
        createBaseVNode("div", _hoisted_2$1f, [
          !quizStarted.value ? (openBlock(), createBlock(unref(QuizSetup$1), {
            key: 0,
            settings: quizSettings.value,
            "available-levels": availableLevels.value,
            onStartQuiz: startQuiz
          }, null, 8, ["settings", "available-levels"])) : !quizCompleted.value ? (openBlock(), createBlock(unref(QuizQuestion$1), {
            key: 1,
            question: currentQuestion.value,
            "selected-answer": selectedAnswer.value,
            "is-first-question": currentQuestionIndex.value === 0,
            "is-last-question": currentQuestionIndex.value === questions.value.length - 1,
            onSelectAnswer: selectAnswer,
            onPreviousQuestion: previousQuestion,
            onNextQuestion: nextQuestion
          }, null, 8, ["question", "selected-answer", "is-first-question", "is-last-question"])) : (openBlock(), createBlock(unref(QuizResults$1), {
            key: 2,
            score: score.value,
            "correct-answers": correctAnswers.value,
            "total-questions": questions.value.length,
            accuracy: Math.round(accuracy.value),
            questions: questions.value,
            "user-answers": userAnswers.value,
            onRestartQuiz: restartQuiz,
            onGoBack: goBack
          }, null, 8, ["score", "correct-answers", "total-questions", "accuracy", "questions", "user-answers"]))
        ])
      ]);
    };
  }
});

const useThemeStore = defineStore("theme", () => {
  const isDarkMode = ref(false);
  const toggleTheme = () => {
    isDarkMode.value = !isDarkMode.value;
    applyTheme();
    saveThemeToStorage();
  };
  const setTheme = (dark) => {
    isDarkMode.value = dark;
    applyTheme();
    saveThemeToStorage();
  };
  const applyTheme = () => {
    const html = document.documentElement;
    if (isDarkMode.value) {
      html.classList.add("dark");
      html.style.colorScheme = "dark";
    } else {
      html.classList.remove("dark");
      html.style.colorScheme = "light";
    }
  };
  const saveThemeToStorage = () => {
    localStorage.setItem("theme", isDarkMode.value ? "dark" : "light");
  };
  const loadThemeFromStorage = () => {
    const savedTheme = localStorage.getItem("theme");
    if (savedTheme) {
      isDarkMode.value = savedTheme === "dark";
    } else {
      isDarkMode.value = window.matchMedia("(prefers-color-scheme: dark)").matches;
    }
    applyTheme();
  };
  const initTheme = () => {
    loadThemeFromStorage();
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    mediaQuery.addEventListener("change", (e) => {
      if (!localStorage.getItem("theme")) {
        isDarkMode.value = e.matches;
        applyTheme();
      }
    });
  };
  const currentTheme = () => isDarkMode.value ? "dark" : "light";
  const themeIcon = () => isDarkMode.value ? "" : "";
  const themeLabel = () => isDarkMode.value ? "Ch  ti" : "Ch  sng";
  return {
    // State
    isDarkMode,
    // Actions
    toggleTheme,
    setTheme,
    initTheme,
    // Getters
    currentTheme,
    themeIcon,
    themeLabel
  };
});

const _hoisted_1$1h = { class: "max-w-4xl mx-auto space-y-8" };
const _hoisted_2$1e = { class: "grid grid-cols-1 md:grid-cols-2 gap-6" };
const _hoisted_3$1c = { class: "bg-white dark:bg-black rounded-xl shadow-md overflow-hidden border border-gray-200 dark:border-gray-700" };
const _hoisted_4$18 = { class: "p-6" };
const _hoisted_5$15 = { class: "mt-4" };
const _hoisted_6$12 = { class: "flex items-center space-x-2" };
const _hoisted_7$_ = { class: "px-2 py-1 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 text-xs font-medium rounded-full" };
const _sfc_main$1i = /* @__PURE__ */ defineComponent({
  __name: "TailwindTest",
  setup(__props) {
    const themeStore = useThemeStore();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1h, [
        _cache[5] || (_cache[5] = createBaseVNode("div", { class: "text-center" }, [
          createBaseVNode("h1", { class: "text-4xl font-bold text-gray-900 dark:text-white mb-4" }, " Tailwind CSS & Dark Mode Test "),
          createBaseVNode("p", { class: "text-lg text-gray-600 dark:text-gray-300" }, " Test cc component vi ch  sng/ti ")
        ], -1)),
        createBaseVNode("div", _hoisted_2$1e, [
          _cache[4] || (_cache[4] = createStaticVNode('<div class="bg-white dark:bg-gray-800 rounded-xl shadow-md overflow-hidden border border-gray-200 dark:border-gray-700"><div class="p-6"><div class="uppercase tracking-wide text-sm text-indigo-500 dark:text-indigo-400 font-semibold"> Tailwind CSS </div><h2 class="block mt-1 text-lg leading-tight font-medium text-gray-900 dark:text-white"> Dark Mode Support </h2><p class="mt-2 text-gray-500 dark:text-gray-400"> Tailwind CSS  c cu hnh vi dark mode s dng mu en. </p><div class="mt-4 space-x-2"><button class="bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition-colors"> Primary Button </button><button class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-900 dark:text-white font-medium py-2 px-4 rounded-lg transition-colors"> Secondary Button </button></div></div></div>', 1)),
          createBaseVNode("div", _hoisted_3$1c, [
            createBaseVNode("div", _hoisted_4$18, [
              _cache[1] || (_cache[1] = createBaseVNode("div", { class: "uppercase tracking-wide text-sm text-green-500 dark:text-green-400 font-semibold" }, " Pinia Store ", -1)),
              _cache[2] || (_cache[2] = createBaseVNode("h2", { class: "block mt-1 text-lg leading-tight font-medium text-gray-900 dark:text-white" }, " Theme Management ", -1)),
              _cache[3] || (_cache[3] = createBaseVNode("p", { class: "mt-2 text-gray-500 dark:text-gray-400" }, " S dng Pinia  qun l state ca theme. ", -1)),
              createBaseVNode("div", _hoisted_5$15, [
                createBaseVNode("div", _hoisted_6$12, [
                  _cache[0] || (_cache[0] = createBaseVNode("span", { class: "text-sm text-gray-600 dark:text-gray-300" }, "Current theme:", -1)),
                  createBaseVNode("span", _hoisted_7$_, toDisplayString$1(unref(themeStore).currentTheme()), 1)
                ])
              ])
            ])
          ])
        ]),
        _cache[6] || (_cache[6] = createStaticVNode('<div class="bg-white dark:bg-black rounded-xl shadow-md p-6 border border-gray-200 dark:border-gray-700"><h3 class="text-lg font-medium text-gray-900 dark:text-white mb-4">Form Elements</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"> Text Input </label><input type="text" placeholder="Enter text..." class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 transition-colors"></div><div><label class="block text-sm font-medium text-gray-700 dark:text-dark-text-secondary mb-2"> Select </label><select class="w-full px-3 py-2 border border-gray-300 dark:border-dark-border rounded-md bg-white dark:bg-dark-surface text-gray-900 dark:text-dark-text-primary focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 transition-colors"><option>Option 1</option><option>Option 2</option><option>Option 3</option></select></div></div></div><div class="bg-white dark:bg-black rounded-xl shadow-md p-6 border border-gray-200 dark:border-gray-700"><h3 class="text-lg font-medium text-gray-900 dark:text-white mb-4">Color Palette</h3><div class="grid grid-cols-2 md:grid-cols-4 gap-4"><div class="text-center"><div class="w-16 h-16 bg-blue-500 dark:bg-blue-600 rounded-lg mx-auto mb-2"></div><span class="text-sm text-gray-600 dark:text-gray-300">Blue</span></div><div class="text-center"><div class="w-16 h-16 bg-green-500 dark:bg-green-600 rounded-lg mx-auto mb-2"></div><span class="text-sm text-gray-600 dark:text-gray-300">Green</span></div><div class="text-center"><div class="w-16 h-16 bg-red-500 dark:bg-red-600 rounded-lg mx-auto mb-2"></div><span class="text-sm text-gray-600 dark:text-gray-300">Red</span></div><div class="text-center"><div class="w-16 h-16 bg-purple-500 dark:bg-purple-600 rounded-lg mx-auto mb-2"></div><span class="text-sm text-gray-600 dark:text-gray-300">Purple</span></div></div></div>', 2))
      ]);
    };
  }
});

const _hoisted_1$1g = { class: "min-h-screen bg-gray-50 dark:bg-black flex flex-col justify-center py-12 sm:px-6 lg:px-8" };
const _hoisted_2$1d = { class: "sm:mx-auto sm:w-full sm:max-w-md" };
const _hoisted_3$1b = { class: "text-center" };
const _hoisted_4$17 = { class: "mt-8 space-y-4" };
const _hoisted_5$14 = { class: "text-center" };
const _hoisted_6$11 = { class: "mt-4 flex justify-center space-x-6" };
const _sfc_main$1h = /* @__PURE__ */ defineComponent({
  __name: "NotFoundView",
  setup(__props) {
    const router = useRouter();
    const goBack = () => {
      router.back();
    };
    const goHome = () => {
      router.push("/dashboard");
    };
    return (_ctx, _cache) => {
      const _component_router_link = resolveComponent("router-link");
      return openBlock(), createElementBlock("div", _hoisted_1$1g, [
        createBaseVNode("div", _hoisted_2$1d, [
          createBaseVNode("div", _hoisted_3$1b, [
            _cache[7] || (_cache[7] = createStaticVNode('<div class="mx-auto h-24 w-24 flex items-center justify-center rounded-full bg-red-100 dark:bg-red-900"><svg class="h-12 w-12 text-red-600 dark:text-red-300" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path></svg></div><h1 class="mt-6 text-6xl font-bold text-gray-900 dark:text-white">404</h1><h2 class="mt-4 text-3xl font-bold text-gray-900 dark:text-white">Khng tm thy trang</h2><p class="mt-2 text-lg text-gray-600 dark:text-gray-300"> Xin li, chng ti khng th tm thy trang bn ang tm kim. </p>', 4)),
            createBaseVNode("div", _hoisted_4$17, [
              createBaseVNode("div", { class: "flex justify-center space-x-4" }, [
                createBaseVNode("button", {
                  onClick: goBack,
                  class: "bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                }, _cache[0] || (_cache[0] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5 inline mr-2",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                      "clip-rule": "evenodd"
                    })
                  ], -1),
                  createTextVNode(" Quay li ")
                ])),
                createBaseVNode("button", {
                  onClick: goHome,
                  class: "bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg transition-colors"
                }, _cache[1] || (_cache[1] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5 inline mr-2",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", { d: "M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z" })
                  ], -1),
                  createTextVNode(" V trang ch ")
                ]))
              ]),
              createBaseVNode("div", _hoisted_5$14, [
                _cache[6] || (_cache[6] = createBaseVNode("p", { class: "text-sm text-gray-500 dark:text-gray-400" }, " Hoc th cc lin kt hu ch di y: ", -1)),
                createBaseVNode("div", _hoisted_6$11, [
                  createVNode(_component_router_link, {
                    to: "/vocabulary",
                    class: "text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300 text-sm font-medium"
                  }, {
                    default: withCtx(() => _cache[2] || (_cache[2] = [
                      createTextVNode(" T vng ")
                    ])),
                    _: 1,
                    __: [2]
                  }),
                  createVNode(_component_router_link, {
                    to: "/grammar",
                    class: "text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300 text-sm font-medium"
                  }, {
                    default: withCtx(() => _cache[3] || (_cache[3] = [
                      createTextVNode(" Ng php ")
                    ])),
                    _: 1,
                    __: [3]
                  }),
                  createVNode(_component_router_link, {
                    to: "/practice/flashcard",
                    class: "text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300 text-sm font-medium"
                  }, {
                    default: withCtx(() => _cache[4] || (_cache[4] = [
                      createTextVNode(" Luyn tp ")
                    ])),
                    _: 1,
                    __: [4]
                  }),
                  createVNode(_component_router_link, {
                    to: "/test",
                    class: "text-blue-600 hover:text-blue-500 dark:text-blue-400 dark:hover:text-blue-300 text-sm font-medium"
                  }, {
                    default: withCtx(() => _cache[5] || (_cache[5] = [
                      createTextVNode(" Test Tailwind ")
                    ])),
                    _: 1,
                    __: [5]
                  })
                ])
              ])
            ])
          ])
        ])
      ]);
    };
  }
});

const router = createRouter({
  history: createWebHashHistory("/web-english/"),
  routes: [
    {
      path: "/",
      redirect: "/dashboard"
    },
    {
      path: "/dashboard",
      name: "dashboard",
      component: _sfc_main$1s
    },
    {
      path: "/vocabulary",
      name: "vocabulary-list",
      component: _sfc_main$1r
    },
    {
      path: "/vocabulary/questions",
      name: "vocabulary-questions",
      component: _sfc_main$1q
    },
    {
      path: "/vocabulary/examples",
      name: "vocabulary-examples",
      component: VocabularyExamplesView
    },
    {
      path: "/vocabulary/generator",
      name: "vocabulary-generator",
      component: AutoGeneratorView
    },
    {
      path: "/grammar",
      name: "grammar-list",
      component: GrammarListView
    },
    {
      path: "/grammar/:id",
      name: "grammar-detail",
      component: GrammarDetailView
    },
    {
      path: "/grammar/:id/practice",
      name: "grammar-practice",
      component: _sfc_main$1l
    },
    {
      path: "/practice/flashcard",
      name: "practice-flashcard",
      component: FlashcardView
    },
    {
      path: "/practice/quiz",
      name: "practice-quiz",
      component: _sfc_main$1j
    },
    {
      path: "/test",
      name: "tailwind-test",
      component: _sfc_main$1i
    },
    {
      path: "/:pathMatch(.*)*",
      name: "NotFound",
      component: _sfc_main$1h
    }
  ]
});

const common$2 = {"easy":"Easy","difficult":"Difficult","reviewed":"Reviewed","correct":"Correct","incorrect":"Incorrect","apply":"Apply","back":"Back","restart":"Practice Again","vocabulary":"Vocabulary","grammar":"Grammar","practice":"Practice","dashboard":"Dashboard","save":"Save","saving":"Saving...","update":"Update","delete":"Delete","edit":"Edit","add":"Add","search":"Search","all":"All","title":"Title","previous":"Previous","next":"Next","minutes":"minutes","finish":"Finish","close":"Close","confirm":"Confirm","cancel":"Cancel","reset":"Reset","resetToDefault":"Reset to Default","actions":"Actions","backToTop":"Back to Top","backToTopTooltip":"Back to Top ({percent}%)","backspace":"Backspace","clear":"Clear","space":"Space","select":"Select"};
const autoGenerator$2 = {"title":"Auto Generator","description":"Generate vocabulary words automatically from text, topics, or AI suggestions","methods":{"textAnalysis":"Text Analysis","textAnalysisDesc":"Extract vocabulary from articles, books, or any text content","topicBased":"Topic-based","topicBasedDesc":"Generate words based on specific topics or categories","aiSuggestions":"AI Suggestions","aiSuggestionsDesc":"Get intelligent word suggestions based on your learning level"},"forms":{"textAnalysis":{"title":"Analyze Text Content","inputLabel":"Paste your text content here:","placeholder":"Paste article, book excerpt, or any English text..."},"topicBased":{"title":"Generate by Topic","selectTopic":"Select Topic:","chooseTopic":"Choose a topic..."},"aiSuggestions":{"title":"AI-Powered Generation","preferences":"Learning Preferences:","preferencesPlaceholder":"Describe what type of words you want to learn (e.g., academic words, daily conversation, business terms)...","focusArea":"Focus Area"},"common":{"difficultyLevel":"Difficulty Level","maxWords":"Maximum Words"}},"levels":{"beginner":"Beginner","intermediate":"Intermediate","advanced":"Advanced","mixed":"Mixed Levels"},"topics":{"business":"Business & Finance","technology":"Technology","travel":"Travel & Tourism","health":"Health & Medicine","education":"Education","environment":"Environment","food":"Food & Cooking","sports":"Sports & Fitness"},"focusAreas":{"vocabulary":"General Vocabulary","academic":"Academic Words","conversation":"Conversational","professional":"Professional"},"generate":"Generate Vocabulary","generating":"Generating...","saveAll":"Save All","saveSuccess":"Successfully saved {count} words to your vocabulary list","saveError":"Failed to save vocabulary words","preview":{"title":"Generated Vocabulary"}};
const vocabulary$2 = /* #__PURE__ */ JSON.parse("{\"title\":\"Vocabulary\",\"description\":\"Manage and learn English vocabulary\",\"topics\":{\"uncategorized\":\"Uncategorized\",\"technology\":\"Technology\",\"business\":\"Business\",\"travel\":\"Travel\",\"food\":\"Food\",\"health\":\"Health\",\"education\":\"Education\",\"sports\":\"Sports\",\"entertainment\":\"Entertainment\",\"science\":\"Science\",\"art\":\"Art\",\"music\":\"Music\",\"literature\":\"Literature\",\"politics\":\"Politics\",\"environment\":\"Environment\",\"fashion\":\"Fashion\",\"finance\":\"Finance\"},\"submenu\":{\"manageWords\":\"Manage Words\",\"manageQuestions\":\"Manage Questions\",\"manageExamples\":\"Manage Examples\",\"autoGenerator\":\"Auto Generator\"},\"header\":{\"title\":\"Vocabulary\",\"accordionTitle\":\"Vocabulary Manager\",\"accordionDescription\":\"Add and manage your vocabulary words\"},\"filters\":{\"accordionTitle\":\"Search & Filter\",\"accordionDescription\":\"Search and filter vocabulary words\"},\"grouping\":{\"accordionTitle\":\"Group by Date Settings\",\"accordionDescription\":\"Configure how vocabulary is grouped and displayed\",\"title\":\"Group by Date\",\"description\":\"Group vocabulary words by creation date\",\"hoverToExpand\":\"Hover to Expand\",\"hoverDescription\":\"Open categories on hover when enabled\"},\"tools\":{\"accordionTitle\":\"Tools & Settings\",\"accordionDescription\":\"Voice settings, topic manager, and save & sync options\"},\"addNew\":\"Add New Word\",\"addWord\":\"Add Word\",\"addVocabulary\":\"Add New Vocabulary\",\"editVocabulary\":\"Edit Vocabulary\",\"saveVocabulary\":\"Save Vocabulary\",\"deleteVocabulary\":\"Delete Vocabulary\",\"vocabularyList\":\"Vocabulary List\",\"word\":\"Word\",\"pronunciation\":{\"label\":\"Pronunciation\",\"ipaPickerTitle\":\"IPA Picker\",\"previewPlaceholder\":\"Start building IPA...\",\"wrap\":\"Wrap with slashes\",\"vowels\":\"Vowels\",\"diphthongs\":\"Diphthongs\",\"consonants\":\"Consonants\",\"marks\":\"Marks\",\"openIpaPicker\":\"Open IPA Picker\"},\"meaning\":\"Meaning\",\"category\":\"Category\",\"level\":\"Level\",\"wordType\":\"Word Type\",\"note\":\"Note\",\"favorite\":\"Favorite\",\"isFavorite\":\"Mark as favorite vocabulary\",\"showFavoritesOnly\":\"Show favorites only\",\"searchPlaceholder\":\"Search vocabulary...\",\"wordPlaceholder\":\"Enter word...\",\"meaningPlaceholder\":\"Enter word meaning...\",\"example\":\"Example\",\"examplePlaceholder\":\"Enter example sentence...\",\"synonyms\":\"Synonyms\",\"antonyms\":\"Antonyms\",\"separateByComma\":\"Separate by comma\",\"notePlaceholder\":\"Additional notes about this word...\",\"selectCategory\":\"Select category\",\"selectLevel\":\"Select level\",\"selectWordType\":\"Select word type\",\"confirmDelete\":\"Are you sure you want to delete \\\"{word}\\\"?\",\"confirmDeleteTitle\":\"Confirm Delete\",\"confirmDeleteMessage\":\"Are you sure you want to delete this vocabulary? This action cannot be undone.\",\"updateInfo\":\"Update vocabulary information\",\"vocabInfo\":\"Vocabulary Information\",\"updateSuccess\":\"Vocabulary has been updated successfully.\",\"addSuccess\":\"Vocabulary added successfully!\",\"deleteSuccess\":\"Deleted \\\"{word}\\\" successfully.\",\"deleteAll\":{\"title\":\"Delete All Vocabularies\",\"description\":\"This will permanently delete all vocabulary words from your collection. This action cannot be undone.\",\"button\":\"Delete All Vocabularies\",\"confirmTitle\":\"Delete All Vocabularies\",\"confirmMessage\":\"Are you sure you want to delete all vocabulary words? This action cannot be undone and will permanently remove all your saved words.\",\"warningCount\":\"You are about to delete {count} vocabulary words.\",\"confirm\":\"Delete All\",\"success\":\"All vocabulary words have been deleted successfully\",\"error\":\"Failed to delete all vocabularies. Please try again.\",\"clearLocalStore\":\"Clear Local Store\",\"clearLocalStoreTitle\":\"Clear Local Store Data\",\"clearLocalStoreMessage\":\"This will clear all data stored in your browser's local storage, including vocabulary words, practice sessions, and user preferences. This action cannot be undone.\",\"clearLocalStoreWarning\":\"Warning: This will remove all locally stored data and reset the application to its initial state.\",\"clearLocalStoreConfirm\":\"Clear All Data\",\"clearLocalStoreSuccess\":\"All local store data has been cleared successfully\",\"clearLocalStoreError\":\"Failed to clear local store data. Please try again.\",\"localStoreClearedInfo\":\"Application has been reset to initial state. All local preferences have been cleared.\",\"pageReloadNotice\":\"Note: Page will automatically reload after clearing to ensure complete reset.\"},\"words\":\"words\",\"createdAt\":\"Created at\",\"updatedAt\":\"Updated at\",\"notes\":{\"title\":\"Vocabulary Notes\",\"description\":\"Manage notes for vocabulary words learned today\",\"manageNotes\":\"Manage Notes\",\"noteLabel\":\"Notes for vocabulary\",\"placeholder\":\"Write your notes about this vocabulary learning session...\",\"wordsLearned\":\"Words in this group\",\"noWordsLearned\":\"No vocabulary words in this group\",\"saveSuccess\":\"Notes saved successfully!\",\"autoSaveNotice\":\"Auto-save enabled. Your notes will be included in the next backup.\",\"today\":\"Today\",\"yesterday\":\"Yesterday\"},\"lazyLoading\":{\"loading\":\"Loading...\",\"componentVisible\":\"Component is now visible\",\"componentHidden\":\"Component is hidden\"},\"accordion\":{\"expand\":\"Expand group\",\"editTopic\":\"Edit Topic\",\"saveTopic\":\"Save Topic\",\"cancelTopic\":\"Cancel\",\"topicPlaceholder\":\"Enter topic name...\"},\"progress\":{\"dailyTarget\":\"Daily Target: {target} words\",\"wordsLearned\":\"Words learned: {count}\",\"percentage\":\"{percent}% complete\",\"completed\":\"Completed!\",\"noProgress\":\"No practice yet\",\"tooltip\":\"Daily learning progress: {learned}/{target} words ({percent}%)\"},\"sameTopicDatesTitle\":\"Dates with same topic\",\"sameTopicDatesEmpty\":\"No other dates found for this topic\",\"sameTopicDatesAria\":\"Show dates with same topic\",\"notFound\":\"Vocabulary not found!\",\"updateError\":\"An error occurred while updating vocabulary. Please try again.\",\"deleteError\":\"An error occurred while deleting vocabulary. Please try again.\",\"showingResults\":\"Showing {start} to {end} of {total} results\",\"showingDateGroups\":\"Showing {start} to {end} of {total} date groups\",\"showingCategoryItems\":\"Showing {start} to {end} of {total} items\",\"categories\":{\"technology\":\"Technology\",\"business\":\"Business\",\"travel\":\"Travel\",\"food\":\"Food\",\"health\":\"Health\",\"education\":\"Education\",\"sports\":\"Sports\",\"entertainment\":\"Entertainment\",\"science\":\"Science\",\"art\":\"Art\",\"music\":\"Music\",\"literature\":\"Literature\",\"politics\":\"Politics\",\"environment\":\"Environment\",\"fashion\":\"Fashion\",\"finance\":\"Finance\"},\"levels\":{\"beginner\":\"Beginner\",\"intermediate\":\"Intermediate\",\"advanced\":\"Advanced\"},\"wordTypes\":{\"noun\":\"Noun\",\"verb\":\"Verb\",\"adjective\":\"Adjective\",\"adverb\":\"Adverb\",\"preposition\":\"Preposition\",\"conjunction\":\"Conjunction\",\"interjection\":\"Interjection\"},\"questions\":{\"title\":\"Question Manager\",\"description\":\"Create and manage questions based on your vocabulary words\",\"addQuestion\":\"Add New Question\",\"editQuestion\":\"Edit Question\",\"selectVocabulary\":\"Select Vocabulary\",\"questionText\":\"Question Text\",\"questionType\":\"Question Type\",\"multipleChoice\":\"Multiple Choice\",\"fillBlank\":\"Fill in the Blank\",\"trueFalse\":\"True/False\",\"shortAnswer\":\"Short Answer\",\"options\":\"Options\",\"addOption\":\"Add Option\",\"removeOption\":\"Remove Option\",\"correctAnswer\":\"Correct Answer\",\"difficulty\":\"Difficulty\",\"easy\":\"Easy\",\"medium\":\"Medium\",\"hard\":\"Hard\",\"explanation\":\"Explanation\",\"optional\":\"(Optional)\",\"searchQuestions\":\"Search questions...\",\"filterByVocabulary\":\"Filter by vocabulary\",\"filterByType\":\"Filter by type\",\"allVocabulary\":\"All Vocabulary\",\"allTypes\":\"All Types\",\"createdAt\":\"Created At\",\"noQuestions\":\"No questions found\",\"deleteConfirm\":\"Are you sure you want to delete this question?\",\"true\":\"True\",\"false\":\"False\"},\"examples\":{\"title\":\"Example Manager\",\"description\":\"Create and manage examples based on your vocabulary words\",\"groupByTopic\":\"Group by Topic\",\"addNew\":\"Add New Example\",\"addExample\":\"Add Example\",\"editExample\":\"Edit Example\",\"selectVocabulary\":\"Select Vocabulary\",\"exampleTitle\":\"Example Title\",\"exampleContent\":\"Example Content\",\"translation\":\"Translation\",\"context\":\"Context\",\"exampleType\":\"Example Type\",\"types\":{\"sentence\":\"Sentence\",\"dialogue\":\"Dialogue\",\"phrase\":\"Phrase\",\"context\":\"Context\"},\"difficulty\":{\"medium\":\"Medium\"},\"tags\":\"Tags\",\"addTag\":\"Add tag and press Enter\",\"searchVocabulary\":\"Search vocabulary words...\",\"searchExamples\":\"Search examples...\",\"filterByVocabulary\":\"Filter by vocabulary\",\"filterByType\":\"Filter by type\",\"allVocabulary\":\"All Vocabulary\",\"allTypes\":\"All Types\",\"createdAt\":\"Created At\",\"noVocabulary\":\"No vocabulary words found\",\"noVocabularyDescription\":\"Add some vocabulary words first to create examples for them.\",\"noExamplesForWord\":\"No examples yet\",\"noExamples\":\"No examples found\",\"examples\":\"examples\",\"confirmDelete\":\"Are you sure you want to delete this example?\",\"deleteConfirm\":\"Are you sure you want to delete this example?\",\"playPronunciation\":\"Play pronunciation\",\"playExample\":\"Play example\",\"showExamples\":\"Show examples\",\"hideExamples\":\"Hide examples\",\"showingExamples\":\"Showing {start} to {end} of {total} examples\",\"deleteSuccess\":\"Example deleted successfully\",\"showingVocabulary\":\"Showing {start} to {end} of {total} vocabulary words\",\"showingTopics\":\"Showing {start} to {end} of {total} topics\"},\"image\":{\"title\":\"Image\",\"upload\":\"Upload\",\"url\":\"URL\",\"clickToUpload\":\"Click to upload\",\"orDragDrop\":\" or drag and drop here\",\"supportedFormats\":\"PNG, JPG, GIF, WebP up to 5MB\",\"urlPlaceholder\":\"Paste image URL from the internet...\",\"loadFromUrl\":\"Load from URL\",\"loading\":\"Loading...\",\"preview\":\"Image preview\",\"change\":\"Change\",\"changeUrl\":\"Change URL\",\"remove\":\"Remove\",\"fromUrl\":\"From URL\",\"processing\":\"Processing...\",\"errors\":{\"unsupportedFormat\":\"Unsupported file format. Please choose PNG, JPG, GIF or WebP.\",\"fileTooLarge\":\"File too large. Please choose a file under 5MB.\",\"processingFailed\":\"Unable to process image. Please try again.\",\"emptyUrl\":\"Please enter an image URL.\",\"invalidUrl\":\"Invalid URL or not an image.\",\"urlLoadFailed\":\"Unable to load image from URL. Please check the URL again.\",\"corsWarning\":\"Image accepted but may not display due to the original website's security settings.\"}},\"imageInfo\":{\"title\":\"Missing images\",\"none\":\"All vocabulary have images\",\"date\":\"Date\",\"category\":\"Category\",\"missingCount\":\"{count} without image\",\"aria\":\"Show info about missing images\"},\"save\":{\"title\":\"Save & Sync\",\"subtitle\":\"Manage your vocabulary data storage\",\"mode\":\"Save Mode:\",\"auto\":\"Auto\",\"manual\":\"Manual\",\"saveNow\":\"Save Now\",\"chooseAutoFile\":\"Choose Auto-save File\",\"setup\":\"Setup\",\"changeAutoFile\":\"Change Auto-save File\",\"change\":\"Change\",\"importFile\":\"Import File\",\"importFromComputer\":\"Import from Computer\",\"importExport\":\"Import & Export\",\"importFromDrive\":\"Import from Google Drive\",\"selectFromDrive\":\"Select from Google Drive\",\"signInRequiredForImport\":\"Sign in to Google Drive to import files\",\"noFilesFound\":\"No JSON files found in Google Drive\",\"importShort\":\"Import\",\"lastSave\":\"Last saved: {time}\",\"notSaved\":\"Not saved\",\"autoSaveFileSetup\":\"Auto-save file setup successfully!\",\"autoSaveRetry\":\"Click here to select a new auto-save file\",\"storageType\":\"Storage Type:\",\"autoSaveConfiguration\":\"Auto Save Configuration\",\"localFile\":\"Local File\",\"googleDrive\":\"Google Drive\",\"googleSignIn\":\"Sign In\",\"googleSignOut\":\"Sign Out\",\"googleSync\":\"Sync\",\"googleDriveSetup\":\"Google Drive setup successful\",\"storageInformation\":\"Storage Information\",\"type\":\"Type\",\"googleSignInSuccess\":\"Successfully signed in to Google\",\"googleSignOutSuccess\":\"Successfully signed out from Google\",\"syncFromDriveSuccess\":\"Successfully synced from Google Drive\",\"googleDriveRetry\":\"Google Drive save failed. Check connection.\",\"account\":\"Account\",\"status\":{\"title\":\"Save Status\",\"saving\":\"Saving...\",\"autoSaving\":\"Auto-saving...\",\"autoWithFile\":\"Auto (file saved)\",\"autoLocalStorage\":\"Auto (localStorage)\",\"autoFile\":\"Auto (file)\",\"autoNoFile\":\"Auto (no file selected)\",\"autoGoogleDrive\":\"Auto saved to Google Drive\",\"googleDriveReady\":\"Google Drive ready\",\"googleDriveSignIn\":\"Sign in to Google Drive\",\"fileSaved\":\"File saved\",\"error\":\"Save error\"},\"errors\":{\"browserNotSupported\":\"Browser doesn't support this feature. Please use Chrome or Edge.\",\"fileSelectError\":\"Error selecting file: {error}\",\"invalidFile\":\"Please select a valid JSON file!\",\"invalidFormat\":\"Invalid file format\",\"autoSaveFileFailed\":\"Auto-save to file failed. Please select a new file.\",\"permissionDenied\":\"Permission to write to file denied. Please select a new file.\",\"googleSignInFailed\":\"Google sign-in failed\",\"googleSignOutFailed\":\"Google sign-out failed\",\"googleDriveFailed\":\"Google Drive save failed\",\"googleDriveSetupFailed\":\"Google Drive setup failed\",\"notSignedIn\":\"Not signed in to Google\",\"syncFailed\":\"Sync failed\"},\"import\":{\"confirmMessage\":\"Do you want to import {count} vocabulary from file \\\"{filename}\\\"?\\n\\nCurrent data will be replaced!\",\"confirmGoogleDriveMessage\":\"Do you want to import {count} vocabulary from Google Drive file \\\"{filename}\\\"?\\n\\nCurrent data will be replaced!\",\"successMessage\":\"Successfully imported {count} vocabulary!\",\"googleDriveSuccessMessage\":\"Successfully imported {count} vocabulary from Google Drive!\"}},\"validation\":{\"wordRequired\":\"Word is required\",\"wordTooShort\":\"Word must be at least 1 character\",\"wordTooLong\":\"Word must be less than 100 characters\",\"meaningRequired\":\"Meaning is required\",\"meaningTooShort\":\"Meaning must be at least 1 character\",\"meaningTooLong\":\"Meaning must be less than 500 characters\",\"partOfSpeechRequired\":\"Part of speech is required\",\"categoryRequired\":\"Category is required\",\"levelRequired\":\"Level is required\",\"exampleTooLong\":\"Example must be less than 500 characters\",\"notesTooLong\":\"Notes must be less than 500 characters\",\"pronunciationTooLong\":\"Pronunciation must be less than 100 characters\",\"synonymsInvalid\":\"Please enter valid synonyms separated by commas\",\"antonymsInvalid\":\"Please enter valid antonyms separated by commas\",\"saveError\":\"Error saving vocabulary. Please try again.\",\"saveSuccess\":\"Vocabulary saved successfully!\",\"updateSuccess\":\"Vocabulary updated successfully!\"},\"details\":{\"title\":\"Vocabulary Details\",\"playAudio\":\"Play vocabulary audio\",\"playExample\":\"Play example audio\",\"addFavorite\":\"Add to favorites\",\"removeFavorite\":\"Remove from favorites\"},\"moveMode\":{\"title\":\"Move Mode\",\"active\":\"Active - Click arrows to move words\",\"inactive\":\"Inactive\"},\"moveVocabulary\":\"Move Vocabulary\",\"movingWord\":\"Moving word\",\"movingCategory\":\"Moving all words in category\",\"wordsWillBeMoved\":\"words will be moved to the selected date\",\"selectTargetDate\":\"Select target date\",\"moveToDateGroup\":\"Move to another date group\",\"moveToDate\":\"Move to Date\",\"moveWord\":\"Move Word\",\"moveAll\":\"Move All\",\"moveSuccess\":\"Successfully moved {count} word(s) to {date}\",\"moveError\":\"Failed to move vocabulary\",\"moveAutoSaveNotice\":\"Word moved and will be included in auto-save\",\"batchMoveSuccess\":\"Successfully moved {count} words to {date}\",\"batchMoveError\":\"Failed to move category\",\"filterBySameTopic\":\"Filter by same topic\",\"showingDatesWithSameTopic\":\"Showing only dates with the same topic\",\"selectTargetDateGroup\":\"Select target date group\",\"selectDate\":\"Select Date\",\"noMatchingDates\":\"No dates found matching this topic. Try disabling the filter.\",\"topicManager\":{\"title\":\"Topic Manager\",\"addNewTopic\":\"Add New Topic\",\"editTopic\":\"Edit Topic\",\"topicKey\":\"Topic Key\",\"topicKeyPlaceholder\":\"Example: cooking, programming...\",\"keyDescription\":\"This key will be used in the system. Use only lowercase letters, numbers and underscores.\",\"vietnameseName\":\"Vietnamese Name\",\"vietnameseNamePlaceholder\":\"V d: Nu n, Lp trnh...\",\"englishName\":\"English Name\",\"englishNamePlaceholder\":\"Example: Cooking, Programming...\",\"existingTopics\":\"Existing Topics\",\"noCustomTopics\":\"No custom topics yet.\",\"cannotDeleteInUse\":\"Cannot delete topic in use\",\"confirmDeleteTitle\":\"Confirm Delete Topic\",\"confirmDeleteMessage\":\"Are you sure you want to delete topic \\\"{topic}\\\"?\",\"duplicateKey\":\"Topic key already exists!\",\"builtInTopics\":\"Built-in Topics\",\"builtInTopicsDescription\":\"The system has 16 built-in topics like Technology, Business, Travel... You can add custom topics here.\",\"builtIn\":\"Built-in\",\"manageTopics\":\"Manage Topics\",\"searchPlaceholder\":\"Search topics by name...\",\"pageOf\":\"Page {current} of {total}\",\"koreanName\":\"Korean Name\",\"koreanNamePlaceholder\":\"Example: , ...\"}}");
const korean$2 = {"inputHelper":{"title":"Korean Input Helper","preview":"Preview","placeholder":"Type or click characters below...","consonants":"Consonants ()","vowels":"Vowels ()","commonSyllables":"Common Syllables","openHelper":"Open Korean Input Helper"},"pronunciationHelper":{"title":"Korean Pronunciation Helper","preview":"Pronunciation Preview","placeholder":"Click Korean sounds below...","consonantSounds":"Consonant Sounds ( )","vowelSounds":"Vowel Sounds ( )","commonPatterns":"Common Patterns","specialChars":"Special Characters","openHelper":"Open Korean Pronunciation Helper"},"wordPlaceholder":"Enter Korean word or click + for help","pronunciationPlaceholder":"an-nyeong-ha-se-yo"};
const flashcard$2 = {"header":{"history":"History","settings":"Settings","progress":"Progress","description":"Practice vocabulary with flashcards","exit":"Exit","selectMode":"Select mode"},"empty":{"title":"No flashcards","description":"Add vocabulary to start practicing.","action":"Add Vocabulary"},"settings":{"title":"Flashcard Settings","category":"Category","level":"Level","all":"All","beginner":"Beginner","intermediate":"Intermediate","advanced":"Advanced","autoFlip":"Auto flip card after 3 seconds","shuffle":"Shuffle order","shuffle_disabled_during_practice":"Shuffle is disabled during practice","disabledDuringPractice":"Settings are disabled during practice"},"history":{"title":"Practice History","empty":{"title":"No history","description":"Start practicing to see your history."},"totalCards":"Total cards","correct":"Correct","incorrect":"Incorrect","duration":"Duration","categories":"Categories","accuracy":"Accuracy","result":"Result","pass":"Pass","fail":"Fail","viewDetails":"View details","noDetails":"No details available","deleteSession":"Delete session","confirmDelete":{"title":"Delete Session","message":"Are you sure you want to delete this practice session? This action cannot be undone.","confirm":"Delete","cancel":"Cancel","success":"Session deleted successfully"},"details":{"title":"Session Details","noData":"No details available for this session","yourAnswer":"Your answer","noAnswer":"No answer","correctAnswer":"Correct answer"}},"completion":{"title":"Completed!","description":"You have completed {count} flashcards.","correct":"Correct","incorrect":"Incorrect","accuracy":"Accuracy","result":"Result"},"modes":{"flashcard":"Flashcard","quiz":"Quiz","typing":"Typing","listening":"Listening","image":"Image","pictionary":"Pictionary","flipTile":"Flip Tile","bubbleShooter":"Bubble Shooter","snakeGame":"Snake Hunt","pronunciation":"Pronunciation","change_disabled_during_practice":"Mode change is disabled during practice","selectMode":"Select mode","mode":"Mode"},"image":{"imageAlt":"Vocabulary image","imageError":"Cannot load image","noImage":"No image available","placeholder":"Type the word...","instruction":"Look at the image and type the corresponding word:","correctAnswer":"Correct answer","unavailable":"Image mode is unavailable for the selected date","quizToggle":"Multiple Choice"},"pictionary":{"imageAlt":"Pictionary image","instruction":"Click the boxes and type to fill in the missing letters. Press Enter to check.","instructionDefinition":"Look at the definition and type the word. Press Enter to check.","dragInstructionDefinition":"Look at the definition and drag letters to form the word.","definitionToggle":"Definition Mode","definitionHint":"Definition","noDefinition":"No definition available","unavailable":"Pictionary mode is unavailable for the selected date"},"flipTile":{"tilesFlipped":"Tiles flipped","imageAlt":"Flip tile image","noDefinition":"No definition available","noContent":"No content available for this card.","answerPlaceholder":"Type your answer...","check":"Check","instruction":"Click on tiles to reveal letters (max {maxFlips}), then type your answer and press Enter.","unavailable":"Flip Tile mode is unavailable for the selected date","hintsToggle":"Use Definition Hints"},"scrambleWords":{"toggle":"Scramble Words","instruction":"Arrange the letters to form the word","correct":"Correct!","incorrect":"Try again!","clear":"Clear","check":"Check","backspace":"Backspace"},"card":{"flip_to_meaning":"Click to see meaning","flip_back":"Click to flip back"},"bubbleShooter":{"title":"Bubble Shooter","instruction":"Shoot bubbles to match 4 or more words!","score":"Score","currentWord":"Current Word","gameComplete":"Game Complete!","finalScore":"Final Score: {score}","wordsMatched":"Words Matched: {count}","playAgain":"Play Again"},"snakeGame":{"title":"Snake Hunt","instruction":"Guide the snake to eat the foods with matching first letters!","score":"Score","currentWord":"Current Word","gameComplete":"Game Complete!","finalScore":"Final Score: {score}","wordsEaten":"Words Eaten: {count}","playAgain":"Play Again","gameOver":"Game Over!"},"snake":{"doubleBaitToggle":"Double Bait Mode"},"listening":{"instruction":"Listen and type the word you hear:","placeholder":"Type the word you hear...","correct":" Correct!","incorrect":" Correct answer:","quizToggle":"Multiple Choice"},"typing":{"quizToggle":"Multiple Choice"},"dateFilter":{"enable":"Filter by creation date","allDates":"All dates","info":"Showing {count} vocabulary from {date}"},"pronunciation":{"microphoneError":"Microphone error! Please check microphone access permissions.","yourRecording":"Your Recording","tryAgain":"Try Again!","wordsCrushToggle":"Hidden Words Mode","wordsCrush":{"title":"Words Crush: Hidden Words","instruction":"Fill in the missing letters to complete the word","playAudio":"Play Audio","checkAnswer":"Check Answer","hint":"Hint","reset":"Reset","correct":" Correct!","tryAgain":"Try Again!","correctWord":"Correct word","meaning":"Meaning"}}};
const grammar$2 = {"title":"Grammar","description":"Learn and practice English grammar","addLesson":"Add Lesson","addNewLesson":"Add New Lesson","editLesson":"Edit Lesson","deleteLesson":"Delete Lesson","confirmDelete":"Are you sure you want to delete the lesson \"{title}\"?","search":"Search grammar lessons...","level":"Level","category":"Category","duration":"minutes","durationLabel":"Duration (minutes)","progress":"Progress","continue":"Continue","start":"Start","emptyState":{"title":"No lessons found","description":"Try changing your filters or add a new lesson."},"levels":{"beginner":"Beginner","intermediate":"Intermediate","advanced":"Advanced"},"manager":{"title":"Grammar Manager","manageGrammar":"Manage Grammar","addNew":"Add New Grammar Rule","editGrammar":"Edit Grammar Rule","existingRules":"Grammar Rules","category":"Category","level":"Level","formula":"Grammar Formula","description":"Description","examples":"Examples","titlePlaceholder":"e.g., Present Perfect Tense","formulaPlaceholder":"e.g., Subject + have/has + past participle","descriptionPlaceholder":"Explain how and when to use this grammar rule...","examplePlaceholder":"e.g., I have studied English for 5 years.","selectCategory":"Select Category","selectLevel":"Select Level","addExample":"Add Example","removeExample":"Remove Example","noRulesYet":"No grammar rules added yet","createdAt":"Created","lastModified":"Last Modified","confirmDelete":"Are you sure you want to delete this grammar rule?","ruleAdded":"Grammar rule added successfully","ruleUpdated":"Grammar rule updated successfully","ruleDeleted":"Grammar rule deleted successfully","globalMode":"Global","perDateMode":"Per Date","perDateDescription":"Managing grammar rules for date: {date}","noDateSelected":"No date selected for per-date mode","showVocabulary":"Show Vocabulary","vocabularyForDate":"Vocabulary for {date}","noVocabularyFound":"No vocabulary found for this date"},"categories":{"tenses":"Tenses","conditionals":"Conditionals","passive":"Passive Voice","modals":"Modal Verbs","articles":"Articles","prepositions":"Prepositions","conjunctions":"Conjunctions","other":"Other"},"selectCategory":"Select category","selectLevel":"Select level","titlePlaceholder":"Enter lesson title...","descriptionPlaceholder":"Enter a brief description of the lesson...","lessonContent":"Lesson Content","theory":"Theory","theoryPlaceholder":"Enter the theory content of the lesson...","structure":"Structure","structurePlaceholder":"Enter the grammar structure...","examples":"Examples","examplePlaceholder":"Example {index}","translationPlaceholder":"Translation {index}","addExample":"Add Example","usageRules":"Usage Rules","ruleTitlePlaceholder":"Rule title {index}","ruleDescriptionPlaceholder":"Rule description {index}","addRule":"Add Rule","commonMistakes":"Common Mistakes","wrongSentencePlaceholder":"Wrong sentence {index}","correctSentencePlaceholder":"Correct sentence {index}","explanationPlaceholder":"Explanation {index}","addMistake":"Add Common Mistake","markdownSupported":"Basic Markdown formatting is supported.","practice":{"title":"Grammar Practice","subtitle":"Choose an exercise type to practice","chooseExercise":"Choose Exercise Type","chooseDescription":"Select an exercise type to start practicing","score":"Score","question":"Question","checkAnswer":"Check Answer","next":"Next","finish":"Finish","explanation":"Explanation","reading":{"passage":"Passage","readingTime":"Reading Time","questions":"Questions","showHighlights":"Show Highlights"},"exercises":{"checkAnswer":"Check Answer","next":"Next","multiple-choice":{"title":"Multiple Choice","description":"Choose the correct answer from multiple options"},"fill-blank":{"title":"Fill in the Blanks","description":"Complete sentences with the correct words"},"pronunciation":{"title":"Pronunciation","description":"Practice speaking and pronunciation"},"reading":{"title":"Reading Comprehension","description":"Read passages and answer questions","passage":"Passage","listen":"Listen","readingTime":"Reading Time","questions":"Questions","true":"True","false":"False","yourAnswer":"Your Answer","correctAnswer":"Correct Answer","correct":"Correct","incorrect":"Incorrect","accuracy":"Accuracy","showHighlights":"Show Highlights","hideHighlights":"Hide Highlights"},"listening":{"title":"Listening","description":"Listen to audio and answer questions","instruction":"Listen to the audio and answer the questions:","speed":"Speed","playsLeft":"Plays Left","loading":"Loading...","questions":"Questions","audioUrl":"Audio URL","audioUrlPlaceholder":"Enter audio file URL or YouTube URL...","maxPlays":"Maximum Plays","allowNotes":"Allow Notes","transcript":"Transcript","transcriptPlaceholder":"Enter audio transcript...","question":"Question","multipleChoice":"Multiple Choice","fillBlank":"Fill in the Blank","ordering":"Ordering","addQuestion":"Add Question","correctAnswerPlaceholder":"Enter correct answer...","notesAllowed":"Notes Allowed","takeNotes":"Take Notes","notesPlaceholder":"Write your notes here...","correct":"Correct","incorrect":"Incorrect","accuracy":"Accuracy","showTranscript":"Show Transcript","correctAnswer":"Correct Answer","audioUrlHint":"Enter direct audio URL or YouTube video URL","youtubeDetected":"YouTube URL detected","youtubeNote":"Audio will be extracted from this YouTube video for listening practice"},"writing":{"title":"Writing","description":"Write essays and get feedback","instruction":"Write a paragraph about the following topic:","essay":"Essay","email":"Email","letter":"Letter","paragraph":"Paragraph","requirements":"Requirements","minWords":"Minimum Words","timeLimit":"Time Limit","yourResponse":"Your Response","words":"words","timeRemaining":"Time Remaining","paragraphPlaceholder":"Enter your paragraph here...","essayPlaceholder":"Write your essay here...","emailPlaceholder":"Write your email here...","letterPlaceholder":"Write your letter here...","tips":"Writing Tips","showTips":"Show Tips","hideTips":"Hide Tips","tip1":"Use varied sentence structures","tip2":"Check grammar and spelling","tip3":"Use connecting words to link ideas","tip4":"Ensure your writing has introduction, body, and conclusion","tip5":"Use vocabulary appropriate to the topic","saveDraft":"Save Draft","clear":"Clear","confirmClear":"Are you sure you want to clear all content?","submit":"Submit","analyzing":"Analyzing...","feedback":"Feedback","overallScore":"Overall Score","grammar":"Grammar","vocabulary":"Vocabulary","coherence":"Coherence","taskResponse":"Task Response","strengths":"Strengths","improvements":"Areas for Improvement","corrections":"Specific Corrections","original":"Original","corrected":"Corrected","explanation":"Explanation"}},"fillBlank":{"instruction":"Fill in the blanks with appropriate words:","clear":"Clear All"},"pronunciation":{"instruction":"Listen and repeat the following sentence:","listen":"Listen","ready":"Ready","recording":"Recording...","recorded":"Recorded","processing":"Processing...","analyze":"Analyze","feedback":"Feedback","tips":"Tips","tryAgain":"Try Again","yourRecording":"Your Recording","microphoneError":"Microphone error! Please check microphone access permissions."},"settings":{"title":"Exercise Settings","difficulty":"Difficulty","autoPlay":"Auto-play Audio","autoplayAudio":"Auto-play Audio","showExplanations":"Show Explanations","timeLimit":"Time Limit (minutes)","questionCount":"Number of Questions","close":"Close","save":"Save Settings","levels":{"easy":"Easy","medium":"Medium","hard":"Hard"}},"exerciseManager":{"title":"Exercise Manager","addNew":"Add New Exercise","existing":"Existing Exercises","exerciseType":"Exercise Type","typePlaceholder":"Enter exercise type...","titlePlaceholder":"Enter exercise title...","description":"Description","descriptionPlaceholder":"Enter exercise description...","difficulty":"Difficulty","duration":"Duration","durationPlaceholder":"e.g. 10-15 minutes","add":"Add Exercise","manageQuestions":"Manage Questions"},"questionManager":{"title":"Question Manager","addNew":"Add New Question","editQuestion":"Edit Question","addQuestion":"Add Question","existingQuestions":"Existing Questions","noQuestions":"No questions yet","addFirstQuestion":"Add your first question","question":"Question","questionPlaceholder":"Enter question...","options":"Options","optionPlaceholder":"Enter option...","correctAnswer":"Correct Answer","explanation":"Explanation","explanationPlaceholder":"Enter explanation...","taskType":"Writing Type","prompt":"Prompt","promptPlaceholder":"Enter writing prompt...","requirements":"Requirements","addRequirement":"Add Requirement","requirementPlaceholder":"Enter requirement...","minWords":"Min Words","timeLimit":"Time Limit (minutes)","selectCorrectAnswer":"Select Correct Answer"},"progress":{"question":"Question","of":"of","score":"Score","timeRemaining":"Time Remaining"},"results":{"title":"Exercise Results","score":"Your Score","correct":"Correct","total":"Total","accuracy":"Accuracy","timeSpent":"Time Spent","tryAgain":"Try Again","backToMenu":"Back to Menu","reviewAnswers":"Review Answers"},"common":{"submit":"Submit","next":"Next","previous":"Previous","finish":"Finish","check":"Check Answer","checkAnswer":"Check Answer","showAnswer":"Show Answer","explanation":"Explanation","hint":"Hint","loading":"Loading...","noAnswer":"No answer provided","correct":"Correct!","incorrect":"Incorrect","skip":"Skip","retry":"Retry"}}};
const categories$2 = {"technology":"Technology","business":"Business","travel":"Travel","food":"Food","health":"Health","education":"Education","sports":"Sports","entertainment":"Entertainment","science":"Science","art":"Art","music":"Music","literature":"Literature","politics":"Politics","environment":"Environment"};
const dashboard$2 = {"title":"Dashboard","welcomeMessage":"Welcome to your English learning journey!","todaysProgress":"Today's Progress","currentLevel":"Current Level","stats":{"vocabularyLearned":"Vocabulary Learned","grammarLessons":"Grammar Lessons","currentStreak":"Current Streak","totalTime":"Total Time","days":"days","hours":"hours"},"flashcardStats":{"title":"Flashcard Practice","noData":"No practice sessions yet","startPracticing":"Start practicing to see your stats!","sessions":"Sessions","streak":"Streak","days":"days","accuracy":"Accuracy","bestScore":"Best Score","totalTime":"Total Practice Time","cardsStudied":"Cards Studied","favoriteMode":"Favorite Mode","weeklyProgress":"This Week"},"quickActions":"Quick Actions","recentActivity":"Recent Activity","actions":{"addVocabulary":"Add Vocabulary","practiceFlashcard":"Practice Flashcard","takeQuiz":"Take a Quiz","learnGrammar":"Learn Grammar"},"activity":{"added":"Added '{word}' to {category}","updated":"Updated '{word}' in {category}","justNow":"Just now","noActivity":"No recent activity","addFirstVocab":"Add your first vocabulary to get started!"}};
const app$3 = {"title":"English Learning App","titleShort":"English App"};
const time$2 = {"today":"Today","yesterday":"Yesterday","ago":{"justNow":"Just now","minutesAgo":"{minutes} minutes ago","hoursAgo":"{hours} hours ago","daysAgo":"{days} days ago","yesterday":"Yesterday"}};
const practice$2 = {"controls":{"next":"Next","complete":"Complete","difficult":"Difficult","easy":"Easy","exit":"Exit"},"timer":{"startPractice":"Start Practice","timeLimit":"Time limit per question: {seconds} seconds","timeUp":"Time's Up!","timeUpMessage":"You've run out of time for this question. Try again or skip.","tryAgain":"Try Again","skip":"Skip"},"exitWarning":{"title":"Exit Practice Warning","message":"You are currently in a practice session. If you leave now, you will lose your progress and score. Are you sure you want to exit?","continue":"Continue Practice","exit":"Exit Practice"}};
const quiz$2 = {"progress":{"question":"Question"},"setup":{"title":"Quiz Settings","description":"Customize your quiz preferences","type":"Quiz Type","level":"Difficulty Level","questionCount":"Number of Questions","timeLimit":"Time Limit (minutes)","start":"Start Quiz","allLevels":"All Levels","unlimited":"Unlimited"},"types":{"vocabulary":"Vocabulary","grammar":"Grammar","mixed":"Mixed"},"navigation":{"previous":"Previous","next":"Next","finish":"Finish"},"results":{"completed":"Quiz Completed!","yourResults":"Your Results","score":"Score","correct":"Correct","accuracy":"Accuracy","passed":"Passed","failed":"Failed","above":"Above","below":"Below","reviewAnswers":"Review Answers","correctAnswer":"Correct Answer","yourAnswer":"Your Answer","noAnswer":"No Answer","explanation":"Explanation","restartQuiz":"Restart Quiz"}};
const voice$2 = {"selector":{"title":"Voice Selection"},"gender":{"female":"Female","male":"Male"},"types":{"female_sweet":"Sweet Female","female_clear":"Clear Female","female_professional":"Professional Female","male_strong":"Strong Male","male_gentle":"Gentle Male","male_deep":"Deep Male","korean_female":"Korean Female","korean_male":"Korean Male"},"info":{"name":"Voice Name","language":"Language","gender":"Gender"},"test":"Test Voice","testing":"Testing...","testText":"Hello! This is a voice test.","testTextKorean":"!   .","settings":{"title":"Voice Settings","rate":"Rate","pitch":"Pitch","volume":"Volume"}};
const en = {
  common: common$2,
  autoGenerator: autoGenerator$2,
  vocabulary: vocabulary$2,
  korean: korean$2,
  flashcard: flashcard$2,
  grammar: grammar$2,
  categories: categories$2,
  dashboard: dashboard$2,
  app: app$3,
  time: time$2,
  practice: practice$2,
  quiz: quiz$2,
  voice: voice$2,
};

const common$1 = {"easy":"D","difficult":"Kh","reviewed":" xem","correct":"ng","incorrect":"Sai","cancel":"Hy","back":"Quay li","restart":"Luyn tp li","vocabulary":"T vng","grammar":"Ng php","practice":"Luyn tp","dashboard":"Trang ch","save":"Lu","saving":"ang lu...","update":"Cp nht","delete":"Xa","edit":"Sa","add":"Thm","search":"Tm kim","all":"Tt c","title":"Tiu ","previous":"Trc","next":"Tip","minutes":"pht","finish":"Hon thnh","close":"ng","confirm":"Xc nhn","reset":"t li","apply":"p dng","resetToDefault":"V mc nh","actions":"Thao tc","backToTop":"Ln u trang","backToTopTooltip":"Ln u trang ({percent}%)","checking":"ang kim tra...","backspace":"Xa li","clear":"Xa","space":"Du cch","select":"Chn"};
const autoGenerator$1 = {"title":"T ng To","description":"T ng to t vng t vn bn, ch  hoc gi  AI","methods":{"textAnalysis":"Phn Tch Vn Bn","textAnalysisDesc":"Trch xut t vng t bi bo, sch hoc bt k ni dung vn bn no","topicBased":"Theo Ch ","topicBasedDesc":"To t vng da trn cc ch  hoc danh mc c th","aiSuggestions":"Gi  AI","aiSuggestionsDesc":"Nhn gi  t vng thng minh da trn trnh  hc tp ca bn"},"forms":{"textAnalysis":{"title":"Phn Tch Ni Dung Vn Bn","inputLabel":"Dn ni dung vn bn ca bn vo y:","placeholder":"Dn bi bo, on sch hoc bt k vn bn ting Anh no..."},"topicBased":{"title":"To Theo Ch ","selectTopic":"Chn Ch :","chooseTopic":"Chn mt ch ..."},"aiSuggestions":{"title":"To Bng AI","preferences":"S Thch Hc Tp:","preferencesPlaceholder":"M t loi t bn mun hc (v d: t hc thut, hi thoi hng ngy, thut ng kinh doanh)...","focusArea":"Lnh Vc Tp Trung"},"common":{"difficultyLevel":"Mc  Kh","maxWords":"S T Ti a"}},"levels":{"beginner":"C Bn","intermediate":"Trung Cp","advanced":"Nng Cao","mixed":"Cp  Hn Hp"},"topics":{"business":"Kinh Doanh & Ti Chnh","technology":"Cng Ngh","travel":"Du Lch & Du Lch","health":"Sc Khe & Y Hc","education":"Gio Dc","environment":"Mi Trng","food":"Thc n & Nu n","sports":"Th Thao & Th Hnh"},"focusAreas":{"vocabulary":"T Vng Tng Qut","academic":"T Hc Thut","conversation":"Hi Thoi","professional":"Chuyn Nghip"},"generate":"To T Vng","generating":"ang to...","saveAll":"Lu Tt C","saveSuccess":" lu thnh cng {count} t vo danh sch t vng ca bn","saveError":"Khng th lu t vng","preview":{"title":"T Vng  To"}};
const levels = {"beginner":"C bn","intermediate":"Trung cp","advanced":"Nng cao"};
const vocabulary$1 = /* #__PURE__ */ JSON.parse("{\"title\":\"T vng\",\"description\":\"Qun l v hc t vng ting Anh\",\"topics\":{\"uncategorized\":\"Cha phn loi\",\"technology\":\"Cng ngh\",\"business\":\"Kinh doanh\",\"travel\":\"Du lch\",\"food\":\"m thc\",\"health\":\"Sc khe\",\"education\":\"Gio dc\",\"sports\":\"Th thao\",\"entertainment\":\"Gii tr\",\"science\":\"Khoa hc\",\"art\":\"Ngh thut\",\"music\":\"m nhc\",\"literature\":\"Vn hc\",\"politics\":\"Chnh tr\",\"environment\":\"Mi trng\",\"fashion\":\"Thi trang\",\"finance\":\"Ti chnh\"},\"submenu\":{\"manageWords\":\"Qun l t vng\",\"manageQuestions\":\"Qun l cu hi\",\"manageExamples\":\"Qun l v d\",\"autoGenerator\":\"T ng to\"},\"header\":{\"title\":\"T vng\",\"accordionTitle\":\"Qun l t vng\",\"accordionDescription\":\"Thm v qun l t vng ca bn\"},\"filters\":{\"accordionTitle\":\"Tm kim & Lc\",\"accordionDescription\":\"Tm kim v lc t vng\"},\"grouping\":{\"accordionTitle\":\"Ci t nhm theo ngy\",\"accordionDescription\":\"Thit lp cch hin th v nhm t vng\",\"title\":\"Nhm theo ngy\",\"description\":\"Nhm t vng theo ngy to\",\"hoverToExpand\":\"M rng khi hover\",\"hoverDescription\":\"M rng nhm ngy khi di chut qua thay v nhp chut\"},\"tools\":{\"accordionTitle\":\"Cng c & Ci t\",\"accordionDescription\":\"Ci t ging c, qun l ch  v ng b d liu\"},\"addNew\":\"Thm t mi\",\"addWord\":\"Thm t\",\"addVocabulary\":\"Thm t vng mi\",\"editVocabulary\":\"Chnh sa t vng\",\"saveVocabulary\":\"Lu t vng\",\"deleteVocabulary\":\"Xa t vng\",\"vocabularyList\":\"Danh sch t vng\",\"word\":\"T vng\",\"pronunciation\":{\"label\":\"Pht m\",\"ipaPickerTitle\":\"Bng k hiu IPA\",\"previewPlaceholder\":\"Bt u xy dng IPA...\",\"wrap\":\"Bc bng du gch cho\",\"vowels\":\"Nguyn m\",\"diphthongs\":\"Nguyn m i\",\"consonants\":\"Ph m\",\"marks\":\"K hiu\",\"openIpaPicker\":\"M bng IPA\"},\"meaning\":\"Ngha\",\"category\":\"Ch \",\"level\":\"Mc \",\"wordType\":\"T loi\",\"note\":\"Ghi ch\",\"favorite\":\"Yu thch\",\"isFavorite\":\"nh du l t vng yu thch\",\"showFavoritesOnly\":\"Ch hin th t vng yu thch\",\"searchPlaceholder\":\"Tm t vng...\",\"wordPlaceholder\":\"Nhp t vng...\",\"meaningPlaceholder\":\"Nhp ngha ca t...\",\"example\":\"V d\",\"examplePlaceholder\":\"Nhp cu v d...\",\"synonyms\":\"T ng ngha\",\"antonyms\":\"T tri ngha\",\"separateByComma\":\"Cch nhau bng du phy\",\"notePlaceholder\":\"Ghi ch thm v t ny...\",\"selectCategory\":\"Chn ch \",\"selectLevel\":\"Chn mc \",\"selectWordType\":\"Chn t loi\",\"confirmDelete\":\"Bn c chc chn mun xa t \\\"{word}\\\"?\",\"confirmDeleteTitle\":\"Xc nhn xa\",\"confirmDeleteMessage\":\"Bn c chc chn mun xa t vng ny? Hnh ng ny khng th hon tc.\",\"updateInfo\":\"Cp nht thng tin t vng\",\"vocabInfo\":\"Thng tin t vng\",\"updateSuccess\":\"T vng  c cp nht thnh cng.\",\"addSuccess\":\"Thm t vng thnh cng!\",\"deleteSuccess\":\" xa \\\"{word}\\\" thnh cng.\",\"deleteAll\":{\"title\":\"Xa tt c t vng\",\"description\":\"Thao tc ny s xa vnh vin tt c t vng trong b su tp ca bn. Hnh ng ny khng th hon tc.\",\"button\":\"Xa tt c t vng\",\"confirmTitle\":\"Xa tt c t vng\",\"confirmMessage\":\"Bn c chc chn mun xa tt c t vng? Hnh ng ny khng th hon tc v s xa vnh vin tt c t vng  lu.\",\"warningCount\":\"Bn sp xa {count} t vng.\",\"confirm\":\"Xa tt c\",\"success\":\" xa tt c t vng thnh cng\",\"error\":\"Khng th xa tt c t vng. Vui lng th li.\",\"clearLocalStore\":\"Xa d liu local store\",\"clearLocalStoreTitle\":\"Xa d liu local store\",\"clearLocalStoreMessage\":\"Thao tc ny s xa tt c d liu c lu trong local storage ca trnh duyt, bao gm t vng, phin luyn tp v ty chn ngi dng. Hnh ng ny khng th hon tc.\",\"clearLocalStoreWarning\":\"Cnh bo: Thao tc ny s xa tt c d liu c lu cc b v t li ng dng v trng thi ban u.\",\"clearLocalStoreConfirm\":\"Xa tt c d liu\",\"clearLocalStoreSuccess\":\" xa tt c d liu local store thnh cng\",\"clearLocalStoreError\":\"Khng th xa d liu local store. Vui lng th li.\",\"localStoreClearedInfo\":\"ng dng  c t li v trng thi ban u. Tt c ty chn cc b  c xa.\",\"pageReloadNotice\":\"Lu : Trang s t ng ti li sau khi xa  m bo reset hon ton.\"},\"topic\":\"Ch \",\"words\":\"t\",\"createdAt\":\"To lc\",\"updatedAt\":\"Cp nht\",\"notes\":{\"title\":\"Ghi ch t vng\",\"description\":\"Qun l ghi ch cho cc t vng  hc\",\"manageNotes\":\"Qun l ghi ch\",\"noteLabel\":\"Ghi ch cho t vng\",\"placeholder\":\"Vit ghi ch v bui hc t vng ny ca bn...\",\"wordsLearned\":\"Cc t trong nhm ny\",\"noWordsLearned\":\"Cha c t vng no trong nhm ny\",\"saveSuccess\":\" lu ghi ch thnh cng!\",\"autoSaveNotice\":\" bt lu t ng. Ghi ch ca bn s c a vo bn sao lu tip theo.\",\"today\":\"Hm nay\",\"yesterday\":\"Hm qua\",\"grammarCheck\":\"Bt kim tra ng php (ting Anh)\",\"preview\":\"Xem trc vi gi  ng php\",\"grammarDisclaimer\":\"Kim tra ng php s dng LanguageTool (public API) v c th b gii hn tn sut.\",\"grammarError\":\"Kim tra ng php tht bi. Vui lng th li sau.\",\"lt\":{\"spelling\":\"C th c li chnh t.\",\"grammar\":\"Li ng php\",\"punctuation\":\"Li chm cu\",\"style\":\"Li phong cch\",\"typographical\":\"Li nh my\",\"suggestion\":\"Gi \"}},\"lazyLoading\":{\"loading\":\"ang ti...\",\"componentVisible\":\"Thnh phn hin  hin th\",\"componentHidden\":\"Thnh phn  n\"},\"accordion\":{\"expand\":\"M rng nhm\",\"collapse\":\"Thu gn nhm\",\"addTopic\":\"Thm ch \",\"editTopic\":\"Sa ch \",\"saveTopic\":\"Lu ch \",\"cancelTopic\":\"Hy\",\"topicPlaceholder\":\"Nhp tn ch ...\"},\"progress\":{\"dailyTarget\":\"Mc tiu hng ngy: {target} t\",\"wordsLearned\":\"T  hc: {count}\",\"percentage\":\"Hon thnh {percent}%\",\"completed\":\" hon thnh!\",\"noProgress\":\"Cha luyn tp\",\"tooltip\":\"Tin trnh hc tp hng ngy: {learned}/{target} t ({percent}%)\"},\"sameTopicDatesTitle\":\"Cc ngy c cng ch \",\"sameTopicDatesEmpty\":\"Khng tm thy ngy no khc cho ch  ny\",\"sameTopicDatesAria\":\"Hin th cc ngy c cng ch \",\"notFound\":\"Khng tm thy t vng!\",\"updateError\":\"C li xy ra khi cp nht t vng. Vui lng th li.\",\"deleteError\":\"C li xy ra khi xa t vng. Vui lng th li.\",\"showingResults\":\"Hin th {start} n {end} ca {total} kt qu\",\"showingDateGroups\":\"Hin th {start} n {end} ca {total} nhm ngy\",\"showingCategoryItems\":\"Hin th {start} n {end} ca {total} mc\",\"categories\":{\"technology\":\"Cng ngh\",\"business\":\"Kinh doanh\",\"travel\":\"Du lch\",\"food\":\"m thc\",\"health\":\"Sc khe\",\"education\":\"Gio dc\",\"sports\":\"Th thao\",\"entertainment\":\"Gii tr\",\"science\":\"Khoa hc\",\"art\":\"Ngh thut\",\"music\":\"m nhc\",\"literature\":\"Vn hc\",\"politics\":\"Chnh tr\",\"environment\":\"Mi trng\",\"fashion\":\"Thi trang\",\"finance\":\"Ti chnh\"},\"levels\":{\"beginner\":\"C bn\",\"intermediate\":\"Trung cp\",\"advanced\":\"Nng cao\"},\"wordTypes\":{\"noun\":\"Danh t (noun)\",\"verb\":\"ng t (verb)\",\"adjective\":\"Tnh t (adjective)\",\"adverb\":\"Trng t (adverb)\",\"preposition\":\"Gii t (preposition)\",\"conjunction\":\"Lin t (conjunction)\",\"interjection\":\"Thn t (interjection)\"},\"questions\":{\"title\":\"Qun l cu hi\",\"description\":\"To v qun l cu hi da trn t vng ca bn\",\"addQuestion\":\"Thm cu hi mi\",\"editQuestion\":\"Chnh sa cu hi\",\"selectVocabulary\":\"Chn t vng\",\"questionText\":\"Ni dung cu hi\",\"questionType\":\"Loi cu hi\",\"multipleChoice\":\"Trc nghim\",\"fillBlank\":\"in vo ch trng\",\"trueFalse\":\"ng/Sai\",\"shortAnswer\":\"Cu tr li ngn\",\"options\":\"La chn\",\"addOption\":\"Thm la chn\",\"removeOption\":\"Xa la chn\",\"correctAnswer\":\"p n ng\",\"difficulty\":\" kh\",\"easy\":\"D\",\"medium\":\"Trung bnh\",\"hard\":\"Kh\",\"explanation\":\"Gii thch\",\"optional\":\"(Ty chn)\",\"searchQuestions\":\"Tm kim cu hi...\",\"filterByVocabulary\":\"Lc theo t vng\",\"filterByType\":\"Lc theo loi\",\"allVocabulary\":\"Tt c t vng\",\"allTypes\":\"Tt c loi\",\"createdAt\":\"Ngy to\",\"noQuestions\":\"Khng tm thy cu hi\",\"deleteConfirm\":\"Bn c chc chn mun xa cu hi ny?\",\"true\":\"ng\",\"false\":\"Sai\"},\"examples\":{\"title\":\"Qun l v d\",\"description\":\"To v qun l v d da trn t vng ca bn\",\"groupByTopic\":\"Nhm theo ch \",\"addNew\":\"Thm v d mi\",\"addExample\":\"Thm v d\",\"editExample\":\"Chnh sa v d\",\"selectVocabulary\":\"Chn t vng\",\"exampleTitle\":\"Tiu  v d\",\"exampleContent\":\"Ni dung v d\",\"translation\":\"Dch ngha\",\"context\":\"Ng cnh\",\"exampleType\":\"Loi v d\",\"types\":{\"sentence\":\"Cu vn\",\"dialogue\":\"i thoi\",\"phrase\":\"Cm t\",\"context\":\"Ng cnh\"},\"difficulty\":{\"medium\":\"Trung bnh\"},\"tags\":\"Th\",\"addTag\":\"Thm th v nhn Enter\",\"searchVocabulary\":\"Tm kim t vng...\",\"searchExamples\":\"Tm kim v d...\",\"filterByVocabulary\":\"Lc theo t vng\",\"filterByType\":\"Lc theo loi\",\"allVocabulary\":\"Tt c t vng\",\"allTypes\":\"Tt c loi\",\"createdAt\":\"Ngy to\",\"noVocabulary\":\"Khng tm thy t vng\",\"noVocabularyDescription\":\"Hy thm t vng trc  to v d cho chng.\",\"noExamplesForWord\":\"Cha c v d\",\"noExamples\":\"Khng tm thy v d\",\"examples\":\"v d\",\"confirmDelete\":\"Bn c chc chn mun xa v d ny?\",\"deleteConfirm\":\"Bn c chc chn mun xa v d ny?\",\"playPronunciation\":\"Pht m\",\"playExample\":\"Pht v d\",\"showExamples\":\"Hin th v d\",\"hideExamples\":\"n v d\",\"showingExamples\":\"Hin th {start} n {end} trong {total} v d\",\"deleteSuccess\":\"Xa v d thnh cng\",\"showingVocabulary\":\"Hin th {start} n {end} trong {total} t vng\",\"showingTopics\":\"Hin th {start} n {end} trong {total} ch \"},\"image\":{\"title\":\"Hnh nh\",\"upload\":\"Ti ln\",\"url\":\"URL\",\"clickToUpload\":\"Nhp  ti ln\",\"orDragDrop\":\" hoc ko th ti y\",\"supportedFormats\":\"PNG, JPG, GIF, WebP ti a 5MB\",\"urlPlaceholder\":\"Dn URL hnh nh t internet...\",\"loadFromUrl\":\"Ti t URL\",\"loading\":\"ang ti...\",\"preview\":\"Xem trc hnh nh\",\"change\":\"Thay i\",\"changeUrl\":\"i URL\",\"remove\":\"Xa\",\"fromUrl\":\"T URL\",\"processing\":\"ang x l...\",\"errors\":{\"unsupportedFormat\":\"nh dng file khng c h tr. Vui lng chn PNG, JPG, GIF hoc WebP.\",\"fileTooLarge\":\"File qu ln. Vui lng chn file di 5MB.\",\"processingFailed\":\"Khng th x l hnh nh. Vui lng th li.\",\"emptyUrl\":\"Vui lng nhp URL hnh nh.\",\"invalidUrl\":\"URL khng hp l hoc khng phi l hnh nh.\",\"urlLoadFailed\":\"Khng th ti hnh nh t URL. Vui lng kim tra li.\",\"corsWarning\":\"Hnh nh  c chp nhn nhng c th khng hin th do bo mt website gc.\"}},\"imageInfo\":{\"title\":\"Thiu hnh nh\",\"none\":\"Tt c t vng u c hnh nh\",\"date\":\"Ngy\",\"category\":\"Ch \",\"missingCount\":\"{count} khng c nh\",\"aria\":\"Hin th thng tin v cc t thiu hnh nh\"},\"save\":{\"title\":\"Lu & ng B\",\"subtitle\":\"Qun l lu tr d liu t vng ca bn\",\"mode\":\"Ch  lu:\",\"auto\":\"T ng\",\"manual\":\"Th cng\",\"saveNow\":\"Lu Ngay\",\"chooseAutoFile\":\"Chn Tp Lu T ng\",\"setup\":\"Thit Lp\",\"changeAutoFile\":\"Thay i Tp Lu T ng\",\"change\":\"Thay i\",\"importFile\":\"Import Tp\",\"importFromComputer\":\"Import t My tnh\",\"importExport\":\"Nhp & Xut\",\"importFromDrive\":\"Import t Google Drive\",\"selectFromDrive\":\"Chn t Google Drive\",\"signInRequiredForImport\":\"ng nhp Google Drive  import file\",\"noFilesFound\":\"Khng tm thy file JSON trong Google Drive\",\"importShort\":\"Import\",\"lastSave\":\"Lu ln cui: {time}\",\"notSaved\":\"Cha lu\",\"autoSaveFileSetup\":\"Thit lp tp lu t ng thnh cng!\",\"autoSaveRetry\":\"Nhp vo y  chn tp lu t ng mi\",\"storageType\":\"Loi lu tr:\",\"autoSaveConfiguration\":\"Cu Hnh Lu T ng\",\"localFile\":\"Tp Cc B\",\"googleDrive\":\"Google Drive\",\"googleSignIn\":\"ng Nhp\",\"googleSignOut\":\"ng Xut\",\"googleSync\":\"ng B\",\"googleDriveSetup\":\"Thit lp Google Drive thnh cng\",\"storageInformation\":\"Thng Tin Lu Tr\",\"type\":\"Loi\",\"googleSignInSuccess\":\"ng nhp Google thnh cng\",\"googleSignOutSuccess\":\"ng xut Google thnh cng\",\"syncFromDriveSuccess\":\"ng b t Google Drive thnh cng\",\"googleDriveRetry\":\"Lu Google Drive tht bi. Kim tra kt ni.\",\"account\":\"Ti khon\",\"status\":{\"title\":\"Trng Thi Lu\",\"saving\":\"ang lu...\",\"autoSaving\":\"ang t ng lu...\",\"autoWithFile\":\"T ng ( lu tp)\",\"autoLocalStorage\":\"T ng (localStorage)\",\"autoFile\":\"T ng (tp)\",\"autoNoFile\":\"T ng (cha chn tp)\",\"autoGoogleDrive\":\" lu t ng ln Google Drive\",\"googleDriveReady\":\"Google Drive sn sng\",\"googleDriveSignIn\":\"ng nhp Google Drive\",\"fileSaved\":\" lu tp\",\"error\":\"Li lu\"},\"errors\":{\"browserNotSupported\":\"Trnh duyt khng h tr tnh nng ny. Vui lng s dng Chrome hoc Edge.\",\"fileSelectError\":\"Li chn tp: {error}\",\"invalidFile\":\"Vui lng chn tp JSON hp l!\",\"invalidFormat\":\"nh dng tp khng hp l\",\"autoSaveFileFailed\":\"Lu t ng vo tp tht bi. Vui lng chn tp mi.\",\"permissionDenied\":\"Quyn ghi vo tp b t chi. Vui lng chn tp mi.\",\"googleSignInFailed\":\"ng nhp Google tht bi\",\"googleSignOutFailed\":\"ng xut Google tht bi\",\"googleDriveFailed\":\"Lu Google Drive tht bi\",\"googleDriveSetupFailed\":\"Thit lp Google Drive tht bi\",\"notSignedIn\":\"Cha ng nhp Google\",\"syncFailed\":\"ng b tht bi\"},\"import\":{\"confirmMessage\":\"Bn c mun import {count} t vng t tp \\\"{filename}\\\"?\\n\\nD liu hin ti s b thay th!\",\"confirmGoogleDriveMessage\":\"Bn c mun import {count} t vng t Google Drive file \\\"{filename}\\\"?\\n\\nD liu hin ti s b thay th!\",\"successMessage\":\"Import thnh cng {count} t vng!\",\"googleDriveSuccessMessage\":\"Import thnh cng {count} t vng t Google Drive!\"}},\"validation\":{\"wordRequired\":\"T vng l bt buc\",\"wordTooShort\":\"T vng phi c t nht 1 k t\",\"wordTooLong\":\"T vng phi t hn 100 k t\",\"meaningRequired\":\"Ngha ca t l bt buc\",\"meaningTooShort\":\"Ngha ca t phi c t nht 1 k t\",\"meaningTooLong\":\"Ngha ca t phi t hn 500 k t\",\"partOfSpeechRequired\":\"Loi t l bt buc\",\"categoryRequired\":\"Danh mc l bt buc\",\"levelRequired\":\"Cp  l bt buc\",\"exampleTooLong\":\"V d phi t hn 500 k t\",\"notesTooLong\":\"Ghi ch phi t hn 500 k t\",\"pronunciationTooLong\":\"Phin m phi t hn 100 k t\",\"synonymsInvalid\":\"Vui lng nhp t ng ngha hp l, ngn cch bng du phy\",\"antonymsInvalid\":\"Vui lng nhp t tri ngha hp l, ngn cch bng du phy\",\"saveError\":\"C li khi lu t vng. Vui lng th li.\",\"saveSuccess\":\"Lu t vng thnh cng!\",\"updateSuccess\":\"Cp nht t vng thnh cng!\"},\"details\":{\"title\":\"Chi tit t vng\",\"playAudio\":\"Pht m thanh t vng\",\"playExample\":\"Pht m thanh v d\",\"addFavorite\":\"Thm vo yu thch\",\"removeFavorite\":\"Xa khi yu thch\"},\"moveMode\":{\"title\":\"Ch  di chuyn\",\"active\":\"ang bt - Nhn mi tn  di chuyn t\",\"inactive\":\"Khng hot ng\"},\"moveVocabulary\":\"Di chuyn t vng\",\"movingWord\":\"ang di chuyn t\",\"movingCategory\":\"Di chuyn tt c t trong ch \",\"wordsWillBeMoved\":\"t s c di chuyn n ngy  chn\",\"selectTargetDate\":\"Chn ngy ch\",\"moveToDateGroup\":\"Di chuyn n nhm ngy khc\",\"moveToDate\":\"Di chuyn n ngy\",\"moveWord\":\"Di chuyn t\",\"moveAll\":\"Di chuyn tt c\",\"moveSuccess\":\" di chuyn thnh cng {count} t n {date}\",\"moveError\":\"Li khi di chuyn t vng\",\"moveAutoSaveNotice\":\"T  di chuyn v s c t ng lu\",\"batchMoveSuccess\":\" di chuyn thnh cng {count} t n {date}\",\"batchMoveError\":\"Li khi di chuyn ch \",\"filterBySameTopic\":\"Lc theo cng ch \",\"showingDatesWithSameTopic\":\"Ch hin th cc ngy c cng ch \",\"selectTargetDateGroup\":\"Chn nhm ngy ch\",\"selectDate\":\"Chn ngy\",\"noMatchingDates\":\"Khng tm thy ngy no ph hp vi ch  ny. Hy th tt b lc.\",\"topicManager\":{\"title\":\"Qun l ch \",\"editTopic\":\"Sa ch \",\"addNewTopic\":\"Thm ch  mi\",\"topicKey\":\"M ch \",\"topicKeyPlaceholder\":\"V d: cooking, programming...\",\"keyDescription\":\"M ny s c s dng trong h thng. Ch dng ch thng, s v du gch di.\",\"vietnameseName\":\"Tn ting Vit\",\"vietnameseNamePlaceholder\":\"V d: Nu n, Lp trnh...\",\"englishName\":\"Tn ting Anh\",\"englishNamePlaceholder\":\"V d: Cooking, Programming...\",\"existingTopics\":\"Ch  hin c\",\"noCustomTopics\":\"Cha c ch  ty chnh no.\",\"cannotDeleteInUse\":\"Khng th xa ch  ang c s dng\",\"confirmDeleteTitle\":\"Xc nhn xa ch \",\"confirmDeleteMessage\":\"Bn c chc chn mun xa ch  \\\"{topic}\\\"?\",\"duplicateKey\":\"M ch   tn ti!\",\"builtInTopics\":\"Ch  c sn\",\"builtInTopicsDescription\":\"H thng c 16 ch  c sn nh Cng ngh, Kinh doanh, Du lch... Bn c th thm ch  ty chnh ti y.\",\"builtIn\":\"C sn\",\"manageTopics\":\"Qun l ch \",\"searchPlaceholder\":\"Tm kim ch  theo tn...\",\"pageOf\":\"Trang {current} trong {total}\",\"koreanName\":\"Tn ting Hn\",\"koreanNamePlaceholder\":\"V d: , ...\"},\"flashcard\":{\"header\":{\"history\":\"Lch s\",\"settings\":\"Ci t\",\"progress\":\"Tin \",\"description\":\"Luyn tp t vng vi th ghi nh\",\"exit\":\"Thot\"},\"topicKey\":\"M ch \",\"topicKeyPlaceholder\":\"V d: cooking, programming...\",\"keyDescription\":\"M ny s c dng trong h thng. Ch dng ch thng, s v du gch di.\",\"vietnameseName\":\"Tn ting Vit\",\"vietnameseNamePlaceholder\":\"V d: Nu n, Lp trnh...\",\"englishName\":\"Tn ting Anh\",\"englishNamePlaceholder\":\"Example: Cooking, Programming...\",\"existingTopics\":\"Ch  hin c\",\"noCustomTopics\":\"Cha c ch  ty chnh no.\",\"cannotDeleteInUse\":\"Khng th xa ch  ang c s dng\",\"confirmDeleteTitle\":\"Xc nhn xa ch \",\"confirmDeleteMessage\":\"Bn c chc chn mun xa ch  \\\"{topic}\\\"?\",\"duplicateKey\":\"M ch   tn ti!\",\"builtInTopics\":\"Ch  c sn\",\"builtInTopicsDescription\":\"H thng c sn 16 ch  c bn nh Technology, Business, Travel... Bn c th thm ch  ty chnh  y.\",\"builtIn\":\"C sn\",\"manageTopics\":\"Qun l ch \"}}");
const korean$1 = {"inputHelper":{"title":"Tr l nhp ting Hn","preview":"Xem trc","placeholder":"G hoc nhp vo k t bn di...","consonants":"Ph m ()","vowels":"Nguyn m ()","commonSyllables":"m tit thng dng","openHelper":"M tr l nhp ting Hn"},"pronunciationHelper":{"title":"Tr l phin m ting Hn","preview":"Xem trc phin m","placeholder":"Nhp vo m thanh ting Hn bn di...","consonantSounds":"m ph m ( )","vowelSounds":"m nguyn m ( )","commonPatterns":"Mu thng dng","specialChars":"K t c bit","openHelper":"M tr l phin m ting Hn"},"wordPlaceholder":"Nhp t ting Hn hoc nhp +  c tr gip","pronunciationPlaceholder":"an-nyeong-ha-se-yo"};
const flashcard$1 = {"header":{"history":"Lch s","settings":"Ci t","progress":"Tin ","description":"Luyn tp t vng vi th ghi nh","exit":"Thot","selectMode":"Chn ch "},"empty":{"title":"Khng c flashcard no","description":"Hy thm t vng  bt u luyn tp.","action":"Thm t vng"},"settings":{"title":"Ci t Flashcard","category":"Ch ","level":"Mc ","all":"Tt c","beginner":"C bn","intermediate":"Trung cp","advanced":"Nng cao","autoFlip":"T ng lt th sau 3 giy","shuffle":"Xo trn th t","shuffle_disabled_during_practice":"Khng th xo trn trong qu trnh luyn tp","disabledDuringPractice":"Ci t b v hiu ha trong qu trnh luyn tp"},"history":{"title":"Lch s luyn tp","empty":{"title":"Cha c lch s","description":"Bt u luyn tp  xem lch s ca bn."},"totalCards":"Tng s th","correct":"ng","incorrect":"Sai","duration":"Thi gian","categories":"Ch ","accuracy":" chnh xc","result":"Kt qu","pass":"t","fail":"Cha t","viewDetails":"Xem chi tit","noDetails":"Khng c chi tit","deleteSession":"Xa phin luyn tp","confirmDelete":{"title":"Xa Phin Luyn Tp","message":"Bn c chc chn mun xa phin luyn tp ny? Hnh ng ny khng th hon tc.","confirm":"Xa","cancel":"Hy","success":" xa phin luyn tp thnh cng"},"details":{"title":"Chi tit phin luyn tp","noData":"Khng c chi tit cho phin luyn tp ny","yourAnswer":"Cu tr li ca bn","noAnswer":"Cha tr li","correctAnswer":"p n ng"}},"completion":{"title":"Hon thnh!","description":"Bn  hon thnh {count} flashcard.","correct":"ng","incorrect":"Sai","accuracy":" chnh xc","result":"Kt qu"},"modes":{"flashcard":"Th ghi nh","quiz":"Trc nghim","typing":"G t","listening":"Nghe","image":"Nhn nh","pictionary":"ui hnh bt ch","flipTile":"Lt ","bubbleShooter":"Bn bng t vng","snakeGame":"Rn sn t","pronunciation":"Pht m","change_disabled_during_practice":"Khng th thay i ch  trong qu trnh luyn tp","selectMode":"Chn ch ","mode":"Ch "},"image":{"imageAlt":"Hnh nh t vng","imageError":"Khng th ti hnh nh","noImage":"Khng c hnh nh","placeholder":"Nhp t vng...","instruction":"Nhn vo hnh nh v nhp t vng tng ng:","correctAnswer":"p n ng","unavailable":"Ch  nhn nh khng kh dng cho ngy  chn","quizToggle":"Trc nghim"},"pictionary":{"imageAlt":"Hnh nh ui hnh bt ch","instruction":"Nhp vo cc  v g  in cc ch ci cn thiu. Nhn Enter  kim tra.","instructionDefinition":"Xem nh ngha v g t tng ng. Nhn Enter  kim tra.","dragInstructionDefinition":"Xem nh ngha v ko th cc ch ci  to thnh t.","definitionToggle":"Ch  nh ngha","definitionHint":"nh ngha","noDefinition":"Khng c nh ngha","unavailable":"Ch  ui hnh bt ch khng kh dng cho ngy  chn"},"flipTile":{"tilesFlipped":"  lt","imageAlt":"Hnh nh lt ","noDefinition":"Khng c nh ngha","noContent":"Khng c ni dung cho th ny.","answerPlaceholder":"Nhp cu tr li ca bn...","check":"Kim tra","instruction":"Nhp vo cc   l cc ch ci (ti a 2), sau  nhp cu tr li v nhn Enter.","unavailable":"Ch  lt  khng kh dng cho ngy  chn","hintsToggle":"S dng gi  nh ngha"},"scrambleWords":{"toggle":"Xp t","instruction":"Sp xp cc ch ci  to thnh t","correct":"Chnh xc!","incorrect":"Th li!","backspace":"Xa li","clear":"Xa","check":"Kim tra"},"card":{"flip_to_meaning":"Nhp  xem ngha","flip_back":"Nhp  lt li"},"bubbleShooter":{"title":"Bn Bng T Vng","instruction":"Bn nhng qu bng  ghp 4 t ging nhau tr ln!","score":"im","currentWord":"T Hin Ti","gameComplete":"Hon Thnh Game!","finalScore":"im Cui: {score}","wordsMatched":"T  Ghp: {count}","playAgain":"Chi Li"},"snakeGame":{"title":"Rn Sn T","instruction":"iu khin rn n nhng thc n c ch ci u ph hp!","score":"im","currentWord":"T Hin Ti","gameComplete":"Hon Thnh Game!","finalScore":"im Cui: {score}","wordsEaten":"T  n: {count}","playAgain":"Chi Li","gameOver":"Game Over!"},"snake":{"doubleBaitToggle":"Ch  mi i"},"listening":{"instruction":"Nghe v nhp t bn nghe c:","placeholder":"Nhp t bn nghe c...","correct":" Chnh xc!","incorrect":" p n ng:","quizToggle":"Trc nghim"},"typing":{"quizToggle":"Trc nghim"},"dateFilter":{"enable":"Lc theo ngy to","allDates":"Tt c ngy","info":"Hin th {count} t vng t {date}"},"pronunciation":{"microphoneError":"Li microphone! Vui lng kim tra quyn truy cp microphone.","yourRecording":"Bn Ghi m Ca Bn","tryAgain":"Th Li!","wordsCrushToggle":"Ch  T n","wordsCrush":{"title":"Words Crush: T n","instruction":"in cc ch ci cn thiu  hon thnh t","playAudio":"Pht m Thanh","checkAnswer":"Kim Tra p n","hint":"Gi ","reset":"t Li","correct":" Chnh xc!","tryAgain":"Th Li!","correctWord":"T ng","meaning":"Ngha"}}};
const grammar$1 = {"title":"Ng php","description":"Hc v luyn tp ng php ting Anh","addLesson":"Thm bi hc","addNewLesson":"Thm bi hc mi","editLesson":"Sa bi hc","deleteLesson":"Xa bi hc","confirmDelete":"Bn c chc chn mun xa bi hc \"{title}\"?","search":"Tm bi hc ng php...","level":"Mc ","category":"Ch ","duration":"pht","durationLabel":"Thi lng (pht)","progress":"Tin ","continue":"Tip tc","start":"Bt u","emptyState":{"title":"Khng tm thy bi hc no","description":"Hy th thay i b lc hoc thm bi hc mi."},"levels":{"beginner":"C bn","intermediate":"Trung cp","advanced":"Nng cao"},"manager":{"title":"Qun l ng php","manageGrammar":"Qun l ng php","addNew":"Thm quy tc ng php mi","editGrammar":"Sa quy tc ng php","existingRules":"Quy tc ng php","category":"Ch ","level":"Mc ","formula":"Cng thc ng php","description":"M t","examples":"V d","titlePlaceholder":"vd: Th hin ti hon thnh","formulaPlaceholder":"vd: Ch ng + have/has + qu kh phn t","descriptionPlaceholder":"Gii thch cch v khi no s dng quy tc ng php ny...","examplePlaceholder":"vd: Ti  hc ting Anh c 5 nm.","selectCategory":"Chn ch ","selectLevel":"Chn mc ","addExample":"Thm v d","removeExample":"Xa v d","noRulesYet":"Cha c quy tc ng php no","createdAt":"To lc","lastModified":"Sa ln cui","confirmDelete":"Bn c chc chn mun xa quy tc ng php ny?","ruleAdded":" thm quy tc ng php thnh cng","ruleUpdated":" cp nht quy tc ng php thnh cng","ruleDeleted":" xa quy tc ng php thnh cng","globalMode":"Chung","perDateMode":"Theo ngy","perDateDescription":"ang qun l quy tc ng php cho ngy: {date}","noDateSelected":"Cha chn ngy cho ch  theo ngy","showVocabulary":"Hin th t vng","vocabularyForDate":"T vng ngy {date}","noVocabularyFound":"Khng tm thy t vng no cho ngy ny"},"categories":{"tenses":"Th","conditionals":"Cu iu kin","passive":"Cu b ng","modals":"ng t khuyt thiu","articles":"Mo t","prepositions":"Gii t","conjunctions":"Lin t","other":"Khc"},"selectCategory":"Chn ch ","selectLevel":"Chn mc ","titlePlaceholder":"Nhp tiu  bi hc...","descriptionPlaceholder":"Nhp m t ngn v bi hc...","lessonContent":"Ni dung bi hc","theory":"L thuyt","theoryPlaceholder":"Nhp ni dung l thuyt ca bi hc...","structure":"Cu trc","structurePlaceholder":"Nhp cu trc ng php...","examples":"V d","examplePlaceholder":"V d {index}","translationPlaceholder":"Dch ngha {index}","addExample":"Thm v d","usageRules":"Quy tc s dng","ruleTitlePlaceholder":"Tiu  quy tc {index}","ruleDescriptionPlaceholder":"M t quy tc {index}","addRule":"Thm quy tc","commonMistakes":"Li thng gp","wrongSentencePlaceholder":"Cu sai {index}","correctSentencePlaceholder":"Cu ng {index}","explanationPlaceholder":"Gii thch {index}","addMistake":"Thm li thng gp","markdownSupported":"H tr nh dng Markdown c bn.","practice":{"title":"Luyn tp ng php","subtitle":"Chn loi bi tp  luyn tp","chooseExercise":"Chn loi bi tp","chooseDescription":"Chn mt loi bi tp  bt u luyn tp","score":"im","question":"Cu hi","checkAnswer":"Kim tra p n","next":"Tip theo","finish":"Hon thnh","explanation":"Gii thch","reading":{"passage":"on vn","readingTime":"Thi gian c","questions":"Cu hi","showHighlights":"Hin th nh du"},"exercises":{"checkAnswer":"Kim tra p n","next":"Tip theo","multiple-choice":{"title":"Trc nghim","description":"Chn p n ng t nhiu la chn"},"fill-blank":{"title":"in vo ch trng","description":"Hon thnh cu vi t ng"},"pronunciation":{"title":"Pht m","description":"Luyn tp ni v pht m"},"reading":{"title":"c hiu","description":"c on vn v tr li cu hi","passage":"on vn","listen":"Nghe","readingTime":"Thi gian c","questions":"Cu hi","true":"ng","false":"Sai","yourAnswer":"Cu tr li ca bn","correctAnswer":"Cu tr li ng","correct":"ng","incorrect":"Sai","accuracy":" chnh xc","showHighlights":"Hin th nh du","hideHighlights":"n nh du"},"listening":{"title":"Nghe","description":"Nghe audio v tr li cu hi","instruction":"Nghe on audio v tr li cu hi:","speed":"Tc ","playsLeft":"Lt nghe cn li","loading":"ang ti...","questions":"Cu hi","audioUrl":"URL m thanh","audioUrlPlaceholder":"Nhp ng dn file m thanh...","maxPlays":"S ln nghe ti a","allowNotes":"Cho php ghi ch","transcript":"Bn ghi m","transcriptPlaceholder":"Nhp ni dung bn ghi m...","question":"Cu hi","multipleChoice":"Trc nghim","fillBlank":"in vo ch trng","ordering":"Sp xp th t","addQuestion":"Thm cu hi","correctAnswerPlaceholder":"Nhp p n ng...","notesAllowed":"Cho php ghi ch","takeNotes":"Ghi ch","notesPlaceholder":"Vit ghi ch ca bn  y...","correct":"ng","incorrect":"Sai","accuracy":" chnh xc","showTranscript":"Hin bn ghi m","correctAnswer":"p n ng","audioUrlHint":"Nhp URL m thanh trc tip hoc URL video YouTube","youtubeDetected":"Pht hin URL YouTube","youtubeNote":"m thanh s c trch xut t video YouTube ny  luyn nghe"},"writing":{"title":"Luyn vit","description":"Vit bi lun v nhn phn hi","instruction":"Vit mt on vn v ch  sau:","essay":"Bi lun","email":"Email","letter":"Th","paragraph":"on vn","requirements":"Yu cu","minWords":"S t ti thiu","timeLimit":"Thi gian gii hn","yourResponse":"Cu tr li ca bn","words":"t","timeRemaining":"Thi gian cn li","paragraphPlaceholder":"Nhp on vn ca bn  y...","essayPlaceholder":"Vit bi lun ca bn  y...","emailPlaceholder":"Vit email ca bn  y...","letterPlaceholder":"Vit th ca bn  y...","tips":"Mo vit","showTips":"Hin th mo","hideTips":"n mo","tip1":"S dng cu trc cu a dng","tip2":"Kim tra ng php v chnh t","tip3":"S dng t ni  lin kt  tng","tip4":"m bo bi vit c m bi, thn bi v kt lun","tip5":"S dng t vng ph hp vi ch ","saveDraft":"Lu nhp","clear":"Xa","confirmClear":"Bn c chc chn mun xa ton b ni dung?","submit":"Np bi","analyzing":"ang phn tch...","feedback":"Phn hi","overallScore":"im tng th","grammar":"Ng php","vocabulary":"T vng","coherence":"Tnh mch lc","taskResponse":"Phn hi ch ","strengths":"im mnh","improvements":"Cn ci thin","corrections":"Sa li c th","original":"Gc","corrected":" sa","explanation":"Gii thch"}},"fillBlank":{"instruction":"in t thch hp vo ch trng:","clear":"Xa tt c"},"pronunciation":{"instruction":"Nghe v lp li cu sau:","listen":"Nghe","ready":"Sn sng","recording":"ang ghi m...","recorded":" ghi m","processing":"ang x l...","analyze":"Phn tch","feedback":"Phn hi","tips":"Mo","tryAgain":"Th li","yourRecording":"Bn ghi m ca bn","microphoneError":"Li microphone! Vui lng kim tra quyn truy cp microphone."},"settings":{"title":"Ci t bi tp","difficulty":" kh","autoPlay":"T ng pht m thanh","autoplayAudio":"T ng pht m thanh","showExplanations":"Hin th gii thch","timeLimit":"Gii hn thi gian (pht)","questionCount":"S cu hi","close":"ng","save":"Lu ci t","levels":{"easy":"D","medium":"Trung bnh","hard":"Kh"}},"exerciseManager":{"title":"Qun l bi tp","addNew":"Thm bi tp mi","existing":"Bi tp hin c","exerciseType":"Loi bi tp","typePlaceholder":"Nhp loi bi tp...","titlePlaceholder":"Nhp tiu  bi tp...","description":"M t","descriptionPlaceholder":"Nhp m t bi tp...","difficulty":" kh","duration":"Thi lng","durationPlaceholder":"V d: 10-15 pht","add":"Thm bi tp","manageQuestions":"Qun l  bi"},"questionManager":{"title":"Qun l  bi","addNew":"Thm  bi mi","editQuestion":"Sa  bi","addQuestion":"Thm  bi","existingQuestions":" bi hin c","noQuestions":"Cha c  bi no","addFirstQuestion":"Hy thm  bi u tin","question":"Cu hi","questionPlaceholder":"Nhp cu hi...","options":"Cc la chn","optionPlaceholder":"Nhp la chn...","correctAnswer":"p n ng","explanation":"Gii thch","explanationPlaceholder":"Nhp gii thch...","taskType":"Loi bi vit","prompt":" bi","promptPlaceholder":"Nhp  bi vit...","requirements":"Yu cu","addRequirement":"Thm yu cu","requirementPlaceholder":"Nhp yu cu...","minWords":"S t ti thiu","timeLimit":"Thi gian (pht)","selectCorrectAnswer":"Chn p n ng"},"progress":{"question":"Cu hi","of":"ca","score":"im","timeRemaining":"Thi gian cn li"},"results":{"title":"Kt qu bi tp","score":"im ca bn","correct":"ng","total":"Tng","accuracy":" chnh xc","timeSpent":"Thi gian lm bi","tryAgain":"Th li","backToMenu":"V menu","reviewAnswers":"Xem li p n"},"common":{"submit":"Np bi","next":"Tip theo","previous":"Trc","finish":"Hon thnh","check":"Kim tra p n","checkAnswer":"Kim tra p n","showAnswer":"Hin p n","explanation":"Gii thch","hint":"Gi ","loading":"ang ti...","noAnswer":"Khng c p n","correct":"ng!","incorrect":"Sai","skip":"B qua","retry":"Th li"}}};
const categories$1 = {"technology":"Cng ngh","business":"Kinh doanh","travel":"Du lch","food":"m thc","health":"Sc khe","education":"Gio dc","sports":"Th thao","entertainment":"Gii tr","science":"Khoa hc","art":"Ngh thut","music":"m nhc","literature":"Vn hc","politics":"Chnh tr","environment":"Mi trng","fashion":"Thi trang","finance":"Ti chnh"};
const dashboard$1 = {"title":"Trang ch","description":"Tng quan v tin  hc tp ca bn","welcomeMessage":"Cho mng bn n vi hnh trnh hc ting Anh!","todaysProgress":"Tin  hm nay","currentLevel":"Cp  hin ti","quickActions":"Thao tc nhanh","recentActivity":"Hot ng gn y","stats":{"vocabularyLearned":"T vng  hc","grammarLessons":"Bi ng php","currentStreak":"Chui lin tip","totalTime":"Tng thi gian","days":"ngy","hours":"gi"},"flashcardStats":{"title":"Luyn tp Flashcard","noData":"Cha c phin luyn tp no","startPracticing":"Bt u luyn tp  xem thng k!","sessions":"Phin","streak":"Chui","days":"ngy","accuracy":" chnh xc","bestScore":"im cao nht","totalTime":"Tng thi gian luyn tp","cardsStudied":"Th  hc","favoriteMode":"Ch  yu thch","weeklyProgress":"Tun ny"},"actions":{"addVocabulary":"Thm t vng","practiceFlashcard":"Luyn tp Flashcard","takeQuiz":"Lm bi kim tra","learnGrammar":"Hc ng php"},"activity":{"added":" thm '{word}' vo {category}","updated":" cp nht '{word}' trong {category}","justNow":"Va xong","noActivity":"Khng c hot ng gn y","addFirstVocab":"Thm t vng u tin  bt u!"}};
const app$2 = {"title":"ng dng Hc Ting Anh","titleShort":"ng dng Ting Anh"};
const time$1 = {"today":"Hm nay","yesterday":"Hm qua","ago":{"justNow":"Va xong","minutesAgo":"{minutes} pht trc","hoursAgo":"{hours} gi trc","daysAgo":"{days} ngy trc","yesterday":"Hm qua"}};
const practice$1 = {"controls":{"next":"Tip theo","complete":"Hon thnh","difficult":"Kh","easy":"D","exit":"Thot"},"timer":{"startPractice":"Bt u luyn tp","timeLimit":"Thi gian cho mi cu: {seconds} giy","timeUp":"Ht thi gian!","timeUpMessage":"Bn  ht thi gian cho cu ny. Hy th li hoc b qua.","tryAgain":"Th li","skip":"B qua"},"exitWarning":{"title":"Cnh bo ri khi bi tp","message":"Bn ang trong qu trnh luyn tp. Nu ri khi by gi, bn s mt tin  v khng t im. Bn c chc chn mun ri?","continue":"Tip tc luyn tp","exit":"Ri khi bi tp"}};
const quiz$1 = {"progress":{"question":"Cu hi"},"setup":{"title":"Ci t Quiz","description":"Ty chnh quiz theo s thch ca bn","type":"Loi quiz","level":"Mc ","questionCount":"S cu hi","timeLimit":"Thi gian (pht)","start":"Bt u Quiz","allLevels":"Tt c","unlimited":"Khng gii hn"},"types":{"vocabulary":"T vng","grammar":"Ng php","mixed":"Hn hp"},"navigation":{"previous":"Cu trc","next":"Cu tip","finish":"Hon thnh"},"results":{"title":"Kt qu quiz","score":"im s","correct":"ng","accuracy":" chnh xc","passed":"t","failed":"Cha t","above":"Trn","below":"Di","reviewAnswers":"Xem li p n","correctAnswer":"p n ng","yourAnswer":"Bn chn","noAnswer":"Khng chn","explanation":"Gii thch","restartQuiz":"Lm li Quiz"}};
const voice$1 = {"selector":{"title":"Ging c"},"gender":{"female":"N","male":"Nam"},"types":{"female_sweet":"Ging n Ngt ngo","female_clear":"Ging n Trong tro","female_professional":"Ging n Chuyn nghip","male_strong":"Ging nam Mnh m","male_gentle":"Ging nam Du dng","male_deep":"Ging nam Trm m","korean_female":"Ging n Hn Quc","korean_male":"Ging nam Hn Quc"},"info":{"name":"Tn","language":"Ngn ng","gender":"Gii tnh"},"test":"Th nghim ging","testing":"ang th nghim...","testText":"Xin cho! y l bi kim tra ging ni.","testTextKorean":"!   .","settings":{"title":"Ci t ging ni","rate":"Tc ","pitch":"Cao ","volume":"m lng"}};
const vi = {
  common: common$1,
  autoGenerator: autoGenerator$1,
  levels,
  vocabulary: vocabulary$1,
  korean: korean$1,
  flashcard: flashcard$1,
  grammar: grammar$1,
  categories: categories$1,
  dashboard: dashboard$1,
  app: app$2,
  time: time$1,
  practice: practice$1,
  quiz: quiz$1,
  voice: voice$1,
};

const common = {"easy":"","difficult":"","reviewed":" ","correct":"","incorrect":"","cancel":"","apply":"","back":"","restart":" ","vocabulary":"","grammar":"","practice":"","dashboard":"","save":"","saving":" ...","update":"","delete":"","edit":"","add":"","search":"","all":"","title":"","previous":"","next":"","minutes":"","finish":"","close":"","confirm":"","reset":"","resetToDefault":" ","actions":"","backToTop":" ","backToTopTooltip":"  ({percent}%)","backspace":"","clear":"","space":"","select":""};
const autoGenerator = {"title":" ","description":",   AI    ","methods":{"textAnalysis":" ","textAnalysisDesc":",       ","topicBased":" ","topicBasedDesc":"     ","aiSuggestions":"AI ","aiSuggestionsDesc":"      "},"forms":{"textAnalysis":{"title":"  ","inputLabel":"   :","placeholder":",      ..."},"topicBased":{"title":" ","selectTopic":" :","chooseTopic":" ..."},"aiSuggestions":{"title":"AI  ","preferences":" :","preferencesPlaceholder":"     (:  ,  ,  )...","focusArea":" "},"common":{"difficultyLevel":"","maxWords":"  "}},"levels":{"beginner":"","intermediate":"","advanced":"","mixed":" "},"topics":{"business":" & ","technology":"","travel":" & ","health":" & ","education":"","environment":"","food":" & ","sports":" & "},"focusAreas":{"vocabulary":" ","academic":" ","conversation":"","professional":" "},"generate":" ","generating":" ...","saveAll":" ","saveSuccess":"{count}     ","saveError":"  ","preview":{"title":" "}};
const vocabulary = /* #__PURE__ */ JSON.parse("{\"title\":\"\",\"description\":\"   \",\"topics\":{\"uncategorized\":\"\",\"technology\":\"\",\"business\":\"\",\"travel\":\"\",\"food\":\"\",\"health\":\"\",\"education\":\"\",\"sports\":\"\",\"entertainment\":\"\",\"science\":\"\",\"art\":\"\",\"music\":\"\",\"literature\":\"\",\"politics\":\"\",\"environment\":\"\",\"fashion\":\"\",\"finance\":\"\"},\"submenu\":{\"manageWords\":\" \",\"manageQuestions\":\" \",\"manageExamples\":\" \",\"autoGenerator\":\" \"},\"header\":{\"title\":\"\",\"accordionTitle\":\" \",\"accordionDescription\":\"  \"},\"filters\":{\"accordionTitle\":\"  \",\"accordionDescription\":\"  \"},\"grouping\":{\"accordionTitle\":\"  \",\"accordionDescription\":\"     \",\"title\":\" \",\"description\":\"    \",\"hoverToExpand\":\" \",\"hoverDescription\":\"    \"},\"tools\":{\"accordionTitle\":\"  \",\"accordionDescription\":\" ,      \"},\"addNew\":\"  \",\"addWord\":\" \",\"addVocabulary\":\"  \",\"editVocabulary\":\" \",\"saveVocabulary\":\" \",\"deleteVocabulary\":\" \",\"vocabularyList\":\" \",\"word\":\"\",\"pronunciation\":{\"label\":\"\",\"ipaPickerTitle\":\"IPA \",\"previewPlaceholder\":\"IPA  ...\",\"wrap\":\" \",\"vowels\":\"\",\"diphthongs\":\"\",\"consonants\":\"\",\"marks\":\"\",\"openIpaPicker\":\"IPA  \"},\"meaning\":\"\",\"category\":\"\",\"level\":\"\",\"wordType\":\"\",\"note\":\"\",\"favorite\":\"\",\"isFavorite\":\"  \",\"showFavoritesOnly\":\" \",\"searchPlaceholder\":\" ...\",\"wordPlaceholder\":\" ...\",\"meaningPlaceholder\":\"  ...\",\"example\":\"\",\"examplePlaceholder\":\" ...\",\"synonyms\":\"\",\"antonyms\":\"\",\"separateByComma\":\" \",\"notePlaceholder\":\"    ...\",\"imageUrl\":\" URL\",\"imageUrlPlaceholder\":\" URL  ()\",\"selectCategory\":\" \",\"selectLevel\":\" \",\"selectWordType\":\" \",\"confirmDelete\":\"\\\"{word}\\\" ?\",\"confirmDeleteTitle\":\" \",\"confirmDeleteMessage\":\"  ?     .\",\"updateInfo\":\"  \",\"vocabInfo\":\" \",\"updateSuccess\":\"  .\",\"addSuccess\":\"  !\",\"deleteSuccess\":\"\\\"{word}\\\"  .\",\"deleteAll\":{\"title\":\"  \",\"description\":\"      .     .\",\"button\":\"  \",\"confirmTitle\":\"  \",\"confirmMessage\":\"   ?          .\",\"warningCount\":\"{count}   .\",\"confirm\":\" \",\"success\":\"   \",\"error\":\"   .  .\",\"clearLocalStore\":\"   \",\"clearLocalStoreTitle\":\"   \",\"clearLocalStoreMessage\":\"        . ,      .     .\",\"clearLocalStoreWarning\":\":           .\",\"clearLocalStoreConfirm\":\"  \",\"clearLocalStoreSuccess\":\"    \",\"clearLocalStoreError\":\"    .  .\",\"localStoreClearedInfo\":\"   .    .\",\"pageReloadNotice\":\":         .\"},\"words\":\"\",\"createdAt\":\"\",\"updatedAt\":\"\",\"notes\":{\"title\":\" \",\"description\":\"     \",\"manageNotes\":\" \",\"noteLabel\":\" \",\"placeholder\":\"     ...\",\"wordsLearned\":\"  \",\"noWordsLearned\":\"   \",\"saveSuccess\":\"  !\",\"autoSaveNotice\":\"  .    .\",\"today\":\"\",\"yesterday\":\"\"},\"lazyLoading\":{\"loading\":\" ...\",\"componentVisible\":\" \",\"componentHidden\":\" \"},\"accordion\":{\"expand\":\" \",\"collapse\":\" \",\"addTopic\":\" \",\"editTopic\":\" \",\"saveTopic\":\" \",\"cancelTopic\":\"\",\"topicPlaceholder\":\"  ...\"},\"progress\":{\"dailyTarget\":\" : {target} \",\"wordsLearned\":\" : {count}\",\"percentage\":\"{percent}% \",\"completed\":\"!\",\"noProgress\":\"  \",\"tooltip\":\"  : {learned}/{target}  ({percent}%)\"},\"sameTopicDatesTitle\":\"   \",\"sameTopicDatesEmpty\":\"    \",\"sameTopicDatesAria\":\"   \",\"notFound\":\"   !\",\"updateError\":\"    .  .\",\"deleteError\":\"    .  .\",\"showingResults\":\" {total}  {start}{end} \",\"showingDateGroups\":\" {total}    {start}{end} \",\"showingCategoryItems\":\" {total}   {start}{end} \",\"categories\":{\"technology\":\"\",\"business\":\"\",\"travel\":\"\",\"food\":\"\",\"health\":\"\",\"education\":\"\",\"sports\":\"\",\"entertainment\":\"\",\"science\":\"\",\"art\":\"\",\"music\":\"\",\"literature\":\"\",\"politics\":\"\",\"environment\":\"\",\"fashion\":\"\",\"finance\":\"\"},\"levels\":{\"beginner\":\"\",\"intermediate\":\"\",\"advanced\":\"\"},\"wordTypes\":{\"noun\":\"\",\"verb\":\"\",\"adjective\":\"\",\"adverb\":\"\",\"preposition\":\"\",\"conjunction\":\"\",\"interjection\":\"\"},\"questions\":{\"title\":\" \",\"description\":\"    \",\"addQuestion\":\"  \",\"editQuestion\":\" \",\"selectVocabulary\":\" \",\"questionText\":\" \",\"questionType\":\" \",\"multipleChoice\":\"\",\"fillBlank\":\" \",\"trueFalse\":\"/\",\"shortAnswer\":\"\",\"options\":\"\",\"addOption\":\" \",\"removeOption\":\" \",\"correctAnswer\":\"\",\"difficulty\":\"\",\"easy\":\"\",\"medium\":\"\",\"hard\":\"\",\"explanation\":\"\",\"optional\":\"()\",\"searchQuestions\":\" ...\",\"filterByVocabulary\":\" \",\"filterByType\":\" \",\"allVocabulary\":\" \",\"allTypes\":\" \",\"createdAt\":\"\",\"noQuestions\":\"   \",\"deleteConfirm\":\"  ?\",\"true\":\"\",\"false\":\"\"},\"examples\":{\"title\":\" \",\"description\":\"    \",\"groupByTopic\":\" \",\"addNew\":\"  \",\"addExample\":\" \",\"editExample\":\" \",\"selectVocabulary\":\" \",\"exampleTitle\":\" \",\"exampleContent\":\" \",\"translation\":\"\",\"context\":\"\",\"exampleType\":\" \",\"types\":{\"sentence\":\"\",\"dialogue\":\"\",\"phrase\":\"\",\"context\":\"\"},\"difficulty\":{\"medium\":\"\"},\"tags\":\"\",\"addTag\":\"   Enter\",\"searchVocabulary\":\" ...\",\"searchExamples\":\" ...\",\"filterByVocabulary\":\" \",\"filterByType\":\" \",\"allVocabulary\":\" \",\"allTypes\":\" \",\"createdAt\":\"\",\"noVocabulary\":\"   \",\"noVocabularyDescription\":\"     .\",\"noExamplesForWord\":\" \",\"noExamples\":\"   \",\"examples\":\"\",\"confirmDelete\":\"  ?\",\"deleteConfirm\":\"  ?\",\"playPronunciation\":\" \",\"playExample\":\" \",\"showExamples\":\" \",\"hideExamples\":\" \",\"showingVocabulary\":\"{total}   {start} {end} \",\"showingTopics\":\"{total}   {start} {end} \",\"showingExamples\":\"{start} {end}  ({total} )\",\"deleteSuccess\":\"  \"},\"image\":{\"title\":\"\",\"upload\":\"\",\"url\":\"URL\",\"imageUrl\":\" URL\",\"imageUrlPlaceholder\":\" URL  ()\",\"copyTab\":\"\",\"clickToUpload\":\" \",\"orDragDrop\":\"     \",\"supportedFormats\":\"PNG, JPG, GIF, WebP ( 5MB)\",\"urlPlaceholder\":\"  URL ...\",\"loadFromUrl\":\"URL \",\"loading\":\" ...\",\"preview\":\" \",\"change\":\"\",\"changeUrl\":\"URL \",\"remove\":\"\",\"fromUrl\":\"URL\",\"processing\":\" ...\",\"errors\":{\"unsupportedFormat\":\"   . PNG, JPG, GIF  WebP .\",\"fileTooLarge\":\"  . 5MB   .\",\"processingFailed\":\"   .  .\",\"emptyUrl\":\" URL .\",\"invalidUrl\":\"  URL  .\",\"urlLoadFailed\":\"URL    . URL  .\",\"corsWarning\":\"         .\"}},\"imageInfo\":{\"title\":\" \",\"none\":\"   \",\"date\":\"\",\"category\":\"\",\"missingCount\":\"  {count}\",\"aria\":\"   \"},\"save\":{\"title\":\"  \",\"subtitle\":\"   \",\"mode\":\" :\",\"auto\":\"\",\"manual\":\"\",\"saveNow\":\" \",\"chooseAutoFile\":\"   \",\"setup\":\"\",\"changeAutoFile\":\"   \",\"change\":\"\",\"importFromComputer\":\" \",\"importExport\":\"  \",\"importFromGoogleDrive\":\"  \",\"selectFromGoogleDrive\":\"  \",\"signInRequired\":\"   \",\"noJsonFiles\":\"JSON    \",\"selectFile\":\" \",\"loadingFiles\":\"  ...\",\"importConfirm\":\" \",\"importSuccess\":\" \",\"importShort\":\"\",\"lastSave\":\" : {time}\",\"notSaved\":\" \",\"autoSaveFileSetup\":\"    !\",\"autoSaveRetry\":\"      \",\"storageType\":\" :\",\"autoSaveConfiguration\":\"  \",\"localFile\":\" \",\"googleDrive\":\" \",\"googleSignIn\":\"\",\"googleSignOut\":\"\",\"googleSync\":\"\",\"googleDriveSetup\":\"   \",\"storageInformation\":\" \",\"type\":\"\",\"googleSignInSuccess\":\"  \",\"googleSignOutSuccess\":\"  \",\"syncFromDriveSuccess\":\"   \",\"googleDriveRetry\":\"   .  .\",\"account\":\"\",\"status\":{\"title\":\" \",\"saving\":\" ...\",\"autoSaving\":\"  ...\",\"autoWithFile\":\" ( )\",\"autoLocalStorage\":\" (localStorage)\",\"autoFile\":\" ()\",\"autoNoFile\":\" (  )\",\"autoGoogleDrive\":\"   \",\"googleDriveReady\":\"  \",\"googleDriveSignIn\":\"  \",\"fileSaved\":\" \",\"error\":\" \"},\"errors\":{\"browserNotSupported\":\"    . Chrome  Edge  .\",\"fileSelectError\":\"  : {error}\",\"invalidFile\":\" JSON   !\",\"invalidFormat\":\"  \",\"autoSaveFileFailed\":\"   .    .\",\"permissionDenied\":\"   .    .\",\"googleSignInFailed\":\"  \",\"googleSignOutFailed\":\"  \",\"googleDriveFailed\":\"   \",\"googleDriveSetupFailed\":\"   \",\"notSignedIn\":\"  \",\"syncFailed\":\" \",\"googleDriveImportFailed\":\"   \",\"fileReadError\":\"  : {error}\"},\"import\":{\"confirmMessage\":\" \\\"{filename}\\\" {count}  ?\\n\\n  !\",\"successMessage\":\"{count}   !\",\"confirmGoogleDriveMessage\":\"  \\\"{filename}\\\"() ?    .\",\"googleDriveSuccessMessage\":\"  {count}   \"}},\"validation\":{\"wordRequired\":\" \",\"wordTooShort\":\"  1  \",\"wordTooLong\":\" 100  \",\"meaningRequired\":\" \",\"meaningTooShort\":\"  1  \",\"meaningTooLong\":\" 500  \",\"partOfSpeechRequired\":\" \",\"categoryRequired\":\" \",\"levelRequired\":\" \",\"exampleTooLong\":\" 500  \",\"notesTooLong\":\" 500  \",\"pronunciationTooLong\":\" 100  \",\"synonymsInvalid\":\"    \",\"antonymsInvalid\":\"    \",\"saveError\":\"    .  .\",\"saveSuccess\":\"  !\",\"updateSuccess\":\"  !\"},\"details\":{\"title\":\" \",\"playAudio\":\"  \",\"playExample\":\"  \",\"addFavorite\":\" \",\"removeFavorite\":\" \"},\"moveMode\":{\"title\":\" \",\"active\":\" -    \",\"inactive\":\"\"},\"moveVocabulary\":\" \",\"movingWord\":\"  \",\"movingCategory\":\"    \",\"wordsWillBeMoved\":\"   \",\"selectTargetDate\":\"  \",\"moveToDateGroup\":\"   \",\"moveToDate\":\" \",\"moveWord\":\" \",\"moveAll\":\" \",\"moveSuccess\":\"{date} {count}   \",\"moveError\":\"  \",\"moveAutoSaveNotice\":\"    \",\"batchMoveSuccess\":\"{date} {count}   \",\"batchMoveError\":\"  \",\"filterBySameTopic\":\"  \",\"showingDatesWithSameTopic\":\"     \",\"selectTargetDateGroup\":\"   \",\"selectDate\":\" \",\"noMatchingDates\":\"      .   .\",\"topicManager\":{\"title\":\" \",\"addNewTopic\":\"  \",\"editTopic\":\" \",\"topicKey\":\" \",\"topicKeyPlaceholder\":\": cooking, programming...\",\"keyDescription\":\"   . , ,  .\",\"vietnameseName\":\" \",\"vietnameseNamePlaceholder\":\": Nu n, Lp trnh...\",\"englishName\":\" \",\"englishNamePlaceholder\":\": Cooking, Programming...\",\"existingTopics\":\" \",\"noCustomTopics\":\"   .\",\"cannotDeleteInUse\":\"     \",\"confirmDeleteTitle\":\"  \",\"confirmDeleteMessage\":\" \\\"{topic}\\\" ?\",\"duplicateKey\":\"   !\",\"builtInTopics\":\"  \",\"builtInTopicsDescription\":\" , ,   16    .       .\",\"builtIn\":\" \",\"manageTopics\":\" \",\"searchPlaceholder\":\"  ...\",\"pageOf\":\"{total}  {current} \",\"koreanName\":\" \",\"koreanNamePlaceholder\":\": , ...\"}}");
const flashcard = {"header":{"history":"","settings":"","progress":"","description":"  ","exit":"","selectMode":" "},"empty":{"title":" ","description":"   .","action":" "},"settings":{"title":" ","category":"","level":"","all":"","beginner":"","intermediate":"","advanced":"","autoFlip":"3    ","shuffle":" ","shuffle_disabled_during_practice":"   ","disabledDuringPractice":"   "},"history":{"title":" ","empty":{"title":" ","description":"   ."},"totalCards":"  ","correct":"","incorrect":"","duration":" ","categories":"","accuracy":"","result":"","pass":"","fail":"","viewDetails":" ","noDetails":"  ","deleteSession":" ","confirmDelete":{"title":" ","message":"   ?     .","confirm":"","cancel":"","success":"  "},"details":{"title":"  ","noData":"     ","yourAnswer":" ","noAnswer":" ","correctAnswer":""}},"completion":{"title":"!","description":"{count}  .","correct":"","incorrect":"","accuracy":"","result":""},"modes":{"flashcard":"","quiz":"","typing":"","listening":"","image":"","pictionary":"","flipTile":" ","bubbleShooter":" ","snakeGame":" ","pronunciation":"","change_disabled_during_practice":"    ","selectMode":" ","mode":""},"image":{"imageAlt":" ","imageError":"   ","noImage":"   ","placeholder":" ...","instruction":"    :","instructionQuiz":"    :","correctAnswer":"","unavailable":"      ","quizToggle":""},"pictionary":{"imageAlt":" ","instruction":"     . Enter  .","instructionDefinition":"   . Enter  .","dragInstructionDefinition":"     .","definitionToggle":" ","definitionHint":"","noDefinition":" ","unavailable":"      "},"flipTile":{"tilesFlipped":" ","imageAlt":"  ","noDefinition":"   ","noContent":"      .","answerPlaceholder":" ...","check":"","instruction":"   ( {maxFlips}),    Enter .","unavailable":"        ","hintsToggle":"  "},"scrambleWords":{"toggle":" ","instruction":"   ","correct":"!","incorrect":" !","backspace":"","clear":"","check":""},"card":{"flip_to_meaning":"  ","flip_back":" "},"bubbleShooter":{"title":" ","instruction":"  4   !","score":"","currentWord":" ","gameComplete":" !","finalScore":" : {score}","wordsMatched":" : {count}","playAgain":" ","unavailable":"8        ","vietnameseModeToggle":"   "},"snakeGame":{"title":" ","instruction":"      !","score":"","currentWord":" ","target":"","controls":"","arrowKeys":"  / WASD","clickToStart":" START ","completed":"","start":" ","up":"","down":"","left":"","right":"","gameComplete":" !","finalScore":" : {score}","wordsHunted":" : {count}","playAgain":" ","gameOver":" !"},"snake":{"doubleBaitToggle":"  "},"listening":{"instruction":"   :","instructionQuiz":"  :","placeholder":"  ...","correct":" !","incorrect":" :","quizToggle":""},"typing":{"instruction":"   :","instructionQuiz":"   :","placeholder":" ...","correctAnswer":":","correct":" !","incorrect":" :","quizToggle":""},"pronunciation":{"instruction":"    :","listen":"","ready":"","recording":" ...","recorded":" ","processing":" ...","analyze":"","feedback":"","tips":"","tryAgain":" !","yourRecording":" ","microphoneError":" !    .","wordsCrushToggle":"  ","wordsCrush":{"title":"Words Crush:  ","instruction":"    ","playAudio":" ","checkAnswer":" ","hint":"","reset":"","correct":" !","tryAgain":" !","correctWord":" ","meaning":""}},"dateFilter":{"enable":"  ","allDates":" ","info":"{date}  {count} "}};
const grammar = {"title":"","description":"   ","addLesson":" ","addNewLesson":"  ","editLesson":" ","deleteLesson":" ","confirmDelete":" \"{title}\"() ?","search":"  ...","level":"","category":"","duration":"","durationLabel":" ()","progress":"","continue":"","start":"","emptyState":{"title":"   ","description":"     ."},"levels":{"beginner":"","intermediate":"","advanced":""},"manager":{"title":" ","manageGrammar":" ","addNew":"   ","editGrammar":"  ","existingRules":" ","category":"","level":"","formula":" ","description":"","examples":"","titlePlaceholder":":  ","formulaPlaceholder":":  + have/has + ","descriptionPlaceholder":"      ...","examplePlaceholder":": I have studied English for 5 years.","selectCategory":" ","selectLevel":" ","addExample":" ","removeExample":" ","noRulesYet":"    ","createdAt":"","lastModified":" ","confirmDelete":"   ?","ruleAdded":"   ","ruleUpdated":"   ","ruleDeleted":"   ","globalMode":"","perDateMode":"","perDateDescription":" {date}   ","noDateSelected":"    ","showVocabulary":" ","vocabularyForDate":"{date} ","noVocabularyFound":"   "},"categories":{"tenses":"","conditionals":"","passive":"","modals":"","articles":"","prepositions":"","conjunctions":"","other":""},"selectCategory":" ","selectLevel":" ","titlePlaceholder":"  ...","descriptionPlaceholder":"    ...","lessonContent":" ","theory":"","theoryPlaceholder":"   ...","structure":"","structurePlaceholder":"  ...","examples":"","examplePlaceholder":" {index}","translationPlaceholder":" {index}","addExample":" ","usageRules":" ","ruleTitlePlaceholder":"  {index}","ruleDescriptionPlaceholder":"  {index}","addRule":" ","commonMistakes":" ","wrongSentencePlaceholder":"  {index}","correctSentencePlaceholder":"  {index}","explanationPlaceholder":" {index}","addMistake":"  ","markdownSupported":" Markdown  .","practice":{"title":" ","subtitle":"   ","chooseExercise":"  ","chooseDescription":"    ","score":"","question":"","checkAnswer":" ","next":"","finish":"","explanation":"","reading":{"passage":"","readingTime":" ","questions":"","showHighlights":" "},"exercises":{"checkAnswer":" ","next":"","multiple-choice":{"title":"","description":"    "},"fill-blank":{"title":" ","description":"   "},"pronunciation":{"title":"","description":"  "},"reading":{"title":"","description":"   ","passage":"","listen":"","readingTime":" ","questions":"","true":"","false":"","yourAnswer":" ","correctAnswer":"","correct":"","incorrect":"","accuracy":"","showHighlights":" ","hideHighlights":" "},"listening":{"title":"","description":"   ","instruction":"   :","speed":"","playsLeft":"  ","loading":" ...","questions":"","audioUrl":" URL","audioUrlPlaceholder":"  URL  YouTube URL ...","maxPlays":"  ","allowNotes":" ","transcript":"","transcriptPlaceholder":"  ...","question":"","multipleChoice":"","fillBlank":" ","ordering":" ","addQuestion":" ","correctAnswerPlaceholder":" ...","notesAllowed":" ","takeNotes":"","notesPlaceholder":"  ...","correct":"","incorrect":"","accuracy":"","showTranscript":" ","correctAnswer":"","audioUrlHint":"  URL  YouTube  URL ","youtubeDetected":"YouTube URL ","youtubeNote":" YouTube      "},"writing":{"title":"","description":"   ","instruction":"    :","essay":"","email":"","letter":"","paragraph":"","requirements":" ","minWords":"  ","timeLimit":" ","yourResponse":" ","words":"","timeRemaining":" ","paragraphPlaceholder":"  ...","essayPlaceholder":"  ...","emailPlaceholder":"  ...","letterPlaceholder":"  ...","tips":" ","showTips":" ","hideTips":" ","tip1":"   ","tip2":"  ","tip3":"   ","tip4":", ,   ","tip5":"   ","saveDraft":" ","clear":"","confirmClear":"  ?","submit":"","analyzing":" ...","feedback":"","overallScore":" ","grammar":"","vocabulary":"","coherence":"","taskResponse":" ","strengths":"","improvements":"  ","corrections":"  ","original":"","corrected":"","explanation":""}},"fillBlank":{"instruction":"   :","clear":" "},"pronunciation":{"instruction":"    :","listen":"","ready":"","recording":" ...","recorded":" ","processing":" ...","analyze":"","feedback":"","tips":"","tryAgain":" ","yourRecording":" ","microphoneError":" !    ."},"settings":{"title":" ","difficulty":"","autoPlay":"  ","autoplayAudio":"  ","showExplanations":" ","timeLimit":"  ()","questionCount":" ","close":"","save":" ","levels":{"easy":"","medium":"","hard":""}},"exerciseManager":{"title":" ","addNew":"  ","existing":" ","exerciseType":" ","typePlaceholder":"  ...","titlePlaceholder":"  ...","description":"","descriptionPlaceholder":"  ...","difficulty":"","duration":" ","durationPlaceholder":": 10-15","add":" ","manageQuestions":" "},"questionManager":{"title":" ","addNew":"  ","editQuestion":" ","addQuestion":" ","existingQuestions":" ","noQuestions":"  ","addFirstQuestion":"   ","question":"","questionPlaceholder":" ...","options":"","optionPlaceholder":" ...","correctAnswer":"","explanation":"","explanationPlaceholder":" ...","taskType":" ","prompt":"","promptPlaceholder":"  ...","requirements":" ","addRequirement":"  ","requirementPlaceholder":"  ...","minWords":"  ","timeLimit":"  ()","selectCorrectAnswer":" "},"progress":{"question":"","of":"/","score":"","timeRemaining":" "},"results":{"title":" ","score":" ","correct":"","total":"","accuracy":"","timeSpent":" ","tryAgain":" ","backToMenu":" ","reviewAnswers":" "},"common":{"submit":"","next":"","previous":"","finish":"","check":" ","checkAnswer":" ","showAnswer":" ","explanation":"","hint":"","loading":" ...","noAnswer":"  ","correct":"!","incorrect":"","skip":"","retry":" "}}};
const categories = {"technology":"","business":"","travel":"","food":"","health":"","education":"","sports":"","entertainment":"","science":"","art":"","music":"","literature":"","politics":"","environment":"","fashion":"","finance":""};
const dashboard = {"title":"","description":"   ","welcomeMessage":"     !","todaysProgress":" ","currentLevel":" ","quickActions":" ","recentActivity":" ","stats":{"vocabularyLearned":" ","grammarLessons":" ","currentStreak":"  ","totalTime":" ","days":"","hours":""},"flashcardStats":{"title":" ","noData":"   ","startPracticing":"   !","sessions":"","streak":" ","days":"","accuracy":"","bestScore":" ","totalTime":"  ","cardsStudied":" ","favoriteMode":" ","weeklyProgress":" "},"actions":{"addVocabulary":" ","practiceFlashcard":" ","takeQuiz":" ","learnGrammar":" "},"activity":{"added":"'{word}'() {category} ","updated":"{category} '{word}'() ","justNow":"","noActivity":"  ","addFirstVocab":"    !"}};
const app$1 = {"title":"  ","titleShort":" "};
const time = {"today":"","yesterday":"","ago":{"justNow":" ","minutesAgo":"{minutes} ","hoursAgo":"{hours} ","daysAgo":"{days} ","yesterday":""}};
const practice = {"controls":{"next":"","complete":"","difficult":"","easy":"","exit":""},"timer":{"startPractice":" ","timeLimit":"  : {seconds}","timeUp":" !","timeUpMessage":"    .   .","tryAgain":" ","skip":""},"exitWarning":{"title":"  ","message":"   .       .  ?","continue":" ","exit":" "}};
const quiz = {"progress":{"question":""},"setup":{"title":" ","description":"   ","type":" ","level":"","questionCount":" ","timeLimit":"  ()","start":" ","allLevels":" ","unlimited":""},"types":{"vocabulary":"","grammar":"","mixed":""},"navigation":{"previous":"","next":"","finish":""},"results":{"completed":" !","yourResults":" ","score":"","correct":"","accuracy":"","passed":"","failed":"","above":"","below":"","reviewAnswers":" ","correctAnswer":"","yourAnswer":" ","noAnswer":" ","explanation":"","restartQuiz":"  "}};
const korean = {"inputHelper":{"title":"  ","preview":"","placeholder":"   ...","consonants":"","vowels":"","commonSyllables":"  ","openHelper":"   "},"pronunciationHelper":{"title":"  ","preview":" ","placeholder":"   ...","consonantSounds":" ","vowelSounds":" ","commonPatterns":"  ","specialChars":" ","openHelper":"   "},"wordPlaceholder":"   +  ","pronunciationPlaceholder":"----"};
const voice = {"selector":{"title":" "},"gender":{"female":"","male":""},"types":{"female_sweet":" ","female_clear":" ","female_professional":" ","male_strong":" ","male_gentle":" ","male_deep":" ","korean_female":" ","korean_male":" "},"info":{"name":" ","language":"","gender":""},"test":" ","testing":" ...","testText":"!   .","testTextKorean":"!   .  ?","settings":{"title":" ","rate":"","pitch":"","volume":""}};
const ko = {
  common,
  autoGenerator,
  vocabulary,
  flashcard,
  grammar,
  categories,
  dashboard,
  app: app$1,
  time,
  practice,
  quiz,
  korean,
  voice,
};

function getInitialLocale() {
  try {
    const savedLocale = localStorage.getItem("locale");
    return savedLocale === "en" || savedLocale === "vi" || savedLocale === "ko" ? savedLocale : "vi";
  } catch (error) {
    console.warn("localStorage not available, using default locale:", error);
    return "vi";
  }
}
const i18n = createI18n({
  legacy: false,
  locale: getInitialLocale(),
  fallbackLocale: "en",
  globalInjection: true,
  missingWarn: false,
  fallbackWarn: false,
  silentTranslationWarn: true,
  silentFallbackWarn: true,
  messages: {
    en,
    vi,
    ko
  }
});
function setLocale(locale) {
  if (typeof i18n.global.locale === "object" && "value" in i18n.global.locale) {
    i18n.global.locale.value = locale;
  } else {
    i18n.global.locale = locale;
  }
  try {
    localStorage.setItem("locale", locale);
  } catch (error) {
    console.warn("Could not save locale to localStorage:", error);
  }
  document.querySelector("html")?.setAttribute("lang", locale);
}
function getLocale() {
  const locale = typeof i18n.global.locale === "object" && "value" in i18n.global.locale ? i18n.global.locale.value : i18n.global.locale;
  return locale;
}
function toggleLocale() {
  const currentLocale = getLocale();
  const order = ["en", "vi", "ko"];
  const idx = order.indexOf(currentLocale);
  const newLocale = order[(idx + 1) % order.length];
  setLocale(newLocale);
  return newLocale;
}

const app = createApp(_sfc_main$1t);
const pinia = createPinia();
app.use(pinia);
app.use(router);
app.use(i18n);
const options = {
  transition: "Vue-Toastification__bounce",
  maxToasts: 5,
  newestOnTop: true,
  filterBeforeCreate: (toast, toasts) => {
    if (toasts.filter((t) => t.content === toast.content).length !== 0) {
      return false;
    }
    return toast;
  },
  bodyClassName: ["font-sans", "text-sm"],
  toastClassName: ["custom-toast"],
  closeButtonClassName: "dark:text-white dark:hover:text-gray-200"
};
app.use(src_default, options);
const themeStore = useThemeStore();
themeStore.initTheme();
app.mount("#app");

const _imports_0 = "/web-english/assets/logo.svg";

const _hoisted_1$1f = { class: "w-full px-4 sm:px-6 lg:px-8 overflow-visible" };
const _hoisted_2$1c = { class: "flex items-center justify-between h-16 overflow-visible" };
const _hoisted_3$1a = { class: "flex items-center space-x-2 sm:space-x-4" };
const _hoisted_4$16 = ["title"];
const _hoisted_5$13 = ["title", "onKeydown"];
const _hoisted_6$10 = ["aria-label"];
const _hoisted_7$Z = ["aria-label"];
const _hoisted_8$Y = { class: "hidden xl:flex items-center space-x-4 overflow-visible" };
const _hoisted_9$X = { class: "flex space-x-1 relative overflow-visible" };
const _hoisted_10$W = { class: "relative group overflow-visible" };
const _hoisted_11$W = { class: "absolute top-full left-0 w-56 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 ease-out transform translate-y-2 group-hover:translate-y-0 z-[9999] pointer-events-none group-hover:pointer-events-auto pt-1" };
const _hoisted_12$U = { class: "bg-white dark:bg-[#0a0a0a] border border-gray-200 dark:border-dark-bg-mute rounded-lg shadow-lg dark:shadow-black/20 py-2" };
const _hoisted_13$U = { class: "flex items-center space-x-2" };
const _hoisted_14$T = { class: "flex items-center space-x-2" };
const _hoisted_15$N = { class: "flex items-center space-x-2" };
const _hoisted_16$M = { class: "flex items-center space-x-2" };
const _hoisted_17$L = { class: "xl:hidden flex items-center space-x-2" };
const _hoisted_18$J = ["aria-expanded"];
const _hoisted_19$J = {
  key: 0,
  class: "h-6 w-6",
  fill: "none",
  viewBox: "0 0 24 24",
  stroke: "currentColor"
};
const _hoisted_20$I = {
  key: 1,
  class: "h-6 w-6",
  fill: "none",
  viewBox: "0 0 24 24",
  stroke: "currentColor"
};
const _hoisted_21$I = { class: "px-2 pt-2 pb-3 space-y-1" };
const _hoisted_22$G = { class: "space-y-1" };
const _hoisted_23$G = ["aria-expanded", "onKeydown"];
const _hoisted_24$E = { class: "ml-4 space-y-1" };
const _hoisted_25$E = { class: "flex items-center space-x-2" };
const _hoisted_26$C = { class: "flex items-center space-x-2" };
const _hoisted_27$B = { class: "flex items-center space-x-2" };
const _hoisted_28$z = { class: "flex items-center space-x-2" };
const _hoisted_29$x = { class: "absolute bottom-0 left-0 right-0 h-1 bg-gray-200/20 dark:bg-white/10" };
const appearStepMs = 120;
const hideStepMs = 80;
const cyclePauseMs = 1200;
const _sfc_main$1g = /* @__PURE__ */ defineComponent({
  __name: "AppHeader",
  setup(__props) {
    const ThemeToggle = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => ThemeToggle$1),true              ?void 0:void 0))
    );
    const LanguageSwitcher$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => LanguageSwitcher),true              ?void 0:void 0))
    );
    const { t } = useI18n();
    const route = useRoute();
    const router = useRouter();
    const isMobileMenuOpen = ref(false);
    const isScrolled = ref(false);
    const scrollProgress = ref(0);
    const isSmallScreen = ref(false);
    const isHiding = ref(false);
    const animationCycleKey = ref(0);
    let cycleTimer = null;
    const scrollProgressPercentage = ref(0);
    let hasAnimated = false;
    let lastScrollY = 0;
    const enhancedScroll = () => {
      const scrollY = window.scrollY;
      const header = document.querySelector("header");
      if (!header) return;
      const documentHeight = document.documentElement.scrollHeight - window.innerHeight;
      scrollProgressPercentage.value = documentHeight > 0 ? Math.min(scrollY / documentHeight * 100, 100) : 0;
      if (scrollY === 0) {
        isScrolled.value = false;
        header.style.transform = "translateY(0)";
        header.style.opacity = "1";
        header.style.boxShadow = "none";
        hasAnimated = false;
        lastScrollY = 0;
        return;
      }
      const scrollingDown = scrollY > lastScrollY;
      if (scrollingDown && !hasAnimated && scrollY > 50) {
        hasAnimated = true;
        isScrolled.value = true;
        header.style.transform = "translateY(-64px)";
        header.style.opacity = "0.8";
        window.setTimeout(() => {
          header.style.transform = "translateY(0)";
          header.style.opacity = "1";
        }, 170);
        const progress = Math.min(scrollY / 100, 1);
        const shadowIntensity = Math.min(progress * 0.3, 0.2);
        header.style.boxShadow = `0 ${4 + progress * 8}px ${8 + progress * 16}px rgba(0, 0, 0, ${shadowIntensity})`;
      }
      lastScrollY = scrollY;
    };
    onMounted(() => {
      window.addEventListener("scroll", enhancedScroll, { passive: true });
      enhancedScroll();
      const media = window.matchMedia("(max-width: 639px)");
      const updateScreen = (e) => {
        isSmallScreen.value = e ? e.matches : media.matches;
      };
      updateScreen(media);
      if (typeof media.addEventListener === "function") {
        media.addEventListener("change", updateScreen);
      } else if (typeof media.addListener === "function") {
        media.addListener(updateScreen);
      }
      window.__headerMedia__ = { media, updateScreen };
      const runCycle = () => {
        isHiding.value = false;
        const wordsCount = isSmallScreen.value ? titleShortChars.value.length : titleFullChars.value.length;
        const appearDuration = appearStepMs * wordsCount + cyclePauseMs;
        cycleTimer = window.setTimeout(() => {
          isHiding.value = true;
          const hideDuration = hideStepMs * wordsCount + cyclePauseMs;
          cycleTimer = window.setTimeout(() => {
            animationCycleKey.value++;
            runCycle();
          }, hideDuration);
        }, appearDuration);
      };
      runCycle();
      window.__headerCycle__ = () => {
        if (cycleTimer) window.clearTimeout(cycleTimer);
      };
    });
    onUnmounted(() => {
      window.removeEventListener("scroll", enhancedScroll);
      const refObj = window.__headerMedia__;
      if (refObj && refObj.media) {
        const { media, updateScreen } = refObj;
        if (typeof media.removeEventListener === "function") {
          media.removeEventListener("change", updateScreen);
        } else if (typeof media.removeListener === "function") {
          media.removeListener(updateScreen);
        }
        delete window.__headerMedia__;
      }
      const stopCycle = window.__headerCycle__;
      if (typeof stopCycle === "function") {
        stopCycle();
        delete window.__headerCycle__;
      }
    });
    const toggleMobileMenu = () => {
      isMobileMenuOpen.value = !isMobileMenuOpen.value;
    };
    const closeMobileMenu = () => {
      isMobileMenuOpen.value = false;
    };
    const isMobileVocabOpen = ref(false);
    const toggleMobileVocabSubmenu = () => {
      isMobileVocabOpen.value = !isMobileVocabOpen.value;
    };
    watch(isMobileMenuOpen, (open) => {
      if (open) {
        isMobileVocabOpen.value = false;
      }
    });
    const handleLogoClick = async () => {
      try {
        if (route.path === "/dashboard") {
          window.scrollTo({ top: 0, behavior: "smooth" });
        } else {
          if (isMobileMenuOpen.value) closeMobileMenu();
          await router.push("/dashboard");
          window.scrollTo({ top: 0, behavior: "smooth" });
        }
      } catch (e) {
      }
    };
    const fullTitle = computed(() => t("app.title", "English Learning App"));
    const shortTitle = computed(() => t("app.titleShort", "English App"));
    const titleFullChars = computed(() => Array.from(fullTitle.value));
    const titleShortChars = computed(() => Array.from(shortTitle.value));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("header", {
        class: normalizeClass([
          "backdrop-blur-md fixed top-0 left-0 right-0 z-50 transition-all duration-500 ease-out",
          isScrolled.value ? "bg-white/95 dark:bg-black/95 shadow-xl shadow-black/10 dark:shadow-white/10 border-b border-gray-200/10 dark:border-gray-700/10" : "bg-transparent shadow-none border-transparent"
        ]),
        style: normalizeStyle({
          position: "fixed",
          top: 0,
          left: "0px",
          right: "0px",
          width: "100vw",
          maxWidth: "100vw",
          minWidth: "100vw",
          opacity: Math.max(0.9, 1 - scrollProgress.value * 0.1),
          backdropFilter: isScrolled.value ? "blur(12px) saturate(180%)" : "blur(0px)",
          WebkitBackdropFilter: isScrolled.value ? "blur(12px) saturate(180%)" : "blur(0px)",
          margin: 0,
          padding: 0,
          boxSizing: "border-box",
          overflow: "visible"
        })
      }, [
        createBaseVNode("div", _hoisted_1$1f, [
          createBaseVNode("div", _hoisted_2$1c, [
            createBaseVNode("div", _hoisted_3$1a, [
              createBaseVNode("img", {
                alt: "Vue logo",
                src: _imports_0,
                class: "header-logo h-6 w-6 sm:h-8 sm:w-8 cursor-pointer select-none",
                onClick: handleLogoClick,
                title: unref(t)("common.dashboard", "Dashboard")
              }, null, 8, _hoisted_4$16),
              createBaseVNode("h1", {
                class: "text-lg sm:text-xl font-bold text-gray-900 dark:text-white truncate cursor-pointer",
                onClick: handleLogoClick,
                title: unref(t)("common.dashboard", "Dashboard"),
                role: "button",
                tabindex: "0",
                onKeydown: [
                  withKeys(withModifiers(handleLogoClick, ["prevent"]), ["enter"]),
                  withKeys(withModifiers(handleLogoClick, ["prevent"]), ["space"])
                ]
              }, [
                !isSmallScreen.value ? (openBlock(), createElementBlock("span", {
                  class: "logo-words",
                  "aria-label": fullTitle.value,
                  key: `full-${animationCycleKey.value}`
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(titleFullChars.value, (char, index) => {
                    return openBlock(), createElementBlock(Fragment, null, [
                      char === " " ? (openBlock(), createElementBlock("span", {
                        key: `full-${index}-space`,
                        class: normalizeClass(["logo-char", "logo-space", isHiding.value ? "logo-char-hide" : ""]),
                        style: normalizeStyle({ animationDelay: `${index * (isHiding.value ? hideStepMs : appearStepMs)}ms` })
                      }, "", 6)) : (openBlock(), createElementBlock("span", {
                        key: `full-${index}-${char}`,
                        class: normalizeClass(["logo-char", isHiding.value ? "logo-char-hide" : ""]),
                        style: normalizeStyle({ animationDelay: `${index * (isHiding.value ? hideStepMs : appearStepMs)}ms` })
                      }, toDisplayString$1(char), 7))
                    ], 64);
                  }), 256))
                ], 8, _hoisted_6$10)) : (openBlock(), createElementBlock("span", {
                  class: "logo-words",
                  "aria-label": shortTitle.value,
                  key: `short-${animationCycleKey.value}`
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(titleShortChars.value, (char, index) => {
                    return openBlock(), createElementBlock(Fragment, null, [
                      char === " " ? (openBlock(), createElementBlock("span", {
                        key: `short-${index}-space`,
                        class: normalizeClass(["logo-char", "logo-space", isHiding.value ? "logo-char-hide" : ""]),
                        style: normalizeStyle({ animationDelay: `${index * (isHiding.value ? hideStepMs : appearStepMs)}ms` })
                      }, "", 6)) : (openBlock(), createElementBlock("span", {
                        key: `short-${index}-${char}`,
                        class: normalizeClass(["logo-char", isHiding.value ? "logo-char-hide" : ""]),
                        style: normalizeStyle({ animationDelay: `${index * (isHiding.value ? hideStepMs : appearStepMs)}ms` })
                      }, toDisplayString$1(char), 7))
                    ], 64);
                  }), 256))
                ], 8, _hoisted_7$Z))
              ], 40, _hoisted_5$13)
            ]),
            createBaseVNode("div", _hoisted_8$Y, [
              createBaseVNode("nav", _hoisted_9$X, [
                createVNode(unref(RouterLink), {
                  to: "/dashboard",
                  class: normalizeClass([
                    "text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-all duration-200 ease-out hover:bg-gray-50 dark:hover:bg-dark-bg-mute focus:outline-none",
                    unref(route).path === "/dashboard" ? "bg-gray-300 dark:bg-dark-bg-mute text-black dark:text-white font-bold" : ""
                  ])
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString$1(unref(t)("common.dashboard", "Dashboard")), 1)
                  ]),
                  _: 1
                }, 8, ["class"]),
                createBaseVNode("div", _hoisted_10$W, [
                  createBaseVNode("div", {
                    class: normalizeClass([
                      "text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-all duration-200 ease-out hover:bg-gray-50 dark:hover:bg-dark-bg-mute focus:outline-none flex items-center space-x-1 select-none cursor-default",
                      unref(route).path.startsWith("/vocabulary") ? "bg-gray-300 dark:bg-dark-bg-mute text-black dark:text-white font-bold" : ""
                    ]),
                    "aria-haspopup": "true",
                    "aria-expanded": "false"
                  }, [
                    createBaseVNode("span", null, toDisplayString$1(unref(t)("common.vocabulary", "Vocabulary")), 1),
                    _cache[0] || (_cache[0] = createBaseVNode("svg", {
                      class: "w-4 h-4 transition-transform duration-200 group-hover:rotate-180",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z",
                        "clip-rule": "evenodd"
                      })
                    ], -1))
                  ], 2),
                  createBaseVNode("div", _hoisted_11$W, [
                    createBaseVNode("div", _hoisted_12$U, [
                      createVNode(unref(RouterLink), {
                        to: "/vocabulary",
                        class: normalizeClass([
                          "block px-4 py-2 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-50 dark:hover:bg-dark-bg-mute transition-colors duration-150",
                          unref(route).path === "/vocabulary" ? "bg-gray-100 dark:bg-gray-custom text-black dark:text-white font-medium" : ""
                        ])
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_13$U, [
                            _cache[1] || (_cache[1] = createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", { d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" })
                            ], -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.manageWords", "Manage Words")), 1)
                          ])
                        ]),
                        _: 1
                      }, 8, ["class"]),
                      createVNode(unref(RouterLink), {
                        to: "/vocabulary/questions",
                        class: normalizeClass([
                          "block px-4 py-2 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-50 dark:hover:bg-dark-bg-mute transition-colors duration-150",
                          unref(route).path === "/vocabulary/questions" ? "bg-gray-100 dark:bg-gray-custom text-black dark:text-white font-medium" : ""
                        ])
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_14$T, [
                            _cache[2] || (_cache[2] = createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", {
                                "fill-rule": "evenodd",
                                d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z",
                                "clip-rule": "evenodd"
                              })
                            ], -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.manageQuestions", "Manage Questions")), 1)
                          ])
                        ]),
                        _: 1
                      }, 8, ["class"]),
                      createVNode(unref(RouterLink), {
                        to: "/vocabulary/examples",
                        class: normalizeClass([
                          "block px-4 py-2 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-50 dark:hover:bg-dark-bg-mute transition-colors duration-150",
                          unref(route).path === "/vocabulary/examples" ? "bg-gray-100 dark:bg-gray-custom text-black dark:text-white font-medium" : ""
                        ])
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_15$N, [
                            _cache[3] || (_cache[3] = createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", {
                                "fill-rule": "evenodd",
                                d: "M4 4a2 2 0 012-2h8a2 2 0 012 2v12a1 1 0 110 2h-3a1 1 0 01-1-1v-2a1 1 0 00-1-1H9a1 1 0 00-1 1v2a1 1 0 01-1 1H4a1 1 0 110-2V4zm3 1h2v2H7V5zm2 4H7v2h2V9zm2-4h2v2h-2V5zm2 4h-2v2h2V9z",
                                "clip-rule": "evenodd"
                              })
                            ], -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.manageExamples", "Manage Examples")), 1)
                          ])
                        ]),
                        _: 1
                      }, 8, ["class"]),
                      _cache[5] || (_cache[5] = createBaseVNode("div", { class: "border-t border-gray-200 dark:border-dark-bg-mute my-1" }, null, -1)),
                      createVNode(unref(RouterLink), {
                        to: "/vocabulary/generator",
                        class: normalizeClass([
                          "block px-4 py-2 text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-50 dark:hover:bg-dark-bg-mute transition-colors duration-150",
                          unref(route).path === "/vocabulary/generator" ? "bg-gray-100 dark:bg-gray-custom text-black dark:text-white font-medium" : ""
                        ])
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_16$M, [
                            _cache[4] || (_cache[4] = createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", {
                                "fill-rule": "evenodd",
                                d: "M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z",
                                "clip-rule": "evenodd"
                              })
                            ], -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.autoGenerator", "Auto Generator")), 1)
                          ])
                        ]),
                        _: 1
                      }, 8, ["class"])
                    ])
                  ])
                ]),
                createVNode(unref(RouterLink), {
                  to: "/grammar",
                  class: normalizeClass([
                    "text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-all duration-200 ease-out hover:bg-gray-50 dark:hover:bg-dark-bg-mute focus:outline-none",
                    unref(route).path === "/grammar" ? "bg-gray-300 dark:bg-dark-bg-mute text-black dark:text-white font-bold" : ""
                  ])
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString$1(unref(t)("common.grammar", "Grammar")), 1)
                  ]),
                  _: 1
                }, 8, ["class"]),
                createVNode(unref(RouterLink), {
                  to: "/practice/flashcard",
                  class: normalizeClass([
                    "text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors focus:outline-none",
                    unref(route).path === "/practice/flashcard" ? "bg-gray-300 dark:bg-dark-bg-mute text-black dark:text-white font-bold" : ""
                  ])
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString$1(unref(t)("common.practice", "Practice")), 1)
                  ]),
                  _: 1
                }, 8, ["class"])
              ]),
              createVNode(unref(LanguageSwitcher$1)),
              createVNode(unref(ThemeToggle))
            ]),
            createBaseVNode("div", _hoisted_17$L, [
              createVNode(unref(LanguageSwitcher$1)),
              createVNode(unref(ThemeToggle)),
              createBaseVNode("button", {
                onClick: toggleMobileMenu,
                class: "inline-flex items-center justify-center p-2 rounded-md text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-blue-500 transition-all duration-200 ease-out transform hover:scale-105 active:scale-95",
                "aria-expanded": isMobileMenuOpen.value,
                "aria-label": "Toggle navigation menu"
              }, [
                !isMobileMenuOpen.value ? (openBlock(), createElementBlock("svg", _hoisted_19$J, _cache[6] || (_cache[6] = [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M4 6h16M4 12h16M4 18h16"
                  }, null, -1)
                ]))) : (openBlock(), createElementBlock("svg", _hoisted_20$I, _cache[7] || (_cache[7] = [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M6 18L18 6M6 6l12 12"
                  }, null, -1)
                ])))
              ], 8, _hoisted_18$J)
            ])
          ]),
          withDirectives(createBaseVNode("div", {
            class: normalizeClass(["xl:hidden border-t border-gray-200 dark:border-gray-700 bg-white dark:bg-black transition-all duration-300 ease-out transform", isMobileMenuOpen.value ? "opacity-100 translate-y-0" : "opacity-0 -translate-y-2 pointer-events-none"])
          }, [
            createBaseVNode("nav", _hoisted_21$I, [
              createVNode(unref(RouterLink), {
                to: "/dashboard",
                onClick: closeMobileMenu,
                class: normalizeClass([
                  "block px-3 py-2 rounded-md text-base font-medium text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-gray-800 transition-all duration-200 ease-out transform hover:translate-x-1 hover:scale-105 focus:outline-none",
                  unref(route).path === "/dashboard" ? "bg-gray-300 dark:bg-gray-700 text-black dark:text-white font-bold" : ""
                ])
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(unref(t)("common.dashboard", "Dashboard")), 1)
                ]),
                _: 1
              }, 8, ["class"]),
              createBaseVNode("div", _hoisted_22$G, [
                createBaseVNode("div", {
                  class: normalizeClass([
                    "px-3 py-2 rounded-md text-base font-medium text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors focus:outline-none select-none flex items-center justify-between",
                    unref(route).path.startsWith("/vocabulary") ? "bg-gray-300 dark:bg-dark-bg-mute text-black dark:text-white font-bold" : ""
                  ]),
                  "aria-haspopup": "true",
                  "aria-expanded": isMobileVocabOpen.value,
                  role: "button",
                  tabindex: "0",
                  onClick: toggleMobileVocabSubmenu,
                  onKeydown: [
                    withKeys(withModifiers(toggleMobileVocabSubmenu, ["prevent"]), ["enter"]),
                    withKeys(withModifiers(toggleMobileVocabSubmenu, ["prevent"]), ["space"])
                  ]
                }, [
                  createBaseVNode("span", null, toDisplayString$1(unref(t)("common.vocabulary", "Vocabulary")), 1),
                  (openBlock(), createElementBlock("svg", {
                    class: normalizeClass(["w-4 h-4 ml-2 transform transition-transform duration-200", isMobileVocabOpen.value ? "rotate-180" : "rotate-0"]),
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, _cache[8] || (_cache[8] = [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z",
                      "clip-rule": "evenodd"
                    }, null, -1)
                  ]), 2))
                ], 42, _hoisted_23$G),
                withDirectives(createBaseVNode("div", _hoisted_24$E, [
                  createVNode(unref(RouterLink), {
                    to: "/vocabulary",
                    onClick: closeMobileMenu,
                    class: "block px-3 py-2 rounded-md text-sm text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors focus:outline-none"
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", _hoisted_25$E, [
                        _cache[9] || (_cache[9] = createBaseVNode("svg", {
                          class: "w-3 h-3",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", { d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" })
                        ], -1)),
                        createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.manageWords", "Manage Words")), 1)
                      ])
                    ]),
                    _: 1
                  }),
                  createVNode(unref(RouterLink), {
                    to: "/vocabulary/questions",
                    onClick: closeMobileMenu,
                    class: "block px-3 py-2 rounded-md text-sm text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors focus:outline-none"
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", _hoisted_26$C, [
                        _cache[10] || (_cache[10] = createBaseVNode("svg", {
                          class: "w-3 h-3",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z",
                            "clip-rule": "evenodd"
                          })
                        ], -1)),
                        createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.manageQuestions", "Manage Questions")), 1)
                      ])
                    ]),
                    _: 1
                  }),
                  createVNode(unref(RouterLink), {
                    to: "/vocabulary/examples",
                    onClick: closeMobileMenu,
                    class: "block px-3 py-2 rounded-md text-sm text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors focus:outline-none"
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", _hoisted_27$B, [
                        _cache[11] || (_cache[11] = createBaseVNode("svg", {
                          class: "w-3 h-3",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M4 4a2 2 0 012-2h8a2 2 0 012 2v12a1 1 0 110 2h-3a1 1 0 01-1-1v-2a1 1 0 00-1-1H9a1 1 0 00-1 1v2a1 1 0 01-1 1H4a1 1 0 110-2V4zm3 1h2v2H7V5zm2 4H7v2h2V9zm2-4h2v2h-2V5zm2 4h-2v2h2V9z",
                            "clip-rule": "evenodd"
                          })
                        ], -1)),
                        createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.manageExamples", "Manage Examples")), 1)
                      ])
                    ]),
                    _: 1
                  }),
                  createVNode(unref(RouterLink), {
                    to: "/vocabulary/generator",
                    onClick: closeMobileMenu,
                    class: "block px-3 py-2 rounded-md text-sm text-gray-500 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors focus:outline-none"
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", _hoisted_28$z, [
                        _cache[12] || (_cache[12] = createBaseVNode("svg", {
                          class: "w-3 h-3",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z",
                            "clip-rule": "evenodd"
                          })
                        ], -1)),
                        createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.submenu.autoGenerator", "Auto Generator")), 1)
                      ])
                    ]),
                    _: 1
                  })
                ], 512), [
                  [vShow, isMobileVocabOpen.value]
                ])
              ]),
              createVNode(unref(RouterLink), {
                to: "/grammar",
                onClick: closeMobileMenu,
                class: normalizeClass([
                  "block px-3 py-2 rounded-md text-base font-medium text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors focus:outline-none",
                  unref(route).path === "/grammar" ? "bg-gray-300 dark:bg-dark-bg-mute text-black dark:text-white font-bold" : ""
                ])
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(unref(t)("common.grammar", "Grammar")), 1)
                ]),
                _: 1
              }, 8, ["class"]),
              createVNode(unref(RouterLink), {
                to: "/practice/flashcard",
                onClick: closeMobileMenu,
                class: normalizeClass([
                  "block px-3 py-2 rounded-md text-base font-medium text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors focus:outline-none",
                  unref(route).path === "/practice/flashcard" ? "bg-gray-300 dark:bg-dark-bg-mute text-black dark:text-white font-bold" : ""
                ])
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(unref(t)("common.practice", "Practice")), 1)
                ]),
                _: 1
              }, 8, ["class"])
            ])
          ], 2), [
            [vShow, isMobileMenuOpen.value]
          ])
        ]),
        createBaseVNode("div", _hoisted_29$x, [
          createBaseVNode("div", {
            class: "h-full bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 dark:from-blue-400 dark:via-purple-400 dark:to-pink-400 transition-all duration-150 ease-out",
            style: normalizeStyle({ width: `${scrollProgressPercentage.value}%` })
          }, null, 4)
        ])
      ], 6);
    };
  }
});

const AppHeader = /* @__PURE__ */ _export_sfc(_sfc_main$1g, [["__scopeId", "data-v-d44f8080"]]);

const AppHeader$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: AppHeader
}, Symbol.toStringTag, { value: 'Module' }));

const useScrollStore = defineStore("scroll", () => {
  const scrollY = ref(0);
  const showBackToTop = ref(false);
  const isScrolling = ref(false);
  const SCROLL_THRESHOLD = 300;
  let scrollTimer = null;
  const handleScroll = () => {
    scrollY.value = window.scrollY;
    showBackToTop.value = scrollY.value > SCROLL_THRESHOLD;
    isScrolling.value = true;
    if (scrollTimer) {
      clearTimeout(scrollTimer);
    }
    scrollTimer = setTimeout(() => {
      isScrolling.value = false;
    }, 150);
  };
  const scrollToTop = () => {
    window.scrollTo({
      top: 0,
      behavior: "smooth"
    });
  };
  const initScrollListener = () => {
    window.addEventListener("scroll", handleScroll, { passive: true });
    handleScroll();
  };
  const removeScrollListener = () => {
    window.removeEventListener("scroll", handleScroll);
    if (scrollTimer) {
      clearTimeout(scrollTimer);
      scrollTimer = null;
    }
  };
  const scrollPercentage = () => {
    const documentHeight = document.documentElement.scrollHeight - window.innerHeight;
    return documentHeight > 0 ? Math.min(scrollY.value / documentHeight * 100, 100) : 0;
  };
  const isNearTop = () => scrollY.value < 100;
  const isNearBottom = () => {
    const documentHeight = document.documentElement.scrollHeight;
    const viewportHeight = window.innerHeight;
    return scrollY.value + viewportHeight >= documentHeight - 100;
  };
  return {
    // State
    scrollY,
    showBackToTop,
    isScrolling,
    // Actions
    scrollToTop,
    initScrollListener,
    removeScrollListener,
    // Getters
    scrollPercentage,
    isNearTop,
    isNearBottom
  };
});

const _hoisted_1$1e = { class: "fixed bottom-6 z-50 left-1/2 -translate-x-[calc(100%+1rem)] sm:left-1/2 sm:-translate-x-[calc(100%+4px)] lg:left-6 lg:translate-x-0" };
const _hoisted_2$1b = { class: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-900 dark:bg-dark-bg rounded shadow-lg whitespace-nowrap z-10 pointer-events-none" };
const _hoisted_3$19 = ["aria-label"];
const _hoisted_4$15 = {
  key: 0,
  class: "absolute inset-0 w-full h-full -rotate-90",
  viewBox: "0 0 100 100"
};
const _hoisted_5$12 = ["stroke-dasharray", "stroke-dashoffset"];
const _sfc_main$1f = /* @__PURE__ */ defineComponent({
  __name: "BackToTop",
  props: {
    showProgress: { type: Boolean, default: false }
  },
  setup(__props) {
    const { t } = useI18n();
    const scrollStore = useScrollStore();
    const modalStore = useModalStore();
    const showTooltip = ref(false);
    const showBackToTop = computed(() => {
      return scrollStore.showBackToTop && !modalStore.shouldHideBackToTop;
    });
    const scrollPercentage = computed(() => scrollStore.scrollPercentage());
    const circumference = computed(() => 2 * Math.PI * 45);
    const handleScrollToTop = () => {
      showTooltip.value = false;
      scrollStore.scrollToTop();
    };
    const displayPercent = computed(() => Math.round(scrollPercentage.value));
    const tooltipText = computed(() => {
      const key = "common.backToTopTooltip";
      const translated = t(key, { percent: displayPercent.value });
      const isMissing = translated === key || translated.includes("{percent}");
      return isMissing ? `Back to Top (${displayPercent.value}%)` : translated;
    });
    onMounted(() => {
      scrollStore.initScrollListener();
    });
    onUnmounted(() => {
      scrollStore.removeScrollListener();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        name: "fade-scale",
        "enter-active-class": "fade-scale-enter-active",
        "enter-from-class": "fade-scale-enter-from",
        "leave-active-class": "fade-scale-leave-active",
        "leave-to-class": "fade-scale-leave-to"
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", _hoisted_1$1e, [
            createVNode(Transition, {
              name: "fade",
              "enter-active-class": "transition-opacity duration-200",
              "enter-from-class": "opacity-0",
              "leave-active-class": "transition-opacity duration-200",
              "leave-to-class": "opacity-0"
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", _hoisted_2$1b, [
                  createTextVNode(toDisplayString$1(tooltipText.value) + " ", 1),
                  _cache[2] || (_cache[2] = createBaseVNode("div", { class: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900 dark:border-t-dark-bg" }, null, -1))
                ], 512), [
                  [vShow, showTooltip.value]
                ])
              ]),
              _: 1
            }),
            createBaseVNode("button", {
              onClick: handleScrollToTop,
              onMouseenter: _cache[0] || (_cache[0] = ($event) => showTooltip.value = true),
              onMouseleave: _cache[1] || (_cache[1] = ($event) => showTooltip.value = false),
              class: "group w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white rounded-full shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-300 flex items-center justify-center",
              "aria-label": unref(t)("common.backToTop")
            }, [
              _cache[4] || (_cache[4] = createBaseVNode("svg", {
                class: "w-6 h-6 sm:w-7 sm:h-7 md:w-8 md:h-8 transform group-hover:-translate-y-0.5 transition-transform duration-200",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24",
                xmlns: "http://www.w3.org/2000/svg"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M5 10l7-7m0 0l7 7m-7-7v18"
                })
              ], -1)),
              _ctx.showProgress ? (openBlock(), createElementBlock("svg", _hoisted_4$15, [
                _cache[3] || (_cache[3] = createBaseVNode("circle", {
                  cx: "50",
                  cy: "50",
                  r: "45",
                  fill: "none",
                  stroke: "currentColor",
                  "stroke-width": "2",
                  opacity: "0.3"
                }, null, -1)),
                createBaseVNode("circle", {
                  cx: "50",
                  cy: "50",
                  r: "45",
                  fill: "none",
                  stroke: "currentColor",
                  "stroke-width": "2",
                  "stroke-dasharray": circumference.value,
                  "stroke-dashoffset": circumference.value - scrollPercentage.value / 100 * circumference.value,
                  class: "transition-all duration-300"
                }, null, 8, _hoisted_5$12)
              ])) : createCommentVNode("", true)
            ], 40, _hoisted_3$19)
          ], 512), [
            [vShow, showBackToTop.value]
          ])
        ]),
        _: 1
      });
    };
  }
});

const BackToTop = /* @__PURE__ */ _export_sfc(_sfc_main$1f, [["__scopeId", "data-v-c3ec54c8"]]);

const BackToTop$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: BackToTop
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1e = /* @__PURE__ */ defineComponent({
  __name: "LazyLoadComponent",
  props: {
    animationType: { default: "fade-up" },
    threshold: { default: 0.99 },
    rootMargin: { default: "0px" }
  },
  setup(__props) {
    const props = __props;
    const elementRef = ref();
    const isVisible = ref(false);
    let observer = null;
    let isFullyVisible = false;
    onMounted(() => {
      if (elementRef.value) {
        observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              const ratio = entry.intersectionRatio;
              const showThreshold = props.threshold;
              const hideThreshold = Math.max(0, props.threshold - 0.1);
              if (ratio >= showThreshold) {
                if (!isFullyVisible) {
                  isFullyVisible = true;
                  isVisible.value = true;
                }
              } else if (ratio <= hideThreshold) {
                if (isFullyVisible) {
                  isFullyVisible = false;
                  isVisible.value = false;
                }
              }
            });
          },
          {
            threshold: [0, 0.25, 0.5, 0.75, 0.9, 0.99, 1],
            // Theo di nhiu ngng  pht hin chnh xc
            rootMargin: props.rootMargin
          }
        );
        observer.observe(elementRef.value);
      }
    });
    onUnmounted(() => {
      if (observer && elementRef.value) {
        observer.unobserve(elementRef.value);
        observer.disconnect();
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "elementRef",
        ref: elementRef,
        class: normalizeClass([
          "lazy-wrapper",
          _ctx.animationType,
          { "is-visible": isVisible.value, "is-hidden": !isVisible.value }
        ])
      }, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 2);
    };
  }
});

const LazyLoadComponent = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["__scopeId", "data-v-e3e20eb0"]]);

const LazyLoadComponent$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: LazyLoadComponent
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$1d = { class: "relative bg-white/70 dark:bg-[#0a0a0a]/70 backdrop-blur-xl shadow-lg border-b border-white/20 dark:border-white/10 overflow-hidden" };
const _hoisted_2$1a = { class: "max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8 relative" };
const _hoisted_3$18 = { class: "flex items-center space-x-4 mb-4" };
const _hoisted_4$14 = { class: "flex-1" };
const _hoisted_5$11 = { class: "text-3xl sm:text-4xl lg:text-5xl font-black bg-gradient-to-r from-blue-600 via-purple-600 to-pink-600 dark:from-blue-400 dark:via-purple-400 dark:to-pink-400 bg-clip-text text-transparent animate-fade-in-up" };
const _hoisted_6$$ = { class: "flex items-center mt-2 space-x-2" };
const _hoisted_7$Y = { class: "text-sm sm:text-base text-gray-600 dark:text-gray-300 font-medium" };
const _sfc_main$1d = /* @__PURE__ */ defineComponent({
  __name: "DashboardHeader",
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1d, [
        _cache[3] || (_cache[3] = createStaticVNode('<div class="absolute inset-0 bg-gradient-to-r from-blue-400/10 via-purple-500/10 to-pink-500/10 dark:from-blue-500/20 dark:via-purple-500/20 dark:to-pink-500/20"></div><div class="absolute top-0 left-0 w-full h-full"><div class="absolute top-0 left-1/4 w-2 h-2 bg-blue-400 dark:bg-blue-300 rounded-full animate-ping opacity-60"></div><div class="absolute top-4 right-1/3 w-1 h-1 bg-purple-400 dark:bg-purple-300 rounded-full animate-pulse"></div><div class="absolute bottom-2 left-1/2 w-1.5 h-1.5 bg-pink-400 dark:bg-pink-300 rounded-full animate-bounce"></div></div>', 2)),
        createBaseVNode("div", _hoisted_2$1a, [
          createBaseVNode("div", _hoisted_3$18, [
            _cache[1] || (_cache[1] = createStaticVNode('<div class="relative"><div class="w-12 h-12 bg-gradient-to-br from-blue-500 to-purple-600 rounded-2xl flex items-center justify-center shadow-lg transform hover:rotate-12 transition-transform duration-300"><svg class="w-6 h-6 text-white animate-pulse" fill="currentColor" viewBox="0 0 20 20"><path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div><div class="absolute -top-1 -right-1 w-4 h-4 bg-gradient-to-br from-yellow-400 to-orange-500 rounded-full animate-bounce"></div></div>', 1)),
            createBaseVNode("div", _hoisted_4$14, [
              createBaseVNode("h1", _hoisted_5$11, toDisplayString$1(unref(t)("dashboard.title", "Dashboard")), 1),
              createBaseVNode("div", _hoisted_6$$, [
                _cache[0] || (_cache[0] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                  createBaseVNode("div", { class: "w-2 h-2 bg-gradient-to-r from-green-400 to-blue-500 rounded-full" })
                ], -1)),
                createBaseVNode("p", _hoisted_7$Y, toDisplayString$1(unref(t)("dashboard.description", "Here is a summary of your learning progress.")), 1)
              ])
            ])
          ]),
          _cache[2] || (_cache[2] = createStaticVNode('<div class="relative"><div class="h-1 bg-gray-200 dark:bg-white/10 rounded-full overflow-hidden"><div class="h-full bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 rounded-full animate-progress-slide"></div></div><div class="absolute -top-1 left-0 w-3 h-3 bg-gradient-to-br from-blue-400 to-blue-600 rounded-full animate-bounce-slow"></div></div><div class="absolute inset-0 pointer-events-none"><div class="absolute top-1/4 left-1/6 w-1 h-1 bg-yellow-400 rounded-full animate-float"></div><div class="absolute top-3/4 right-1/4 w-0.5 h-0.5 bg-green-400 rounded-full animate-float-delay"></div><div class="absolute top-1/2 right-1/6 w-1.5 h-1.5 bg-blue-400 rounded-full animate-float-slow"></div></div>', 2))
        ])
      ]);
    };
  }
});

const DashboardHeader = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$1d
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$1c = { class: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6 mb-8" };
const _hoisted_2$19 = {
  class: "group relative bg-white/70 dark:bg-[#0a0a0a]/70 backdrop-blur-lg overflow-hidden shadow-lg hover:shadow-2xl rounded-2xl border border-white/30 dark:border-white/10 transition-all duration-500 hover:scale-105 hover:-translate-y-3 animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_3$17 = { class: "relative p-6" };
const _hoisted_4$13 = { class: "space-y-2" };
const _hoisted_5$10 = { class: "text-sm font-semibold text-blue-600 dark:text-blue-400 uppercase tracking-wide" };
const _hoisted_6$_ = { class: "text-3xl font-bold text-gray-900 dark:text-white counter-animate" };
const _hoisted_7$X = {
  class: "group relative bg-white/70 dark:bg-[#0a0a0a]/70 backdrop-blur-lg overflow-hidden shadow-lg hover:shadow-2xl rounded-2xl border border-white/30 dark:border-white/10 transition-all duration-500 hover:scale-105 hover:-translate-y-3 animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_8$X = { class: "relative p-6" };
const _hoisted_9$W = { class: "space-y-2" };
const _hoisted_10$V = { class: "text-sm font-semibold text-green-600 dark:text-green-400 uppercase tracking-wide" };
const _hoisted_11$V = { class: "text-3xl font-bold text-gray-900 dark:text-white counter-animate" };
const _hoisted_12$T = {
  class: "group relative bg-white/70 dark:bg-[#0a0a0a]/70 backdrop-blur-lg overflow-hidden shadow-lg hover:shadow-2xl rounded-2xl border border-white/30 dark:border-white/10 transition-all duration-500 hover:scale-105 hover:-translate-y-3 animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_13$T = { class: "relative p-6" };
const _hoisted_14$S = { class: "space-y-2" };
const _hoisted_15$M = { class: "text-sm font-semibold text-orange-600 dark:text-orange-400 uppercase tracking-wide" };
const _hoisted_16$L = { class: "text-3xl font-bold text-gray-900 dark:text-white counter-animate" };
const _hoisted_17$K = { class: "text-lg font-medium" };
const _hoisted_18$I = {
  class: "group relative bg-white/70 dark:bg-[#0a0a0a]/70 backdrop-blur-lg overflow-hidden shadow-lg hover:shadow-2xl rounded-2xl border border-white/30 dark:border-white/10 transition-all duration-500 hover:scale-105 hover:-translate-y-3 animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_19$I = { class: "relative p-6" };
const _hoisted_20$H = { class: "space-y-2" };
const _hoisted_21$H = { class: "text-sm font-semibold text-purple-600 dark:text-purple-400 uppercase tracking-wide" };
const _hoisted_22$F = { class: "text-3xl font-bold text-gray-900 dark:text-white counter-animate" };
const _hoisted_23$F = { class: "text-lg font-medium" };
const _sfc_main$1c = /* @__PURE__ */ defineComponent({
  __name: "DashboardStats",
  props: {
    stats: {}
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1c, [
        createBaseVNode("div", _hoisted_2$19, [
          _cache[2] || (_cache[2] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-br from-blue-500/10 to-blue-600/20 dark:from-blue-400/20 dark:to-blue-500/30" }, null, -1)),
          createBaseVNode("div", _hoisted_3$17, [
            _cache[1] || (_cache[1] = createStaticVNode('<div class="flex items-center justify-between mb-4"><div class="flex-shrink-0"><div class="w-12 h-12 bg-gradient-to-br from-blue-500 to-blue-600 rounded-2xl flex items-center justify-center shadow-lg transform group-hover:rotate-12 group-hover:scale-110 transition-all duration-300"><svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20"><path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div></div><div class="opacity-0 group-hover:opacity-100 transition-opacity duration-300"><div class="w-8 h-8 bg-blue-100 dark:bg-blue-900/30 rounded-full flex items-center justify-center"><svg class="w-4 h-4 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path></svg></div></div></div>', 1)),
            createBaseVNode("div", _hoisted_4$13, [
              createBaseVNode("dt", _hoisted_5$10, toDisplayString$1(unref(t)("dashboard.stats.vocabularyLearned", "Vocabulary Learned")), 1),
              createBaseVNode("dd", _hoisted_6$_, toDisplayString$1(_ctx.stats.vocabularyLearned), 1),
              _cache[0] || (_cache[0] = createBaseVNode("div", { class: "w-full bg-blue-100 dark:bg-blue-900/30 rounded-full h-2" }, [
                createBaseVNode("div", {
                  class: "bg-gradient-to-r from-blue-500 to-blue-600 h-2 rounded-full animate-progress-slide",
                  style: { "width": "75%" }
                })
              ], -1))
            ])
          ]),
          _cache[3] || (_cache[3] = createBaseVNode("div", { class: "absolute top-4 right-4 w-2 h-2 bg-blue-400 rounded-full animate-ping" }, null, -1))
        ]),
        createBaseVNode("div", _hoisted_7$X, [
          _cache[6] || (_cache[6] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-br from-green-500/10 to-green-600/20 dark:from-green-400/20 dark:to-green-500/30" }, null, -1)),
          createBaseVNode("div", _hoisted_8$X, [
            _cache[5] || (_cache[5] = createStaticVNode('<div class="flex items-center justify-between mb-4"><div class="flex-shrink-0"><div class="w-12 h-12 bg-gradient-to-br from-green-500 to-green-600 rounded-2xl flex items-center justify-center shadow-lg transform group-hover:rotate-12 group-hover:scale-110 transition-all duration-300"><svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20"><path d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg></div></div><div class="opacity-0 group-hover:opacity-100 transition-opacity duration-300"><div class="w-8 h-8 bg-green-100 dark:bg-green-900/30 rounded-full flex items-center justify-center"><svg class="w-4 h-4 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg></div></div></div>', 1)),
            createBaseVNode("div", _hoisted_9$W, [
              createBaseVNode("dt", _hoisted_10$V, toDisplayString$1(unref(t)("dashboard.stats.grammarLessons", "Grammar Lessons")), 1),
              createBaseVNode("dd", _hoisted_11$V, toDisplayString$1(_ctx.stats.grammarLessons), 1),
              _cache[4] || (_cache[4] = createBaseVNode("div", { class: "w-full bg-green-100 dark:bg-green-900/30 rounded-full h-2" }, [
                createBaseVNode("div", {
                  class: "bg-gradient-to-r from-green-500 to-green-600 h-2 rounded-full animate-progress-slide",
                  style: { "width": "60%" }
                })
              ], -1))
            ])
          ]),
          _cache[7] || (_cache[7] = createBaseVNode("div", { class: "absolute top-4 right-4 w-2 h-2 bg-green-400 rounded-full animate-ping" }, null, -1))
        ]),
        createBaseVNode("div", _hoisted_12$T, [
          _cache[10] || (_cache[10] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-br from-yellow-500/10 to-orange-600/20 dark:from-yellow-400/20 dark:to-orange-500/30" }, null, -1)),
          createBaseVNode("div", _hoisted_13$T, [
            _cache[9] || (_cache[9] = createStaticVNode('<div class="flex items-center justify-between mb-4"><div class="flex-shrink-0"><div class="w-12 h-12 bg-gradient-to-br from-yellow-500 to-orange-600 rounded-2xl flex items-center justify-center shadow-lg transform group-hover:rotate-12 group-hover:scale-110 transition-all duration-300"><svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20"><path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3z"></path></svg></div></div><div class="opacity-0 group-hover:opacity-100 transition-opacity duration-300"><div class="w-8 h-8 bg-orange-100 dark:bg-orange-900/30 rounded-full flex items-center justify-center"><svg class="w-4 h-4 text-orange-600 dark:text-orange-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975 0 0120 13a7.975 7.975 0 01-2.343 5.657z"></path></svg></div></div></div>', 1)),
            createBaseVNode("div", _hoisted_14$S, [
              createBaseVNode("dt", _hoisted_15$M, toDisplayString$1(unref(t)("dashboard.stats.currentStreak", "Current Streak")), 1),
              createBaseVNode("dd", _hoisted_16$L, [
                createTextVNode(toDisplayString$1(_ctx.stats.currentStreak) + " ", 1),
                createBaseVNode("span", _hoisted_17$K, toDisplayString$1(unref(t)("dashboard.stats.days", "days")), 1)
              ]),
              _cache[8] || (_cache[8] = createBaseVNode("div", { class: "w-full bg-orange-100 dark:bg-orange-900/30 rounded-full h-2" }, [
                createBaseVNode("div", {
                  class: "bg-gradient-to-r from-yellow-500 to-orange-600 h-2 rounded-full animate-progress-slide",
                  style: { "width": "85%" }
                })
              ], -1))
            ])
          ]),
          _cache[11] || (_cache[11] = createBaseVNode("div", { class: "absolute top-4 right-4 w-2 h-2 bg-orange-400 rounded-full animate-ping" }, null, -1))
        ]),
        createBaseVNode("div", _hoisted_18$I, [
          _cache[14] || (_cache[14] = createBaseVNode("div", { class: "absolute inset-0 bg-gradient-to-br from-purple-500/10 to-purple-600/20 dark:from-purple-400/20 dark:to-purple-500/30" }, null, -1)),
          createBaseVNode("div", _hoisted_19$I, [
            _cache[13] || (_cache[13] = createStaticVNode('<div class="flex items-center justify-between mb-4"><div class="flex-shrink-0"><div class="w-12 h-12 bg-gradient-to-br from-purple-500 to-purple-600 rounded-2xl flex items-center justify-center shadow-lg transform group-hover:rotate-12 group-hover:scale-110 transition-all duration-300"><svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2C5.03 2 1 6.03 1 11s4.03 9 9 9 9-4.03 9-9-4.03-9-9-9zm0 16c-3.86 0-7-3.14-7-7s3.14-7 7-7 7 3.14 7 7-3.14 7-7 7zm.5-13H9v6l5.25 3.15.75-1.23-4.5-2.67z"></path></svg></div></div><div class="opacity-0 group-hover:opacity-100 transition-opacity duration-300"><div class="w-8 h-8 bg-purple-100 dark:bg-purple-900/30 rounded-full flex items-center justify-center"><svg class="w-4 h-4 text-purple-600 dark:text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div></div></div>', 1)),
            createBaseVNode("div", _hoisted_20$H, [
              createBaseVNode("dt", _hoisted_21$H, toDisplayString$1(unref(t)("dashboard.stats.totalTime", "Total Time")), 1),
              createBaseVNode("dd", _hoisted_22$F, [
                createTextVNode(toDisplayString$1(_ctx.stats.totalTime) + " ", 1),
                createBaseVNode("span", _hoisted_23$F, toDisplayString$1(unref(t)("dashboard.stats.hours", "hours")), 1)
              ]),
              _cache[12] || (_cache[12] = createBaseVNode("div", { class: "w-full bg-purple-100 dark:bg-purple-900/30 rounded-full h-2" }, [
                createBaseVNode("div", {
                  class: "bg-gradient-to-r from-purple-500 to-purple-600 h-2 rounded-full animate-progress-slide",
                  style: { "width": "90%" }
                })
              ], -1))
            ])
          ]),
          _cache[15] || (_cache[15] = createBaseVNode("div", { class: "absolute top-4 right-4 w-2 h-2 bg-purple-400 rounded-full animate-ping" }, null, -1))
        ])
      ]);
    };
  }
});

const DashboardStats = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$1c
}, Symbol.toStringTag, { value: 'Module' }));

function useFlashcardDashboardStats() {
  const practiceHistory = ref([]);
  const isLoading = ref(true);
  const loadPracticeHistory = () => {
    try {
      const saved = localStorage.getItem("flashcard-practice-history");
      if (saved) {
        const parsed = JSON.parse(saved);
        practiceHistory.value = parsed;
      }
    } catch (error) {
      console.error("Error loading flashcard practice history:", error);
    } finally {
      isLoading.value = false;
    }
  };
  const getStreakDays = () => {
    if (practiceHistory.value.length === 0) return 0;
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const practiceDates = [...new Set(
      practiceHistory.value.map((item) => {
        const date = new Date(item.date);
        date.setHours(0, 0, 0, 0);
        return date.getTime();
      })
    )].sort((a, b) => b - a);
    if (practiceDates.length === 0) return 0;
    const mostRecentDate = new Date(practiceDates[0]);
    const daysDiff = Math.floor((today.getTime() - mostRecentDate.getTime()) / (1e3 * 60 * 60 * 24));
    if (daysDiff > 1) return 0;
    let streak = 0;
    let expectedDate = today.getTime();
    for (const practiceDate of practiceDates) {
      const date = new Date(practiceDate);
      if (date.getTime() === expectedDate) {
        streak++;
        expectedDate -= 24 * 60 * 60 * 1e3;
      } else if (date.getTime() === expectedDate + 24 * 60 * 60 * 1e3 && streak === 0) {
        streak++;
        expectedDate -= 24 * 60 * 60 * 1e3;
      } else {
        break;
      }
    }
    return streak;
  };
  const getWeeklyProgress = () => {
    const now = /* @__PURE__ */ new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
    const thisWeekSessions = practiceHistory.value.filter((item) => {
      const itemDate = new Date(item.date);
      return itemDate >= weekAgo && itemDate <= now;
    });
    const weeklyProgress = Math.min(Math.round(thisWeekSessions.length / 7 * 100), 100);
    return {
      sessionsThisWeek: thisWeekSessions.length,
      weeklyProgress
    };
  };
  const getSessionsThisMonth = () => {
    const now = /* @__PURE__ */ new Date();
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1e3);
    return practiceHistory.value.filter((item) => {
      const itemDate = new Date(item.date);
      return itemDate >= monthAgo && itemDate <= now;
    }).length;
  };
  const getFavoriteMode = () => {
    if (practiceHistory.value.length === 0) return "";
    const modeCount = practiceHistory.value.reduce((acc, item) => {
      acc[item.mode] = (acc[item.mode] || 0) + 1;
      return acc;
    }, {});
    return Object.entries(modeCount).sort(([, a], [, b]) => b - a)[0]?.[0] || "";
  };
  const stats = computed(() => {
    if (isLoading.value || practiceHistory.value.length === 0) {
      return {
        totalSessions: 0,
        totalPracticeTime: 0,
        averageAccuracy: 0,
        bestScore: 0,
        favoriteMode: "",
        totalCardsStudied: 0,
        streakDays: 0,
        weeklyProgress: 0,
        sessionsThisWeek: 0,
        sessionsThisMonth: 0
      };
    }
    const totalSessions = practiceHistory.value.length;
    const totalPracticeTime = practiceHistory.value.reduce((sum, item) => sum + item.duration, 0);
    const averageAccuracy = Math.round(
      practiceHistory.value.reduce((sum, item) => sum + item.accuracy, 0) / totalSessions
    );
    const bestScore = Math.max(...practiceHistory.value.map((item) => item.score));
    const totalCardsStudied = practiceHistory.value.reduce((sum, item) => sum + item.totalCards, 0);
    const favoriteMode = getFavoriteMode();
    const streakDays = getStreakDays();
    const { sessionsThisWeek, weeklyProgress } = getWeeklyProgress();
    const sessionsThisMonth = getSessionsThisMonth();
    return {
      totalSessions,
      totalPracticeTime: Math.round(totalPracticeTime / 60),
      // Convert to minutes
      averageAccuracy,
      bestScore,
      favoriteMode,
      totalCardsStudied,
      streakDays,
      weeklyProgress,
      sessionsThisWeek,
      sessionsThisMonth
    };
  });
  const getFormattedStats = computed(() => {
    const currentStats = stats.value;
    return {
      ...currentStats,
      totalPracticeTimeFormatted: formatDuration(currentStats.totalPracticeTime),
      favoriteModeFormatted: formatMode(currentStats.favoriteMode),
      accuracyLevel: getAccuracyLevel(currentStats.averageAccuracy),
      streakLevel: getStreakLevel(currentStats.streakDays),
      progressLevel: getProgressLevel(currentStats.weeklyProgress)
    };
  });
  const formatDuration = (minutes) => {
    if (minutes < 60) {
      return `${minutes}m`;
    }
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;
    return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;
  };
  const formatMode = (mode) => {
    const modeNames = {
      "flashcard": "Flashcard",
      "quiz": "Quiz",
      "typing": "Typing",
      "listening": "Listening",
      "image": "Image",
      "pictionary": "Pictionary",
      "pronunciation": "Pronunciation",
      "bubble-shooter": "Bubble Shooter",
      "snake-game": "Snake Hunt"
    };
    return modeNames[mode] || mode;
  };
  const getAccuracyLevel = (accuracy) => {
    if (accuracy >= 90) return { level: "Excellent", color: "text-green-600 dark:text-green-400" };
    if (accuracy >= 80) return { level: "Good", color: "text-blue-600 dark:text-blue-400" };
    if (accuracy >= 70) return { level: "Fair", color: "text-yellow-600 dark:text-yellow-400" };
    if (accuracy >= 60) return { level: "Average", color: "text-orange-600 dark:text-orange-400" };
    return { level: "Needs Work", color: "text-red-600 dark:text-red-400" };
  };
  const getStreakLevel = (days) => {
    if (days >= 30) return { level: "Amazing", color: "text-purple-600 dark:text-purple-400" };
    if (days >= 14) return { level: "Great", color: "text-green-600 dark:text-green-400" };
    if (days >= 7) return { level: "Good", color: "text-blue-600 dark:text-blue-400" };
    if (days >= 3) return { level: "Building", color: "text-yellow-600 dark:text-yellow-400" };
    if (days >= 1) return { level: "Started", color: "text-orange-600 dark:text-orange-400" };
    return { level: "None", color: "text-gray-600 dark:text-gray-400" };
  };
  const getProgressLevel = (progress) => {
    if (progress >= 90) return { level: "Outstanding", color: "text-green-600 dark:text-green-400" };
    if (progress >= 70) return { level: "Strong", color: "text-blue-600 dark:text-blue-400" };
    if (progress >= 50) return { level: "Moderate", color: "text-yellow-600 dark:text-yellow-400" };
    if (progress >= 30) return { level: "Light", color: "text-orange-600 dark:text-orange-400" };
    return { level: "Minimal", color: "text-red-600 dark:text-red-400" };
  };
  const refreshStats = () => {
    loadPracticeHistory();
  };
  onMounted(() => {
    loadPracticeHistory();
  });
  return {
    stats,
    getFormattedStats,
    isLoading,
    refreshStats
  };
}

const _hoisted_1$1b = ["width", "height"];
const _hoisted_2$18 = ["id"];
const _hoisted_3$16 = ["id"];
const _hoisted_4$12 = ["id"];
const _hoisted_5$$ = ["cx", "cy", "r", "stroke", "stroke-width"];
const _hoisted_6$Z = ["cx", "cy", "r", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset"];
const _hoisted_7$W = ["cx", "cy", "r", "stroke-dashoffset"];
const _hoisted_8$W = { class: "flex flex-col items-center justify-center text-center space-y-1 transform transition-all duration-300 group-hover:scale-105" };
const _hoisted_9$V = {
  key: 0,
  class: "flex-shrink-0 mb-1 relative"
};
const _hoisted_10$U = { class: "flex flex-col items-center justify-center" };
const _hoisted_11$U = {
  key: 0,
  class: "absolute inset-0 pointer-events-none overflow-hidden rounded-full"
};
const __default__$3 = {
  name: "CircularProgress"
};
const _sfc_main$1b = /* @__PURE__ */ defineComponent({
  ...__default__$3,
  props: {
    value: {},
    max: {},
    size: { default: 120 },
    strokeWidth: { default: 8 },
    progressColor: { default: "#3b82f6" },
    progressColorSecondary: { default: "#60a5fa" },
    progressColorThertiary: { default: "#93c5fd" },
    backgroundColor: { default: "#e5e7eb" },
    label: {},
    unit: { default: "" },
    showIcon: { type: Boolean, default: false },
    valueClass: { default: "text-xl font-bold" },
    showShimmer: { type: Boolean, default: false },
    glowEffect: { type: Boolean, default: false },
    animationDelay: { default: 0 }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "bd8d57e4": _ctx.animationDelay + "ms"
    }));
    const props = __props;
    const animatedValue = ref(0);
    const animatedProgress = ref(0);
    const isAnimating = ref(false);
    const radius = computed(() => (props.size - props.strokeWidth) / 2);
    const circumference = computed(() => 2 * Math.PI * radius.value);
    const percentage = computed(() => Math.min(props.value / props.max * 100, 100));
    const strokeDashoffset = computed(
      () => circumference.value - animatedProgress.value / 100 * circumference.value
    );
    const displayValue = computed(() => {
      if (props.unit === "%") {
        return Math.round(animatedProgress.value);
      }
      return Math.round(animatedValue.value);
    });
    const animateValue = (from, to, duration = 1500) => {
      const startTime = Date.now();
      const update = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easeOutCubic = 1 - Math.pow(1 - progress, 3);
        animatedValue.value = from + (to - from) * easeOutCubic;
        animatedProgress.value = from + (percentage.value - from) * easeOutCubic;
        if (progress < 1) {
          requestAnimationFrame(update);
        } else {
          isAnimating.value = false;
        }
      };
      isAnimating.value = true;
      requestAnimationFrame(update);
    };
    const circularProgressRef = ref();
    ref(false);
    const startAnimation = () => {
      setTimeout(() => {
        animateValue(0, props.value);
      }, props.animationDelay);
    };
    onMounted(() => {
      startAnimation();
      if (!circularProgressRef.value) return;
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting && !isAnimating.value) {
              animatedValue.value = 0;
              animatedProgress.value = 0;
              startAnimation();
            }
          });
        },
        {
          threshold: 0.3,
          // Trigger when 30% visible
          rootMargin: "0px 0px -20px 0px"
        }
      );
      observer.observe(circularProgressRef.value);
      return () => observer.disconnect();
    });
    const iconSize = computed(() => {
      if (props.size >= 140) return "w-6 h-6";
      if (props.size >= 100) return "w-5 h-5";
      return "w-4 h-4";
    });
    const gradientId = computed(() => Math.random().toString(36).substr(2, 9));
    const shimmerOffset = computed(() => circumference.value);
    const progressColorTertiary = computed(() => props.progressColorThertiary);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "circularProgressRef",
        ref: circularProgressRef,
        class: "relative group cursor-pointer rounded-full overflow-hidden",
        style: normalizeStyle([{ "display": "inline-block", "background": "transparent !important", "box-shadow": "none !important" }, { width: _ctx.size + "px", height: _ctx.size + "px", clipPath: "circle(50% at 50% 50%)" }])
      }, [
        createBaseVNode("div", {
          class: "absolute inset-0 rounded-full overflow-hidden pointer-events-none opacity-0 group-hover:opacity-30 transition-all duration-700 blur-xl animate-pulse",
          style: normalizeStyle({
            background: `radial-gradient(circle, ${_ctx.progressColor}20, transparent 70%)`,
            transform: "scale(1.2)"
          })
        }, null, 4),
        (openBlock(), createElementBlock("svg", {
          width: _ctx.size,
          height: _ctx.size,
          class: "transform -rotate-90 transition-all duration-500 group-hover:scale-105 relative z-10",
          style: { "display": "block", "background": "transparent !important" }
        }, [
          createBaseVNode("defs", null, [
            createBaseVNode("linearGradient", {
              id: `progressGradient-${gradientId.value}`,
              x1: "0%",
              y1: "0%",
              x2: "100%",
              y2: "100%"
            }, [
              createBaseVNode("stop", {
                offset: "0%",
                style: normalizeStyle({ stopColor: _ctx.progressColor, stopOpacity: 1 })
              }, null, 4),
              createBaseVNode("stop", {
                offset: "50%",
                style: normalizeStyle({ stopColor: _ctx.progressColorSecondary, stopOpacity: 0.9 })
              }, null, 4),
              createBaseVNode("stop", {
                offset: "100%",
                style: normalizeStyle({ stopColor: progressColorTertiary.value, stopOpacity: 1 })
              }, null, 4)
            ], 8, _hoisted_2$18),
            createBaseVNode("linearGradient", {
              id: `backgroundGradient-${gradientId.value}`,
              x1: "0%",
              y1: "0%",
              x2: "100%",
              y2: "100%"
            }, [
              createBaseVNode("stop", {
                offset: "0%",
                style: normalizeStyle({ stopColor: _ctx.backgroundColor, stopOpacity: 0.1 })
              }, null, 4),
              createBaseVNode("stop", {
                offset: "100%",
                style: normalizeStyle({ stopColor: _ctx.backgroundColor, stopOpacity: 0.3 })
              }, null, 4)
            ], 8, _hoisted_3$16),
            createBaseVNode("filter", {
              id: `glow-${gradientId.value}`
            }, _cache[0] || (_cache[0] = [
              createBaseVNode("feGaussianBlur", {
                stdDeviation: "3",
                result: "coloredBlur"
              }, null, -1),
              createBaseVNode("feMerge", null, [
                createBaseVNode("feMergeNode", { in: "coloredBlur" }),
                createBaseVNode("feMergeNode", { in: "SourceGraphic" })
              ], -1)
            ]), 8, _hoisted_4$12)
          ]),
          createBaseVNode("circle", {
            cx: _ctx.size / 2,
            cy: _ctx.size / 2,
            r: radius.value,
            stroke: `url(#backgroundGradient-${gradientId.value})`,
            "stroke-width": _ctx.strokeWidth,
            fill: "transparent",
            class: "opacity-40"
          }, null, 8, _hoisted_5$$),
          createBaseVNode("circle", {
            cx: _ctx.size / 2,
            cy: _ctx.size / 2,
            r: radius.value,
            stroke: `url(#progressGradient-${gradientId.value})`,
            "stroke-width": _ctx.strokeWidth + 1,
            fill: "transparent",
            "stroke-dasharray": circumference.value,
            "stroke-dashoffset": strokeDashoffset.value,
            "stroke-linecap": "round",
            class: "transition-all duration-1500 ease-out transform-gpu",
            style: normalizeStyle({
              filter: _ctx.glowEffect ? `url(#glow-${gradientId.value})` : "none",
              animation: "progressShine 3s infinite linear"
            })
          }, null, 12, _hoisted_6$Z),
          _ctx.showShimmer ? (openBlock(), createElementBlock("circle", {
            key: 0,
            cx: _ctx.size / 2,
            cy: _ctx.size / 2,
            r: radius.value,
            stroke: "rgba(255, 255, 255, 0.6)",
            "stroke-width": 1,
            fill: "transparent",
            "stroke-dasharray": "20 80",
            "stroke-dashoffset": shimmerOffset.value,
            "stroke-linecap": "round",
            class: "animate-spin",
            style: { "animation-duration": "4s" },
            opacity: "0.8"
          }, null, 8, _hoisted_7$W)) : createCommentVNode("", true)
        ], 8, _hoisted_1$1b)),
        createBaseVNode("div", {
          class: "pointer-events-none absolute inset-0 flex items-center justify-center",
          style: normalizeStyle({
            width: _ctx.size + "px",
            height: _ctx.size + "px"
          })
        }, [
          createBaseVNode("div", _hoisted_8$W, [
            _ctx.showIcon ? (openBlock(), createElementBlock("div", _hoisted_9$V, [
              createBaseVNode("div", {
                class: normalizeClass(["transition-all duration-300 group-hover:text-white", iconSize.value]),
                style: normalizeStyle({
                  color: _ctx.progressColor,
                  filter: `drop-shadow(0 0 8px ${_ctx.progressColor}40)`,
                  textShadow: `0 0 10px ${_ctx.progressColor}60`
                })
              }, [
                renderSlot(_ctx.$slots, "icon", {}, void 0, true)
              ], 6)
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_10$U, [
              createBaseVNode("div", {
                class: normalizeClass(["font-bold tracking-tight transition-all duration-300 group-hover:scale-110", _ctx.valueClass]),
                style: normalizeStyle({
                  color: "white",
                  textShadow: `0 0 15px ${_ctx.progressColor}50, 0 2px 4px rgba(0,0,0,0.3)`,
                  letterSpacing: "-0.02em"
                })
              }, toDisplayString$1(displayValue.value) + toDisplayString$1(_ctx.unit), 7),
              _ctx.label ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "text-xs font-semibold uppercase tracking-wider transition-all duration-300 group-hover:text-white mt-1",
                style: normalizeStyle({
                  color: `${_ctx.progressColor}dd`,
                  textShadow: `0 0 8px ${_ctx.progressColor}40`,
                  letterSpacing: "0.05em"
                })
              }, toDisplayString$1(_ctx.label), 5)) : createCommentVNode("", true)
            ])
          ])
        ], 4),
        _ctx.showShimmer ? (openBlock(), createElementBlock("div", _hoisted_11$U, [
          (openBlock(), createElementBlock(Fragment, null, renderList(3, (i) => {
            return createBaseVNode("div", {
              key: i,
              class: "absolute w-1 h-1 rounded-full animate-pulse",
              style: normalizeStyle({
                background: `radial-gradient(circle, ${_ctx.progressColor}, transparent)`,
                top: Math.random() * 80 + 10 + "%",
                left: Math.random() * 80 + 10 + "%",
                animationDelay: i * 0.5 + "s",
                animationDuration: "2s"
              })
            }, null, 4);
          }), 64))
        ])) : createCommentVNode("", true)
      ], 4);
    };
  }
});

const CircularProgress$2 = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["__scopeId", "data-v-621c8743"]]);

const _hoisted_1$1a = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-105 hover:-translate-y-2 h-full min-h-[420px] flex flex-col" };
const _hoisted_2$17 = { class: "px-6 py-8 sm:p-8 flex-1 flex flex-col" };
const _hoisted_3$15 = { class: "flex items-center mb-6" };
const _hoisted_4$11 = { class: "text-lg sm:text-xl md:text-2xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 dark:from-purple-400 dark:to-pink-400 bg-clip-text text-transparent" };
const _hoisted_5$_ = {
  key: 0,
  class: "flex-1 flex items-center justify-center"
};
const _hoisted_6$Y = {
  key: 1,
  class: "flex-1 flex flex-col items-center justify-center text-center space-y-4"
};
const _hoisted_7$V = { class: "text-sm font-medium text-gray-600 dark:text-gray-300" };
const _hoisted_8$V = { class: "text-xs text-gray-500 dark:text-gray-400 mt-1" };
const _hoisted_9$U = {
  key: 2,
  class: "space-y-6 flex-1"
};
const _hoisted_10$T = {
  class: "grid grid-cols-2 lg:grid-cols-4 place-items-center justify-center gap-8 lg:gap-6",
  style: { "background": "transparent !important" }
};
const _hoisted_11$T = {
  class: "flex flex-col items-center text-center",
  style: { "background": "transparent !important" }
};
const _hoisted_12$S = { style: { "background": "transparent !important" } };
const _hoisted_13$S = {
  class: "flex flex-col items-center text-center",
  style: { "background": "transparent !important" }
};
const _hoisted_14$R = {
  class: "flex flex-col items-center text-center",
  style: { "background": "transparent !important" }
};
const _hoisted_15$L = { class: "grid grid-cols-1 sm:grid-cols-2 gap-4" };
const _hoisted_16$K = {
  class: "bg-white/50 dark:bg-[#0a0a0a]/30 rounded-xl p-4 group/stat hover:bg-white/70 dark:hover:bg-[#0a0a0a]/50 transition-all duration-300",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_17$J = { class: "flex items-center justify-between mb-2" };
const _hoisted_18$H = { class: "text-xs font-semibold text-blue-600 dark:text-blue-400 uppercase tracking-wide" };
const _hoisted_19$H = { class: "text-2xl font-bold text-gray-900 dark:text-white counter-animate" };
const _hoisted_20$G = {
  class: "bg-white/50 dark:bg-[#0a0a0a]/30 rounded-xl p-4 group/stat hover:bg-white/70 dark:hover:bg-[#0a0a0a]/50 transition-all duration-300",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_21$G = { class: "flex items-center justify-between mb-2" };
const _hoisted_22$E = { class: "text-xs font-semibold text-pink-600 dark:text-pink-400 uppercase tracking-wide" };
const _hoisted_23$E = { class: "text-2xl font-bold text-gray-900 dark:text-white counter-animate" };
const _hoisted_24$D = { class: "space-y-3" };
const _hoisted_25$D = {
  class: "group/activity flex items-center space-x-4 p-3 rounded-xl hover:bg-white/50 dark:hover:bg-[#0a0a0a]/20 transition-all duration-300",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_26$B = { class: "flex-1 min-w-0" };
const _hoisted_27$A = { class: "text-xs sm:text-sm font-semibold text-gray-900 dark:text-white" };
const _hoisted_28$y = { class: "text-xs text-purple-600 dark:text-purple-400 font-medium" };
const _hoisted_29$w = {
  key: 0,
  class: "group/activity flex items-center space-x-4 p-3 rounded-xl hover:bg-white/50 dark:hover:bg-[#0a0a0a]/20 transition-all duration-300",
  style: { "animation-delay": "0.8s" }
};
const _hoisted_30$v = { class: "flex-1 min-w-0" };
const _hoisted_31$u = { class: "text-xs sm:text-sm font-semibold text-gray-900 dark:text-white" };
const _hoisted_32$r = { class: "text-xs text-yellow-600 dark:text-yellow-400 font-medium" };
const _sfc_main$1a = /* @__PURE__ */ defineComponent({
  __name: "FlashcardStats",
  setup(__props) {
    const { t } = useI18n();
    const { stats, getFormattedStats: formattedStats, isLoading } = useFlashcardDashboardStats();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1a, [
        createBaseVNode("div", _hoisted_2$17, [
          createBaseVNode("div", _hoisted_3$15, [
            _cache[0] || (_cache[0] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
              createBaseVNode("div", { class: "w-3 h-3 bg-gradient-to-r from-purple-400 to-pink-500 rounded-full mr-3" })
            ], -1)),
            createBaseVNode("h3", _hoisted_4$11, toDisplayString$1(unref(t)("dashboard.flashcardStats.title", "Flashcard Practice")), 1)
          ]),
          unref(isLoading) ? (openBlock(), createElementBlock("div", _hoisted_5$_, _cache[1] || (_cache[1] = [
            createBaseVNode("div", { class: "animate-spin rounded-full h-8 w-8 border-b-2 border-purple-500" }, null, -1)
          ]))) : unref(stats).totalSessions === 0 ? (openBlock(), createElementBlock("div", _hoisted_6$Y, [
            _cache[2] || (_cache[2] = createBaseVNode("div", { class: "w-16 h-16 bg-gradient-to-br from-purple-100 to-pink-100 dark:bg-gradient-to-br dark:from-purple-900/30 dark:to-pink-900/30 rounded-full flex items-center justify-center" }, [
              createBaseVNode("svg", {
                class: "w-8 h-8 text-purple-500 dark:text-purple-400",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"
                })
              ])
            ], -1)),
            createBaseVNode("div", null, [
              createBaseVNode("p", _hoisted_7$V, toDisplayString$1(unref(t)("dashboard.flashcardStats.noData", "No practice sessions yet")), 1),
              createBaseVNode("p", _hoisted_8$V, toDisplayString$1(unref(t)("dashboard.flashcardStats.startPracticing", "Start practicing to see your stats!")), 1)
            ])
          ])) : (openBlock(), createElementBlock("div", _hoisted_9$U, [
            createBaseVNode("div", _hoisted_10$T, [
              createBaseVNode("div", _hoisted_11$T, [
                createVNode(CircularProgress$2, {
                  value: unref(stats).totalSessions,
                  max: Math.max(unref(stats).totalSessions + 10, 50),
                  size: 110,
                  "stroke-width": 7,
                  "progress-color": "#8b5cf6",
                  "progress-color-secondary": "#a855f7",
                  "progress-color-tertiary": "#c084fc",
                  "background-color": "#1e1b4b",
                  label: unref(t)("dashboard.flashcardStats.sessions", "Sessions"),
                  "show-icon": "",
                  "show-shimmer": true,
                  "glow-effect": true,
                  "value-class": "text-lg sm:text-xl font-bold",
                  "animation-delay": 100
                }, {
                  icon: withCtx(() => _cache[3] || (_cache[3] = [
                    createBaseVNode("svg", {
                      class: "w-5 h-5",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", { d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" })
                    ], -1)
                  ])),
                  _: 1
                }, 8, ["value", "max", "label"])
              ]),
              createBaseVNode("div", _hoisted_12$S, [
                createVNode(CircularProgress$2, {
                  value: unref(stats).streakDays,
                  max: Math.max(unref(stats).streakDays + 5, 30),
                  size: 110,
                  "stroke-width": 7,
                  "progress-color": "#f97316",
                  "progress-color-secondary": "#fb923c",
                  "progress-color-tertiary": "#fdba74",
                  "background-color": "#7c2d12",
                  label: unref(t)("dashboard.flashcardStats.streak", "Streak"),
                  unit: unref(t)("dashboard.flashcardStats.days", "days"),
                  "show-icon": "",
                  "show-shimmer": true,
                  "glow-effect": true,
                  "value-class": "text-lg sm:text-xl font-bold",
                  "animation-delay": 200
                }, {
                  icon: withCtx(() => _cache[4] || (_cache[4] = [
                    createBaseVNode("svg", {
                      class: "w-5 h-5",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", { d: "M17.657 18.657A8 8 0 716.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975 0 0120 13a7.975 7.975 0 01-2.343 5.657z" })
                    ], -1)
                  ])),
                  _: 1
                }, 8, ["value", "max", "label", "unit"])
              ]),
              createBaseVNode("div", _hoisted_13$S, [
                createVNode(CircularProgress$2, {
                  value: unref(stats).averageAccuracy,
                  max: 100,
                  size: 110,
                  "stroke-width": 7,
                  "progress-color": "#10b981",
                  "progress-color-secondary": "#34d399",
                  "progress-color-tertiary": "#6ee7b7",
                  "background-color": "#064e3b",
                  label: unref(t)("dashboard.flashcardStats.accuracy", "Accuracy"),
                  unit: "%",
                  "show-icon": "",
                  "show-shimmer": true,
                  "glow-effect": true,
                  "value-class": "text-lg sm:text-xl font-bold",
                  "animation-delay": 300
                }, {
                  icon: withCtx(() => _cache[5] || (_cache[5] = [
                    createBaseVNode("svg", {
                      class: "w-5 h-5",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
                      })
                    ], -1)
                  ])),
                  _: 1
                }, 8, ["value", "label"]),
                createBaseVNode("p", {
                  class: normalizeClass(["text-xs font-medium mt-1", unref(formattedStats).accuracyLevel.color])
                }, toDisplayString$1(unref(formattedStats).accuracyLevel.level), 3)
              ]),
              createBaseVNode("div", _hoisted_14$R, [
                createVNode(CircularProgress$2, {
                  value: unref(stats).sessionsThisWeek,
                  max: 7,
                  size: 110,
                  "stroke-width": 7,
                  "progress-color": "#3b82f6",
                  "progress-color-secondary": "#60a5fa",
                  "progress-color-tertiary": "#93c5fd",
                  "background-color": "#1e3a8a",
                  label: unref(t)("dashboard.flashcardStats.weeklyProgress", "This Week"),
                  "show-icon": "",
                  "show-shimmer": true,
                  "glow-effect": true,
                  "value-class": "text-lg sm:text-xl font-bold",
                  "animation-delay": 400
                }, {
                  icon: withCtx(() => _cache[6] || (_cache[6] = [
                    createBaseVNode("svg", {
                      class: "w-5 h-5",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"
                      })
                    ], -1)
                  ])),
                  _: 1
                }, 8, ["value", "label"]),
                createBaseVNode("p", {
                  class: normalizeClass(["text-xs font-medium mt-1", unref(formattedStats).progressLevel.color])
                }, toDisplayString$1(unref(stats).sessionsThisWeek) + "/7 " + toDisplayString$1(unref(t)("dashboard.flashcardStats.sessions", "sessions")), 3)
              ])
            ]),
            createBaseVNode("div", _hoisted_15$L, [
              createBaseVNode("div", _hoisted_16$K, [
                createBaseVNode("div", _hoisted_17$J, [
                  createBaseVNode("span", _hoisted_18$H, toDisplayString$1(unref(t)("dashboard.flashcardStats.bestScore", "Best Score")), 1),
                  _cache[7] || (_cache[7] = createBaseVNode("div", { class: "w-6 h-6 bg-blue-100 dark:bg-blue-900/50 rounded-lg flex items-center justify-center group-hover/stat:scale-110 transition-transform duration-300" }, [
                    createBaseVNode("svg", {
                      class: "w-3 h-3 text-blue-600 dark:text-blue-400",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" })
                    ])
                  ], -1))
                ]),
                createBaseVNode("p", _hoisted_19$H, toDisplayString$1(unref(stats).bestScore), 1)
              ]),
              createBaseVNode("div", _hoisted_20$G, [
                createBaseVNode("div", _hoisted_21$G, [
                  createBaseVNode("span", _hoisted_22$E, toDisplayString$1(unref(t)("dashboard.flashcardStats.cardsStudied", "Cards Studied")), 1),
                  _cache[8] || (_cache[8] = createBaseVNode("div", { class: "w-6 h-6 bg-pink-100 dark:bg-pink-900/50 rounded-lg flex items-center justify-center group-hover/stat:scale-110 transition-transform duration-300" }, [
                    createBaseVNode("svg", {
                      class: "w-3 h-3 text-pink-600 dark:text-pink-400",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", { d: "M7 3a1 1 0 000 2h6a1 1 0 100-2H7zM4 7a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zM2 11a2 2 0 012-2h12a2 2 0 012 2v4a2 2 0 01-2 2H4a2 2 0 01-2-2v-4z" })
                    ])
                  ], -1))
                ]),
                createBaseVNode("p", _hoisted_23$E, toDisplayString$1(unref(stats).totalCardsStudied.toLocaleString()), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_24$D, [
              createBaseVNode("div", _hoisted_25$D, [
                _cache[9] || (_cache[9] = createBaseVNode("div", { class: "flex-shrink-0" }, [
                  createBaseVNode("div", { class: "w-8 h-8 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-lg flex items-center justify-center transform group-hover/activity:rotate-12 group-hover/activity:scale-110 transition-all duration-300" }, [
                    createBaseVNode("svg", {
                      class: "w-4 h-4 text-white",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                      })
                    ])
                  ])
                ], -1)),
                createBaseVNode("div", _hoisted_26$B, [
                  createBaseVNode("p", _hoisted_27$A, toDisplayString$1(unref(t)("dashboard.flashcardStats.totalTime", "Total Practice Time")), 1),
                  createBaseVNode("p", _hoisted_28$y, toDisplayString$1(unref(formattedStats).totalPracticeTimeFormatted), 1)
                ])
              ]),
              unref(stats).favoriteMode ? (openBlock(), createElementBlock("div", _hoisted_29$w, [
                _cache[10] || (_cache[10] = createBaseVNode("div", { class: "flex-shrink-0" }, [
                  createBaseVNode("div", { class: "w-8 h-8 bg-gradient-to-br from-yellow-500 to-orange-500 rounded-lg flex items-center justify-center transform group-hover/activity:rotate-12 group-hover/activity:scale-110 transition-all duration-300" }, [
                    createBaseVNode("svg", {
                      class: "w-4 h-4 text-white",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" })
                    ])
                  ])
                ], -1)),
                createBaseVNode("div", _hoisted_30$v, [
                  createBaseVNode("p", _hoisted_31$u, toDisplayString$1(unref(t)("dashboard.flashcardStats.favoriteMode", "Favorite Mode")), 1),
                  createBaseVNode("p", _hoisted_32$r, toDisplayString$1(unref(formattedStats).favoriteModeFormatted), 1)
                ])
              ])) : createCommentVNode("", true)
            ])
          ]))
        ])
      ]);
    };
  }
});

const FlashcardStats = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["__scopeId", "data-v-4522b048"]]);

const FlashcardStats$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: FlashcardStats
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$19 = { class: "flex flex-col items-center p-4" };
const _hoisted_2$16 = { class: "text-center mb-4 text-base font-medium" };
const _hoisted_3$14 = { class: "flex space-x-4" };
const _sfc_main$19 = /* @__PURE__ */ defineComponent({
  __name: "ConfirmToast",
  props: {
    message: {},
    confirmText: {},
    cancelText: {},
    onConfirm: { type: Function },
    onCancel: { type: Function }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$19, [
        createBaseVNode("p", _hoisted_2$16, toDisplayString$1(_ctx.message), 1),
        createBaseVNode("div", _hoisted_3$14, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = //@ts-ignore
            (...args) => _ctx.onConfirm && _ctx.onConfirm(...args)),
            class: "px-4 py-2 text-sm font-semibold text-white bg-green-600 border border-transparent rounded-md shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors"
          }, toDisplayString$1(_ctx.confirmText), 1),
          createBaseVNode("button", {
            onClick: _cache[1] || (_cache[1] = //@ts-ignore
            (...args) => _ctx.onCancel && _ctx.onCancel(...args)),
            class: "px-4 py-2 text-sm font-semibold text-white bg-red-600 border border-transparent rounded-md shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors"
          }, toDisplayString$1(_ctx.cancelText), 1)
        ])
      ]);
    };
  }
});

const ConfirmToast = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$19
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$18 = { class: "bg-white dark:bg-[#0a0a0a] shadow rounded-lg border border-gray-200 dark:border-dark-bg-mute overflow-hidden" };
const _hoisted_2$15 = ["aria-expanded"];
const _hoisted_3$13 = { class: "flex items-center space-x-3 flex-1 min-w-0" };
const _hoisted_4$10 = {
  key: 0,
  class: "flex-shrink-0"
};
const _hoisted_5$Z = {
  class: "w-5 h-5 xs:w-6 xs:h-6 text-blue-500 dark:text-blue-400",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_6$X = ["d"];
const _hoisted_7$U = { class: "flex-1 min-w-0" };
const _hoisted_8$U = { class: "text-sm xs:text-base sm:text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_9$T = {
  key: 0,
  class: "text-xs xs:text-sm text-gray-600 dark:text-white/70 mt-1"
};
const _hoisted_10$S = { class: "flex items-center justify-end space-x-3 mt-4 md:mt-0 md:ml-3" };
const _hoisted_11$S = {
  key: 0,
  class: "flex items-center space-x-3 mr-auto"
};
const _hoisted_12$R = { class: "text-xs sm:text-sm text-gray-600 dark:text-gray-400 truncate max-w-48 sm:max-w-64" };
const _hoisted_13$R = { class: "accordion-content" };
const _hoisted_14$Q = { class: "px-3 py-3 xs:px-4 xs:py-4 sm:px-5 sm:py-5" };
const _sfc_main$18 = /* @__PURE__ */ defineComponent({
  __name: "BaseAccordion",
  props: {
    title: {},
    description: {},
    icon: {},
    defaultOpen: { type: Boolean, default: true },
    persistKey: { default: void 0 },
    statusText: { default: void 0 },
    statusColor: { default: void 0 },
    showStatusWhenClosed: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const getInitialState = () => {
      if (props.persistKey && typeof localStorage !== "undefined") {
        try {
          const stored = localStorage.getItem(`accordion-${props.persistKey}`);
          return stored !== null ? JSON.parse(stored) : props.defaultOpen;
        } catch {
          return props.defaultOpen;
        }
      }
      return props.defaultOpen;
    };
    const isOpen = ref(getInitialState());
    const iconPaths = computed(() => {
      const iconMap = {
        "vocabulary": "M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z",
        "filter": "M3 3a1 1 0 011-1h12a1 1 0 011 1v3a1 1 0 01-.293.707L12 11.414V15a1 1 0 01-.293.707l-2 2A1 1 0 018 17v-5.586L3.293 6.707A1 1 0 013 6V3z",
        "settings": "M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z"
      };
      return iconMap[props.icon || ""] || null;
    });
    const toggle = () => {
      isOpen.value = !isOpen.value;
      if (props.persistKey && typeof localStorage !== "undefined") {
        try {
          localStorage.setItem(`accordion-${props.persistKey}`, JSON.stringify(isOpen.value));
        } catch {
        }
      }
    };
    const enter = (el) => {
      const element = el;
      element.style.height = "0";
      element.style.overflow = "hidden";
    };
    const afterEnter = (el) => {
      const element = el;
      element.style.height = "auto";
      element.style.overflow = "visible";
    };
    const leave = (el) => {
      const element = el;
      element.style.height = element.offsetHeight + "px";
      element.style.overflow = "hidden";
      element.offsetHeight;
      element.style.height = "0";
    };
    const afterLeave = (el) => {
      const element = el;
      element.style.height = "auto";
      element.style.overflow = "visible";
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$18, [
        createBaseVNode("button", {
          onClick: toggle,
          "aria-expanded": isOpen.value ? "true" : "false",
          class: "w-full flex flex-col md:flex-row md:items-center px-3 py-3 xs:px-4 xs:py-3 sm:px-5 sm:py-4 text-left bg-gray-50 dark:bg-[#0f0f0f] hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors border-b border-gray-200 dark:border-dark-bg-mute focus:outline-none focus:ring-2 focus:ring-blue-500"
        }, [
          createBaseVNode("div", _hoisted_3$13, [
            _ctx.icon && iconPaths.value ? (openBlock(), createElementBlock("div", _hoisted_4$10, [
              (openBlock(), createElementBlock("svg", _hoisted_5$Z, [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: iconPaths.value,
                  "clip-rule": "evenodd"
                }, null, 8, _hoisted_6$X)
              ]))
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_7$U, [
              createBaseVNode("h3", _hoisted_8$U, toDisplayString$1(_ctx.title), 1),
              _ctx.description ? (openBlock(), createElementBlock("p", _hoisted_9$T, toDisplayString$1(_ctx.description), 1)) : createCommentVNode("", true)
            ])
          ]),
          createBaseVNode("div", _hoisted_10$S, [
            _ctx.statusText && _ctx.showStatusWhenClosed && !isOpen.value ? (openBlock(), createElementBlock("div", _hoisted_11$S, [
              _ctx.statusColor ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(["h-2 w-2 rounded-full", _ctx.statusColor])
              }, null, 2)) : createCommentVNode("", true),
              createBaseVNode("span", _hoisted_12$R, toDisplayString$1(_ctx.statusText), 1)
            ])) : createCommentVNode("", true),
            (openBlock(), createElementBlock("svg", {
              class: normalizeClass(["w-5 h-5 text-gray-500 dark:text-white/60 transition-transform duration-200 flex-shrink-0", { "rotate-180": isOpen.value }]),
              fill: "none",
              stroke: "currentColor",
              viewBox: "0 0 24 24"
            }, _cache[0] || (_cache[0] = [
              createBaseVNode("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M19 9l-7 7-7-7"
              }, null, -1)
            ]), 2))
          ])
        ], 8, _hoisted_2$15),
        createVNode(Transition, {
          name: "accordion",
          onEnter: enter,
          onAfterEnter: afterEnter,
          onLeave: leave,
          onAfterLeave: afterLeave
        }, {
          default: withCtx(() => [
            withDirectives(createBaseVNode("div", _hoisted_13$R, [
              createBaseVNode("div", _hoisted_14$Q, [
                renderSlot(_ctx.$slots, "default", {}, void 0, true)
              ])
            ], 512), [
              [vShow, isOpen.value]
            ])
          ]),
          _: 3
        })
      ]);
    };
  }
});

const BaseAccordion = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["__scopeId", "data-v-f39e0c05"]]);

const BaseAccordion$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: BaseAccordion
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$17 = { class: "p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_2$14 = { class: "flex items-center justify-between mb-3 sm:mb-4" };
const _hoisted_3$12 = { class: "flex items-center space-x-2 sm:space-x-3" };
const _hoisted_4$$ = { class: "text-xs sm:text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_5$Y = { class: "text-xs text-gray-500 dark:text-gray-400 hidden sm:block" };
const _hoisted_6$W = {
  key: 0,
  class: "flex items-center justify-between pt-3 sm:pt-4 border-t border-gray-200 dark:border-gray-700 mb-3 sm:mb-4"
};
const _hoisted_7$T = { class: "flex items-center space-x-2 sm:space-x-3" };
const _hoisted_8$T = { class: "text-xs sm:text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_9$S = { class: "text-xs text-gray-500 dark:text-gray-400 hidden sm:block" };
const _hoisted_10$R = {
  key: 1,
  class: "flex items-center justify-between pt-3 sm:pt-4 border-t border-gray-200 dark:border-gray-700"
};
const _hoisted_11$R = { class: "flex items-center space-x-2 sm:space-x-3" };
const _hoisted_12$Q = { class: "text-xs sm:text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_13$Q = { class: "text-xs text-gray-500 dark:text-gray-400 hidden sm:block" };
const _sfc_main$17 = /* @__PURE__ */ defineComponent({
  __name: "GroupingToggle",
  props: {
    modelValue: { type: Boolean },
    hoverEnabled: { type: Boolean },
    moveMode: { type: Boolean }
  },
  emits: ["update:modelValue", "update:hoverEnabled", "update:moveMode"],
  setup(__props, { emit: __emit }) {
    const BaseAccordion = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => BaseAccordion$1),true              ?void 0:void 0));
    const emit = __emit;
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(BaseAccordion), {
        title: unref(t)("vocabulary.grouping.accordionTitle", "Group by Date Settings"),
        description: unref(t)("vocabulary.grouping.accordionDescription", "Configure how vocabulary is grouped and displayed"),
        icon: "vocabulary",
        "default-open": true,
        "persist-key": "vocabulary-grouping",
        class: "mb-4 sm:mb-6"
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$17, [
            createBaseVNode("div", _hoisted_2$14, [
              createBaseVNode("div", _hoisted_3$12, [
                _cache[3] || (_cache[3] = createBaseVNode("svg", {
                  class: "w-4 h-4 sm:w-5 sm:h-5 text-gray-500 dark:text-gray-400",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z",
                    "clip-rule": "evenodd"
                  })
                ], -1)),
                createBaseVNode("div", null, [
                  createBaseVNode("h3", _hoisted_4$$, toDisplayString$1(unref(t)("vocabulary.grouping.title", "Group by Date")), 1),
                  createBaseVNode("p", _hoisted_5$Y, toDisplayString$1(unref(t)("vocabulary.grouping.description", "Group vocabulary words by creation date")), 1)
                ])
              ]),
              createBaseVNode("button", {
                onClick: _cache[0] || (_cache[0] = ($event) => emit("update:modelValue", !_ctx.modelValue)),
                class: normalizeClass([
                  "relative inline-flex items-center rounded-full transition-colors",
                  "h-5 w-9 sm:h-6 sm:w-11",
                  _ctx.modelValue ? "bg-blue-600" : "bg-gray-200 dark:bg-gray-600"
                ])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass([
                    "inline-block transform rounded-full bg-white transition-transform",
                    "h-3 w-3 sm:h-4 sm:w-4",
                    _ctx.modelValue ? "translate-x-5 sm:translate-x-6" : "translate-x-1"
                  ])
                }, null, 2)
              ], 2)
            ]),
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_6$W, [
              createBaseVNode("div", _hoisted_7$T, [
                _cache[4] || (_cache[4] = createBaseVNode("svg", {
                  class: "w-4 h-4 sm:w-5 sm:h-5 text-gray-500 dark:text-gray-400",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z",
                    "clip-rule": "evenodd"
                  })
                ], -1)),
                createBaseVNode("div", null, [
                  createBaseVNode("h3", _hoisted_8$T, toDisplayString$1(unref(t)("vocabulary.grouping.hoverToExpand", "Hover to Expand")), 1),
                  createBaseVNode("p", _hoisted_9$S, toDisplayString$1(unref(t)("vocabulary.grouping.hoverDescription", "Expand date groups on hover instead of click")), 1)
                ])
              ]),
              createBaseVNode("button", {
                onClick: _cache[1] || (_cache[1] = ($event) => emit("update:hoverEnabled", !_ctx.hoverEnabled)),
                class: normalizeClass([
                  "relative inline-flex items-center rounded-full transition-colors",
                  "h-5 w-9 sm:h-6 sm:w-11",
                  _ctx.hoverEnabled ? "bg-blue-600" : "bg-gray-200 dark:bg-gray-600"
                ])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass([
                    "inline-block transform rounded-full bg-white transition-transform",
                    "h-3 w-3 sm:h-4 sm:w-4",
                    _ctx.hoverEnabled ? "translate-x-5 sm:translate-x-6" : "translate-x-1"
                  ])
                }, null, 2)
              ], 2)
            ])) : createCommentVNode("", true),
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_10$R, [
              createBaseVNode("div", _hoisted_11$R, [
                _cache[5] || (_cache[5] = createBaseVNode("svg", {
                  class: "w-4 h-4 sm:w-5 sm:h-5 text-gray-500 dark:text-gray-400",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z",
                    "clip-rule": "evenodd"
                  })
                ], -1)),
                createBaseVNode("div", null, [
                  createBaseVNode("h3", _hoisted_12$Q, toDisplayString$1(unref(t)("vocabulary.moveMode.title", "Move Mode")), 1),
                  createBaseVNode("p", _hoisted_13$Q, toDisplayString$1(_ctx.moveMode ? unref(t)("vocabulary.moveMode.active", "Active - Click arrows to move words") : unref(t)("vocabulary.moveMode.inactive", "Inactive - Enable to show move arrows")), 1)
                ])
              ]),
              createBaseVNode("button", {
                onClick: _cache[2] || (_cache[2] = ($event) => emit("update:moveMode", !_ctx.moveMode)),
                class: normalizeClass([
                  "relative inline-flex items-center rounded-full transition-colors",
                  "h-5 w-9 sm:h-6 sm:w-11",
                  _ctx.moveMode ? "bg-blue-600" : "bg-gray-200 dark:bg-gray-600"
                ])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass([
                    "inline-block transform rounded-full bg-white transition-transform",
                    "h-3 w-3 sm:h-4 sm:w-4",
                    _ctx.moveMode ? "translate-x-5 sm:translate-x-6" : "translate-x-1"
                  ])
                }, null, 2)
              ], 2)
            ])) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }, 8, ["title", "description"]);
    };
  }
});

const GroupingToggle = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$17
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$16 = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg shadow border border-gray-200 dark:border-gray-700 p-4 sm:p-5 mb-6" };
const _hoisted_2$13 = { class: "flex flex-col md:flex-row md:items-center md:justify-between gap-3 sm:gap-4" };
const _hoisted_3$11 = { class: "flex items-center space-x-4 sm:space-x-4" };
const _hoisted_4$_ = { class: "flex flex-col space-y-0.5 sm:space-y-1" };
const _hoisted_5$X = { class: "text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_6$V = { class: "text-xs text-gray-500 dark:text-gray-400" };
const _sfc_main$16 = /* @__PURE__ */ defineComponent({
  __name: "TopicManagerPanel",
  emits: ["open"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$16, [
        createBaseVNode("div", _hoisted_2$13, [
          createBaseVNode("div", _hoisted_3$11, [
            _cache[1] || (_cache[1] = createBaseVNode("svg", {
              class: "w-5 h-5 text-gray-500 dark:text-gray-400",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z",
                "clip-rule": "evenodd"
              })
            ], -1)),
            createBaseVNode("div", _hoisted_4$_, [
              createBaseVNode("h3", _hoisted_5$X, toDisplayString$1(unref(t)("vocabulary.topicManager.title", "Topic Manager")), 1),
              createBaseVNode("p", _hoisted_6$V, toDisplayString$1(unref(t)("vocabulary.topicManager.builtInTopicsDescription", "Manage built-in topics and categories")), 1)
            ])
          ]),
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => emit("open")),
            class: "px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white text-sm font-medium rounded-lg transition-colors flex items-center space-x-2 self-start md:self-auto mt-3 sm:mt-3 md:mt-0 w-full md:w-auto"
          }, [
            _cache[2] || (_cache[2] = createBaseVNode("svg", {
              class: "h-4 w-4",
              fill: "none",
              stroke: "currentColor",
              viewBox: "0 0 24 24"
            }, [
              createBaseVNode("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M12 6v6m0 0v6m0-6h6m-6 0H6"
              })
            ], -1)),
            createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.topicManager.manageTopics", "Manage Topics")), 1)
          ])
        ])
      ]);
    };
  }
});

const TopicManagerPanel = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$16
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$15 = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-[#0f0f0f] mb-6 overflow-hidden" };
const _hoisted_2$12 = { class: "bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0f0f0f] dark:to-[#0a0a0a] px-3 xs:px-4 sm:px-6 py-3 xs:py-4 border-b border-gray-200 dark:border-[#0f0f0f]" };
const _hoisted_3$10 = { class: "block sm:hidden" };
const _hoisted_4$Z = { class: "flex items-center justify-between mb-3" };
const _hoisted_5$W = { class: "flex items-center space-x-2" };
const _hoisted_6$U = { class: "text-base xs:text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_7$S = { class: "flex items-center justify-between" };
const _hoisted_8$S = { class: "text-xs xs:text-sm text-gray-500 dark:text-gray-400 flex-1 pr-2" };
const _hoisted_9$R = { class: "text-xs font-medium text-gray-600 dark:text-gray-400 flex-shrink-0" };
const _hoisted_10$Q = { class: "hidden sm:block" };
const _hoisted_11$Q = { class: "flex items-center justify-between" };
const _hoisted_12$P = { class: "flex items-center space-x-3" };
const _hoisted_13$P = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_14$P = { class: "text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_15$K = { class: "flex items-center space-x-3" };
const _hoisted_16$J = { class: "text-sm font-medium text-gray-600 dark:text-gray-400" };
const _hoisted_17$I = { class: "p-3 xs:p-4 sm:p-6" };
const _hoisted_18$G = { class: "grid grid-cols-1 lg:grid-cols-3 gap-6 xs:gap-8 sm:gap-10" };
const _hoisted_19$G = { class: "lg:col-span-2 space-y-4 xs:space-y-6" };
const _hoisted_20$F = {
  key: 0,
  class: "bg-green-50 dark:bg-green-900/10 border border-green-200 dark:border-green-800 rounded-lg p-3 xs:p-4"
};
const _hoisted_21$F = { class: "text-xs xs:text-sm font-medium text-green-800 dark:text-green-400 mb-2 xs:mb-3" };
const _hoisted_22$D = ["disabled"];
const _hoisted_23$D = {
  key: 0,
  class: "animate-spin h-3 xs:h-4 w-3 xs:w-4",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _hoisted_24$C = {
  key: 1,
  class: "h-3 xs:h-4 w-3 xs:w-4",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_25$C = {
  key: 1,
  class: "bg-blue-50 dark:bg-blue-900/10 border border-blue-200 dark:border-blue-800 rounded-lg p-3 xs:p-4"
};
const _hoisted_26$A = { class: "text-xs xs:text-sm font-medium text-blue-800 dark:text-blue-400 mb-2 xs:mb-3" };
const _hoisted_27$z = { class: "mb-3 xs:mb-4" };
const _hoisted_28$x = { class: "block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1.5 xs:mb-2" };
const _hoisted_29$v = ["value"];
const _hoisted_30$u = { value: "local" };
const _hoisted_31$t = { value: "google-drive" };
const _hoisted_32$q = { class: "space-y-1.5 xs:space-y-2" };
const _hoisted_33$q = { class: "bg-purple-50 dark:bg-purple-900/10 border border-purple-200 dark:border-purple-800 rounded-lg p-3 xs:p-4" };
const _hoisted_34$n = { class: "text-xs xs:text-sm font-medium text-purple-800 dark:text-purple-400 mb-2 xs:mb-3" };
const _hoisted_35$n = { class: "space-y-2 xs:space-y-2.5" };
const _hoisted_36$m = { class: "relative" };
const _hoisted_37$l = { class: "space-y-3 xs:space-y-4" };
const _hoisted_38$l = { class: "bg-gray-50 dark:bg-[#0f0f0f] border border-gray-200 dark:border-[#0f0f0f] rounded-lg p-3 xs:p-4" };
const _hoisted_39$j = { class: "text-xs xs:text-sm font-medium text-gray-800 dark:text-gray-200 mb-2 xs:mb-3" };
const _hoisted_40$j = { class: "space-y-2 xs:space-y-3" };
const _hoisted_41$i = { class: "flex items-center space-x-1.5 xs:space-x-2" };
const _hoisted_42$g = { class: "text-xs xs:text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_43$f = { class: "flex items-center space-x-1.5 xs:space-x-2 text-xs xs:text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_44$e = { class: "truncate" };
const _hoisted_45$d = {
  key: 0,
  class: "bg-indigo-50 dark:bg-indigo-900/10 border border-indigo-200 dark:border-indigo-800 rounded-lg p-3 xs:p-4"
};
const _hoisted_46$d = { class: "text-xs xs:text-sm font-medium text-indigo-800 dark:text-indigo-400 mb-2 xs:mb-3" };
const _hoisted_47$d = { class: "text-xs xs:text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_48$d = { class: "mb-1.5 xs:mb-2" };
const _hoisted_49$c = { class: "font-medium" };
const _hoisted_50$b = {
  key: 0,
  class: "text-xs text-green-600 dark:text-green-400"
};
const _hoisted_51$a = {
  key: 1,
  class: "space-y-1"
};
const _hoisted_52$a = { class: "text-xs text-green-600 dark:text-green-400" };
const _hoisted_53$a = {
  key: 0,
  class: "text-xs text-gray-600 dark:text-gray-400"
};
const _hoisted_54$a = { class: "font-medium" };
const _hoisted_55$a = {
  key: 1,
  class: "text-xs text-yellow-600 dark:text-yellow-400"
};
const AUTO_SAVE_KEY = "vocabulary-auto-save-enabled";
const STORAGE_TYPE_KEY = "vocabulary-storage-type";
const HAS_AUTO_SAVE_FILE_KEY = "vocabulary-has-auto-save-file";
const HAS_GOOGLE_DRIVE_FILE_KEY = "vocabulary-has-google-drive-file";
const IS_GOOGLE_SIGNED_IN_KEY = "vocabulary-is-google-signed-in";
const AUTO_SAVE_FILE_PATH_KEY = "vocabulary-auto-save-file-path";
const _sfc_main$15 = /* @__PURE__ */ defineComponent({
  __name: "SaveControlPanel",
  props: {
    autoSaveEnabled: { type: Boolean },
    isSaving: { type: Boolean },
    hasAutoSaveFile: { type: Boolean },
    hasGoogleDriveFile: { type: Boolean },
    isGoogleSignedIn: { type: Boolean },
    googleUserEmail: {},
    lastSaveTime: {},
    saveStatusColor: {},
    saveStatusText: {},
    autoSaveFilePath: {},
    storageType: {}
  },
  emits: [
    "update:autoSaveEnabled",
    "update:storageType",
    "update:hasAutoSaveFile",
    "update:hasGoogleDriveFile",
    "update:isGoogleSignedIn",
    "update:autoSaveFilePath",
    "manual-save",
    "setup-auto-save",
    "reset-auto-save",
    "import-file",
    "google-sign-in",
    "google-sign-out",
    "setup-google-drive",
    "sync-from-google-drive"
  ],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const fileInputRef = ref(null);
    const loadAutoSaveEnabled = () => {
      try {
        const saved = localStorage.getItem(AUTO_SAVE_KEY);
        return saved !== null ? JSON.parse(saved) : null;
      } catch (error) {
        console.warn("Failed to load auto save setting from localStorage:", error);
        return null;
      }
    };
    const saveAutoSaveEnabled = (enabled) => {
      try {
        localStorage.setItem(AUTO_SAVE_KEY, JSON.stringify(enabled));
      } catch (error) {
        console.warn("Failed to save auto save setting to localStorage:", error);
      }
    };
    const loadStorageType = () => {
      try {
        const saved = localStorage.getItem(STORAGE_TYPE_KEY);
        if (saved && (saved === "local" || saved === "google-drive")) {
          return saved;
        }
        return null;
      } catch (error) {
        console.warn("Failed to load storage type from localStorage:", error);
        return null;
      }
    };
    const saveStorageType = (type) => {
      try {
        localStorage.setItem(STORAGE_TYPE_KEY, type);
      } catch (error) {
        console.warn("Failed to save storage type to localStorage:", error);
      }
    };
    const loadHasAutoSaveFile = () => {
      try {
        const saved = localStorage.getItem(HAS_AUTO_SAVE_FILE_KEY);
        return saved !== null ? JSON.parse(saved) : null;
      } catch (error) {
        console.warn("Failed to load auto save file state from localStorage:", error);
        return null;
      }
    };
    const saveHasAutoSaveFile = (hasFile) => {
      try {
        localStorage.setItem(HAS_AUTO_SAVE_FILE_KEY, JSON.stringify(hasFile));
      } catch (error) {
        console.warn("Failed to save auto save file state to localStorage:", error);
      }
    };
    const loadHasGoogleDriveFile = () => {
      try {
        const saved = localStorage.getItem(HAS_GOOGLE_DRIVE_FILE_KEY);
        return saved !== null ? JSON.parse(saved) : null;
      } catch (error) {
        console.warn("Failed to load Google Drive file state from localStorage:", error);
        return null;
      }
    };
    const saveHasGoogleDriveFile = (hasFile) => {
      try {
        localStorage.setItem(HAS_GOOGLE_DRIVE_FILE_KEY, JSON.stringify(hasFile));
      } catch (error) {
        console.warn("Failed to save Google Drive file state to localStorage:", error);
      }
    };
    const loadIsGoogleSignedIn = () => {
      try {
        const saved = localStorage.getItem(IS_GOOGLE_SIGNED_IN_KEY);
        return saved !== null ? JSON.parse(saved) : null;
      } catch (error) {
        console.warn("Failed to load Google sign-in state from localStorage:", error);
        return null;
      }
    };
    const saveIsGoogleSignedIn = (isSignedIn) => {
      try {
        localStorage.setItem(IS_GOOGLE_SIGNED_IN_KEY, JSON.stringify(isSignedIn));
      } catch (error) {
        console.warn("Failed to save Google sign-in state to localStorage:", error);
      }
    };
    const loadAutoSaveFilePath = () => {
      try {
        return localStorage.getItem(AUTO_SAVE_FILE_PATH_KEY);
      } catch (error) {
        console.warn("Failed to load auto save file path from localStorage:", error);
        return null;
      }
    };
    const saveAutoSaveFilePath = (filePath) => {
      try {
        localStorage.setItem(AUTO_SAVE_FILE_PATH_KEY, filePath);
      } catch (error) {
        console.warn("Failed to save auto save file path to localStorage:", error);
      }
    };
    watch(
      () => props.autoSaveEnabled,
      (newValue) => {
        saveAutoSaveEnabled(newValue);
      }
    );
    watch(
      () => props.storageType,
      (newValue) => {
        saveStorageType(newValue);
      }
    );
    watch(
      () => props.hasAutoSaveFile,
      (newValue) => {
        saveHasAutoSaveFile(newValue);
      }
    );
    watch(
      () => props.hasGoogleDriveFile,
      (newValue) => {
        saveHasGoogleDriveFile(newValue);
      }
    );
    watch(
      () => props.isGoogleSignedIn,
      (newValue) => {
        saveIsGoogleSignedIn(newValue);
      }
    );
    watch(
      () => props.autoSaveFilePath,
      (newValue) => {
        if (newValue) {
          saveAutoSaveFilePath(newValue);
        }
      }
    );
    onMounted(() => {
      const savedAutoSave = loadAutoSaveEnabled();
      const savedStorageType = loadStorageType();
      const savedHasAutoSaveFile = loadHasAutoSaveFile();
      const savedHasGoogleDriveFile = loadHasGoogleDriveFile();
      const savedIsGoogleSignedIn = loadIsGoogleSignedIn();
      const savedAutoSaveFilePath = loadAutoSaveFilePath();
      if (savedAutoSave !== null && savedAutoSave !== props.autoSaveEnabled) {
        emit("update:autoSaveEnabled", savedAutoSave);
      }
      if (savedStorageType !== null && savedStorageType !== props.storageType) {
        emit("update:storageType", savedStorageType);
      }
      if (savedHasAutoSaveFile !== null && savedHasAutoSaveFile !== props.hasAutoSaveFile) {
        emit("update:hasAutoSaveFile", savedHasAutoSaveFile);
      }
      if (savedHasGoogleDriveFile !== null && savedHasGoogleDriveFile !== props.hasGoogleDriveFile) {
        emit("update:hasGoogleDriveFile", savedHasGoogleDriveFile);
      }
      if (savedIsGoogleSignedIn !== null && savedIsGoogleSignedIn !== props.isGoogleSignedIn) {
        emit("update:isGoogleSignedIn", savedIsGoogleSignedIn);
      }
      if (savedAutoSaveFilePath !== null && savedAutoSaveFilePath !== props.autoSaveFilePath) {
        emit("update:autoSaveFilePath", savedAutoSaveFilePath);
      }
    });
    const formattedLastSave = computed(() => {
      const notSaved = t("vocabulary.save.notSaved", "Not saved");
      if (!props.lastSaveTime) {
        return notSaved;
      }
      const result = t("vocabulary.save.lastSave", { time: props.lastSaveTime }, "Last save: {time}");
      if (result && result.includes("{time}")) {
        return result.replace("{time}", props.lastSaveTime);
      }
      return result || `Last save: ${props.lastSaveTime}`;
    });
    const handleStorageTypeChange = (event) => {
      const target = event.target;
      emit("update:storageType", target.value);
    };
    const openFilePicker = () => {
      fileInputRef.value?.click();
    };
    const handleFileSelected = (event) => {
      const target = event.target;
      if (target.files && target.files.length > 0) {
        emit("import-file", target.files[0]);
        target.value = "";
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1$15, [
          createBaseVNode("div", _hoisted_2$12, [
            createBaseVNode("div", _hoisted_3$10, [
              createBaseVNode("div", _hoisted_4$Z, [
                createBaseVNode("div", _hoisted_5$W, [
                  _cache[8] || (_cache[8] = createBaseVNode("div", { class: "p-1.5 bg-blue-100 dark:bg-blue-900/20 rounded-lg" }, [
                    createBaseVNode("svg", {
                      class: "h-4 w-4 text-blue-600 dark:text-blue-400",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3-3m0 0l-3 3m3-3v12"
                      })
                    ])
                  ], -1)),
                  createBaseVNode("div", null, [
                    createBaseVNode("h3", _hoisted_6$U, toDisplayString$1(unref(t)("vocabulary.save.title", "Save & Sync")), 1)
                  ])
                ]),
                createBaseVNode("button", {
                  onClick: _cache[0] || (_cache[0] = ($event) => emit("update:autoSaveEnabled", !_ctx.autoSaveEnabled)),
                  class: normalizeClass([
                    "relative inline-flex h-5 w-9 items-center rounded-full transition-colors duration-200 flex-shrink-0",
                    _ctx.autoSaveEnabled ? "bg-blue-600" : "bg-gray-200 dark:bg-gray-600"
                  ])
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass([
                      "inline-block h-3 w-3 transform rounded-full bg-white transition-transform duration-200",
                      _ctx.autoSaveEnabled ? "translate-x-5" : "translate-x-1"
                    ])
                  }, null, 2)
                ], 2)
              ]),
              createBaseVNode("div", _hoisted_7$S, [
                createBaseVNode("p", _hoisted_8$S, toDisplayString$1(unref(t)("vocabulary.save.subtitle", "Manage your vocabulary data storage")), 1),
                createBaseVNode("span", _hoisted_9$R, toDisplayString$1(_ctx.autoSaveEnabled ? unref(t)("vocabulary.save.auto", "Auto") : unref(t)("vocabulary.save.manual", "Manual")), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_10$Q, [
              createBaseVNode("div", _hoisted_11$Q, [
                createBaseVNode("div", _hoisted_12$P, [
                  _cache[9] || (_cache[9] = createBaseVNode("div", { class: "p-2 bg-blue-100 dark:bg-blue-900/20 rounded-lg" }, [
                    createBaseVNode("svg", {
                      class: "h-5 w-5 text-blue-600 dark:text-blue-400",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3-3m0 0l-3 3m3-3v12"
                      })
                    ])
                  ], -1)),
                  createBaseVNode("div", null, [
                    createBaseVNode("h3", _hoisted_13$P, toDisplayString$1(unref(t)("vocabulary.save.title", "Save & Sync")), 1),
                    createBaseVNode("p", _hoisted_14$P, toDisplayString$1(unref(t)("vocabulary.save.subtitle", "Manage your vocabulary data storage")), 1)
                  ])
                ]),
                createBaseVNode("div", _hoisted_15$K, [
                  createBaseVNode("button", {
                    onClick: _cache[1] || (_cache[1] = ($event) => emit("update:autoSaveEnabled", !_ctx.autoSaveEnabled)),
                    class: normalizeClass([
                      "relative inline-flex h-6 w-11 items-center rounded-full transition-colors duration-200 flex-shrink-0",
                      _ctx.autoSaveEnabled ? "bg-blue-600" : "bg-gray-200 dark:bg-gray-600"
                    ])
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass([
                        "inline-block h-4 w-4 transform rounded-full bg-white transition-transform duration-200",
                        _ctx.autoSaveEnabled ? "translate-x-6" : "translate-x-1"
                      ])
                    }, null, 2)
                  ], 2),
                  createBaseVNode("span", _hoisted_16$J, toDisplayString$1(_ctx.autoSaveEnabled ? unref(t)("vocabulary.save.auto", "Auto") : unref(t)("vocabulary.save.manual", "Manual")), 1)
                ])
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_17$I, [
          createBaseVNode("div", _hoisted_18$G, [
            createBaseVNode("div", _hoisted_19$G, [
              !_ctx.autoSaveEnabled ? (openBlock(), createElementBlock("div", _hoisted_20$F, [
                createBaseVNode("h4", _hoisted_21$F, toDisplayString$1(unref(t)("vocabulary.save.manualMode", "Manual Save Mode")), 1),
                createBaseVNode("button", {
                  onClick: _cache[2] || (_cache[2] = ($event) => emit("manual-save")),
                  disabled: _ctx.isSaving,
                  class: "w-full px-3 xs:px-4 py-2 xs:py-2.5 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 text-white text-sm xs:text-base font-medium rounded-lg transition-all duration-200 flex items-center justify-center space-x-2 hover:shadow-md"
                }, [
                  _ctx.isSaving ? (openBlock(), createElementBlock("svg", _hoisted_23$D, _cache[10] || (_cache[10] = [
                    createBaseVNode("circle", {
                      class: "opacity-25",
                      cx: "12",
                      cy: "12",
                      r: "10",
                      stroke: "currentColor",
                      "stroke-width": "4"
                    }, null, -1),
                    createBaseVNode("path", {
                      class: "opacity-75",
                      fill: "currentColor",
                      d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    }, null, -1)
                  ]))) : (openBlock(), createElementBlock("svg", _hoisted_24$C, _cache[11] || (_cache[11] = [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3-3m0 0l-3 3m3-3v12"
                    }, null, -1)
                  ]))),
                  createBaseVNode("span", null, toDisplayString$1(_ctx.isSaving ? unref(t)("common.saving", "Saving...") : unref(t)("vocabulary.save.saveNow", "Save Now")), 1)
                ], 8, _hoisted_22$D)
              ])) : createCommentVNode("", true),
              _ctx.autoSaveEnabled ? (openBlock(), createElementBlock("div", _hoisted_25$C, [
                createBaseVNode("h4", _hoisted_26$A, toDisplayString$1(unref(t)("vocabulary.save.autoMode", "Auto Save Configuration")), 1),
                createBaseVNode("div", _hoisted_27$z, [
                  createBaseVNode("label", _hoisted_28$x, toDisplayString$1(unref(t)("vocabulary.save.storageType", "Storage Type")), 1),
                  createBaseVNode("select", {
                    value: _ctx.storageType,
                    onChange: handleStorageTypeChange,
                    class: "w-full px-2.5 xs:px-3 py-1.5 xs:py-2 text-xs xs:text-sm border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-colors"
                  }, [
                    createBaseVNode("option", _hoisted_30$u, toDisplayString$1(unref(t)("vocabulary.save.localStorage", "Local File")), 1),
                    createBaseVNode("option", _hoisted_31$t, toDisplayString$1(unref(t)("vocabulary.save.googleDrive", "Google Drive")), 1)
                  ], 40, _hoisted_29$v)
                ]),
                createBaseVNode("div", _hoisted_32$q, [
                  _ctx.storageType === "local" && !_ctx.hasAutoSaveFile ? (openBlock(), createElementBlock("button", {
                    key: 0,
                    onClick: _cache[3] || (_cache[3] = ($event) => emit("setup-auto-save")),
                    class: "w-full px-3 xs:px-4 py-2 xs:py-2.5 bg-orange-600 hover:bg-orange-700 text-white text-sm xs:text-base font-medium rounded-lg transition-all duration-200 flex items-center justify-center space-x-1.5 xs:space-x-2 hover:shadow-md"
                  }, [
                    _cache[12] || (_cache[12] = createBaseVNode("svg", {
                      class: "h-3 xs:h-4 w-3 xs:w-4",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M12 6v6m0 0v6m0-6h6m-6 0H6"
                      })
                    ], -1)),
                    createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.save.chooseAutoFile", "Choose Auto File")), 1)
                  ])) : createCommentVNode("", true),
                  _ctx.storageType === "google-drive" && !_ctx.isGoogleSignedIn ? (openBlock(), createElementBlock("button", {
                    key: 1,
                    onClick: _cache[4] || (_cache[4] = ($event) => emit("google-sign-in")),
                    class: "w-full px-3 xs:px-4 py-2 xs:py-2.5 bg-red-600 hover:bg-red-700 text-white text-sm xs:text-base font-medium rounded-lg transition-all duration-200 flex items-center justify-center space-x-1.5 xs:space-x-2 hover:shadow-md"
                  }, [
                    _cache[13] || (_cache[13] = createBaseVNode("svg", {
                      class: "h-3 xs:h-4 w-3 xs:w-4",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013 3v1"
                      })
                    ], -1)),
                    createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.save.signInGoogle", "Sign in Google")), 1)
                  ])) : createCommentVNode("", true),
                  _ctx.storageType === "google-drive" && _ctx.isGoogleSignedIn && !_ctx.hasGoogleDriveFile ? (openBlock(), createElementBlock("button", {
                    key: 2,
                    onClick: _cache[5] || (_cache[5] = ($event) => emit("setup-google-drive")),
                    class: "w-full px-3 xs:px-4 py-2 xs:py-2.5 bg-blue-600 hover:bg-blue-700 text-white text-sm xs:text-base font-medium rounded-lg transition-all duration-200 flex items-center justify-center space-x-1.5 xs:space-x-2 hover:shadow-md"
                  }, [
                    _cache[14] || (_cache[14] = createBaseVNode("svg", {
                      class: "h-3 xs:h-4 w-3 xs:w-4",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
                      })
                    ], -1)),
                    createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.save.setupDrive", "Setup Google Drive")), 1)
                  ])) : createCommentVNode("", true),
                  _ctx.storageType === "google-drive" && _ctx.isGoogleSignedIn && _ctx.hasGoogleDriveFile ? (openBlock(), createElementBlock("button", {
                    key: 3,
                    onClick: _cache[6] || (_cache[6] = ($event) => emit("sync-from-google-drive")),
                    class: "w-full px-3 xs:px-4 py-2 xs:py-2.5 bg-green-600 hover:bg-green-700 text-white text-sm xs:text-base font-medium rounded-lg transition-all duration-200 flex items-center justify-center space-x-1.5 xs:space-x-2 hover:shadow-md"
                  }, [
                    _cache[15] || (_cache[15] = createBaseVNode("svg", {
                      class: "h-3 xs:h-4 w-3 xs:w-4",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                      })
                    ], -1)),
                    createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.save.syncFromDrive", "Sync from Drive")), 1)
                  ])) : createCommentVNode("", true),
                  _ctx.storageType === "local" && _ctx.hasAutoSaveFile || _ctx.storageType === "google-drive" && _ctx.isGoogleSignedIn ? (openBlock(), createElementBlock("button", {
                    key: 4,
                    onClick: _cache[7] || (_cache[7] = ($event) => _ctx.storageType === "local" ? emit("reset-auto-save") : emit("google-sign-out")),
                    class: "w-full px-3 xs:px-4 py-2 xs:py-2.5 bg-gray-500 hover:bg-gray-600 text-white text-sm xs:text-base font-medium rounded-lg transition-all duration-200 flex items-center justify-center space-x-1.5 xs:space-x-2 hover:shadow-md"
                  }, [
                    _cache[16] || (_cache[16] = createBaseVNode("svg", {
                      class: "h-3 xs:h-4 w-3 xs:w-4",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                      })
                    ], -1)),
                    createBaseVNode("span", null, toDisplayString$1(_ctx.storageType === "local" ? unref(t)("vocabulary.save.changeAutoFile", "Change Auto File") : unref(t)("vocabulary.save.signOutGoogle", "Sign Out Google")), 1)
                  ])) : createCommentVNode("", true)
                ])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_33$q, [
                createBaseVNode("h4", _hoisted_34$n, toDisplayString$1(unref(t)("vocabulary.save.importExport", "Import & Export")), 1),
                createBaseVNode("div", _hoisted_35$n, [
                  createBaseVNode("div", _hoisted_36$m, [
                    createBaseVNode("input", {
                      ref_key: "fileInputRef",
                      ref: fileInputRef,
                      type: "file",
                      accept: ".json",
                      onChange: handleFileSelected,
                      class: "hidden"
                    }, null, 544),
                    createBaseVNode("button", {
                      onClick: openFilePicker,
                      class: "w-full px-3 xs:px-4 py-2 xs:py-2.5 bg-purple-600 hover:bg-purple-700 text-white text-sm xs:text-base font-medium rounded-lg transition-all duration-200 flex items-center justify-center space-x-1.5 xs:space-x-2 hover:shadow-md"
                    }, [
                      _cache[17] || (_cache[17] = createBaseVNode("svg", {
                        class: "h-3 xs:h-4 w-3 xs:w-4",
                        fill: "none",
                        stroke: "currentColor",
                        viewBox: "0 0 24 24"
                      }, [
                        createBaseVNode("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10"
                        })
                      ], -1)),
                      createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.save.importFromComputer", "Import from Computer")), 1)
                    ])
                  ])
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_37$l, [
              createBaseVNode("div", _hoisted_38$l, [
                createBaseVNode("h4", _hoisted_39$j, toDisplayString$1(unref(t)("vocabulary.save.status", "Save Status")), 1),
                createBaseVNode("div", _hoisted_40$j, [
                  createBaseVNode("div", _hoisted_41$i, [
                    createBaseVNode("div", {
                      class: normalizeClass(["h-2.5 xs:h-3 w-2.5 xs:w-3 rounded-full", _ctx.saveStatusColor])
                    }, null, 2),
                    createBaseVNode("span", _hoisted_42$g, toDisplayString$1(_ctx.saveStatusText), 1)
                  ]),
                  createBaseVNode("div", _hoisted_43$f, [
                    _cache[18] || (_cache[18] = createBaseVNode("svg", {
                      class: "h-3 xs:h-4 w-3 xs:w-4 flex-shrink-0",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                      })
                    ], -1)),
                    createBaseVNode("span", _hoisted_44$e, toDisplayString$1(formattedLastSave.value), 1)
                  ])
                ])
              ]),
              _ctx.autoSaveEnabled ? (openBlock(), createElementBlock("div", _hoisted_45$d, [
                createBaseVNode("h4", _hoisted_46$d, toDisplayString$1(unref(t)("vocabulary.save.storageInfo", "Storage Information")), 1),
                createBaseVNode("div", _hoisted_47$d, [
                  createBaseVNode("p", _hoisted_48$d, [
                    createBaseVNode("span", _hoisted_49$c, toDisplayString$1(unref(t)("vocabulary.save.type", "Type")) + ":", 1),
                    createTextVNode(" " + toDisplayString$1(_ctx.storageType === "local" ? unref(t)("vocabulary.save.localStorage", "Local File") : unref(t)("vocabulary.save.googleDrive", "Google Drive")), 1)
                  ]),
                  _ctx.storageType === "local" && _ctx.hasAutoSaveFile ? (openBlock(), createElementBlock("p", _hoisted_50$b, "  " + toDisplayString$1(unref(t)("vocabulary.save.fileConfigured", "Auto-save file configured")), 1)) : createCommentVNode("", true),
                  _ctx.storageType === "google-drive" && _ctx.isGoogleSignedIn ? (openBlock(), createElementBlock("div", _hoisted_51$a, [
                    createBaseVNode("p", _hoisted_52$a, "  " + toDisplayString$1(unref(t)("vocabulary.save.googleConnected", "Google Drive connected")), 1),
                    _ctx.googleUserEmail ? (openBlock(), createElementBlock("p", _hoisted_53$a, [
                      createBaseVNode("span", _hoisted_54$a, toDisplayString$1(unref(t)("vocabulary.save.account", "Account")) + ":", 1),
                      createTextVNode(" " + toDisplayString$1(_ctx.googleUserEmail), 1)
                    ])) : (openBlock(), createElementBlock("p", _hoisted_55$a, "  Email not loaded - Sign out and sign in again "))
                  ])) : createCommentVNode("", true)
                ])
              ])) : createCommentVNode("", true)
            ])
          ])
        ])
      ]);
    };
  }
});

const SaveControlPanel = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$15
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$14 = { class: "flex flex-col md:flex-row md:justify-between md:items-center gap-3 md:gap-0" };
const _hoisted_2$11 = { class: "text-3xl font-bold text-gray-900 dark:text-white" };
const _hoisted_3$$ = { class: "mt-2 text-sm text-gray-600 dark:text-white/80" };
const _sfc_main$14 = /* @__PURE__ */ defineComponent({
  __name: "VocabularyHeader",
  emits: ["add-vocabulary"],
  setup(__props) {
    const BaseAccordion = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => BaseAccordion$1),true              ?void 0:void 0));
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(BaseAccordion), {
        title: unref(t)("vocabulary.header.accordionTitle", "Vocabulary Manager"),
        description: unref(t)("vocabulary.header.accordionDescription", "Add and manage your vocabulary words"),
        icon: "vocabulary",
        "default-open": true,
        "persist-key": "vocabulary-header",
        "data-vocabulary-header": ""
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$14, [
            createBaseVNode("div", null, [
              createBaseVNode("h1", _hoisted_2$11, toDisplayString$1(unref(t)("vocabulary.title", "Vocabulary")), 1),
              createBaseVNode("p", _hoisted_3$$, toDisplayString$1(unref(t)("vocabulary.description", "Manage and learn English vocabulary")), 1)
            ]),
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("add-vocabulary")),
              "data-original-add-button": "",
              class: "bg-blue-500 hover:bg-blue-600 text-white font-medium w-full md:w-auto py-1.5 px-3 xs:py-2 xs:px-4 rounded-lg transition-colors"
            }, [
              _cache[1] || (_cache[1] = createBaseVNode("svg", {
                class: "w-4 h-4 xs:w-5 xs:h-5 inline mr-1 xs:mr-2",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                  "clip-rule": "evenodd"
                })
              ], -1)),
              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.addNew", "Add New Word")), 1)
            ])
          ])
        ]),
        _: 1
      }, 8, ["title", "description"]);
    };
  }
});

const VocabularyHeader = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$14
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$13 = { class: "p-2 xs:p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_2$10 = { class: "grid grid-cols-1 xs:grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-2 xs:gap-3 sm:gap-4 lg:gap-6" };
const _hoisted_3$_ = { class: "col-span-1 xs:col-span-1 sm:col-span-2 md:col-span-2" };
const _hoisted_4$Y = { class: "block text-xs sm:text-sm font-medium text-gray-700 dark:text-white mb-1 xs:mb-1.5 sm:mb-2" };
const _hoisted_5$V = { class: "group relative" };
const _hoisted_6$T = { class: "rounded-md p-[1px] bg-gradient-to-r from-blue-500 via-emerald-500 to-purple-500 transition duration-300 group-focus-within:brightness-110" };
const _hoisted_7$R = { class: "relative rounded-md bg-white dark:bg-[#0a0a0a]" };
const _hoisted_8$R = ["value", "placeholder"];
const _hoisted_9$Q = { class: "block text-xs sm:text-sm font-medium text-gray-700 dark:text-white mb-1 xs:mb-1.5 sm:mb-2" };
const _hoisted_10$P = { class: "group relative" };
const _hoisted_11$P = { class: "rounded-md p-[1px] bg-gradient-to-r from-blue-500 via-emerald-500 to-purple-500 transition duration-300 group-focus-within:brightness-110" };
const _hoisted_12$O = { class: "relative rounded-md bg-white dark:bg-[#0a0a0a]" };
const _hoisted_13$O = ["aria-expanded"];
const _hoisted_14$O = { class: "truncate text-left" };
const _hoisted_15$J = { class: "p-2 border-b border-gray-200 dark:border-blue-900/30 bg-white dark:bg-[#0a0a0a]" };
const _hoisted_16$I = ["placeholder"];
const _hoisted_17$H = ["onClick"];
const _hoisted_18$F = { class: "col-span-1" };
const _hoisted_19$F = { class: "block text-xs sm:text-sm font-medium text-gray-700 dark:text-white mb-1 xs:mb-1.5 sm:mb-2" };
const _hoisted_20$E = { class: "rounded-md p-[1px] bg-gradient-to-r from-blue-500 via-emerald-500 to-purple-500 transition duration-300 group-focus-within:brightness-110" };
const _hoisted_21$E = { class: "relative rounded-md bg-white dark:bg-[#0a0a0a]" };
const _hoisted_22$C = ["aria-expanded"];
const _hoisted_23$C = { class: "truncate text-left" };
const _hoisted_24$B = { class: "max-h-80 overflow-y-auto py-1 divide-y divide-blue-50 dark:divide-blue-900/20" };
const _hoisted_25$B = { class: "mt-2 xs:mt-3 sm:mt-4" };
const _hoisted_26$z = ["aria-pressed", "title"];
const _hoisted_27$y = { class: "leading-none" };
const _sfc_main$13 = /* @__PURE__ */ defineComponent({
  __name: "VocabularyFilters",
  props: {
    searchQuery: {},
    selectedCategory: {},
    selectedLevel: {},
    categories: {},
    showFavoritesOnly: { type: Boolean }
  },
  emits: ["update:searchQuery", "update:selectedCategory", "update:selectedLevel", "update:showFavoritesOnly"],
  setup(__props, { emit: __emit }) {
    const BaseAccordion = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => BaseAccordion$1),true              ?void 0:void 0));
    const { t, locale } = useI18n();
    const props = __props;
    const emit = __emit;
    const getTopicDisplayName = (category) => {
      return getTopicName(category, t, { value: locale.value });
    };
    const isCategoryOpen = ref(false);
    const categoryDropdownRef = ref(null);
    const categoryTriggerRef = ref(null);
    const categoryMenuRef = ref(null);
    const categoryMenuListRef = ref(null);
    const categorySearchInputRef = ref(null);
    const categorySearch = ref("");
    const menuStyles = ref({});
    const selectedCategoryLabel = computed(() => {
      if (!props.selectedCategory) return t("common.all", "All");
      return getTopicDisplayName(props.selectedCategory);
    });
    const isLevelOpen = ref(false);
    const levelDropdownRef = ref(null);
    const levelTriggerRef = ref(null);
    const levelMenuRef = ref(null);
    const levelMenuStyles = ref({});
    const selectedLevelLabel = computed(() => {
      switch (props.selectedLevel) {
        case "beginner":
          return t("vocabulary.levels.beginner", "Beginner");
        case "intermediate":
          return t("vocabulary.levels.intermediate", "Intermediate");
        case "advanced":
          return t("vocabulary.levels.advanced", "Advanced");
        default:
          return t("common.all", "All");
      }
    });
    const filteredCategories = computed(() => {
      const q = categorySearch.value.trim().toLowerCase();
      if (!q) return props.categories;
      return props.categories.filter((c) => {
        const name = getTopicDisplayName(c).toLowerCase();
        return name.includes(q) || c.toLowerCase().includes(q);
      });
    });
    const updateMenuPosition = () => {
      const trigger = categoryTriggerRef.value;
      if (!trigger) return;
      const rect = trigger.getBoundingClientRect();
      const top = rect.bottom;
      const left = rect.left;
      const width = rect.width;
      const margin = 8;
      const maxLeft = window.innerWidth - margin - width;
      const safeLeft = Math.max(margin, Math.min(left, maxLeft));
      menuStyles.value = {
        top: `${top}px`,
        left: `${safeLeft}px`,
        width: `${width}px`
      };
    };
    const toggleCategoryDropdown = async () => {
      isCategoryOpen.value = !isCategoryOpen.value;
      if (isCategoryOpen.value) {
        categorySearch.value = "";
        await nextTick();
        updateMenuPosition();
        addListScrollGuards();
        categorySearchInputRef.value?.focus();
      } else {
        removeListScrollGuards();
      }
    };
    const selectCategory = (value) => {
      emit("update:selectedCategory", value);
      isCategoryOpen.value = false;
      removeListScrollGuards();
    };
    const updateLevelMenuPosition = () => {
      const trigger = levelTriggerRef.value;
      if (!trigger) return;
      const rect = trigger.getBoundingClientRect();
      const top = rect.bottom;
      const left = rect.left;
      const width = rect.width;
      const margin = 8;
      const maxLeft = window.innerWidth - margin - width;
      const safeLeft = Math.max(margin, Math.min(left, maxLeft));
      levelMenuStyles.value = {
        top: `${top}px`,
        left: `${safeLeft}px`,
        width: `${width}px`
      };
    };
    const toggleLevelDropdown = async () => {
      isLevelOpen.value = !isLevelOpen.value;
      if (isLevelOpen.value) {
        await nextTick();
        updateLevelMenuPosition();
      }
    };
    const selectLevel = (value) => {
      emit("update:selectedLevel", value);
      isLevelOpen.value = false;
    };
    const handleClickOutside = (e) => {
      const target = e.target;
      const catWrapper = categoryDropdownRef.value;
      const catMenu = categoryMenuRef.value;
      const clickedInsideCatWrapper = catWrapper ? catWrapper.contains(target) : false;
      const clickedInsideCatMenu = catMenu ? catMenu.contains(target) : false;
      if (!clickedInsideCatWrapper && !clickedInsideCatMenu) {
        if (isCategoryOpen.value) {
          isCategoryOpen.value = false;
          removeListScrollGuards();
        }
      }
      const lvlWrapper = levelDropdownRef.value;
      const lvlMenu = levelMenuRef.value;
      const clickedInsideLvlWrapper = lvlWrapper ? lvlWrapper.contains(target) : false;
      const clickedInsideLvlMenu = lvlMenu ? lvlMenu.contains(target) : false;
      if (!clickedInsideLvlWrapper && !clickedInsideLvlMenu) {
        if (isLevelOpen.value) {
          isLevelOpen.value = false;
        }
      }
    };
    const handleViewportChange = () => {
      if (isCategoryOpen.value) updateMenuPosition();
      if (isLevelOpen.value) updateLevelMenuPosition();
    };
    const handleScrollClose = (e) => {
      if (isCategoryOpen.value) {
        const menu = categoryMenuRef.value;
        const wrapper = categoryDropdownRef.value;
        const target = e?.target || null;
        if (menu && target && menu.contains(target)) return;
        if (wrapper && target && wrapper.contains(target)) return;
        isCategoryOpen.value = false;
      }
      if (isLevelOpen.value) {
        const lvlMenu = levelMenuRef.value;
        const lvlWrapper = levelDropdownRef.value;
        const target = e?.target || null;
        if (lvlMenu && target && lvlMenu.contains(target)) return;
        if (lvlWrapper && target && lvlWrapper.contains(target)) return;
        isLevelOpen.value = false;
      }
    };
    const handleScrollStart = (e) => {
      const t2 = e.target;
      const catMenu = categoryMenuRef.value;
      const lvlMenu = levelMenuRef.value;
      const catWrapper = categoryDropdownRef.value;
      const lvlWrapper = levelDropdownRef.value;
      if (catMenu && t2 && catMenu.contains(t2) || lvlMenu && t2 && lvlMenu.contains(t2)) return;
      if (catWrapper && t2 && catWrapper.contains(t2) || lvlWrapper && t2 && lvlWrapper.contains(t2)) return;
      if (isCategoryOpen.value) isCategoryOpen.value = false;
      if (isLevelOpen.value) isLevelOpen.value = false;
    };
    const handleKeydownForScroll = (e) => {
      const keys = ["PageUp", "PageDown", "Home", "End", " ", "ArrowDown", "ArrowUp"];
      if (!keys.includes(e.key)) return;
      if (isCategoryOpen.value) {
        const menu = categoryMenuRef.value;
        const wrapper = categoryDropdownRef.value;
        const target = e.target;
        if (menu && target && menu.contains(target)) return;
        if (wrapper && target && wrapper.contains(target)) return;
        isCategoryOpen.value = false;
      }
      if (isLevelOpen.value) {
        const menu = levelMenuRef.value;
        const wrapper = levelDropdownRef.value;
        const target = e.target;
        if (menu && target && menu.contains(target)) return;
        if (wrapper && target && wrapper.contains(target)) return;
        isLevelOpen.value = false;
      }
    };
    onMounted(() => {
      window.addEventListener("click", handleClickOutside, { passive: true });
      window.addEventListener("scroll", handleScrollClose, true);
      window.addEventListener("wheel", handleScrollStart, { passive: false, capture: true });
      window.addEventListener("touchstart", handleScrollStart, { passive: true, capture: true });
      window.addEventListener("touchmove", handleScrollStart, { passive: false, capture: true });
      window.addEventListener("pointerdown", handleScrollStart, { capture: true });
      window.addEventListener("mousedown", handleScrollStart, { capture: true });
      window.addEventListener("keydown", handleKeydownForScroll);
      window.addEventListener("resize", handleViewportChange);
    });
    onBeforeUnmount(() => {
      window.removeEventListener("click", handleClickOutside);
      window.removeEventListener("scroll", handleScrollClose, true);
      window.removeEventListener("wheel", handleScrollStart, true);
      window.removeEventListener("touchstart", handleScrollStart, true);
      window.removeEventListener("touchmove", handleScrollStart, true);
      window.removeEventListener("pointerdown", handleScrollStart, true);
      window.removeEventListener("mousedown", handleScrollStart, true);
      window.removeEventListener("keydown", handleKeydownForScroll);
      window.removeEventListener("resize", handleViewportChange);
      removeListScrollGuards();
    });
    const handleSearchInput = (event) => {
      const target = event.target;
      emit("update:searchQuery", target.value);
    };
    const handleFavoritesClick = () => {
      emit("update:showFavoritesOnly", !props.showFavoritesOnly);
    };
    const touchStartY = ref(0);
    const onMenuWheel = (e) => {
      const el = categoryMenuListRef.value;
      if (!el) return;
      const delta = e.deltaY;
      const atTop = el.scrollTop <= 0;
      const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 1;
      if (delta < 0 && atTop || delta > 0 && atBottom) {
        e.preventDefault();
      }
      e.stopPropagation();
    };
    const onMenuTouchStart = (e) => {
      touchStartY.value = e.touches[0]?.clientY ?? 0;
    };
    const onMenuTouchMove = (e) => {
      const el = categoryMenuListRef.value;
      if (!el) return;
      const y = e.touches[0]?.clientY ?? 0;
      const delta = touchStartY.value - y;
      const atTop = el.scrollTop <= 0;
      const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 1;
      if (delta < 0 && atTop || delta > 0 && atBottom) {
        e.preventDefault();
      }
      e.stopPropagation();
    };
    const addListScrollGuards = () => {
      const el = categoryMenuListRef.value;
      if (!el) return;
      el.addEventListener("wheel", onMenuWheel, { passive: false });
      el.addEventListener("touchstart", onMenuTouchStart, { passive: true });
      el.addEventListener("touchmove", onMenuTouchMove, { passive: false });
    };
    const removeListScrollGuards = () => {
      const el = categoryMenuListRef.value;
      if (!el) return;
      el.removeEventListener("wheel", onMenuWheel);
      el.removeEventListener("touchstart", onMenuTouchStart);
      el.removeEventListener("touchmove", onMenuTouchMove);
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(BaseAccordion), {
        title: unref(t)("vocabulary.filters.accordionTitle", "Search & Filter"),
        description: unref(t)("vocabulary.filters.accordionDescription", "Search and filter vocabulary words"),
        icon: "filter",
        "default-open": true,
        "persist-key": "vocabulary-filters"
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$13, [
            createBaseVNode("div", _hoisted_2$10, [
              createBaseVNode("div", _hoisted_3$_, [
                createBaseVNode("label", _hoisted_4$Y, toDisplayString$1(unref(t)("common.search", "Search")), 1),
                createBaseVNode("div", _hoisted_5$V, [
                  createBaseVNode("div", _hoisted_6$T, [
                    createBaseVNode("div", _hoisted_7$R, [
                      _cache[6] || (_cache[6] = createBaseVNode("span", { class: "pointer-events-none absolute inset-y-0 left-2.5 flex items-center" }, [
                        createBaseVNode("svg", {
                          class: "h-3.5 w-3.5 sm:h-4 sm:w-4 text-blue-500 dark:text-blue-400",
                          viewBox: "0 0 24 24",
                          fill: "none",
                          stroke: "currentColor",
                          "stroke-width": "2",
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "aria-hidden": "true"
                        }, [
                          createBaseVNode("circle", {
                            cx: "11",
                            cy: "11",
                            r: "8"
                          }),
                          createBaseVNode("line", {
                            x1: "21",
                            y1: "21",
                            x2: "16.65",
                            y2: "16.65"
                          })
                        ])
                      ], -1)),
                      createBaseVNode("input", {
                        value: _ctx.searchQuery,
                        onInput: handleSearchInput,
                        type: "text",
                        placeholder: unref(t)("vocabulary.searchPlaceholder", "Search vocabulary..."),
                        class: "w-full pl-8 pr-3 py-1.5 xs:pl-9 xs:pr-3 xs:py-2 sm:pl-9 sm:pr-3 sm:py-2 text-xs sm:text-sm rounded-md bg-transparent text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-blue-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      }, null, 40, _hoisted_8$R)
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", {
                class: "col-span-1",
                ref_key: "categoryDropdownRef",
                ref: categoryDropdownRef
              }, [
                createBaseVNode("label", _hoisted_9$Q, toDisplayString$1(unref(t)("vocabulary.category", "Category")), 1),
                createBaseVNode("div", _hoisted_10$P, [
                  createBaseVNode("div", _hoisted_11$P, [
                    createBaseVNode("div", _hoisted_12$O, [
                      createBaseVNode("button", {
                        type: "button",
                        onClick: toggleCategoryDropdown,
                        "aria-expanded": isCategoryOpen.value ? "true" : "false",
                        ref_key: "categoryTriggerRef",
                        ref: categoryTriggerRef,
                        class: "w-full inline-flex items-center justify-between px-2 py-1.5 xs:px-2.5 xs:py-2 sm:px-3 sm:py-2 text-xs sm:text-sm rounded-md bg-transparent text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      }, [
                        createBaseVNode("span", _hoisted_14$O, toDisplayString$1(selectedCategoryLabel.value), 1),
                        _cache[7] || (_cache[7] = createBaseVNode("svg", {
                          class: "ml-2 h-3.5 w-3.5 sm:h-4 sm:w-4 text-blue-500 dark:text-blue-400 flex-shrink-0",
                          viewBox: "0 0 20 20",
                          fill: "currentColor"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.24 4.5a.75.75 0 01-1.08 0l-4.24-4.5a.75.75 0 01.02-1.06z",
                            "clip-rule": "evenodd"
                          })
                        ], -1))
                      ], 8, _hoisted_13$O)
                    ])
                  ])
                ]),
                (openBlock(), createBlock(Teleport, { to: "body" }, [
                  isCategoryOpen.value ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: "fixed z-[9999] rounded-md border border-gray-300 dark:border-blue-900/30 bg-white dark:bg-[#0a0a0a] shadow-xl ring-1 ring-blue-100/50 dark:ring-blue-900/30 overflow-hidden",
                    style: normalizeStyle(menuStyles.value),
                    ref_key: "categoryMenuRef",
                    ref: categoryMenuRef
                  }, [
                    createBaseVNode("div", _hoisted_15$J, [
                      withDirectives(createBaseVNode("input", {
                        ref_key: "categorySearchInputRef",
                        ref: categorySearchInputRef,
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => categorySearch.value = $event),
                        type: "text",
                        placeholder: unref(t)("common.search", "Search"),
                        class: "w-full px-2 py-1.5 text-xs sm:text-sm border border-gray-300 dark:border-blue-900/30 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-blue-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      }, null, 8, _hoisted_16$I), [
                        [vModelText, categorySearch.value]
                      ])
                    ]),
                    createBaseVNode("ul", {
                      class: "max-h-80 overflow-y-auto divide-y divide-blue-50 dark:divide-blue-900/20",
                      ref_key: "categoryMenuListRef",
                      ref: categoryMenuListRef
                    }, [
                      createBaseVNode("li", null, [
                        createBaseVNode("button", {
                          type: "button",
                          onClick: _cache[1] || (_cache[1] = ($event) => selectCategory("")),
                          class: "w-full text-left px-3 py-2 text-xs sm:text-sm hover:bg-blue-50 dark:hover:bg-blue-800/30 text-gray-700 dark:text-white"
                        }, toDisplayString$1(unref(t)("common.all", "All")), 1)
                      ]),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(filteredCategories.value, (category) => {
                        return openBlock(), createElementBlock("li", { key: category }, [
                          createBaseVNode("button", {
                            type: "button",
                            onClick: ($event) => selectCategory(category),
                            class: "w-full text-left px-3 py-2 text-xs sm:text-sm hover:bg-blue-50 dark:hover:bg-blue-800/30 text-gray-700 dark:text-white"
                          }, toDisplayString$1(getTopicDisplayName(category)), 9, _hoisted_17$H)
                        ]);
                      }), 128))
                    ], 512)
                  ], 4)) : createCommentVNode("", true)
                ]))
              ], 512),
              createBaseVNode("div", _hoisted_18$F, [
                createBaseVNode("label", _hoisted_19$F, toDisplayString$1(unref(t)("vocabulary.level", "Level")), 1),
                createBaseVNode("div", {
                  class: "group relative",
                  ref_key: "levelDropdownRef",
                  ref: levelDropdownRef
                }, [
                  createBaseVNode("div", _hoisted_20$E, [
                    createBaseVNode("div", _hoisted_21$E, [
                      createBaseVNode("button", {
                        type: "button",
                        onClick: toggleLevelDropdown,
                        "aria-expanded": isLevelOpen.value ? "true" : "false",
                        ref_key: "levelTriggerRef",
                        ref: levelTriggerRef,
                        class: "w-full inline-flex items-center justify-between px-2 py-1.5 xs:px-2.5 xs:py-2 sm:px-3 sm:py-2 text-xs sm:text-sm rounded-md bg-transparent text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      }, [
                        createBaseVNode("span", _hoisted_23$C, toDisplayString$1(selectedLevelLabel.value), 1),
                        _cache[8] || (_cache[8] = createBaseVNode("svg", {
                          class: "ml-2 h-3.5 w-3.5 sm:h-4 sm:w-4 text-blue-500 dark:text-blue-400 flex-shrink-0",
                          viewBox: "0 0 20 20",
                          fill: "currentColor"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.24 4.5a.75.75 0 01-1.08 0l-4.24-4.5a.75.75 0 01.02-1.06z",
                            "clip-rule": "evenodd"
                          })
                        ], -1))
                      ], 8, _hoisted_22$C),
                      (openBlock(), createBlock(Teleport, { to: "body" }, [
                        isLevelOpen.value ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          ref_key: "levelMenuRef",
                          ref: levelMenuRef,
                          class: "fixed z-[10000] rounded-md border border-blue-200 dark:border-blue-900/30 bg-white dark:bg-[#0a0a0a] shadow-xl ring-1 ring-blue-100/50 dark:ring-blue-900/30 overflow-hidden",
                          style: normalizeStyle(levelMenuStyles.value)
                        }, [
                          createBaseVNode("ul", _hoisted_24$B, [
                            createBaseVNode("li", null, [
                              createBaseVNode("button", {
                                type: "button",
                                onClick: _cache[2] || (_cache[2] = ($event) => selectLevel("")),
                                class: "w-full text-left px-3 py-2 text-xs sm:text-sm hover:bg-blue-50 dark:hover:bg-blue-800/30 text-gray-700 dark:text-white"
                              }, toDisplayString$1(unref(t)("common.all", "All")), 1)
                            ]),
                            createBaseVNode("li", null, [
                              createBaseVNode("button", {
                                type: "button",
                                onClick: _cache[3] || (_cache[3] = ($event) => selectLevel("beginner")),
                                class: "w-full text-left px-3 py-2 text-xs sm:text-sm hover:bg-blue-50 dark:hover:bg-blue-800/30 text-gray-700 dark:text-white"
                              }, toDisplayString$1(unref(t)("vocabulary.levels.beginner", "Beginner")), 1)
                            ]),
                            createBaseVNode("li", null, [
                              createBaseVNode("button", {
                                type: "button",
                                onClick: _cache[4] || (_cache[4] = ($event) => selectLevel("intermediate")),
                                class: "w-full text-left px-3 py-2 text-xs sm:text-sm hover:bg-blue-50 dark:hover:bg-blue-800/30 text-gray-700 dark:text-white"
                              }, toDisplayString$1(unref(t)("vocabulary.levels.intermediate", "Intermediate")), 1)
                            ]),
                            createBaseVNode("li", null, [
                              createBaseVNode("button", {
                                type: "button",
                                onClick: _cache[5] || (_cache[5] = ($event) => selectLevel("advanced")),
                                class: "w-full text-left px-3 py-2 text-xs sm:text-sm hover:bg-blue-50 dark:hover:bg-blue-800/30 text-gray-700 dark:text-white"
                              }, toDisplayString$1(unref(t)("vocabulary.levels.advanced", "Advanced")), 1)
                            ])
                          ])
                        ], 4)) : createCommentVNode("", true)
                      ]))
                    ])
                  ])
                ], 512)
              ]),
              createBaseVNode("div", _hoisted_25$B, [
                createBaseVNode("button", {
                  type: "button",
                  "aria-pressed": _ctx.showFavoritesOnly ? "true" : "false",
                  title: unref(t)("vocabulary.showFavoritesOnly", "Show favorites only"),
                  onClick: handleFavoritesClick,
                  class: normalizeClass(["inline-flex items-center select-none rounded-full border px-3 py-1.5 xs:px-3 xs:py-1.5 sm:px-3.5 sm:py-2 text-xs sm:text-sm transition-all duration-150", [
                    _ctx.showFavoritesOnly ? "bg-rose-500 border-rose-600 text-white shadow hover:bg-rose-600" : "bg-white border-blue-500 text-blue-600 hover:bg-blue-50 dark:bg-[#0a0a0a] dark:border-blue-400 dark:text-blue-300 dark:hover:bg-blue-900/30"
                  ]])
                }, [
                  _cache[9] || (_cache[9] = createBaseVNode("svg", {
                    class: "w-4 h-4 sm:w-4.5 sm:h-4.5 mr-1.5",
                    viewBox: "0 0 24 24",
                    fill: "currentColor",
                    "aria-hidden": "true"
                  }, [
                    createBaseVNode("path", { d: "M12 21.35l-1.45-1.32C6.4 16.36 4 14.28 4 11.5 4 9.5 5.5 8 7.5 8c1.04 0 2.04.5 2.65 1.32.61-.82 1.61-1.32 2.65-1.32C15.5 8 17 9.5 17 11.5c0 2.78-2.4 4.86-6.55 8.54L12 21.35z" })
                  ], -1)),
                  createBaseVNode("span", _hoisted_27$y, toDisplayString$1(unref(t)("vocabulary.showFavoritesOnly", "Show favorites only")), 1)
                ], 10, _hoisted_26$z)
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["title", "description"]);
    };
  }
});

const VocabularyFilters = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$13
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$12 = { class: "px-3 py-3 sm:px-4 sm:py-4 md:px-6 md:py-4 border-b border-gray-200 dark:border-gray-700" };
const _hoisted_2$$ = { class: "flex items-center justify-between" };
const _hoisted_3$Z = { class: "text-base sm:text-lg font-semibold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent" };
const _hoisted_4$X = ["aria-label"];
const _hoisted_5$U = { class: "text-sm font-semibold mb-2" };
const _hoisted_6$S = {
  key: 0,
  class: "text-sm text-gray-600 dark:text-white/70"
};
const _hoisted_7$Q = {
  key: 1,
  class: "max-h-64 overflow-y-auto space-y-2 pr-1"
};
const _hoisted_8$Q = { class: "text-xs font-medium text-gray-700 mb-1 dark:text-white/80" };
const _hoisted_9$P = { class: "font-semibold" };
const _hoisted_10$O = { class: "text-xs pl-0 space-y-0.5" };
const _hoisted_11$O = ["onClick"];
const _hoisted_12$N = { class: "min-w-0 pr-2" };
const _hoisted_13$N = { class: "font-medium" };
const _hoisted_14$N = { class: "truncate" };
const _hoisted_15$I = { class: "text-gray-500 whitespace-nowrap" };
const _hoisted_16$H = { key: 0 };
const _hoisted_17$G = {
  key: 0,
  class: "bg-white dark:bg-[#0a0a0a] px-4 py-3 border-t border-gray-200 dark:border-gray-700 sm:px-6"
};
const _hoisted_18$E = { class: "flex items-center justify-between" };
const _hoisted_19$E = { class: "flex-1 flex justify-between sm:hidden" };
const _hoisted_20$D = ["disabled"];
const _hoisted_21$D = ["disabled"];
const _hoisted_22$B = { class: "hidden sm:flex-1 sm:flex sm:items-center sm:justify-between" };
const _hoisted_23$B = { class: "text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_24$A = { class: "relative z-0 inline-flex rounded-md shadow-sm -space-x-px" };
const _hoisted_25$A = ["disabled"];
const _hoisted_26$y = { class: "sr-only" };
const _hoisted_27$x = ["onClick", "disabled"];
const _hoisted_28$w = ["disabled"];
const _hoisted_29$u = { class: "sr-only" };
const _hoisted_30$t = {
  key: 1,
  class: "divide-y divide-gray-200 dark:divide-gray-700"
};
const _hoisted_31$s = {
  key: 2,
  class: "bg-white dark:bg-[#0a0a0a] px-4 py-3 border-t border-gray-200 dark:border-gray-700 sm:px-6"
};
const _hoisted_32$p = { class: "flex items-center justify-between" };
const _hoisted_33$p = { class: "flex-1 flex justify-between sm:hidden" };
const _hoisted_34$m = ["disabled"];
const _hoisted_35$m = ["disabled"];
const _hoisted_36$l = { class: "hidden sm:flex-1 sm:flex sm:items-center sm:justify-between" };
const _hoisted_37$k = { class: "text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_38$k = { class: "relative z-0 inline-flex rounded-md shadow-sm -space-x-px" };
const _hoisted_39$i = ["disabled"];
const _hoisted_40$i = { class: "sr-only" };
const _hoisted_41$h = ["onClick"];
const _hoisted_42$f = ["disabled"];
const _hoisted_43$e = { class: "sr-only" };
const ACCORDION_STATE_STORAGE_KEY = "vocabulary-accordion-state";
const PENDING_OPEN_KEY$1 = "open-date-topic-pending";
const dateGroupsPerPage = 7;
const _sfc_main$12 = /* @__PURE__ */ defineComponent({
  __name: "VocabularyList",
  props: {
    paginatedWords: {},
    currentPage: {},
    totalPages: {},
    totalCount: {},
    startIndex: {},
    endIndex: {},
    visiblePages: {},
    useGrouping: { type: Boolean },
    allWords: {},
    dateGroupPages: {},
    itemsPerPageGrouped: {},
    hoverToExpandEnabled: { type: Boolean },
    globalMoveMode: { type: Boolean },
    recentlyAddedCategory: {}
  },
  emits: ["play-audio", "edit-word", "delete-word", "toggle-favorite", "view-details", "previous-page", "next-page", "go-to-page", "date-group-previous", "date-group-next", "date-group-go-to-page", "accordion-toggle", "open-note-dialog", "open-add-vocabulary-dialog", "open-grammar-manager", "move-vocabulary", "batch-move-category"],
  setup(__props, { emit: __emit }) {
    const { t, locale } = useI18n();
    const toast = useToast();
    const showMissingTooltip = ref(false);
    let missingTooltipHideTimer = null;
    const handleMissingTooltipEnter = () => {
      if (missingTooltipHideTimer) {
        clearTimeout(missingTooltipHideTimer);
        missingTooltipHideTimer = null;
      }
      showMissingTooltip.value = true;
    };
    const handleMissingTooltipLeave = () => {
      missingTooltipHideTimer = setTimeout(() => {
        showMissingTooltip.value = false;
        missingTooltipHideTimer = null;
      }, 120);
    };
    const VocabularyCard = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => VocabularyCard$1),true              ?void 0:void 0))
    );
    const DateGroupAccordion = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => DateGroupAccordion$1),true              ?void 0:void 0))
    );
    const accordionState = ref({});
    const getStoredAccordionState = () => {
      try {
        const stored = localStorage.getItem(ACCORDION_STATE_STORAGE_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch (error) {
        console.warn("Failed to load accordion state from localStorage:", error);
        return {};
      }
    };
    const setStoredAccordionState = (state) => {
      try {
        localStorage.setItem(ACCORDION_STATE_STORAGE_KEY, JSON.stringify(state));
      } catch (error) {
        console.warn("Failed to save accordion state to localStorage:", error);
      }
    };
    onMounted(() => {
      accordionState.value = getStoredAccordionState();
    });
    const props = __props;
    const missingImagesByDate = computed(() => {
      const source = props.useGrouping ? props.allWords || [] : props.paginatedWords || [];
      if (!Array.isArray(source) || source.length === 0) return [];
      const normalizeDate = (d) => {
        if (!d) return "Unknown";
        const dt = new Date(d);
        return isNaN(dt.getTime()) ? "Unknown" : dt.toISOString().slice(0, 10);
      };
      const map = /* @__PURE__ */ new Map();
      for (const w of source) {
        const img = (w.image ?? "").trim();
        if (img) continue;
        const dateKey = normalizeDate(w.createdAt);
        const catKey = w.category || "uncategorized";
        const displayName = w.categoryName || getTopicName(catKey, t, locale, w);
        if (!map.has(dateKey)) map.set(dateKey, /* @__PURE__ */ new Map());
        const catMap = map.get(dateKey);
        const prev = catMap.get(catKey) || { name: displayName, count: 0 };
        prev.count += 1;
        if (!prev.name && displayName) {
          prev.name = displayName;
        }
        catMap.set(catKey, prev);
      }
      const result = [];
      for (const [date, catMap] of map.entries()) {
        const categories = Array.from(catMap.entries()).map(([key, value]) => ({ key, name: value.name, count: value.count }));
        result.push({ date, categories });
      }
      result.sort((a, b) => {
        if (a.date === "Unknown") return 1;
        if (b.date === "Unknown") return -1;
        return new Date(b.date).getTime() - new Date(a.date).getTime();
      });
      return result;
    });
    const dateGroupCurrentPage = ref(1);
    const groupedWords = computed(() => {
      if (!props.useGrouping) return [];
      const wordsToGroup = props.allWords || props.paginatedWords;
      let allGroups = groupVocabulariesByDateAndTopic(wordsToGroup, locale.value, t);
      if (props.recentlyAddedCategory) {
        allGroups = allGroups.map((group) => {
          if (!group.topics) return group;
          const recentCategoryIndex = group.topics.findIndex(
            (topic) => topic.topic === props.recentlyAddedCategory
          );
          if (recentCategoryIndex > -1) {
            const sortedTopics = [...group.topics];
            const [recentCategory] = sortedTopics.splice(recentCategoryIndex, 1);
            sortedTopics.unshift(recentCategory);
            return {
              ...group,
              topics: sortedTopics
            };
          }
          return group;
        });
      }
      if (props.dateGroupPages && props.itemsPerPageGrouped) {
        return allGroups.map((group) => {
          const currentPage = props.dateGroupPages[group.date] || 1;
          const itemsPerPage = props.itemsPerPageGrouped;
          const totalTopics = group.topics ? group.topics.length : 0;
          const startIndex = (currentPage - 1) * itemsPerPage;
          const endIndex = startIndex + itemsPerPage;
          return {
            ...group,
            topics: group.topics ? group.topics.slice(startIndex, endIndex) : [],
            currentPage,
            totalPages: Math.ceil(totalTopics / itemsPerPage),
            topicsTotal: totalTopics,
            totalItems: group.vocabularies.length
            // gi li s lng t vng gc
          };
        });
      }
      return allGroups;
    });
    const paginatedDateGroups = computed(() => {
      if (!props.useGrouping) return [];
      const allGroups = groupedWords.value;
      const startIndex = (dateGroupCurrentPage.value - 1) * dateGroupsPerPage;
      const endIndex = startIndex + dateGroupsPerPage;
      return allGroups.slice(startIndex, endIndex);
    });
    const dateGroupPaginationInfo = computed(() => {
      const totalGroups = groupedWords.value.length;
      const totalPages = Math.ceil(totalGroups / dateGroupsPerPage);
      const startIndex = (dateGroupCurrentPage.value - 1) * dateGroupsPerPage + 1;
      const endIndex = Math.min(startIndex + dateGroupsPerPage - 1, totalGroups);
      return {
        totalGroups,
        totalPages,
        currentPage: dateGroupCurrentPage.value,
        startIndex,
        endIndex,
        hasNext: dateGroupCurrentPage.value < totalPages,
        hasPrevious: dateGroupCurrentPage.value > 1
      };
    });
    const goToDateGroupPage = (page) => {
      if (page >= 1 && page <= dateGroupPaginationInfo.value.totalPages) {
        dateGroupCurrentPage.value = page;
      }
    };
    const nextDateGroupPage = () => {
      if (dateGroupPaginationInfo.value.hasNext) {
        dateGroupCurrentPage.value++;
      }
    };
    const previousDateGroupPage = () => {
      if (dateGroupPaginationInfo.value.hasPrevious) {
        dateGroupCurrentPage.value--;
      }
    };
    const visibleDateGroupPages = computed(() => {
      const totalPages = dateGroupPaginationInfo.value.totalPages;
      const currentPage = dateGroupCurrentPage.value;
      if (totalPages <= 0) return [];
      const pages = [];
      const maxVisible = 5;
      let start = Math.max(1, currentPage - Math.floor(maxVisible / 2));
      let end = Math.min(totalPages, start + maxVisible - 1);
      start = Math.max(1, end - maxVisible + 1);
      for (let i = start; i <= end; i++) {
        pages.push(i);
      }
      return pages;
    });
    const handleAccordionToggle = (date, expanded) => {
      accordionState.value[date] = expanded;
      setStoredAccordionState(accordionState.value);
      console.log(`Accordion for ${date} toggled to:`, expanded);
    };
    const handleNoteSaved = (date, note, markedWords) => {
      toast.success(t("vocabulary.notes.saveSuccess", "Notes saved successfully"), {
        timeout: 2e3
      });
      const autoSaveEnabled = localStorage.getItem("vocabulary-auto-save-enabled");
      if (autoSaveEnabled === "true") {
        toast.info(t("vocabulary.notes.autoSaveNotice", "Notes will be included in auto-save"), {
          timeout: 3e3
        });
      }
      console.log(`Note saved for ${date} with ${markedWords.length} marked words`);
    };
    const handleVocabularyListMouseLeave = () => {
      if (props.hoverToExpandEnabled) {
        window.dispatchEvent(new CustomEvent("vocabulary-list-mouse-leave"));
      }
    };
    const handleVocabularyListMouseEnter = () => {
      if (props.hoverToExpandEnabled) {
        window.dispatchEvent(new CustomEvent("vocabulary-list-mouse-enter"));
      }
    };
    const emit = __emit;
    const handleMoveVocabulary = (data) => {
      const sourceDate = groupedWords.value.find(
        (group) => group.vocabularies.some((word) => word.id === data.word.id)
      )?.date;
      emit("move-vocabulary", {
        ...data,
        sourceDate
      });
    };
    const handleRequestAvailableDates = (data) => {
      const availableDates = groupedWords.value.filter((group) => {
        const hasSameTopic = group.vocabularies.some((word) => word.category === data.topic);
        return hasSameTopic && group.date !== data.currentDate;
      }).map((group) => ({
        date: group.date,
        count: group.vocabularies.filter((word) => word.category === data.topic).length
      })).filter((item) => item.count > 0).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
      nextTick(() => {
        const event = new CustomEvent("available-dates-response", {
          detail: {
            topic: data.topic,
            currentDate: data.currentDate,
            availableDates
          }
        });
        window.dispatchEvent(event);
      });
    };
    const handleNavigateToDateTopic = (payload) => {
      const allGroups = groupedWords.value;
      const targetIndex = allGroups.findIndex((g) => g.date === payload.date);
      if (targetIndex === -1) return;
      const targetPage = Math.floor(targetIndex / dateGroupsPerPage) + 1;
      const dispatchOpenEvent = () => {
        const ev = new CustomEvent("open-date-topic", {
          detail: { date: payload.date, topic: payload.topic }
        });
        window.dispatchEvent(ev);
      };
      if (dateGroupCurrentPage.value !== targetPage) {
        try {
          sessionStorage.setItem(PENDING_OPEN_KEY$1, JSON.stringify({ date: payload.date, topic: payload.topic }));
        } catch {
        }
        dateGroupCurrentPage.value = targetPage;
        nextTick(() => {
          requestAnimationFrame(() => {
            setTimeout(() => {
              dispatchOpenEvent();
            }, 50);
          });
        });
      } else {
        nextTick(() => {
          dispatchOpenEvent();
        });
      }
    };
    const handleMissingNavigate = (date, topicKey) => {
      handleNavigateToDateTopic({ date, topic: topicKey });
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-[#0a0a0a] shadow rounded-lg overflow-hidden border border-gray-200 dark:border-gray-700",
        onMouseleave: handleVocabularyListMouseLeave,
        onMouseenter: handleVocabularyListMouseEnter
      }, [
        createBaseVNode("div", _hoisted_1$12, [
          createBaseVNode("div", _hoisted_2$$, [
            createBaseVNode("h3", _hoisted_3$Z, toDisplayString$1(unref(t)("vocabulary.vocabularyList", "Vocabulary List")) + " (" + toDisplayString$1(_ctx.totalCount) + ") ", 1),
            createBaseVNode("div", {
              class: "relative ml-2 select-none",
              "aria-hidden": "false",
              onMouseenter: handleMissingTooltipEnter,
              onMouseleave: handleMissingTooltipLeave
            }, [
              createBaseVNode("button", {
                type: "button",
                class: "inline-flex items-center justify-center w-6 h-6 sm:w-7 sm:h-7 rounded-full border border-blue-200 text-blue-600 bg-blue-50 hover:bg-blue-100 dark:text-blue-300 dark:bg-dark-bg-soft dark:border-dark-bg-mute dark:hover:bg-dark-bg-mute transition",
                "aria-label": unref(t)("vocabulary.imageInfo.aria", "Show dates/categories missing images")
              }, _cache[20] || (_cache[20] = [
                createBaseVNode("svg", {
                  viewBox: "0 0 24 24",
                  fill: "currentColor",
                  class: "w-4 h-4 sm:w-5 sm:h-5"
                }, [
                  createBaseVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm.75 15h-1.5v-6h1.5v6zm0-8h-1.5V7h1.5v2z" })
                ], -1)
              ]), 8, _hoisted_4$X),
              showMissingTooltip.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "transition-opacity duration-150 absolute right-0 mt-2 w-72 sm:w-80 rounded-lg shadow-xl ring-1 ring-black/5 bg-white text-gray-800 p-3 z-30 border border-gray-200 dark:bg-[#0a0a0a] dark:text-white dark:border dark:border-dark-bg-mute",
                onMouseenter: handleMissingTooltipEnter,
                onMouseleave: handleMissingTooltipLeave
              }, [
                _cache[21] || (_cache[21] = createBaseVNode("div", {
                  class: "absolute -top-[2px] right-7 w-4 h-[4px] bg-white dark:bg-[#0a0a0a] pointer-events-none z-10",
                  "aria-hidden": "true"
                }, null, -1)),
                _cache[22] || (_cache[22] = createBaseVNode("div", {
                  class: "absolute -top-1.5 right-[29.5px] w-3 h-3 rotate-45 bg-white pointer-events-none z-20 dark:bg-[#0a0a0a] border-t border-l border-gray-200 dark:border-[#0f0f0f]",
                  "aria-hidden": "true"
                }, null, -1)),
                createBaseVNode("div", _hoisted_5$U, toDisplayString$1(unref(t)("vocabulary.imageInfo.title", "Missing images by date")), 1),
                missingImagesByDate.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_6$S, toDisplayString$1(unref(t)("vocabulary.imageInfo.none", "All categories have images for the current list")), 1)) : (openBlock(), createElementBlock("div", _hoisted_7$Q, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(missingImagesByDate.value, (item) => {
                    return openBlock(), createElementBlock("div", {
                      key: item.date,
                      class: "border border-gray-200 rounded-md p-2 dark:border-dark-bg-mute"
                    }, [
                      createBaseVNode("div", _hoisted_8$Q, [
                        createTextVNode(toDisplayString$1(unref(t)("vocabulary.imageInfo.date", "Date")) + ": ", 1),
                        createBaseVNode("span", _hoisted_9$P, toDisplayString$1(item.date), 1)
                      ]),
                      createBaseVNode("ul", _hoisted_10$O, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(item.categories, (cat) => {
                          return openBlock(), createElementBlock("li", {
                            key: cat.key,
                            class: "flex items-center justify-between rounded px-2 py-1 cursor-pointer hover:bg-gray-custom dark:hover:bg-gray-custom",
                            onClick: ($event) => handleMissingNavigate(item.date, cat.key)
                          }, [
                            createBaseVNode("div", _hoisted_12$N, [
                              createBaseVNode("span", _hoisted_13$N, toDisplayString$1(unref(t)("vocabulary.imageInfo.category", "Category")) + ":", 1),
                              createBaseVNode("span", _hoisted_14$N, toDisplayString$1(cat.name), 1)
                            ]),
                            createBaseVNode("span", _hoisted_15$I, toDisplayString$1(unref(t)("vocabulary.imageInfo.missingCount", { count: cat.count }) || `${cat.count} without image`), 1)
                          ], 8, _hoisted_11$O);
                        }), 128))
                      ])
                    ]);
                  }), 128))
                ]))
              ], 32)) : createCommentVNode("", true)
            ], 32)
          ])
        ]),
        _ctx.useGrouping && groupedWords.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_16$H, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(paginatedDateGroups.value, (group) => {
            return openBlock(), createBlock(unref(DateGroupAccordion), {
              key: group.date,
              group,
              "default-expanded": false,
              "accordion-state": accordionState.value,
              "hover-to-expand-enabled": _ctx.hoverToExpandEnabled,
              "global-move-mode": _ctx.globalMoveMode,
              onPlayAudio: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("play-audio", $event)),
              onEditWord: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("edit-word", $event)),
              onDeleteWord: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("delete-word", $event)),
              onToggleFavorite: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("toggle-favorite", $event)),
              onViewDetails: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("view-details", $event)),
              onDateGroupPrevious: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("date-group-previous", $event)),
              onDateGroupNext: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("date-group-next", $event)),
              onAccordionToggle: handleAccordionToggle,
              onNoteSaved: handleNoteSaved,
              onOpenNoteDialog: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("open-note-dialog", $event.date, $event.words)),
              onOpenAddVocabularyDialog: _cache[8] || (_cache[8] = ($event) => _ctx.$emit("open-add-vocabulary-dialog", $event)),
              onOpenGrammarManager: _cache[9] || (_cache[9] = ($event) => _ctx.$emit("open-grammar-manager", $event)),
              onMoveVocabulary: handleMoveVocabulary,
              onRequestAvailableDates: handleRequestAvailableDates,
              onNavigateToDateTopic: handleNavigateToDateTopic,
              onBatchMoveCategory: _cache[10] || (_cache[10] = ($event) => _ctx.$emit("batch-move-category", $event))
            }, null, 8, ["group", "accordion-state", "hover-to-expand-enabled", "global-move-mode"]);
          }), 128)),
          dateGroupPaginationInfo.value.totalPages > 1 ? (openBlock(), createElementBlock("div", _hoisted_17$G, [
            createBaseVNode("div", _hoisted_18$E, [
              createBaseVNode("div", _hoisted_19$E, [
                createBaseVNode("button", {
                  onClick: previousDateGroupPage,
                  disabled: !dateGroupPaginationInfo.value.hasPrevious,
                  class: "relative inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_20$D),
                createBaseVNode("button", {
                  onClick: nextDateGroupPage,
                  disabled: !dateGroupPaginationInfo.value.hasNext,
                  class: "ml-3 relative inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_21$D)
              ]),
              createBaseVNode("div", _hoisted_22$B, [
                createBaseVNode("div", null, [
                  createBaseVNode("p", _hoisted_23$B, toDisplayString$1(unref(t)("vocabulary.showingDateGroups", {
                    start: dateGroupPaginationInfo.value.startIndex,
                    end: dateGroupPaginationInfo.value.endIndex,
                    total: dateGroupPaginationInfo.value.totalGroups
                  }, `Showing ${dateGroupPaginationInfo.value.startIndex} to ${dateGroupPaginationInfo.value.endIndex} of ${dateGroupPaginationInfo.value.totalGroups} date groups`)), 1)
                ]),
                createBaseVNode("div", null, [
                  createBaseVNode("nav", _hoisted_24$A, [
                    createBaseVNode("button", {
                      onClick: previousDateGroupPage,
                      disabled: !dateGroupPaginationInfo.value.hasPrevious,
                      class: "relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, [
                      createBaseVNode("span", _hoisted_26$y, toDisplayString$1(unref(t)("common.previous", "Previous")), 1),
                      _cache[23] || (_cache[23] = createBaseVNode("svg", {
                        class: "h-5 w-5",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                          "clip-rule": "evenodd"
                        })
                      ], -1))
                    ], 8, _hoisted_25$A),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(visibleDateGroupPages.value, (page) => {
                      return openBlock(), createElementBlock("button", {
                        key: page,
                        onClick: ($event) => page > 0 ? goToDateGroupPage(page) : null,
                        disabled: page === -1,
                        class: normalizeClass([
                          page === dateGroupPaginationInfo.value.currentPage ? "z-10 bg-blue-50 dark:bg-blue-900 border-blue-500 dark:border-blue-400 text-blue-600 dark:text-blue-300" : page === -1 ? "bg-white dark:bg-[#0a0a0a] border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-400 cursor-default" : "bg-white dark:bg-[#0a0a0a] border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600",
                          "relative inline-flex items-center px-4 py-2 border text-sm font-medium"
                        ])
                      }, toDisplayString$1(page === -1 ? "..." : page), 11, _hoisted_27$x);
                    }), 128)),
                    createBaseVNode("button", {
                      onClick: nextDateGroupPage,
                      disabled: !dateGroupPaginationInfo.value.hasNext,
                      class: "relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, [
                      createBaseVNode("span", _hoisted_29$u, toDisplayString$1(unref(t)("common.next", "Next")), 1),
                      _cache[24] || (_cache[24] = createBaseVNode("svg", {
                        class: "h-5 w-5",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                          "clip-rule": "evenodd"
                        })
                      ], -1))
                    ], 8, _hoisted_28$w)
                  ])
                ])
              ])
            ])
          ])) : createCommentVNode("", true)
        ])) : (openBlock(), createElementBlock("div", _hoisted_30$t, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.paginatedWords, (word) => {
            return openBlock(), createBlock(unref(VocabularyCard), {
              key: word.id,
              word,
              onPlayAudio: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("play-audio", $event)),
              onEditWord: _cache[12] || (_cache[12] = ($event) => _ctx.$emit("edit-word", $event)),
              onDeleteWord: _cache[13] || (_cache[13] = ($event) => _ctx.$emit("delete-word", $event)),
              onToggleFavorite: _cache[14] || (_cache[14] = ($event) => _ctx.$emit("toggle-favorite", $event)),
              onViewDetails: _cache[15] || (_cache[15] = ($event) => _ctx.$emit("view-details", $event))
            }, null, 8, ["word"]);
          }), 128))
        ])),
        !_ctx.useGrouping ? (openBlock(), createElementBlock("div", _hoisted_31$s, [
          createBaseVNode("div", _hoisted_32$p, [
            createBaseVNode("div", _hoisted_33$p, [
              createBaseVNode("button", {
                onClick: _cache[16] || (_cache[16] = ($event) => _ctx.$emit("previous-page")),
                disabled: _ctx.currentPage === 1,
                class: "relative inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600"
              }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_34$m),
              createBaseVNode("button", {
                onClick: _cache[17] || (_cache[17] = ($event) => _ctx.$emit("next-page")),
                disabled: _ctx.currentPage === _ctx.totalPages,
                class: "ml-3 relative inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600"
              }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_35$m)
            ]),
            createBaseVNode("div", _hoisted_36$l, [
              createBaseVNode("div", null, [
                createBaseVNode("p", _hoisted_37$k, toDisplayString$1(unref(t)("vocabulary.showingResults", { start: _ctx.startIndex, end: _ctx.endIndex, total: _ctx.totalCount }, `Showing ${_ctx.startIndex} to ${_ctx.endIndex} of ${_ctx.totalCount} results`)), 1)
              ]),
              createBaseVNode("div", null, [
                createBaseVNode("nav", _hoisted_38$k, [
                  createBaseVNode("button", {
                    onClick: _cache[18] || (_cache[18] = ($event) => _ctx.$emit("previous-page")),
                    disabled: _ctx.currentPage === 1,
                    class: "relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                  }, [
                    createBaseVNode("span", _hoisted_40$i, toDisplayString$1(unref(t)("common.previous", "Previous")), 1),
                    _cache[25] || (_cache[25] = createBaseVNode("svg", {
                      class: "h-5 w-5",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                        "clip-rule": "evenodd"
                      })
                    ], -1))
                  ], 8, _hoisted_39$i),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.visiblePages, (page) => {
                    return openBlock(), createElementBlock("button", {
                      key: page,
                      onClick: ($event) => _ctx.$emit("go-to-page", page),
                      class: normalizeClass([page === _ctx.currentPage ? "bg-blue-50 dark:bg-blue-900 border-blue-500 dark:border-blue-400 text-blue-600 dark:text-blue-300" : "bg-white dark:bg-[#0a0a0a] border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600", "relative inline-flex items-center px-4 py-2 border text-sm font-medium"])
                    }, toDisplayString$1(page), 11, _hoisted_41$h);
                  }), 128)),
                  createBaseVNode("button", {
                    onClick: _cache[19] || (_cache[19] = ($event) => _ctx.$emit("next-page")),
                    disabled: _ctx.currentPage === _ctx.totalPages,
                    class: "relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                  }, [
                    createBaseVNode("span", _hoisted_43$e, toDisplayString$1(unref(t)("common.next", "Next")), 1),
                    _cache[26] || (_cache[26] = createBaseVNode("svg", {
                      class: "h-5 w-5",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l4 4a1 1 0 01-1.414 0z",
                        "clip-rule": "evenodd"
                      })
                    ], -1))
                  ], 8, _hoisted_42$f)
                ])
              ])
            ])
          ])
        ])) : createCommentVNode("", true)
      ], 32);
    };
  }
});

const VocabularyList = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$12
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$11 = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$_ = { class: "w-full max-h-[90vh] flex flex-col max-w-full sm:max-w-lg md:max-w-2xl lg:max-w-4xl" };
const _hoisted_3$Y = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$W = { class: "flex items-center justify-between" };
const _hoisted_5$T = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$R = { class: "grid grid-cols-1 md:grid-cols-2 gap-6" };
const _hoisted_7$P = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_8$P = {
  for: "word",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_9$O = { class: "relative" };
const _hoisted_10$N = ["placeholder"];
const _hoisted_11$N = ["title", "aria-label"];
const _hoisted_12$M = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_13$M = {
  for: "pronunciation",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_14$M = { class: "relative" };
const _hoisted_15$H = ["placeholder"];
const _hoisted_16$G = ["title", "aria-label"];
const _hoisted_17$F = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_18$D = {
  for: "partOfSpeech",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_19$D = { value: "" };
const _hoisted_20$C = { value: "noun" };
const _hoisted_21$C = { value: "verb" };
const _hoisted_22$A = { value: "adjective" };
const _hoisted_23$A = { value: "adverb" };
const _hoisted_24$z = { value: "preposition" };
const _hoisted_25$z = { value: "conjunction" };
const _hoisted_26$x = { value: "interjection" };
const _hoisted_27$w = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_28$v = {
  for: "category",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_29$t = { class: "relative" };
const _hoisted_30$s = ["title"];
const _hoisted_31$r = { class: "relative" };
const _hoisted_32$o = ["placeholder", "value"];
const _hoisted_33$o = { class: "absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none" };
const _hoisted_34$l = ["placeholder"];
const _hoisted_35$l = { class: "max-h-40 overflow-y-auto" };
const _hoisted_36$k = {
  key: 0,
  class: "px-3 py-2 text-sm text-gray-500 dark:text-gray-400"
};
const _hoisted_37$j = ["onClick"];
const _hoisted_38$j = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_39$h = {
  for: "level",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_40$h = { value: "" };
const _hoisted_41$g = { value: "beginner" };
const _hoisted_42$e = { value: "intermediate" };
const _hoisted_43$d = { value: "advanced" };
const _hoisted_44$d = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_45$c = {
  for: "meaning",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_46$c = ["placeholder"];
const _hoisted_47$c = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_48$c = {
  for: "example",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_49$b = ["placeholder"];
const _hoisted_50$a = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.8s" }
};
const _hoisted_51$9 = {
  for: "synonyms",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_52$9 = ["placeholder"];
const _hoisted_53$9 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.9s" }
};
const _hoisted_54$9 = {
  for: "antonyms",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_55$9 = ["placeholder"];
const _hoisted_56$9 = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "1.0s" }
};
const _hoisted_57$9 = {
  for: "imageUrl",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_58$9 = ["placeholder"];
const _hoisted_59$8 = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "1.1s" }
};
const _hoisted_60$8 = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "1.2s" }
};
const _hoisted_61$7 = { class: "flex items-center p-3 bg-gray-50 dark:bg-[#0a0a0a] rounded-lg border border-gray-200 dark:border-gray-700 hover:bg-gray-100 dark:hover:bg-gray-800 transition-all duration-300" };
const _hoisted_62$7 = {
  for: "favorite",
  class: "ml-3 block text-sm text-gray-700 dark:text-white cursor-pointer hover:text-blue-600 dark:hover:text-blue-400 transition-colors duration-300"
};
const _hoisted_63$5 = { class: "px-6 py-4 border-t border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_64$5 = { class: "flex justify-end space-x-3" };
const _hoisted_65$5 = ["disabled"];
const _hoisted_66$5 = {
  key: 0,
  class: "animate-spin h-4 w-4",
  fill: "none",
  viewBox: "0 0 24 24"
};
const SEARCH_FREQUENCY_KEY = "vocabulary-category-search-frequency";
const _sfc_main$11 = /* @__PURE__ */ defineComponent({
  __name: "VocabularyFormDialog",
  props: {
    modelValue: { type: Boolean },
    vocabulary: { default: null },
    targetDate: { default: null }
  },
  emits: ["update:modelValue", "vocabulary-saved"],
  setup(__props, { emit: __emit }) {
    const ImageUpload$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ImageUpload),true              ?void 0:void 0));
    const TopicManager = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => TopicManager$1),true              ?void 0:void 0));
    const IpaPickerModal$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => IpaPickerModal),true              ?void 0:void 0));
    const KoreanInputHelper$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => KoreanInputHelper),true              ?void 0:void 0));
    const KoreanPronunciationHelper = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => KoreanPronunciationHelper$1),true              ?void 0:void 0));
    const props = __props;
    const emit = __emit;
    const { t, locale } = useI18n();
    const toast = useToast();
    const vocabularyStore = useVocabularyStore();
    const isSubmitting = ref(false);
    const refreshTrigger = ref(0);
    const showTopicManager = ref(false);
    const showKoreanInputHelper = ref(false);
    const showKoreanPronunciationHelper = ref(false);
    const categorySearchQuery = ref("");
    const showCategoryDropdown = ref(false);
    const categorySearchInput = ref(null);
    const dropdownElement = ref(null);
    const modalContentRef = ref(null);
    const categorySearchFrequency = ref({});
    const searchFrequencyTimeout = ref(null);
    const loadSearchFrequency = () => {
      try {
        const stored = localStorage.getItem(SEARCH_FREQUENCY_KEY);
        if (stored) {
          categorySearchFrequency.value = JSON.parse(stored);
        }
      } catch (error) {
        console.warn("Failed to load search frequency:", error);
        categorySearchFrequency.value = {};
      }
    };
    const saveSearchFrequency = () => {
      try {
        localStorage.setItem(SEARCH_FREQUENCY_KEY, JSON.stringify(categorySearchFrequency.value));
      } catch (error) {
        console.warn("Failed to save search frequency:", error);
      }
    };
    const updateSearchFrequency = (categoryKey) => {
      if (!categoryKey) return;
      categorySearchFrequency.value[categoryKey] = (categorySearchFrequency.value[categoryKey] || 0) + 1;
      saveSearchFrequency();
      console.log("Updated search frequency for:", categoryKey, "new count:", categorySearchFrequency.value[categoryKey]);
    };
    const categoryKeys = computed(() => {
      refreshTrigger.value;
      const categories = vocabularyStore.getCategories.value;
      console.log("Category keys computed with refreshTrigger:", refreshTrigger.value, "Categories:", categories);
      return categories;
    });
    const form = reactive({
      word: "",
      pronunciation: "",
      partOfSpeech: "",
      meaning: "",
      example: "",
      category: "",
      level: "",
      synonyms: "",
      antonyms: "",
      notes: "",
      favorite: false,
      image: null
    });
    const showIpaPicker = ref(false);
    const openIpaPicker = () => {
      showIpaPicker.value = true;
    };
    const onIpaApply = (value) => {
      form.pronunciation = value;
    };
    const openKoreanInputHelper = () => {
      showKoreanInputHelper.value = true;
    };
    const onKoreanInputConfirmed = (value) => {
      form.word = value;
    };
    const openKoreanPronunciationHelper = () => {
      showKoreanPronunciationHelper.value = true;
    };
    const onKoreanPronunciationConfirmed = (value) => {
      form.pronunciation = value;
    };
    const isEditing = computed(() => !!props.vocabulary);
    const categoryUsage = computed(() => vocabularyStore.getCategoryUsage.value);
    const isKoreanLocale = computed(() => locale.value === "ko");
    const filteredCategoryKeys = computed(() => {
      let filtered;
      if (!categorySearchQuery.value.trim()) {
        filtered = [...categoryKeys.value];
      } else {
        const query = categorySearchQuery.value.toLowerCase();
        filtered = categoryKeys.value.filter(
          (key) => getTopicDisplayName(key).toLowerCase().includes(query)
        );
        if (query.length >= 2) {
          filtered.forEach((key) => {
            if (getTopicDisplayName(key).toLowerCase().includes(query)) {
              if (searchFrequencyTimeout.value) {
                clearTimeout(searchFrequencyTimeout.value);
              }
              searchFrequencyTimeout.value = setTimeout(() => {
                updateSearchFrequency(key);
              }, 1e3);
            }
          });
        }
      }
      return filtered.sort((a, b) => {
        const freqA = categorySearchFrequency.value[a] || 0;
        const freqB = categorySearchFrequency.value[b] || 0;
        if (freqA !== freqB) {
          return freqB - freqA;
        }
        return getTopicDisplayName(a).localeCompare(getTopicDisplayName(b));
      });
    });
    const simpleDropdownStyle = computed(() => {
      if (!showCategoryDropdown.value) {
        return { display: "none" };
      }
      const inputElement = document.getElementById("category");
      if (!inputElement) {
        return {
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          width: "400px",
          maxWidth: "90vw"
        };
      }
      const rect = inputElement.getBoundingClientRect();
      return {
        top: rect.bottom + 4 + "px",
        left: rect.left + "px",
        width: Math.max(rect.width, 300) + "px",
        maxWidth: "500px"
      };
    });
    const validateWord = () => {
      if (!form.word.trim()) {
        toast.error(t("vocabulary.validation.wordRequired", "Word is required"));
        return false;
      } else if (form.word.trim().length > 100) {
        toast.error(t("vocabulary.validation.wordTooLong", "Word is too long"));
        return false;
      }
      return true;
    };
    const validateMeaning = () => {
      if (!form.meaning.trim()) {
        toast.error(t("vocabulary.validation.meaningRequired", "Meaning is required"));
        return false;
      } else if (form.meaning.trim().length > 500) {
        toast.error(t("vocabulary.validation.meaningTooLong", "Meaning is too long"));
        return false;
      }
      return true;
    };
    const validatePartOfSpeech = () => {
      if (!form.partOfSpeech) {
        toast.error(t("vocabulary.validation.partOfSpeechRequired", "Part of speech is required"));
        return false;
      }
      return true;
    };
    const validateCategory = () => {
      if (!form.category) {
        toast.error(t("vocabulary.validation.categoryRequired", "Category is required"));
        return false;
      }
      return true;
    };
    const validateLevel = () => {
      if (!form.level) {
        toast.error(t("vocabulary.validation.levelRequired", "Level is required"));
        return false;
      }
      return true;
    };
    const validateExample = () => {
      if (form.example.length > 500) {
        toast.error(t("vocabulary.validation.exampleTooLong", "Example is too long"));
        return false;
      }
      return true;
    };
    const validateNotes = () => {
      if (form.notes.length > 500) {
        toast.error(t("vocabulary.validation.notesTooLong", "Notes are too long"));
        return false;
      }
      return true;
    };
    const validatePronunciation = () => {
      if (form.pronunciation.length > 100) {
        toast.error(t("vocabulary.validation.pronunciationTooLong", "Pronunciation is too long"));
        return false;
      }
      return true;
    };
    const validateSynonyms = () => {
      if (form.synonyms && form.synonyms.trim()) {
        const synonyms = form.synonyms.split(",").map((s) => s.trim()).filter((s) => s);
        if (synonyms.length === 0) {
          toast.error(t("vocabulary.validation.synonymsInvalid", "Synonyms are invalid"));
          return false;
        }
      }
      return true;
    };
    const validateAntonyms = () => {
      if (form.antonyms && form.antonyms.trim()) {
        const antonyms = form.antonyms.split(",").map((s) => s.trim()).filter((s) => s);
        if (antonyms.length === 0) {
          toast.error(t("vocabulary.validation.antonymsInvalid", "Antonyms are invalid"));
          return false;
        }
      }
      return true;
    };
    const resetForm = () => {
      form.word = "";
      form.pronunciation = "";
      form.partOfSpeech = "";
      form.meaning = "";
      form.example = "";
      form.category = "";
      form.level = "";
      form.synonyms = "";
      form.antonyms = "";
      form.notes = "";
      form.favorite = false;
    };
    const handleScroll = () => {
      if (showCategoryDropdown.value) {
        showCategoryDropdown.value = false;
        categorySearchQuery.value = "";
        console.log("Scroll detected, dropdown closed");
      }
    };
    onMounted(() => {
      loadSearchFrequency();
      console.log("Loaded category search frequency:", categorySearchFrequency.value);
      nextTick(() => {
        if (modalContentRef.value) {
          modalContentRef.value.addEventListener("scroll", handleScroll, { passive: true });
          console.log("Added scroll listener to modal content");
        }
      });
    });
    onUnmounted(() => {
      if (modalContentRef.value) {
        modalContentRef.value.removeEventListener("scroll", handleScroll);
        modalContentRef.value.removeEventListener("scroll", handleScroll);
        console.log("Removed scroll listeners from modal content");
      }
    });
    watch(() => props.modelValue, (isOpen) => {
      if (!isOpen) {
        showCategoryDropdown.value = false;
        categorySearchQuery.value = "";
        document.body.style.overflow = "";
        console.log("Modal closed, dropdown closed, body scroll enabled");
      } else {
        document.body.style.overflow = "hidden";
        nextTick(() => {
          setTimeout(() => {
            if (modalContentRef.value) {
              modalContentRef.value.addEventListener("scroll", handleScroll, { passive: true });
              console.log("Added scroll listener to modal content on modal open");
            }
          }, 100);
        });
        console.log("Modal opened, body scroll disabled");
      }
    });
    watch(
      () => props.vocabulary,
      (newVocabulary) => {
        if (newVocabulary) {
          form.word = newVocabulary.word;
          form.pronunciation = newVocabulary.pronunciation || "";
          form.partOfSpeech = newVocabulary.partOfSpeech;
          form.meaning = newVocabulary.meaning;
          form.example = newVocabulary.example || "";
          form.category = newVocabulary.category;
          form.level = newVocabulary.level;
          form.synonyms = newVocabulary.synonyms?.join(", ") || "";
          form.antonyms = newVocabulary.antonyms?.join(", ") || "";
          form.notes = newVocabulary.notes || "";
          form.favorite = !!newVocabulary.favorite;
          form.image = newVocabulary.image || null;
        } else {
          resetForm();
        }
      },
      { immediate: true }
    );
    const handleKeydown = (event) => {
      if (event.key === "Escape") {
        closeDialog();
      }
    };
    watch(() => props.modelValue, (newValue) => {
      if (newValue) {
        window.dispatchEvent(new CustomEvent("vocabulary-edit-word"));
        if (!props.vocabulary) {
          resetForm();
        }
        document.body.style.overflow = "hidden";
        document.addEventListener("keydown", handleKeydown);
      } else {
        document.body.style.overflow = "";
        document.removeEventListener("keydown", handleKeydown);
      }
    });
    const getTopicDisplayName = (category) => {
      return getTopicName(category, t, locale);
    };
    const toggleCategoryDropdown = () => {
      console.log("Toggle category dropdown clicked");
      showCategoryDropdown.value = !showCategoryDropdown.value;
      if (showCategoryDropdown.value) {
        categorySearchQuery.value = "";
        nextTick(() => {
          categorySearchInput.value?.focus();
        });
      }
    };
    const closeCategoryDropdown = () => {
      showCategoryDropdown.value = false;
      categorySearchQuery.value = "";
    };
    const openTopicManager = () => {
      if (showCategoryDropdown.value) {
        closeCategoryDropdown();
      }
      showTopicManager.value = true;
    };
    const selectCategory = (key) => {
      form.category = key;
      showCategoryDropdown.value = false;
      categorySearchQuery.value = "";
      updateSearchFrequency(key);
      console.log("Category selected:", getTopicDisplayName(key));
    };
    const onTopicAdded = (newTopic) => {
      console.log("Topic added, refreshing categories:", newTopic.key);
      setTimeout(() => {
        vocabularyStore.refreshCustomTopics();
        refreshTrigger.value++;
        form.category = newTopic.key;
        console.log("Categories refreshed, new topic selected:", newTopic.key);
      }, 150);
    };
    const onTopicUpdated = () => {
      refreshTrigger.value++;
      vocabularyStore.refreshCustomTopics();
      console.log("Topic updated, refreshing categories");
    };
    const onTopicDeleted = (deletedTopicId) => {
      refreshTrigger.value++;
      vocabularyStore.refreshCustomTopics();
      if (form.category === deletedTopicId) {
        form.category = "";
      }
      console.log("Topic deleted, refreshing categories:", deletedTopicId);
    };
    const handleTopicsUpdated = () => {
      setTimeout(() => {
        refreshTrigger.value++;
        vocabularyStore.refreshCustomTopics();
        console.log("Topics updated, refreshing categories in form dialog");
      }, 100);
    };
    const handleClickOutside = (event) => {
      if (!showCategoryDropdown.value) return;
      const target = event.target;
      const dropdownContainer = target.closest(".relative");
      const dropdownMenu = target.closest('[class*="z-[99999]"]');
      if (dropdownContainer || dropdownMenu) {
        return;
      }
      closeCategoryDropdown();
    };
    onMounted(() => {
      window.addEventListener("topics-updated", handleTopicsUpdated);
      document.addEventListener("click", handleClickOutside);
    });
    onUnmounted(() => {
      document.body.style.overflow = "";
      document.body.classList.remove("modal-open");
      document.removeEventListener("keydown", handleKeydown);
      window.removeEventListener("topics-updated", handleTopicsUpdated);
      document.removeEventListener("click", handleClickOutside);
    });
    const closeDialog = () => {
      window.dispatchEvent(new CustomEvent("vocabulary-modal-closed"));
      emit("update:modelValue", false);
    };
    const submitForm = async () => {
      if (isSubmitting.value) return;
      if (!validateWord()) return;
      if (!validatePronunciation()) return;
      if (!validatePartOfSpeech()) return;
      if (!validateCategory()) return;
      if (!validateLevel()) return;
      if (!validateMeaning()) return;
      if (!validateExample()) return;
      if (!validateSynonyms()) return;
      if (!validateAntonyms()) return;
      if (!validateNotes()) return;
      isSubmitting.value = true;
      try {
        await new Promise((resolve) => setTimeout(resolve, 500));
        const vocabularyData = {
          word: form.word.trim(),
          pronunciation: form.pronunciation.trim(),
          partOfSpeech: form.partOfSpeech,
          meaning: form.meaning.trim(),
          example: form.example.trim(),
          category: form.category,
          level: form.level,
          synonyms: form.synonyms ? form.synonyms.split(",").map((s) => s.trim()).filter((s) => s) : [],
          antonyms: form.antonyms ? form.antonyms.split(",").map((s) => s.trim()).filter((s) => s) : [],
          notes: form.notes.trim(),
          favorite: form.favorite,
          image: form.image
        };
        if (isEditing.value && props.vocabulary) {
          vocabularyStore.updateVocabulary(props.vocabulary.id, vocabularyData);
          console.log("Vocabulary updated:", props.vocabulary.id, vocabularyData);
          toast.success(t("vocabulary.validation.updateSuccess", "Vocabulary updated successfully!"));
        } else {
          if (props.targetDate) {
            const now = /* @__PURE__ */ new Date();
            const [year, month, day] = props.targetDate.split("-");
            const targetDateObj = new Date(parseInt(year), parseInt(month) - 1, parseInt(day), now.getHours(), now.getMinutes(), now.getSeconds(), now.getMilliseconds());
            vocabularyData.createdAt = targetDateObj.toISOString();
            vocabularyData.updatedAt = targetDateObj.toISOString();
          }
          const newVocabulary = vocabularyStore.addVocabulary(vocabularyData);
          console.log("Vocabulary added:", newVocabulary);
          toast.success(t("vocabulary.validation.saveSuccess", "Vocabulary added successfully!"));
        }
        emit("vocabulary-saved", { category: vocabularyData.category });
        setTimeout(() => {
          closeDialog();
        }, 500);
      } catch (error) {
        console.error("Error saving vocabulary:", error);
        toast.error(t("vocabulary.validation.saveError", "Error saving vocabulary"));
      } finally {
        isSubmitting.value = false;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$11, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$_, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 flex flex-col h-full overflow-hidden transform",
                      onClick: _cache[18] || (_cache[18] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$Y, [
                        createBaseVNode("div", _hoisted_4$W, [
                          createBaseVNode("h2", _hoisted_5$T, [
                            _cache[23] || (_cache[23] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(isEditing.value ? unref(t)("vocabulary.editVocabulary", "Edit Vocabulary") : unref(t)("vocabulary.addVocabulary", "Add Vocabulary")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: closeDialog,
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[24] || (_cache[24] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", {
                        ref_key: "modalContentRef",
                        ref: modalContentRef,
                        class: "px-6 py-4 flex-1 overflow-y-auto min-h-0"
                      }, [
                        createBaseVNode("form", {
                          onSubmit: withModifiers(submitForm, ["prevent"]),
                          class: "space-y-6"
                        }, [
                          createBaseVNode("div", _hoisted_6$R, [
                            createBaseVNode("div", _hoisted_7$P, [
                              createBaseVNode("label", _hoisted_8$P, [
                                _cache[25] || (_cache[25] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.word", "Word")) + " ", 1),
                                _cache[26] || (_cache[26] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              createBaseVNode("div", _hoisted_9$O, [
                                withDirectives(createBaseVNode("input", {
                                  id: "word",
                                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => form.word = $event),
                                  type: "text",
                                  required: "",
                                  class: normalizeClass([
                                    "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 hover:border-blue-400 dark:hover:border-blue-500 transform hover:scale-[1.02]",
                                    isKoreanLocale.value ? "pr-12" : ""
                                  ]),
                                  placeholder: isKoreanLocale.value ? unref(t)("korean.wordPlaceholder", "Enter Korean word or click + for help") : unref(t)("vocabulary.wordPlaceholder", "Enter English word"),
                                  onBlur: validateWord
                                }, null, 42, _hoisted_10$N), [
                                  [vModelText, form.word]
                                ]),
                                isKoreanLocale.value ? (openBlock(), createElementBlock("button", {
                                  key: 0,
                                  type: "button",
                                  onClick: openKoreanInputHelper,
                                  class: "absolute right-2 top-1/2 -translate-y-1/2 w-7 h-7 bg-blue-500 hover:bg-blue-600 text-white rounded-full flex items-center justify-center text-sm font-bold transition-all duration-300 hover:scale-110 z-[5] shadow-lg keep-center-hover",
                                  title: unref(t)("korean.inputHelper.openHelper", "Open Korean Input Helper"),
                                  "aria-label": unref(t)("korean.inputHelper.openHelper", "Open Korean Input Helper")
                                }, " + ", 8, _hoisted_11$N)) : createCommentVNode("", true)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_12$M, [
                              createBaseVNode("label", _hoisted_13$M, [
                                _cache[27] || (_cache[27] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.pronunciation.label", "Pronunciation")), 1)
                              ]),
                              createBaseVNode("div", _hoisted_14$M, [
                                withDirectives(createBaseVNode("input", {
                                  id: "pronunciation",
                                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => form.pronunciation = $event),
                                  type: "text",
                                  class: "w-full pr-12 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-300 hover:border-green-400 dark:hover:border-green-500 transform hover:scale-[1.02]",
                                  placeholder: isKoreanLocale.value ? unref(t)("korean.pronunciationPlaceholder", "an-nyeong-ha-se-yo") : "/eksmpl/",
                                  onBlur: validatePronunciation
                                }, null, 40, _hoisted_15$H), [
                                  [vModelText, form.pronunciation]
                                ]),
                                createBaseVNode("button", {
                                  type: "button",
                                  onClick: _cache[2] || (_cache[2] = ($event) => isKoreanLocale.value ? openKoreanPronunciationHelper() : openIpaPicker()),
                                  class: "absolute right-2 top-1/2 -translate-y-1/2 w-7 h-7 bg-green-500 hover:bg-green-600 text-white rounded-full flex items-center justify-center text-sm font-bold transition-all duration-300 hover:scale-110 z-[5] shadow-lg keep-center-hover",
                                  title: isKoreanLocale.value ? unref(t)("korean.pronunciationHelper.openHelper", "Open Korean Pronunciation Helper") : unref(t)("vocabulary.pronunciation.openIpaPicker", "Open IPA Picker"),
                                  "aria-label": isKoreanLocale.value ? unref(t)("korean.pronunciationHelper.openHelper", "Open Korean Pronunciation Helper") : unref(t)("vocabulary.pronunciation.openIpaPicker", "Open IPA Picker")
                                }, " + ", 8, _hoisted_16$G)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_17$F, [
                              createBaseVNode("label", _hoisted_18$D, [
                                _cache[28] || (_cache[28] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.wordType", "Word Type")) + " ", 1),
                                _cache[29] || (_cache[29] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              withDirectives(createBaseVNode("select", {
                                id: "partOfSpeech",
                                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => form.partOfSpeech = $event),
                                required: "",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-300 hover:border-purple-400 dark:hover:border-purple-500 transform hover:scale-[1.02] cursor-pointer",
                                onChange: validatePartOfSpeech
                              }, [
                                createBaseVNode("option", _hoisted_19$D, toDisplayString$1(unref(t)("vocabulary.selectWordType", "Select word type")), 1),
                                createBaseVNode("option", _hoisted_20$C, toDisplayString$1(unref(t)("vocabulary.wordTypes.noun", "Noun")), 1),
                                createBaseVNode("option", _hoisted_21$C, toDisplayString$1(unref(t)("vocabulary.wordTypes.verb", "Verb")), 1),
                                createBaseVNode("option", _hoisted_22$A, toDisplayString$1(unref(t)("vocabulary.wordTypes.adjective", "Adjective")), 1),
                                createBaseVNode("option", _hoisted_23$A, toDisplayString$1(unref(t)("vocabulary.wordTypes.adverb", "Adverb")), 1),
                                createBaseVNode("option", _hoisted_24$z, toDisplayString$1(unref(t)("vocabulary.wordTypes.preposition", "Preposition")), 1),
                                createBaseVNode("option", _hoisted_25$z, toDisplayString$1(unref(t)("vocabulary.wordTypes.conjunction", "Conjunction")), 1),
                                createBaseVNode("option", _hoisted_26$x, toDisplayString$1(unref(t)("vocabulary.wordTypes.interjection", "Interjection")), 1)
                              ], 544), [
                                [vModelSelect, form.partOfSpeech]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_27$w, [
                              createBaseVNode("label", _hoisted_28$v, [
                                _cache[30] || (_cache[30] = createBaseVNode("span", { class: "w-1 h-4 bg-orange-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.category", "Category")) + " ", 1),
                                _cache[31] || (_cache[31] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              createBaseVNode("div", _hoisted_29$t, [
                                createBaseVNode("button", {
                                  type: "button",
                                  onClick: _cache[4] || (_cache[4] = ($event) => openTopicManager()),
                                  class: "absolute left-2 top-1/2 transform -translate-y-1/2 w-6 h-6 bg-blue-500 hover:bg-blue-600 text-white rounded-full flex items-center justify-center text-sm font-bold transition-all duration-300 hover:scale-110 hover:rotate-90 z-[10000] shadow-lg keep-center-hover-rotate",
                                  title: unref(t)("vocabulary.addCategory", "Add Category")
                                }, " + ", 8, _hoisted_30$s),
                                createBaseVNode("div", _hoisted_31$r, [
                                  createBaseVNode("input", {
                                    id: "category",
                                    type: "text",
                                    required: "",
                                    readonly: "",
                                    onClick: toggleCategoryDropdown,
                                    class: "w-full pl-10 pr-10 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all duration-300 hover:border-orange-400 dark:hover:border-orange-500 transform hover:scale-[1.02] cursor-pointer",
                                    placeholder: unref(t)("vocabulary.selectCategory", "Select category"),
                                    value: form.category ? getTopicDisplayName(form.category) : ""
                                  }, null, 8, _hoisted_32$o),
                                  createBaseVNode("div", _hoisted_33$o, [
                                    (openBlock(), createElementBlock("svg", {
                                      class: normalizeClass(["w-4 h-4 text-gray-400 transition-transform duration-200", { "rotate-180": showCategoryDropdown.value }]),
                                      fill: "none",
                                      stroke: "currentColor",
                                      viewBox: "0 0 24 24"
                                    }, _cache[32] || (_cache[32] = [
                                      createBaseVNode("path", {
                                        "stroke-linecap": "round",
                                        "stroke-linejoin": "round",
                                        "stroke-width": "2",
                                        d: "M19 9l-7 7-7-7"
                                      }, null, -1)
                                    ]), 2))
                                  ]),
                                  (openBlock(), createBlock(Teleport, { to: "body" }, [
                                    createVNode(Transition, {
                                      "enter-active-class": "transition duration-200 ease-out",
                                      "enter-from-class": "transform scale-95 opacity-0",
                                      "enter-to-class": "transform scale-100 opacity-100",
                                      "leave-active-class": "transition duration-75 ease-in",
                                      "leave-from-class": "transform scale-100 opacity-100",
                                      "leave-to-class": "transform scale-95 opacity-0"
                                    }, {
                                      default: withCtx(() => [
                                        showCategoryDropdown.value ? (openBlock(), createElementBlock("div", {
                                          key: 0,
                                          ref_key: "dropdownElement",
                                          ref: dropdownElement,
                                          style: normalizeStyle(simpleDropdownStyle.value),
                                          class: "fixed z-[9999] bg-white dark:bg-[#0a0a0a] border border-gray-300 dark:border-gray-600 rounded-lg shadow-xl max-h-60 overflow-hidden"
                                        }, [
                                          createBaseVNode("div", {
                                            class: "p-2 border-b border-gray-200 dark:border-gray-600",
                                            onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                                            }, ["stop"]))
                                          }, [
                                            withDirectives(createBaseVNode("input", {
                                              ref_key: "categorySearchInput",
                                              ref: categorySearchInput,
                                              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => categorySearchQuery.value = $event),
                                              type: "text",
                                              class: "w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent",
                                              placeholder: unref(t)("vocabulary.searchCategory", "Search categories..."),
                                              onKeydown: [
                                                _cache[6] || (_cache[6] = withKeys(withModifiers(() => {
                                                }, ["prevent"]), ["enter"])),
                                                withKeys(closeCategoryDropdown, ["escape"])
                                              ],
                                              onClick: _cache[7] || (_cache[7] = withModifiers(() => {
                                              }, ["stop"])),
                                              onFocus: _cache[8] || (_cache[8] = withModifiers(() => {
                                              }, ["stop"]))
                                            }, null, 40, _hoisted_34$l), [
                                              [vModelText, categorySearchQuery.value]
                                            ])
                                          ]),
                                          createBaseVNode("div", _hoisted_35$l, [
                                            filteredCategoryKeys.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_36$k, toDisplayString$1(unref(t)("vocabulary.noCategories", "No categories found")), 1)) : createCommentVNode("", true),
                                            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredCategoryKeys.value, (key) => {
                                              return openBlock(), createElementBlock("div", {
                                                key,
                                                class: normalizeClass(["px-3 py-2 text-sm cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-custom transition-colors duration-150", { "bg-orange-50 dark:bg-orange-900/20 text-orange-700 dark:text-orange-300": form.category === key }]),
                                                onClick: ($event) => selectCategory(key)
                                              }, toDisplayString$1(getTopicDisplayName(key)), 11, _hoisted_37$j);
                                            }), 128))
                                          ])
                                        ], 4)) : createCommentVNode("", true)
                                      ]),
                                      _: 1
                                    })
                                  ]))
                                ])
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_38$j, [
                              createBaseVNode("label", _hoisted_39$h, [
                                _cache[33] || (_cache[33] = createBaseVNode("span", { class: "w-1 h-4 bg-red-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.level", "Level")) + " ", 1),
                                _cache[34] || (_cache[34] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              withDirectives(createBaseVNode("select", {
                                id: "level",
                                "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => form.level = $event),
                                required: "",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all duration-300 hover:border-red-400 dark:hover:border-red-500 transform hover:scale-[1.02] cursor-pointer",
                                onChange: validateLevel
                              }, [
                                createBaseVNode("option", _hoisted_40$h, toDisplayString$1(unref(t)("vocabulary.selectLevel", "Select level")), 1),
                                createBaseVNode("option", _hoisted_41$g, toDisplayString$1(unref(t)("vocabulary.levels.beginner", "Beginner")), 1),
                                createBaseVNode("option", _hoisted_42$e, toDisplayString$1(unref(t)("vocabulary.levels.intermediate", "Intermediate")), 1),
                                createBaseVNode("option", _hoisted_43$d, toDisplayString$1(unref(t)("vocabulary.levels.advanced", "Advanced")), 1)
                              ], 544), [
                                [vModelSelect, form.level]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_44$d, [
                              createBaseVNode("label", _hoisted_45$c, [
                                _cache[35] || (_cache[35] = createBaseVNode("span", { class: "w-1 h-4 bg-indigo-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.meaning", "Meaning")) + " ", 1),
                                _cache[36] || (_cache[36] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              withDirectives(createBaseVNode("textarea", {
                                id: "meaning",
                                "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => form.meaning = $event),
                                required: "",
                                rows: "3",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent resize-none transition-all duration-300 hover:border-indigo-400 dark:hover:border-indigo-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("vocabulary.meaningPlaceholder", "Enter meaning in Vietnamese"),
                                onBlur: validateMeaning
                              }, null, 40, _hoisted_46$c), [
                                [vModelText, form.meaning]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_47$c, [
                              createBaseVNode("label", _hoisted_48$c, [
                                _cache[37] || (_cache[37] = createBaseVNode("span", { class: "w-1 h-4 bg-teal-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.example", "Example")), 1)
                              ]),
                              withDirectives(createBaseVNode("textarea", {
                                id: "example",
                                "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => form.example = $event),
                                rows: "2",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all duration-300 hover:border-teal-400 dark:hover:border-teal-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("vocabulary.examplePlaceholder", "Enter example sentence"),
                                onBlur: validateExample
                              }, null, 40, _hoisted_49$b), [
                                [vModelText, form.example]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_50$a, [
                              createBaseVNode("label", _hoisted_51$9, [
                                _cache[38] || (_cache[38] = createBaseVNode("span", { class: "w-1 h-4 bg-pink-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.synonyms", "Synonyms")), 1)
                              ]),
                              withDirectives(createBaseVNode("input", {
                                id: "synonyms",
                                "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => form.synonyms = $event),
                                type: "text",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-transparent transition-all duration-300 hover:border-pink-400 dark:hover:border-pink-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("vocabulary.separateByComma", "Separate by comma"),
                                onBlur: validateSynonyms
                              }, null, 40, _hoisted_52$9), [
                                [vModelText, form.synonyms]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_53$9, [
                              createBaseVNode("label", _hoisted_54$9, [
                                _cache[39] || (_cache[39] = createBaseVNode("span", { class: "w-1 h-4 bg-yellow-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.antonyms", "Antonyms")), 1)
                              ]),
                              withDirectives(createBaseVNode("input", {
                                id: "antonyms",
                                "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => form.antonyms = $event),
                                type: "text",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent transition-all duration-300 hover:border-yellow-400 dark:hover:border-yellow-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("vocabulary.separateByComma", "Separate by comma"),
                                onBlur: validateAntonyms
                              }, null, 40, _hoisted_55$9), [
                                [vModelText, form.antonyms]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_56$9, [
                              createBaseVNode("label", _hoisted_57$9, [
                                _cache[40] || (_cache[40] = createBaseVNode("span", { class: "w-1 h-4 bg-cyan-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.imageUrl", "Image URL")), 1)
                              ]),
                              withDirectives(createBaseVNode("textarea", {
                                id: "imageUrl",
                                "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => form.image = $event),
                                rows: "3",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent resize-none transition-all duration-300 hover:border-cyan-400 dark:hover:border-cyan-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("vocabulary.imageUrlPlaceholder", "Enter image URL (optional)")
                              }, null, 8, _hoisted_58$9), [
                                [vModelText, form.image]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_59$8, [
                              createVNode(unref(ImageUpload$1), {
                                modelValue: form.image,
                                "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => form.image = $event)
                              }, null, 8, ["modelValue"])
                            ]),
                            createBaseVNode("div", _hoisted_60$8, [
                              createBaseVNode("div", _hoisted_61$7, [
                                withDirectives(createBaseVNode("input", {
                                  id: "favorite",
                                  "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => form.favorite = $event),
                                  type: "checkbox",
                                  class: "h-5 w-5 text-blue-600 focus:ring-blue-500 border-gray-300 dark:border-gray-600 rounded transition-all duration-300 hover:scale-110 cursor-pointer"
                                }, null, 512), [
                                  [vModelCheckbox, form.favorite]
                                ]),
                                createBaseVNode("label", _hoisted_62$7, toDisplayString$1(unref(t)("vocabulary.isFavorite", "Mark as favorite")), 1)
                              ])
                            ])
                          ])
                        ], 32)
                      ], 512),
                      createBaseVNode("div", _hoisted_63$5, [
                        createBaseVNode("div", _hoisted_64$5, [
                          createBaseVNode("button", {
                            type: "button",
                            onClick: closeDialog,
                            class: "px-6 py-2 text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium"
                          }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                          createBaseVNode("button", {
                            onClick: submitForm,
                            disabled: isSubmitting.value,
                            class: "px-6 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg hover:from-blue-600 hover:to-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 flex items-center space-x-2 transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium disabled:cursor-not-allowed"
                          }, [
                            isSubmitting.value ? (openBlock(), createElementBlock("svg", _hoisted_66$5, _cache[41] || (_cache[41] = [
                              createBaseVNode("circle", {
                                class: "opacity-25",
                                cx: "12",
                                cy: "12",
                                r: "10",
                                stroke: "currentColor",
                                "stroke-width": "4"
                              }, null, -1),
                              createBaseVNode("path", {
                                class: "opacity-75",
                                fill: "currentColor",
                                d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                              }, null, -1)
                            ]))) : createCommentVNode("", true),
                            createBaseVNode("span", null, toDisplayString$1(isSubmitting.value ? unref(t)("common.saving", "Saving...") : isEditing.value ? unref(t)("common.update", "Update") : unref(t)("vocabulary.saveVocabulary", "Save Vocabulary")), 1)
                          ], 8, _hoisted_65$5)
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        }),
        createVNode(unref(IpaPickerModal$1), {
          modelValue: showIpaPicker.value,
          "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => showIpaPicker.value = $event),
          "initial-value": form.pronunciation,
          onApply: onIpaApply
        }, null, 8, ["modelValue", "initial-value"]),
        showTopicManager.value ? (openBlock(), createBlock(unref(TopicManager), {
          key: 0,
          modelValue: showTopicManager.value,
          "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => showTopicManager.value = $event),
          "vocabulary-usage": categoryUsage.value,
          onTopicAdded,
          onTopicUpdated,
          onTopicDeleted
        }, null, 8, ["modelValue", "vocabulary-usage"])) : createCommentVNode("", true),
        showKoreanInputHelper.value ? (openBlock(), createBlock(unref(KoreanInputHelper$1), {
          key: 1,
          modelValue: showKoreanInputHelper.value,
          "onUpdate:modelValue": _cache[21] || (_cache[21] = ($event) => showKoreanInputHelper.value = $event),
          "initial-value": form.word,
          onInputConfirmed: onKoreanInputConfirmed
        }, null, 8, ["modelValue", "initial-value"])) : createCommentVNode("", true),
        showKoreanPronunciationHelper.value ? (openBlock(), createBlock(unref(KoreanPronunciationHelper), {
          key: 2,
          modelValue: showKoreanPronunciationHelper.value,
          "onUpdate:modelValue": _cache[22] || (_cache[22] = ($event) => showKoreanPronunciationHelper.value = $event),
          "initial-value": form.pronunciation,
          onPronunciationConfirmed: onKoreanPronunciationConfirmed
        }, null, 8, ["modelValue", "initial-value"])) : createCommentVNode("", true)
      ]);
    };
  }
});

const VocabularyFormDialog = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["__scopeId", "data-v-c4851cdd"]]);

const VocabularyFormDialog$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: VocabularyFormDialog
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$10 = { class: "flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-600 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] rounded-t-lg" };
const _hoisted_2$Z = { class: "text-lg font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_3$X = {
  key: 0,
  class: "p-6 overflow-y-auto flex-1"
};
const _hoisted_4$V = {
  class: "mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_5$S = { class: "flex items-center space-x-4 mb-2" };
const _hoisted_6$Q = { class: "text-3xl font-bold text-gray-900 dark:text-white" };
const _hoisted_7$O = ["title"];
const _hoisted_8$O = ["title"];
const _hoisted_9$N = {
  class: "w-6 h-6",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_10$M = {
  key: 0,
  d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"
};
const _hoisted_11$M = {
  key: 1,
  d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2"
};
const _hoisted_12$L = { class: "text-lg text-gray-600 dark:text-gray-300 mb-1" };
const _hoisted_13$L = { class: "flex items-center space-x-3" };
const _hoisted_14$L = { class: "px-3 py-1 text-sm bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-full transition-all duration-300 hover:scale-105" };
const _hoisted_15$G = { class: "px-3 py-1 text-sm bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 rounded-full transition-all duration-300 hover:scale-105" };
const _hoisted_16$F = {
  key: 0,
  class: "mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_17$E = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-3 flex items-center" };
const _hoisted_18$C = { class: "flex justify-center" };
const _hoisted_19$C = { class: "max-w-md w-full" };
const _hoisted_20$B = { class: "relative rounded-lg overflow-hidden border-2 border-gray-200 dark:border-gray-600 shadow-lg" };
const _hoisted_21$B = ["src", "alt"];
const _hoisted_22$z = { class: "absolute inset-0 bg-black bg-opacity-0 hover:bg-opacity-10 transition-all duration-200 flex items-center justify-center opacity-0 hover:opacity-100" };
const _hoisted_23$z = { class: "bg-white dark:bg-gray-800 bg-opacity-90 dark:bg-opacity-90 px-3 py-1 rounded-full" };
const _hoisted_24$y = { class: "text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_25$y = {
  class: "mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_26$w = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-2 flex items-center" };
const _hoisted_27$v = { class: "text-gray-700 dark:text-gray-300 text-lg" };
const _hoisted_28$u = {
  key: 1,
  class: "mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_29$s = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-2 flex items-center" };
const _hoisted_30$r = { class: "bg-gray-50 dark:bg-gray-800 rounded-lg p-4" };
const _hoisted_31$q = { class: "flex items-start space-x-3" };
const _hoisted_32$n = { class: "flex-1" };
const _hoisted_33$n = { class: "text-gray-700 dark:text-gray-300 italic text-lg" };
const _hoisted_34$k = ["title"];
const _hoisted_35$k = {
  key: 2,
  class: "mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_36$j = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-2 flex items-center" };
const _hoisted_37$i = { class: "flex flex-wrap gap-2" };
const _hoisted_38$i = {
  key: 3,
  class: "mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_39$g = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-2 flex items-center" };
const _hoisted_40$g = { class: "flex flex-wrap gap-2" };
const _hoisted_41$f = {
  key: 4,
  class: "mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_42$d = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-2 flex items-center" };
const _hoisted_43$c = { class: "bg-yellow-50 dark:bg-yellow-900/10 border-l-4 border-yellow-400 dark:border-yellow-500 p-4" };
const _hoisted_44$c = { class: "text-gray-700 dark:text-gray-300" };
const _hoisted_45$b = {
  class: "border-t border-gray-200 dark:border-gray-600 pt-4 animate-fade-in-up",
  style: { "animation-delay": "0.8s" }
};
const _hoisted_46$b = { class: "grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_47$b = {
  key: 0,
  class: "flex items-center space-x-2"
};
const _hoisted_48$b = {
  key: 1,
  class: "flex items-center space-x-2"
};
const _hoisted_49$a = { class: "flex items-center justify-end space-x-3 p-6 border-t border-gray-200 dark:border-gray-600 bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] rounded-b-lg" };
const _sfc_main$10 = /* @__PURE__ */ defineComponent({
  __name: "VocabularyDetailDialog",
  props: {
    modelValue: { type: Boolean },
    vocabulary: {}
  },
  emits: ["update:modelValue", "edit-vocabulary", "toggle-favorite"],
  setup(__props, { emit: __emit }) {
    const { t, locale } = useI18n();
    const modalStore = useModalStore();
    const props = __props;
    const emit = __emit;
    const { playAudio: playVoiceAudio } = useVoiceStore();
    const playAudio = (text) => {
      playVoiceAudio(text);
    };
    watch(() => props.modelValue, (newValue) => {
      modalStore.showVocabularyDetail = newValue;
    });
    const closeDialog = () => {
      window.dispatchEvent(new CustomEvent("vocabulary-modal-closed"));
      emit("update:modelValue", false);
    };
    const editVocabulary = () => {
      if (props.vocabulary) {
        emit("edit-vocabulary", props.vocabulary);
        closeDialog();
      }
    };
    const toggleFavorite = () => {
      if (props.vocabulary) {
        emit("toggle-favorite", props.vocabulary);
      }
    };
    const handleImageError = (event) => {
      const img = event.target;
      console.warn(`Failed to load image for vocabulary: ${props.vocabulary?.word}`, img.src);
      const imageSection = img.closest(".mb-6");
      if (imageSection) {
        imageSection.style.display = "none";
      }
    };
    const getLevelColor = (level) => {
      switch (level) {
        case "beginner":
          return "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200";
        case "intermediate":
          return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200";
        case "advanced":
          return "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200";
        default:
          return "bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200";
      }
    };
    const handleKeydown = (event) => {
      if (event.key === "Escape") {
        closeDialog();
      }
    };
    watch(() => props.modelValue, (newValue) => {
      if (newValue) {
        window.dispatchEvent(new CustomEvent("vocabulary-view-details"));
        document.body.style.overflow = "hidden";
        document.addEventListener("keydown", handleKeydown);
      } else {
        document.body.style.overflow = "";
        document.removeEventListener("keydown", handleKeydown);
      }
    }, { immediate: true });
    onUnmounted(() => {
      document.body.style.overflow = "";
      document.removeEventListener("keydown", handleKeydown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.modelValue ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 backdrop-blur-sm",
              onKeyup: withKeys(closeDialog, ["esc"])
            }, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: "bg-white dark:bg-[#0a0a0a] rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[90vh] border border-gray-200 dark:border-gray-700 transform overflow-hidden flex flex-col",
                    onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("div", _hoisted_1$10, [
                      createBaseVNode("h3", _hoisted_2$Z, [
                        _cache[3] || (_cache[3] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                        createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.details.title", "Vocabulary Details")), 1)
                      ]),
                      createBaseVNode("button", {
                        onClick: closeDialog,
                        class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                      }, _cache[4] || (_cache[4] = [
                        createBaseVNode("svg", {
                          class: "w-6 h-6",
                          fill: "none",
                          stroke: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          createBaseVNode("path", {
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            "stroke-width": "2",
                            d: "M6 18L18 6M6 6l12 12"
                          })
                        ], -1)
                      ]))
                    ]),
                    _ctx.vocabulary ? (openBlock(), createElementBlock("div", _hoisted_3$X, [
                      createBaseVNode("div", _hoisted_4$V, [
                        createBaseVNode("div", _hoisted_5$S, [
                          createBaseVNode("h1", _hoisted_6$Q, toDisplayString$1(_ctx.vocabulary.word), 1),
                          createBaseVNode("button", {
                            onClick: _cache[0] || (_cache[0] = ($event) => playAudio(_ctx.vocabulary.word)),
                            class: "flex items-center justify-center w-10 h-10 bg-blue-500 hover:bg-blue-600 text-white rounded-full transition-all duration-300 hover:scale-110 hover:shadow-lg transform hover:-translate-y-0.5",
                            title: unref(t)("vocabulary.details.playAudio", "Play Audio")
                          }, _cache[5] || (_cache[5] = [
                            createBaseVNode("svg", {
                              class: "w-5 h-5",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", {
                                "fill-rule": "evenodd",
                                d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.816L4.846 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.846l3.537-3.816a1 1 0 011.617.816zM16 8a2 2 0 11-4 0 2 2 0 014 0zM14 8a2 2 0 012-2v4a2 2 0 01-2-2z",
                                "clip-rule": "evenodd"
                              })
                            ], -1)
                          ]), 8, _hoisted_7$O),
                          createBaseVNode("button", {
                            onClick: toggleFavorite,
                            class: normalizeClass(["flex items-center justify-center w-10 h-10 rounded-full transition-all duration-300 hover:scale-110 transform hover:-translate-y-0.5", _ctx.vocabulary.favorite ? "text-yellow-500 hover:text-yellow-600" : "text-gray-400 hover:text-yellow-500"]),
                            title: _ctx.vocabulary.favorite ? unref(t)("vocabulary.details.removeFavorite", "Remove from favorites") : unref(t)("vocabulary.details.addFavorite", "Add to favorites")
                          }, [
                            (openBlock(), createElementBlock("svg", _hoisted_9$N, [
                              _ctx.vocabulary.favorite ? (openBlock(), createElementBlock("path", _hoisted_10$M)) : (openBlock(), createElementBlock("path", _hoisted_11$M))
                            ]))
                          ], 10, _hoisted_8$O)
                        ]),
                        createBaseVNode("p", _hoisted_12$L, toDisplayString$1(_ctx.vocabulary.pronunciation), 1),
                        createBaseVNode("div", _hoisted_13$L, [
                          createBaseVNode("span", {
                            class: normalizeClass([getLevelColor(_ctx.vocabulary.level), "px-3 py-1 text-sm font-medium rounded-full transition-all duration-300 hover:scale-105"])
                          }, toDisplayString$1(unref(t)(`vocabulary.levels.${_ctx.vocabulary.level}`, _ctx.vocabulary.level)), 3),
                          createBaseVNode("span", _hoisted_14$L, toDisplayString$1(unref(getTopicName)(_ctx.vocabulary.category)), 1),
                          createBaseVNode("span", _hoisted_15$G, toDisplayString$1(unref(t)(`vocabulary.wordTypes.${_ctx.vocabulary.partOfSpeech}`, _ctx.vocabulary.partOfSpeech)), 1)
                        ])
                      ]),
                      _ctx.vocabulary.image ? (openBlock(), createElementBlock("div", _hoisted_16$F, [
                        createBaseVNode("h3", _hoisted_17$E, [
                          _cache[6] || (_cache[6] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.image.title", "Image")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_18$C, [
                          createBaseVNode("div", _hoisted_19$C, [
                            createBaseVNode("div", _hoisted_20$B, [
                              createBaseVNode("img", {
                                src: _ctx.vocabulary.image,
                                alt: `${unref(t)("vocabulary.image.preview")} - ${_ctx.vocabulary.word}`,
                                class: "w-full h-auto max-h-80 object-cover transition-all duration-300 hover:scale-105",
                                onError: handleImageError
                              }, null, 40, _hoisted_21$B),
                              createBaseVNode("div", _hoisted_22$z, [
                                createBaseVNode("div", _hoisted_23$z, [
                                  createBaseVNode("span", _hoisted_24$y, toDisplayString$1(_ctx.vocabulary.word), 1)
                                ])
                              ])
                            ])
                          ])
                        ])
                      ])) : createCommentVNode("", true),
                      createBaseVNode("div", _hoisted_25$y, [
                        createBaseVNode("h3", _hoisted_26$w, [
                          _cache[7] || (_cache[7] = createBaseVNode("span", { class: "w-1 h-4 bg-indigo-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.meaning", "Meaning")), 1)
                        ]),
                        createBaseVNode("p", _hoisted_27$v, toDisplayString$1(_ctx.vocabulary.meaning), 1)
                      ]),
                      _ctx.vocabulary.example ? (openBlock(), createElementBlock("div", _hoisted_28$u, [
                        createBaseVNode("h3", _hoisted_29$s, [
                          _cache[8] || (_cache[8] = createBaseVNode("span", { class: "w-1 h-4 bg-teal-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.example", "Example")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_30$r, [
                          createBaseVNode("div", _hoisted_31$q, [
                            createBaseVNode("div", _hoisted_32$n, [
                              createBaseVNode("p", _hoisted_33$n, ' "' + toDisplayString$1(_ctx.vocabulary.example) + '" ', 1)
                            ]),
                            createBaseVNode("button", {
                              onClick: _cache[1] || (_cache[1] = ($event) => playAudio(_ctx.vocabulary.example)),
                              class: "flex items-center justify-center w-8 h-8 bg-green-500 hover:bg-green-600 text-white rounded-full transition-all duration-300 hover:scale-110 transform hover:-translate-y-0.5 flex-shrink-0",
                              title: unref(t)("vocabulary.details.playExample")
                            }, _cache[9] || (_cache[9] = [
                              createBaseVNode("svg", {
                                class: "w-4 h-4",
                                fill: "currentColor",
                                viewBox: "0 0 20 20"
                              }, [
                                createBaseVNode("path", {
                                  "fill-rule": "evenodd",
                                  d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.816L4.846 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.846l3.537-3.816a1 1 0 011.617.816zM16 8a2 2 0 11-4 0 2 2 0 014 0zM14 8a2 2 0 012-2v4a2 2 0 01-2-2z",
                                  "clip-rule": "evenodd"
                                })
                              ], -1)
                            ]), 8, _hoisted_34$k)
                          ])
                        ])
                      ])) : createCommentVNode("", true),
                      _ctx.vocabulary.synonyms && _ctx.vocabulary.synonyms.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_35$k, [
                        createBaseVNode("h3", _hoisted_36$j, [
                          _cache[10] || (_cache[10] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.synonyms", "Synonyms")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_37$i, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.vocabulary.synonyms, (synonym) => {
                            return openBlock(), createElementBlock("span", {
                              key: synonym,
                              class: "px-3 py-1 bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300 rounded-full text-sm transition-all duration-300 hover:scale-105 hover:shadow-md"
                            }, toDisplayString$1(synonym), 1);
                          }), 128))
                        ])
                      ])) : createCommentVNode("", true),
                      _ctx.vocabulary.antonyms && _ctx.vocabulary.antonyms.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_38$i, [
                        createBaseVNode("h3", _hoisted_39$g, [
                          _cache[11] || (_cache[11] = createBaseVNode("span", { class: "w-1 h-4 bg-red-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.antonyms", "Antonyms")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_40$g, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.vocabulary.antonyms, (antonym) => {
                            return openBlock(), createElementBlock("span", {
                              key: antonym,
                              class: "px-3 py-1 bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-300 rounded-full text-sm transition-all duration-300 hover:scale-105 hover:shadow-md"
                            }, toDisplayString$1(antonym), 1);
                          }), 128))
                        ])
                      ])) : createCommentVNode("", true),
                      _ctx.vocabulary.notes ? (openBlock(), createElementBlock("div", _hoisted_41$f, [
                        createBaseVNode("h3", _hoisted_42$d, [
                          _cache[12] || (_cache[12] = createBaseVNode("span", { class: "w-1 h-4 bg-yellow-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.note", "Notes")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_43$c, [
                          createBaseVNode("p", _hoisted_44$c, toDisplayString$1(_ctx.vocabulary.notes), 1)
                        ])
                      ])) : createCommentVNode("", true),
                      createBaseVNode("div", _hoisted_45$b, [
                        createBaseVNode("div", _hoisted_46$b, [
                          _ctx.vocabulary.createdAt ? (openBlock(), createElementBlock("div", _hoisted_47$b, [
                            _cache[13] || (_cache[13] = createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", {
                                "fill-rule": "evenodd",
                                d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z",
                                "clip-rule": "evenodd"
                              })
                            ], -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.createdAt", "Created")) + ": " + toDisplayString$1(unref(getRelativeTime)(_ctx.vocabulary.createdAt, unref(t))), 1)
                          ])) : createCommentVNode("", true),
                          _ctx.vocabulary.updatedAt && _ctx.vocabulary.updatedAt !== _ctx.vocabulary.createdAt ? (openBlock(), createElementBlock("div", _hoisted_48$b, [
                            _cache[14] || (_cache[14] = createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", { d: "M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" })
                            ], -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.updatedAt", "Updated")) + ": " + toDisplayString$1(unref(getRelativeTime)(_ctx.vocabulary.updatedAt, unref(t))), 1)
                          ])) : createCommentVNode("", true)
                        ])
                      ])
                    ])) : createCommentVNode("", true),
                    createBaseVNode("div", _hoisted_49$a, [
                      createBaseVNode("button", {
                        onClick: editVocabulary,
                        class: "px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg transform hover:-translate-y-0.5 active:scale-95"
                      }, toDisplayString$1(unref(t)("common.edit", "Edit")), 1),
                      createBaseVNode("button", {
                        onClick: closeDialog,
                        class: "px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg transform hover:-translate-y-0.5 active:scale-95"
                      }, toDisplayString$1(unref(t)("common.close", "Close")), 1)
                    ])
                  ])
                ]),
                _: 1
              })
            ], 32)) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const VocabularyDetailDialog = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["__scopeId", "data-v-c3ed5305"]]);

const VocabularyDetailDialog$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: VocabularyDetailDialog
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$$ = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$Y = { class: "w-full max-h-[90vh] flex flex-col max-w-[95vw] sm:max-w-lg md:max-w-xl lg:max-w-2xl" };
const _hoisted_3$W = { class: "px-3 sm:px-6 py-3 sm:py-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-green-50 to-emerald-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$U = { class: "flex items-center justify-between" };
const _hoisted_5$R = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-1 sm:space-x-2 flex-1 min-w-0" };
const _hoisted_6$P = { class: "truncate" };
const _hoisted_7$N = { class: "px-3 sm:px-6 py-3 sm:py-4 flex-1 overflow-y-auto min-h-0 custom-scrollbar" };
const _hoisted_8$N = { class: "space-y-6" };
const _hoisted_9$M = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_10$L = { class: "text-sm text-gray-600 dark:text-gray-400 p-3 bg-green-50 dark:bg-[#0a0a0a] rounded-lg border border-green-200 dark:border-gray-700" };
const _hoisted_11$L = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_12$K = {
  for: "note-content",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_13$K = ["placeholder"];
const _hoisted_14$K = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_15$F = { class: "text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_16$E = { class: "ml-2 px-2 py-1 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 rounded-full text-xs font-semibold" };
const _hoisted_17$D = { class: "max-h-60 overflow-y-auto border border-gray-200 dark:border-gray-700 rounded-lg p-3 bg-white dark:bg-[#0a0a0a] custom-scrollbar" };
const _hoisted_18$B = {
  key: 0,
  class: "p-4 text-center text-gray-500 dark:text-gray-400"
};
const _hoisted_19$B = {
  key: 1,
  class: "space-y-2"
};
const _hoisted_20$A = { class: "flex-1 min-w-0" };
const _hoisted_21$A = { class: "flex items-center space-x-1 sm:space-x-2 mb-1" };
const _hoisted_22$y = { class: "font-medium text-gray-900 dark:text-white truncate" };
const _hoisted_23$y = { class: "text-xs sm:text-sm text-gray-500 dark:text-gray-400 font-mono truncate" };
const _hoisted_24$x = { class: "text-sm text-gray-600 dark:text-gray-300 truncate" };
const _hoisted_25$x = { class: "text-xs px-1 sm:px-2 py-1 bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-300 rounded-full whitespace-nowrap" };
const _hoisted_26$v = { class: "flex items-center space-x-1 sm:space-x-2 flex-shrink-0" };
const _hoisted_27$u = ["onClick", "title"];
const _hoisted_28$t = ["onClick"];
const _hoisted_29$r = {
  class: "w-4 h-4",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_30$q = {
  key: 0,
  "fill-rule": "evenodd",
  d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
  "clip-rule": "evenodd"
};
const _hoisted_31$p = {
  key: 1,
  d: "M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"
};
const _hoisted_32$m = { class: "px-6 py-4 border-t border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-gray-50 to-green-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_33$m = { class: "flex justify-end space-x-3" };
const NOTE_STORAGE_KEY = "vocabulary-notes";
const MARKED_WORDS_STORAGE_KEY = "vocabulary-marked-words";
const _sfc_main$$ = /* @__PURE__ */ defineComponent({
  __name: "VocabularyNoteDialog",
  props: {
    modelValue: { type: Boolean },
    date: {},
    todayWords: {}
  },
  emits: ["update:modelValue", "save-note"],
  setup(__props, { emit: __emit }) {
    const { t, locale } = useI18n();
    useToast();
    const { playAudio } = useVoiceStore();
    const props = __props;
    const emit = __emit;
    const noteContent = ref("");
    const markedWords = ref([]);
    const formattedDate = computed(() => {
      const today = /* @__PURE__ */ new Date();
      const todayKey = getDateKey(today.toISOString());
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayKey = getDateKey(yesterday.toISOString());
      if (props.date === todayKey) {
        return t("vocabulary.notes.today", "Today");
      } else if (props.date === yesterdayKey) {
        return t("vocabulary.notes.yesterday", "Yesterday");
      } else {
        return formatDate(props.date, locale.value);
      }
    });
    const loadNote = () => {
      try {
        const notesData = localStorage.getItem(NOTE_STORAGE_KEY);
        if (notesData) {
          const notes = JSON.parse(notesData);
          if (notes[props.date]) {
            noteContent.value = notes[props.date];
          } else {
            noteContent.value = "";
          }
        }
      } catch (error) {
        console.warn("Failed to load notes from localStorage:", error);
      }
    };
    const loadMarkedWords = () => {
      try {
        const markedData = localStorage.getItem(MARKED_WORDS_STORAGE_KEY);
        if (markedData) {
          const marked = JSON.parse(markedData);
          if (marked[props.date]) {
            markedWords.value = marked[props.date];
          } else {
            markedWords.value = [];
          }
        }
      } catch (error) {
        console.warn("Failed to load marked words from localStorage:", error);
      }
    };
    const saveNoteToStorage = (note) => {
      try {
        const notesData = localStorage.getItem(NOTE_STORAGE_KEY);
        const notes = notesData ? JSON.parse(notesData) : {};
        notes[props.date] = note;
        localStorage.setItem(NOTE_STORAGE_KEY, JSON.stringify(notes));
      } catch (error) {
        console.warn("Failed to save note to localStorage:", error);
      }
    };
    const saveMarkedWordsToStorage = (wordIds) => {
      try {
        const markedData = localStorage.getItem(MARKED_WORDS_STORAGE_KEY);
        const marked = markedData ? JSON.parse(markedData) : {};
        marked[props.date] = wordIds;
        localStorage.setItem(MARKED_WORDS_STORAGE_KEY, JSON.stringify(marked));
      } catch (error) {
        console.warn("Failed to save marked words to localStorage:", error);
      }
    };
    const toggleWordMarked = (wordId) => {
      const index = markedWords.value.indexOf(wordId);
      if (index === -1) {
        markedWords.value.push(wordId);
      } else {
        markedWords.value.splice(index, 1);
      }
    };
    const speakWord = async (word) => {
      try {
        await playAudio(word);
      } catch (error) {
        console.warn("Failed to play word pronunciation:", error);
      }
    };
    const saveNote = () => {
      saveNoteToStorage(noteContent.value);
      saveMarkedWordsToStorage(markedWords.value);
      emit("save-note", noteContent.value, markedWords.value);
      const event = new CustomEvent("vocabulary-notes-updated", {
        detail: {
          date: props.date,
          note: noteContent.value,
          markedWords: markedWords.value
        }
      });
      window.dispatchEvent(event);
      close();
    };
    const close = () => {
      emit("update:modelValue", false);
    };
    watch(
      () => props.modelValue,
      (newValue) => {
        if (newValue) {
          loadNote();
          loadMarkedWords();
        }
      }
    );
    onMounted(() => {
      if (props.modelValue) {
        loadNote();
        loadMarkedWords();
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$$, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$Y, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 flex flex-col h-full overflow-hidden transform",
                      onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$W, [
                        createBaseVNode("div", _hoisted_4$U, [
                          createBaseVNode("h2", _hoisted_5$R, [
                            _cache[2] || (_cache[2] = createBaseVNode("span", { class: "w-2 h-2 bg-green-500 rounded-full animate-pulse flex-shrink-0" }, null, -1)),
                            _cache[3] || (_cache[3] = createBaseVNode("svg", {
                              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6 text-green-500 flex-shrink-0",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
                            ], -1)),
                            createBaseVNode("span", _hoisted_6$P, toDisplayString$1(unref(t)("vocabulary.notes.title", "Vocabulary Notes")) + " - " + toDisplayString$1(formattedDate.value), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: close,
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[4] || (_cache[4] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_7$N, [
                        createBaseVNode("div", _hoisted_8$N, [
                          createBaseVNode("div", _hoisted_9$M, [
                            createBaseVNode("p", _hoisted_10$L, toDisplayString$1(unref(t)("vocabulary.notes.description", "Manage notes for vocabulary words learned today")), 1)
                          ]),
                          createBaseVNode("div", _hoisted_11$L, [
                            createBaseVNode("label", _hoisted_12$K, [
                              _cache[5] || (_cache[5] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.notes.noteLabel", "Notes for vocabulary")), 1)
                            ]),
                            withDirectives(createBaseVNode("textarea", {
                              id: "note-content",
                              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => noteContent.value = $event),
                              rows: "6",
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-300 hover:border-green-400 dark:hover:border-green-500 transform hover:scale-[1.02]",
                              placeholder: unref(t)("vocabulary.notes.placeholder", "Write your notes about this vocabulary learning session...")
                            }, null, 8, _hoisted_13$K), [
                              [vModelText, noteContent.value]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_14$K, [
                            createBaseVNode("h4", _hoisted_15$F, [
                              _cache[6] || (_cache[6] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.notes.wordsLearned", "Words in this group")) + " ", 1),
                              createBaseVNode("span", _hoisted_16$E, toDisplayString$1(_ctx.todayWords.length), 1)
                            ]),
                            createBaseVNode("div", _hoisted_17$D, [
                              _ctx.todayWords.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_18$B, [
                                _cache[7] || (_cache[7] = createBaseVNode("svg", {
                                  class: "w-12 h-12 mx-auto mb-3 text-gray-300 dark:text-gray-600",
                                  fill: "none",
                                  stroke: "currentColor",
                                  viewBox: "0 0 24 24"
                                }, [
                                  createBaseVNode("path", {
                                    "stroke-linecap": "round",
                                    "stroke-linejoin": "round",
                                    "stroke-width": "1",
                                    d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                                  })
                                ], -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.notes.noWordsLearned", "No vocabulary words in this group")), 1)
                              ])) : (openBlock(), createElementBlock("div", _hoisted_19$B, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.todayWords, (word, index) => {
                                  return openBlock(), createElementBlock("div", {
                                    key: word.id,
                                    class: "flex items-center space-x-2 sm:space-x-3 p-2 sm:p-3 rounded-lg hover:bg-white dark:hover:bg-[#0f0f0f] transition-all duration-300 border border-transparent hover:border-green-200 cursor-pointer hover:shadow-md hover:scale-[1.02] animate-fade-in-up",
                                    style: normalizeStyle(`animation-delay: ${0.4 + index * 0.1}s`)
                                  }, [
                                    createBaseVNode("div", _hoisted_20$A, [
                                      createBaseVNode("div", _hoisted_21$A, [
                                        createBaseVNode("span", _hoisted_22$y, toDisplayString$1(word.word), 1),
                                        createBaseVNode("span", _hoisted_23$y, toDisplayString$1(word.pronunciation), 1)
                                      ]),
                                      createBaseVNode("div", _hoisted_24$x, toDisplayString$1(word.meaning), 1)
                                    ]),
                                    createBaseVNode("div", _hoisted_25$x, toDisplayString$1(word.level), 1),
                                    createBaseVNode("div", _hoisted_26$v, [
                                      createBaseVNode("button", {
                                        onClick: ($event) => speakWord(word.word),
                                        class: "p-1 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-300 hover:scale-110 bg-blue-100 dark:bg-blue-900 text-blue-600 dark:text-blue-400 hover:bg-blue-200 dark:hover:bg-blue-800",
                                        title: `Play pronunciation: ${word.word}`
                                      }, _cache[8] || (_cache[8] = [
                                        createBaseVNode("svg", {
                                          class: "w-4 h-4",
                                          fill: "currentColor",
                                          viewBox: "0 0 20 20"
                                        }, [
                                          createBaseVNode("path", {
                                            "fill-rule": "evenodd",
                                            d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.776L4.146 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.146l4.237-3.776zM12.828 7.172a1 1 0 011.414 0 4 4 0 010 5.656 1 1 0 01-1.414-1.414 2 2 0 000-2.828 1 1 0 010-1.414z",
                                            "clip-rule": "evenodd"
                                          }),
                                          createBaseVNode("path", {
                                            "fill-rule": "evenodd",
                                            d: "M15.536 4.464a1 1 0 011.414 0 8 8 0 010 11.314 1 1 0 11-1.414-1.414 6 6 0 000-8.486 1 1 0 010-1.414z",
                                            "clip-rule": "evenodd"
                                          })
                                        ], -1)
                                      ]), 8, _hoisted_27$u),
                                      createBaseVNode("button", {
                                        onClick: ($event) => toggleWordMarked(word.id),
                                        class: normalizeClass(["p-1 rounded-full focus:outline-none focus:ring-2 focus:ring-green-500 transition-all duration-300 hover:scale-110", markedWords.value.includes(word.id) ? "bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-400" : "bg-gray-100 dark:bg-gray-600 text-gray-500 dark:text-gray-400"])
                                      }, [
                                        (openBlock(), createElementBlock("svg", _hoisted_29$r, [
                                          markedWords.value.includes(word.id) ? (openBlock(), createElementBlock("path", _hoisted_30$q)) : (openBlock(), createElementBlock("path", _hoisted_31$p))
                                        ]))
                                      ], 10, _hoisted_28$t)
                                    ])
                                  ], 4);
                                }), 128))
                              ]))
                            ])
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_32$m, [
                        createBaseVNode("div", _hoisted_33$m, [
                          createBaseVNode("button", {
                            onClick: close,
                            class: "px-4 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg text-sm font-medium text-gray-700 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-all duration-300 hover:scale-105 hover:shadow-md transform hover:-translate-y-0.5"
                          }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                          createBaseVNode("button", {
                            onClick: saveNote,
                            class: "px-4 py-2 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-all duration-300 hover:scale-105 hover:shadow-lg transform hover:-translate-y-0.5 flex items-center space-x-2"
                          }, [
                            _cache[9] || (_cache[9] = createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M5 13l4 4L19 7"
                              })
                            ], -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("common.save", "Save")), 1)
                          ])
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const VocabularyNoteDialog = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["__scopeId", "data-v-6c613da1"]]);

const VocabularyNoteDialog$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: VocabularyNoteDialog
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$_ = {
  key: 0,
  class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$X = { class: "w-full max-w-4xl" };
const _hoisted_3$V = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$T = { class: "flex items-center justify-between" };
const _hoisted_5$Q = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$O = { class: "flex items-center space-x-4" };
const _hoisted_7$M = { class: "flex items-center space-x-3" };
const _hoisted_8$M = { class: "text-sm font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_9$L = { class: "relative inline-flex items-center cursor-pointer" };
const _hoisted_10$K = { class: "text-sm font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_11$K = {
  key: 0,
  class: "mt-3 p-2 bg-blue-50 dark:bg-gray-custom rounded-lg"
};
const _hoisted_12$J = { class: "flex items-center justify-between" };
const _hoisted_13$J = { class: "text-sm text-blue-700 dark:text-blue-300 flex items-center" };
const _hoisted_14$J = {
  key: 0,
  class: "relative"
};
const _hoisted_15$E = { class: "bg-green-200 dark:bg-green-800 text-green-800 dark:text-green-200 px-2 py-0.5 rounded-full text-xs font-bold" };
const _hoisted_16$D = {
  key: 0,
  class: "absolute right-0 top-full mt-2 w-80 bg-white dark:bg-[#0a0a0a] border border-gray-200 dark:border-gray-700 rounded-lg shadow-xl z-50 max-h-64 overflow-y-auto"
};
const _hoisted_17$C = { class: "p-3 border-b border-gray-200 dark:border-gray-700" };
const _hoisted_18$A = { class: "text-sm font-semibold text-gray-900 dark:text-white flex items-center" };
const _hoisted_19$A = {
  key: 0,
  class: "p-4 text-center text-gray-500 dark:text-gray-400 text-sm"
};
const _hoisted_20$z = {
  key: 1,
  class: "divide-y divide-gray-200 dark:divide-gray-700"
};
const _hoisted_21$z = { class: "flex items-start justify-between" };
const _hoisted_22$x = { class: "flex-1 min-w-0" };
const _hoisted_23$x = { class: "text-sm font-medium text-gray-900 dark:text-white truncate" };
const _hoisted_24$w = { class: "text-xs text-gray-600 dark:text-gray-300 mt-1 line-clamp-2" };
const _hoisted_25$w = { class: "flex items-center space-x-2 mt-2" };
const _hoisted_26$u = { class: "inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200" };
const _hoisted_27$t = { class: "inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-purple-100 dark:bg-purple-900/30 text-purple-800 dark:text-purple-200" };
const _hoisted_28$s = { class: "px-6 py-4 max-h-[70vh] overflow-y-auto" };
const _hoisted_29$q = {
  class: "mb-6 p-4 bg-gray-50 dark:bg-dark-bg-mute rounded-lg border border-gray-200 dark:border-dark-bg-mute animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_30$p = { class: "text-md font-medium text-gray-900 dark:text-white mb-4 flex items-center" };
const _hoisted_31$o = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_32$l = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_33$l = ["placeholder"];
const _hoisted_34$j = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_35$j = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_36$i = { value: "" };
const _hoisted_37$h = { value: "tenses" };
const _hoisted_38$h = { value: "conditionals" };
const _hoisted_39$f = { value: "passive" };
const _hoisted_40$f = { value: "modals" };
const _hoisted_41$e = { value: "articles" };
const _hoisted_42$c = { value: "prepositions" };
const _hoisted_43$b = { value: "conjunctions" };
const _hoisted_44$b = { value: "other" };
const _hoisted_45$a = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_46$a = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_47$a = { value: "" };
const _hoisted_48$a = { value: "beginner" };
const _hoisted_49$9 = { value: "intermediate" };
const _hoisted_50$9 = { value: "advanced" };
const _hoisted_51$8 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_52$8 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_53$8 = { class: "space-y-2" };
const _hoisted_54$8 = ["placeholder"];
const _hoisted_55$8 = {
  key: 0,
  class: "p-2 bg-yellow-50 dark:bg-[#0a0a0a] border border-yellow-200 dark:border-yellow-600 rounded text-sm"
};
const _hoisted_56$8 = { class: "text-yellow-700 dark:text-yellow-400 font-medium mb-1" };
const _hoisted_57$8 = ["innerHTML"];
const _hoisted_58$8 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_59$7 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_60$7 = { class: "space-y-2" };
const _hoisted_61$6 = ["placeholder"];
const _hoisted_62$6 = {
  key: 0,
  class: "p-2 bg-teal-50 dark:bg-[#0a0a0a] border border-teal-200 dark:border-teal-600 rounded text-sm"
};
const _hoisted_63$4 = { class: "text-teal-700 dark:text-teal-400 font-medium mb-1" };
const _hoisted_64$4 = ["innerHTML"];
const _hoisted_65$4 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_66$4 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_67$4 = { class: "space-y-2" };
const _hoisted_68$4 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_69$4 = ["onClick"];
const _hoisted_70$4 = {
  class: "flex justify-end space-x-3 pt-4 animate-fade-in-up",
  style: { "animation-delay": "0.8s" }
};
const _hoisted_71$4 = {
  type: "submit",
  class: "px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-all duration-300 transform hover:scale-105 hover:shadow-lg"
};
const _hoisted_72$4 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.9s" }
};
const _hoisted_73$4 = { class: "flex items-center justify-between mb-4" };
const _hoisted_74$4 = { class: "text-md font-medium text-gray-900 dark:text-white flex items-center" };
const _hoisted_75$3 = { value: "" };
const _hoisted_76$3 = { value: "tenses" };
const _hoisted_77$3 = { value: "conditionals" };
const _hoisted_78$2 = { value: "passive" };
const _hoisted_79$2 = { value: "modals" };
const _hoisted_80$2 = { value: "articles" };
const _hoisted_81$2 = { value: "prepositions" };
const _hoisted_82$2 = { value: "conjunctions" };
const _hoisted_83$2 = { value: "other" };
const _hoisted_84$2 = {
  key: 0,
  class: "space-y-4 max-h-96 overflow-y-auto scrollbar-custom"
};
const _hoisted_85$2 = { class: "flex items-start justify-between" };
const _hoisted_86$1 = { class: "flex-1" };
const _hoisted_87$1 = { class: "flex items-center space-x-2 mb-2" };
const _hoisted_88$1 = { class: "font-medium text-gray-900 dark:text-white" };
const _hoisted_89$1 = { class: "px-2 py-1 text-xs bg-blue-100 dark:bg-blue-900/50 text-blue-800 dark:text-blue-300 rounded-full" };
const _hoisted_90$1 = { class: "px-2 py-1 text-xs bg-green-100 dark:bg-green-900/50 text-green-800 dark:text-green-300 rounded-full" };
const _hoisted_91$1 = { class: "mb-2" };
const _hoisted_92$1 = { class: "text-sm font-medium text-gray-700 dark:text-gray-300 mb-1" };
const _hoisted_93$1 = ["innerHTML"];
const _hoisted_94$1 = {
  key: 0,
  class: "mb-2"
};
const _hoisted_95$1 = ["innerHTML"];
const _hoisted_96$1 = {
  key: 1,
  class: "mb-2"
};
const _hoisted_97$1 = { class: "text-sm font-medium text-gray-700 dark:text-gray-300 mb-1" };
const _hoisted_98$1 = { class: "text-sm text-gray-600 dark:text-gray-400 space-y-2" };
const _hoisted_99$1 = { class: "flex items-start flex-1" };
const _hoisted_100 = { class: "flex-1" };
const _hoisted_101 = ["onClick", "disabled", "title"];
const _hoisted_102 = {
  key: 0,
  class: "w-4 h-4",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_103 = {
  key: 1,
  class: "w-4 h-4",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_104 = { class: "text-xs text-gray-500 dark:text-gray-400" };
const _hoisted_105 = { class: "flex items-center space-x-2 ml-4" };
const _hoisted_106 = ["onClick", "title"];
const _hoisted_107 = ["onClick", "title"];
const _hoisted_108 = {
  key: 1,
  class: "text-center py-8 animate-fade-in-up",
  style: { "animation-delay": "1.0s" }
};
const _hoisted_109 = { class: "text-gray-500 dark:text-gray-400" };
const _hoisted_110 = { class: "px-6 py-4 border-t border-gray-200 dark:border-gray-700 bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_111 = { class: "flex justify-end" };
const _sfc_main$_ = /* @__PURE__ */ defineComponent({
  __name: "GrammarManagerModal",
  props: {
    modelValue: { type: Boolean },
    selectedDate: { default: null }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const ConfirmToast$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ConfirmToast),true              ?void 0:void 0));
    const { t } = useI18n();
    const toast = useToast();
    const { allVocabularies } = useVocabularyStore();
    const isPlayingAudio = ref(null);
    const props = __props;
    const emit = __emit;
    const grammarRules = ref([]);
    const isEditing = ref(false);
    const editingId = ref(null);
    const filterCategory = ref("");
    const perDateMode = ref(false);
    const showVocabularyDropdown = ref(false);
    const formData = ref({
      title: "",
      category: "",
      level: "",
      formula: "",
      description: "",
      examples: [""]
    });
    const filteredGrammarRules = computed(() => {
      let filtered = grammarRules.value;
      if (perDateMode.value) {
        filtered = filtered.filter((rule) => rule.dateGroup === props.selectedDate);
      } else {
        filtered = filtered.filter((rule) => !rule.dateGroup);
      }
      if (filterCategory.value) {
        filtered = filtered.filter((rule) => rule.category === filterCategory.value);
      }
      return filtered;
    });
    const vocabulariesForSelectedDate = computed(() => {
      if (!props.selectedDate) return [];
      return allVocabularies.value.filter((vocab) => {
        const vocabDateKey = getDateKey(vocab.createdAt);
        return vocabDateKey === props.selectedDate;
      });
    });
    const renderHtmlContent = (content) => {
      if (!content) return "";
      return content.replace(/<\/br>/gi, "<br>").replace(/<br\s*\/?>/gi, "<br>").replace(/\n/g, "<br>");
    };
    const formulaPreview = computed(() => renderHtmlContent(formData.value.formula));
    const descriptionPreview = computed(() => renderHtmlContent(formData.value.description));
    const playExampleAudio = async (example) => {
      if (isPlayingAudio.value === example) return;
      try {
        isPlayingAudio.value = example;
        if ("speechSynthesis" in window) {
          return new Promise((resolve, reject) => {
            const utterance = new SpeechSynthesisUtterance(example);
            const savedSettings = localStorage.getItem("voice-settings");
            let voiceSettings = {
              rate: 0.8,
              pitch: 1,
              volume: 1
            };
            if (savedSettings) {
              try {
                const settings = JSON.parse(savedSettings);
                const currentVoiceType2 = localStorage.getItem("current-voice-type") || "female-sweet";
                if (settings[currentVoiceType2]) {
                  voiceSettings = settings[currentVoiceType2];
                }
              } catch (e) {
                console.warn("Failed to parse voice settings");
              }
            }
            utterance.lang = "en-US";
            utterance.rate = Math.max(0.1, Math.min(10, voiceSettings.rate));
            utterance.pitch = Math.max(0, Math.min(2, voiceSettings.pitch));
            utterance.volume = Math.max(0, Math.min(1, voiceSettings.volume));
            const voices = speechSynthesis.getVoices();
            const currentVoiceType = localStorage.getItem("current-voice-type") || "female-sweet";
            let targetVoice = null;
            if (currentVoiceType.includes("female")) {
              targetVoice = voices.find(
                (voice) => voice.lang.includes("en") && voice.name.toLowerCase().includes("female")
              ) || voices.find(
                (voice) => voice.lang.includes("en") && !voice.name.toLowerCase().includes("male")
              );
            } else {
              targetVoice = voices.find(
                (voice) => voice.lang.includes("en") && voice.name.toLowerCase().includes("male")
              );
            }
            if (!targetVoice) {
              targetVoice = voices.find((voice) => voice.lang.includes("en"));
            }
            if (targetVoice) {
              utterance.voice = targetVoice;
            }
            utterance.onend = () => resolve(void 0);
            utterance.onerror = (event) => reject(event.error);
            speechSynthesis.speak(utterance);
          });
        } else {
          console.warn("Speech synthesis not supported");
        }
      } catch (error) {
        console.error("Error playing audio:", error);
      } finally {
        isPlayingAudio.value = null;
      }
    };
    const closeModal = () => {
      resetForm();
      emit("update:modelValue", false);
    };
    const resetForm = () => {
      formData.value = {
        title: "",
        category: "",
        level: "",
        formula: "",
        description: "",
        examples: [""]
      };
      isEditing.value = false;
      editingId.value = null;
    };
    const addExample = () => {
      formData.value.examples.push("");
    };
    const removeExample = (index) => {
      if (formData.value.examples.length > 1) {
        formData.value.examples.splice(index, 1);
      }
    };
    const submitForm = () => {
      const now = /* @__PURE__ */ new Date();
      let ruleId = "";
      if (isEditing.value) {
        const index = grammarRules.value.findIndex((rule) => rule.id === editingId.value);
        if (index !== -1) {
          grammarRules.value[index] = {
            ...grammarRules.value[index],
            title: formData.value.title,
            category: formData.value.category,
            level: formData.value.level,
            formula: formData.value.formula,
            description: formData.value.description,
            examples: formData.value.examples.filter((ex) => ex.trim()),
            updatedAt: now
          };
          ruleId = editingId.value || "";
        }
      } else {
        const newRule = {
          id: Date.now().toString(),
          title: formData.value.title,
          category: formData.value.category,
          level: formData.value.level,
          formula: formData.value.formula,
          description: formData.value.description,
          examples: formData.value.examples.filter((ex) => ex.trim()),
          createdAt: now,
          updatedAt: now,
          dateGroup: perDateMode.value ? props.selectedDate || void 0 : void 0
        };
        grammarRules.value.push(newRule);
        ruleId = newRule.id;
      }
      saveToLocalStorage();
      const event = new CustomEvent("grammar-rules-updated", {
        detail: {
          action: isEditing.value ? "updated" : "added",
          ruleId,
          dateGroup: perDateMode.value ? props.selectedDate || void 0 : void 0
        }
      });
      window.dispatchEvent(event);
      resetForm();
    };
    const editGrammar = (rule) => {
      formData.value = {
        title: rule.title,
        category: rule.category,
        level: rule.level,
        formula: rule.formula,
        description: rule.description || "",
        examples: rule.examples.length > 0 ? [...rule.examples] : [""]
      };
      isEditing.value = true;
      editingId.value = rule.id;
    };
    const deleteGrammar = (id) => {
      const rule = grammarRules.value.find((r) => r.id === id);
      if (!rule) return;
      const toastId = toast({
        component: ConfirmToast$1,
        props: {
          message: t("grammar.manager.confirmDelete", "Are you sure you want to delete this grammar rule?"),
          confirmText: t("common.delete", "Delete"),
          cancelText: t("common.cancel", "Cancel"),
          onConfirm: () => {
            grammarRules.value = grammarRules.value.filter((rule2) => rule2.id !== id);
            saveToLocalStorage();
            const event = new CustomEvent("grammar-rules-updated", {
              detail: {
                action: "deleted",
                ruleId: id,
                dateGroup: rule.dateGroup
              }
            });
            window.dispatchEvent(event);
            toast.success(t("grammar.manager.ruleDeleted", "Grammar rule deleted successfully"));
            toast.dismiss(toastId);
          },
          onCancel: () => {
            toast.dismiss(toastId);
          }
        }
      }, {
        timeout: false,
        closeOnClick: false,
        closeButton: false,
        draggable: false
      });
    };
    const formatDate = (date) => {
      return new Date(date).toLocaleDateString();
    };
    const saveToLocalStorage = () => {
      localStorage.setItem("grammar-rules", JSON.stringify(grammarRules.value));
    };
    const saveToggleState = () => {
      localStorage.setItem("grammar-manager-per-date-mode", JSON.stringify(perDateMode.value));
    };
    const loadToggleState = () => {
      const stored = localStorage.getItem("grammar-manager-per-date-mode");
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          perDateMode.value = typeof parsed === "boolean" ? parsed : false;
        } catch (error) {
          console.error("Error loading toggle state:", error);
          perDateMode.value = false;
        }
      }
    };
    const loadFromLocalStorage = () => {
      const stored = localStorage.getItem("grammar-rules");
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          grammarRules.value = parsed.map((rule) => ({
            ...rule,
            createdAt: new Date(rule.createdAt),
            updatedAt: new Date(rule.updatedAt)
          }));
        } catch (error) {
          console.error("Error loading grammar rules:", error);
        }
      }
    };
    const handleVocabularyImport = () => {
      console.log("Vocabulary import detected, refreshing grammar rules");
      loadFromLocalStorage();
    };
    onMounted(() => {
      loadFromLocalStorage();
      loadToggleState();
      window.addEventListener("vocabularyImportComplete", handleVocabularyImport);
    });
    onUnmounted(() => {
      window.removeEventListener("vocabularyImportComplete", handleVocabularyImport);
      unlockBodyScroll();
    });
    const lockBodyScroll = () => {
      document.body.style.overflow = "hidden";
    };
    const unlockBodyScroll = () => {
      document.body.style.overflow = "";
    };
    watch(() => props.modelValue, (newValue) => {
      if (newValue) {
        loadFromLocalStorage();
        lockBodyScroll();
      } else {
        resetForm();
        unlockBodyScroll();
      }
    });
    watch(perDateMode, (newValue) => {
      resetForm();
      filterCategory.value = "";
      saveToggleState();
      if (newValue && !props.selectedDate) {
        console.warn("Per-date mode enabled but no date selected");
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            props.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$_, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$X, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 transform overflow-hidden",
                      onClick: _cache[8] || (_cache[8] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$V, [
                        createBaseVNode("div", _hoisted_4$T, [
                          createBaseVNode("h3", _hoisted_5$Q, [
                            _cache[9] || (_cache[9] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("grammar.manager.title", "Grammar Manager")), 1)
                          ]),
                          createBaseVNode("div", _hoisted_6$O, [
                            createBaseVNode("div", _hoisted_7$M, [
                              createBaseVNode("span", _hoisted_8$M, toDisplayString$1(unref(t)("grammar.manager.globalMode", "Global")), 1),
                              createBaseVNode("label", _hoisted_9$L, [
                                withDirectives(createBaseVNode("input", {
                                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => perDateMode.value = $event),
                                  type: "checkbox",
                                  class: "sr-only peer"
                                }, null, 512), [
                                  [vModelCheckbox, perDateMode.value]
                                ]),
                                _cache[10] || (_cache[10] = createBaseVNode("div", { class: "w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600" }, null, -1))
                              ]),
                              createBaseVNode("span", _hoisted_10$K, toDisplayString$1(unref(t)("grammar.manager.perDateMode", "Per Date")), 1)
                            ]),
                            createBaseVNode("button", {
                              onClick: closeModal,
                              class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                            }, _cache[11] || (_cache[11] = [
                              createBaseVNode("svg", {
                                class: "w-6 h-6",
                                fill: "none",
                                stroke: "currentColor",
                                viewBox: "0 0 24 24"
                              }, [
                                createBaseVNode("path", {
                                  "stroke-linecap": "round",
                                  "stroke-linejoin": "round",
                                  "stroke-width": "2",
                                  d: "M6 18L18 6M6 6l12 12"
                                })
                              ], -1)
                            ]))
                          ])
                        ]),
                        perDateMode.value ? (openBlock(), createElementBlock("div", _hoisted_11$K, [
                          createBaseVNode("div", _hoisted_12$J, [
                            createBaseVNode("p", _hoisted_13$J, [
                              _cache[12] || (_cache[12] = createBaseVNode("svg", {
                                class: "w-4 h-4 mr-2",
                                fill: "none",
                                stroke: "currentColor",
                                viewBox: "0 0 24 24"
                              }, [
                                createBaseVNode("path", {
                                  "stroke-linecap": "round",
                                  "stroke-linejoin": "round",
                                  "stroke-width": "2",
                                  d: "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                                })
                              ], -1)),
                              createTextVNode(" " + toDisplayString$1(_ctx.selectedDate ? unref(t)("grammar.manager.perDateDescription", { date: _ctx.selectedDate }) || `Managing grammar rules for date: ${_ctx.selectedDate}` : unref(t)("grammar.manager.noDateSelected") || "No date selected for per-date mode"), 1)
                            ]),
                            _ctx.selectedDate ? (openBlock(), createElementBlock("div", _hoisted_14$J, [
                              createBaseVNode("button", {
                                onClick: _cache[1] || (_cache[1] = ($event) => showVocabularyDropdown.value = !showVocabularyDropdown.value),
                                class: "flex items-center space-x-2 px-3 py-1.5 bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-200 rounded-md hover:bg-green-200 dark:hover:bg-green-900/50 transition-all duration-200 text-sm font-medium"
                              }, [
                                _cache[14] || (_cache[14] = createBaseVNode("svg", {
                                  class: "w-4 h-4",
                                  fill: "none",
                                  stroke: "currentColor",
                                  viewBox: "0 0 24 24"
                                }, [
                                  createBaseVNode("path", {
                                    "stroke-linecap": "round",
                                    "stroke-linejoin": "round",
                                    "stroke-width": "2",
                                    d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                                  })
                                ], -1)),
                                createBaseVNode("span", null, toDisplayString$1(unref(t)("grammar.manager.showVocabulary", "Show Vocabulary")), 1),
                                createBaseVNode("span", _hoisted_15$E, toDisplayString$1(vocabulariesForSelectedDate.value.length), 1),
                                (openBlock(), createElementBlock("svg", {
                                  class: normalizeClass(["w-4 h-4 transition-transform duration-200", { "rotate-180": showVocabularyDropdown.value }]),
                                  fill: "none",
                                  stroke: "currentColor",
                                  viewBox: "0 0 24 24"
                                }, _cache[13] || (_cache[13] = [
                                  createBaseVNode("path", {
                                    "stroke-linecap": "round",
                                    "stroke-linejoin": "round",
                                    "stroke-width": "2",
                                    d: "M19 9l-7 7-7-7"
                                  }, null, -1)
                                ]), 2))
                              ]),
                              createVNode(Transition, {
                                "enter-active-class": "transition-all duration-300 ease-out",
                                "enter-from-class": "opacity-0 scale-95 translate-y-2",
                                "enter-to-class": "opacity-100 scale-100 translate-y-0",
                                "leave-active-class": "transition-all duration-200 ease-in",
                                "leave-from-class": "opacity-100 scale-100 translate-y-0",
                                "leave-to-class": "opacity-0 scale-95 translate-y-2"
                              }, {
                                default: withCtx(() => [
                                  showVocabularyDropdown.value ? (openBlock(), createElementBlock("div", _hoisted_16$D, [
                                    createBaseVNode("div", _hoisted_17$C, [
                                      createBaseVNode("h4", _hoisted_18$A, [
                                        _cache[15] || (_cache[15] = createBaseVNode("svg", {
                                          class: "w-4 h-4 mr-2 text-green-500",
                                          fill: "none",
                                          stroke: "currentColor",
                                          viewBox: "0 0 24 24"
                                        }, [
                                          createBaseVNode("path", {
                                            "stroke-linecap": "round",
                                            "stroke-linejoin": "round",
                                            "stroke-width": "2",
                                            d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                                          })
                                        ], -1)),
                                        createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.vocabularyForDate", { date: _ctx.selectedDate }) || `Vocabulary for ${_ctx.selectedDate}`), 1)
                                      ])
                                    ]),
                                    vocabulariesForSelectedDate.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_19$A, toDisplayString$1(unref(t)("grammar.manager.noVocabularyFound", "No vocabulary found for this date")), 1)) : (openBlock(), createElementBlock("div", _hoisted_20$z, [
                                      (openBlock(true), createElementBlock(Fragment, null, renderList(vocabulariesForSelectedDate.value, (vocab) => {
                                        return openBlock(), createElementBlock("div", {
                                          key: vocab.id,
                                          class: "p-3 hover:bg-gray-50 dark:hover:bg-gray-custom cursor-pointer transition-colors duration-150"
                                        }, [
                                          createBaseVNode("div", _hoisted_21$z, [
                                            createBaseVNode("div", _hoisted_22$x, [
                                              createBaseVNode("h5", _hoisted_23$x, toDisplayString$1(vocab.word), 1),
                                              createBaseVNode("p", _hoisted_24$w, toDisplayString$1(vocab.meaning), 1),
                                              createBaseVNode("div", _hoisted_25$w, [
                                                createBaseVNode("span", _hoisted_26$u, toDisplayString$1(unref(getTopicName)(vocab.category)), 1),
                                                createBaseVNode("span", _hoisted_27$t, toDisplayString$1(vocab.level), 1)
                                              ])
                                            ])
                                          ])
                                        ]);
                                      }), 128))
                                    ]))
                                  ])) : createCommentVNode("", true)
                                ]),
                                _: 1
                              })
                            ])) : createCommentVNode("", true)
                          ])
                        ])) : createCommentVNode("", true)
                      ]),
                      createBaseVNode("div", _hoisted_28$s, [
                        createBaseVNode("div", _hoisted_29$q, [
                          createBaseVNode("h4", _hoisted_30$p, [
                            _cache[16] || (_cache[16] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                            createTextVNode(" " + toDisplayString$1(isEditing.value ? unref(t)("grammar.manager.editGrammar", "Edit Grammar Rule") : unref(t)("grammar.manager.addNew", "Add New Grammar Rule")), 1)
                          ]),
                          createBaseVNode("form", {
                            onSubmit: withModifiers(submitForm, ["prevent"]),
                            class: "space-y-4"
                          }, [
                            createBaseVNode("div", _hoisted_31$o, [
                              createBaseVNode("label", _hoisted_32$l, [
                                _cache[17] || (_cache[17] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.title", "Title")) + " ", 1),
                                _cache[18] || (_cache[18] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => formData.value.title = $event),
                                type: "text",
                                required: "",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-300 hover:border-green-400 dark:hover:border-green-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("grammar.manager.titlePlaceholder", "e.g., Present Perfect Tense")
                              }, null, 8, _hoisted_33$l), [
                                [vModelText, formData.value.title]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_34$j, [
                              createBaseVNode("label", _hoisted_35$j, [
                                _cache[19] || (_cache[19] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.category", "Category")) + " ", 1),
                                _cache[20] || (_cache[20] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              withDirectives(createBaseVNode("select", {
                                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => formData.value.category = $event),
                                required: "",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-300 hover:border-purple-400 dark:hover:border-purple-500 transform hover:scale-[1.02] cursor-pointer"
                              }, [
                                createBaseVNode("option", _hoisted_36$i, toDisplayString$1(unref(t)("grammar.manager.selectCategory", "Select Category")), 1),
                                createBaseVNode("option", _hoisted_37$h, toDisplayString$1(unref(t)("grammar.categories.tenses", "Tenses")), 1),
                                createBaseVNode("option", _hoisted_38$h, toDisplayString$1(unref(t)("grammar.categories.conditionals", "Conditionals")), 1),
                                createBaseVNode("option", _hoisted_39$f, toDisplayString$1(unref(t)("grammar.categories.passive", "Passive Voice")), 1),
                                createBaseVNode("option", _hoisted_40$f, toDisplayString$1(unref(t)("grammar.categories.modals", "Modal Verbs")), 1),
                                createBaseVNode("option", _hoisted_41$e, toDisplayString$1(unref(t)("grammar.categories.articles", "Articles")), 1),
                                createBaseVNode("option", _hoisted_42$c, toDisplayString$1(unref(t)("grammar.categories.prepositions", "Prepositions")), 1),
                                createBaseVNode("option", _hoisted_43$b, toDisplayString$1(unref(t)("grammar.categories.conjunctions", "Conjunctions")), 1),
                                createBaseVNode("option", _hoisted_44$b, toDisplayString$1(unref(t)("grammar.categories.other", "Other")), 1)
                              ], 512), [
                                [vModelSelect, formData.value.category]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_45$a, [
                              createBaseVNode("label", _hoisted_46$a, [
                                _cache[21] || (_cache[21] = createBaseVNode("span", { class: "w-1 h-4 bg-orange-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.level", "Level")) + " ", 1),
                                _cache[22] || (_cache[22] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              withDirectives(createBaseVNode("select", {
                                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => formData.value.level = $event),
                                required: "",
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all duration-300 hover:border-orange-400 dark:hover:border-orange-500 transform hover:scale-[1.02] cursor-pointer"
                              }, [
                                createBaseVNode("option", _hoisted_47$a, toDisplayString$1(unref(t)("grammar.manager.selectLevel", "Select Level")), 1),
                                createBaseVNode("option", _hoisted_48$a, toDisplayString$1(unref(t)("grammar.levels.beginner", "Beginner")), 1),
                                createBaseVNode("option", _hoisted_49$9, toDisplayString$1(unref(t)("grammar.levels.intermediate", "Intermediate")), 1),
                                createBaseVNode("option", _hoisted_50$9, toDisplayString$1(unref(t)("grammar.levels.advanced", "Advanced")), 1)
                              ], 512), [
                                [vModelSelect, formData.value.level]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_51$8, [
                              createBaseVNode("label", _hoisted_52$8, [
                                _cache[23] || (_cache[23] = createBaseVNode("span", { class: "w-1 h-4 bg-yellow-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.formula", "Grammar Formula")) + " ", 1),
                                _cache[24] || (_cache[24] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              createBaseVNode("div", _hoisted_53$8, [
                                withDirectives(createBaseVNode("textarea", {
                                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => formData.value.formula = $event),
                                  required: "",
                                  rows: "3",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent transition-all duration-300 hover:border-yellow-400 dark:hover:border-yellow-500 transform hover:scale-[1.02] resize-none",
                                  placeholder: unref(t)("grammar.manager.formulaPlaceholder", "e.g., Subject + have/has + past participle + <br> or </br> for line break")
                                }, null, 8, _hoisted_54$8), [
                                  [vModelText, formData.value.formula]
                                ]),
                                formData.value.formula.trim() ? (openBlock(), createElementBlock("div", _hoisted_55$8, [
                                  createBaseVNode("div", _hoisted_56$8, toDisplayString$1(unref(t)("grammar.manager.preview", "Preview")) + ":", 1),
                                  createBaseVNode("div", {
                                    class: "text-gray-900 dark:text-white",
                                    innerHTML: formulaPreview.value
                                  }, null, 8, _hoisted_57$8)
                                ])) : createCommentVNode("", true)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_58$8, [
                              createBaseVNode("label", _hoisted_59$7, [
                                _cache[25] || (_cache[25] = createBaseVNode("span", { class: "w-1 h-4 bg-teal-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.description", "Description")), 1)
                              ]),
                              createBaseVNode("div", _hoisted_60$7, [
                                withDirectives(createBaseVNode("textarea", {
                                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => formData.value.description = $event),
                                  rows: "3",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all duration-300 hover:border-teal-400 dark:hover:border-teal-500 transform hover:scale-[1.02] resize-none",
                                  placeholder: unref(t)("grammar.manager.descriptionPlaceholder", "Explain when and how to use this grammar rule + <br> or </br> for line break")
                                }, null, 8, _hoisted_61$6), [
                                  [vModelText, formData.value.description]
                                ]),
                                formData.value.description.trim() ? (openBlock(), createElementBlock("div", _hoisted_62$6, [
                                  createBaseVNode("div", _hoisted_63$4, toDisplayString$1(unref(t)("grammar.manager.preview", "Preview")) + ":", 1),
                                  createBaseVNode("div", {
                                    class: "text-gray-900 dark:text-white",
                                    innerHTML: descriptionPreview.value
                                  }, null, 8, _hoisted_64$4)
                                ])) : createCommentVNode("", true)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_65$4, [
                              createBaseVNode("label", _hoisted_66$4, [
                                _cache[26] || (_cache[26] = createBaseVNode("span", { class: "w-1 h-4 bg-pink-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.examples", "Examples")), 1)
                              ]),
                              createBaseVNode("div", _hoisted_67$4, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(formData.value.examples, (example, index) => {
                                  return openBlock(), createElementBlock("div", {
                                    key: index,
                                    class: "flex items-center space-x-2"
                                  }, [
                                    withDirectives(createBaseVNode("input", {
                                      "onUpdate:modelValue": ($event) => formData.value.examples[index] = $event,
                                      type: "text",
                                      class: "flex-1 px-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-transparent transition-all duration-300 hover:border-pink-400 dark:hover:border-pink-500 transform hover:scale-[1.02]",
                                      placeholder: unref(t)("grammar.manager.examplePlaceholder", "e.g., I have finished my homework.")
                                    }, null, 8, _hoisted_68$4), [
                                      [vModelText, formData.value.examples[index]]
                                    ]),
                                    createBaseVNode("button", {
                                      type: "button",
                                      onClick: ($event) => removeExample(index),
                                      class: "text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-50 dark:hover:bg-red-900/20 transition-all duration-300 hover:scale-110"
                                    }, _cache[27] || (_cache[27] = [
                                      createBaseVNode("svg", {
                                        class: "w-4 h-4",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M6 18L18 6M6 6l12 12"
                                        })
                                      ], -1)
                                    ]), 8, _hoisted_69$4)
                                  ]);
                                }), 128)),
                                createBaseVNode("button", {
                                  type: "button",
                                  onClick: addExample,
                                  class: "text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 text-sm font-medium transition-all duration-300 hover:scale-105"
                                }, " + " + toDisplayString$1(unref(t)("grammar.manager.addExample", "Add Example")), 1)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_70$4, [
                              createBaseVNode("button", {
                                type: "button",
                                onClick: resetForm,
                                class: "px-4 py-2 text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 rounded-lg transition-all duration-300 transform hover:scale-105 hover:shadow-md"
                              }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                              createBaseVNode("button", _hoisted_71$4, toDisplayString$1(isEditing.value ? unref(t)("common.update", "Update") : unref(t)("common.add", "Add")), 1)
                            ])
                          ], 32)
                        ]),
                        createBaseVNode("div", _hoisted_72$4, [
                          createBaseVNode("div", _hoisted_73$4, [
                            createBaseVNode("h4", _hoisted_74$4, [
                              _cache[28] || (_cache[28] = createBaseVNode("span", { class: "w-1 h-4 bg-indigo-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("grammar.manager.existingRules", "Grammar Rules")), 1)
                            ]),
                            withDirectives(createBaseVNode("select", {
                              "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => filterCategory.value = $event),
                              class: "px-3 py-1 border border-gray-300 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition-all duration-300 hover:border-indigo-400 dark:hover:border-indigo-500 cursor-pointer"
                            }, [
                              createBaseVNode("option", _hoisted_75$3, toDisplayString$1(unref(t)("common.all", "All Categories")), 1),
                              createBaseVNode("option", _hoisted_76$3, toDisplayString$1(unref(t)("grammar.categories.tenses", "Tenses")), 1),
                              createBaseVNode("option", _hoisted_77$3, toDisplayString$1(unref(t)("grammar.categories.conditionals", "Conditionals")), 1),
                              createBaseVNode("option", _hoisted_78$2, toDisplayString$1(unref(t)("grammar.categories.passive", "Passive Voice")), 1),
                              createBaseVNode("option", _hoisted_79$2, toDisplayString$1(unref(t)("grammar.categories.modals", "Modal Verbs")), 1),
                              createBaseVNode("option", _hoisted_80$2, toDisplayString$1(unref(t)("grammar.categories.articles", "Articles")), 1),
                              createBaseVNode("option", _hoisted_81$2, toDisplayString$1(unref(t)("grammar.categories.prepositions", "Prepositions")), 1),
                              createBaseVNode("option", _hoisted_82$2, toDisplayString$1(unref(t)("grammar.categories.conjunctions", "Conjunctions")), 1),
                              createBaseVNode("option", _hoisted_83$2, toDisplayString$1(unref(t)("grammar.categories.other", "Other")), 1)
                            ], 512), [
                              [vModelSelect, filterCategory.value]
                            ])
                          ]),
                          filteredGrammarRules.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_84$2, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredGrammarRules.value, (rule, index) => {
                              return openBlock(), createElementBlock("div", {
                                key: rule.id,
                                class: "p-4 border border-gray-200 dark:border-dark-bg-mute rounded-lg bg-white dark:bg-dark-bg-mute animate-fade-in-up transition-all duration-300 hover:shadow-lg hover:scale-[1.02]",
                                style: normalizeStyle(`animation-delay: ${1 + index * 0.1}s`)
                              }, [
                                createBaseVNode("div", _hoisted_85$2, [
                                  createBaseVNode("div", _hoisted_86$1, [
                                    createBaseVNode("div", _hoisted_87$1, [
                                      createBaseVNode("h5", _hoisted_88$1, toDisplayString$1(rule.title), 1),
                                      createBaseVNode("span", _hoisted_89$1, toDisplayString$1(unref(t)(`grammar.categories.${rule.category}`, rule.category)), 1),
                                      createBaseVNode("span", _hoisted_90$1, toDisplayString$1(unref(t)(`grammar.levels.${rule.level}`, rule.level)), 1)
                                    ]),
                                    createBaseVNode("div", _hoisted_91$1, [
                                      createBaseVNode("p", _hoisted_92$1, toDisplayString$1(unref(t)("grammar.manager.formula", "Formula")) + ": ", 1),
                                      createBaseVNode("div", {
                                        class: "text-sm text-gray-600 dark:text-gray-400 font-mono bg-gray-50 dark:bg-[#0a0a0a] p-2 rounded",
                                        innerHTML: renderHtmlContent(rule.formula)
                                      }, null, 8, _hoisted_93$1)
                                    ]),
                                    rule.description ? (openBlock(), createElementBlock("div", _hoisted_94$1, [
                                      createBaseVNode("div", {
                                        class: "text-sm text-gray-600 dark:text-gray-400",
                                        innerHTML: renderHtmlContent(rule.description)
                                      }, null, 8, _hoisted_95$1)
                                    ])) : createCommentVNode("", true),
                                    rule.examples && rule.examples.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_96$1, [
                                      createBaseVNode("p", _hoisted_97$1, toDisplayString$1(unref(t)("grammar.manager.examples", "Examples")) + ": ", 1),
                                      createBaseVNode("ul", _hoisted_98$1, [
                                        (openBlock(true), createElementBlock(Fragment, null, renderList(rule.examples, (example) => {
                                          return openBlock(), createElementBlock("li", {
                                            key: example,
                                            class: "flex items-start justify-between"
                                          }, [
                                            createBaseVNode("div", _hoisted_99$1, [
                                              _cache[29] || (_cache[29] = createBaseVNode("span", { class: "text-gray-400 mr-2 mt-0.5" }, "", -1)),
                                              createBaseVNode("span", _hoisted_100, toDisplayString$1(example), 1)
                                            ]),
                                            createBaseVNode("button", {
                                              onClick: ($event) => playExampleAudio(example),
                                              disabled: isPlayingAudio.value === example,
                                              class: normalizeClass(["ml-2 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-[#0a0a0a] transition-colors duration-200 flex-shrink-0", {
                                                "text-blue-500 dark:text-blue-400": isPlayingAudio.value !== example,
                                                "text-orange-500 dark:text-orange-400 animate-pulse": isPlayingAudio.value === example
                                              }]),
                                              title: unref(t)("grammar.examples.playAudio", "Play example audio")
                                            }, [
                                              isPlayingAudio.value !== example ? (openBlock(), createElementBlock("svg", _hoisted_102, _cache[30] || (_cache[30] = [
                                                createBaseVNode("path", {
                                                  "stroke-linecap": "round",
                                                  "stroke-linejoin": "round",
                                                  "stroke-width": "2",
                                                  d: "M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M6 10l4-4v12l-4-4H3a1 1 0 01-1-1v-2a1 1 0 011-1h3z"
                                                }, null, -1)
                                              ]))) : (openBlock(), createElementBlock("svg", _hoisted_103, _cache[31] || (_cache[31] = [
                                                createBaseVNode("path", {
                                                  "stroke-linecap": "round",
                                                  "stroke-linejoin": "round",
                                                  "stroke-width": "2",
                                                  d: "M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"
                                                }, null, -1)
                                              ])))
                                            ], 10, _hoisted_101)
                                          ]);
                                        }), 128))
                                      ])
                                    ])) : createCommentVNode("", true),
                                    createBaseVNode("p", _hoisted_104, toDisplayString$1(unref(t)("grammar.manager.createdAt", "Created")) + ": " + toDisplayString$1(formatDate(rule.createdAt)), 1)
                                  ]),
                                  createBaseVNode("div", _hoisted_105, [
                                    createBaseVNode("button", {
                                      onClick: ($event) => editGrammar(rule),
                                      class: "text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 p-1 rounded-full hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-all duration-300 hover:scale-110",
                                      title: unref(t)("common.edit", "Edit")
                                    }, _cache[32] || (_cache[32] = [
                                      createBaseVNode("svg", {
                                        class: "w-4 h-4",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                                        })
                                      ], -1)
                                    ]), 8, _hoisted_106),
                                    createBaseVNode("button", {
                                      onClick: ($event) => deleteGrammar(rule.id),
                                      class: "text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300 p-1 rounded-full hover:bg-red-50 dark:hover:bg-red-900/20 transition-all duration-300 hover:scale-110",
                                      title: unref(t)("common.delete", "Delete")
                                    }, _cache[33] || (_cache[33] = [
                                      createBaseVNode("svg", {
                                        class: "w-4 h-4",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M19 7l-.867 12.142A2 2 0 0016.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                                        })
                                      ], -1)
                                    ]), 8, _hoisted_107)
                                  ])
                                ])
                              ], 4);
                            }), 128))
                          ])) : (openBlock(), createElementBlock("div", _hoisted_108, [
                            _cache[34] || (_cache[34] = createBaseVNode("svg", {
                              class: "w-12 h-12 text-gray-400 mx-auto mb-4",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                              })
                            ], -1)),
                            createBaseVNode("p", _hoisted_109, toDisplayString$1(unref(t)("grammar.manager.noRules", "No grammar rules found")), 1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_110, [
                        createBaseVNode("div", _hoisted_111, [
                          createBaseVNode("button", {
                            onClick: closeModal,
                            class: "px-4 py-2 bg-gray-100 dark:bg-dark-bg-mute hover:bg-gray-200 dark:hover:bg-dark-bg-soft text-gray-700 dark:text-gray-300 rounded-lg transition-all duration-300 transform hover:scale-105 hover:shadow-md"
                          }, toDisplayString$1(unref(t)("common.close", "Close")), 1)
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const GrammarManagerModal = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["__scopeId", "data-v-cbcef1c1"]]);

const GrammarManagerModal$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: GrammarManagerModal
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$Z = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$W = { class: "w-full max-w-md mx-4" };
const _hoisted_3$U = { class: "bg-white dark:bg-[#0a0a0a] p-4 border-b border-gray-200 dark:border-white/10" };
const _hoisted_4$S = { class: "flex items-center justify-between" };
const _hoisted_5$P = { class: "flex items-center space-x-2" };
const _hoisted_6$N = { class: "text-lg font-medium text-gray-900 dark:text-white" };
const _hoisted_7$L = { class: "p-4" };
const _hoisted_8$L = {
  key: 0,
  class: "mb-4"
};
const _hoisted_9$K = {
  key: 0,
  class: "mb-4"
};
const _hoisted_10$J = { class: "text-sm text-gray-500 dark:text-white/60 mb-1" };
const _hoisted_11$J = { class: "mb-2" };
const _hoisted_12$I = { class: "text-lg font-medium text-gray-900 dark:text-white" };
const _hoisted_13$I = { class: "text-sm text-gray-600 dark:text-white/70 bg-gray-50 dark:bg-black/20 px-3 py-2 rounded-md" };
const _hoisted_14$I = { class: "font-medium" };
const _hoisted_15$D = { key: 1 };
const _hoisted_16$C = { class: "text-sm text-gray-500 dark:text-white/60 mb-1" };
const _hoisted_17$B = { class: "mb-1" };
const _hoisted_18$z = { class: "text-lg font-medium text-gray-900 dark:text-white" };
const _hoisted_19$z = { class: "text-gray-500 dark:text-white/60 ml-2" };
const _hoisted_20$y = { class: "text-sm text-gray-500 dark:text-white/60" };
const _hoisted_21$y = { class: "mb-4" };
const _hoisted_22$w = { class: "flex items-center justify-between" };
const _hoisted_23$w = {
  for: "filterByTopic",
  class: "text-sm font-medium text-gray-700 dark:text-white"
};
const _hoisted_24$v = { class: "relative inline-flex items-center cursor-pointer" };
const _hoisted_25$v = {
  key: 0,
  class: "text-xs text-gray-500 dark:text-white/60 mt-1"
};
const _hoisted_26$t = { class: "font-medium" };
const _hoisted_27$s = { class: "mb-4" };
const _hoisted_28$r = {
  for: "targetDate",
  class: "block text-sm font-medium text-gray-700 dark:text-white mb-2"
};
const _hoisted_29$p = { value: "" };
const _hoisted_30$o = ["value"];
const _hoisted_31$n = {
  key: 0,
  class: "text-sm text-gray-500 dark:text-white/60 mt-2"
};
const _hoisted_32$k = { class: "px-4 py-4 bg-white dark:bg-[#0a0a0a] border-t border-gray-200 dark:border-white/10 flex justify-end space-x-3" };
const _hoisted_33$k = ["disabled"];
const _sfc_main$Z = /* @__PURE__ */ defineComponent({
  __name: "MoveModal",
  props: {
    showModal: { type: Boolean },
    wordToMove: {},
    availableDateGroups: {},
    sourceDate: {},
    allVocabularies: {}
  },
  emits: ["close", "confirm-move"],
  setup(__props, { emit: __emit }) {
    const { t, locale } = useI18n();
    const props = __props;
    const emit = __emit;
    const selectedTargetDate = ref("");
    const getStoredFilterState = () => {
      try {
        const stored = localStorage.getItem("vocabulary-move-filter-by-topic");
        return stored ? JSON.parse(stored) : false;
      } catch (error) {
        console.warn("Failed to parse stored filter state:", error);
        return false;
      }
    };
    const setStoredFilterState = (value) => {
      try {
        localStorage.setItem("vocabulary-move-filter-by-topic", JSON.stringify(value));
      } catch (error) {
        console.warn("Failed to store filter state:", error);
      }
    };
    const filterBySameTopic = ref(getStoredFilterState());
    watch(filterBySameTopic, (newValue) => {
      setStoredFilterState(newValue);
    });
    const filteredDateGroups = computed(() => {
      console.log("Filter state:", {
        filterBySameTopic: filterBySameTopic.value,
        hasWordToMove: !!props.wordToMove,
        hasAllVocabularies: !!props.allVocabularies,
        allVocabulariesLength: props.allVocabularies?.length
      });
      if (!filterBySameTopic.value || !props.wordToMove || !props.allVocabularies) {
        return props.availableDateGroups;
      }
      const currentCategory = props.wordToMove.categoryName || props.wordToMove.category;
      console.log("Current category:", currentCategory);
      console.log("Word to move:", props.wordToMove);
      if (!currentCategory) {
        return props.availableDateGroups;
      }
      console.log("Sample vocabularies:", props.allVocabularies.slice(0, 3));
      const filtered = props.availableDateGroups.filter((dateGroup) => {
        const groupDate = new Date(dateGroup.date);
        const groupDateStr = groupDate.toISOString().split("T")[0];
        const hasMatch = props.allVocabularies.some((vocab) => {
          if (vocab.category !== currentCategory) return false;
          const vocabDateStr = vocab.createdAt ? new Date(vocab.createdAt).toISOString().split("T")[0] : null;
          const vocabUpdateDateStr = vocab.updatedAt ? new Date(vocab.updatedAt).toISOString().split("T")[0] : null;
          const matches = vocabDateStr === groupDateStr || vocabUpdateDateStr === groupDateStr;
          if (matches) {
            console.log("Found match:", {
              vocab: vocab.word,
              category: vocab.category,
              vocabDate: vocabDateStr,
              groupDate: groupDateStr
            });
          }
          return matches;
        });
        return hasMatch;
      });
      console.log("Filtered result:", filtered.length, "groups");
      return filtered;
    });
    const formatDateForDisplay = (dateStr) => {
      const date = new Date(dateStr);
      return date.toLocaleDateString(locale.value, {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    };
    const closeModal = () => {
      selectedTargetDate.value = "";
      emit("close");
    };
    const confirmMove = () => {
      if (props.wordToMove && selectedTargetDate.value) {
        emit("confirm-move", {
          word: props.wordToMove,
          targetDate: selectedTargetDate.value
        });
        closeModal();
      }
    };
    watch(() => props.showModal, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        document.body.classList.remove("modal-open");
        selectedTargetDate.value = "";
      }
    });
    onUnmounted(() => {
      document.body.classList.remove("modal-open");
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.showModal ? (openBlock(), createElementBlock("div", _hoisted_1$Z, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$W, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-white/10 overflow-hidden transform",
                      onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$U, [
                        createBaseVNode("div", _hoisted_4$S, [
                          createBaseVNode("div", _hoisted_5$P, [
                            _cache[3] || (_cache[3] = createBaseVNode("div", { class: "w-2 h-2 bg-green-500 rounded-full" }, null, -1)),
                            createBaseVNode("h3", _hoisted_6$N, toDisplayString$1(unref(t)("vocabulary.moveVocabulary", "Move Vocabulary")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: closeModal,
                            class: "text-gray-400 dark:text-white/60 hover:text-gray-600 dark:hover:text-white transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-black/20"
                          }, _cache[4] || (_cache[4] = [
                            createBaseVNode("svg", {
                              class: "w-5 h-5",
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, [
                              createBaseVNode("path", {
                                "fill-rule": "evenodd",
                                d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                                "clip-rule": "evenodd"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_7$L, [
                        _ctx.wordToMove ? (openBlock(), createElementBlock("div", _hoisted_8$L, [
                          _ctx.wordToMove.isBatchMove ? (openBlock(), createElementBlock("div", _hoisted_9$K, [
                            createBaseVNode("p", _hoisted_10$J, toDisplayString$1(unref(t)("vocabulary.movingCategory", "Moving all words in category")) + ": ", 1),
                            createBaseVNode("div", _hoisted_11$J, [
                              createBaseVNode("span", _hoisted_12$I, toDisplayString$1(unref(getTopicName)(_ctx.wordToMove.categoryName || _ctx.wordToMove.category, unref(t), unref(locale), _ctx.wordToMove)), 1)
                            ]),
                            createBaseVNode("p", _hoisted_13$I, [
                              createBaseVNode("span", _hoisted_14$I, toDisplayString$1(_ctx.wordToMove.batchWords?.length || 0), 1),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.wordsWillBeMoved", "words will be moved to the selected date")), 1)
                            ])
                          ])) : (openBlock(), createElementBlock("div", _hoisted_15$D, [
                            createBaseVNode("p", _hoisted_16$C, toDisplayString$1(unref(t)("vocabulary.movingWord", "Moving word")) + ": ", 1),
                            createBaseVNode("div", _hoisted_17$B, [
                              createBaseVNode("span", _hoisted_18$z, toDisplayString$1(_ctx.wordToMove.word), 1),
                              createBaseVNode("span", _hoisted_19$z, "- " + toDisplayString$1(_ctx.wordToMove.meaning), 1)
                            ]),
                            createBaseVNode("p", _hoisted_20$y, " Topic: " + toDisplayString$1(unref(getTopicName)(_ctx.wordToMove.category, unref(t), unref(locale), _ctx.wordToMove)), 1)
                          ]))
                        ])) : createCommentVNode("", true),
                        createBaseVNode("div", _hoisted_21$y, [
                          createBaseVNode("div", _hoisted_22$w, [
                            createBaseVNode("label", _hoisted_23$w, toDisplayString$1(unref(t)("vocabulary.filterBySameTopic", "Filter by same topic")), 1),
                            createBaseVNode("label", _hoisted_24$v, [
                              withDirectives(createBaseVNode("input", {
                                id: "filterByTopic",
                                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => filterBySameTopic.value = $event),
                                type: "checkbox",
                                class: "sr-only peer"
                              }, null, 512), [
                                [vModelCheckbox, filterBySameTopic.value]
                              ]),
                              _cache[5] || (_cache[5] = createBaseVNode("div", { class: "w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-1 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-[#0a0a0a] peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-white/20 peer-checked:bg-blue-600" }, null, -1))
                            ])
                          ]),
                          filterBySameTopic.value ? (openBlock(), createElementBlock("p", _hoisted_25$v, [
                            createTextVNode(toDisplayString$1(unref(t)("vocabulary.showingDatesWithSameTopic", "Showing only dates with same topic")) + ": ", 1),
                            createBaseVNode("span", _hoisted_26$t, toDisplayString$1(unref(getTopicName)(_ctx.wordToMove?.categoryName || _ctx.wordToMove?.category || "", unref(t), unref(locale), _ctx.wordToMove)), 1)
                          ])) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("div", _hoisted_27$s, [
                          createBaseVNode("label", _hoisted_28$r, toDisplayString$1(unref(t)("vocabulary.selectTargetDateGroup", "Select target date group")) + ": ", 1),
                          withDirectives(createBaseVNode("select", {
                            id: "targetDate",
                            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedTargetDate.value = $event),
                            class: "w-full px-3 py-2 border border-gray-300 dark:border-white/20 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white"
                          }, [
                            createBaseVNode("option", _hoisted_29$p, toDisplayString$1(unref(t)("vocabulary.selectDate", "Select a date")), 1),
                            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredDateGroups.value, (dateGroup) => {
                              return openBlock(), createElementBlock("option", {
                                key: dateGroup.date,
                                value: dateGroup.date
                              }, toDisplayString$1(formatDateForDisplay(dateGroup.date)) + " (" + toDisplayString$1(dateGroup.count) + " words) ", 9, _hoisted_30$o);
                            }), 128))
                          ], 512), [
                            [vModelSelect, selectedTargetDate.value]
                          ]),
                          filteredDateGroups.value.length === 0 ? (openBlock(), createElementBlock("p", _hoisted_31$n, toDisplayString$1(unref(t)("vocabulary.noMatchingDates", "No dates found with this topic. Try disabling the filter.")), 1)) : createCommentVNode("", true)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_32$k, [
                        createBaseVNode("button", {
                          onClick: closeModal,
                          class: "px-4 py-2 text-sm font-medium text-gray-700 dark:text-white bg-gray-100 dark:bg-black/40 rounded-md hover:bg-gray-200 dark:hover:bg-black/60 transition-all duration-200 hover:scale-105 hover:shadow-md active:scale-95"
                        }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                        createBaseVNode("button", {
                          onClick: confirmMove,
                          disabled: !selectedTargetDate.value,
                          class: "px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 hover:scale-105 hover:shadow-md hover:-translate-y-0.5 active:scale-95"
                        }, toDisplayString$1(_ctx.wordToMove?.isBatchMove ? unref(t)("vocabulary.moveAll", "Move All") : unref(t)("vocabulary.moveWord", "Move Word")), 9, _hoisted_33$k)
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const MoveModal = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["__scopeId", "data-v-98e3af71"]]);

const MoveModal$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: MoveModal
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$Y = { class: "flex flex-col sm:flex-row sm:items-center space-y-2 sm:space-y-0 sm:space-x-3 md:space-x-4 lg:space-x-4" };
const _hoisted_2$V = { class: "text-sm md:text-sm lg:text-base font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_3$T = { class: "flex items-center space-x-2" };
const _hoisted_4$R = { class: "text-sm md:text-base lg:text-lg" };
const _hoisted_5$O = { class: "truncate" };
const _hoisted_6$M = { class: "overflow-y-auto max-h-60" };
const _hoisted_7$K = ["onClick"];
const _hoisted_8$K = { class: "flex items-center space-x-2 min-w-0 flex-1" };
const _hoisted_9$J = { class: "text-sm md:text-base lg:text-lg flex-shrink-0" };
const _hoisted_10$I = { class: "truncate flex-1" };
const _hoisted_11$I = { class: "flex items-center space-x-1 flex-shrink-0" };
const _hoisted_12$H = {
  key: 0,
  class: "inline-block w-4 h-4 md:w-4 md:h-4 lg:w-5 lg:h-5 text-blue-600 dark:text-blue-400 flex-shrink-0",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_13$H = ["onClick"];
const _hoisted_14$H = {
  key: 0,
  class: "absolute z-[9999] bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 dark:bg-gray-700 text-white text-xs rounded-lg shadow-lg whitespace-nowrap"
};
const _hoisted_15$C = ["disabled"];
const _hoisted_16$B = {
  key: 0,
  class: "w-4 h-4 md:w-4 md:h-4 lg:w-5 lg:h-5",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_17$A = {
  key: 1,
  class: "w-4 h-4 md:w-4 md:h-4 lg:w-5 lg:h-5 animate-spin",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _sfc_main$Y = /* @__PURE__ */ defineComponent({
  __name: "VoiceSelector",
  props: {
    showVoiceInfo: { type: Boolean, default: true }
  },
  setup(__props) {
    const VoiceSettingsModal = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => VoiceSettingsModal$1),true              ?void 0:void 0));
    const { t } = useI18n();
    const {
      voiceSettings,
      currentVoiceType,
      setVoiceType,
      updateVoiceSettings,
      resetVoiceSettings,
      playAudio,
      getVoiceTypeOptions,
      getCurrentVoiceInfo,
      loadVoices
    } = useVoiceStore();
    const isTesting = ref(false);
    const showTooltip = ref(false);
    const showDropdown = ref(false);
    const dropdownButton = ref(null);
    const dropdownMenu = ref(null);
    const dropdownContainer = ref(null);
    const showSettingsModal = ref(false);
    const selectedVoiceForSettings = ref(null);
    const voiceOptions = computed(() => getVoiceTypeOptions());
    const currentVoiceInfo = computed(() => getCurrentVoiceInfo());
    const currentVoiceOption = computed(() => {
      return voiceOptions.value.find((option) => option.value === currentVoiceType.value);
    });
    const dropdownStyle = computed(() => {
      if (!showDropdown.value || !dropdownButton.value) {
        return { display: "none" };
      }
      const buttonRect = dropdownButton.value.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const dropdownWidth = buttonRect.width;
      let leftPosition = buttonRect.left;
      if (leftPosition + dropdownWidth > viewportWidth) {
        leftPosition = viewportWidth - dropdownWidth - 8;
      }
      if (leftPosition < 8) {
        leftPosition = 8;
      }
      return {
        position: "fixed",
        top: `${buttonRect.bottom + 4}px`,
        left: `${leftPosition}px`,
        width: `${buttonRect.width}px`,
        maxWidth: `${viewportWidth - 16}px`,
        // Ensure it never exceeds viewport width
        zIndex: "9999"
      };
    });
    const handleVoiceChange = (voiceType) => {
      setVoiceType(voiceType);
    };
    const selectVoiceOption = (option) => {
      handleVoiceChange(option.value);
      showDropdown.value = false;
    };
    const testVoice = async () => {
      if (isTesting.value) return;
      isTesting.value = true;
      try {
        let testText = t("voice.testText", "Hello, this is a test of the selected voice.");
        if (currentVoiceType.value === "korean-female" || currentVoiceType.value === "korean-male") {
          testText = t("voice.testTextKorean", "!   .");
        }
        console.log("Testing voice:", currentVoiceType.value, "with text:", testText);
        await playAudio(testText);
      } catch (error) {
        console.error("Error testing voice:", error);
      } finally {
        isTesting.value = false;
      }
    };
    const openVoiceSettings = (option) => {
      selectedVoiceForSettings.value = option;
      showSettingsModal.value = true;
      showDropdown.value = false;
    };
    const handleSaveVoiceSettings = (payload) => {
      updateVoiceSettings(payload.voiceType, payload.settings);
      showSettingsModal.value = false;
    };
    const handleResetVoiceSettings = (voiceType) => {
      resetVoiceSettings(voiceType);
      const option = voiceOptions.value.find((o) => o.value === voiceType);
      if (option) {
        selectedVoiceForSettings.value = option;
      }
    };
    const handleClickOutside = (event) => {
      if (showDropdown.value) {
        const target = event.target;
        if (dropdownButton.value && !dropdownButton.value.contains(target) && dropdownMenu.value && !dropdownMenu.value.contains(target)) {
          showDropdown.value = false;
        }
      }
    };
    const updateDropdownPosition = () => {
      if (showDropdown.value && dropdownButton.value) {
        const buttonRect = dropdownButton.value.getBoundingClientRect();
        const dropdown = dropdownMenu.value;
        if (dropdown) {
          dropdown.style.top = `${buttonRect.bottom + 4}px`;
          dropdown.style.left = `${buttonRect.left}px`;
          dropdown.style.minWidth = `${buttonRect.width}px`;
        }
      }
    };
    let scrollTimeout = null;
    const handleScroll = () => {
      if (showDropdown.value) {
        if (scrollTimeout) {
          cancelAnimationFrame(scrollTimeout);
        }
        scrollTimeout = requestAnimationFrame(updateDropdownPosition);
      }
    };
    const handleResize = () => {
      if (showDropdown.value) {
        showDropdown.value = false;
      }
    };
    onMounted(() => {
      loadVoices();
      document.addEventListener("click", handleClickOutside);
      window.addEventListener("scroll", handleScroll, true);
      window.addEventListener("resize", handleResize);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleClickOutside);
      window.removeEventListener("scroll", handleScroll, true);
      window.removeEventListener("resize", handleResize);
      if (scrollTimeout) {
        cancelAnimationFrame(scrollTimeout);
      }
    });
    watch(currentVoiceType, (newType) => {
      console.log("VoiceSelector: Voice type changed to:", newType);
    }, { immediate: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$Y, [
        createBaseVNode("span", _hoisted_2$V, toDisplayString$1(unref(t)("voice.selector.title", "Voice")), 1),
        createBaseVNode("div", {
          class: "relative w-full sm:w-auto",
          onClick: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"])),
          ref_key: "dropdownContainer",
          ref: dropdownContainer
        }, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => showDropdown.value = !showDropdown.value),
            ref_key: "dropdownButton",
            ref: dropdownButton,
            class: "flex w-full min-w-[240px] sm:min-w-[260px] md:min-w-[280px] lg:min-w-[300px] items-center justify-between px-3 py-2 md:px-3 md:py-2 lg:px-4 lg:py-2.5 bg-white dark:bg-[#0f0f0f] border border-gray-300 dark:border-gray-700 rounded-lg text-sm md:text-sm lg:text-base font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-[#0a0a0a] transition-colors"
          }, [
            createBaseVNode("div", _hoisted_3$T, [
              createBaseVNode("span", _hoisted_4$R, toDisplayString$1(currentVoiceOption.value?.icon), 1),
              createBaseVNode("span", _hoisted_5$O, toDisplayString$1(currentVoiceOption.value?.label), 1)
            ]),
            (openBlock(), createElementBlock("svg", {
              class: normalizeClass(["w-4 h-4 md:w-4 md:h-4 lg:w-5 lg:h-5 flex-shrink-0", { "rotate-180": showDropdown.value }]),
              fill: "none",
              stroke: "currentColor",
              viewBox: "0 0 24 24"
            }, _cache[5] || (_cache[5] = [
              createBaseVNode("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M19 9l-7 7-7-7"
              }, null, -1)
            ]), 2))
          ], 512)
        ], 512),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          showDropdown.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            ref_key: "dropdownMenu",
            ref: dropdownMenu,
            style: normalizeStyle(dropdownStyle.value),
            class: "bg-white dark:bg-[#0f0f0f] border border-gray-300 dark:border-gray-700 rounded-lg shadow-lg max-h-60 overflow-hidden z-[9998] min-w-[240px] sm:min-w-[260px] md:min-w-[280px] lg:min-w-[300px]"
          }, [
            createBaseVNode("div", _hoisted_6$M, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(voiceOptions.value, (option) => {
                return openBlock(), createElementBlock("div", {
                  key: option.value,
                  onClick: ($event) => selectVoiceOption(option),
                  class: normalizeClass([
                    "flex items-center justify-between gap-2 px-3 py-2 md:px-3 md:py-2 lg:px-4 lg:py-2.5 text-left text-sm md:text-sm lg:text-base transition-colors cursor-pointer",
                    unref(currentVoiceType) === option.value ? "bg-blue-50 dark:bg-[#2d3436] text-blue-600 dark:text-blue-400" : "text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800"
                  ])
                }, [
                  createBaseVNode("div", _hoisted_8$K, [
                    createBaseVNode("span", _hoisted_9$J, toDisplayString$1(option.icon), 1),
                    createBaseVNode("span", _hoisted_10$I, toDisplayString$1(option.label), 1)
                  ]),
                  createBaseVNode("div", _hoisted_11$I, [
                    unref(currentVoiceType) === option.value ? (openBlock(), createElementBlock("svg", _hoisted_12$H, _cache[6] || (_cache[6] = [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                        "clip-rule": "evenodd"
                      }, null, -1)
                    ]))) : createCommentVNode("", true),
                    createBaseVNode("button", {
                      onClick: withModifiers(($event) => openVoiceSettings(option), ["stop"]),
                      class: "inline-block p-1 md:p-1 lg:p-1.5 rounded-full hover:bg-gray-200 dark:hover:bg-gray-500 flex-shrink-0"
                    }, _cache[7] || (_cache[7] = [
                      createBaseVNode("svg", {
                        class: "inline-block w-3 h-3 sm:w-4 sm:h-4 md:w-4 md:h-4 lg:w-4 lg:h-4 text-gray-500 dark:text-gray-400",
                        fill: "none",
                        stroke: "currentColor",
                        viewBox: "0 0 24 24"
                      }, [
                        createBaseVNode("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"
                        }),
                        createBaseVNode("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                        })
                      ], -1)
                    ]), 8, _hoisted_13$H)
                  ])
                ], 10, _hoisted_7$K);
              }), 128))
            ])
          ], 4)) : createCommentVNode("", true)
        ])),
        _ctx.showVoiceInfo && currentVoiceInfo.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "relative",
          onMouseenter: _cache[2] || (_cache[2] = ($event) => showTooltip.value = true),
          onMouseleave: _cache[3] || (_cache[3] = ($event) => showTooltip.value = false)
        }, [
          _cache[9] || (_cache[9] = createBaseVNode("button", { class: "p-2 text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 transition-colors" }, [
            createBaseVNode("svg", {
              class: "w-4 h-4",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z",
                "clip-rule": "evenodd"
              })
            ])
          ], -1)),
          showTooltip.value ? (openBlock(), createElementBlock("div", _hoisted_14$H, [
            createBaseVNode("div", null, toDisplayString$1(unref(t)("voice.info.name")) + ": " + toDisplayString$1(currentVoiceInfo.value.name), 1),
            createBaseVNode("div", null, toDisplayString$1(unref(t)("voice.info.language")) + ": " + toDisplayString$1(currentVoiceInfo.value.lang), 1),
            createBaseVNode("div", null, toDisplayString$1(unref(t)("voice.info.gender")) + ": " + toDisplayString$1(unref(t)(`voice.gender.${currentVoiceInfo.value.gender}`)), 1),
            _cache[8] || (_cache[8] = createBaseVNode("div", { class: "absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-gray-900 dark:border-t-gray-700" }, null, -1))
          ])) : createCommentVNode("", true)
        ], 32)) : createCommentVNode("", true),
        createBaseVNode("button", {
          onClick: testVoice,
          disabled: isTesting.value,
          class: "flex items-center space-x-1 px-3 py-2 md:px-3 md:py-2 lg:px-4 lg:py-2.5 text-sm md:text-sm lg:text-base bg-blue-500 hover:bg-blue-600 disabled:bg-gray-400 text-white rounded-lg transition-colors w-full sm:w-auto"
        }, [
          !isTesting.value ? (openBlock(), createElementBlock("svg", _hoisted_16$B, _cache[10] || (_cache[10] = [
            createBaseVNode("path", {
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              "stroke-width": "2",
              d: "M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 14.142M9 9a3 3 0 000 6v-6z"
            }, null, -1)
          ]))) : (openBlock(), createElementBlock("svg", _hoisted_17$A, _cache[11] || (_cache[11] = [
            createBaseVNode("circle", {
              class: "opacity-25",
              cx: "12",
              cy: "12",
              r: "10",
              stroke: "currentColor",
              "stroke-width": "4"
            }, null, -1),
            createBaseVNode("path", {
              class: "opacity-75",
              fill: "currentColor",
              d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            }, null, -1)
          ]))),
          createBaseVNode("span", null, toDisplayString$1(isTesting.value ? unref(t)("voice.testing", "Testing...") : unref(t)("voice.test", "Test Voice")), 1)
        ], 8, _hoisted_15$C),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          showSettingsModal.value && selectedVoiceForSettings.value ? (openBlock(), createBlock(unref(VoiceSettingsModal), {
            key: 0,
            show: showSettingsModal.value,
            "voice-type": selectedVoiceForSettings.value.value,
            "voice-name": selectedVoiceForSettings.value.label,
            "initial-settings": unref(voiceSettings)[selectedVoiceForSettings.value.value],
            onClose: _cache[4] || (_cache[4] = ($event) => showSettingsModal.value = false),
            onSave: handleSaveVoiceSettings,
            onReset: handleResetVoiceSettings
          }, null, 8, ["show", "voice-type", "voice-name", "initial-settings"])) : createCommentVNode("", true)
        ]))
      ]);
    };
  }
});

const VoiceSelector = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$Y
}, Symbol.toStringTag, { value: 'Module' }));

function useTopicCRUD(emit) {
  const customTopics = ref([]);
  const editingTopic = ref(null);
  const topicToDelete = ref(null);
  const newTopic = ref({
    key: "",
    vi: "",
    en: "",
    ko: ""
  });
  const canSaveTopic = computed(() => {
    return newTopic.value.vi?.trim() && newTopic.value.en?.trim() && newTopic.value.ko?.trim();
  });
  const showDeleteModal = computed(() => {
    console.log("showDeleteModal computed - topicToDelete:", topicToDelete.value);
    return !!topicToDelete.value;
  });
  const generateTopicKey = (vi, en) => {
    const sourceName = vi.trim() || en.trim();
    if (!sourceName) return "";
    let key = sourceName.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "");
    let counter = 1;
    let originalKey = key;
    while (isKeyTaken(key)) {
      key = `${originalKey}_${counter}`;
      counter++;
    }
    return key;
  };
  const isKeyTaken = (key) => {
    const builtInKeys = [
      "technology",
      "business",
      "travel",
      "food",
      "health",
      "education",
      "sports",
      "entertainment",
      "science",
      "art",
      "music",
      "literature",
      "politics",
      "environment",
      "fashion",
      "finance"
    ];
    if (builtInKeys.includes(key)) return true;
    const existingKeys = customTopics.value.filter((topic) => editingTopic.value ? topic.key !== editingTopic.value.key : true).map((topic) => topic.key);
    return existingKeys.includes(key);
  };
  const loadCustomTopics = () => {
    try {
      const saved = localStorage.getItem("customTopics");
      console.log("Loading custom topics from localStorage:", saved);
      if (saved) {
        const parsed = JSON.parse(saved);
        console.log("Parsed custom topics:", parsed);
        if (Array.isArray(parsed)) {
          customTopics.value = parsed;
          console.log("Custom topics loaded successfully:", customTopics.value);
        } else {
          console.log("Invalid data format, resetting to empty array");
          customTopics.value = [];
          localStorage.removeItem("customTopics");
        }
      } else {
        console.log("No custom topics found in localStorage");
        customTopics.value = [];
      }
      console.log("Final custom topics loaded:", customTopics.value);
    } catch (error) {
      console.error("Error loading custom topics:", error);
      customTopics.value = [];
      localStorage.removeItem("customTopics");
    }
  };
  const saveCustomTopics = () => {
    try {
      console.log("Saving custom topics to localStorage:", customTopics.value);
      localStorage.setItem("customTopics", JSON.stringify(customTopics.value));
      console.log("Custom topics saved successfully");
    } catch (error) {
      console.error("Error saving custom topics:", error);
    }
  };
  const notifyTopicsUpdated = () => {
    window.dispatchEvent(new CustomEvent("topics-updated"));
    console.log("Topics updated, dispatching topics-updated event");
  };
  const saveTopic = () => {
    if (!canSaveTopic.value) return;
    const generatedKey = editingTopic.value ? editingTopic.value.key : generateTopicKey(newTopic.value.vi, newTopic.value.en);
    const topic = {
      key: generatedKey,
      vi: newTopic.value.vi.trim(),
      en: newTopic.value.en.trim(),
      ko: newTopic.value.ko.trim()
    };
    if (editingTopic.value) {
      const index = customTopics.value.findIndex((t) => t.key === editingTopic.value.key);
      if (index !== -1) {
        const oldKey = customTopics.value[index].key;
        customTopics.value[index] = topic;
        saveCustomTopics();
        emit("topic-updated", oldKey, topic);
        notifyTopicsUpdated();
      }
      editingTopic.value = null;
    } else {
      customTopics.value.unshift(topic);
      saveCustomTopics();
      emit("topic-added", topic);
      notifyTopicsUpdated();
    }
    newTopic.value = { key: "", vi: "", en: "", ko: "" };
  };
  const editTopic = (topic) => {
    editingTopic.value = { ...topic };
    newTopic.value = { ...topic };
  };
  const cancelEdit = () => {
    editingTopic.value = null;
    newTopic.value = { key: "", vi: "", en: "", ko: "" };
  };
  const confirmDeleteTopic = (topic) => {
    console.log("Confirming delete for topic:", topic);
    topicToDelete.value = topic;
    console.log("topicToDelete set to:", topicToDelete.value);
  };
  const deleteTopic = () => {
    if (!topicToDelete.value) {
      console.log("No topic to delete");
      return;
    }
    console.log("Attempting to delete topic:", topicToDelete.value);
    console.log("Current custom topics:", customTopics.value);
    const index = customTopics.value.findIndex((t) => t.key === topicToDelete.value.key);
    console.log("Found index:", index);
    if (index !== -1) {
      const key = customTopics.value[index].key;
      console.log("Deleting topic with key:", key);
      const updatedTopics = [...customTopics.value];
      updatedTopics.splice(index, 1);
      customTopics.value = updatedTopics;
      console.log("Topics after deletion:", customTopics.value);
      saveCustomTopics();
      emit("topic-deleted", key);
      notifyTopicsUpdated();
      console.log("Topic deleted successfully");
    } else {
      console.log("Topic not found in custom topics");
    }
    topicToDelete.value = null;
  };
  const reloadCustomTopics = () => {
    console.log("Force reloading custom topics");
    loadCustomTopics();
    customTopics.value = [...customTopics.value];
  };
  const clearAllCustomTopics = () => {
    console.log("Clearing all custom topics");
    customTopics.value = [];
    localStorage.removeItem("customTopics");
    console.log("All custom topics cleared");
  };
  const testDeleteModal = () => {
    console.log("Testing delete modal");
    topicToDelete.value = {
      key: "test",
      vi: "Test Topic",
      en: "Test Topic",
      ko: " "
    };
    console.log("Test topic set:", topicToDelete.value);
  };
  const resetForm = () => {
    editingTopic.value = null;
    newTopic.value = { key: "", vi: "", en: "", ko: "" };
    topicToDelete.value = null;
  };
  return {
    // State
    customTopics,
    editingTopic,
    topicToDelete,
    newTopic,
    // Computed
    canSaveTopic,
    showDeleteModal,
    // Methods
    loadCustomTopics,
    saveCustomTopics,
    saveTopic,
    editTopic,
    cancelEdit,
    confirmDeleteTopic,
    deleteTopic,
    reloadCustomTopics,
    clearAllCustomTopics,
    testDeleteModal,
    resetForm,
    generateTopicKey,
    isKeyTaken,
    notifyTopicsUpdated
  };
}

function useTopicSearch(customTopics, builtInTopics) {
  const searchQuery = ref("");
  const filteredCustomTopics = computed(() => {
    if (!searchQuery.value.trim()) {
      return customTopics.value;
    }
    const query = searchQuery.value.toLowerCase().trim();
    return customTopics.value.filter(
      (topic) => (topic.key || "").toLowerCase().includes(query) || (topic.vi || "").toLowerCase().includes(query) || (topic.en || "").toLowerCase().includes(query) || (topic.ko || "").toLowerCase().includes(query)
    );
  });
  const filteredBuiltInTopics = computed(() => {
    if (!searchQuery.value.trim()) {
      return builtInTopics.value;
    }
    const query = searchQuery.value.toLowerCase().trim();
    return builtInTopics.value.filter(
      (topic) => (topic.key || "").toLowerCase().includes(query) || (topic.vi || "").toLowerCase().includes(query) || (topic.en || "").toLowerCase().includes(query) || (topic.ko || "").toLowerCase().includes(query)
    );
  });
  const resetSearch = () => {
    searchQuery.value = "";
  };
  return {
    // State
    searchQuery,
    // Computed
    filteredCustomTopics,
    filteredBuiltInTopics,
    // Methods
    resetSearch
  };
}

function useTopicPagination(filteredCustomTopics, filteredBuiltInTopics, searchQuery) {
  const ITEMS_PER_PAGE = 3;
  const currentCustomPage = ref(1);
  const currentBuiltInPage = ref(1);
  const totalCustomPages = computed(() => {
    return Math.ceil(filteredCustomTopics.value.length / ITEMS_PER_PAGE);
  });
  const paginatedCustomTopics = computed(() => {
    const start = (currentCustomPage.value - 1) * ITEMS_PER_PAGE;
    const end = start + ITEMS_PER_PAGE;
    return filteredCustomTopics.value.slice(start, end);
  });
  const totalBuiltInPages = computed(() => {
    return Math.ceil(filteredBuiltInTopics.value.length / ITEMS_PER_PAGE);
  });
  const paginatedBuiltInTopics = computed(() => {
    const start = (currentBuiltInPage.value - 1) * ITEMS_PER_PAGE;
    const end = start + ITEMS_PER_PAGE;
    return filteredBuiltInTopics.value.slice(start, end);
  });
  const visibleCustomPages = computed(() => {
    const total = totalCustomPages.value;
    const current = currentCustomPage.value;
    const maxVisible = 3;
    if (total <= maxVisible) {
      return Array.from({ length: total }, (_, i) => i + 1);
    }
    let start = Math.max(1, current - Math.floor(maxVisible / 2));
    let end = Math.min(total, start + maxVisible - 1);
    if (end - start + 1 < maxVisible) {
      start = Math.max(1, end - maxVisible + 1);
    }
    return Array.from({ length: end - start + 1 }, (_, i) => start + i);
  });
  const visibleBuiltInPages = computed(() => {
    const total = totalBuiltInPages.value;
    const current = currentBuiltInPage.value;
    const maxVisible = 3;
    if (total <= maxVisible) {
      return Array.from({ length: total }, (_, i) => i + 1);
    }
    let start = Math.max(1, current - Math.floor(maxVisible / 2));
    let end = Math.min(total, start + maxVisible - 1);
    if (end - start + 1 < maxVisible) {
      start = Math.max(1, end - maxVisible + 1);
    }
    return Array.from({ length: end - start + 1 }, (_, i) => start + i);
  });
  const goToCustomPage = (page) => {
    if (page >= 1 && page <= totalCustomPages.value) {
      currentCustomPage.value = page;
    }
  };
  const goToBuiltInPage = (page) => {
    if (page >= 1 && page <= totalBuiltInPages.value) {
      currentBuiltInPage.value = page;
    }
  };
  const nextCustomPage = () => {
    if (currentCustomPage.value < totalCustomPages.value) {
      currentCustomPage.value++;
    }
  };
  const prevCustomPage = () => {
    if (currentCustomPage.value > 1) {
      currentCustomPage.value--;
    }
  };
  const nextBuiltInPage = () => {
    if (currentBuiltInPage.value < totalBuiltInPages.value) {
      currentBuiltInPage.value++;
    }
  };
  const prevBuiltInPage = () => {
    if (currentBuiltInPage.value > 1) {
      currentBuiltInPage.value--;
    }
  };
  const resetPagination = () => {
    currentCustomPage.value = 1;
    currentBuiltInPage.value = 1;
  };
  watch(searchQuery, () => {
    resetPagination();
  });
  return {
    // Constants
    ITEMS_PER_PAGE,
    // State
    currentCustomPage,
    currentBuiltInPage,
    // Computed
    totalCustomPages,
    totalBuiltInPages,
    paginatedCustomTopics,
    paginatedBuiltInTopics,
    visibleCustomPages,
    visibleBuiltInPages,
    // Methods
    goToCustomPage,
    goToBuiltInPage,
    nextCustomPage,
    prevCustomPage,
    nextBuiltInPage,
    prevBuiltInPage,
    resetPagination
  };
}

function useTopicModal(modelValue, emit, resetForm, resetSearch, resetPagination, loadCustomTopics) {
  const closeDialog = () => {
    emit("update:modelValue", false);
  };
  const lockBodyScroll = () => {
    document.body.style.overflow = "hidden";
  };
  const unlockBodyScroll = () => {
    document.body.style.overflow = "";
  };
  watch(() => modelValue.value, (newValue) => {
    if (newValue) {
      lockBodyScroll();
      loadCustomTopics();
    } else {
      unlockBodyScroll();
      resetForm();
      resetSearch();
      resetPagination();
    }
  }, { immediate: true });
  onMounted(() => {
    if (modelValue.value) {
      loadCustomTopics();
      lockBodyScroll();
    }
  });
  onUnmounted(() => {
    unlockBodyScroll();
  });
  return {
    // Methods
    closeDialog,
    lockBodyScroll,
    unlockBodyScroll
  };
}

function useBuiltInTopics() {
  const builtInTopics = computed(() => {
    return [
      { key: "technology", vi: "Cng ngh", en: "Technology", ko: "" },
      { key: "business", vi: "Kinh doanh", en: "Business", ko: "" },
      { key: "travel", vi: "Du lch", en: "Travel", ko: "" },
      { key: "food", vi: "m thc", en: "Food", ko: "" },
      { key: "health", vi: "Sc khe", en: "Health", ko: "" },
      { key: "education", vi: "Gio dc", en: "Education", ko: "" },
      { key: "sports", vi: "Th thao", en: "Sports", ko: "" },
      { key: "entertainment", vi: "Gii tr", en: "Entertainment", ko: "" },
      { key: "science", vi: "Khoa hc", en: "Science", ko: "" },
      { key: "art", vi: "Ngh thut", en: "Art", ko: "" },
      { key: "music", vi: "m nhc", en: "Music", ko: "" },
      { key: "literature", vi: "Vn hc", en: "Literature", ko: "" },
      { key: "politics", vi: "Chnh tr", en: "Politics", ko: "" },
      { key: "environment", vi: "Mi trng", en: "Environment", ko: "" },
      { key: "fashion", vi: "Thi trang", en: "Fashion", ko: "" },
      { key: "finance", vi: "Ti chnh", en: "Finance", ko: "" }
    ];
  });
  const builtInTopicKeys = computed(() => {
    return builtInTopics.value.map((topic) => topic.key);
  });
  const isBuiltInTopic = (key) => {
    return builtInTopicKeys.value.includes(key);
  };
  const getBuiltInTopic = (key) => {
    return builtInTopics.value.find((topic) => topic.key === key);
  };
  return {
    // Computed
    builtInTopics,
    builtInTopicKeys,
    // Methods
    isBuiltInTopic,
    getBuiltInTopic
  };
}

const _hoisted_1$X = {
  key: 0,
  class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$U = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl w-full max-w-full sm:max-w-lg md:max-w-2xl lg:max-w-4xl max-h-[90vh] flex flex-col overflow-hidden" };
const _hoisted_3$S = { class: "flex-shrink-0 flex flex-row items-center justify-between p-4 sm:p-6 md:p-6 lg:p-8 border-b border-gray-200 dark:border-gray-700 space-x-4 sm:space-x-6 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$Q = { class: "flex-1 min-w-0" };
const _hoisted_5$N = { class: "text-base sm:text-lg md:text-2xl lg:text-2xl font-semibold text-gray-900 dark:text-white mb-0 flex items-center space-x-2" };
const _hoisted_6$L = { class: "sticky top-0 z-10 bg-white dark:bg-[#0a0a0a] border-b border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_7$J = { class: "px-4 py-3 border-b border-gray-100 dark:border-dark-bg-mute" };
const _hoisted_8$J = { class: "relative" };
const _hoisted_9$I = ["placeholder"];
const _hoisted_10$H = { class: "px-4 py-3 bg-gray-50 dark:bg-[#0a0a0a]" };
const _hoisted_11$H = { class: "flex items-center gap-2 mb-2" };
const _hoisted_12$G = { class: "text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_13$G = { class: "flex flex-wrap gap-2" };
const _hoisted_14$G = { class: "flex-1 min-w-[200px]" };
const _hoisted_15$B = ["placeholder"];
const _hoisted_16$A = { class: "flex-1 min-w-[200px]" };
const _hoisted_17$z = ["placeholder"];
const _hoisted_18$y = { class: "flex-1 min-w-[200px]" };
const _hoisted_19$y = ["placeholder"];
const _hoisted_20$x = { class: "flex gap-2" };
const _hoisted_21$x = ["disabled"];
const _hoisted_22$v = { class: "flex-1 p-4 sm:p-6 md:p-6 lg:p-8 overflow-y-auto min-h-0" };
const _hoisted_23$v = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_24$u = { class: "text-base sm:text-lg md:text-base lg:text-lg font-medium text-gray-900 dark:text-white mb-3 sm:mb-4 md:mb-3 lg:mb-4 flex items-center" };
const _hoisted_25$u = {
  key: 0,
  class: "text-center py-6 sm:py-8 md:py-6 lg:py-8 text-sm md:text-sm lg:text-base text-gray-500 dark:text-gray-400"
};
const _hoisted_26$s = {
  key: 1,
  class: "space-y-3 sm:space-y-4 md:space-y-3 lg:space-y-4"
};
const _hoisted_27$r = { class: "flex-1" };
const _hoisted_28$q = { class: "flex items-center gap-4 sm:gap-4 mb-2" };
const _hoisted_29$o = { class: "px-2 py-1 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 text-xs font-medium rounded" };
const _hoisted_30$n = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_31$m = { class: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4 text-sm" };
const _hoisted_32$j = { class: "flex gap-3 sm:gap-4 ml-4" };
const _hoisted_33$j = ["onClick", "title"];
const _hoisted_34$i = ["onClick", "disabled", "title"];
const _hoisted_35$i = {
  key: 0,
  class: "flex justify-center mt-6"
};
const _hoisted_36$h = { class: "flex items-center space-x-1" };
const _hoisted_37$g = ["disabled"];
const _hoisted_38$g = ["onClick"];
const _hoisted_39$e = ["disabled"];
const _hoisted_40$e = {
  class: "mt-6 animate-fade-in-up",
  style: { "animation-delay": "0.8s" }
};
const _hoisted_41$d = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4 flex items-center" };
const _hoisted_42$b = { class: "text-sm text-gray-600 dark:text-gray-400 mb-4" };
const _hoisted_43$a = { class: "grid grid-cols-1 md:grid-cols-2 gap-3 sm:gap-4" };
const _hoisted_44$a = { class: "flex-1" };
const _hoisted_45$9 = { class: "flex items-center gap-3 mb-1" };
const _hoisted_46$9 = { class: "px-2 py-1 bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 text-xs font-medium rounded" };
const _hoisted_47$9 = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_48$9 = { class: "grid grid-cols-1 gap-1 text-sm" };
const _hoisted_49$8 = { class: "ml-4" };
const _hoisted_50$8 = { class: "px-2 py-1 bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300 text-xs font-medium rounded" };
const _hoisted_51$7 = {
  key: 0,
  class: "flex justify-center mt-6"
};
const _hoisted_52$7 = { class: "flex items-center space-x-1" };
const _hoisted_53$7 = ["disabled"];
const _hoisted_54$7 = ["onClick"];
const _hoisted_55$7 = ["disabled"];
const _hoisted_56$7 = { class: "flex-shrink-0 flex justify-end p-4 sm:p-6 border-t border-gray-200 dark:border-dark-bg-mute bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_57$7 = { class: "p-6" };
const _hoisted_58$7 = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4 flex items-center" };
const _hoisted_59$6 = { class: "text-gray-600 dark:text-gray-300 mb-6" };
const _hoisted_60$6 = { class: "flex gap-3 justify-end" };
const _sfc_main$X = /* @__PURE__ */ defineComponent({
  __name: "TopicManager",
  props: {
    modelValue: { type: Boolean },
    vocabularyUsage: { default: () => ({}) }
  },
  emits: ["update:modelValue", "topic-added", "topic-updated", "topic-deleted"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const modelValueRef = toRef(props, "modelValue");
    const topicCRUD = useTopicCRUD(emit);
    const { builtInTopics } = useBuiltInTopics();
    const topicSearch = useTopicSearch(topicCRUD.customTopics, builtInTopics);
    const topicPagination = useTopicPagination(
      topicSearch.filteredCustomTopics,
      topicSearch.filteredBuiltInTopics,
      topicSearch.searchQuery
    );
    const topicModal = useTopicModal(
      modelValueRef,
      emit,
      topicCRUD.resetForm,
      topicSearch.resetSearch,
      topicPagination.resetPagination,
      topicCRUD.loadCustomTopics
    );
    const {
      customTopics,
      editingTopic,
      topicToDelete,
      newTopic,
      canSaveTopic,
      showDeleteModal,
      saveTopic,
      editTopic,
      cancelEdit,
      confirmDeleteTopic,
      deleteTopic} = topicCRUD;
    const { searchQuery, filteredCustomTopics, filteredBuiltInTopics } = topicSearch;
    const {
      ITEMS_PER_PAGE,
      currentCustomPage,
      currentBuiltInPage,
      totalCustomPages,
      totalBuiltInPages,
      paginatedCustomTopics,
      paginatedBuiltInTopics,
      visibleCustomPages,
      visibleBuiltInPages
    } = topicPagination;
    const { closeDialog } = topicModal;
    const getTopicUsageCount = (key) => {
      return props.vocabularyUsage[key] || 0;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$X, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$U, [
                    createBaseVNode("div", _hoisted_3$S, [
                      createBaseVNode("div", _hoisted_4$Q, [
                        createBaseVNode("h2", _hoisted_5$N, [
                          _cache[16] || (_cache[16] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                          createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.topicManager.title", "Topic Manager")), 1)
                        ])
                      ]),
                      createBaseVNode("button", {
                        onClick: _cache[0] || (_cache[0] = //@ts-ignore
                        (...args) => unref(closeDialog) && unref(closeDialog)(...args)),
                        class: "flex-shrink-0 inline-flex items-center justify-center w-8 h-8 sm:w-9 sm:h-9 rounded-full bg-gray-50 hover:bg-gray-100 text-gray-600 hover:text-gray-800 dark:bg-dark-bg-soft dark:text-white/70 dark:hover:text-white dark:hover:bg-dark-bg-mute transition-all duration-300 hover:scale-110 hover:rotate-90 hover:dark:bg-gray-800"
                      }, _cache[17] || (_cache[17] = [
                        createBaseVNode("svg", {
                          class: "w-5 h-5 sm:w-6 sm:h-6",
                          fill: "none",
                          stroke: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          createBaseVNode("path", {
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            "stroke-width": "2",
                            d: "M6 18L18 6M6 6l12 12"
                          })
                        ], -1)
                      ]))
                    ]),
                    createBaseVNode("div", _hoisted_6$L, [
                      createBaseVNode("div", _hoisted_7$J, [
                        createBaseVNode("div", _hoisted_8$J, [
                          withDirectives(createBaseVNode("input", {
                            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(searchQuery) ? searchQuery.value = $event : null),
                            type: "text",
                            placeholder: unref(t)("vocabulary.topicManager.searchPlaceholder", "Search topics by name..."),
                            class: "w-full px-4 py-2.5 pl-10 border-2 animated-search-border rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white text-sm focus:ring-2 focus:ring-blue-500/50 transition-all duration-300 shadow-sm"
                          }, null, 8, _hoisted_9$I), [
                            [vModelText, unref(searchQuery)]
                          ]),
                          _cache[18] || (_cache[18] = createBaseVNode("div", { class: "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none" }, [
                            createBaseVNode("svg", {
                              class: "w-4 h-4 text-gray-400 dark:text-gray-500",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                              })
                            ])
                          ], -1))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_10$H, [
                        createBaseVNode("div", _hoisted_11$H, [
                          _cache[19] || (_cache[19] = createBaseVNode("span", { class: "w-1 h-3 bg-blue-500 rounded" }, null, -1)),
                          createBaseVNode("h3", _hoisted_12$G, toDisplayString$1(unref(editingTopic) ? unref(t)("vocabulary.topicManager.editTopic", "Edit Topic") : unref(t)("vocabulary.topicManager.addNewTopic", "Add New Topic")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_13$G, [
                          createBaseVNode("div", _hoisted_14$G, [
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(newTopic).vi = $event),
                              type: "text",
                              placeholder: unref(t)("vocabulary.topicManager.vietnameseNamePlaceholder", "Tn ting Vit"),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white text-sm focus:ring-1 focus:ring-purple-500 focus:border-transparent transition-all duration-300"
                            }, null, 8, _hoisted_15$B), [
                              [vModelText, unref(newTopic).vi]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_16$A, [
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(newTopic).en = $event),
                              type: "text",
                              placeholder: unref(t)("vocabulary.topicManager.englishNamePlaceholder", "English name"),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white text-sm focus:ring-1 focus:ring-orange-500 focus:border-transparent transition-all duration-300"
                            }, null, 8, _hoisted_17$z), [
                              [vModelText, unref(newTopic).en]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_18$y, [
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(newTopic).ko = $event),
                              type: "text",
                              placeholder: unref(t)("vocabulary.topicManager.koreanNamePlaceholder", " "),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white text-sm focus:ring-1 focus:ring-green-500 focus:border-transparent transition-all duration-300"
                            }, null, 8, _hoisted_19$y), [
                              [vModelText, unref(newTopic).ko]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_20$x, [
                            createBaseVNode("button", {
                              onClick: _cache[5] || (_cache[5] = //@ts-ignore
                              (...args) => unref(saveTopic) && unref(saveTopic)(...args)),
                              disabled: !unref(canSaveTopic),
                              class: "px-4 py-2 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 disabled:from-gray-400 disabled:to-gray-500 text-white text-sm rounded-md transition-all duration-300 disabled:cursor-not-allowed font-medium"
                            }, toDisplayString$1(unref(editingTopic) ? unref(t)("common.update", "Update") : unref(t)("common.add", "Add")), 9, _hoisted_21$x),
                            unref(editingTopic) ? (openBlock(), createElementBlock("button", {
                              key: 0,
                              onClick: _cache[6] || (_cache[6] = //@ts-ignore
                              (...args) => unref(cancelEdit) && unref(cancelEdit)(...args)),
                              class: "px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white text-sm rounded-md transition-all duration-300 font-medium"
                            }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1)) : createCommentVNode("", true)
                          ])
                        ])
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_22$v, [
                      createBaseVNode("div", _hoisted_23$v, [
                        createBaseVNode("h3", _hoisted_24$u, [
                          _cache[20] || (_cache[20] = createBaseVNode("span", { class: "w-1 h-4 bg-indigo-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.topicManager.existingTopics", "Custom Topics")), 1)
                        ]),
                        unref(customTopics).length === 0 ? (openBlock(), createElementBlock("div", _hoisted_25$u, toDisplayString$1(unref(t)("vocabulary.topicManager.noCustomTopics", "No custom topics created yet")), 1)) : (openBlock(), createElementBlock("div", _hoisted_26$s, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(paginatedCustomTopics), (topic, index) => {
                            return openBlock(), createElementBlock("div", {
                              key: topic.key,
                              class: "flex items-center justify-between p-3 sm:p-4 md:p-3 lg:p-4 bg-gray-50 dark:bg-[#0a0a0a] rounded-lg border border-gray-200 dark:border-gray-700 hover:bg-gray-100 dark:hover:bg-gray-800 transition-all duration-300 hover:scale-[1.02] animate-fade-in-up",
                              style: normalizeStyle({ animationDelay: `${0.7 + index * 0.1}s` })
                            }, [
                              createBaseVNode("div", _hoisted_27$r, [
                                createBaseVNode("div", _hoisted_28$q, [
                                  createBaseVNode("span", _hoisted_29$o, toDisplayString$1(topic.key), 1),
                                  createBaseVNode("span", _hoisted_30$n, " (" + toDisplayString$1(getTopicUsageCount(topic.key)) + " " + toDisplayString$1(unref(t)("vocabulary.words", "words")) + ") ", 1)
                                ]),
                                createBaseVNode("div", _hoisted_31$m, [
                                  createBaseVNode("div", null, [
                                    _cache[21] || (_cache[21] = createBaseVNode("span", { class: "font-medium" }, "VI:", -1)),
                                    createTextVNode(" " + toDisplayString$1(topic.vi), 1)
                                  ]),
                                  createBaseVNode("div", null, [
                                    _cache[22] || (_cache[22] = createBaseVNode("span", { class: "font-medium" }, "EN:", -1)),
                                    createTextVNode(" " + toDisplayString$1(topic.en), 1)
                                  ]),
                                  createBaseVNode("div", null, [
                                    _cache[23] || (_cache[23] = createBaseVNode("span", { class: "font-medium" }, "KO:", -1)),
                                    createTextVNode(" " + toDisplayString$1(topic.ko), 1)
                                  ])
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_32$j, [
                                createBaseVNode("button", {
                                  onClick: ($event) => unref(editTopic)(topic),
                                  class: "p-2 text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-200 hover:bg-blue-50 dark:hover:bg-blue-900 rounded-lg transition-all duration-300 hover:scale-110",
                                  title: unref(t)("common.edit", "Edit")
                                }, _cache[24] || (_cache[24] = [
                                  createBaseVNode("svg", {
                                    class: "w-4 h-4",
                                    fill: "none",
                                    stroke: "currentColor",
                                    viewBox: "0 0 24 24"
                                  }, [
                                    createBaseVNode("path", {
                                      "stroke-linecap": "round",
                                      "stroke-linejoin": "round",
                                      "stroke-width": "2",
                                      d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                                    })
                                  ], -1)
                                ]), 8, _hoisted_33$j),
                                createBaseVNode("button", {
                                  onClick: ($event) => unref(confirmDeleteTopic)(topic),
                                  disabled: getTopicUsageCount(topic.key) > 0,
                                  class: "p-2 text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-200 hover:bg-red-50 dark:hover:bg-red-900 rounded-lg transition-all duration-300 hover:scale-110 disabled:text-gray-400 disabled:cursor-not-allowed",
                                  title: getTopicUsageCount(topic.key) > 0 ? unref(t)("vocabulary.topicManager.cannotDeleteInUse", "Cannot delete topic in use") : unref(t)("common.delete", "Delete")
                                }, _cache[25] || (_cache[25] = [
                                  createBaseVNode("svg", {
                                    class: "w-4 h-4",
                                    fill: "none",
                                    stroke: "currentColor",
                                    viewBox: "0 0 24 24"
                                  }, [
                                    createBaseVNode("path", {
                                      "stroke-linecap": "round",
                                      "stroke-linejoin": "round",
                                      "stroke-width": "2",
                                      d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                                    })
                                  ], -1)
                                ]), 8, _hoisted_34$i)
                              ])
                            ], 4);
                          }), 128)),
                          unref(filteredCustomTopics).length > unref(ITEMS_PER_PAGE) ? (openBlock(), createElementBlock("div", _hoisted_35$i, [
                            createBaseVNode("div", _hoisted_36$h, [
                              createBaseVNode("button", {
                                onClick: _cache[7] || (_cache[7] = ($event) => currentCustomPage.value--),
                                disabled: unref(currentCustomPage) === 1,
                                class: "px-3 py-2 rounded-lg bg-gray-100 dark:bg-dark-bg-mute text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-dark-bg-soft disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300"
                              }, "  ", 8, _hoisted_37$g),
                              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(visibleCustomPages), (page) => {
                                return openBlock(), createElementBlock("button", {
                                  key: page,
                                  onClick: ($event) => currentCustomPage.value = page,
                                  class: normalizeClass([
                                    "px-3 py-2 rounded-lg text-sm transition-all duration-300",
                                    unref(currentCustomPage) === page ? "bg-blue-500 text-white shadow-md" : "bg-gray-100 dark:bg-dark-bg-mute text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-dark-bg-soft"
                                  ])
                                }, toDisplayString$1(page), 11, _hoisted_38$g);
                              }), 128)),
                              createBaseVNode("button", {
                                onClick: _cache[8] || (_cache[8] = ($event) => currentCustomPage.value++),
                                disabled: unref(currentCustomPage) === unref(totalCustomPages),
                                class: "px-3 py-2 rounded-lg bg-gray-100 dark:bg-dark-bg-mute text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-dark-bg-soft disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300"
                              }, "  ", 8, _hoisted_39$e)
                            ])
                          ])) : createCommentVNode("", true)
                        ]))
                      ]),
                      createBaseVNode("div", _hoisted_40$e, [
                        createBaseVNode("h3", _hoisted_41$d, [
                          _cache[26] || (_cache[26] = createBaseVNode("span", { class: "w-1 h-4 bg-teal-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.topicManager.builtInTopics", "Built-in Topics")), 1)
                        ]),
                        createBaseVNode("p", _hoisted_42$b, toDisplayString$1(unref(t)("vocabulary.topicManager.builtInTopicsDescription", "These are system-provided topics that cannot be modified")), 1),
                        createBaseVNode("div", _hoisted_43$a, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(paginatedBuiltInTopics), (topic, index) => {
                            return openBlock(), createElementBlock("div", {
                              key: topic.key,
                              class: "flex items-center justify-between p-3 sm:p-4 bg-gray-50 dark:bg-[#0a0a0a] rounded-lg border border-gray-200 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-800 transition-all duration-300 hover:scale-[1.02] animate-fade-in-up",
                              style: normalizeStyle({ animationDelay: `${0.9 + index * 0.05}s` })
                            }, [
                              createBaseVNode("div", _hoisted_44$a, [
                                createBaseVNode("div", _hoisted_45$9, [
                                  createBaseVNode("span", _hoisted_46$9, toDisplayString$1(topic.key), 1),
                                  createBaseVNode("span", _hoisted_47$9, " (" + toDisplayString$1(getTopicUsageCount(topic.key)) + " " + toDisplayString$1(unref(t)("vocabulary.words", "words")) + ") ", 1)
                                ]),
                                createBaseVNode("div", _hoisted_48$9, [
                                  createBaseVNode("div", null, [
                                    _cache[27] || (_cache[27] = createBaseVNode("span", { class: "font-medium" }, "VI:", -1)),
                                    createTextVNode(" " + toDisplayString$1(topic.vi), 1)
                                  ]),
                                  createBaseVNode("div", null, [
                                    _cache[28] || (_cache[28] = createBaseVNode("span", { class: "font-medium" }, "EN:", -1)),
                                    createTextVNode(" " + toDisplayString$1(topic.en), 1)
                                  ]),
                                  createBaseVNode("div", null, [
                                    _cache[29] || (_cache[29] = createBaseVNode("span", { class: "font-medium" }, "KO:", -1)),
                                    createTextVNode(" " + toDisplayString$1(topic.ko), 1)
                                  ])
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_49$8, [
                                createBaseVNode("span", _hoisted_50$8, toDisplayString$1(unref(t)("vocabulary.topicManager.builtIn", "Built-in")), 1)
                              ])
                            ], 4);
                          }), 128))
                        ]),
                        unref(filteredBuiltInTopics).length > unref(ITEMS_PER_PAGE) ? (openBlock(), createElementBlock("div", _hoisted_51$7, [
                          createBaseVNode("div", _hoisted_52$7, [
                            createBaseVNode("button", {
                              onClick: _cache[9] || (_cache[9] = ($event) => currentBuiltInPage.value--),
                              disabled: unref(currentBuiltInPage) === 1,
                              class: "px-3 py-2 rounded-lg bg-gray-100 dark:bg-dark-bg-mute text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-dark-bg-soft disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300"
                            }, "  ", 8, _hoisted_53$7),
                            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(visibleBuiltInPages), (page) => {
                              return openBlock(), createElementBlock("button", {
                                key: page,
                                onClick: ($event) => currentBuiltInPage.value = page,
                                class: normalizeClass([
                                  "px-3 py-2 rounded-lg text-sm transition-all duration-300",
                                  unref(currentBuiltInPage) === page ? "bg-blue-500 text-white shadow-md" : "bg-gray-100 dark:bg-dark-bg-mute text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-dark-bg-soft"
                                ])
                              }, toDisplayString$1(page), 11, _hoisted_54$7);
                            }), 128)),
                            createBaseVNode("button", {
                              onClick: _cache[10] || (_cache[10] = ($event) => currentBuiltInPage.value++),
                              disabled: unref(currentBuiltInPage) === unref(totalBuiltInPages),
                              class: "px-3 py-2 rounded-lg bg-gray-100 dark:bg-dark-bg-mute text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-dark-bg-soft disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300"
                            }, "  ", 8, _hoisted_55$7)
                          ])
                        ])) : createCommentVNode("", true)
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_56$7, [
                      createBaseVNode("button", {
                        onClick: _cache[11] || (_cache[11] = //@ts-ignore
                        (...args) => unref(closeDialog) && unref(closeDialog)(...args)),
                        class: "px-6 py-2.5 sm:px-8 sm:py-3 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium text-sm sm:text-base animate-fade-in-up focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2",
                        style: { "animation-delay": "0.1s" }
                      }, toDisplayString$1(unref(t)("common.finish", "Finish")), 1)
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        }),
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-300 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-200 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            unref(showDeleteModal) ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-[9999] backdrop-blur-sm",
              onClick: _cache[15] || (_cache[15] = withModifiers(($event) => topicToDelete.value = null, ["self"]))
            }, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-300 ease-out",
                "enter-from-class": "opacity-0 scale-95 translate-y-4",
                "enter-to-class": "opacity-100 scale-100 translate-y-0",
                "leave-active-class": "transition-all duration-200 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0",
                "leave-to-class": "opacity-0 scale-95 translate-y-4"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl max-w-md w-full",
                    onClick: _cache[14] || (_cache[14] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("div", _hoisted_57$7, [
                      createBaseVNode("h3", _hoisted_58$7, [
                        _cache[30] || (_cache[30] = createBaseVNode("span", { class: "w-2 h-2 bg-red-500 rounded-full mr-2 animate-pulse" }, null, -1)),
                        createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.topicManager.confirmDeleteTitle", "Confirm Delete")), 1)
                      ]),
                      createBaseVNode("p", _hoisted_59$6, toDisplayString$1(unref(t)("vocabulary.topicManager.confirmDeleteMessage", { topic: unref(topicToDelete)?.vi || unref(topicToDelete)?.en || "this topic" }, `Are you sure you want to delete "${unref(topicToDelete)?.vi || unref(topicToDelete)?.en || "this topic"}"?`)), 1),
                      createBaseVNode("div", _hoisted_60$6, [
                        createBaseVNode("button", {
                          onClick: _cache[12] || (_cache[12] = ($event) => topicToDelete.value = null),
                          class: "px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium"
                        }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                        createBaseVNode("button", {
                          onClick: _cache[13] || (_cache[13] = //@ts-ignore
                          (...args) => unref(deleteTopic) && unref(deleteTopic)(...args)),
                          class: "px-4 py-2 bg-gradient-to-r from-red-600 to-red-700 hover:from-red-700 hover:to-red-800 text-white rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium"
                        }, toDisplayString$1(unref(t)("common.delete", "Delete")), 1)
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const TopicManager = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["__scopeId", "data-v-429bd37b"]]);

const TopicManager$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: TopicManager
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$W = { class: "bg-white/60 dark:bg-[#0a0a0a]/60 backdrop-blur-sm rounded-xl border border-white/20 dark:border-white/10 p-3 sm:p-4 md:p-5" };
const _hoisted_2$T = { class: "flex items-center mb-3 sm:mb-4" };
const _hoisted_3$R = { class: "text-sm sm:text-base font-semibold bg-gradient-to-r from-red-600 to-red-600 dark:from-red-400 dark:to-red-400 bg-clip-text text-transparent" };
const _hoisted_4$P = { class: "flex flex-col space-y-3" };
const _hoisted_5$M = { class: "text-xs sm:text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_6$K = { class: "flex flex-col sm:flex-row gap-2" };
const _hoisted_7$I = {
  key: 0,
  class: "fixed inset-0 z-[9999] flex items-center justify-center p-4",
  "aria-labelledby": "modal-title",
  role: "dialog",
  "aria-modal": "true"
};
const _hoisted_8$I = { class: "relative bg-white dark:bg-[#0a0a0a] rounded-lg shadow-xl w-full max-w-lg mx-auto border border-gray-200 dark:border-dark-bg-mute overflow-hidden p-6" };
const _hoisted_9$H = { class: "sm:flex sm:items-start" };
const _hoisted_10$G = { class: "mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left" };
const _hoisted_11$G = {
  class: "text-lg leading-6 font-medium text-gray-900 dark:text-white",
  id: "modal-title"
};
const _hoisted_12$F = { class: "mt-2" };
const _hoisted_13$F = { class: "text-sm text-gray-500 dark:text-gray-300" };
const _hoisted_14$F = { class: "mt-3 p-3 bg-red-50 dark:bg-red-900/20 rounded-md border border-red-200 dark:border-red-800" };
const _hoisted_15$A = { class: "text-sm text-red-800 dark:text-red-300 font-medium" };
const _hoisted_16$z = { class: "mt-5 sm:mt-4 sm:flex sm:flex-row-reverse" };
const _hoisted_17$y = {
  key: 0,
  class: "fixed inset-0 z-[9999] flex items-center justify-center p-4",
  "aria-labelledby": "clear-local-store-modal-title",
  role: "dialog",
  "aria-modal": "true"
};
const _hoisted_18$x = { class: "relative bg-white dark:bg-[#0a0a0a] rounded-lg shadow-xl w-full max-w-lg mx-auto border border-gray-200 dark:border-dark-bg-mute overflow-hidden p-6" };
const _hoisted_19$x = { class: "sm:flex sm:items-start" };
const _hoisted_20$w = { class: "mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left" };
const _hoisted_21$w = {
  class: "text-lg leading-6 font-medium text-gray-900 dark:text-white",
  id: "clear-local-store-modal-title"
};
const _hoisted_22$u = { class: "mt-2" };
const _hoisted_23$u = { class: "text-sm text-gray-500 dark:text-gray-300" };
const _hoisted_24$t = { class: "text-sm text-orange-600 dark:text-orange-400 mt-2 font-medium" };
const _hoisted_25$t = { class: "mt-3 p-3 bg-orange-50 dark:bg-orange-900/20 rounded-md border border-orange-200 dark:border-orange-800" };
const _hoisted_26$r = { class: "text-sm text-orange-800 dark:text-orange-300 font-medium" };
const _hoisted_27$q = { class: "mt-5 sm:mt-4 sm:flex sm:flex-row-reverse" };
const _sfc_main$W = /* @__PURE__ */ defineComponent({
  __name: "DeleteAllVocabulariesPanel",
  props: {
    totalCount: {},
    autoSaveEnabled: { type: Boolean },
    useGrouping: { type: Boolean }
  },
  emits: ["vocabularies-deleted", "local-store-cleared"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const { t } = useI18n();
    const toast = useToast();
    const vocabularyStore = useVocabularyStore();
    const themeStore = useThemeStore();
    const voiceStore = useVoiceStore();
    const showDeleteAllModal = ref(false);
    const showClearLocalStoreModal = ref(false);
    watch(showDeleteAllModal, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        document.body.classList.remove("modal-open");
      }
    });
    watch(showClearLocalStoreModal, (newValue) => {
      if (newValue) {
        document.body.classList.add("modal-open");
      } else {
        document.body.classList.remove("modal-open");
      }
    });
    const confirmDeleteAll = () => {
      try {
        vocabularyStore.clearAllVocabularies();
        showDeleteAllModal.value = false;
        toast.success(
          t("vocabulary.deleteAll.success", "All vocabulary words have been deleted successfully"),
          { timeout: 3e3 }
        );
        emit("vocabularies-deleted");
        console.log("All vocabularies deleted successfully");
      } catch (error) {
        console.error("Error deleting all vocabularies:", error);
        toast.error(
          t("vocabulary.deleteAll.error", "Failed to delete all vocabularies. Please try again."),
          { timeout: 5e3 }
        );
      }
    };
    const confirmClearLocalStore = () => {
      try {
        vocabularyStore.clearAllVocabularies();
        localStorage.clear();
        sessionStorage.clear();
        if ("indexedDB" in window) {
          try {
            indexedDB.deleteDatabase("vocabulary-db");
            indexedDB.deleteDatabase("practice-sessions-db");
            indexedDB.deleteDatabase("user-settings-db");
            console.log("IndexedDB databases deleted");
          } catch (dbError) {
            console.log("IndexedDB not available or error deleting:", dbError);
          }
        }
        document.cookie.split(";").forEach(function(c) {
          document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + (/* @__PURE__ */ new Date()).toUTCString() + ";path=/");
        });
        if ("caches" in window) {
          caches.keys().then(function(names) {
            for (let name of names) {
              caches.delete(name);
            }
          });
        }
        if ("cacheStorage" in window) {
          caches.keys().then(function(names) {
            for (let name of names) {
              caches.delete(name);
            }
          });
        }
        if ("serviceWorker" in navigator) {
          navigator.serviceWorker.getRegistrations().then(function(registrations) {
            for (let registration of registrations) {
              registration.unregister();
            }
          });
        }
        themeStore.setTheme(false);
        const voiceTypes = ["female-sweet", "female-clear", "female-professional", "male-strong", "male-gentle", "male-deep", "korean-female", "korean-male"];
        voiceTypes.forEach((type) => voiceStore.resetVoiceSettings(type));
        const commonKeys = [
          "vocabulary-data",
          "practice-sessions",
          "user-settings",
          "theme",
          "voice-settings",
          "accordion-state",
          "hover-expand-enabled",
          "auto-save-enabled",
          "move-mode-enabled",
          "grouping-enabled",
          "last-save-time",
          "save-status",
          "google-drive-token",
          "google-drive-refresh-token",
          "google-drive-file-id",
          "auto-save-file-path",
          "vocabulary-notes",
          "grammar-rules",
          "user-preferences",
          "app-settings",
          "vocabulary-filters",
          "search-history",
          "recent-searches",
          "favorite-words",
          "learning-progress",
          "daily-targets",
          "study-sessions",
          "vocabulary-categories",
          "topic-groups",
          "date-grouping",
          "pagination-settings",
          "sort-preferences",
          "display-options",
          "accessibility-settings",
          "performance-settings",
          "debug-settings",
          "error-logs",
          "analytics-data",
          "user-activity",
          "session-data",
          "cache-data",
          "temp-data",
          "backup-data",
          "sync-data",
          "offline-data",
          "pending-changes",
          "auto-save-queue",
          "undo-redo-stack",
          "clipboard-data",
          "drag-drop-state",
          "modal-state",
          "tooltip-state",
          "notification-state",
          "loading-state",
          "error-state",
          "success-state",
          "warning-state",
          "info-state"
        ];
        commonKeys.forEach((key) => {
          try {
            localStorage.removeItem(key);
            sessionStorage.removeItem(key);
          } catch (e) {
            console.log(`Error removing key ${key}:`, e);
          }
        });
        let localStorageLength = localStorage.length;
        while (localStorageLength > 0) {
          try {
            const key = localStorage.key(0);
            if (key) {
              localStorage.removeItem(key);
            }
            localStorageLength = localStorage.length;
          } catch (e) {
            console.log("Error removing dynamic localStorage key:", e);
            break;
          }
        }
        let sessionStorageLength = sessionStorage.length;
        while (sessionStorageLength > 0) {
          try {
            const key = sessionStorage.key(0);
            if (key) {
              sessionStorage.removeItem(key);
            }
            sessionStorageLength = sessionStorage.length;
          } catch (e) {
            console.log("Error removing dynamic sessionStorage key:", e);
            break;
          }
        }
        try {
          localStorage.clear();
          sessionStorage.clear();
        } catch (e) {
          console.log("Error in final clear:", e);
        }
        if ("gc" in window) {
          try {
            window.gc();
          } catch (e) {
            console.log("Garbage collection not available");
          }
        }
        showClearLocalStoreModal.value = false;
        toast.success(
          t("vocabulary.deleteAll.clearLocalStoreSuccess", "All local store data has been cleared successfully"),
          { timeout: 3e3 }
        );
        emit("local-store-cleared");
        console.log("Local store data cleared successfully - 100% complete");
        setTimeout(() => {
          const remainingLocalStorage = localStorage.length;
          const remainingSessionStorage = sessionStorage.length;
          if (remainingLocalStorage > 0 || remainingSessionStorage > 0) {
            console.log(`Warning: ${remainingLocalStorage} localStorage items and ${remainingSessionStorage} sessionStorage items remain`);
            try {
              localStorage.clear();
              sessionStorage.clear();
            } catch (e) {
              console.log("Final clear attempt failed:", e);
            }
          }
          console.log("Reloading page to ensure complete reset...");
          window.location.reload();
        }, 1500);
      } catch (error) {
        console.error("Error clearing local store data:", error);
        toast.error(
          t("vocabulary.deleteAll.clearLocalStoreError", "Failed to clear local store data. Please try again."),
          { timeout: 5e3 }
        );
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$W, [
        createBaseVNode("div", _hoisted_2$T, [
          _cache[4] || (_cache[4] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
            createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-red-400 to-red-500 rounded-full mr-2.5" })
          ], -1)),
          createBaseVNode("h3", _hoisted_3$R, toDisplayString$1(unref(t)("vocabulary.deleteAll.title", "Delete All Vocabularies")), 1)
        ]),
        createBaseVNode("div", _hoisted_4$P, [
          createBaseVNode("p", _hoisted_5$M, toDisplayString$1(unref(t)("vocabulary.deleteAll.description", "This will permanently delete all vocabulary words from your collection. This action cannot be undone.")), 1),
          createBaseVNode("div", _hoisted_6$K, [
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => showDeleteAllModal.value = true),
              class: "inline-flex items-center justify-center px-2 py-1.5 sm:px-3 sm:py-2 text-xs font-medium text-white bg-red-600 hover:bg-red-700 dark:bg-red-500 dark:hover:bg-red-600 rounded-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 dark:focus:ring-offset-[#0a0a0a] w-fit"
            }, [
              _cache[5] || (_cache[5] = createBaseVNode("svg", {
                class: "w-3 h-3 mr-1.5",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                })
              ], -1)),
              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.deleteAll.button", "Delete All Vocabularies")), 1)
            ]),
            createBaseVNode("button", {
              onClick: _cache[1] || (_cache[1] = ($event) => showClearLocalStoreModal.value = true),
              class: "inline-flex items-center justify-center px-2 py-1.5 sm:px-3 sm:py-2 text-xs font-medium text-white bg-orange-600 hover:bg-orange-700 dark:bg-orange-500 dark:hover:bg-orange-600 rounded-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-offset-2 dark:focus:ring-offset-[#0a0a0a] w-fit"
            }, [
              _cache[6] || (_cache[6] = createBaseVNode("svg", {
                class: "w-3 h-3 mr-1.5",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                })
              ], -1)),
              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.deleteAll.clearLocalStore", "Clear Local Store")), 1)
            ])
          ])
        ]),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          showDeleteAllModal.value ? (openBlock(), createElementBlock("div", _hoisted_7$I, [
            _cache[8] || (_cache[8] = createBaseVNode("div", {
              class: "fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm transition-opacity",
              "aria-hidden": "true"
            }, null, -1)),
            createBaseVNode("div", _hoisted_8$I, [
              createBaseVNode("div", _hoisted_9$H, [
                _cache[7] || (_cache[7] = createBaseVNode("div", { class: "mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100 dark:bg-red-900/30 sm:mx-0 sm:h-10 sm:w-10" }, [
                  createBaseVNode("svg", {
                    class: "h-6 w-6 text-red-600 dark:text-red-400",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    "stroke-width": "1.5",
                    stroke: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      d: "M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z"
                    })
                  ])
                ], -1)),
                createBaseVNode("div", _hoisted_10$G, [
                  createBaseVNode("h3", _hoisted_11$G, toDisplayString$1(unref(t)("vocabulary.deleteAll.confirmTitle", "Delete All Vocabularies")), 1),
                  createBaseVNode("div", _hoisted_12$F, [
                    createBaseVNode("p", _hoisted_13$F, toDisplayString$1(unref(t)("vocabulary.deleteAll.confirmMessage", "Are you sure you want to delete all vocabulary words? This action cannot be undone and will permanently remove all your saved words.")), 1),
                    createBaseVNode("div", _hoisted_14$F, [
                      createBaseVNode("p", _hoisted_15$A, toDisplayString$1(unref(t)("vocabulary.deleteAll.warningCount", { count: _ctx.totalCount }, `You are about to delete ${_ctx.totalCount} vocabulary words.`)), 1)
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_16$z, [
                createBaseVNode("button", {
                  onClick: confirmDeleteAll,
                  type: "button",
                  class: "w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-red-600 text-base font-medium text-white hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 dark:focus:ring-offset-[#0a0a0a] sm:ml-3 sm:w-auto sm:text-sm transition-colors duration-200"
                }, toDisplayString$1(unref(t)("vocabulary.deleteAll.confirm", "Delete All")), 1),
                createBaseVNode("button", {
                  onClick: _cache[2] || (_cache[2] = ($event) => showDeleteAllModal.value = false),
                  type: "button",
                  class: "mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 dark:border-dark-bg-mute shadow-sm px-4 py-2 bg-white dark:bg-dark-bg-soft text-base font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-dark-bg-mute focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:focus:ring-offset-[#0a0a0a] sm:mt-0 sm:w-auto sm:text-sm transition-colors duration-200"
                }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1)
              ])
            ])
          ])) : createCommentVNode("", true)
        ])),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          showClearLocalStoreModal.value ? (openBlock(), createElementBlock("div", _hoisted_17$y, [
            _cache[10] || (_cache[10] = createBaseVNode("div", {
              class: "fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm transition-opacity",
              "aria-hidden": "true"
            }, null, -1)),
            createBaseVNode("div", _hoisted_18$x, [
              createBaseVNode("div", _hoisted_19$x, [
                _cache[9] || (_cache[9] = createBaseVNode("div", { class: "mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-orange-100 dark:bg-orange-900/30 sm:mx-0 sm:h-10 sm:w-10" }, [
                  createBaseVNode("svg", {
                    class: "h-6 w-6 text-orange-600 dark:text-orange-400",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    "stroke-width": "1.5",
                    stroke: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      d: "M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z"
                    })
                  ])
                ], -1)),
                createBaseVNode("div", _hoisted_20$w, [
                  createBaseVNode("h3", _hoisted_21$w, toDisplayString$1(unref(t)("vocabulary.deleteAll.clearLocalStoreTitle", "Clear Local Store Data")), 1),
                  createBaseVNode("div", _hoisted_22$u, [
                    createBaseVNode("p", _hoisted_23$u, toDisplayString$1(unref(t)("vocabulary.deleteAll.clearLocalStoreMessage", "This will clear all data stored in your browser's local storage, including vocabulary words, practice sessions, and user preferences. This action cannot be undone.")), 1),
                    createBaseVNode("p", _hoisted_24$t, toDisplayString$1(unref(t)("vocabulary.deleteAll.pageReloadNotice", "Note: Page will automatically reload after clearing to ensure complete reset.")), 1),
                    createBaseVNode("div", _hoisted_25$t, [
                      createBaseVNode("p", _hoisted_26$r, toDisplayString$1(unref(t)("vocabulary.deleteAll.clearLocalStoreWarning", "Warning: This will remove all locally stored data and reset the application to its initial state.")), 1)
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_27$q, [
                createBaseVNode("button", {
                  onClick: confirmClearLocalStore,
                  type: "button",
                  class: "w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-orange-600 text-base font-medium text-white hover:bg-orange-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500 dark:focus:ring-offset-[#0a0a0a] sm:ml-3 sm:w-auto sm:text-sm transition-colors duration-200"
                }, toDisplayString$1(unref(t)("vocabulary.deleteAll.clearLocalStoreConfirm", "Clear All Data")), 1),
                createBaseVNode("button", {
                  onClick: _cache[3] || (_cache[3] = ($event) => showClearLocalStoreModal.value = false),
                  type: "button",
                  class: "mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 dark:border-dark-bg-mute shadow-sm px-4 py-2 bg-white dark:bg-dark-bg-soft text-base font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-dark-bg-mute focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:focus:ring-offset-[#0a0a0a] sm:mt-0 sm:w-auto sm:text-sm transition-colors duration-200"
                }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1)
              ])
            ])
          ])) : createCommentVNode("", true)
        ]))
      ]);
    };
  }
});

const DeleteAllVocabulariesPanel = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$W
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$V = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$S = { class: "w-full max-h-[90vh] flex flex-col max-w-full sm:max-w-lg md:max-w-2xl lg:max-w-4xl" };
const _hoisted_3$Q = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$O = { class: "flex items-center justify-between" };
const _hoisted_5$L = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$J = { class: "px-6 py-4 flex-1 overflow-y-auto min-h-0" };
const _hoisted_7$H = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_8$H = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_9$G = { value: "" };
const _hoisted_10$F = ["value"];
const _hoisted_11$F = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_12$E = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_13$E = { value: "" };
const _hoisted_14$E = { value: "multiple-choice" };
const _hoisted_15$z = { value: "fill-blank" };
const _hoisted_16$y = { value: "true-false" };
const _hoisted_17$x = { value: "short-answer" };
const _hoisted_18$w = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_19$w = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_20$v = ["placeholder"];
const _hoisted_21$v = {
  key: 0,
  class: "space-y-4 animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_22$t = { class: "flex items-center justify-between" };
const _hoisted_23$t = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 flex items-center" };
const _hoisted_24$s = { class: "flex items-center" };
const _hoisted_25$s = ["id", "value"];
const _hoisted_26$q = ["for"];
const _hoisted_27$p = ["onUpdate:modelValue", "placeholder"];
const _hoisted_28$p = ["onClick"];
const _hoisted_29$n = {
  key: 1,
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_30$m = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_31$l = ["value"];
const _hoisted_32$i = {
  key: 1,
  class: "mt-2 flex space-x-4"
};
const _hoisted_33$i = { class: "flex items-center" };
const _hoisted_34$h = { class: "ml-2 text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_35$h = { class: "flex items-center" };
const _hoisted_36$g = { class: "ml-2 text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_37$f = ["placeholder"];
const _hoisted_38$f = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_39$d = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_40$d = { value: "" };
const _hoisted_41$c = { value: "easy" };
const _hoisted_42$a = { value: "medium" };
const _hoisted_43$9 = { value: "hard" };
const _hoisted_44$9 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_45$8 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_46$8 = ["placeholder"];
const _hoisted_47$8 = { class: "flex items-center justify-end space-x-3 p-6 border-t border-gray-200 dark:border-gray-700 bg-gradient-to-r from-gray-50 to-white dark:from-[#0a0a0a] dark:to-[#0a0a0a] flex-shrink-0" };
const _hoisted_48$8 = ["disabled"];
const __default__$2 = {};
const _sfc_main$V = /* @__PURE__ */ defineComponent({
  ...__default__$2,
  ...{
    name: "QuestionFormDialog"
  },
  __name: "QuestionFormDialog",
  props: {
    show: { type: Boolean },
    question: {},
    vocabularyList: {}
  },
  emits: ["close", "save"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const formData = ref({
      vocabularyId: "",
      question: "",
      type: "multiple-choice",
      options: void 0,
      correctAnswer: "",
      difficulty: void 0,
      explanation: ""
    });
    const isFormValid = computed(() => {
      if (!formData.value.vocabularyId || !formData.value.question || !formData.value.type) {
        return false;
      }
      if (formData.value.type === "multiple-choice") {
        return formData.value.options?.every((opt) => opt.trim()) && formData.value.correctAnswer !== "" && formData.value.options?.length >= 2;
      }
      return formData.value.correctAnswer !== "";
    });
    const resetForm = () => {
      formData.value = {
        vocabularyId: "",
        question: "",
        type: "multiple-choice",
        options: void 0,
        correctAnswer: "",
        difficulty: void 0,
        explanation: ""
      };
    };
    const loadQuestion = () => {
      if (props.question) {
        formData.value = {
          vocabularyId: props.question.vocabularyId,
          question: props.question.question,
          type: props.question.type,
          options: props.question.options ? [...props.question.options] : ["", "", "", ""],
          correctAnswer: String(props.question.correctAnswer),
          difficulty: props.question.difficulty || "easy",
          explanation: props.question.explanation || ""
        };
      } else {
        resetForm();
      }
    };
    const onTypeChange = () => {
      if (formData.value.type === "multiple-choice") {
        formData.value.options = ["", "", "", ""];
      } else if (formData.value.type === "true-false") {
        formData.value.options = void 0;
        formData.value.correctAnswer = "true";
      } else {
        formData.value.options = void 0;
        formData.value.correctAnswer = "";
      }
    };
    const addOption = () => {
      if (formData.value.options && formData.value.options.length < 6) {
        formData.value.options.push("");
      }
    };
    const removeOption = (index) => {
      if (formData.value.options && formData.value.options.length > 2) {
        formData.value.options.splice(index, 1);
        const currentAnswerIndex = Number(formData.value.correctAnswer);
        if (currentAnswerIndex === index) {
          formData.value.correctAnswer = "";
        } else if (currentAnswerIndex > index) {
          formData.value.correctAnswer = String(currentAnswerIndex - 1);
        }
      }
    };
    const handleSubmit = () => {
      if (!isFormValid.value) return;
      const questionData = {
        vocabularyId: formData.value.vocabularyId,
        question: formData.value.question,
        type: formData.value.type,
        correctAnswer: formData.value.correctAnswer,
        difficulty: formData.value.difficulty,
        explanation: formData.value.explanation,
        options: formData.value.type === "multiple-choice" ? formData.value.options?.filter((opt) => opt.trim()) : void 0
      };
      emit("save", questionData);
    };
    const lockBodyScroll = () => {
      document.body.style.overflow = "hidden";
    };
    const unlockBodyScroll = () => {
      document.body.style.overflow = "";
    };
    watch(() => props.show, (newShow) => {
      if (newShow) {
        loadQuestion();
        lockBodyScroll();
      } else {
        unlockBodyScroll();
      }
    });
    watch(() => props.question, () => {
      if (props.show) {
        loadQuestion();
      }
    });
    onMounted(() => {
      if (props.show) {
        loadQuestion();
        lockBodyScroll();
      }
    });
    onUnmounted(() => {
      unlockBodyScroll();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$V, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$S, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 flex flex-col h-full overflow-hidden transform",
                      onClick: _cache[11] || (_cache[11] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$Q, [
                        createBaseVNode("div", _hoisted_4$O, [
                          createBaseVNode("h2", _hoisted_5$L, [
                            _cache[12] || (_cache[12] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(_ctx.question ? unref(t)("vocabulary.questions.editQuestion", "Edit Question") : unref(t)("vocabulary.questions.addQuestion", "Add New Question")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close")),
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[13] || (_cache[13] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_6$J, [
                        createBaseVNode("form", {
                          onSubmit: withModifiers(handleSubmit, ["prevent"]),
                          class: "space-y-6"
                        }, [
                          createBaseVNode("div", _hoisted_7$H, [
                            createBaseVNode("label", _hoisted_8$H, [
                              _cache[14] || (_cache[14] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.questions.selectVocabulary", "Select Vocabulary Word")) + " ", 1),
                              _cache[15] || (_cache[15] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                            ]),
                            withDirectives(createBaseVNode("select", {
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => formData.value.vocabularyId = $event),
                              required: "",
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 hover:border-blue-400 dark:hover:border-blue-500 transform hover:scale-[1.02]"
                            }, [
                              createBaseVNode("option", _hoisted_9$G, toDisplayString$1(unref(t)("vocabulary.questions.selectVocabularyPlaceholder", "Choose a vocabulary word...")), 1),
                              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.vocabularyList, (vocab) => {
                                return openBlock(), createElementBlock("option", {
                                  key: vocab.id,
                                  value: vocab.id
                                }, toDisplayString$1(vocab.word) + " - " + toDisplayString$1(vocab.meaning), 9, _hoisted_10$F);
                              }), 128))
                            ], 512), [
                              [vModelSelect, formData.value.vocabularyId]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_11$F, [
                            createBaseVNode("label", _hoisted_12$E, [
                              _cache[16] || (_cache[16] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.questions.questionType", "Question Type")) + " ", 1),
                              _cache[17] || (_cache[17] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                            ]),
                            withDirectives(createBaseVNode("select", {
                              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => formData.value.type = $event),
                              required: "",
                              onChange: onTypeChange,
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-300 hover:border-green-400 dark:hover:border-green-500 transform hover:scale-[1.02]"
                            }, [
                              createBaseVNode("option", _hoisted_13$E, toDisplayString$1(unref(t)("vocabulary.questions.selectType", "Select question type...")), 1),
                              createBaseVNode("option", _hoisted_14$E, toDisplayString$1(unref(t)("vocabulary.questions.types.multipleChoice", "Multiple Choice")), 1),
                              createBaseVNode("option", _hoisted_15$z, toDisplayString$1(unref(t)("vocabulary.questions.types.fillBlank", "Fill in the Blank")), 1),
                              createBaseVNode("option", _hoisted_16$y, toDisplayString$1(unref(t)("vocabulary.questions.types.trueFalse", "True/False")), 1),
                              createBaseVNode("option", _hoisted_17$x, toDisplayString$1(unref(t)("vocabulary.questions.types.shortAnswer", "Short Answer")), 1)
                            ], 544), [
                              [vModelSelect, formData.value.type]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_18$w, [
                            createBaseVNode("label", _hoisted_19$w, [
                              _cache[18] || (_cache[18] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.questions.questionText", "Question")) + " ", 1),
                              _cache[19] || (_cache[19] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                            ]),
                            withDirectives(createBaseVNode("textarea", {
                              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => formData.value.question = $event),
                              required: "",
                              rows: "3",
                              placeholder: unref(t)("vocabulary.questions.questionPlaceholder", "Enter your question..."),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-300 hover:border-purple-400 dark:hover:border-purple-500 transform hover:scale-[1.02] resize-none"
                            }, null, 8, _hoisted_20$v), [
                              [vModelText, formData.value.question]
                            ])
                          ]),
                          formData.value.type === "multiple-choice" ? (openBlock(), createElementBlock("div", _hoisted_21$v, [
                            createBaseVNode("div", _hoisted_22$t, [
                              createBaseVNode("label", _hoisted_23$t, [
                                _cache[20] || (_cache[20] = createBaseVNode("span", { class: "w-1 h-4 bg-orange-500 rounded mr-2" }, null, -1)),
                                createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.questions.options", "Answer Options")) + " ", 1),
                                _cache[21] || (_cache[21] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                              ]),
                              createBaseVNode("button", {
                                type: "button",
                                onClick: addOption,
                                class: "text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 text-sm font-medium transition-all duration-300 hover:scale-105"
                              }, " + " + toDisplayString$1(unref(t)("vocabulary.questions.addOption", "Add Option")), 1)
                            ]),
                            formData.value.options ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(formData.value.options, (option, index) => {
                              return openBlock(), createElementBlock("div", {
                                key: index,
                                class: "flex items-center space-x-3"
                              }, [
                                createBaseVNode("div", _hoisted_24$s, [
                                  withDirectives(createBaseVNode("input", {
                                    id: `option-${index}`,
                                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => formData.value.correctAnswer = $event),
                                    value: index,
                                    type: "radio",
                                    name: "correctAnswer",
                                    class: "w-4 h-4 text-blue-600 focus:ring-blue-500 border-gray-300 dark:border-gray-600"
                                  }, null, 8, _hoisted_25$s), [
                                    [vModelRadio, formData.value.correctAnswer]
                                  ]),
                                  createBaseVNode("label", {
                                    for: `option-${index}`,
                                    class: "ml-2 text-sm text-gray-700 dark:text-gray-300"
                                  }, toDisplayString$1(String.fromCharCode(65 + index)), 9, _hoisted_26$q)
                                ]),
                                withDirectives(createBaseVNode("input", {
                                  "onUpdate:modelValue": ($event) => formData.value.options[index] = $event,
                                  type: "text",
                                  placeholder: `${unref(t)("vocabulary.questions.optionPlaceholder", "Option")} ${String.fromCharCode(65 + index)}`,
                                  class: "flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 hover:border-blue-400 dark:hover:border-blue-500 transform hover:scale-[1.02]"
                                }, null, 8, _hoisted_27$p), [
                                  [vModelText, formData.value.options[index]]
                                ]),
                                formData.value.options && formData.value.options.length > 2 ? (openBlock(), createElementBlock("button", {
                                  key: 0,
                                  type: "button",
                                  onClick: ($event) => removeOption(index),
                                  class: "p-2 text-red-600 dark:text-red-400 hover:bg-red-50/50 dark:hover:bg-red-900/20 rounded-lg transition-all duration-300 hover:scale-110"
                                }, _cache[22] || (_cache[22] = [
                                  createBaseVNode("svg", {
                                    class: "w-4 h-4",
                                    fill: "none",
                                    stroke: "currentColor",
                                    viewBox: "0 0 24 24"
                                  }, [
                                    createBaseVNode("path", {
                                      "stroke-linecap": "round",
                                      "stroke-linejoin": "round",
                                      "stroke-width": "2",
                                      d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                                    })
                                  ], -1)
                                ]), 8, _hoisted_28$p)) : createCommentVNode("", true)
                              ]);
                            }), 128)) : createCommentVNode("", true)
                          ])) : createCommentVNode("", true),
                          formData.value.type && formData.value.type !== "multiple-choice" ? (openBlock(), createElementBlock("div", _hoisted_29$n, [
                            createBaseVNode("label", _hoisted_30$m, [
                              _cache[23] || (_cache[23] = createBaseVNode("span", { class: "w-1 h-4 bg-orange-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.questions.correctAnswer", "Correct Answer")) + " ", 1),
                              _cache[24] || (_cache[24] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                            ]),
                            formData.value.type === "true-false" ? (openBlock(), createElementBlock("input", {
                              key: 0,
                              value: formData.value.correctAnswer === "true" ? unref(t)("vocabulary.questions.true", "True") : unref(t)("vocabulary.questions.false", "False"),
                              type: "text",
                              readonly: "",
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50/50 dark:bg-[#0a0a0a]/50 text-gray-900 dark:text-white"
                            }, null, 8, _hoisted_31$l)) : createCommentVNode("", true),
                            formData.value.type === "true-false" ? (openBlock(), createElementBlock("div", _hoisted_32$i, [
                              createBaseVNode("label", _hoisted_33$i, [
                                withDirectives(createBaseVNode("input", {
                                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => formData.value.correctAnswer = $event),
                                  value: "true",
                                  type: "radio",
                                  name: "trueFalse",
                                  class: "w-4 h-4 text-blue-600 focus:ring-blue-500 border-gray-300 dark:border-gray-600"
                                }, null, 512), [
                                  [vModelRadio, formData.value.correctAnswer]
                                ]),
                                createBaseVNode("span", _hoisted_34$h, toDisplayString$1(unref(t)("vocabulary.questions.true", "True")), 1)
                              ]),
                              createBaseVNode("label", _hoisted_35$h, [
                                withDirectives(createBaseVNode("input", {
                                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => formData.value.correctAnswer = $event),
                                  value: "false",
                                  type: "radio",
                                  name: "trueFalse",
                                  class: "w-4 h-4 text-blue-600 focus:ring-blue-500 border-gray-300 dark:border-gray-600"
                                }, null, 512), [
                                  [vModelRadio, formData.value.correctAnswer]
                                ]),
                                createBaseVNode("span", _hoisted_36$g, toDisplayString$1(unref(t)("vocabulary.questions.false", "False")), 1)
                              ])
                            ])) : withDirectives((openBlock(), createElementBlock("input", {
                              key: 2,
                              "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => formData.value.correctAnswer = $event),
                              type: "text",
                              required: "",
                              placeholder: unref(t)("vocabulary.questions.correctAnswerPlaceholder", "Enter the correct answer..."),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all duration-300 hover:border-orange-400 dark:hover:border-orange-500 transform hover:scale-[1.02]"
                            }, null, 8, _hoisted_37$f)), [
                              [vModelText, formData.value.correctAnswer]
                            ])
                          ])) : createCommentVNode("", true),
                          createBaseVNode("div", _hoisted_38$f, [
                            createBaseVNode("label", _hoisted_39$d, [
                              _cache[25] || (_cache[25] = createBaseVNode("span", { class: "w-1 h-4 bg-yellow-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.questions.difficulty", "Difficulty")), 1)
                            ]),
                            withDirectives(createBaseVNode("select", {
                              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => formData.value.difficulty = $event),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent transition-all duration-300 hover:border-yellow-400 dark:hover:border-yellow-500 transform hover:scale-[1.02]"
                            }, [
                              createBaseVNode("option", _hoisted_40$d, toDisplayString$1(unref(t)("vocabulary.questions.selectDifficulty", "Select difficulty...")), 1),
                              createBaseVNode("option", _hoisted_41$c, toDisplayString$1(unref(t)("common.easy", "Easy")), 1),
                              createBaseVNode("option", _hoisted_42$a, toDisplayString$1(unref(t)("vocabulary.questions.difficulty.medium", "Medium")), 1),
                              createBaseVNode("option", _hoisted_43$9, toDisplayString$1(unref(t)("common.difficult", "Difficult")), 1)
                            ], 512), [
                              [vModelSelect, formData.value.difficulty]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_44$9, [
                            createBaseVNode("label", _hoisted_45$8, [
                              _cache[26] || (_cache[26] = createBaseVNode("span", { class: "w-1 h-4 bg-cyan-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.questions.explanation", "Explanation")), 1)
                            ]),
                            withDirectives(createBaseVNode("textarea", {
                              "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => formData.value.explanation = $event),
                              rows: "3",
                              placeholder: unref(t)("vocabulary.questions.explanationPlaceholder", "Optional explanation for the answer..."),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent transition-all duration-300 hover:border-cyan-400 dark:hover:border-cyan-500 transform hover:scale-[1.02] resize-none"
                            }, null, 8, _hoisted_46$8), [
                              [vModelText, formData.value.explanation]
                            ])
                          ])
                        ], 32)
                      ]),
                      createBaseVNode("div", _hoisted_47$8, [
                        createBaseVNode("button", {
                          onClick: _cache[10] || (_cache[10] = ($event) => _ctx.$emit("close")),
                          type: "button",
                          class: "px-4 py-2 text-gray-700 dark:text-gray-300 bg-white/50 dark:bg-[#0a0a0a]/50 hover:bg-gray-100/50 dark:hover:bg-[#0a0a0a]/70 border border-gray-300 dark:border-gray-600 rounded-lg font-medium transition-all duration-300 hover:scale-105 shadow-md hover:shadow-lg"
                        }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                        createBaseVNode("button", {
                          onClick: handleSubmit,
                          type: "submit",
                          disabled: !isFormValid.value,
                          class: "px-6 py-2 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 disabled:from-gray-400 disabled:to-gray-500 disabled:cursor-not-allowed text-white rounded-lg font-medium transition-all duration-300 hover:scale-105 shadow-lg hover:shadow-xl"
                        }, toDisplayString$1(_ctx.question ? unref(t)("common.update", "Update") : unref(t)("common.add", "Add")), 9, _hoisted_48$8)
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const QuestionFormDialog = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$V
}, Symbol.toStringTag, { value: 'Module' }));

const ExampleFormDialog$1 = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => ExampleFormDialog),true              ?void 0:void 0));
function useTopicGroupAccordion(props) {
  const { t } = useI18n();
  useVocabularyStore();
  const audioSystem = useAudioSystem();
  const { getTopicName } = useTopicName();
  const expandedGroups = ref({});
  const expandedVocabExamples = ref({});
  const examplePages = ref({});
  const examplesPerPage = ref(3);
  const currentPage = ref(1);
  const topicsPerPage = ref(3);
  const topicVocabPages = ref({});
  const topicVocabPerPage = ref(3);
  const playVocabularyAudio = (word) => audioSystem.playVocabularySound(word, "en");
  const playExampleAudio = (text) => audioSystem.playVocabularySound(text, "en");
  const loadExpandedState = () => {
    try {
      const saved = localStorage.getItem("vocabulary-examples-expanded-topics");
      if (saved) expandedGroups.value = { ...JSON.parse(saved) };
    } catch (error) {
      console.error("Error loading expanded state:", error);
    }
  };
  const saveExpandedState = () => {
    try {
      localStorage.setItem("vocabulary-examples-expanded-topics", JSON.stringify(expandedGroups.value));
    } catch (error) {
      console.error("Error saving expanded state:", error);
    }
  };
  const loadExpandedVocabExamplesState = () => {
    try {
      const saved = localStorage.getItem("vocabulary-examples-expanded-vocab-grouped");
      if (saved) expandedVocabExamples.value = { ...JSON.parse(saved) };
    } catch (error) {
      console.error("Error loading expanded vocabulary examples state:", error);
    }
  };
  const saveExpandedVocabExamplesState = () => {
    try {
      localStorage.setItem("vocabulary-examples-expanded-vocab-grouped", JSON.stringify(expandedVocabExamples.value));
    } catch (error) {
      console.error("Error saving expanded vocab examples state:", error);
    }
  };
  const loadExamplePagesState = () => {
    try {
      const saved = localStorage.getItem("vocabulary-examples-pages-grouped");
      if (saved) examplePages.value = { ...JSON.parse(saved) };
    } catch (error) {
      console.error("Error loading example pages state:", error);
    }
  };
  const saveExamplePagesState = () => {
    try {
      localStorage.setItem("vocabulary-examples-pages-grouped", JSON.stringify(examplePages.value));
    } catch (error) {
      console.error("Error saving example pages state:", error);
    }
  };
  const loadTopicVocabPagesState = () => {
    try {
      const saved = localStorage.getItem("vocabulary-topic-vocab-pages");
      if (saved) topicVocabPages.value = { ...JSON.parse(saved) };
    } catch (error) {
      console.error("Error loading topic vocab pages state:", error);
    }
  };
  const saveTopicVocabPagesState = () => {
    try {
      localStorage.setItem("vocabulary-topic-vocab-pages", JSON.stringify(topicVocabPages.value));
    } catch (error) {
      console.error("Error saving topic vocab pages state:", error);
    }
  };
  const allGroupedVocabulary = computed(() => {
    const groups = {};
    props.vocabularyList.forEach((vocab) => {
      const topicKey = vocab.category || "uncategorized";
      if (!groups[topicKey]) groups[topicKey] = [];
      groups[topicKey].push(vocab);
    });
    Object.keys(groups).forEach((key) => {
      groups[key].sort((a, b) => a.word.localeCompare(b.word));
    });
    return groups;
  });
  const groupedVocabulary = computed(() => {
    const allGroups = allGroupedVocabulary.value;
    const topicKeys = Object.keys(allGroups).sort((a, b) => a.localeCompare(b));
    const start = (currentPage.value - 1) * topicsPerPage.value;
    const end = start + topicsPerPage.value;
    const paginatedTopics = topicKeys.slice(start, end);
    const paginatedGroups = {};
    paginatedTopics.forEach((topicKey) => {
      paginatedGroups[topicKey] = allGroups[topicKey];
    });
    return paginatedGroups;
  });
  const paginationInfo = computed(() => {
    const totalTopics = Object.keys(allGroupedVocabulary.value).length;
    const totalPages = Math.ceil(totalTopics / topicsPerPage.value);
    const startIndex = (currentPage.value - 1) * topicsPerPage.value + 1;
    const endIndex = Math.min(currentPage.value * topicsPerPage.value, totalTopics);
    return {
      totalTopics,
      totalPages,
      currentPage: currentPage.value,
      startIndex,
      endIndex,
      hasNext: currentPage.value < totalPages,
      hasPrevious: currentPage.value > 1
    };
  });
  const visiblePages = computed(() => {
    const pages = [];
    const maxVisible = 5;
    const totalP = paginationInfo.value.totalPages;
    if (totalP <= maxVisible) {
      for (let i = 1; i <= totalP; i++) pages.push(i);
    } else {
      const start = Math.max(1, currentPage.value - Math.floor(maxVisible / 2));
      const end = Math.min(totalP, start + maxVisible - 1);
      for (let i = start; i <= end; i++) pages.push(i);
    }
    return pages;
  });
  const getVocabExamples = (vocabId) => props.examples.filter((e) => e.vocabularyId === vocabId);
  const getPaginatedVocabExamples = (vocabId) => {
    const allExamples = getVocabExamples(vocabId);
    const totalPages = Math.max(1, Math.ceil(allExamples.length / examplesPerPage.value));
    const current = Math.min(examplePages.value[vocabId] || 1, totalPages);
    const start = (current - 1) * examplesPerPage.value;
    return allExamples.slice(start, start + examplesPerPage.value);
  };
  const getPaginatedTopicVocabs = (topicKey) => {
    const group = allGroupedVocabulary.value[topicKey] || [];
    const current = topicVocabPages.value[topicKey] || 1;
    const start = (current - 1) * topicVocabPerPage.value;
    return group.slice(start, start + topicVocabPerPage.value);
  };
  const getTopicVocabPagesCount = (topicKey) => {
    const total = (allGroupedVocabulary.value[topicKey] || []).length;
    return Math.max(1, Math.ceil(total / topicVocabPerPage.value));
  };
  const getTopicVocabPaginationInfo = (topicKey) => {
    const totalVocab = (allGroupedVocabulary.value[topicKey] || []).length;
    const totalPages = Math.max(1, Math.ceil(totalVocab / topicVocabPerPage.value));
    const current = Math.min(topicVocabPages.value[topicKey] || 1, totalPages);
    const start = totalVocab === 0 ? 0 : (current - 1) * topicVocabPerPage.value + 1;
    const end = Math.min(current * topicVocabPerPage.value, totalVocab);
    return { totalVocab, totalPages, currentPage: current, start, end, hasNext: current < totalPages, hasPrevious: current > 1 };
  };
  const getVocabExamplePages = (vocabId) => Math.ceil(getVocabExamples(vocabId).length / examplesPerPage.value);
  const getExamplePaginationInfo = (vocabId) => {
    const totalExamples = getVocabExamples(vocabId).length;
    const totalPages = getVocabExamplePages(vocabId);
    const safeTotalPages = Math.max(1, totalPages);
    const current = Math.min(examplePages.value[vocabId] || 1, safeTotalPages);
    const start = (current - 1) * examplesPerPage.value + 1;
    const end = Math.min(current * examplesPerPage.value, totalExamples);
    return { totalExamples, totalPages, currentPage: current, start, end, hasNext: current < totalPages, hasPrevious: current > 1 };
  };
  const getVocabExampleCount = (vocabId) => props.examples.filter((e) => e.vocabularyId === vocabId).length;
  const getTotalExamplesForTopic = (group) => group.reduce((total, vocab) => total + getVocabExampleCount(vocab.id), 0);
  const getTopicVisiblePages = (topicKey) => {
    const pages = [];
    const maxVisible = 5;
    const totalP = getTopicVocabPagesCount(topicKey);
    const current = topicVocabPages.value[topicKey] || 1;
    if (totalP <= maxVisible) {
      for (let i = 1; i <= totalP; i++) pages.push(i);
    } else {
      const start = Math.max(1, current - Math.floor(maxVisible / 2));
      const end = Math.min(totalP, start + maxVisible - 1);
      for (let i = start; i <= end; i++) pages.push(i);
    }
    return pages;
  };
  const goToTopicVocabPage = (topicKey, page) => {
    const totalPages = getTopicVocabPagesCount(topicKey);
    if (page >= 1 && page <= totalPages) {
      topicVocabPages.value[topicKey] = page;
      saveTopicVocabPagesState();
    }
  };
  const previousTopicVocabPage = (topicKey) => {
    const current = topicVocabPages.value[topicKey] || 1;
    if (current > 1) goToTopicVocabPage(topicKey, current - 1);
  };
  const nextTopicVocabPage = (topicKey) => {
    const current = topicVocabPages.value[topicKey] || 1;
    const totalPages = getTopicVocabPagesCount(topicKey);
    if (current < totalPages) goToTopicVocabPage(topicKey, current + 1);
  };
  const goToExamplePage = (vocabId, page) => {
    const totalPages = getVocabExamplePages(vocabId);
    if (page >= 1 && page <= totalPages) {
      examplePages.value[vocabId] = page;
      saveExamplePagesState();
    }
  };
  const previousExamplePage = (vocabId) => {
    const current = examplePages.value[vocabId] || 1;
    if (current > 1) goToExamplePage(vocabId, current - 1);
  };
  const nextExamplePage = (vocabId) => {
    const current = examplePages.value[vocabId] || 1;
    const totalPages = getVocabExamplePages(vocabId);
    if (current < totalPages) goToExamplePage(vocabId, current + 1);
  };
  const goToPage = (page) => {
    if (page >= 1 && page <= paginationInfo.value.totalPages) currentPage.value = page;
  };
  const previousPage = () => {
    if (paginationInfo.value.hasPrevious) currentPage.value--;
  };
  const nextPage = () => {
    if (paginationInfo.value.hasNext) currentPage.value++;
  };
  const toggleGroup = (topicKey) => {
    expandedGroups.value[topicKey] = !expandedGroups.value[topicKey];
    saveExpandedState();
  };
  const toggleVocabExamples = (vocabId) => {
    expandedVocabExamples.value[vocabId] = !expandedVocabExamples.value[vocabId];
    saveExpandedVocabExamplesState();
  };
  const getTypeLabel = (type) => {
    const labels = {
      "sentence": t("vocabulary.examples.types.sentence", "Sentence"),
      "dialogue": t("vocabulary.examples.types.dialogue", "Dialogue"),
      "phrase": t("vocabulary.examples.types.phrase", "Phrase"),
      "context": t("vocabulary.examples.types.context", "Context")
    };
    return labels[type] || type;
  };
  const getTypeColorClass = (type) => {
    const classes = {
      "sentence": "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300",
      "dialogue": "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300",
      "phrase": "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300",
      "context": "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-300"
    };
    return classes[type] || "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300";
  };
  const getDifficultyLabel = (difficulty) => {
    const labels = {
      "easy": t("common.easy", "Easy"),
      "medium": t("vocabulary.examples.difficulty.medium", "Medium"),
      "hard": t("common.difficult", "Difficult")
    };
    return labels[difficulty] || difficulty;
  };
  const getDifficultyColorClass = (difficulty) => {
    const classes = {
      "easy": "text-green-600 dark:text-green-400",
      "medium": "text-yellow-600 dark:text-yellow-400",
      "hard": "text-red-600 dark:text-red-400"
    };
    return classes[difficulty] || "text-gray-600 dark:text-gray-400";
  };
  const enter = (el) => {
    const element = el;
    element.style.height = "0";
    element.style.overflow = "hidden";
  };
  const afterEnter = (el) => {
    const element = el;
    element.style.height = "auto";
    element.style.overflow = "visible";
  };
  const leave = (el) => {
    const element = el;
    element.style.height = element.scrollHeight + "px";
    element.style.overflow = "hidden";
    element.offsetHeight;
    element.style.height = "0";
  };
  const afterLeave = (el) => {
    const element = el;
    element.style.height = "auto";
    element.style.overflow = "visible";
  };
  const vocabExamplesEnter = (el) => {
    const element = el;
    element.style.height = "0";
    element.style.overflow = "hidden";
  };
  const vocabExamplesAfterEnter = (el) => {
    const element = el;
    element.style.height = "auto";
    element.style.overflow = "visible";
  };
  const vocabExamplesLeave = (el) => {
    const element = el;
    element.style.height = element.scrollHeight + "px";
    element.style.overflow = "hidden";
    element.offsetHeight;
    element.style.height = "0";
  };
  const vocabExamplesAfterLeave = (el) => {
    const element = el;
    element.style.height = "auto";
    element.style.overflow = "visible";
  };
  const deleteExample = (example, emit) => {
    emit("delete-example", example);
  };
  const initializeExpandedVocabExamplesState = () => {
    let examplesChanged = false, pagesChanged = false;
    Object.values(groupedVocabulary.value).forEach((group) => {
      group.forEach((vocab) => {
        if (expandedVocabExamples.value[vocab.id] === void 0) {
          expandedVocabExamples.value[vocab.id] = true;
          examplesChanged = true;
        }
        if (examplePages.value[vocab.id] === void 0) {
          examplePages.value[vocab.id] = 1;
          pagesChanged = true;
        }
      });
    });
    if (examplesChanged) saveExpandedVocabExamplesState();
    if (pagesChanged) saveExamplePagesState();
  };
  const initializeTopicVocabPagesState = () => {
    let changed = false;
    Object.keys(groupedVocabulary.value).forEach((topicKey) => {
      if (topicVocabPages.value[topicKey] === void 0) {
        topicVocabPages.value[topicKey] = 1;
        changed = true;
      }
    });
    if (changed) saveTopicVocabPagesState();
  };
  const initializeExpandedState = () => {
    const topicKeys = Object.keys(groupedVocabulary.value);
    let changed = false;
    topicKeys.forEach((key) => {
      if (expandedGroups.value[key] === void 0) {
        expandedGroups.value[key] = true;
        changed = true;
      }
    });
    if (changed) saveExpandedState();
  };
  const cleanupOldTopicStates = () => {
    try {
      const currentTopicKeys = new Set(Object.keys(allGroupedVocabulary.value));
      const expandedKeys = Object.keys(expandedGroups.value);
      let expandedChanged = false;
      expandedKeys.forEach((topicKey) => {
        if (!currentTopicKeys.has(topicKey)) {
          delete expandedGroups.value[topicKey];
          expandedChanged = true;
        }
      });
      const topicPageKeys = Object.keys(topicVocabPages.value);
      let topicPagesChanged = false;
      topicPageKeys.forEach((topicKey) => {
        if (!currentTopicKeys.has(topicKey)) {
          delete topicVocabPages.value[topicKey];
          topicPagesChanged = true;
        }
      });
      Object.keys(allGroupedVocabulary.value).forEach((topicKey) => {
        const totalPages = getTopicVocabPagesCount(topicKey);
        const current = topicVocabPages.value[topicKey] || 1;
        if (current > totalPages) {
          topicVocabPages.value[topicKey] = totalPages;
          topicPagesChanged = true;
        }
      });
      if (expandedChanged) saveExpandedState();
      if (topicPagesChanged) saveTopicVocabPagesState();
    } catch (error) {
      console.error("Error cleaning up old topic states:", error);
    }
  };
  const cleanupOldVocabularyStates = () => {
    try {
      const currentVocabIds = new Set(props.vocabularyList.map((v) => v.id));
      const expandedKeys = Object.keys(expandedVocabExamples.value);
      let expandedChanged = false;
      expandedKeys.forEach((vocabId) => {
        if (!currentVocabIds.has(vocabId)) {
          delete expandedVocabExamples.value[vocabId];
          expandedChanged = true;
        }
      });
      const pagesKeys = Object.keys(examplePages.value);
      let pagesChanged = false;
      pagesKeys.forEach((vocabId) => {
        if (!currentVocabIds.has(vocabId)) {
          delete examplePages.value[vocabId];
          pagesChanged = true;
        }
      });
      if (expandedChanged) saveExpandedVocabExamplesState();
      if (pagesChanged) saveExamplePagesState();
    } catch (error) {
      console.error("Error cleaning up old vocabulary states:", error);
    }
  };
  watch(() => groupedVocabulary.value, () => {
    initializeExpandedState();
    initializeExpandedVocabExamplesState();
    initializeTopicVocabPagesState();
  });
  watch(() => allGroupedVocabulary.value, () => cleanupOldTopicStates(), { deep: true });
  watch(() => props.vocabularyList, () => cleanupOldVocabularyStates(), { deep: true });
  watch(() => expandedGroups.value, () => saveExpandedState(), { deep: true });
  watch(() => expandedVocabExamples.value, () => saveExpandedVocabExamplesState(), { deep: true });
  watch(() => examplePages.value, () => saveExamplePagesState(), { deep: true });
  watch(() => topicVocabPages.value, () => saveTopicVocabPagesState(), { deep: true });
  onMounted(() => {
    loadExpandedState();
    loadExpandedVocabExamplesState();
    loadExamplePagesState();
    loadTopicVocabPagesState();
    initializeExpandedState();
    initializeExpandedVocabExamplesState();
    initializeTopicVocabPagesState();
    setTimeout(() => {
      cleanupOldTopicStates();
      cleanupOldVocabularyStates();
    }, 100);
  });
  return {
    // External dependencies
    ExampleFormDialog: ExampleFormDialog$1,
    getTopicName,
    t,
    // State
    expandedGroups,
    expandedVocabExamples,
    examplePages,
    examplesPerPage,
    currentPage,
    topicsPerPage,
    topicVocabPages,
    topicVocabPerPage,
    // Computed
    allGroupedVocabulary,
    groupedVocabulary,
    paginationInfo,
    visiblePages,
    // Audio
    playVocabularyAudio,
    playExampleAudio,
    // Data helpers
    getVocabExamples,
    getPaginatedVocabExamples,
    getPaginatedTopicVocabs,
    getTopicVocabPagesCount,
    getTopicVocabPaginationInfo,
    getVocabExamplePages,
    getExamplePaginationInfo,
    getVocabExampleCount,
    getTotalExamplesForTopic,
    getTopicVisiblePages,
    // Navigation
    goToTopicVocabPage,
    previousTopicVocabPage,
    nextTopicVocabPage,
    goToExamplePage,
    previousExamplePage,
    nextExamplePage,
    goToPage,
    previousPage,
    nextPage,
    // Toggle
    toggleGroup,
    toggleVocabExamples,
    // Styling
    getTypeLabel,
    getTypeColorClass,
    getDifficultyLabel,
    getDifficultyColorClass,
    // Animation
    enter,
    afterEnter,
    leave,
    afterLeave,
    vocabExamplesEnter,
    vocabExamplesAfterEnter,
    vocabExamplesLeave,
    vocabExamplesAfterLeave,
    // Actions
    deleteExample
  };
}

const _hoisted_1$U = { class: "space-y-4" };
const _hoisted_2$R = ["onClick"];
const _hoisted_3$P = { class: "flex items-center space-x-3" };
const _hoisted_4$N = { class: "text-lg font-bold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent" };
const _hoisted_5$K = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_6$I = { class: "flex items-center space-x-2" };
const _hoisted_7$G = { class: "text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_8$G = {
  key: 0,
  class: "accordion-content border-t border-gray-200/50 dark:border-gray-700/50"
};
const _hoisted_9$F = { class: "p-4 space-y-4" };
const _hoisted_10$E = ["onClick"];
const _hoisted_11$E = { class: "flex items-center space-x-3" };
const _hoisted_12$D = { class: "flex items-center space-x-2" };
const _hoisted_13$D = { class: "text-base font-bold text-gray-900 dark:text-white" };
const _hoisted_14$D = ["onClick", "title"];
const _hoisted_15$y = ["onClick", "title"];
const _hoisted_16$x = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_17$w = { class: "flex items-center space-x-2 mt-1" };
const _hoisted_18$v = { class: "inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800 dark:bg-blue-900/20 dark:text-blue-300" };
const _hoisted_19$v = { class: "text-xs text-gray-500 dark:text-gray-400" };
const _hoisted_20$u = ["onClick"];
const _hoisted_21$u = { class: "text-sm" };
const _hoisted_22$s = {
  key: 0,
  class: "vocab-examples-accordion-content space-y-2"
};
const _hoisted_23$s = {
  key: 0,
  class: "text-center py-3 text-gray-500 dark:text-gray-400"
};
const _hoisted_24$r = { class: "text-xs" };
const _hoisted_25$r = { class: "flex items-start justify-between" };
const _hoisted_26$p = { class: "flex-1" };
const _hoisted_27$o = { class: "flex items-center space-x-2 mb-2" };
const _hoisted_28$o = { class: "mb-2" };
const _hoisted_29$m = { class: "flex items-center justify-between" };
const _hoisted_30$l = { class: "text-gray-900 dark:text-white font-medium text-sm" };
const _hoisted_31$k = ["onClick", "title"];
const _hoisted_32$h = { class: "text-gray-700 dark:text-gray-300 mt-1 text-sm" };
const _hoisted_33$h = {
  key: 0,
  class: "text-gray-600 dark:text-gray-400 text-xs mt-1 italic"
};
const _hoisted_34$g = {
  key: 0,
  class: "flex flex-wrap gap-1"
};
const _hoisted_35$g = { class: "flex items-center gap-1.5 ml-3" };
const _hoisted_36$f = ["onClick"];
const _hoisted_37$e = ["onClick"];
const _hoisted_38$e = {
  key: 1,
  class: "border-t border-white/20 dark:border-white/10 px-3 py-2 mt-3"
};
const _hoisted_39$c = { class: "flex items-center justify-between" };
const _hoisted_40$c = { class: "flex sm:hidden items-center gap-2" };
const _hoisted_41$b = ["onClick", "disabled"];
const _hoisted_42$9 = { class: "text-xs text-slate-600 dark:text-slate-400" };
const _hoisted_43$8 = ["onClick", "disabled"];
const _hoisted_44$8 = { class: "hidden sm:flex items-center gap-2" };
const _hoisted_45$7 = ["onClick", "disabled"];
const _hoisted_46$7 = { class: "flex gap-1" };
const _hoisted_47$7 = ["onClick"];
const _hoisted_48$7 = ["onClick", "disabled"];
const _hoisted_49$7 = { class: "text-xs text-slate-500 dark:text-slate-400" };
const _hoisted_50$7 = {
  key: 0,
  class: "border-t border-white/20 dark:border-white/10 px-3 py-2"
};
const _hoisted_51$6 = { class: "flex items-center justify-between" };
const _hoisted_52$6 = { class: "flex sm:hidden items-center gap-2" };
const _hoisted_53$6 = ["onClick", "disabled"];
const _hoisted_54$6 = { class: "text-xs text-slate-600 dark:text-slate-400" };
const _hoisted_55$6 = ["onClick", "disabled"];
const _hoisted_56$6 = { class: "hidden sm:flex items-center gap-2" };
const _hoisted_57$6 = ["onClick", "disabled"];
const _hoisted_58$6 = { class: "flex gap-1" };
const _hoisted_59$5 = ["onClick"];
const _hoisted_60$5 = ["onClick", "disabled"];
const _hoisted_61$5 = { class: "text-xs text-slate-500 dark:text-slate-400" };
const _hoisted_62$5 = {
  key: 0,
  class: "mt-6 group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-4"
};
const _hoisted_63$3 = { class: "flex items-center justify-between" };
const _hoisted_64$3 = { class: "flex-1 flex justify-between sm:hidden" };
const _hoisted_65$3 = ["disabled"];
const _hoisted_66$3 = ["disabled"];
const _hoisted_67$3 = { class: "hidden sm:flex-1 sm:flex sm:items-center sm:justify-between" };
const _hoisted_68$3 = { class: "text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_69$3 = { class: "relative z-0 inline-flex rounded-md shadow-sm -space-x-px" };
const _hoisted_70$3 = ["disabled"];
const _hoisted_71$3 = { class: "sr-only" };
const _hoisted_72$3 = ["onClick"];
const _hoisted_73$3 = ["disabled"];
const _hoisted_74$3 = { class: "sr-only" };
const __default__$1 = {
  name: "TopicGroupAccordion"
};
const _sfc_main$U = /* @__PURE__ */ defineComponent({
  ...__default__$1,
  props: {
    vocabularyList: {},
    examples: {}
  },
  emits: ["add-example", "edit-example", "delete-example"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const {
      getTopicName,
      t,
      expandedGroups,
      expandedVocabExamples,
      currentPage,
      groupedVocabulary,
      paginationInfo,
      visiblePages,
      playVocabularyAudio,
      playExampleAudio,
      getVocabExamples,
      getPaginatedVocabExamples,
      getPaginatedTopicVocabs,
      getTopicVocabPagesCount,
      getTopicVocabPaginationInfo,
      getVocabExamplePages,
      getExamplePaginationInfo,
      getVocabExampleCount,
      getTotalExamplesForTopic,
      getTopicVisiblePages,
      goToTopicVocabPage,
      previousTopicVocabPage,
      nextTopicVocabPage,
      goToExamplePage,
      previousExamplePage,
      nextExamplePage,
      goToPage,
      previousPage,
      nextPage,
      toggleGroup,
      toggleVocabExamples,
      getTypeLabel,
      getTypeColorClass,
      getDifficultyLabel,
      getDifficultyColorClass,
      enter,
      afterEnter,
      leave,
      afterLeave,
      vocabExamplesEnter,
      vocabExamplesAfterEnter,
      vocabExamplesLeave,
      vocabExamplesAfterLeave,
      deleteExample
    } = useTopicGroupAccordion(props);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$U, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(groupedVocabulary), (group, topicKey) => {
          return openBlock(), createElementBlock("div", {
            key: topicKey,
            class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.002]"
          }, [
            createBaseVNode("div", {
              onClick: ($event) => unref(toggleGroup)(topicKey),
              class: "flex items-center justify-between p-4 cursor-pointer hover:bg-white/20 dark:hover:bg-[#0a0a0a]/20 rounded-t-2xl transition-all duration-300"
            }, [
              createBaseVNode("div", _hoisted_3$P, [
                _cache[4] || (_cache[4] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                  createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-purple-500 rounded-full" })
                ], -1)),
                createBaseVNode("div", null, [
                  createBaseVNode("h3", _hoisted_4$N, toDisplayString$1(unref(getTopicName)(topicKey)), 1),
                  createBaseVNode("p", _hoisted_5$K, toDisplayString$1(group.length) + " " + toDisplayString$1(group.length === 1 ? unref(t)("vocabulary.word", "word") : unref(t)("vocabulary.words", "words")), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_6$I, [
                createBaseVNode("span", _hoisted_7$G, toDisplayString$1(unref(getTotalExamplesForTopic)(group)) + " " + toDisplayString$1(unref(t)("vocabulary.examples.examples", "examples")), 1),
                (openBlock(), createElementBlock("svg", {
                  class: normalizeClass(["w-5 h-5 text-gray-500 dark:text-gray-400 transition-transform duration-300", { "rotate-180": unref(expandedGroups)[topicKey] }]),
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, _cache[5] || (_cache[5] = [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M19 9l-7 7-7-7"
                  }, null, -1)
                ]), 2))
              ])
            ], 8, _hoisted_2$R),
            createVNode(Transition, {
              name: "accordion",
              onEnter: unref(enter),
              onAfterEnter: unref(afterEnter),
              onLeave: unref(leave),
              onAfterLeave: unref(afterLeave)
            }, {
              default: withCtx(() => [
                unref(expandedGroups)[topicKey] ? (openBlock(), createElementBlock("div", _hoisted_8$G, [
                  createBaseVNode("div", _hoisted_9$F, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(getPaginatedTopicVocabs)(topicKey), (vocab) => {
                      return openBlock(), createElementBlock("div", {
                        key: vocab.id,
                        class: "bg-white/60 dark:bg-[#0a0a0a]/60 backdrop-blur-sm rounded-xl border border-white/20 dark:border-white/10 p-4 hover:shadow-lg transition-all duration-300"
                      }, [
                        createBaseVNode("div", {
                          onClick: ($event) => unref(toggleVocabExamples)(vocab.id),
                          class: "flex items-center justify-between mb-3 pb-2 border-b border-gray-200/30 dark:border-gray-700/30 cursor-pointer"
                        }, [
                          createBaseVNode("div", _hoisted_11$E, [
                            _cache[8] || (_cache[8] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                              createBaseVNode("div", { class: "w-2 h-2 bg-gradient-to-r from-green-400 to-blue-500 rounded-full" })
                            ], -1)),
                            createBaseVNode("div", null, [
                              createBaseVNode("div", _hoisted_12$D, [
                                createBaseVNode("h4", _hoisted_13$D, toDisplayString$1(vocab.word), 1),
                                createBaseVNode("button", {
                                  onClick: withModifiers(($event) => unref(playVocabularyAudio)(vocab.word), ["stop"]),
                                  class: "p-1 text-blue-600 hover:text-blue-700 hover:bg-blue-50/50 dark:text-blue-400 dark:hover:text-blue-300 dark:hover:bg-blue-900/20 rounded transition-all duration-300 group",
                                  title: unref(t)("vocabulary.examples.playPronunciation", "Play pronunciation")
                                }, _cache[6] || (_cache[6] = [
                                  createBaseVNode("svg", {
                                    class: "w-3.5 h-3.5 group-hover:scale-110 transition-transform duration-200",
                                    fill: "none",
                                    stroke: "currentColor",
                                    viewBox: "0 0 24 24"
                                  }, [
                                    createBaseVNode("path", {
                                      "stroke-linecap": "round",
                                      "stroke-linejoin": "round",
                                      "stroke-width": "2",
                                      d: "M15.536 8.464a5 5 0 010 7.072m2.464-9.536a9 9 0 010 12.728M9 9l3-3v6l-3-3H4a1 1 0 01-1-1V10a1 1 0 011-1h5z"
                                    })
                                  ], -1)
                                ]), 8, _hoisted_14$D),
                                createBaseVNode("button", {
                                  onClick: withModifiers(($event) => unref(toggleVocabExamples)(vocab.id), ["stop"]),
                                  class: "p-1 text-gray-600 hover:text-gray-700 hover:bg-gray-50/50 dark:text-gray-400 dark:hover:text-gray-300 dark:hover:bg-[#0a0a0a]/20 rounded transition-all duration-300 group",
                                  title: unref(expandedVocabExamples)[vocab.id] ? unref(t)("vocabulary.examples.hideExamples", "Hide examples") : unref(t)("vocabulary.examples.showExamples", "Show examples")
                                }, [
                                  (openBlock(), createElementBlock("svg", {
                                    class: normalizeClass(["w-3.5 h-3.5 group-hover:scale-110 transition-all duration-200", { "rotate-180": unref(expandedVocabExamples)[vocab.id] }]),
                                    fill: "none",
                                    stroke: "currentColor",
                                    viewBox: "0 0 24 24"
                                  }, _cache[7] || (_cache[7] = [
                                    createBaseVNode("path", {
                                      "stroke-linecap": "round",
                                      "stroke-linejoin": "round",
                                      "stroke-width": "2",
                                      d: "M19 9l-7 7-7-7"
                                    }, null, -1)
                                  ]), 2))
                                ], 8, _hoisted_15$y)
                              ]),
                              createBaseVNode("p", _hoisted_16$x, toDisplayString$1(vocab.meaning), 1),
                              createBaseVNode("div", _hoisted_17$w, [
                                createBaseVNode("span", _hoisted_18$v, toDisplayString$1(vocab.partOfSpeech), 1),
                                createBaseVNode("span", _hoisted_19$v, toDisplayString$1(unref(getVocabExampleCount)(vocab.id)) + " " + toDisplayString$1(unref(getVocabExampleCount)(vocab.id) === 1 ? "example" : "examples"), 1)
                              ])
                            ])
                          ]),
                          createBaseVNode("button", {
                            onClick: withModifiers(($event) => _ctx.$emit("add-example", vocab), ["stop"]),
                            class: "px-3 py-1.5 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 text-white rounded-lg font-medium transition-all duration-300 shadow-lg hover:shadow-xl flex items-center space-x-1.5"
                          }, [
                            _cache[9] || (_cache[9] = createBaseVNode("svg", {
                              class: "w-3.5 h-3.5",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M12 4v16m8-8H4"
                              })
                            ], -1)),
                            createBaseVNode("span", _hoisted_21$u, toDisplayString$1(unref(t)("vocabulary.examples.addExample", "Add Example")), 1)
                          ], 8, _hoisted_20$u)
                        ], 8, _hoisted_10$E),
                        createVNode(Transition, {
                          name: "vocab-examples-accordion",
                          onEnter: unref(vocabExamplesEnter),
                          onAfterEnter: unref(vocabExamplesAfterEnter),
                          onLeave: unref(vocabExamplesLeave),
                          onAfterLeave: unref(vocabExamplesAfterLeave)
                        }, {
                          default: withCtx(() => [
                            unref(expandedVocabExamples)[vocab.id] ? (openBlock(), createElementBlock("div", _hoisted_22$s, [
                              unref(getVocabExamples)(vocab.id).length === 0 ? (openBlock(), createElementBlock("div", _hoisted_23$s, [
                                _cache[10] || (_cache[10] = createBaseVNode("svg", {
                                  class: "mx-auto h-6 w-6 text-gray-400 mb-1",
                                  fill: "none",
                                  stroke: "currentColor",
                                  viewBox: "0 0 24 24"
                                }, [
                                  createBaseVNode("path", {
                                    "stroke-linecap": "round",
                                    "stroke-linejoin": "round",
                                    "stroke-width": "2",
                                    d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                                  })
                                ], -1)),
                                createBaseVNode("p", _hoisted_24$r, toDisplayString$1(unref(t)("vocabulary.examples.noExamplesForWord", "No examples yet")), 1)
                              ])) : createCommentVNode("", true),
                              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(getPaginatedVocabExamples)(vocab.id), (example) => {
                                return openBlock(), createElementBlock("div", {
                                  key: example.id,
                                  class: "bg-white/40 dark:bg-[#0a0a0a]/40 backdrop-blur-sm rounded-lg border border-white/20 dark:border-white/10 p-3 hover:shadow-md transition-all duration-300"
                                }, [
                                  createBaseVNode("div", _hoisted_25$r, [
                                    createBaseVNode("div", _hoisted_26$p, [
                                      createBaseVNode("div", _hoisted_27$o, [
                                        createBaseVNode("span", {
                                          class: normalizeClass(["inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium", unref(getTypeColorClass)(example.type)])
                                        }, toDisplayString$1(unref(getTypeLabel)(example.type)), 3),
                                        example.difficulty ? (openBlock(), createElementBlock("span", {
                                          key: 0,
                                          class: normalizeClass(["text-sm", unref(getDifficultyColorClass)(example.difficulty)])
                                        }, toDisplayString$1(unref(getDifficultyLabel)(example.difficulty)), 3)) : createCommentVNode("", true)
                                      ]),
                                      createBaseVNode("div", _hoisted_28$o, [
                                        createBaseVNode("div", _hoisted_29$m, [
                                          createBaseVNode("p", _hoisted_30$l, toDisplayString$1(example.title), 1),
                                          createBaseVNode("button", {
                                            onClick: ($event) => unref(playExampleAudio)(example.content),
                                            class: "p-1 text-green-600 hover:text-green-700 hover:bg-green-50/50 dark:text-green-400 dark:hover:text-green-300 dark:hover:bg-green-900/20 rounded transition-all duration-300 group",
                                            title: unref(t)("vocabulary.examples.playExample", "Play example")
                                          }, _cache[11] || (_cache[11] = [
                                            createBaseVNode("svg", {
                                              class: "w-3 h-3 group-hover:scale-110 transition-transform duration-200",
                                              fill: "none",
                                              stroke: "currentColor",
                                              viewBox: "0 0 24 24"
                                            }, [
                                              createBaseVNode("path", {
                                                "stroke-linecap": "round",
                                                "stroke-linejoin": "round",
                                                "stroke-width": "2",
                                                d: "M15.536 8.464a5 5 0 010 7.072m2.464-9.536a9 9 0 010 12.728M9 9l3-3v6l-3-3H4a1 1 0 01-1-1V10a1 1 0 011-1h5z"
                                              })
                                            ], -1)
                                          ]), 8, _hoisted_31$k)
                                        ]),
                                        createBaseVNode("p", _hoisted_32$h, toDisplayString$1(example.content), 1),
                                        example.translation ? (openBlock(), createElementBlock("p", _hoisted_33$h, toDisplayString$1(example.translation), 1)) : createCommentVNode("", true)
                                      ]),
                                      example.tags && example.tags.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_34$g, [
                                        (openBlock(true), createElementBlock(Fragment, null, renderList(example.tags, (tag) => {
                                          return openBlock(), createElementBlock("span", {
                                            key: tag,
                                            class: "inline-flex items-center px-1.5 py-0.5 rounded text-xs bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300"
                                          }, toDisplayString$1(tag), 1);
                                        }), 128))
                                      ])) : createCommentVNode("", true)
                                    ]),
                                    createBaseVNode("div", _hoisted_35$g, [
                                      createBaseVNode("button", {
                                        onClick: ($event) => _ctx.$emit("edit-example", example),
                                        class: "px-2 py-1.5 text-blue-600 hover:text-blue-700 hover:bg-blue-50/50 dark:text-blue-400 dark:hover:text-blue-300 dark:hover:bg-blue-900/20 rounded-md transition-all duration-300 text-sm"
                                      }, toDisplayString$1(unref(t)("common.edit", "Edit")), 9, _hoisted_36$f),
                                      createBaseVNode("button", {
                                        onClick: ($event) => unref(deleteExample)(example, emit),
                                        class: "px-2 py-1.5 text-red-600 hover:text-red-700 hover:bg-red-50/50 dark:text-red-400 dark:hover:text-red-300 dark:hover:bg-red-900/20 rounded-md transition-all duration-300 text-sm"
                                      }, toDisplayString$1(unref(t)("common.delete", "Delete")), 9, _hoisted_37$e)
                                    ])
                                  ])
                                ]);
                              }), 128)),
                              unref(getVocabExamplePages)(vocab.id) > 1 ? (openBlock(), createElementBlock("div", _hoisted_38$e, [
                                createBaseVNode("div", _hoisted_39$c, [
                                  createBaseVNode("div", _hoisted_40$c, [
                                    createBaseVNode("button", {
                                      onClick: ($event) => unref(previousExamplePage)(vocab.id),
                                      disabled: !unref(getExamplePaginationInfo)(vocab.id).hasPrevious,
                                      class: "px-2 py-1 text-xs bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                    }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_41$b),
                                    createBaseVNode("span", _hoisted_42$9, toDisplayString$1(unref(getExamplePaginationInfo)(vocab.id).currentPage) + " / " + toDisplayString$1(unref(getExamplePaginationInfo)(vocab.id).totalPages), 1),
                                    createBaseVNode("button", {
                                      onClick: ($event) => unref(nextExamplePage)(vocab.id),
                                      disabled: !unref(getExamplePaginationInfo)(vocab.id).hasNext,
                                      class: "px-2 py-1 text-xs bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                    }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_43$8)
                                  ]),
                                  createBaseVNode("div", _hoisted_44$8, [
                                    createBaseVNode("button", {
                                      onClick: ($event) => unref(previousExamplePage)(vocab.id),
                                      disabled: !unref(getExamplePaginationInfo)(vocab.id).hasPrevious,
                                      class: "px-3 py-1.5 text-sm bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                    }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_45$7),
                                    createBaseVNode("div", _hoisted_46$7, [
                                      (openBlock(true), createElementBlock(Fragment, null, renderList(Math.min(unref(getExamplePaginationInfo)(vocab.id).totalPages, 5), (page) => {
                                        return openBlock(), createElementBlock("button", {
                                          key: page,
                                          onClick: ($event) => unref(goToExamplePage)(vocab.id, page),
                                          class: normalizeClass([
                                            "px-3 py-1.5 text-sm rounded transition-colors",
                                            unref(getExamplePaginationInfo)(vocab.id).currentPage === page ? "bg-blue-600 text-white" : "bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600"
                                          ])
                                        }, toDisplayString$1(page), 11, _hoisted_47$7);
                                      }), 128))
                                    ]),
                                    createBaseVNode("button", {
                                      onClick: ($event) => unref(nextExamplePage)(vocab.id),
                                      disabled: !unref(getExamplePaginationInfo)(vocab.id).hasNext,
                                      class: "px-3 py-1.5 text-sm bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                    }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_48$7)
                                  ]),
                                  createBaseVNode("div", _hoisted_49$7, toDisplayString$1(unref(t)("vocabulary.examples.showingExamples", { start: unref(getExamplePaginationInfo)(vocab.id).start, end: unref(getExamplePaginationInfo)(vocab.id).end, total: unref(getExamplePaginationInfo)(vocab.id).totalExamples }, "Showing {start} to {end} of {total} examples")), 1)
                                ])
                              ])) : createCommentVNode("", true)
                            ])) : createCommentVNode("", true)
                          ]),
                          _: 2
                        }, 1032, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])
                      ]);
                    }), 128)),
                    unref(getTopicVocabPagesCount)(topicKey) > 1 ? (openBlock(), createElementBlock("div", _hoisted_50$7, [
                      createBaseVNode("div", _hoisted_51$6, [
                        createBaseVNode("div", _hoisted_52$6, [
                          createBaseVNode("button", {
                            onClick: ($event) => unref(previousTopicVocabPage)(topicKey),
                            disabled: !unref(getTopicVocabPaginationInfo)(topicKey).hasPrevious,
                            class: "px-2 py-1 text-xs bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                          }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_53$6),
                          createBaseVNode("span", _hoisted_54$6, toDisplayString$1(unref(getTopicVocabPaginationInfo)(topicKey).currentPage) + " / " + toDisplayString$1(unref(getTopicVocabPaginationInfo)(topicKey).totalPages), 1),
                          createBaseVNode("button", {
                            onClick: ($event) => unref(nextTopicVocabPage)(topicKey),
                            disabled: !unref(getTopicVocabPaginationInfo)(topicKey).hasNext,
                            class: "px-2 py-1 text-xs bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                          }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_55$6)
                        ]),
                        createBaseVNode("div", _hoisted_56$6, [
                          createBaseVNode("button", {
                            onClick: ($event) => unref(previousTopicVocabPage)(topicKey),
                            disabled: !unref(getTopicVocabPaginationInfo)(topicKey).hasPrevious,
                            class: "px-3 py-1.5 text-sm bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                          }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_57$6),
                          createBaseVNode("div", _hoisted_58$6, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(getTopicVisiblePages)(topicKey), (page) => {
                              return openBlock(), createElementBlock("button", {
                                key: page,
                                onClick: ($event) => unref(goToTopicVocabPage)(topicKey, page),
                                class: normalizeClass([
                                  "px-3 py-1.5 text-sm rounded transition-colors",
                                  unref(getTopicVocabPaginationInfo)(topicKey).currentPage === page ? "bg-blue-600 text-white" : "bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600"
                                ])
                              }, toDisplayString$1(page), 11, _hoisted_59$5);
                            }), 128))
                          ]),
                          createBaseVNode("button", {
                            onClick: ($event) => unref(nextTopicVocabPage)(topicKey),
                            disabled: !unref(getTopicVocabPaginationInfo)(topicKey).hasNext,
                            class: "px-3 py-1.5 text-sm bg-slate-200 dark:bg-dark-bg-mute text-slate-700 dark:text-slate-300 rounded disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                          }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_60$5)
                        ]),
                        createBaseVNode("div", _hoisted_61$5, toDisplayString$1(unref(t)("vocabulary.examples.showingVocabulary", { start: unref(getTopicVocabPaginationInfo)(topicKey).start, end: unref(getTopicVocabPaginationInfo)(topicKey).end, total: unref(getTopicVocabPaginationInfo)(topicKey).totalVocab }, "Showing {start} to {end} of {total} words")), 1)
                      ])
                    ])) : createCommentVNode("", true)
                  ])
                ])) : createCommentVNode("", true)
              ]),
              _: 2
            }, 1032, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])
          ]);
        }), 128)),
        unref(paginationInfo).totalPages > 1 ? (openBlock(), createElementBlock("div", _hoisted_62$5, [
          createBaseVNode("div", _hoisted_63$3, [
            createBaseVNode("div", _hoisted_64$3, [
              createBaseVNode("button", {
                onClick: _cache[0] || (_cache[0] = //@ts-ignore
                (...args) => unref(previousPage) && unref(previousPage)(...args)),
                disabled: !unref(paginationInfo).hasPrevious,
                class: "relative inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
              }, toDisplayString$1(unref(t)("common.previous", "Previous")), 9, _hoisted_65$3),
              createBaseVNode("button", {
                onClick: _cache[1] || (_cache[1] = //@ts-ignore
                (...args) => unref(nextPage) && unref(nextPage)(...args)),
                disabled: !unref(paginationInfo).hasNext,
                class: "ml-3 relative inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
              }, toDisplayString$1(unref(t)("common.next", "Next")), 9, _hoisted_66$3)
            ]),
            createBaseVNode("div", _hoisted_67$3, [
              createBaseVNode("div", null, [
                createBaseVNode("p", _hoisted_68$3, toDisplayString$1(unref(t)("vocabulary.examples.showingTopics", {
                  start: unref(paginationInfo).startIndex,
                  end: unref(paginationInfo).endIndex,
                  total: unref(paginationInfo).totalTopics
                }, `Showing ${unref(paginationInfo).startIndex} to ${unref(paginationInfo).endIndex} of ${unref(paginationInfo).totalTopics} topics`)), 1)
              ]),
              createBaseVNode("nav", _hoisted_69$3, [
                createBaseVNode("button", {
                  onClick: _cache[2] || (_cache[2] = //@ts-ignore
                  (...args) => unref(previousPage) && unref(previousPage)(...args)),
                  disabled: !unref(paginationInfo).hasPrevious,
                  class: "relative inline-flex items-center px-2 py-2 rounded-l-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                }, [
                  createBaseVNode("span", _hoisted_71$3, toDisplayString$1(unref(t)("common.previous", "Previous")), 1),
                  _cache[12] || (_cache[12] = createBaseVNode("svg", {
                    class: "h-5 w-5",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                      "clip-rule": "evenodd"
                    })
                  ], -1))
                ], 8, _hoisted_70$3),
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(visiblePages), (page) => {
                  return openBlock(), createElementBlock("button", {
                    key: page,
                    onClick: ($event) => unref(goToPage)(page),
                    class: normalizeClass([
                      page === unref(currentPage) ? "z-10 bg-blue-50 dark:bg-blue-900 border-blue-500 dark:border-blue-400 text-blue-600 dark:text-blue-300" : "bg-white dark:bg-[#0a0a0a] border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600",
                      "relative inline-flex items-center px-4 py-2 border text-sm font-medium"
                    ])
                  }, toDisplayString$1(page), 11, _hoisted_72$3);
                }), 128)),
                createBaseVNode("button", {
                  onClick: _cache[3] || (_cache[3] = //@ts-ignore
                  (...args) => unref(nextPage) && unref(nextPage)(...args)),
                  disabled: !unref(paginationInfo).hasNext,
                  class: "relative inline-flex items-center px-2 py-2 rounded-r-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-sm font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                }, [
                  createBaseVNode("span", _hoisted_74$3, toDisplayString$1(unref(t)("common.next", "Next")), 1),
                  _cache[13] || (_cache[13] = createBaseVNode("svg", {
                    class: "h-5 w-5",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                      "clip-rule": "evenodd"
                    })
                  ], -1))
                ], 8, _hoisted_73$3)
              ])
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const TopicGroupAccordion = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["__scopeId", "data-v-8a43d51e"]]);

const TopicGroupAccordion$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: TopicGroupAccordion
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$T = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$Q = { class: "w-full max-h-[90vh] flex flex-col max-w-full sm:max-w-lg md:max-w-2xl lg:max-w-4xl" };
const _hoisted_3$O = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-green-50 to-emerald-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$M = { class: "flex items-center justify-between" };
const _hoisted_5$J = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$H = {
  key: 0,
  class: "mt-2 flex items-center space-x-2 text-sm text-gray-600 dark:text-gray-300"
};
const _hoisted_7$F = { class: "font-medium text-green-600 dark:text-green-400" };
const _hoisted_8$F = { class: "font-semibold" };
const _hoisted_9$E = { class: "px-6 py-4 flex-1 overflow-y-auto min-h-0" };
const _hoisted_10$D = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_11$D = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_12$C = { value: "" };
const _hoisted_13$C = { value: "sentence" };
const _hoisted_14$C = { value: "dialogue" };
const _hoisted_15$x = { value: "phrase" };
const _hoisted_16$w = { value: "context" };
const _hoisted_17$v = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_18$u = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_19$u = ["placeholder"];
const _hoisted_20$t = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_21$t = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_22$r = ["placeholder"];
const _hoisted_23$r = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_24$q = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_25$q = ["placeholder"];
const _hoisted_26$o = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_27$n = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_28$n = ["placeholder"];
const _hoisted_29$l = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_30$k = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_31$j = { value: "" };
const _hoisted_32$g = { value: "easy" };
const _hoisted_33$g = { value: "medium" };
const _hoisted_34$f = { value: "hard" };
const _hoisted_35$f = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.8s" }
};
const _hoisted_36$e = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_37$d = { class: "space-y-3" };
const _hoisted_38$d = ["placeholder", "onKeydown"];
const _hoisted_39$b = {
  key: 0,
  class: "flex flex-wrap gap-2"
};
const _hoisted_40$b = ["onClick"];
const _hoisted_41$a = { class: "flex items-center justify-end space-x-3 p-6 border-t border-gray-200 dark:border-gray-700 bg-gradient-to-r from-gray-50 to-white dark:from-[#0a0a0a] dark:to-[#0a0a0a] flex-shrink-0" };
const _hoisted_42$8 = ["disabled"];
const __default__ = {};
const _sfc_main$T = /* @__PURE__ */ defineComponent({
  ...__default__,
  ...{
    name: "ExampleFormDialog"
  },
  __name: "ExampleFormDialog",
  props: {
    show: { type: Boolean },
    example: {},
    vocabularyId: {},
    vocabularyList: {}
  },
  emits: ["close", "save"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const formData = ref({
      vocabularyId: "",
      title: "",
      content: "",
      translation: "",
      context: "",
      type: "sentence",
      difficulty: "easy",
      tags: []
    });
    const tagInput = ref("");
    const selectedVocab = computed(() => {
      return props.vocabularyList.find((v) => v.id === formData.value.vocabularyId);
    });
    const isFormValid = computed(() => {
      return formData.value.vocabularyId && formData.value.title.trim() && formData.value.content.trim() && formData.value.type;
    });
    const resetForm = () => {
      formData.value = {
        vocabularyId: props.vocabularyId || "",
        title: "",
        content: "",
        translation: "",
        context: "",
        type: "sentence",
        difficulty: "easy",
        tags: []
      };
      tagInput.value = "";
    };
    const loadExample = () => {
      if (props.example) {
        formData.value = {
          ...props.example,
          tags: props.example.tags ? [...props.example.tags] : []
        };
      } else {
        resetForm();
        if (props.vocabularyId) {
          formData.value.vocabularyId = props.vocabularyId;
        }
      }
    };
    const addTagFromInput = () => {
      if (tagInput.value.trim()) {
        const newTags = tagInput.value.split(",").map((tag) => tag.trim()).filter((tag) => tag && !formData.value.tags?.includes(tag));
        if (newTags.length > 0) {
          formData.value.tags = [...formData.value.tags || [], ...newTags];
          tagInput.value = "";
        }
      }
    };
    const removeTag = (index) => {
      if (formData.value.tags) {
        formData.value.tags.splice(index, 1);
      }
    };
    const handleSubmit = () => {
      if (!isFormValid.value) return;
      const exampleData = {
        ...formData.value,
        tags: formData.value.tags?.filter((tag) => tag.trim()) || []
      };
      emit("save", exampleData);
    };
    const lockBodyScroll = () => {
      document.body.style.overflow = "hidden";
    };
    const unlockBodyScroll = () => {
      document.body.style.overflow = "";
    };
    watch(() => props.show, (newShow) => {
      if (newShow) {
        loadExample();
        lockBodyScroll();
      } else {
        unlockBodyScroll();
      }
    });
    watch(() => props.example, () => {
      if (props.show) {
        loadExample();
      }
    });
    watch(() => props.vocabularyId, () => {
      if (props.show && !props.example) {
        formData.value.vocabularyId = props.vocabularyId || "";
      }
    });
    onMounted(() => {
      if (props.show) {
        loadExample();
        lockBodyScroll();
      }
    });
    onUnmounted(() => {
      unlockBodyScroll();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$T, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$Q, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 flex flex-col h-full overflow-hidden transform",
                      onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$O, [
                        createBaseVNode("div", _hoisted_4$M, [
                          createBaseVNode("div", null, [
                            createBaseVNode("h2", _hoisted_5$J, [
                              _cache[10] || (_cache[10] = createBaseVNode("span", { class: "w-2 h-2 bg-green-500 rounded-full animate-pulse" }, null, -1)),
                              createBaseVNode("span", null, toDisplayString$1(_ctx.example ? unref(t)("vocabulary.examples.editExample", "Edit Example") : unref(t)("vocabulary.examples.addExample", "Add New Example")), 1)
                            ]),
                            selectedVocab.value ? (openBlock(), createElementBlock("div", _hoisted_6$H, [
                              createBaseVNode("span", _hoisted_7$F, toDisplayString$1(unref(t)("common.vocabulary", "Vocabulary")) + ":", 1),
                              createBaseVNode("span", _hoisted_8$F, toDisplayString$1(selectedVocab.value.word), 1),
                              _cache[11] || (_cache[11] = createBaseVNode("span", { class: "text-gray-400" }, "", -1)),
                              createBaseVNode("span", null, toDisplayString$1(selectedVocab.value.meaning), 1)
                            ])) : createCommentVNode("", true)
                          ]),
                          createBaseVNode("button", {
                            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close")),
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[12] || (_cache[12] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_9$E, [
                        createBaseVNode("form", {
                          onSubmit: withModifiers(handleSubmit, ["prevent"]),
                          class: "space-y-6"
                        }, [
                          createBaseVNode("div", _hoisted_10$D, [
                            createBaseVNode("label", _hoisted_11$D, [
                              _cache[13] || (_cache[13] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.examples.exampleType", "Example Type")) + " ", 1),
                              _cache[14] || (_cache[14] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                            ]),
                            withDirectives(createBaseVNode("select", {
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => formData.value.type = $event),
                              required: "",
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 hover:border-blue-400 dark:hover:border-blue-500 transform hover:scale-[1.02]"
                            }, [
                              createBaseVNode("option", _hoisted_12$C, toDisplayString$1(unref(t)("vocabulary.examples.selectType", "Select example type...")), 1),
                              createBaseVNode("option", _hoisted_13$C, toDisplayString$1(unref(t)("vocabulary.examples.types.sentence", "Sentence")), 1),
                              createBaseVNode("option", _hoisted_14$C, toDisplayString$1(unref(t)("vocabulary.examples.types.dialogue", "Dialogue")), 1),
                              createBaseVNode("option", _hoisted_15$x, toDisplayString$1(unref(t)("vocabulary.examples.types.phrase", "Phrase")), 1),
                              createBaseVNode("option", _hoisted_16$w, toDisplayString$1(unref(t)("vocabulary.examples.types.context", "Context")), 1)
                            ], 512), [
                              [vModelSelect, formData.value.type]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_17$v, [
                            createBaseVNode("label", _hoisted_18$u, [
                              _cache[15] || (_cache[15] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("common.title", "Title")) + " ", 1),
                              _cache[16] || (_cache[16] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                            ]),
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => formData.value.title = $event),
                              type: "text",
                              required: "",
                              placeholder: unref(t)("vocabulary.examples.titlePlaceholder", "Brief title for this example..."),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-300 hover:border-purple-400 dark:hover:border-purple-500 transform hover:scale-[1.02]"
                            }, null, 8, _hoisted_19$u), [
                              [vModelText, formData.value.title]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_20$t, [
                            createBaseVNode("label", _hoisted_21$t, [
                              _cache[17] || (_cache[17] = createBaseVNode("span", { class: "w-1 h-4 bg-orange-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.examples.content", "Example Content")) + " ", 1),
                              _cache[18] || (_cache[18] = createBaseVNode("span", { class: "text-red-500 ml-1" }, "*", -1))
                            ]),
                            withDirectives(createBaseVNode("textarea", {
                              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => formData.value.content = $event),
                              required: "",
                              rows: "4",
                              placeholder: unref(t)("vocabulary.examples.contentPlaceholder", "Enter the example sentence or dialogue..."),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all duration-300 hover:border-orange-400 dark:hover:border-orange-500 transform hover:scale-[1.02] resize-none"
                            }, null, 8, _hoisted_22$r), [
                              [vModelText, formData.value.content]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_23$r, [
                            createBaseVNode("label", _hoisted_24$q, [
                              _cache[19] || (_cache[19] = createBaseVNode("span", { class: "w-1 h-4 bg-yellow-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.examples.translation", "Translation")), 1)
                            ]),
                            withDirectives(createBaseVNode("textarea", {
                              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => formData.value.translation = $event),
                              rows: "2",
                              placeholder: unref(t)("vocabulary.examples.translationPlaceholder", "Optional translation in your native language..."),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent transition-all duration-300 hover:border-yellow-400 dark:hover:border-yellow-500 transform hover:scale-[1.02] resize-none"
                            }, null, 8, _hoisted_25$q), [
                              [vModelText, formData.value.translation]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_26$o, [
                            createBaseVNode("label", _hoisted_27$n, [
                              _cache[20] || (_cache[20] = createBaseVNode("span", { class: "w-1 h-4 bg-cyan-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.examples.context", "Context")), 1)
                            ]),
                            withDirectives(createBaseVNode("textarea", {
                              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => formData.value.context = $event),
                              rows: "2",
                              placeholder: unref(t)("vocabulary.examples.contextPlaceholder", "Optional context or situation where this example is used..."),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent transition-all duration-300 hover:border-cyan-400 dark:hover:border-cyan-500 transform hover:scale-[1.02] resize-none"
                            }, null, 8, _hoisted_28$n), [
                              [vModelText, formData.value.context]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_29$l, [
                            createBaseVNode("label", _hoisted_30$k, [
                              _cache[21] || (_cache[21] = createBaseVNode("span", { class: "w-1 h-4 bg-pink-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.examples.difficulty", "Difficulty")), 1)
                            ]),
                            withDirectives(createBaseVNode("select", {
                              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => formData.value.difficulty = $event),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-transparent transition-all duration-300 hover:border-pink-400 dark:hover:border-pink-500 transform hover:scale-[1.02]"
                            }, [
                              createBaseVNode("option", _hoisted_31$j, toDisplayString$1(unref(t)("vocabulary.examples.selectDifficulty", "Select difficulty...")), 1),
                              createBaseVNode("option", _hoisted_32$g, toDisplayString$1(unref(t)("common.easy", "Easy")), 1),
                              createBaseVNode("option", _hoisted_33$g, toDisplayString$1(unref(t)("vocabulary.examples.difficulty.medium", "Medium")), 1),
                              createBaseVNode("option", _hoisted_34$f, toDisplayString$1(unref(t)("common.difficult", "Difficult")), 1)
                            ], 512), [
                              [vModelSelect, formData.value.difficulty]
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_35$f, [
                            createBaseVNode("label", _hoisted_36$e, [
                              _cache[22] || (_cache[22] = createBaseVNode("span", { class: "w-1 h-4 bg-indigo-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.examples.tags", "Tags")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_37$d, [
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => tagInput.value = $event),
                                type: "text",
                                placeholder: unref(t)("vocabulary.examples.tagsPlaceholder", "Enter tags separated by commas..."),
                                onKeydown: withKeys(withModifiers(addTagFromInput, ["prevent"]), ["enter"]),
                                class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition-all duration-300 hover:border-indigo-400 dark:hover:border-indigo-500 transform hover:scale-[1.02]"
                              }, null, 40, _hoisted_38$d), [
                                [vModelText, tagInput.value]
                              ]),
                              formData.value.tags && formData.value.tags.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_39$b, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(formData.value.tags, (tag, index) => {
                                  return openBlock(), createElementBlock("span", {
                                    key: index,
                                    class: "inline-flex items-center px-3 py-1 rounded-full text-sm bg-green-100/50 text-green-800 dark:bg-green-900/20 dark:text-green-300 backdrop-blur-sm"
                                  }, [
                                    createTextVNode(toDisplayString$1(tag) + " ", 1),
                                    createBaseVNode("button", {
                                      type: "button",
                                      onClick: ($event) => removeTag(index),
                                      class: "ml-2 text-green-600 dark:text-green-400 hover:text-green-800 dark:hover:text-green-200 transition-all duration-300 hover:scale-110"
                                    }, _cache[23] || (_cache[23] = [
                                      createBaseVNode("svg", {
                                        class: "w-3 h-3",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M6 18L18 6M6 6l12 12"
                                        })
                                      ], -1)
                                    ]), 8, _hoisted_40$b)
                                  ]);
                                }), 128))
                              ])) : createCommentVNode("", true)
                            ])
                          ])
                        ], 32)
                      ]),
                      createBaseVNode("div", _hoisted_41$a, [
                        createBaseVNode("button", {
                          onClick: _cache[8] || (_cache[8] = ($event) => _ctx.$emit("close")),
                          type: "button",
                          class: "px-4 py-2 text-gray-700 dark:text-gray-300 bg-white/50 dark:bg-[#0a0a0a]/50 hover:bg-gray-100/50 dark:hover:bg-[#0a0a0a]/70 border border-gray-300 dark:border-gray-600 rounded-lg font-medium transition-all duration-300 hover:scale-105 shadow-md hover:shadow-lg"
                        }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                        createBaseVNode("button", {
                          onClick: handleSubmit,
                          type: "submit",
                          disabled: !isFormValid.value,
                          class: "px-6 py-2 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 disabled:from-gray-400 disabled:to-gray-500 disabled:cursor-not-allowed text-white rounded-lg font-medium transition-all duration-300 hover:scale-105 shadow-lg hover:shadow-xl"
                        }, toDisplayString$1(_ctx.example ? unref(t)("common.update", "Update") : unref(t)("common.add", "Add")), 9, _hoisted_42$8)
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const ExampleFormDialog = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$T
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$S = { class: "relative z-10 max-w-full sm:max-w-full md:max-w-full lg:max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-3 sm:pt-6" };
const _hoisted_2$P = { class: "group bg-white/80 dark:bg-[#0a0a0a]/80 backdrop-blur-md shadow-xl hover:shadow-2xl rounded-2xl border border-white/20 dark:border-white/10 transition-all duration-500 hover:scale-[1.005] p-3 sm:p-4 md:p-5 lg:p-6" };
const _hoisted_3$N = { class: "flex justify-between items-center" };
const _hoisted_4$L = { class: "flex items-center mb-1" };
const _hoisted_5$I = { class: "text-2xl sm:text-3xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 dark:from-blue-400 dark:to-indigo-400 bg-clip-text text-transparent" };
const _hoisted_6$G = { class: "mt-1 text-sm text-gray-700 dark:text-white/70" };
const _sfc_main$S = /* @__PURE__ */ defineComponent({
  __name: "GrammarHeader",
  emits: ["add-lesson"],
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$S, [
        createBaseVNode("div", _hoisted_2$P, [
          createBaseVNode("div", _hoisted_3$N, [
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_4$L, [
                _cache[1] || (_cache[1] = createBaseVNode("div", { class: "animate-pulse-slow" }, [
                  createBaseVNode("div", { class: "w-2.5 h-2.5 bg-gradient-to-r from-blue-400 to-indigo-500 rounded-full mr-2.5" })
                ], -1)),
                createBaseVNode("h1", _hoisted_5$I, toDisplayString$1(unref(t)("grammar.title", "Grammar")), 1)
              ]),
              createBaseVNode("p", _hoisted_6$G, toDisplayString$1(unref(t)("grammar.description", "Master English grammar with structured lessons and practice")), 1)
            ]),
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("add-lesson")),
              class: "bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition-colors shadow"
            }, [
              _cache[2] || (_cache[2] = createBaseVNode("svg", {
                class: "w-5 h-5 inline mr-2",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                  "clip-rule": "evenodd"
                })
              ], -1)),
              createTextVNode(" " + toDisplayString$1(unref(t)("grammar.addLesson", "Add Lesson")), 1)
            ])
          ])
        ])
      ]);
    };
  }
});

const GrammarHeader = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$S
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$R = { class: "bg-white dark:bg-[#0a0a0a] shadow rounded-lg p-6 mb-6" };
const _hoisted_2$O = { class: "grid grid-cols-1 md:grid-cols-3 gap-4" };
const _hoisted_3$M = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_4$K = ["value", "placeholder"];
const _hoisted_5$H = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_6$F = ["value"];
const _hoisted_7$E = { value: "" };
const _hoisted_8$E = { value: "beginner" };
const _hoisted_9$D = { value: "intermediate" };
const _hoisted_10$C = { value: "advanced" };
const _hoisted_11$C = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_12$B = ["value"];
const _hoisted_13$B = { value: "" };
const _hoisted_14$B = ["value"];
const _sfc_main$R = /* @__PURE__ */ defineComponent({
  __name: "GrammarFilters",
  props: {
    searchQuery: {},
    selectedLevel: {},
    selectedCategory: {},
    categories: {}
  },
  emits: ["update:searchQuery", "update:selectedLevel", "update:selectedCategory"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const emit = __emit;
    const handleSearchInput = (event) => {
      const target = event.target;
      emit("update:searchQuery", target.value);
    };
    const handleLevelChange = (event) => {
      const target = event.target;
      emit("update:selectedLevel", target.value);
    };
    const handleCategoryChange = (event) => {
      const target = event.target;
      emit("update:selectedCategory", target.value);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$R, [
        createBaseVNode("div", _hoisted_2$O, [
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_3$M, toDisplayString$1(unref(t)("common.search", "Search")), 1),
            createBaseVNode("input", {
              value: _ctx.searchQuery,
              onInput: handleSearchInput,
              type: "text",
              placeholder: unref(t)("grammar.search", "Search grammar..."),
              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400"
            }, null, 40, _hoisted_4$K)
          ]),
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_5$H, toDisplayString$1(unref(t)("grammar.level", "Level")), 1),
            createBaseVNode("select", {
              value: _ctx.selectedLevel,
              onChange: handleLevelChange,
              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400"
            }, [
              createBaseVNode("option", _hoisted_7$E, toDisplayString$1(unref(t)("common.all", "All")), 1),
              createBaseVNode("option", _hoisted_8$E, toDisplayString$1(unref(t)("grammar.levels.beginner", "Beginner")), 1),
              createBaseVNode("option", _hoisted_9$D, toDisplayString$1(unref(t)("grammar.levels.intermediate", "Intermediate")), 1),
              createBaseVNode("option", _hoisted_10$C, toDisplayString$1(unref(t)("grammar.levels.advanced", "Advanced")), 1)
            ], 40, _hoisted_6$F)
          ]),
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_11$C, toDisplayString$1(unref(t)("grammar.category", "Category")), 1),
            createBaseVNode("select", {
              value: _ctx.selectedCategory,
              onChange: handleCategoryChange,
              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400"
            }, [
              createBaseVNode("option", _hoisted_13$B, toDisplayString$1(unref(t)("common.all", "All")), 1),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.categories, (category) => {
                return openBlock(), createElementBlock("option", {
                  key: category,
                  value: category
                }, toDisplayString$1(category), 9, _hoisted_14$B);
              }), 128))
            ], 40, _hoisted_12$B)
          ])
        ])
      ]);
    };
  }
});

const GrammarFilters = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$R
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$Q = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg shadow-md overflow-hidden hover:shadow-lg transition-shadow border border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_2$N = { class: "h-48 bg-gradient-to-br from-blue-400 to-blue-600 flex items-center justify-center" };
const _hoisted_3$L = { class: "text-center text-white" };
const _hoisted_4$J = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_5$G = { class: "p-6" };
const _hoisted_6$E = { class: "flex items-center justify-between mb-3" };
const _hoisted_7$D = { class: "text-sm text-gray-500 dark:text-white/70" };
const _hoisted_8$D = { class: "text-gray-600 dark:text-white/80 text-sm mb-4 line-clamp-3" };
const _hoisted_9$C = { class: "flex items-center justify-between mb-4" };
const _hoisted_10$B = { class: "text-xs text-gray-500 dark:text-white/60" };
const _hoisted_11$B = { class: "flex items-center" };
const _hoisted_12$A = { class: "text-sm text-gray-600 dark:text-white/80" };
const _hoisted_13$A = { class: "mb-4" };
const _hoisted_14$A = { class: "flex justify-between text-sm text-gray-600 dark:text-white/80 mb-1" };
const _hoisted_15$w = { class: "w-full bg-gray-200 dark:bg-dark-bg-mute rounded-full h-2" };
const _hoisted_16$v = { class: "flex space-x-2" };
const _sfc_main$Q = /* @__PURE__ */ defineComponent({
  __name: "GrammarCard",
  props: {
    lesson: {}
  },
  emits: ["view-lesson", "practice-lesson", "edit-lesson", "delete-lesson"],
  setup(__props) {
    const { t } = useI18n();
    const getLevelColor = (level) => {
      switch (level) {
        case "beginner":
          return "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300";
        case "intermediate":
          return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300";
        case "advanced":
          return "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300";
        default:
          return "bg-gray-100 text-gray-800 dark:bg-dark-bg-mute dark:text-white/80";
      }
    };
    const getLevelText = (level) => {
      const fallbackMap = {
        beginner: "Beginner",
        intermediate: "Intermediate",
        advanced: "Advanced"
      };
      return t(`grammar.levels.${level}`, fallbackMap[level] || "Level");
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$Q, [
        createBaseVNode("div", _hoisted_2$N, [
          createBaseVNode("div", _hoisted_3$L, [
            _cache[4] || (_cache[4] = createBaseVNode("svg", {
              class: "w-16 h-16 mx-auto mb-2",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", { d: "M9 4.804A7.968 7.968 0 005.5 4c-1.255 0-2.443.29-3.5.804v10A7.969 7.969 0 015.5 14c1.669 0 3.218.51 4.5 1.385A7.962 7.962 0 0114.5 14c1.255 0 2.443.29 3.5.804v-10A7.968 7.968 0 0014.5 4c-1.255 0-2.443.29-3.5.804V12a1 1 0 11-2 0V4.804z" })
            ], -1)),
            createBaseVNode("h3", _hoisted_4$J, toDisplayString$1(_ctx.lesson.title), 1)
          ])
        ]),
        createBaseVNode("div", _hoisted_5$G, [
          createBaseVNode("div", _hoisted_6$E, [
            createBaseVNode("span", {
              class: normalizeClass([getLevelColor(_ctx.lesson.level), "px-2 py-1 text-xs font-medium rounded-full"])
            }, toDisplayString$1(getLevelText(_ctx.lesson.level)), 3),
            createBaseVNode("span", _hoisted_7$D, toDisplayString$1(_ctx.lesson.duration) + " " + toDisplayString$1(unref(t)("grammar.duration", "mins")), 1)
          ]),
          createBaseVNode("p", _hoisted_8$D, toDisplayString$1(_ctx.lesson.description), 1),
          createBaseVNode("div", _hoisted_9$C, [
            createBaseVNode("span", _hoisted_10$B, toDisplayString$1(_ctx.lesson.category), 1),
            createBaseVNode("div", _hoisted_11$B, [
              _cache[5] || (_cache[5] = createBaseVNode("svg", {
                class: "w-4 h-4 text-yellow-400 mr-1",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" })
              ], -1)),
              createBaseVNode("span", _hoisted_12$A, toDisplayString$1(_ctx.lesson.rating), 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_13$A, [
            createBaseVNode("div", _hoisted_14$A, [
              createBaseVNode("span", null, toDisplayString$1(unref(t)("grammar.progress", "Progress")), 1),
              createBaseVNode("span", null, toDisplayString$1(_ctx.lesson.progress) + "%", 1)
            ]),
            createBaseVNode("div", _hoisted_15$w, [
              createBaseVNode("div", {
                class: "bg-blue-500 h-2 rounded-full transition-all duration-300",
                style: normalizeStyle({ width: _ctx.lesson.progress + "%" })
              }, null, 4)
            ])
          ]),
          createBaseVNode("div", _hoisted_16$v, [
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("view-lesson", _ctx.lesson)),
              class: "flex-1 bg-blue-500 hover:bg-blue-600 text-white text-sm font-medium py-2 px-4 rounded-md transition-colors"
            }, toDisplayString$1(_ctx.lesson.progress > 0 ? unref(t)("grammar.continue", "Continue") : unref(t)("grammar.start", "Start")), 1),
            createBaseVNode("button", {
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("practice-lesson", _ctx.lesson)),
              class: "bg-green-500 hover:bg-green-600 text-white text-sm font-medium py-2 px-3 rounded-md transition-colors"
            }, _cache[6] || (_cache[6] = [
              createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z",
                  "clip-rule": "evenodd"
                })
              ], -1)
            ])),
            createBaseVNode("button", {
              onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("edit-lesson", _ctx.lesson)),
              class: "text-gray-500 dark:text-white/70 hover:text-gray-700 dark:hover:text-white p-2"
            }, _cache[7] || (_cache[7] = [
              createBaseVNode("svg", {
                class: "w-5 h-5",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
              ], -1)
            ])),
            createBaseVNode("button", {
              onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("delete-lesson", _ctx.lesson)),
              class: "text-red-500 hover:text-red-700 p-2"
            }, _cache[8] || (_cache[8] = [
              createBaseVNode("svg", {
                class: "w-5 h-5",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M9 2a1 1 0 000 2h2a1 1 0 100-2H9z",
                  "clip-rule": "evenodd"
                }),
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",
                  "clip-rule": "evenodd"
                })
              ], -1)
            ]))
          ])
        ])
      ]);
    };
  }
});

const GrammarCard = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$Q
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$P = { class: "text-center py-12" };
const _hoisted_2$M = { class: "mt-2 text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_3$K = { class: "mt-1 text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_4$I = { class: "mt-6" };
const _sfc_main$P = /* @__PURE__ */ defineComponent({
  __name: "GrammarEmptyState",
  emits: ["add-lesson"],
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$P, [
        _cache[2] || (_cache[2] = createBaseVNode("svg", {
          class: "mx-auto h-12 w-12 text-gray-400 dark:text-gray-500",
          fill: "none",
          viewBox: "0 0 24 24",
          stroke: "currentColor"
        }, [
          createBaseVNode("path", {
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            "stroke-width": "2",
            d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
          })
        ], -1)),
        createBaseVNode("h3", _hoisted_2$M, toDisplayString$1(unref(t)("grammar.emptyState.title", "No lessons yet")), 1),
        createBaseVNode("p", _hoisted_3$K, toDisplayString$1(unref(t)("grammar.emptyState.description", "Create your first grammar lesson to get started")), 1),
        createBaseVNode("div", _hoisted_4$I, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("add-lesson")),
            class: "inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700"
          }, [
            _cache[1] || (_cache[1] = createBaseVNode("svg", {
              class: "-ml-1 mr-2 h-5 w-5",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                "clip-rule": "evenodd"
              })
            ], -1)),
            createTextVNode(" " + toDisplayString$1(unref(t)("grammar.addNewLesson", "Add New Lesson")), 1)
          ])
        ])
      ]);
    };
  }
});

const GrammarEmptyState = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$P
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$O = {
  key: 0,
  class: "fixed inset-0 z-50 overflow-hidden",
  "aria-labelledby": "modal-title",
  role: "dialog",
  "aria-modal": "true"
};
const _hoisted_2$L = { class: "flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0" };
const _hoisted_3$J = { class: "inline-block align-bottom bg-white dark:bg-[#0a0a0a] rounded-xl text-left overflow-hidden shadow-2xl transform transition-all sm:my-8 sm:align-middle sm:max-w-4xl sm:w-full border border-gray-200 dark:border-gray-700" };
const _hoisted_4$H = { class: "bg-white dark:bg-[#0a0a0a] px-4 pt-5 pb-4 sm:p-6 sm:pb-4" };
const _hoisted_5$F = { class: "flex items-center justify-between pb-4 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] -mx-4 -mt-5 px-4 pt-5 sm:-mx-6 sm:-mt-6 sm:px-6 sm:pt-6" };
const _hoisted_6$D = { class: "text-lg leading-6 font-medium text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_7$C = {
  class: "bg-white dark:bg-[#0f0f0f] shadow-lg rounded-xl p-6 border border-gray-200 dark:border-gray-700 animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_8$C = { class: "text-lg font-medium text-gray-900 dark:text-white mb-6 flex items-center" };
const _hoisted_9$B = { class: "grid grid-cols-1 md:grid-cols-2 gap-6" };
const _hoisted_10$A = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_11$A = {
  for: "title",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_12$z = ["placeholder"];
const _hoisted_13$z = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_14$z = {
  for: "category",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_15$v = { value: "" };
const _hoisted_16$u = ["value"];
const _hoisted_17$u = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_18$t = {
  for: "level",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_19$t = { value: "" };
const _hoisted_20$s = { value: "beginner" };
const _hoisted_21$s = { value: "intermediate" };
const _hoisted_22$q = { value: "advanced" };
const _hoisted_23$q = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_24$p = {
  for: "duration",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_25$p = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "0.6s" }
};
const _hoisted_26$n = {
  for: "description",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_27$m = ["placeholder"];
const _hoisted_28$m = {
  class: "bg-white dark:bg-[#0f0f0f] shadow-lg rounded-xl p-6 border border-gray-200 dark:border-gray-700 animate-fade-in-up",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_29$k = { class: "text-lg font-medium text-gray-900 dark:text-white mb-6 flex items-center" };
const _hoisted_30$j = { class: "space-y-6" };
const _hoisted_31$i = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.8s" }
};
const _hoisted_32$f = {
  for: "theory",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_33$f = ["placeholder"];
const _hoisted_34$e = { class: "mt-1 text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_35$e = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.9s" }
};
const _hoisted_36$d = {
  for: "structure",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center"
};
const _hoisted_37$c = ["placeholder"];
const _hoisted_38$c = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "1.0s" }
};
const _hoisted_39$a = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_40$a = { class: "space-y-2" };
const _hoisted_41$9 = { class: "flex-1" };
const _hoisted_42$7 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_43$7 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_44$7 = ["onClick", "disabled"];
const _hoisted_45$6 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "1.2s" }
};
const _hoisted_46$6 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_47$6 = { class: "space-y-2" };
const _hoisted_48$6 = { class: "flex-1" };
const _hoisted_49$6 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_50$6 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_51$5 = ["onClick"];
const _hoisted_52$5 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "1.4s" }
};
const _hoisted_53$5 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_54$5 = { class: "space-y-2" };
const _hoisted_55$5 = { class: "flex-1" };
const _hoisted_56$5 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_57$5 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_58$5 = ["onUpdate:modelValue", "placeholder"];
const _hoisted_59$4 = ["onClick"];
const _hoisted_60$4 = { class: "bg-gray-50 dark:bg-[#0f0f0f] px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_61$4 = ["disabled"];
const _hoisted_62$4 = {
  key: 0,
  class: "animate-spin h-4 w-4 mr-2",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _sfc_main$O = /* @__PURE__ */ defineComponent({
  __name: "GrammarFormDialog",
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    editId: {
      type: String,
      default: ""
    }
  },
  emits: ["update:modelValue", "saved"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      const translated = params ? t(key, params) : t(key);
      const text = typeof translated === "string" ? translated : String(translated);
      if (text === key) {
        if (params) {
          return fallback.replace("{{index}}", String(params.index ?? ""));
        }
        return fallback;
      }
      return text;
    };
    const grammarStore = useGrammarStore();
    const isSubmitting = ref(false);
    const isEdit = computed(() => !!props.editId);
    watch(() => props.modelValue, (isOpen) => {
      if (isOpen) {
        document.body.style.overflow = "hidden";
      } else {
        document.body.style.overflow = "";
      }
    });
    onUnmounted(() => {
      document.body.style.overflow = "";
    });
    const categories = ref([
      "Tenses",
      "Conditionals",
      "Passive Voice",
      "Modal Verbs",
      "Reported Speech",
      "Articles",
      "Prepositions",
      "Adjectives & Adverbs",
      "Phrasal Verbs",
      "Gerunds & Infinitives"
    ]);
    const form = ref({
      title: "",
      description: "",
      level: "",
      category: "",
      duration: 30,
      theory: "",
      structure: "",
      examples: [
        { text: "", translation: "" }
      ],
      usageRules: [
        { title: "", description: "" }
      ],
      commonMistakes: [
        { wrong: "", correct: "", explanation: "" }
      ]
    });
    const resetForm = () => {
      form.value = {
        title: "",
        description: "",
        level: "",
        category: "",
        duration: 30,
        theory: "",
        structure: "",
        examples: [{ text: "", translation: "" }],
        usageRules: [{ title: "", description: "" }],
        commonMistakes: [{ wrong: "", correct: "", explanation: "" }]
      };
    };
    watch(() => props.editId, (newId) => {
      if (newId) {
        const lesson = grammarStore.getLesson(newId);
        if (lesson) {
          form.value = {
            title: lesson.title,
            description: lesson.description,
            level: lesson.level,
            category: lesson.category,
            duration: lesson.duration,
            theory: lesson.theory,
            structure: lesson.structure || "",
            examples: lesson.examples.map((ex) => ({
              text: ex.text,
              translation: ex.translation
            })),
            usageRules: lesson.usageRules?.map((rule) => ({
              title: rule.title,
              description: rule.description
            })) || [{ title: "", description: "" }],
            commonMistakes: lesson.commonMistakes?.map((mistake) => ({
              wrong: mistake.wrong,
              correct: mistake.correct,
              explanation: mistake.explanation
            })) || [{ wrong: "", correct: "", explanation: "" }]
          };
        }
      } else {
        resetForm();
      }
    }, { immediate: true });
    const addExample = () => {
      form.value.examples.push({ text: "", translation: "" });
    };
    const removeExample = (index) => {
      if (form.value.examples.length > 1) {
        form.value.examples.splice(index, 1);
      }
    };
    const addRule = () => {
      form.value.usageRules.push({ title: "", description: "" });
    };
    const removeRule = (index) => {
      form.value.usageRules.splice(index, 1);
    };
    const addMistake = () => {
      form.value.commonMistakes.push({ wrong: "", correct: "", explanation: "" });
    };
    const removeMistake = (index) => {
      form.value.commonMistakes.splice(index, 1);
    };
    const closeDialog = () => {
      emit("update:modelValue", false);
    };
    const submitForm = () => {
      isSubmitting.value = true;
      const filteredUsageRules = form.value.usageRules.filter((rule) => rule.title.trim() !== "" || rule.description.trim() !== "");
      const filteredMistakes = form.value.commonMistakes.filter((mistake) => mistake.wrong.trim() !== "" || mistake.correct.trim() !== "" || mistake.explanation.trim() !== "");
      const rules = filteredUsageRules.map((rule, index) => ({
        id: index + 1,
        title: rule.title,
        description: rule.description
      }));
      const examples = form.value.examples.map((example, index) => ({
        id: index + 1,
        text: example.text,
        translation: example.translation
      }));
      const commonMistakes = filteredMistakes.map((mistake, index) => ({
        id: index + 1,
        wrong: mistake.wrong,
        correct: mistake.correct,
        explanation: mistake.explanation
      }));
      const lessonData = {
        id: isEdit.value ? props.editId : Date.now().toString(),
        title: form.value.title,
        description: form.value.description,
        level: form.value.level,
        category: form.value.category,
        duration: form.value.duration,
        rating: isEdit.value ? grammarStore.getLesson(props.editId)?.rating || 5 : 5,
        progress: isEdit.value ? grammarStore.getLesson(props.editId)?.progress || 0 : 0,
        exercises: Math.floor(form.value.duration / 5),
        theory: form.value.theory,
        structure: form.value.structure,
        examples,
        rules,
        usageRules: filteredUsageRules,
        commonMistakes
      };
      if (isEdit.value) {
        grammarStore.updateLesson(props.editId, lessonData);
      } else {
        grammarStore.addLesson(lessonData);
      }
      setTimeout(() => {
        isSubmitting.value = false;
        emit("saved", lessonData);
        emit("update:modelValue", false);
        resetForm();
      }, 500);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            __props.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$O, [
              createBaseVNode("div", _hoisted_2$L, [
                _cache[36] || (_cache[36] = createBaseVNode("div", { class: "fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity backdrop-blur-sm" }, null, -1)),
                createVNode(Transition, {
                  "enter-active-class": "transition-all duration-500 ease-out",
                  "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                  "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                  "leave-active-class": "transition-all duration-300 ease-in",
                  "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                  "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_3$J, [
                      createBaseVNode("div", _hoisted_4$H, [
                        createBaseVNode("div", _hoisted_5$F, [
                          createBaseVNode("h3", _hoisted_6$D, [
                            _cache[7] || (_cache[7] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(isEdit.value ? unref(t)("grammar.editLesson", "Edit Lesson") : unref(t)("grammar.addNewLesson", "Add New Lesson")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: closeDialog,
                            class: "text-gray-400 hover:text-gray-500 dark:hover:text-gray-300 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[8] || (_cache[8] = [
                            createBaseVNode("svg", {
                              class: "h-6 w-6",
                              fill: "none",
                              viewBox: "0 0 24 24",
                              stroke: "currentColor"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ]),
                        createBaseVNode("form", {
                          onSubmit: withModifiers(submitForm, ["prevent"]),
                          class: "space-y-6 mt-4 max-h-[calc(100vh-200px)] overflow-y-auto px-2"
                        }, [
                          createBaseVNode("div", _hoisted_7$C, [
                            createBaseVNode("h3", _hoisted_8$C, [
                              _cache[9] || (_cache[9] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("common.title")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_9$B, [
                              createBaseVNode("div", _hoisted_10$A, [
                                createBaseVNode("label", _hoisted_11$A, [
                                  _cache[10] || (_cache[10] = createBaseVNode("span", { class: "w-1 h-3 bg-blue-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("common.title", "Title")) + " ", 1),
                                  _cache[11] || (_cache[11] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                withDirectives(createBaseVNode("input", {
                                  id: "title",
                                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => form.value.title = $event),
                                  type: "text",
                                  required: "",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 hover:border-blue-400 dark:hover:border-blue-500 transform hover:scale-[1.02]",
                                  placeholder: unref(t)("grammar.titlePlaceholder", "Enter lesson title")
                                }, null, 8, _hoisted_12$z), [
                                  [vModelText, form.value.title]
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_13$z, [
                                createBaseVNode("label", _hoisted_14$z, [
                                  _cache[12] || (_cache[12] = createBaseVNode("span", { class: "w-1 h-3 bg-green-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.category", "Category")) + " ", 1),
                                  _cache[13] || (_cache[13] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                withDirectives(createBaseVNode("select", {
                                  id: "category",
                                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => form.value.category = $event),
                                  required: "",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-300 hover:border-green-400 dark:hover:border-green-500 transform hover:scale-[1.02] cursor-pointer"
                                }, [
                                  createBaseVNode("option", _hoisted_15$v, toDisplayString$1(unref(t)("grammar.selectCategory", "Select category")), 1),
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(categories.value, (category) => {
                                    return openBlock(), createElementBlock("option", {
                                      key: category,
                                      value: category
                                    }, toDisplayString$1(category), 9, _hoisted_16$u);
                                  }), 128))
                                ], 512), [
                                  [vModelSelect, form.value.category]
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_17$u, [
                                createBaseVNode("label", _hoisted_18$t, [
                                  _cache[14] || (_cache[14] = createBaseVNode("span", { class: "w-1 h-3 bg-purple-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.level", "Level")) + " ", 1),
                                  _cache[15] || (_cache[15] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                withDirectives(createBaseVNode("select", {
                                  id: "level",
                                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => form.value.level = $event),
                                  required: "",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-300 hover:border-purple-400 dark:hover:border-purple-500 transform hover:scale-[1.02] cursor-pointer"
                                }, [
                                  createBaseVNode("option", _hoisted_19$t, toDisplayString$1(unref(t)("grammar.selectLevel", "Select level")), 1),
                                  createBaseVNode("option", _hoisted_20$s, toDisplayString$1(unref(t)("grammar.levels.beginner", "Beginner")), 1),
                                  createBaseVNode("option", _hoisted_21$s, toDisplayString$1(unref(t)("grammar.levels.intermediate", "Intermediate")), 1),
                                  createBaseVNode("option", _hoisted_22$q, toDisplayString$1(unref(t)("grammar.levels.advanced", "Advanced")), 1)
                                ], 512), [
                                  [vModelSelect, form.value.level]
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_23$q, [
                                createBaseVNode("label", _hoisted_24$p, [
                                  _cache[16] || (_cache[16] = createBaseVNode("span", { class: "w-1 h-3 bg-orange-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.durationLabel", "Duration (minutes)")) + " ", 1),
                                  _cache[17] || (_cache[17] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                withDirectives(createBaseVNode("input", {
                                  id: "duration",
                                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => form.value.duration = $event),
                                  type: "number",
                                  min: "1",
                                  required: "",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all duration-300 hover:border-orange-400 dark:hover:border-orange-500 transform hover:scale-[1.02]",
                                  placeholder: "30"
                                }, null, 512), [
                                  [
                                    vModelText,
                                    form.value.duration,
                                    void 0,
                                    { number: true }
                                  ]
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_25$p, [
                                createBaseVNode("label", _hoisted_26$n, [
                                  _cache[18] || (_cache[18] = createBaseVNode("span", { class: "w-1 h-3 bg-indigo-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.description", "Description")) + " ", 1),
                                  _cache[19] || (_cache[19] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                withDirectives(createBaseVNode("textarea", {
                                  id: "description",
                                  "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => form.value.description = $event),
                                  rows: "3",
                                  required: "",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition-all duration-300 hover:border-indigo-400 dark:hover:border-indigo-500 transform hover:scale-[1.02] resize-none",
                                  placeholder: unref(t)("grammar.descriptionPlaceholder", "Enter a brief description")
                                }, null, 8, _hoisted_27$m), [
                                  [vModelText, form.value.description]
                                ])
                              ])
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_28$m, [
                            createBaseVNode("h3", _hoisted_29$k, [
                              _cache[20] || (_cache[20] = createBaseVNode("span", { class: "w-1 h-4 bg-teal-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("grammar.lessonContent", "Lesson Content")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_30$j, [
                              createBaseVNode("div", _hoisted_31$i, [
                                createBaseVNode("label", _hoisted_32$f, [
                                  _cache[21] || (_cache[21] = createBaseVNode("span", { class: "w-1 h-3 bg-teal-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.theory", "Theory")) + " ", 1),
                                  _cache[22] || (_cache[22] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                withDirectives(createBaseVNode("textarea", {
                                  id: "theory",
                                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => form.value.theory = $event),
                                  rows: "6",
                                  required: "",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all duration-300 hover:border-teal-400 dark:hover:border-teal-500 transform hover:scale-[1.02] resize-none",
                                  placeholder: unref(t)("grammar.theoryPlaceholder", "Enter grammar theory")
                                }, null, 8, _hoisted_33$f), [
                                  [vModelText, form.value.theory]
                                ]),
                                createBaseVNode("p", _hoisted_34$e, toDisplayString$1(unref(t)("grammar.markdownSupported", "Markdown is supported")), 1)
                              ]),
                              createBaseVNode("div", _hoisted_35$e, [
                                createBaseVNode("label", _hoisted_36$d, [
                                  _cache[23] || (_cache[23] = createBaseVNode("span", { class: "w-1 h-3 bg-pink-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.structure", "Structure")) + " ", 1),
                                  _cache[24] || (_cache[24] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                withDirectives(createBaseVNode("textarea", {
                                  id: "structure",
                                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => form.value.structure = $event),
                                  rows: "4",
                                  required: "",
                                  class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-transparent transition-all duration-300 hover:border-pink-400 dark:hover:border-pink-500 transform hover:scale-[1.02] resize-none",
                                  placeholder: unref(t)("grammar.structurePlaceholder", "Enter structure")
                                }, null, 8, _hoisted_37$c), [
                                  [vModelText, form.value.structure]
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_38$c, [
                                createBaseVNode("label", _hoisted_39$a, [
                                  _cache[25] || (_cache[25] = createBaseVNode("span", { class: "w-1 h-3 bg-yellow-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.examples", "Examples")) + " ", 1),
                                  _cache[26] || (_cache[26] = createBaseVNode("span", { class: "text-red-500" }, "*", -1))
                                ]),
                                createBaseVNode("div", _hoisted_40$a, [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(form.value.examples, (example, index) => {
                                    return openBlock(), createElementBlock("div", {
                                      key: index,
                                      class: "flex items-start space-x-2 animate-fade-in-up",
                                      style: normalizeStyle({ animationDelay: `${1.1 + index * 0.1}s` })
                                    }, [
                                      createBaseVNode("div", _hoisted_41$9, [
                                        withDirectives(createBaseVNode("input", {
                                          "onUpdate:modelValue": ($event) => example.text = $event,
                                          type: "text",
                                          class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent transition-all duration-300 hover:border-yellow-400 dark:hover:border-yellow-500 transform hover:scale-[1.02]",
                                          placeholder: tf("grammar.examplePlaceholder", "Example {{index}}", { index: index + 1 })
                                        }, null, 8, _hoisted_42$7), [
                                          [vModelText, example.text]
                                        ]),
                                        withDirectives(createBaseVNode("input", {
                                          "onUpdate:modelValue": ($event) => example.translation = $event,
                                          type: "text",
                                          class: "w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent transition-all duration-300 hover:border-yellow-400 dark:hover:border-yellow-500 transform hover:scale-[1.02]",
                                          placeholder: tf("grammar.translationPlaceholder", "Translation {{index}}", { index: index + 1 })
                                        }, null, 8, _hoisted_43$7), [
                                          [vModelText, example.translation]
                                        ])
                                      ]),
                                      createBaseVNode("button", {
                                        type: "button",
                                        onClick: ($event) => removeExample(index),
                                        class: "mt-2 text-red-500 hover:text-red-700 transition-all duration-300 hover:scale-110 p-1 rounded-full hover:bg-red-50 dark:hover:bg-red-900",
                                        disabled: form.value.examples.length <= 1
                                      }, _cache[27] || (_cache[27] = [
                                        createBaseVNode("svg", {
                                          class: "w-5 h-5",
                                          fill: "currentColor",
                                          viewBox: "0 0 20 20"
                                        }, [
                                          createBaseVNode("path", {
                                            "fill-rule": "evenodd",
                                            d: "M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z",
                                            "clip-rule": "evenodd"
                                          })
                                        ], -1)
                                      ]), 8, _hoisted_44$7)
                                    ], 4);
                                  }), 128))
                                ]),
                                createBaseVNode("button", {
                                  type: "button",
                                  onClick: addExample,
                                  class: "mt-2 inline-flex items-center text-sm text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 transition-all duration-300 hover:scale-105"
                                }, [
                                  _cache[28] || (_cache[28] = createBaseVNode("svg", {
                                    class: "w-4 h-4 mr-1",
                                    fill: "currentColor",
                                    viewBox: "0 0 20 20"
                                  }, [
                                    createBaseVNode("path", {
                                      "fill-rule": "evenodd",
                                      d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                                      "clip-rule": "evenodd"
                                    })
                                  ], -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.addExample", "Add example")), 1)
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_45$6, [
                                createBaseVNode("label", _hoisted_46$6, [
                                  _cache[29] || (_cache[29] = createBaseVNode("span", { class: "w-1 h-3 bg-cyan-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.usageRules", "Usage Rules")), 1)
                                ]),
                                createBaseVNode("div", _hoisted_47$6, [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(form.value.usageRules, (rule, index) => {
                                    return openBlock(), createElementBlock("div", {
                                      key: index,
                                      class: "flex items-start space-x-2 animate-fade-in-up",
                                      style: normalizeStyle({ animationDelay: `${1.3 + index * 0.1}s` })
                                    }, [
                                      createBaseVNode("div", _hoisted_48$6, [
                                        withDirectives(createBaseVNode("input", {
                                          "onUpdate:modelValue": ($event) => rule.title = $event,
                                          type: "text",
                                          class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent transition-all duration-300 hover:border-cyan-400 dark:hover:border-cyan-500 transform hover:scale-[1.02]",
                                          placeholder: tf("grammar.ruleTitlePlaceholder", "Rule {{index}} title", { index: index + 1 })
                                        }, null, 8, _hoisted_49$6), [
                                          [vModelText, rule.title]
                                        ]),
                                        withDirectives(createBaseVNode("textarea", {
                                          "onUpdate:modelValue": ($event) => rule.description = $event,
                                          rows: "2",
                                          class: "w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent transition-all duration-300 hover:border-cyan-400 dark:hover:border-cyan-500 transform hover:scale-[1.02] resize-none",
                                          placeholder: tf("grammar.ruleDescriptionPlaceholder", "Rule {{index}} description", { index: index + 1 })
                                        }, null, 8, _hoisted_50$6), [
                                          [vModelText, rule.description]
                                        ])
                                      ]),
                                      createBaseVNode("button", {
                                        type: "button",
                                        onClick: ($event) => removeRule(index),
                                        class: "mt-2 text-red-500 hover:text-red-700 transition-all duration-300 hover:scale-110 p-1 rounded-full hover:bg-red-50 dark:hover:bg-red-900"
                                      }, _cache[30] || (_cache[30] = [
                                        createBaseVNode("svg", {
                                          class: "w-5 h-5",
                                          fill: "currentColor",
                                          viewBox: "0 0 20 20"
                                        }, [
                                          createBaseVNode("path", {
                                            "fill-rule": "evenodd",
                                            d: "M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z",
                                            "clip-rule": "evenodd"
                                          })
                                        ], -1)
                                      ]), 8, _hoisted_51$5)
                                    ], 4);
                                  }), 128))
                                ]),
                                createBaseVNode("button", {
                                  type: "button",
                                  onClick: addRule,
                                  class: "mt-2 inline-flex items-center text-sm text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 transition-all duration-300 hover:scale-105"
                                }, [
                                  _cache[31] || (_cache[31] = createBaseVNode("svg", {
                                    class: "w-4 h-4 mr-1",
                                    fill: "currentColor",
                                    viewBox: "0 0 20 20"
                                  }, [
                                    createBaseVNode("path", {
                                      "fill-rule": "evenodd",
                                      d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                                      "clip-rule": "evenodd"
                                    })
                                  ], -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.addRule", "Add rule")), 1)
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_52$5, [
                                createBaseVNode("label", _hoisted_53$5, [
                                  _cache[32] || (_cache[32] = createBaseVNode("span", { class: "w-1 h-3 bg-red-500 rounded mr-2" }, null, -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.commonMistakes", "Common Mistakes")), 1)
                                ]),
                                createBaseVNode("div", _hoisted_54$5, [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(form.value.commonMistakes, (mistake, index) => {
                                    return openBlock(), createElementBlock("div", {
                                      key: index,
                                      class: "flex items-start space-x-2 animate-fade-in-up",
                                      style: normalizeStyle({ animationDelay: `${1.5 + index * 0.1}s` })
                                    }, [
                                      createBaseVNode("div", _hoisted_55$5, [
                                        withDirectives(createBaseVNode("input", {
                                          "onUpdate:modelValue": ($event) => mistake.wrong = $event,
                                          type: "text",
                                          class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all duration-300 hover:border-red-400 dark:hover:border-red-500 transform hover:scale-[1.02]",
                                          placeholder: tf("grammar.wrongSentencePlaceholder", "Wrong sentence {{index}}", { index: index + 1 })
                                        }, null, 8, _hoisted_56$5), [
                                          [vModelText, mistake.wrong]
                                        ]),
                                        withDirectives(createBaseVNode("input", {
                                          "onUpdate:modelValue": ($event) => mistake.correct = $event,
                                          type: "text",
                                          class: "w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all duration-300 hover:border-red-400 dark:hover:border-red-500 transform hover:scale-[1.02]",
                                          placeholder: tf("grammar.correctSentencePlaceholder", "Correct sentence {{index}}", { index: index + 1 })
                                        }, null, 8, _hoisted_57$5), [
                                          [vModelText, mistake.correct]
                                        ]),
                                        withDirectives(createBaseVNode("textarea", {
                                          "onUpdate:modelValue": ($event) => mistake.explanation = $event,
                                          rows: "2",
                                          class: "w-full mt-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent transition-all duration-300 hover:border-red-400 dark:hover:border-red-500 transform hover:scale-[1.02] resize-none",
                                          placeholder: tf("grammar.explanationPlaceholder", "Explanation {{index}}", { index: index + 1 })
                                        }, null, 8, _hoisted_58$5), [
                                          [vModelText, mistake.explanation]
                                        ])
                                      ]),
                                      createBaseVNode("button", {
                                        type: "button",
                                        onClick: ($event) => removeMistake(index),
                                        class: "mt-2 text-red-500 hover:text-red-700 transition-all duration-300 hover:scale-110 p-1 rounded-full hover:bg-red-50 dark:hover:bg-red-900"
                                      }, _cache[33] || (_cache[33] = [
                                        createBaseVNode("svg", {
                                          class: "w-5 h-5",
                                          fill: "currentColor",
                                          viewBox: "0 0 20 20"
                                        }, [
                                          createBaseVNode("path", {
                                            "fill-rule": "evenodd",
                                            d: "M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z",
                                            "clip-rule": "evenodd"
                                          })
                                        ], -1)
                                      ]), 8, _hoisted_59$4)
                                    ], 4);
                                  }), 128))
                                ]),
                                createBaseVNode("button", {
                                  type: "button",
                                  onClick: addMistake,
                                  class: "mt-2 inline-flex items-center text-sm text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 transition-all duration-300 hover:scale-105"
                                }, [
                                  _cache[34] || (_cache[34] = createBaseVNode("svg", {
                                    class: "w-4 h-4 mr-1",
                                    fill: "currentColor",
                                    viewBox: "0 0 20 20"
                                  }, [
                                    createBaseVNode("path", {
                                      "fill-rule": "evenodd",
                                      d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                                      "clip-rule": "evenodd"
                                    })
                                  ], -1)),
                                  createTextVNode(" " + toDisplayString$1(unref(t)("grammar.addMistake", "Add mistake")), 1)
                                ])
                              ])
                            ])
                          ])
                        ], 32)
                      ]),
                      createBaseVNode("div", _hoisted_60$4, [
                        createBaseVNode("button", {
                          type: "button",
                          onClick: submitForm,
                          disabled: isSubmitting.value,
                          class: "w-full inline-flex justify-center rounded-lg border border-transparent shadow-sm px-4 py-2 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-base font-medium text-white focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:ml-3 sm:w-auto sm:text-sm transition-all duration-300 hover:scale-105 hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                        }, [
                          isSubmitting.value ? (openBlock(), createElementBlock("svg", _hoisted_62$4, _cache[35] || (_cache[35] = [
                            createBaseVNode("circle", {
                              class: "opacity-25",
                              cx: "12",
                              cy: "12",
                              r: "10",
                              stroke: "currentColor",
                              "stroke-width": "4"
                            }, null, -1),
                            createBaseVNode("path", {
                              class: "opacity-75",
                              fill: "currentColor",
                              d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                            }, null, -1)
                          ]))) : createCommentVNode("", true),
                          createTextVNode(" " + toDisplayString$1(isSubmitting.value ? unref(t)("common.saving", "Saving...") : isEdit.value ? unref(t)("common.update", "Update") : unref(t)("common.save", "Save")), 1)
                        ], 8, _hoisted_61$4),
                        createBaseVNode("button", {
                          type: "button",
                          onClick: closeDialog,
                          class: "mt-3 w-full inline-flex justify-center rounded-lg border border-gray-300 dark:border-gray-600 shadow-sm px-4 py-2 bg-white dark:bg-[#0a0a0a] text-base font-medium text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:mt-0 sm:ml-3 sm:w-auto sm:text-sm transition-all duration-300 hover:scale-105 hover:shadow-lg"
                        }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1)
                      ])
                    ])
                  ]),
                  _: 1
                })
              ])
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const GrammarFormDialog = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["__scopeId", "data-v-6c037500"]]);

const GrammarFormDialog$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: GrammarFormDialog
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$N = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-white/10 p-6" };
const _hoisted_2$K = { class: "mb-6" };
const _hoisted_3$I = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_4$G = {
  key: 0,
  class: "mb-4"
};
const _hoisted_5$E = { class: "space-y-3 mb-8" };
const _hoisted_6$C = ["onClick"];
const _hoisted_7$B = { class: "flex items-center space-x-3" };
const _hoisted_8$B = { class: "text-gray-900 dark:text-white" };
const _hoisted_9$A = { class: "ml-auto" };
const _hoisted_10$z = {
  key: 0,
  class: "w-5 h-5 text-green-600 dark:text-green-400",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_11$z = {
  key: 1,
  class: "w-5 h-5 text-red-600 dark:text-red-400",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_12$y = {
  key: 0,
  class: "mb-6 p-4 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700 rounded-lg"
};
const _hoisted_13$y = { class: "font-medium text-yellow-800 dark:text-yellow-200 mb-2" };
const _hoisted_14$y = { class: "text-yellow-700 dark:text-yellow-300 text-sm" };
const _hoisted_15$u = { class: "flex justify-between items-center" };
const _hoisted_16$t = { class: "flex items-center space-x-4" };
const _hoisted_17$t = {
  key: 1,
  class: "text-sm text-blue-600 dark:text-blue-400"
};
const _hoisted_18$s = { class: "flex space-x-4" };
const _hoisted_19$s = ["disabled"];
const _sfc_main$N = /* @__PURE__ */ defineComponent({
  __name: "MultipleChoiceExercise",
  props: {
    question: {},
    questionIndex: {},
    totalQuestions: {}
  },
  emits: ["answer", "next", "complete"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      const translated = params ? t(key, params) : t(key);
      const text = typeof translated === "string" ? translated : String(translated);
      if (text === key) return fallback;
      return text;
    };
    const { playAudio } = useVoiceStore();
    const props = __props;
    const emit = __emit;
    const selectedOption = ref(null);
    const showAnswer = ref(false);
    const showHint = ref(false);
    const correctAnswerIndex = computed(() => {
      return props.question.options.findIndex((option) => option === props.question.correctAnswer);
    });
    const selectOption = (index) => {
      if (!showAnswer.value) {
        selectedOption.value = index;
      }
    };
    const checkAnswer = () => {
      if (selectedOption.value === null) return;
      showAnswer.value = true;
      const isCorrect = selectedOption.value === correctAnswerIndex.value;
      const userAnswer = props.question.options[selectedOption.value];
      emit("answer", {
        isCorrect,
        userAnswer,
        correctAnswer: props.question.correctAnswer
      });
    };
    const nextQuestion = () => {
      if (props.questionIndex === props.totalQuestions - 1) {
        emit("complete");
      } else {
        selectedOption.value = null;
        showAnswer.value = false;
        showHint.value = false;
        emit("next");
      }
    };
    const playQuestionAudio = async () => {
      if (props.question.audio) {
        try {
          await playAudio(props.question.question);
        } catch (error) {
          console.error("Error playing audio:", error);
        }
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$N, [
        createBaseVNode("div", _hoisted_2$K, [
          createBaseVNode("h3", _hoisted_3$I, toDisplayString$1(_ctx.question.question), 1),
          _ctx.question.audio ? (openBlock(), createElementBlock("div", _hoisted_4$G, [
            createBaseVNode("button", {
              onClick: playQuestionAudio,
              class: "flex items-center space-x-2 px-4 py-2 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-lg hover:bg-blue-200 dark:hover:bg-blue-900/50 transition-colors"
            }, [
              _cache[1] || (_cache[1] = createBaseVNode("svg", {
                class: "w-5 h-5",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M15.536 8.464a5 5 0 010 7.072m-2.036-5.036a2.5 2.5 0 010 3.536M6 10h4l4.5-4.5v9L10 10H6V8z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.playAudio", "Play audio")), 1)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_5$E, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.question.options, (option, index) => {
            return openBlock(), createElementBlock("div", {
              key: index,
              onClick: ($event) => selectOption(index),
              class: normalizeClass([
                "p-4 rounded-lg border-2 cursor-pointer transition-all duration-200",
                selectedOption.value === index ? "border-blue-500 bg-blue-50 dark:bg-blue-900/30" : "border-gray-200 dark:border-white/10 hover:border-gray-300 dark:hover:border-white/20 bg-gray-50 dark:bg-[#0a0a0a]/50",
                showAnswer.value && index === correctAnswerIndex.value ? "border-green-500 bg-green-50 dark:bg-green-900/30" : "",
                showAnswer.value && selectedOption.value === index && selectedOption.value !== correctAnswerIndex.value ? "border-red-500 bg-red-50 dark:bg-red-900/30" : ""
              ])
            }, [
              createBaseVNode("div", _hoisted_7$B, [
                createBaseVNode("div", {
                  class: normalizeClass([
                    "w-6 h-6 rounded-full border-2 flex items-center justify-center text-sm font-medium",
                    selectedOption.value === index ? "border-blue-500 bg-blue-500 text-white" : "border-gray-300 dark:border-white/10 text-gray-500 dark:text-white/60",
                    showAnswer.value && index === correctAnswerIndex.value ? "border-green-500 bg-green-500 text-white" : "",
                    showAnswer.value && selectedOption.value === index && selectedOption.value !== correctAnswerIndex.value ? "border-red-500 bg-red-500 text-white" : ""
                  ])
                }, toDisplayString$1(String.fromCharCode(65 + index)), 3),
                createBaseVNode("span", _hoisted_8$B, toDisplayString$1(option), 1),
                createBaseVNode("div", _hoisted_9$A, [
                  showAnswer.value && index === correctAnswerIndex.value ? (openBlock(), createElementBlock("svg", _hoisted_10$z, _cache[2] || (_cache[2] = [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M5 13l4 4L19 7"
                    }, null, -1)
                  ]))) : showAnswer.value && selectedOption.value === index && selectedOption.value !== correctAnswerIndex.value ? (openBlock(), createElementBlock("svg", _hoisted_11$z, _cache[3] || (_cache[3] = [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M6 18L18 6M6 6l12 12"
                    }, null, -1)
                  ]))) : createCommentVNode("", true)
                ])
              ])
            ], 10, _hoisted_6$C);
          }), 128))
        ]),
        showAnswer.value && _ctx.question.explanation ? (openBlock(), createElementBlock("div", _hoisted_12$y, [
          createBaseVNode("h4", _hoisted_13$y, toDisplayString$1(tf("grammar.practice.explanation", "Explanation")), 1),
          createBaseVNode("p", _hoisted_14$y, toDisplayString$1(_ctx.question.explanation), 1)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_15$u, [
          createBaseVNode("div", _hoisted_16$t, [
            !showAnswer.value && _ctx.question.hint ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: _cache[0] || (_cache[0] = ($event) => showHint.value = !showHint.value),
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-gray-600 dark:text-white/60 hover:text-gray-800 dark:hover:text-white/80 transition-colors"
            }, [
              _cache[4] || (_cache[4] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.hint", "Hint")), 1)
            ])) : createCommentVNode("", true),
            showHint.value && _ctx.question.hint ? (openBlock(), createElementBlock("div", _hoisted_17$t, "  " + toDisplayString$1(_ctx.question.hint), 1)) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_18$s, [
            !showAnswer.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: checkAnswer,
              disabled: selectedOption.value === null,
              class: "px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            }, toDisplayString$1(tf("grammar.practice.checkAnswer", "Check answer")), 9, _hoisted_19$s)) : (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: nextQuestion,
              class: "px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            }, toDisplayString$1(_ctx.questionIndex === _ctx.totalQuestions - 1 ? tf("grammar.practice.finish", "Finish") : tf("grammar.practice.next", "Next")), 1))
          ])
        ])
      ]);
    };
  }
});

const MultipleChoiceExercise = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$N
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$M = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-white/10 p-6" };
const _hoisted_2$J = { class: "mb-6" };
const _hoisted_3$H = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_4$F = { class: "bg-gray-50 dark:bg-[#0a0a0a]/50 rounded-lg p-4 mb-4" };
const _hoisted_5$D = { class: "text-lg leading-relaxed text-gray-900 dark:text-white" };
const _hoisted_6$B = { key: 0 };
const _hoisted_7$A = ["onUpdate:modelValue", "placeholder", "disabled"];
const _hoisted_8$A = {
  key: 0,
  class: "mb-4"
};
const _hoisted_9$z = { class: "text-sm font-medium text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_10$y = { class: "flex flex-wrap gap-2" };
const _hoisted_11$y = ["onClick", "disabled"];
const _hoisted_12$x = {
  key: 1,
  class: "mb-4"
};
const _hoisted_13$x = {
  key: 0,
  class: "mb-6 space-y-4"
};
const _hoisted_14$x = { class: "p-4 bg-green-50 dark:bg-green-900/30 border border-green-200 dark:border-green-700 rounded-lg" };
const _hoisted_15$t = { class: "font-medium text-green-800 dark:text-green-200 mb-2" };
const _hoisted_16$s = { class: "text-lg leading-relaxed text-green-700 dark:text-green-300" };
const _hoisted_17$s = { key: 0 };
const _hoisted_18$r = {
  key: 1,
  class: "inline-block mx-1 px-2 py-1 bg-green-100 dark:bg-green-800 rounded border font-medium"
};
const _hoisted_19$r = {
  key: 0,
  class: "p-4 bg-red-50 dark:bg-red-900/30 border border-red-200 dark:border-red-700 rounded-lg"
};
const _hoisted_20$r = { class: "font-medium text-red-800 dark:text-red-200 mb-2" };
const _hoisted_21$r = { class: "text-lg leading-relaxed text-red-700 dark:text-red-300" };
const _hoisted_22$p = { key: 0 };
const _hoisted_23$p = {
  key: 1,
  class: "mb-6 p-4 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700 rounded-lg"
};
const _hoisted_24$o = { class: "font-medium text-yellow-800 dark:text-yellow-200 mb-2" };
const _hoisted_25$o = { class: "text-yellow-700 dark:text-yellow-300 text-sm" };
const _hoisted_26$m = { class: "flex justify-between items-center" };
const _hoisted_27$l = { class: "flex items-center space-x-4" };
const _hoisted_28$l = {
  key: 1,
  class: "text-sm text-blue-600 dark:text-blue-400"
};
const _hoisted_29$j = { class: "flex space-x-4" };
const _hoisted_30$i = ["disabled"];
const _sfc_main$M = /* @__PURE__ */ defineComponent({
  __name: "FillBlankExercise",
  props: {
    question: {},
    questionIndex: {},
    totalQuestions: {}
  },
  emits: ["answer", "next", "complete"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      try {
        const translated = t(key, params);
        return typeof translated === "string" && translated !== key ? translated : fallback;
      } catch {
        return fallback;
      }
    };
    const { playAudio } = useVoiceStore();
    const props = __props;
    const emit = __emit;
    const userAnswers = ref([]);
    const showAnswer = ref(false);
    const showHint = ref(false);
    const focusedBlankIndex = ref(null);
    const sentenceParts = computed(() => {
      if (!props.question?.sentence) return [];
      const parts = [];
      const regex = /___+/g;
      let lastIndex = 0;
      let match;
      let blankIndex = 0;
      while ((match = regex.exec(props.question.sentence)) !== null) {
        if (match.index > lastIndex) {
          parts.push({
            type: "text",
            content: props.question.sentence.slice(lastIndex, match.index)
          });
        }
        parts.push({
          type: "blank",
          index: blankIndex++
        });
        lastIndex = regex.lastIndex;
      }
      if (lastIndex < props.question.sentence.length) {
        parts.push({
          type: "text",
          content: props.question.sentence.slice(lastIndex)
        });
      }
      return parts;
    });
    const hasAllAnswers = computed(() => {
      if (!props.question?.correctAnswers) return false;
      return userAnswers.value.length === props.question.correctAnswers.length && userAnswers.value.every((answer) => answer && answer.trim() !== "");
    });
    const hasIncorrectAnswers = computed(() => {
      if (!props.question?.correctAnswers) return false;
      return userAnswers.value.some(
        (answer, index) => answer.toLowerCase().trim() !== props.question.correctAnswers[index].toLowerCase().trim()
      );
    });
    const correctCount = computed(() => {
      if (!props.question?.correctAnswers) return 0;
      return userAnswers.value.filter(
        (answer, index) => answer.toLowerCase().trim() === props.question.correctAnswers[index].toLowerCase().trim()
      ).length;
    });
    const isBlankPart = (part) => {
      return part.type === "blank";
    };
    const isAnswerCorrect = (index) => {
      if (!showAnswer.value || !userAnswers.value[index] || !props.question?.correctAnswers?.[index]) return false;
      return userAnswers.value[index].toLowerCase().trim() === props.question.correctAnswers[index].toLowerCase().trim();
    };
    const insertWord = (word) => {
      if (focusedBlankIndex.value !== null) {
        userAnswers.value[focusedBlankIndex.value] = word;
      } else {
        const emptyIndex = userAnswers.value.findIndex((answer) => !answer || answer.trim() === "");
        if (emptyIndex !== -1) {
          userAnswers.value[emptyIndex] = word;
        }
      }
    };
    const clearAnswers = () => {
      userAnswers.value = [];
    };
    const checkAnswer = () => {
      if (!hasAllAnswers.value || !props.question?.correctAnswers) return;
      showAnswer.value = true;
      const isCorrect = correctCount.value === props.question.correctAnswers.length;
      emit("answer", {
        isCorrect,
        userAnswer: [...userAnswers.value],
        correctAnswer: [...props.question.correctAnswers]
      });
    };
    const nextQuestion = () => {
      if (props.questionIndex === props.totalQuestions - 1) {
        emit("complete");
      } else {
        userAnswers.value = [];
        showAnswer.value = false;
        showHint.value = false;
        focusedBlankIndex.value = null;
        emit("next");
      }
    };
    const playSentenceAudio = async () => {
      try {
        let completeSentence = props.question.sentence;
        props.question.correctAnswers.forEach((answer, index) => {
          completeSentence = completeSentence.replace(/___+/, answer);
        });
        await playAudio(completeSentence);
      } catch (error) {
        console.error("Error playing audio:", error);
      }
    };
    watch(() => props.question, (newQuestion) => {
      if (newQuestion && newQuestion.correctAnswers && newQuestion.correctAnswers.length > 0) {
        userAnswers.value = new Array(newQuestion.correctAnswers.length).fill("");
      }
    }, { immediate: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$M, [
        createBaseVNode("div", _hoisted_2$J, [
          createBaseVNode("h3", _hoisted_3$H, toDisplayString$1(tf("grammar.practice.fillBlank.instruction", "Fill in the blanks")), 1),
          createBaseVNode("div", _hoisted_4$F, [
            createBaseVNode("div", _hoisted_5$D, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(sentenceParts.value, (part, index) => {
                return openBlock(), createElementBlock("span", { key: index }, [
                  part.type === "text" ? (openBlock(), createElementBlock("span", _hoisted_6$B, toDisplayString$1(part.content), 1)) : part.type === "blank" ? withDirectives((openBlock(), createElementBlock("input", {
                    key: 1,
                    "onUpdate:modelValue": ($event) => userAnswers.value[part.index] = $event,
                    class: normalizeClass([
                      "inline-block mx-1 px-3 py-1 border-b-2 bg-transparent text-center min-w-20 focus:outline-none transition-colors",
                      showAnswer.value ? isAnswerCorrect(part.index) ? "border-green-500 text-green-600 dark:text-green-400" : "border-red-500 text-red-600 dark:text-red-400" : "border-blue-500 focus:border-blue-600"
                    ]),
                    placeholder: `(${part.index + 1})`,
                    disabled: showAnswer.value
                  }, null, 10, _hoisted_7$A)), [
                    [vModelText, userAnswers.value[part.index]]
                  ]) : createCommentVNode("", true)
                ]);
              }), 128))
            ])
          ]),
          _ctx.question.wordBank && _ctx.question.wordBank.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_8$A, [
            createBaseVNode("h4", _hoisted_9$z, toDisplayString$1(tf("grammar.practice.fillBlank.wordBank", "Word bank")), 1),
            createBaseVNode("div", _hoisted_10$y, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.question.wordBank, (word) => {
                return openBlock(), createElementBlock("button", {
                  key: word,
                  onClick: ($event) => insertWord(word),
                  disabled: showAnswer.value,
                  class: "px-3 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-lg hover:bg-blue-200 dark:hover:bg-blue-900/50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                }, toDisplayString$1(word), 9, _hoisted_11$y);
              }), 128))
            ])
          ])) : createCommentVNode("", true),
          _ctx.question.audio ? (openBlock(), createElementBlock("div", _hoisted_12$x, [
            createBaseVNode("button", {
              onClick: playSentenceAudio,
              class: "flex items-center space-x-2 px-4 py-2 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-lg hover:bg-blue-200 dark:hover:bg-blue-900/50 transition-colors"
            }, [
              _cache[1] || (_cache[1] = createBaseVNode("svg", {
                class: "w-5 h-5",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M15.536 8.464a5 5 0 010 7.072m-2.036-5.036a2.5 2.5 0 010 3.536M6 10h4l4.5-4.5v9L10 10H6V8z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.playAudio", "Play audio")), 1)
            ])
          ])) : createCommentVNode("", true)
        ]),
        showAnswer.value ? (openBlock(), createElementBlock("div", _hoisted_13$x, [
          createBaseVNode("div", _hoisted_14$x, [
            createBaseVNode("h4", _hoisted_15$t, toDisplayString$1(tf("grammar.practice.correctAnswers", "Correct answers")), 1),
            createBaseVNode("div", _hoisted_16$s, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(sentenceParts.value, (part, index) => {
                return openBlock(), createElementBlock("span", {
                  key: `correct-${index}`
                }, [
                  part.type === "text" ? (openBlock(), createElementBlock("span", _hoisted_17$s, toDisplayString$1(part.content), 1)) : part.type === "blank" ? (openBlock(), createElementBlock("span", _hoisted_18$r, toDisplayString$1(_ctx.question.correctAnswers[part.index]), 1)) : createCommentVNode("", true)
                ]);
              }), 128))
            ])
          ]),
          hasIncorrectAnswers.value ? (openBlock(), createElementBlock("div", _hoisted_19$r, [
            createBaseVNode("h4", _hoisted_20$r, toDisplayString$1(tf("grammar.practice.yourAnswers", "Your answers")), 1),
            createBaseVNode("div", _hoisted_21$r, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(sentenceParts.value, (part, index) => {
                return openBlock(), createElementBlock("span", {
                  key: `user-${index}`
                }, [
                  part.type === "text" ? (openBlock(), createElementBlock("span", _hoisted_22$p, toDisplayString$1(part.content), 1)) : isBlankPart(part) ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass([
                      "inline-block mx-1 px-2 py-1 rounded border font-medium",
                      isAnswerCorrect(part.index) ? "bg-green-100 dark:bg-green-800 text-green-700 dark:text-green-300" : "bg-red-100 dark:bg-red-800 text-red-700 dark:text-red-300"
                    ])
                  }, toDisplayString$1(userAnswers.value[part.index] || "(empty)"), 3)) : createCommentVNode("", true)
                ]);
              }), 128))
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        showAnswer.value && _ctx.question.explanation ? (openBlock(), createElementBlock("div", _hoisted_23$p, [
          createBaseVNode("h4", _hoisted_24$o, toDisplayString$1(tf("grammar.practice.explanation", "Explanation")), 1),
          createBaseVNode("p", _hoisted_25$o, toDisplayString$1(_ctx.question.explanation), 1)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_26$m, [
          createBaseVNode("div", _hoisted_27$l, [
            !showAnswer.value && _ctx.question.hint ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: _cache[0] || (_cache[0] = ($event) => showHint.value = !showHint.value),
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-gray-600 dark:text-white/60 hover:text-gray-800 dark:hover:text-white transition-colors"
            }, [
              _cache[2] || (_cache[2] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.hint", "Hint")), 1)
            ])) : createCommentVNode("", true),
            showHint.value && _ctx.question.hint ? (openBlock(), createElementBlock("div", _hoisted_28$l, "  " + toDisplayString$1(_ctx.question.hint), 1)) : createCommentVNode("", true),
            !showAnswer.value ? (openBlock(), createElementBlock("button", {
              key: 2,
              onClick: clearAnswers,
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-gray-600 dark:text-white/60 hover:text-gray-800 dark:hover:text-white transition-colors"
            }, [
              _cache[3] || (_cache[3] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.clear", "Clear")), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_29$j, [
            !showAnswer.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: checkAnswer,
              disabled: !hasAllAnswers.value,
              class: "px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 dark:disabled:bg-white/20 disabled:cursor-not-allowed transition-colors"
            }, toDisplayString$1(tf("grammar.practice.checkAnswer", "Check answer")), 9, _hoisted_30$i)) : (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: nextQuestion,
              class: "px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            }, toDisplayString$1(_ctx.questionIndex === _ctx.totalQuestions - 1 ? tf("grammar.practice.finish", "Finish") : tf("grammar.practice.next", "Next")), 1))
          ])
        ])
      ]);
    };
  }
});

const FillBlankExercise = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$M
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$L = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-white/10 p-6" };
const _hoisted_2$I = { class: "mb-6" };
const _hoisted_3$G = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_4$E = { class: "bg-gray-50 dark:bg-[#0a0a0a]/50 rounded-lg p-4 mb-4" };
const _hoisted_5$C = { class: "text-center" };
const _hoisted_6$A = { class: "text-2xl font-bold text-gray-900 dark:text-white mb-2" };
const _hoisted_7$z = {
  key: 0,
  class: "text-lg text-blue-600 dark:text-blue-400 mb-4"
};
const _hoisted_8$z = { class: "text-center" };
const _hoisted_9$y = { class: "mb-6" };
const _hoisted_10$x = { class: "text-center" };
const _hoisted_11$x = ["disabled"];
const _hoisted_12$w = {
  key: 0,
  class: "w-10 h-10 text-gray-600 dark:text-white/60",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_13$w = {
  key: 1,
  class: "w-10 h-10 text-red-600",
  fill: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_14$w = {
  key: 2,
  class: "w-10 h-10 text-blue-600 animate-spin",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _hoisted_15$s = { class: "text-sm text-gray-600 dark:text-white/60 mb-2" };
const _hoisted_16$r = {
  key: 0,
  class: "text-lg font-mono text-blue-600 dark:text-blue-400"
};
const _hoisted_17$r = {
  key: 0,
  class: "mb-6"
};
const _hoisted_18$q = { class: "bg-blue-50 dark:bg-blue-900/30 rounded-lg p-4" };
const _hoisted_19$q = { class: "flex items-center justify-between" };
const _hoisted_20$q = { class: "flex items-center space-x-3" };
const _hoisted_21$q = { class: "text-blue-700 dark:text-blue-300 font-medium" };
const _hoisted_22$o = {
  key: 1,
  class: "mb-6"
};
const _hoisted_23$o = { class: "flex items-center justify-between mb-3" };
const _hoisted_24$n = { class: "w-full bg-gray-200 dark:bg-white/10 rounded-full h-3 mb-3" };
const _hoisted_25$n = {
  key: 2,
  class: "mb-6"
};
const _hoisted_26$l = {
  key: 0,
  class: "mt-3 p-4 bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded-lg"
};
const _hoisted_27$k = { class: "space-y-2" };
const _hoisted_28$k = { class: "flex justify-between items-center" };
const _hoisted_29$i = { class: "flex space-x-4" };
const _hoisted_30$h = { class: "flex space-x-4" };
const _hoisted_31$h = ["disabled"];
const _sfc_main$L = /* @__PURE__ */ defineComponent({
  __name: "PronunciationExercise",
  props: {
    question: {},
    questionIndex: {},
    totalQuestions: {}
  },
  emits: ["answer", "next", "complete"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      try {
        const translated = t(key, params);
        return typeof translated === "string" && translated !== key ? translated : fallback;
      } catch {
        return fallback;
      }
    };
    const { playAudio } = useVoiceStore();
    const props = __props;
    const emit = __emit;
    const isMounted = ref(true);
    const isRecording = ref(false);
    const isProcessing = ref(false);
    const recordedAudio = ref(null);
    const recordingDuration = ref(0);
    const pronunciationScore = ref(null);
    const showTips = ref(false);
    const mediaRecorder = ref(null);
    const audioChunks = ref([]);
    const recordingTimer = ref(null);
    const recordingStatus = computed(() => {
      if (isProcessing.value) return tf("grammar.practice.pronunciation.processing", "Processing...");
      if (isRecording.value) return tf("grammar.practice.pronunciation.recording", "Recording...");
      if (recordedAudio.value) return tf("grammar.practice.pronunciation.recorded", "Recorded");
      return tf("grammar.practice.pronunciation.ready", "Ready to record");
    });
    const toggleRecording = async () => {
      if (!isRecording.value) {
        await startRecording();
      } else {
        stopRecording();
      }
    };
    const startRecording = async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder.value = new MediaRecorder(stream);
        audioChunks.value = [];
        recordingDuration.value = 0;
        mediaRecorder.value.ondataavailable = (event) => {
          audioChunks.value.push(event.data);
        };
        mediaRecorder.value.onstop = () => {
          const audioBlob = new Blob(audioChunks.value, { type: "audio/wav" });
          recordedAudio.value = audioBlob;
          stream.getTracks().forEach((track) => track.stop());
        };
        mediaRecorder.value.start();
        isRecording.value = true;
        recordingTimer.value = setInterval(() => {
          recordingDuration.value += 1;
          if (recordingDuration.value >= 10) {
            stopRecording();
          }
        }, 1e3);
      } catch (error) {
        console.error("Error accessing microphone:", error);
        alert(tf("grammar.practice.pronunciation.microphoneError", "Unable to access microphone. Please check your browser permissions and try again."));
      }
    };
    const stopRecording = () => {
      if (mediaRecorder.value && mediaRecorder.value.state !== "inactive") {
        mediaRecorder.value.stop();
      }
      isRecording.value = false;
      if (recordingTimer.value) {
        clearInterval(recordingTimer.value);
        recordingTimer.value = null;
      }
    };
    const playTargetAudio = async () => {
      try {
        await playAudio(props.question.targetText);
      } catch (error) {
        console.error("Error playing target audio:", error);
      }
    };
    const playRecordedAudio = () => {
      if (recordedAudio.value) {
        const audio = new Audio(URL.createObjectURL(recordedAudio.value));
        audio.play();
      }
    };
    const clearRecording = () => {
      recordedAudio.value = null;
      recordingDuration.value = 0;
      pronunciationScore.value = null;
    };
    const analyzePronunciation = async () => {
      if (!recordedAudio.value) return;
      isProcessing.value = true;
      try {
        await new Promise((resolve) => setTimeout(resolve, 2e3));
        const mockScore = Math.floor(Math.random() * 40) + 60;
        pronunciationScore.value = mockScore;
        emit("answer", {
          isCorrect: mockScore >= 70,
          score: mockScore,
          targetText: props.question.targetText
        });
      } catch (error) {
        console.error("Error analyzing pronunciation:", error);
      } finally {
        isProcessing.value = false;
      }
    };
    const getFeedbackMessage = () => {
      if (pronunciationScore.value === null) return "";
      if (pronunciationScore.value >= 90) {
        return tf("grammar.practice.pronunciation.excellent", "Excellent pronunciation!");
      } else if (pronunciationScore.value >= 80) {
        return tf("grammar.practice.pronunciation.good", "Good pronunciation!");
      } else if (pronunciationScore.value >= 70) {
        return tf("grammar.practice.pronunciation.fair", "Fair pronunciation. Keep practicing!");
      } else {
        return tf("grammar.practice.pronunciation.needsImprovement", "Needs improvement. Try again!");
      }
    };
    const resetExercise = () => {
      clearRecording();
      showTips.value = false;
    };
    const nextQuestion = () => {
      if (props.questionIndex === props.totalQuestions - 1) {
        emit("complete");
      } else {
        resetExercise();
        emit("next");
      }
    };
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    };
    onUnmounted(() => {
      isMounted.value = false;
      if (recordingTimer.value) {
        clearInterval(recordingTimer.value);
        recordingTimer.value = null;
      }
      if (mediaRecorder.value && mediaRecorder.value.state !== "inactive") {
        try {
          mediaRecorder.value.stop();
        } catch (error) {
          console.warn("Error stopping media recorder:", error);
        }
      }
      mediaRecorder.value = null;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$L, [
        createBaseVNode("div", _hoisted_2$I, [
          createBaseVNode("h3", _hoisted_3$G, toDisplayString$1(tf("grammar.practice.pronunciation.instruction", "Pronounce the following correctly")), 1),
          createBaseVNode("div", _hoisted_4$E, [
            createBaseVNode("div", _hoisted_5$C, [
              createBaseVNode("div", _hoisted_6$A, toDisplayString$1(_ctx.question.targetText), 1),
              _ctx.question.phonetic ? (openBlock(), createElementBlock("div", _hoisted_7$z, toDisplayString$1(_ctx.question.phonetic), 1)) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_8$z, [
              createBaseVNode("button", {
                onClick: playTargetAudio,
                class: "inline-flex items-center space-x-2 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
              }, [
                _cache[1] || (_cache[1] = createBaseVNode("svg", {
                  class: "w-5 h-5",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M15.536 8.464a5 5 0 010 7.072m-2.036-5.036a2.5 2.5 0 010 3.536M6 10h4l4.5-4.5v9L10 10H6V8z"
                  })
                ], -1)),
                createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.pronunciation.listen", "Listen")), 1)
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_9$y, [
          createBaseVNode("div", _hoisted_10$x, [
            createBaseVNode("button", {
              onClick: toggleRecording,
              disabled: isProcessing.value,
              class: normalizeClass([
                "w-24 h-24 rounded-full border-4 flex items-center justify-center transition-all duration-200 mb-4",
                isRecording.value ? "border-red-500 bg-red-100 dark:bg-red-900/30 animate-pulse" : "border-gray-300 dark:border-white/10 bg-gray-100 dark:bg-[#0a0a0a] hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/30",
                isProcessing.value ? "opacity-50 cursor-not-allowed" : "cursor-pointer"
              ])
            }, [
              !isRecording.value && !isProcessing.value ? (openBlock(), createElementBlock("svg", _hoisted_12$w, _cache[2] || (_cache[2] = [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"
                }, null, -1)
              ]))) : isRecording.value ? (openBlock(), createElementBlock("svg", _hoisted_13$w, _cache[3] || (_cache[3] = [
                createBaseVNode("rect", {
                  x: "6",
                  y: "6",
                  width: "12",
                  height: "12",
                  rx: "2"
                }, null, -1)
              ]))) : (openBlock(), createElementBlock("svg", _hoisted_14$w, _cache[4] || (_cache[4] = [
                createBaseVNode("circle", {
                  class: "opacity-25",
                  cx: "12",
                  cy: "12",
                  r: "10",
                  stroke: "currentColor",
                  "stroke-width": "4"
                }, null, -1),
                createBaseVNode("path", {
                  class: "opacity-75",
                  fill: "currentColor",
                  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                }, null, -1)
              ])))
            ], 10, _hoisted_11$x),
            createBaseVNode("div", _hoisted_15$s, toDisplayString$1(recordingStatus.value), 1),
            isRecording.value || recordingDuration.value > 0 ? (openBlock(), createElementBlock("div", _hoisted_16$r, toDisplayString$1(formatTime(recordingDuration.value)), 1)) : createCommentVNode("", true)
          ])
        ]),
        recordedAudio.value && !isRecording.value ? (openBlock(), createElementBlock("div", _hoisted_17$r, [
          createBaseVNode("div", _hoisted_18$q, [
            createBaseVNode("div", _hoisted_19$q, [
              createBaseVNode("div", _hoisted_20$q, [
                createBaseVNode("button", {
                  onClick: playRecordedAudio,
                  class: "p-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
                }, _cache[5] || (_cache[5] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M14.828 14.828a4 4 0 01-5.656 0M9 10h1m4 0h1m-6 4h8m2-10V9a2 2 0 01-2 2H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2z"
                    })
                  ], -1)
                ])),
                createBaseVNode("span", _hoisted_21$q, toDisplayString$1(tf("grammar.practice.pronunciation.yourRecording", "Your recording")), 1)
              ]),
              createBaseVNode("button", {
                onClick: clearRecording,
                class: "p-2 text-gray-500 dark:text-white/60 hover:text-red-600 dark:hover:text-red-400 transition-colors"
              }, _cache[6] || (_cache[6] = [
                createBaseVNode("svg", {
                  class: "w-5 h-5",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                  })
                ], -1)
              ]))
            ])
          ])
        ])) : createCommentVNode("", true),
        pronunciationScore.value !== null ? (openBlock(), createElementBlock("div", _hoisted_22$o, [
          createBaseVNode("div", {
            class: normalizeClass([
              "p-4 rounded-lg border",
              pronunciationScore.value >= 80 ? "bg-green-50 dark:bg-green-900/30 border-green-200 dark:border-green-700" : pronunciationScore.value >= 60 ? "bg-yellow-50 dark:bg-yellow-900/30 border-yellow-200 dark:border-yellow-700" : "bg-red-50 dark:bg-red-900/30 border-red-200 dark:border-red-700"
            ])
          }, [
            createBaseVNode("div", _hoisted_23$o, [
              createBaseVNode("h4", {
                class: normalizeClass([
                  "font-medium",
                  pronunciationScore.value >= 80 ? "text-green-800 dark:text-green-200" : pronunciationScore.value >= 60 ? "text-yellow-800 dark:text-yellow-200" : "text-red-800 dark:text-red-200"
                ])
              }, toDisplayString$1(unref(t)("grammar.practice.pronunciation.feedback")), 3),
              createBaseVNode("div", {
                class: normalizeClass([
                  "text-2xl font-bold",
                  pronunciationScore.value >= 80 ? "text-green-600 dark:text-green-400" : pronunciationScore.value >= 60 ? "text-yellow-600 dark:text-yellow-400" : "text-red-600 dark:text-red-400"
                ])
              }, toDisplayString$1(pronunciationScore.value) + "% ", 3)
            ]),
            createBaseVNode("div", _hoisted_24$n, [
              createBaseVNode("div", {
                class: normalizeClass([
                  "h-3 rounded-full transition-all duration-500",
                  pronunciationScore.value >= 80 ? "bg-green-600" : pronunciationScore.value >= 60 ? "bg-yellow-600" : "bg-red-600"
                ]),
                style: normalizeStyle({ width: `${pronunciationScore.value}%` })
              }, null, 6)
            ]),
            createBaseVNode("p", {
              class: normalizeClass([
                "text-sm",
                pronunciationScore.value >= 80 ? "text-green-700 dark:text-green-300" : pronunciationScore.value >= 60 ? "text-yellow-700 dark:text-yellow-300" : "text-red-700 dark:text-red-300"
              ])
            }, toDisplayString$1(getFeedbackMessage()), 3)
          ], 2)
        ])) : createCommentVNode("", true),
        _ctx.question.tips && _ctx.question.tips.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_25$n, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => showTips.value = !showTips.value),
            class: "flex items-center space-x-2 text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 transition-colors"
          }, [
            _cache[7] || (_cache[7] = createBaseVNode("svg", {
              class: "w-5 h-5",
              fill: "none",
              stroke: "currentColor",
              viewBox: "0 0 24 24"
            }, [
              createBaseVNode("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
              })
            ], -1)),
            createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.pronunciation.tips", "Tips")), 1)
          ]),
          showTips.value ? (openBlock(), createElementBlock("div", _hoisted_26$l, [
            createBaseVNode("ul", _hoisted_27$k, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.question.tips, (tip) => {
                return openBlock(), createElementBlock("li", {
                  key: tip,
                  class: "text-sm text-blue-700 dark:text-blue-300 flex items-start space-x-2"
                }, [
                  _cache[8] || (_cache[8] = createBaseVNode("span", { class: "text-blue-500 mt-1" }, "", -1)),
                  createBaseVNode("span", null, toDisplayString$1(tip), 1)
                ]);
              }), 128))
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_28$k, [
          createBaseVNode("div", _hoisted_29$i, [
            pronunciationScore.value !== null && pronunciationScore.value < 80 ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: resetExercise,
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 transition-colors"
            }, [
              _cache[9] || (_cache[9] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.pronunciation.tryAgain", "Try again")), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_30$h, [
            pronunciationScore.value === null ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: analyzePronunciation,
              disabled: !recordedAudio.value,
              class: "px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            }, toDisplayString$1(tf("grammar.practice.pronunciation.analyze", "Analyze pronunciation")), 9, _hoisted_31$h)) : (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: nextQuestion,
              class: "px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            }, toDisplayString$1(_ctx.questionIndex === _ctx.totalQuestions - 1 ? tf("grammar.practice.finish", "Finish") : tf("grammar.practice.next", "Next")), 1))
          ])
        ])
      ]);
    };
  }
});

const PronunciationExercise = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$L
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$K = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-white/10 p-6" };
const _hoisted_2$H = { class: "mb-8" };
const _hoisted_3$F = { class: "flex items-center justify-between mb-4" };
const _hoisted_4$D = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_5$B = { class: "flex items-center space-x-4" };
const _hoisted_6$z = { class: "text-sm text-gray-500 dark:text-white/60" };
const _hoisted_7$y = { class: "bg-gray-50 dark:bg-[#0a0a0a]/50 rounded-lg p-6 max-h-96 overflow-y-auto" };
const _hoisted_8$y = { class: "prose dark:prose-invert max-w-none" };
const _hoisted_9$x = ["innerHTML"];
const _hoisted_10$w = { class: "space-y-6" };
const _hoisted_11$w = { class: "text-lg font-semibold text-gray-900 dark:text-white border-b border-gray-200 dark:border-white/10 pb-2" };
const _hoisted_12$v = { class: "space-y-6" };
const _hoisted_13$v = { class: "mb-4" };
const _hoisted_14$v = { class: "font-medium text-gray-900 dark:text-white mb-2" };
const _hoisted_15$r = {
  key: 0,
  class: "space-y-2"
};
const _hoisted_16$q = ["name", "value", "onUpdate:modelValue", "disabled"];
const _hoisted_17$q = { class: "text-gray-900 dark:text-white" };
const _hoisted_18$p = { class: "ml-auto" };
const _hoisted_19$p = {
  key: 0,
  class: "w-5 h-5 text-green-600 dark:text-green-400",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_20$p = {
  key: 1,
  class: "w-5 h-5 text-red-600 dark:text-red-400",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_21$p = {
  key: 1,
  class: "space-y-2"
};
const _hoisted_22$n = ["name", "value", "onUpdate:modelValue", "disabled"];
const _hoisted_23$n = { class: "text-gray-900 dark:text-white" };
const _hoisted_24$m = {
  key: 2,
  class: "space-y-2"
};
const _hoisted_25$m = ["onUpdate:modelValue", "disabled", "placeholder"];
const _hoisted_26$k = {
  key: 0,
  class: "text-sm text-green-600 dark:text-green-400"
};
const _hoisted_27$j = {
  key: 0,
  class: "mt-4 p-3 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700 rounded-lg"
};
const _hoisted_28$j = { class: "text-sm text-yellow-800 dark:text-yellow-200" };
const _hoisted_29$h = {
  key: 0,
  class: "mt-8 p-4 bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded-lg"
};
const _hoisted_30$g = { class: "grid grid-cols-3 gap-4 text-center" };
const _hoisted_31$g = { class: "text-2xl font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_32$e = { class: "text-sm text-gray-600 dark:text-white/60" };
const _hoisted_33$e = { class: "text-2xl font-bold text-red-600 dark:text-red-400" };
const _hoisted_34$d = { class: "text-sm text-gray-600 dark:text-white/60" };
const _hoisted_35$d = { class: "text-2xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_36$c = { class: "text-sm text-gray-600 dark:text-white/60" };
const _hoisted_37$b = { class: "flex justify-between items-center mt-8" };
const _hoisted_38$b = { class: "flex space-x-4" };
const _hoisted_39$9 = { class: "flex items-center space-x-2 text-sm text-gray-600 dark:text-white/60" };
const _hoisted_40$9 = { class: "flex space-x-4" };
const _hoisted_41$8 = ["disabled"];
const _sfc_main$K = /* @__PURE__ */ defineComponent({
  __name: "ReadingExercise",
  props: {
    question: {},
    questionIndex: {},
    totalQuestions: {}
  },
  emits: ["answer", "next", "complete"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      try {
        const translated = t(key, params);
        return typeof translated === "string" && translated !== key ? translated : fallback;
      } catch {
        return fallback;
      }
    };
    const { playAudio } = useVoiceStore();
    const props = __props;
    const emit = __emit;
    const userAnswers = ref([]);
    const showAnswers = ref(false);
    const showHighlights = ref(false);
    const readingTime = ref(0);
    const timer = ref(null);
    const formattedPassage = computed(() => {
      let passage = props.question.passage;
      if (showHighlights.value && props.question.keywords) {
        props.question.keywords.forEach((keyword) => {
          const regex = new RegExp(`\\b${keyword}\\b`, "gi");
          passage = passage.replace(regex, `<mark class="bg-yellow-200 dark:bg-yellow-700 px-1 rounded">${keyword}</mark>`);
        });
      }
      return passage;
    });
    const hasAllAnswers = computed(() => {
      if (!props.question?.questions) return false;
      return userAnswers.value.length === props.question.questions.length && userAnswers.value.every((answer) => answer !== null && answer !== void 0 && answer !== "");
    });
    const correctAnswers = computed(() => {
      if (!props.question?.questions) return 0;
      return props.question.questions.filter((q, index) => {
        if (q.type === "short-answer") {
          return isShortAnswerCorrect(index);
        }
        return userAnswers.value[index] === q.correctAnswer;
      }).length;
    });
    const incorrectAnswers = computed(() => {
      if (!props.question?.questions) return 0;
      return props.question.questions.length - correctAnswers.value;
    });
    const accuracy = computed(() => {
      return props.question.questions.length > 0 ? Math.round(correctAnswers.value / props.question.questions.length * 100) : 0;
    });
    const isShortAnswerCorrect = (index) => {
      const userAnswer = userAnswers.value[index];
      const correctAnswer = props.question.questions[index].correctAnswer;
      if (!userAnswer || !correctAnswer) return false;
      return userAnswer.toLowerCase().trim() === correctAnswer.toLowerCase().trim();
    };
    const toggleHighlights = () => {
      showHighlights.value = !showHighlights.value;
    };
    const checkAnswers = () => {
      if (!hasAllAnswers.value) return;
      showAnswers.value = true;
      stopTimer();
      const isCorrect = correctAnswers.value === props.question.questions.length;
      emit("answer", {
        isCorrect,
        correctAnswers: correctAnswers.value,
        totalQuestions: props.question.questions.length
      });
    };
    const nextQuestion = () => {
      if (props.questionIndex === props.totalQuestions - 1) {
        emit("complete");
      } else {
        resetExercise();
        emit("next");
      }
    };
    const playPassageAudio = async () => {
      try {
        await playAudio(props.question.passage);
      } catch (error) {
        console.error("Error playing passage audio:", error);
      }
    };
    const resetExercise = () => {
      userAnswers.value = [];
      showAnswers.value = false;
      showHighlights.value = false;
      readingTime.value = 0;
      startTimer();
    };
    const startTimer = () => {
      timer.value = setInterval(() => {
        readingTime.value += 1;
      }, 1e3);
    };
    const stopTimer = () => {
      if (timer.value) {
        clearInterval(timer.value);
        timer.value = null;
      }
    };
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    };
    onMounted(() => {
      if (props.question?.questions && Array.isArray(props.question.questions)) {
        userAnswers.value = new Array(props.question.questions.length).fill(null);
      } else {
        userAnswers.value = [];
      }
      startTimer();
    });
    onUnmounted(() => {
      stopTimer();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$K, [
        createBaseVNode("div", _hoisted_2$H, [
          createBaseVNode("div", _hoisted_3$F, [
            createBaseVNode("h3", _hoisted_4$D, toDisplayString$1(_ctx.question.title || tf("grammar.practice.reading.passage", "Reading passage")), 1),
            createBaseVNode("div", _hoisted_5$B, [
              _ctx.question.audio ? (openBlock(), createElementBlock("button", {
                key: 0,
                onClick: playPassageAudio,
                class: "flex items-center space-x-2 px-3 py-2 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-lg hover:bg-blue-200 dark:hover:bg-blue-900/50 transition-colors"
              }, [
                _cache[0] || (_cache[0] = createBaseVNode("svg", {
                  class: "w-4 h-4",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M15.536 8.464a5 5 0 010 7.072m-2.036-5.036a2.5 2.5 0 010 3.536M6 10h4l4.5-4.5v9L10 10H6V8z"
                  })
                ], -1)),
                createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.reading.listen", "Listen")), 1)
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_6$z, toDisplayString$1(tf("grammar.practice.reading.readingTime", "Reading time")) + ": " + toDisplayString$1(formatTime(readingTime.value)), 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_7$y, [
            createBaseVNode("div", _hoisted_8$y, [
              createBaseVNode("div", {
                innerHTML: formattedPassage.value,
                class: "text-gray-800 dark:text-gray-200 leading-relaxed text-justify"
              }, null, 8, _hoisted_9$x)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_10$w, [
          createBaseVNode("h4", _hoisted_11$w, toDisplayString$1(tf("grammar.practice.reading.questions", "Questions")), 1),
          createBaseVNode("div", _hoisted_12$v, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.question.questions, (q, index) => {
              return openBlock(), createElementBlock("div", {
                key: index,
                class: "border border-gray-200 dark:border-white/10 rounded-lg p-4"
              }, [
                createBaseVNode("div", _hoisted_13$v, [
                  createBaseVNode("h5", _hoisted_14$v, toDisplayString$1(index + 1) + ". " + toDisplayString$1(q.question), 1),
                  q.type === "multiple-choice" ? (openBlock(), createElementBlock("div", _hoisted_15$r, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(q.options, (option, optionIndex) => {
                      return openBlock(), createElementBlock("label", {
                        key: optionIndex,
                        class: normalizeClass([
                          "flex items-start space-x-3 p-3 rounded-lg cursor-pointer transition-all",
                          userAnswers.value[index] === optionIndex ? "bg-blue-50 dark:bg-blue-900/30 border border-blue-300 dark:border-blue-600" : "bg-gray-50 dark:bg-[#0a0a0a]/50 hover:bg-gray-100 dark:hover:bg-[#0a0a0a]/70 border border-transparent",
                          showAnswers.value && optionIndex === q.correctAnswer ? "bg-green-50 dark:bg-green-900/30 border border-green-300 dark:border-green-600" : "",
                          showAnswers.value && userAnswers.value[index] === optionIndex && optionIndex !== q.correctAnswer ? "bg-red-50 dark:bg-red-900/30 border border-red-300 dark:border-red-600" : ""
                        ])
                      }, [
                        withDirectives(createBaseVNode("input", {
                          type: "radio",
                          name: `question-${index}`,
                          value: optionIndex,
                          "onUpdate:modelValue": ($event) => userAnswers.value[index] = $event,
                          disabled: showAnswers.value,
                          class: "mt-1"
                        }, null, 8, _hoisted_16$q), [
                          [vModelRadio, userAnswers.value[index]]
                        ]),
                        createBaseVNode("span", _hoisted_17$q, toDisplayString$1(option), 1),
                        createBaseVNode("div", _hoisted_18$p, [
                          showAnswers.value && optionIndex === q.correctAnswer ? (openBlock(), createElementBlock("svg", _hoisted_19$p, _cache[1] || (_cache[1] = [
                            createBaseVNode("path", {
                              "stroke-linecap": "round",
                              "stroke-linejoin": "round",
                              "stroke-width": "2",
                              d: "M5 13l4 4L19 7"
                            }, null, -1)
                          ]))) : showAnswers.value && userAnswers.value[index] === optionIndex && optionIndex !== q.correctAnswer ? (openBlock(), createElementBlock("svg", _hoisted_20$p, _cache[2] || (_cache[2] = [
                            createBaseVNode("path", {
                              "stroke-linecap": "round",
                              "stroke-linejoin": "round",
                              "stroke-width": "2",
                              d: "M6 18L18 6M6 6l12 12"
                            }, null, -1)
                          ]))) : createCommentVNode("", true)
                        ])
                      ], 2);
                    }), 128))
                  ])) : q.type === "true-false" ? (openBlock(), createElementBlock("div", _hoisted_21$p, [
                    (openBlock(), createElementBlock(Fragment, null, renderList(["true", "false"], (option) => {
                      return createBaseVNode("label", {
                        key: option,
                        class: normalizeClass([
                          "flex items-center space-x-3 p-3 rounded-lg cursor-pointer transition-all",
                          userAnswers.value[index] === option ? "bg-blue-50 dark:bg-blue-900/30 border border-blue-300 dark:border-blue-600" : "bg-gray-50 dark:bg-gray-700/50 hover:bg-gray-100 dark:hover:bg-gray-700 border border-transparent",
                          showAnswers.value && option === q.correctAnswer ? "bg-green-50 dark:bg-green-900/30 border border-green-300 dark:border-green-600" : "",
                          showAnswers.value && userAnswers.value[index] === option && option !== q.correctAnswer ? "bg-red-50 dark:bg-red-900/30 border border-red-300 dark:border-red-600" : ""
                        ])
                      }, [
                        withDirectives(createBaseVNode("input", {
                          type: "radio",
                          name: `question-${index}`,
                          value: option,
                          "onUpdate:modelValue": ($event) => userAnswers.value[index] = $event,
                          disabled: showAnswers.value
                        }, null, 8, _hoisted_22$n), [
                          [vModelRadio, userAnswers.value[index]]
                        ]),
                        createBaseVNode("span", _hoisted_23$n, toDisplayString$1(option === "true" ? tf("grammar.practice.reading.true", "True") : tf("grammar.practice.reading.false", "False")), 1)
                      ], 2);
                    }), 64))
                  ])) : q.type === "short-answer" ? (openBlock(), createElementBlock("div", _hoisted_24$m, [
                    withDirectives(createBaseVNode("input", {
                      "onUpdate:modelValue": ($event) => userAnswers.value[index] = $event,
                      disabled: showAnswers.value,
                      placeholder: tf("grammar.practice.reading.yourAnswer", "Your answer"),
                      class: normalizeClass([
                        "w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                        showAnswers.value ? isShortAnswerCorrect(index) ? "border-green-500 bg-green-50 dark:bg-green-900/30" : "border-red-500 bg-red-50 dark:bg-red-900/30" : "border-gray-300 dark:border-white/10 bg-white dark:bg-[#0a0a0a]",
                        "text-gray-900 dark:text-white"
                      ])
                    }, null, 10, _hoisted_25$m), [
                      [vModelText, userAnswers.value[index]]
                    ]),
                    showAnswers.value && !isShortAnswerCorrect(index) ? (openBlock(), createElementBlock("div", _hoisted_26$k, toDisplayString$1(tf("grammar.practice.reading.correctAnswer", "Correct answer")) + ": " + toDisplayString$1(q.correctAnswer), 1)) : createCommentVNode("", true)
                  ])) : createCommentVNode("", true)
                ]),
                showAnswers.value && q.explanation ? (openBlock(), createElementBlock("div", _hoisted_27$j, [
                  createBaseVNode("p", _hoisted_28$j, [
                    createBaseVNode("strong", null, toDisplayString$1(tf("grammar.practice.explanation", "Explanation")) + ":", 1),
                    createTextVNode(" " + toDisplayString$1(q.explanation), 1)
                  ])
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])
        ]),
        showAnswers.value ? (openBlock(), createElementBlock("div", _hoisted_29$h, [
          createBaseVNode("div", _hoisted_30$g, [
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_31$g, toDisplayString$1(correctAnswers.value), 1),
              createBaseVNode("div", _hoisted_32$e, toDisplayString$1(tf("grammar.practice.reading.correct", "Correct")), 1)
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_33$e, toDisplayString$1(incorrectAnswers.value), 1),
              createBaseVNode("div", _hoisted_34$d, toDisplayString$1(tf("grammar.practice.reading.incorrect", "Incorrect")), 1)
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_35$d, toDisplayString$1(accuracy.value) + "%", 1),
              createBaseVNode("div", _hoisted_36$c, toDisplayString$1(tf("grammar.practice.reading.accuracy", "Accuracy")), 1)
            ])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_37$b, [
          createBaseVNode("div", _hoisted_38$b, [
            createBaseVNode("button", {
              onClick: toggleHighlights,
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-gray-600 dark:text-white/60 hover:text-gray-800 dark:hover:text-white transition-colors"
            }, [
              _cache[3] || (_cache[3] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M7 20l4-16m2 16l4-16M6 9h14M4 15h14"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(showHighlights.value ? tf("grammar.practice.reading.hideHighlights", "Hide highlights") : tf("grammar.practice.reading.showHighlights", "Show highlights")), 1)
            ]),
            createBaseVNode("div", _hoisted_39$9, [
              _cache[4] || (_cache[4] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(formatTime(readingTime.value)), 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_40$9, [
            !showAnswers.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: checkAnswers,
              disabled: !hasAllAnswers.value,
              class: "px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            }, toDisplayString$1(tf("grammar.practice.checkAnswer", "Check answer")), 9, _hoisted_41$8)) : (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: nextQuestion,
              class: "px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            }, toDisplayString$1(_ctx.questionIndex === _ctx.totalQuestions - 1 ? tf("grammar.practice.finish", "Finish") : tf("grammar.practice.next", "Next")), 1))
          ])
        ])
      ]);
    };
  }
});

const ReadingExercise = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$K
}, Symbol.toStringTag, { value: 'Module' }));

/*!
  * vue-draggable-next v2.2.0
  * (c) 2023 Anish George
  * @license MIT
  */

/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var version = "1.14.0";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}

var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};

function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}

function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}

function matches(
/**HTMLElement*/
el,
/**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));

  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }

  return false;
}

function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}

function closest(
/**HTMLElement*/
el,
/**String*/
selector,
/**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;

    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }

      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }

  return null;
}

var R_SPACE = /\s+/g;

function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}

function css(el, prop, val) {
  var style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

function matrix(el, selfOnly) {
  var appliedTransforms = '';

  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */

    } while (!selfOnly && (el = el.parentNode));
  }

  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}

function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;

    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }

    return list;
  }

  return [];
}

function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;

  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */


function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;

  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }

  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */

      } while (container = container.parentNode);
    }
  }

  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;

    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */


function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;

    {
      visible = elSideVal >= parentSideVal;
    }

    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }

  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */


function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
      i = 0,
      children = el.children;

  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }

      currentChild++;
    }

    i++;
  }

  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */


function lastChild(el, selector) {
  var last = el.lastElementChild;

  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }

  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */


function index(el, selector) {
  var index = 0;

  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */


  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }

  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */


function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();

  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }

  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */


function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }

  return -1;
}

function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;

  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);

      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */

  } while (elem = elem.parentNode);

  return getWindowScrollingElement();
}

function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }

  return dst;
}

function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}

var _throttleTimeout;

function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;

      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }

      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}

function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}

function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}

function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;

  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}

var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });

        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);

          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }

        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;

      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }

      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);

        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }

        target.toRect = toRect;

        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate


        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;

          if (!time) {
            time = _this.options.animation;
          }

          _this.animate(target, animatingRect, toRect, time);
        }

        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);

      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }

      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}

function repaint(target) {
  return target.offsetWidth;
}

function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }

    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;

    this.eventCanceled = false;

    evt.cancel = function () {
      _this.eventCanceled = true;
    };

    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined


      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });

    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);

      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;

      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }

  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));

  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }

  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }

  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];

var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, _excluded);

  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};

function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}

var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)
_silent = false,
    savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return; // false when <= IE11

  if (IE11OrLess) {
    return false;
  }

  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }

  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }

  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }

  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},

/**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable)) return;
    var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

      if (value == null && (pull || sameGroup)) {
        // Default pull value
        // Default pull and put value if same group
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }

  var group = {};
  var originalGroup = options.group;

  if (!originalGroup || _typeof(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }

  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


if (documentExists) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}

var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;

    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

    if (nearest) {
      // Create imitation event
      var event = {};

      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }

      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;

      nearest[expando]._onDragOver(event);
    }
  }
};

var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */


function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }

  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }

  _prepareGroup(options); // Bind all private methods


  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode


  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events


  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }

  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }

  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}

Sortable.prototype =
/** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;

    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;

    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


    if (dragEl) {
      return;
    }

    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable


    if (originalTarget.isContentEditable) {
      return;
    } // Safari ignores further event handling after mousedown


    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }

    target = closest(target, options.draggable, el, false);

    if (target && target.animated) {
      return;
    }

    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent


    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });

        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);

        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });

      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`


    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  /** Event */
  evt,
  /** Touch */
  touch,
  /** HTMLElement */
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;

    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';

      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          _this._onDrop();

          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove


        _this._disableDelayedDragEvents();

        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend


        _this._triggerDragStart(evt, touch); // Drag start event


        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item


        toggleClass(dragEl, options.chosenClass, true);
      }; // Disable "draggable"


      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }

      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag


        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;

    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);

    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  /** Event */
  evt,
  /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;

    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }

    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {

    awaitingDragStarted = false;

    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });

      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }

      var options = this.options; // Apply effect

      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;

      _hideGhostForTarget();

      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;

      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }

      dragEl.parentNode[expando]._isOutsideThisEl(target);

      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });

            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }

          target = parent; // store last element
        }
        /* jshint boss:true */
        while (parent = parent.parentNode);
      }

      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }

        this._onDragStart(evt, true);
      }

      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }

        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }

      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;

        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }

        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }

        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }

      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  /**Event*/
  evt,
  /**boolean*/
  fallback) {
    var _this = this;

    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });

    if (Sortable.eventCanceled) {
      this._onDrop();

      return;
    }

    pluginEvent('setupClone', this);

    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';

      this._hideClone();

      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround


    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;

      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }

      _this._hideClone();

      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);

      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }

      on(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }

    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;

    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(
  /**Event*/
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;

    if (_silent) return;

    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state


    function capture() {
      dragOverEvent('dragOverAnimationCapture');

      _this.captureAnimationState();

      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)


    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }

        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }

        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation


        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }

        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });

        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element


      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback


      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


        !insertion && nearestEmptyInsertDetectEvent(evt);
      }

      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted


    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);

      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }

    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }

    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;

    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }

    ignoreNextClick = false;

    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;

      if (revert) {
        parentEl = rootEl; // actualization

        capture();

        this._hideClone();

        dragOverEvent('revert');

        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }

        return completed(true);
      }

      var elLastChild = lastChild(el, options.draggable);

      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // if there is a last element, it is the target


        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }

        if (target) {
          targetRect = getRect(target);
        }

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);

        if (firstChild === dragEl) {
          return completed(false);
        }

        target = firstChild;
        targetRect = getRect(target);

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }

        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;

        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);

          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert


        if (direction === 0 || sibling === target) {
          return completed(false);
        }

        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;

        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }

          _silent = true;
          setTimeout(_unsilent, 30);
          capture();

          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)


          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }

          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }

          changed();
          return completed(true);
        }
      }

      if (el.contains(dragEl)) {
        return completed(false);
      }
    }

    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  /**Event*/
  evt) {
    var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);

    if (Sortable.eventCanceled) {
      this._nulling();

      return;
    }

    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);

    _cancelNextTick(this.cloneId);

    _cancelNextTick(this._dragStartId); // Unbind events


    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }

    this._offMoveEvents();

    this._offUpEvents();

    if (Safari) {
      css(document.body, 'user-select', '');
    }

    css(dragEl, 'transform', '');

    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }

      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }

      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }

        _disableDraggable(dragEl);

        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }

        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });

        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event


            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another


            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }

          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }

        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }

          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting


          this.save();
        }
      }
    }

    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);

        break;

      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);

          _globalDragOver(evt);
        }

        break;

      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },

  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;

    for (; i < n; i++) {
      el = children[i];

      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }

    return order;
  },

  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];

      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },

  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },

  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },

  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;

    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);

      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }

      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },

  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);

    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes


    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });

    this._onDrop();

    this._disableDelayedDragEvents();

    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');

      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }

      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();

      return;
    }

    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }

      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }

      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};

function _globalDragOver(
/**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }

  evt.cancelable && evt.preventDefault();
}

function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }

  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);

  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }

  return retVal;
}

function _disableDraggable(el) {
  el.draggable = false;
}

function _unsilent() {
  _silent = false;
}

function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}

function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;

  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }

      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }

  invert = invert || invertSwap;

  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }

  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */


function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */


function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;

  while (i--) {
    sum += str.charCodeAt(i);
  }

  return sum.toString(36);
}

function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;

  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}

function _nextTick(fn) {
  return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:


if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils


Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */


Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }

    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */


Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export


Sortable.version = version;

var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;

function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }

  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;

      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;

      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }

      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;

      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);

        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }

            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }

        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}

function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}

function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}

var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;

    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }

  var layersOut = 0;
  var currentParent = scrollEl;

  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;

    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }

    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }

    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);

      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }

          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }

    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();

  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};

function Revert() {}

Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();

    if (putSortable) {
      putSortable.captureAnimationState();
    }

    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }

    this.sortable.animateAll();

    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};

_extends(Revert, {
  pluginName: 'revertOnSpill'
});

function Remove() {}

Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};

_extends(Remove, {
  pluginName: 'removeOnSpill'
});

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

function getConsole() {
    if (typeof window !== 'undefined') {
        return window.console;
    }
    return global.console;
}
const console$1 = getConsole();
function cached(fn) {
    const cache = Object.create(null);
    return function cachedFn(str) {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
}
const regex = /-(\w)/g;
const camelize = cached((str) => str.replace(regex, (_, c) => (c ? c.toUpperCase() : '')));
function removeNode(node) {
    if (node.parentElement !== null) {
        node.parentElement.removeChild(node);
    }
}
function insertNodeAt(fatherNode, node, position) {
    const refNode = position === 0
        ? fatherNode.children[0]
        : fatherNode.children[position - 1].nextSibling;
    fatherNode.insertBefore(node, refNode);
}

function computeVmIndex(vnodes, element) {
    return Object.values(vnodes).indexOf(element);
}
function computeIndexes(slots, children, isTransition, footerOffset) {
    if (!slots) {
        return [];
    }
    const elmFromNodes = Object.values(slots);
    const footerIndex = children.length - footerOffset;
    const rawIndexes = [...children].map((elt, idx) => idx >= footerIndex ? elmFromNodes.length : elmFromNodes.indexOf(elt));
    return rawIndexes;
}
function emit(evtName, evtData) {
    //@ts-ignore
    this.$nextTick(() => this.$emit(evtName.toLowerCase(), evtData));
}
function delegateAndEmit(evtName) {
    //@ts-ignore
    return evtData => {
        //@ts-ignore
        if (this.realList !== null) {
            //@ts-ignore
            this['onDrag' + evtName](evtData);
        }
        //@ts-ignore
        emit.call(this, evtName, evtData);
    };
}
function isTransitionName(name) {
    return ['transition-group', 'TransitionGroup'].includes(name);
}
function isTransition(slots) {
    if (!slots || slots.length !== 1) {
        return false;
    }
    // @ts-ignore
    const [{ type }] = slots;
    if (!type) {
        return false;
    }
    //@ts-ignore
    return isTransitionName(type.name);
}
function getComponentAttributes($attrs, componentData) {
    if (!componentData) {
        return $attrs;
    }
    return { ...componentData.props, ...componentData.attrs };
}
const eventsListened = ['Start', 'Add', 'Remove', 'Update', 'End'];
const eventsToEmit = ['Choose', 'Unchoose', 'Sort', 'Filter', 'Clone'];
const readonlyProperties = ['Move', ...eventsListened, ...eventsToEmit].map(evt => 'on' + evt);
// @ts-ignore
let draggingElement = null;
const props = {
    options: Object,
    list: {
        type: Array,
        required: false,
        default: null,
    },
    noTransitionOnDrag: {
        type: Boolean,
        default: false,
    },
    clone: {
        type: Function,
        default: (original) => {
            return original;
        },
    },
    tag: {
        type: String,
        default: 'div',
    },
    move: {
        type: Function,
        default: null,
    },
    componentData: {
        type: Object,
        required: false,
        default: null,
    },
    component: {
        type: String,
        default: null,
    },
    modelValue: {
        type: Array,
        required: false,
        default: null,
    },
};
const VueDraggableNext = defineComponent({
    name: 'VueDraggableNext',
    inheritAttrs: false,
    emits: [
        'update:modelValue',
        'move',
        'change',
        ...eventsListened.map(s => s.toLowerCase()),
        ...eventsToEmit.map(s => s.toLowerCase()),
    ],
    props,
    data() {
        return {
            transitionMode: false,
            noneFunctionalComponentMode: false,
            headerOffset: 0,
            footerOffset: 0,
            _sortable: {},
            visibleIndexes: [],
            context: {},
        };
    },
    render() {
        const slots = this.$slots.default ? this.$slots.default() : null;
        const attrs = getComponentAttributes(this.$attrs, this.componentData);
        if (!slots)
            return h(this.getTag(), attrs, []);
        this.transitionMode = isTransition(slots);
        return h(this.getTag(), attrs, slots);
    },
    created() {
        if (this.list !== null && this.modelValue !== null) {
            console$1.error('list props are mutually exclusive! Please set one.');
        }
    },
    mounted() {
        const optionsAdded = {};
        eventsListened.forEach(elt => {
            optionsAdded['on' + elt] = delegateAndEmit.call(this, elt);
        });
        eventsToEmit.forEach(elt => {
            optionsAdded['on' + elt] = emit.bind(this, elt);
        });
        const attributes = Object.keys(this.$attrs).reduce((res, key) => {
            res[camelize(key)] = this.$attrs[key];
            return res;
        }, {});
        const options = Object.assign({}, attributes, optionsAdded, {
            onMove: (evt, originalEvent) => {
                return this.onDragMove(evt, originalEvent);
            },
        });
        !('draggable' in options) && (options.draggable = '>*');
        const targetDomElement = this.$el.nodeType === 1 ? this.$el : this.$el.parentElement;
        this._sortable = new Sortable(targetDomElement, options);
        targetDomElement.__draggable_component__ = this;
        this.computeIndexes();
    },
    beforeUnmount() {
        try {
            if (this._sortable !== undefined)
                this._sortable.destroy();
        }
        catch (error) { }
    },
    computed: {
        realList() {
            return this.list ? this.list : this.modelValue;
        },
    },
    watch: {
        $attrs: {
            handler(newOptionValue) {
                this.updateOptions(newOptionValue);
            },
            deep: true,
        },
        realList() {
            this.computeIndexes();
        },
    },
    methods: {
        getTag() {
            return this.component ? resolveComponent(this.component) : this.tag;
        },
        updateOptions(newOptionValue) {
            for (var property in newOptionValue) {
                const value = camelize(property);
                if (readonlyProperties.indexOf(value) === -1) {
                    this._sortable.option(value, newOptionValue[property]);
                }
            }
        },
        getChildrenNodes() {
            return this.$el.children;
        },
        computeIndexes() {
            this.$nextTick(() => {
                this.visibleIndexes = computeIndexes(this.getChildrenNodes(), this.$el.children, this.transitionMode, this.footerOffset);
            });
        },
        getUnderlyingVm(htmlElt) {
            const index = computeVmIndex(this.getChildrenNodes() || [], htmlElt);
            if (index === -1) {
                //Edge case during move callback: related element might be
                //an element different from collection
                return null;
            }
            //@ts-ignore
            const element = this.realList[index];
            return { index, element };
        },
        emitChanges(evt) {
            this.$nextTick(() => {
                this.$emit('change', evt);
            });
        },
        alterList(onList) {
            if (this.list) {
                onList(this.list);
                return;
            }
            const newList = [...this.modelValue];
            onList(newList);
            this.$emit('update:modelValue', newList);
        },
        spliceList() {
            const spliceList = (list) => list.splice(...arguments);
            this.alterList(spliceList);
        },
        updatePosition(oldIndex, newIndex) {
            const updatePosition = (list) => list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);
            this.alterList(updatePosition);
        },
        getVmIndex(domIndex) {
            const indexes = this.visibleIndexes;
            const numberIndexes = indexes.length;
            return domIndex > numberIndexes - 1 ? numberIndexes : indexes[domIndex];
        },
        getComponent() {
            return this.$slots.default
                ? //@ts-ignore
                    this.$slots.default()[0].componentInstance
                : null;
        },
        resetTransitionData(index) {
            if (!this.noTransitionOnDrag || !this.transitionMode) {
                return;
            }
            var nodes = this.getChildrenNodes();
            nodes[index].data = null;
            const transitionContainer = this.getComponent();
            transitionContainer.children = [];
            transitionContainer.kept = undefined;
        },
        onDragStart(evt) {
            this.computeIndexes();
            this.context = this.getUnderlyingVm(evt.item);
            if (!this.context)
                return;
            evt.item._underlying_vm_ = this.clone(this.context.element);
            draggingElement = evt.item;
        },
        onDragAdd(evt) {
            const element = evt.item._underlying_vm_;
            if (element === undefined) {
                return;
            }
            removeNode(evt.item);
            const newIndex = this.getVmIndex(evt.newIndex);
            //@ts-ignore
            this.spliceList(newIndex, 0, element);
            this.computeIndexes();
            const added = { element, newIndex };
            this.emitChanges({ added });
        },
        onDragRemove(evt) {
            insertNodeAt(this.$el, evt.item, evt.oldIndex);
            if (evt.pullMode === 'clone') {
                removeNode(evt.clone);
                return;
            }
            if (!this.context)
                return;
            const oldIndex = this.context.index;
            //@ts-ignore
            this.spliceList(oldIndex, 1);
            const removed = { element: this.context.element, oldIndex };
            this.resetTransitionData(oldIndex);
            this.emitChanges({ removed });
        },
        onDragUpdate(evt) {
            removeNode(evt.item);
            insertNodeAt(evt.from, evt.item, evt.oldIndex);
            //@ts-ignore
            const oldIndex = this.context.index;
            const newIndex = this.getVmIndex(evt.newIndex);
            this.updatePosition(oldIndex, newIndex);
            //@ts-ignore
            const moved = { element: this.context.element, oldIndex, newIndex };
            this.emitChanges({ moved });
        },
        updateProperty(evt, propertyName) {
            evt.hasOwnProperty(propertyName) &&
                (evt[propertyName] += this.headerOffset);
        },
        onDragMove(evt, originalEvent) {
            const onMove = this.move;
            if (!onMove || !this.realList) {
                return true;
            }
            const relatedContext = this.getRelatedContextFromMoveEvent(evt);
            const draggedContext = this.context;
            const futureIndex = this.computeFutureIndex(relatedContext, evt);
            Object.assign(draggedContext, { futureIndex });
            const sendEvt = Object.assign({}, evt, {
                relatedContext,
                draggedContext,
            });
            return onMove(sendEvt, originalEvent);
        },
        onDragEnd() {
            this.computeIndexes();
            draggingElement = null;
        },
        getTrargetedComponent(htmElement) {
            return htmElement.__draggable_component__;
        },
        getRelatedContextFromMoveEvent({ to, related }) {
            const component = this.getTrargetedComponent(to);
            if (!component) {
                return { component };
            }
            const list = component.realList;
            const context = { list, component };
            if (to !== related && list && component.getUnderlyingVm) {
                const destination = component.getUnderlyingVm(related);
                if (destination) {
                    return Object.assign(destination, context);
                }
            }
            return context;
        },
        computeFutureIndex(relatedContext, evt) {
            const domChildren = [...evt.to.children].filter(el => el.style['display'] !== 'none');
            if (domChildren.length === 0)
                return 0;
            const currentDOMIndex = domChildren.indexOf(evt.related);
            const currentIndex = relatedContext.component.getVmIndex(currentDOMIndex);
            const draggedInList = domChildren.indexOf(draggingElement) !== -1;
            return draggedInList || !evt.willInsertAfter
                ? currentIndex
                : currentIndex + 1;
        },
    },
});

const _hoisted_1$J = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-white/10 p-6" };
const _hoisted_2$G = { class: "mb-8" };
const _hoisted_3$E = { class: "text-center" };
const _hoisted_4$C = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_5$A = { class: "bg-gray-50 dark:bg-[#0a0a0a]/50 rounded-lg p-6 mb-4" };
const _hoisted_6$y = { class: "flex items-center justify-center space-x-6 mb-4" };
const _hoisted_7$x = ["disabled"];
const _hoisted_8$x = {
  key: 0,
  class: "w-8 h-8 ml-1",
  fill: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_9$w = {
  key: 1,
  class: "w-8 h-8",
  fill: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_10$v = ["disabled"];
const _hoisted_11$v = { class: "mb-4" };
const _hoisted_12$u = { class: "flex justify-between text-xs text-gray-500 dark:text-white/60 mt-1" };
const _hoisted_13$u = { class: "flex items-center justify-center space-x-4 text-sm text-gray-600 dark:text-white/60" };
const _hoisted_14$u = { class: "flex items-center space-x-1" };
const _hoisted_15$q = {
  key: 0,
  class: "flex items-center space-x-1"
};
const _hoisted_16$p = {
  key: 0,
  class: "text-gray-500 dark:text-white/60"
};
const _hoisted_17$p = {
  key: 0,
  class: "mb-6"
};
const _hoisted_18$o = { class: "block text-sm font-medium text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_19$o = ["placeholder"];
const _hoisted_20$o = { class: "space-y-6" };
const _hoisted_21$o = { class: "text-lg font-semibold text-gray-900 dark:text-white border-b border-gray-200 dark:border-white/10 pb-2" };
const _hoisted_22$m = { class: "space-y-6" };
const _hoisted_23$m = { class: "mb-4" };
const _hoisted_24$l = { class: "font-medium text-gray-900 dark:text-white mb-2" };
const _hoisted_25$l = {
  key: 0,
  class: "space-y-2"
};
const _hoisted_26$j = ["name", "value", "onUpdate:modelValue", "disabled"];
const _hoisted_27$i = { class: "text-gray-900 dark:text-white" };
const _hoisted_28$i = { class: "ml-auto" };
const _hoisted_29$g = {
  key: 0,
  class: "w-5 h-5 text-green-600 dark:text-green-400",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_30$f = {
  key: 1,
  class: "w-5 h-5 text-red-600 dark:text-red-400",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_31$f = {
  key: 1,
  class: "space-y-2"
};
const _hoisted_32$d = ["onUpdate:modelValue", "disabled", "placeholder"];
const _hoisted_33$d = {
  key: 0,
  class: "text-sm text-green-600 dark:text-green-400"
};
const _hoisted_34$c = {
  key: 2,
  class: "space-y-2"
};
const _hoisted_35$c = { class: "text-sm text-gray-600 dark:text-white/60 mb-2" };
const _hoisted_36$b = { class: "flex items-center space-x-3" };
const _hoisted_37$a = { class: "w-6 h-6 bg-blue-600 text-white rounded-full flex items-center justify-center text-sm font-medium" };
const _hoisted_38$a = { class: "text-gray-900 dark:text-white" };
const _hoisted_39$8 = {
  key: 0,
  class: "mt-4 p-3 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700 rounded-lg"
};
const _hoisted_40$8 = { class: "text-sm text-yellow-800 dark:text-yellow-200" };
const _hoisted_41$7 = {
  key: 1,
  class: "mt-8 p-4 bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded-lg"
};
const _hoisted_42$6 = { class: "grid grid-cols-3 gap-4 text-center" };
const _hoisted_43$6 = { class: "text-2xl font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_44$6 = { class: "text-sm text-gray-600 dark:text-white/60" };
const _hoisted_45$5 = { class: "text-2xl font-bold text-red-600 dark:text-red-400" };
const _hoisted_46$5 = { class: "text-sm text-gray-600 dark:text-white/60" };
const _hoisted_47$5 = { class: "text-2xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_48$5 = { class: "text-sm text-gray-600 dark:text-white/60" };
const _hoisted_49$5 = { class: "flex justify-between items-center mt-8" };
const _hoisted_50$5 = { class: "flex space-x-4" };
const _hoisted_51$4 = { class: "flex space-x-4" };
const _hoisted_52$4 = ["disabled"];
const _hoisted_53$4 = {
  key: 2,
  class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
};
const _hoisted_54$4 = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-white/10 p-6 max-w-2xl w-full mx-4 max-h-96 overflow-y-auto" };
const _hoisted_55$4 = { class: "flex items-center justify-between mb-4" };
const _hoisted_56$4 = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_57$4 = { class: "prose dark:prose-invert max-w-none" };
const _hoisted_58$4 = { class: "text-gray-800 dark:text-gray-200 leading-relaxed" };
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  __name: "ListeningExercise",
  props: {
    question: {},
    questionIndex: {},
    totalQuestions: {},
    difficulty: {}
  },
  emits: ["answer", "next", "complete"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      try {
        const translated = t(key, params);
        return typeof translated === "string" && translated !== key ? translated : fallback;
      } catch {
        return fallback;
      }
    };
    const { playAudio } = useVoiceStore();
    let youtubePlayer = null;
    const isYouTubeAudio = ref(false);
    ref("");
    const props = __props;
    const emit = __emit;
    const userAnswers = ref([]);
    const userNotes = ref("");
    const showAnswers = ref(false);
    const showTranscript = ref(false);
    const audioLoaded = ref(false);
    const isPlaying = ref(false);
    const currentTime = ref(0);
    const duration = ref(0);
    const progress = ref(0);
    const playsRemaining = ref(3);
    const audio = ref(null);
    const progressBar = ref(null);
    const youtubePlayerReady = ref(false);
    const hasAllAnswers = computed(() => {
      if (!props.question?.questions) return false;
      return userAnswers.value.length === props.question.questions.length && userAnswers.value.every((answer) => answer !== null && answer !== void 0 && answer !== "");
    });
    const correctAnswers = computed(() => {
      if (!props.question?.questions) return 0;
      return props.question.questions.filter((q, index) => {
        return isAnswerCorrect(index);
      }).length;
    });
    const incorrectAnswers = computed(() => {
      return props.question.questions.length - correctAnswers.value;
    });
    const accuracy = computed(() => {
      return props.question.questions.length > 0 ? Math.round(correctAnswers.value / props.question.questions.length * 100) : 0;
    });
    const playbackSpeed = computed(() => {
      console.log("DEBUG - Question difficulty:", props.question.difficulty);
      console.log("DEBUG - Global difficulty:", props.difficulty);
      console.log("DEBUG - Explicit playbackSpeed:", props.question.playbackSpeed);
      if (props.question.playbackSpeed) {
        console.log("DEBUG - Using explicit playbackSpeed:", props.question.playbackSpeed);
        return props.question.playbackSpeed;
      }
      const difficulty = props.question.difficulty || props.difficulty;
      console.log("DEBUG - Final difficulty used:", difficulty);
      let speed;
      switch (difficulty) {
        case "easy":
          speed = 0.75;
          break;
        case "medium":
          speed = 1;
          break;
        case "hard":
          speed = 3.25;
          break;
        default:
          speed = 1;
      }
      console.log("DEBUG - Computed playback speed:", speed);
      return speed;
    });
    const isAnswerCorrect = (index) => {
      const userAnswer = userAnswers.value[index];
      const correctAnswer = props.question.questions[index].correctAnswer;
      const questionType = props.question.questions[index].type;
      if (questionType === "fill-blank") {
        return userAnswer?.toLowerCase().trim() === correctAnswer?.toLowerCase().trim();
      } else if (questionType === "ordering") {
        return JSON.stringify(userAnswer) === JSON.stringify(correctAnswer);
      }
      return userAnswer === correctAnswer;
    };
    const togglePlayback = () => {
      if (playsRemaining.value <= 0) return;
      if (isYouTubeAudio.value) {
        if (!youtubePlayerReady.value || !youtubePlayer || !youtubePlayer.playVideo || !youtubePlayer.pauseVideo) {
          console.warn("YouTube player not ready yet");
          return;
        }
        if (isPlaying.value) {
          youtubePlayer.pauseVideo();
        } else {
          youtubePlayer.playVideo();
          if (playsRemaining.value > 0) {
            playsRemaining.value--;
          }
        }
        return;
      }
      if (!audio.value) return;
      if (isPlaying.value) {
        audio.value.pause();
      } else {
        audio.value.play();
        if (playsRemaining.value > 0) {
          playsRemaining.value--;
        }
      }
    };
    const restartAudio = () => {
      if (isYouTubeAudio.value) {
        if (youtubePlayer && youtubePlayer.seekTo) {
          youtubePlayer.seekTo(0);
          currentTime.value = 0;
          progress.value = 0;
        }
      } else {
        if (!audio.value) return;
        audio.value.currentTime = 0;
        currentTime.value = 0;
        progress.value = 0;
      }
    };
    const updatePlaybackSpeed = () => {
      console.log("DEBUG - updatePlaybackSpeed called!");
      console.log("DEBUG - Current playbackSpeed.value:", playbackSpeed.value);
      console.log("DEBUG - isYouTubeAudio.value:", isYouTubeAudio.value);
      console.log("DEBUG - audio.value exists:", !!audio.value);
      if (isYouTubeAudio.value) {
        if (youtubePlayer && youtubePlayer.setPlaybackRate) {
          console.log("DEBUG - Setting YouTube playback rate to:", playbackSpeed.value);
          youtubePlayer.setPlaybackRate(parseFloat(playbackSpeed.value.toString()));
        } else {
          console.log("DEBUG - YouTube player not ready for setPlaybackRate");
        }
      } else if (audio.value) {
        console.log("DEBUG - Setting audio playback rate to:", playbackSpeed.value);
        console.log("DEBUG - Audio playbackRate BEFORE setting:", audio.value.playbackRate);
        audio.value.playbackRate = parseFloat(playbackSpeed.value.toString());
        console.log("DEBUG - Audio playbackRate AFTER setting:", audio.value.playbackRate);
        setTimeout(() => {
          console.log("DEBUG - Audio playbackRate after 100ms:", audio.value?.playbackRate);
          if (audio.value && audio.value.playbackRate !== parseFloat(playbackSpeed.value.toString())) {
            console.log("DEBUG - Playback rate was reset! Force re-applying...");
            audio.value.playbackRate = parseFloat(playbackSpeed.value.toString());
            console.log("DEBUG - Force-applied playbackRate:", audio.value.playbackRate);
          }
        }, 100);
      } else {
        console.log("DEBUG - No audio element available to set playback rate");
      }
    };
    const seekAudio = (event) => {
      if (!progressBar.value) return;
      const rect = progressBar.value.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const newTime = clickX / rect.width * duration.value;
      if (isYouTubeAudio.value) {
        if (youtubePlayer && youtubePlayer.seekTo) {
          youtubePlayer.seekTo(newTime, true);
          currentTime.value = newTime;
        }
      } else if (audio.value) {
        audio.value.currentTime = newTime;
        currentTime.value = newTime;
      }
    };
    const updateProgress = () => {
      if (audio.value) {
        currentTime.value = audio.value.currentTime;
        progress.value = duration.value > 0 ? currentTime.value / duration.value * 100 : 0;
      }
    };
    const checkAnswers = () => {
      if (!hasAllAnswers.value) return;
      showAnswers.value = true;
      const isCorrect = correctAnswers.value === props.question.questions.length;
      emit("answer", {
        isCorrect,
        correctAnswers: correctAnswers.value,
        totalQuestions: props.question.questions.length
      });
    };
    const nextQuestion = () => {
      if (props.questionIndex === props.totalQuestions - 1) {
        emit("complete");
      } else {
        resetExercise();
        emit("next");
      }
    };
    const resetExercise = () => {
      userAnswers.value = [];
      userNotes.value = "";
      showAnswers.value = false;
      showTranscript.value = false;
      playsRemaining.value = props.question.maxPlays || 3;
      restartAudio();
    };
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    };
    const createYouTubeAudioPlayer = (videoId) => {
      isYouTubeAudio.value = true;
      const playerContainer = document.createElement("div");
      playerContainer.id = `youtube-player-${Date.now()}`;
      playerContainer.style.position = "absolute";
      playerContainer.style.left = "-9999px";
      playerContainer.style.top = "-9999px";
      playerContainer.style.width = "1px";
      playerContainer.style.height = "1px";
      document.body.appendChild(playerContainer);
      if (!window.YT) {
        const script = document.createElement("script");
        script.src = "https://www.youtube.com/iframe_api";
        document.head.appendChild(script);
        window.onYouTubeIframeAPIReady = () => {
          initYouTubePlayer(videoId, playerContainer.id);
        };
      } else {
        initYouTubePlayer(videoId, playerContainer.id);
      }
    };
    const initYouTubePlayer = (videoId, containerId) => {
      youtubePlayer = new window.YT.Player(containerId, {
        height: "1",
        width: "1",
        videoId,
        playerVars: {
          autoplay: 0,
          controls: 0,
          disablekb: 1,
          fs: 0,
          iv_load_policy: 3,
          modestbranding: 1,
          rel: 0,
          showinfo: 0
        },
        events: {
          onReady: (event) => {
            audioLoaded.value = true;
            youtubePlayerReady.value = true;
            duration.value = event.target.getDuration() || 0;
            updatePlaybackSpeed();
          },
          onStateChange: (event) => {
            const state = event.data;
            if (state === window.YT.PlayerState.PLAYING) {
              isPlaying.value = true;
            } else if (state === window.YT.PlayerState.PAUSED || state === window.YT.PlayerState.ENDED) {
              isPlaying.value = false;
              if (state === window.YT.PlayerState.ENDED) {
                currentTime.value = 0;
                progress.value = 0;
              }
            }
          }
        }
      });
      const updateYouTubeProgress = () => {
        if (youtubePlayer && youtubePlayer.getCurrentTime && isPlaying.value) {
          const current = youtubePlayer.getCurrentTime();
          currentTime.value = current;
          if (duration.value > 0) {
            progress.value = current / duration.value * 100;
          }
        }
      };
      setInterval(updateYouTubeProgress, 1e3);
    };
    const initializeAudio = () => {
      let audioUrl = props.question.audioUrl;
      if (audioUrl.startsWith("youtube:")) {
        const videoId = audioUrl.replace("youtube:", "");
        createYouTubeAudioPlayer(videoId);
        return;
      }
      if (audioUrl.includes("youtube.com/watch") || audioUrl.includes("youtu.be/")) {
        let videoId = "";
        if (audioUrl.includes("youtube.com/watch")) {
          const urlParams = new URLSearchParams(audioUrl.split("?")[1]);
          videoId = urlParams.get("v") || "";
        } else if (audioUrl.includes("youtu.be/")) {
          videoId = audioUrl.split("youtu.be/")[1].split("?")[0];
        }
        if (videoId) {
          createYouTubeAudioPlayer(videoId);
          return;
        }
      }
      audio.value = new Audio(audioUrl);
      audio.value.addEventListener("loadedmetadata", () => {
        duration.value = audio.value.duration;
        audioLoaded.value = true;
        updatePlaybackSpeed();
      });
      audio.value.addEventListener("timeupdate", updateProgress);
      audio.value.addEventListener("play", () => {
        isPlaying.value = true;
        updatePlaybackSpeed();
      });
      audio.value.addEventListener("pause", () => {
        isPlaying.value = false;
      });
      audio.value.addEventListener("ended", () => {
        isPlaying.value = false;
        currentTime.value = 0;
        progress.value = 0;
      });
    };
    watch(playbackSpeed, (newSpeed) => {
      updatePlaybackSpeed();
    }, { immediate: false });
    watch(() => props.question, (newQuestion, oldQuestion) => {
      if (newQuestion && oldQuestion && newQuestion.audioUrl !== oldQuestion.audioUrl) {
        if (audio.value) {
          audio.value.pause();
          audio.value = null;
        }
        if (youtubePlayer) {
          youtubePlayer.destroy();
          youtubePlayer = null;
        }
        audioLoaded.value = false;
        isPlaying.value = false;
        currentTime.value = 0;
        duration.value = 0;
        progress.value = 0;
        playsRemaining.value = newQuestion.maxPlays || 3;
        isYouTubeAudio.value = false;
        youtubePlayerReady.value = false;
        initializeAudio();
      }
    }, { deep: true });
    onMounted(() => {
      userAnswers.value = new Array(props.question.questions?.length || 0).fill(null);
      playsRemaining.value = props.question.maxPlays || 3;
      initializeAudio();
    });
    onUnmounted(() => {
      if (audio.value) {
        audio.value.pause();
        audio.value = null;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$J, [
        createBaseVNode("div", _hoisted_2$G, [
          createBaseVNode("div", _hoisted_3$E, [
            createBaseVNode("h3", _hoisted_4$C, toDisplayString$1(tf("grammar.practice.exercises.listening.instruction", "Listen carefully and answer the questions")), 1),
            createBaseVNode("div", _hoisted_5$A, [
              createBaseVNode("div", _hoisted_6$y, [
                createBaseVNode("button", {
                  onClick: togglePlayback,
                  disabled: !audioLoaded.value,
                  class: "w-16 h-16 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white rounded-full flex items-center justify-center transition-colors shadow-lg"
                }, [
                  !isPlaying.value ? (openBlock(), createElementBlock("svg", _hoisted_8$x, _cache[3] || (_cache[3] = [
                    createBaseVNode("path", { d: "M8 5v14l11-7z" }, null, -1)
                  ]))) : (openBlock(), createElementBlock("svg", _hoisted_9$w, _cache[4] || (_cache[4] = [
                    createBaseVNode("rect", {
                      x: "6",
                      y: "4",
                      width: "4",
                      height: "16"
                    }, null, -1),
                    createBaseVNode("rect", {
                      x: "14",
                      y: "4",
                      width: "4",
                      height: "16"
                    }, null, -1)
                  ])))
                ], 8, _hoisted_7$x),
                createBaseVNode("button", {
                  onClick: restartAudio,
                  disabled: !audioLoaded.value,
                  class: "p-3 bg-gray-300 dark:bg-white/10 hover:bg-gray-400 dark:hover:bg-white/15 disabled:bg-gray-200 dark:disabled:bg-white/5 text-gray-700 dark:text-white/80 rounded-full transition-colors"
                }, _cache[5] || (_cache[5] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                    })
                  ], -1)
                ]), 8, _hoisted_10$v)
              ]),
              createBaseVNode("div", _hoisted_11$v, [
                createBaseVNode("div", {
                  class: "w-full bg-gray-200 dark:bg-white/10 rounded-full h-2 cursor-pointer",
                  onClick: seekAudio,
                  ref_key: "progressBar",
                  ref: progressBar
                }, [
                  createBaseVNode("div", {
                    class: "bg-blue-600 h-2 rounded-full transition-all duration-100",
                    style: normalizeStyle({ width: `${progress.value}%` })
                  }, null, 4)
                ], 512),
                createBaseVNode("div", _hoisted_12$u, [
                  createBaseVNode("span", null, toDisplayString$1(formatTime(currentTime.value)), 1),
                  createBaseVNode("span", null, toDisplayString$1(formatTime(duration.value)), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_13$u, [
                createBaseVNode("div", _hoisted_14$u, [
                  _cache[6] || (_cache[6] = createBaseVNode("svg", {
                    class: "w-4 h-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M15.536 8.464a5 5 0 010 7.072m-2.036-5.036a2.5 2.5 0 010 3.536M6 10h4l4.5-4.5v9L10 10H6V8z"
                    })
                  ], -1)),
                  createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.exercises.listening.playsLeft", "Plays left")) + ": " + toDisplayString$1(playsRemaining.value), 1)
                ]),
                _ctx.question.allowNotes ? (openBlock(), createElementBlock("div", _hoisted_15$q, [
                  _cache[7] || (_cache[7] = createBaseVNode("svg", {
                    class: "w-4 h-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                    })
                  ], -1)),
                  createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.exercises.listening.notesAllowed", "Notes are allowed")), 1)
                ])) : createCommentVNode("", true)
              ])
            ]),
            !audioLoaded.value ? (openBlock(), createElementBlock("div", _hoisted_16$p, toDisplayString$1(tf("grammar.practice.exercises.listening.loading", "Loading")) + "... ", 1)) : createCommentVNode("", true)
          ])
        ]),
        _ctx.question.allowNotes ? (openBlock(), createElementBlock("div", _hoisted_17$p, [
          createBaseVNode("label", _hoisted_18$o, toDisplayString$1(tf("grammar.practice.exercises.listening.takeNotes", "Take notes")), 1),
          withDirectives(createBaseVNode("textarea", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => userNotes.value = $event),
            placeholder: tf("grammar.practice.exercises.listening.notesPlaceholder", "Type your notes here..."),
            class: "w-full h-32 px-4 py-2 border border-gray-300 dark:border-white/10 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white resize-none"
          }, null, 8, _hoisted_19$o), [
            [vModelText, userNotes.value]
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_20$o, [
          createBaseVNode("h4", _hoisted_21$o, toDisplayString$1(tf("grammar.practice.exercises.listening.questions", "Questions")), 1),
          createBaseVNode("div", _hoisted_22$m, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.question.questions, (q, index) => {
              return openBlock(), createElementBlock("div", {
                key: index,
                class: "border border-gray-200 dark:border-white/10 rounded-lg p-4"
              }, [
                createBaseVNode("div", _hoisted_23$m, [
                  createBaseVNode("h5", _hoisted_24$l, toDisplayString$1(index + 1) + ". " + toDisplayString$1(q.question), 1),
                  q.type === "multiple-choice" ? (openBlock(), createElementBlock("div", _hoisted_25$l, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(q.options, (option, optionIndex) => {
                      return openBlock(), createElementBlock("label", {
                        key: optionIndex,
                        class: normalizeClass([
                          "flex items-start space-x-3 p-3 rounded-lg cursor-pointer transition-all",
                          userAnswers.value[index] === optionIndex ? "bg-blue-50 dark:bg-blue-900/30 border border-blue-300 dark:border-blue-600" : "bg-gray-50 dark:bg-[#0a0a0a]/50 hover:bg-gray-100 dark:hover:bg-[#0a0a0a]/70 border border-transparent",
                          showAnswers.value && optionIndex === q.correctAnswer ? "bg-green-50 dark:bg-green-900/30 border border-green-300 dark:border-green-600" : "",
                          showAnswers.value && userAnswers.value[index] === optionIndex && optionIndex !== q.correctAnswer ? "bg-red-50 dark:bg-red-900/30 border border-red-300 dark:border-red-600" : ""
                        ])
                      }, [
                        withDirectives(createBaseVNode("input", {
                          type: "radio",
                          name: `question-${index}`,
                          value: optionIndex,
                          "onUpdate:modelValue": ($event) => userAnswers.value[index] = $event,
                          disabled: showAnswers.value,
                          class: "mt-1"
                        }, null, 8, _hoisted_26$j), [
                          [vModelRadio, userAnswers.value[index]]
                        ]),
                        createBaseVNode("span", _hoisted_27$i, toDisplayString$1(option), 1),
                        createBaseVNode("div", _hoisted_28$i, [
                          showAnswers.value && optionIndex === q.correctAnswer ? (openBlock(), createElementBlock("svg", _hoisted_29$g, _cache[8] || (_cache[8] = [
                            createBaseVNode("path", {
                              "stroke-linecap": "round",
                              "stroke-linejoin": "round",
                              "stroke-width": "2",
                              d: "M5 13l4 4L19 7"
                            }, null, -1)
                          ]))) : showAnswers.value && userAnswers.value[index] === optionIndex && optionIndex !== q.correctAnswer ? (openBlock(), createElementBlock("svg", _hoisted_30$f, _cache[9] || (_cache[9] = [
                            createBaseVNode("path", {
                              "stroke-linecap": "round",
                              "stroke-linejoin": "round",
                              "stroke-width": "2",
                              d: "M6 18L18 6M6 6l12 12"
                            }, null, -1)
                          ]))) : createCommentVNode("", true)
                        ])
                      ], 2);
                    }), 128))
                  ])) : q.type === "fill-blank" ? (openBlock(), createElementBlock("div", _hoisted_31$f, [
                    withDirectives(createBaseVNode("input", {
                      "onUpdate:modelValue": ($event) => userAnswers.value[index] = $event,
                      disabled: showAnswers.value,
                      placeholder: tf("grammar.practice.exercises.listening.fillBlank", "Type the missing word/phrase"),
                      class: normalizeClass([
                        "w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent",
                        showAnswers.value ? isAnswerCorrect(index) ? "border-green-500 bg-green-50 dark:bg-green-900/30" : "border-red-500 bg-red-50 dark:bg-red-900/30" : "border-gray-300 dark:border-white/10 bg-white dark:bg-[#0a0a0a]",
                        "text-gray-900 dark:text-white"
                      ])
                    }, null, 10, _hoisted_32$d), [
                      [vModelText, userAnswers.value[index]]
                    ]),
                    showAnswers.value && !isAnswerCorrect(index) ? (openBlock(), createElementBlock("div", _hoisted_33$d, toDisplayString$1(tf("grammar.practice.exercises.listening.correctAnswer", "Correct answer")) + ": " + toDisplayString$1(q.correctAnswer), 1)) : createCommentVNode("", true)
                  ])) : q.type === "ordering" ? (openBlock(), createElementBlock("div", _hoisted_34$c, [
                    createBaseVNode("div", _hoisted_35$c, toDisplayString$1(tf("grammar.practice.exercises.listening.dragToOrder", "Drag to order")), 1),
                    createVNode(unref(VueDraggableNext), {
                      modelValue: userAnswers.value[index],
                      "onUpdate:modelValue": ($event) => userAnswers.value[index] = $event,
                      disabled: showAnswers.value,
                      class: "space-y-2",
                      "item-key": "id"
                    }, {
                      item: withCtx(({ element, index: itemIndex }) => [
                        createBaseVNode("div", {
                          class: normalizeClass([
                            "p-3 bg-gray-50 dark:bg-[#0a0a0a] rounded-lg border cursor-move",
                            showAnswers.value && itemIndex === element.correctPosition ? "border-green-500 bg-green-50 dark:bg-green-900/30" : showAnswers.value && itemIndex !== element.correctPosition ? "border-red-500 bg-red-50 dark:bg-red-900/30" : "border-gray-200 dark:border-white/10"
                          ])
                        }, [
                          createBaseVNode("div", _hoisted_36$b, [
                            createBaseVNode("span", _hoisted_37$a, toDisplayString$1(itemIndex + 1), 1),
                            createBaseVNode("span", _hoisted_38$a, toDisplayString$1(element.text), 1)
                          ])
                        ], 2)
                      ]),
                      _: 2
                    }, 1032, ["modelValue", "onUpdate:modelValue", "disabled"])
                  ])) : createCommentVNode("", true)
                ]),
                showAnswers.value && q.explanation ? (openBlock(), createElementBlock("div", _hoisted_39$8, [
                  createBaseVNode("p", _hoisted_40$8, [
                    createBaseVNode("strong", null, toDisplayString$1(tf("grammar.practice.exercises.explanation", "Explanation")) + ":", 1),
                    createTextVNode(" " + toDisplayString$1(q.explanation), 1)
                  ])
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])
        ]),
        showAnswers.value ? (openBlock(), createElementBlock("div", _hoisted_41$7, [
          createBaseVNode("div", _hoisted_42$6, [
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_43$6, toDisplayString$1(correctAnswers.value), 1),
              createBaseVNode("div", _hoisted_44$6, toDisplayString$1(tf("grammar.practice.exercises.listening.correct", "Correct")), 1)
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_45$5, toDisplayString$1(incorrectAnswers.value), 1),
              createBaseVNode("div", _hoisted_46$5, toDisplayString$1(tf("grammar.practice.exercises.listening.incorrect", "Incorrect")), 1)
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_47$5, toDisplayString$1(accuracy.value) + "%", 1),
              createBaseVNode("div", _hoisted_48$5, toDisplayString$1(tf("grammar.practice.exercises.listening.accuracy", "Accuracy")), 1)
            ])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_49$5, [
          createBaseVNode("div", _hoisted_50$5, [
            _ctx.question.transcript && showAnswers.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: _cache[1] || (_cache[1] = ($event) => showTranscript.value = !showTranscript.value),
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 transition-colors"
            }, [
              _cache[10] || (_cache[10] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(showTranscript.value ? tf("grammar.practice.exercises.listening.hideTranscript", "Hide transcript") : tf("grammar.practice.exercises.listening.showTranscript", "Show transcript")), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_51$4, [
            !showAnswers.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: checkAnswers,
              disabled: !hasAllAnswers.value,
              class: "px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            }, toDisplayString$1(tf("grammar.practice.exercises.checkAnswer", "Check answer")), 9, _hoisted_52$4)) : (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: nextQuestion,
              class: "px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            }, toDisplayString$1(_ctx.questionIndex === _ctx.totalQuestions - 1 ? tf("grammar.practice.exercises.finish", "Finish") : tf("grammar.practice.exercises.next", "Next")), 1))
          ])
        ]),
        showTranscript.value ? (openBlock(), createElementBlock("div", _hoisted_53$4, [
          createBaseVNode("div", _hoisted_54$4, [
            createBaseVNode("div", _hoisted_55$4, [
              createBaseVNode("h3", _hoisted_56$4, toDisplayString$1(tf("grammar.practice.exercises.listening.transcript", "Transcript")), 1),
              createBaseVNode("button", {
                onClick: _cache[2] || (_cache[2] = ($event) => showTranscript.value = false),
                class: "p-2 rounded-lg text-gray-500 dark:text-white/60 hover:text-gray-700 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-white/10 transition-colors"
              }, _cache[11] || (_cache[11] = [
                createBaseVNode("svg", {
                  class: "w-5 h-5",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M6 18L18 6M6 6l12 12"
                  })
                ], -1)
              ]))
            ]),
            createBaseVNode("div", _hoisted_57$4, [
              createBaseVNode("p", _hoisted_58$4, toDisplayString$1(_ctx.question.transcript), 1)
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const ListeningExercise = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$J
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$I = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg border border-gray-200 dark:border-white/10 p-6" };
const _hoisted_2$F = { class: "mb-8" };
const _hoisted_3$D = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_4$B = { class: "bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded-lg p-4 mb-6" };
const _hoisted_5$z = { class: "flex items-start space-x-3" };
const _hoisted_6$x = { class: "font-medium text-blue-800 dark:text-blue-200 mb-2" };
const _hoisted_7$w = { class: "text-blue-700 dark:text-blue-300 text-sm" };
const _hoisted_8$w = {
  key: 0,
  class: "mb-6"
};
const _hoisted_9$v = { class: "text-sm font-medium text-gray-700 dark:text-white/70 mb-2" };
const _hoisted_10$u = { class: "space-y-1" };
const _hoisted_11$u = { class: "flex items-center space-x-6 text-sm text-gray-600 dark:text-white/60 mb-4" };
const _hoisted_12$t = {
  key: 0,
  class: "flex items-center space-x-1"
};
const _hoisted_13$t = {
  key: 1,
  class: "flex items-center space-x-1"
};
const _hoisted_14$t = { class: "mb-6" };
const _hoisted_15$p = { class: "flex items-center justify-between mb-4" };
const _hoisted_16$o = { class: "text-lg font-medium text-gray-900 dark:text-white" };
const _hoisted_17$o = { class: "flex items-center space-x-4 text-sm" };
const _hoisted_18$n = { class: "flex items-center space-x-1" };
const _hoisted_19$n = { class: "text-gray-500 dark:text-white/60" };
const _hoisted_20$n = {
  key: 0,
  class: "text-gray-400 dark:text-white/50"
};
const _hoisted_21$n = {
  key: 0,
  class: "flex items-center space-x-1"
};
const _hoisted_22$l = { class: "text-gray-500 dark:text-white/60" };
const _hoisted_23$l = ["disabled", "placeholder"];
const _hoisted_24$k = { class: "mt-4 text-sm text-gray-600 dark:text-white/60" };
const _hoisted_25$k = {
  key: 0,
  class: "mt-2 p-3 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700 rounded-lg"
};
const _hoisted_26$i = { class: "space-y-1" };
const _hoisted_27$h = {
  key: 0,
  class: "mb-6"
};
const _hoisted_28$h = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_29$f = { class: "bg-gradient-to-r from-blue-50 to-purple-50 dark:from-blue-900/30 dark:to-purple-900/30 border border-blue-200 dark:border-blue-700 rounded-lg p-4 mb-4" };
const _hoisted_30$e = { class: "flex items-center justify-between" };
const _hoisted_31$e = { class: "font-medium text-gray-900 dark:text-white" };
const _hoisted_32$c = { class: "text-2xl font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_33$c = { class: "grid grid-cols-2 md:grid-cols-4 gap-4 mt-4" };
const _hoisted_34$b = { class: "text-center" };
const _hoisted_35$b = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_36$a = { class: "text-xs text-gray-600 dark:text-white/60" };
const _hoisted_37$9 = { class: "text-center" };
const _hoisted_38$9 = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_39$7 = { class: "text-xs text-gray-600 dark:text-white/60" };
const _hoisted_40$7 = { class: "text-center" };
const _hoisted_41$6 = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_42$5 = { class: "text-xs text-gray-600 dark:text-white/60" };
const _hoisted_43$5 = { class: "text-center" };
const _hoisted_44$5 = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_45$4 = { class: "text-xs text-gray-600 dark:text-white/60" };
const _hoisted_46$4 = { class: "space-y-4" };
const _hoisted_47$4 = {
  key: 0,
  class: "p-4 bg-green-50 dark:bg-green-900/30 border border-green-200 dark:border-green-700 rounded-lg"
};
const _hoisted_48$4 = { class: "font-medium text-green-800 dark:text-green-200 mb-2" };
const _hoisted_49$4 = { class: "space-y-1" };
const _hoisted_50$4 = {
  key: 1,
  class: "p-4 bg-orange-50 dark:bg-orange-900/30 border border-orange-200 dark:border-orange-700 rounded-lg"
};
const _hoisted_51$3 = { class: "font-medium text-orange-800 dark:text-orange-200 mb-2" };
const _hoisted_52$3 = { class: "space-y-1" };
const _hoisted_53$3 = {
  key: 2,
  class: "p-4 bg-red-50 dark:bg-red-900/30 border border-red-200 dark:border-red-700 rounded-lg"
};
const _hoisted_54$3 = { class: "font-medium text-red-800 dark:text-red-200 mb-2" };
const _hoisted_55$3 = { class: "space-y-2" };
const _hoisted_56$3 = { class: "text-red-700 dark:text-red-300" };
const _hoisted_57$3 = { class: "text-green-700 dark:text-green-300" };
const _hoisted_58$3 = {
  key: 0,
  class: "text-gray-600 dark:text-white/60 text-xs mt-1"
};
const _hoisted_59$3 = { class: "flex justify-between items-center" };
const _hoisted_60$3 = { class: "flex space-x-4" };
const _hoisted_61$3 = { class: "flex space-x-4" };
const _hoisted_62$3 = ["disabled"];
const _sfc_main$I = /* @__PURE__ */ defineComponent({
  __name: "WritingExercise",
  props: {
    question: {},
    questionIndex: {},
    totalQuestions: {}
  },
  emits: ["answer", "next", "complete"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      const translated = params ? t(key, params) : t(key);
      const text = typeof translated === "string" ? translated : String(translated);
      if (text === key) return fallback;
      return text;
    };
    const props = __props;
    const emit = __emit;
    const userText = ref("");
    const wordCount = ref(0);
    const timeRemaining = ref(0);
    const timeExpired = ref(false);
    const isSubmitted = ref(false);
    const isAnalyzing = ref(false);
    const showTips = ref(false);
    const timer = ref(null);
    const feedback = ref(null);
    const canSubmit = computed(() => {
      return userText.value.trim().length > 0 && wordCount.value >= (props.question.minWords || 0) && !timeExpired.value && !isAnalyzing.value;
    });
    const writingTips = computed(() => {
      const tips = [
        tf("grammar.practice.exercises.writing.tip1", "Plan your structure before writing."),
        tf("grammar.practice.exercises.writing.tip2", "Use clear and concise sentences."),
        tf("grammar.practice.exercises.writing.tip3", "Vary vocabulary and sentence patterns."),
        tf("grammar.practice.exercises.writing.tip4", "Check grammar and punctuation."),
        tf("grammar.practice.exercises.writing.tip5", "Review and edit your response.")
      ];
      return tips;
    });
    const updateWordCount = () => {
      wordCount.value = userText.value.trim().split(/\s+/).filter((word) => word.length > 0).length;
    };
    const getPlaceholderText = () => {
      switch (props.question.taskType) {
        case "essay":
          return tf("grammar.practice.exercises.writing.essayPlaceholder", "Write your essay here...");
        case "email":
          return tf("grammar.practice.exercises.writing.emailPlaceholder", "Write your email here...");
        case "letter":
          return tf("grammar.practice.exercises.writing.letterPlaceholder", "Write your letter here...");
        default:
          return tf("grammar.practice.exercises.writing.paragraphPlaceholder", "Write your paragraph here...");
      }
    };
    const startTimer = () => {
      if (props.question.timeLimit) {
        timeRemaining.value = props.question.timeLimit * 60;
        timer.value = setInterval(() => {
          timeRemaining.value--;
          if (timeRemaining.value <= 0) {
            timeExpired.value = true;
            stopTimer();
            if (!isSubmitted.value) {
              submitForReview();
            }
          }
        }, 1e3);
      }
    };
    const stopTimer = () => {
      if (timer.value) {
        clearInterval(timer.value);
        timer.value = null;
      }
    };
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    };
    const saveDraft = () => {
      const draftKey = `writing-draft-${props.question.id}`;
      localStorage.setItem(draftKey, userText.value);
      console.log("Draft saved!");
    };
    const clearText = () => {
      if (confirm(t("grammar.practice.exercises.writing.confirmClear", "Clear all text?"))) {
        userText.value = "";
        wordCount.value = 0;
      }
    };
    const submitForReview = async () => {
      isAnalyzing.value = true;
      stopTimer();
      try {
        await new Promise((resolve) => setTimeout(resolve, 3e3));
        const mockFeedback = {
          overallScore: Math.floor(Math.random() * 30) + 70,
          // 70-100
          grammar: Math.floor(Math.random() * 30) + 70,
          vocabulary: Math.floor(Math.random() * 30) + 70,
          coherence: Math.floor(Math.random() * 30) + 70,
          taskResponse: Math.floor(Math.random() * 30) + 70,
          strengths: [
            "Good use of complex sentence structures",
            "Clear organization of ideas",
            "Appropriate vocabulary for the task"
          ],
          improvements: [
            "Work on paragraph transitions",
            "Use more varied sentence beginnings",
            "Expand on supporting details"
          ],
          corrections: [
            {
              original: "This is very good",
              corrected: "This is excellent",
              explanation: "Use more precise adjectives for better impact"
            }
          ]
        };
        feedback.value = mockFeedback;
        isSubmitted.value = true;
        const score = mockFeedback.overallScore;
        emit("answer", {
          isCorrect: score >= 70,
          score,
          text: userText.value
        });
      } catch (error) {
        console.error("Error analyzing writing:", error);
      } finally {
        isAnalyzing.value = false;
      }
    };
    const nextQuestion = () => {
      if (props.questionIndex === props.totalQuestions - 1) {
        emit("complete");
      } else {
        resetExercise();
        emit("next");
      }
    };
    const resetExercise = () => {
      userText.value = "";
      wordCount.value = 0;
      timeExpired.value = false;
      isSubmitted.value = false;
      isAnalyzing.value = false;
      showTips.value = false;
      feedback.value = null;
      stopTimer();
      startTimer();
    };
    const loadDraft = () => {
      const draftKey = `writing-draft-${props.question.id}`;
      const draft = localStorage.getItem(draftKey);
      if (draft) {
        userText.value = draft;
        updateWordCount();
      }
    };
    onMounted(() => {
      startTimer();
      loadDraft();
    });
    onUnmounted(() => {
      stopTimer();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$I, [
        createBaseVNode("div", _hoisted_2$F, [
          createBaseVNode("h3", _hoisted_3$D, toDisplayString$1(tf("grammar.practice.exercises.writing.instruction", "Follow the writing instructions")), 1),
          createBaseVNode("div", _hoisted_4$B, [
            createBaseVNode("div", _hoisted_5$z, [
              _cache[2] || (_cache[2] = createBaseVNode("div", { class: "w-6 h-6 bg-blue-600 rounded-full flex items-center justify-center flex-shrink-0 mt-1" }, [
                createBaseVNode("svg", {
                  class: "w-4 h-4 text-white",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                  })
                ])
              ], -1)),
              createBaseVNode("div", null, [
                createBaseVNode("h4", _hoisted_6$x, toDisplayString$1(_ctx.question.taskType === "essay" ? tf("grammar.practice.exercises.writing.essay", "Essay") : _ctx.question.taskType === "email" ? tf("grammar.practice.exercises.writing.email", "Email") : _ctx.question.taskType === "letter" ? tf("grammar.practice.exercises.writing.letter", "Letter") : tf("grammar.practice.exercises.writing.paragraph", "Paragraph")), 1),
                createBaseVNode("p", _hoisted_7$w, toDisplayString$1(_ctx.question.prompt), 1)
              ])
            ])
          ]),
          _ctx.question.requirements && _ctx.question.requirements.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_8$w, [
            createBaseVNode("h4", _hoisted_9$v, toDisplayString$1(tf("grammar.practice.exercises.writing.requirements", "Requirements")), 1),
            createBaseVNode("ul", _hoisted_10$u, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.question.requirements, (requirement) => {
                return openBlock(), createElementBlock("li", {
                  key: requirement,
                  class: "flex items-start space-x-2 text-sm text-gray-600 dark:text-white/60"
                }, [
                  _cache[3] || (_cache[3] = createBaseVNode("svg", {
                    class: "w-4 h-4 text-green-600 dark:text-green-400 mt-0.5 flex-shrink-0",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M5 13l4 4L19 7"
                    })
                  ], -1)),
                  createBaseVNode("span", null, toDisplayString$1(requirement), 1)
                ]);
              }), 128))
            ])
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_11$u, [
            _ctx.question.minWords ? (openBlock(), createElementBlock("div", _hoisted_12$t, [
              _cache[4] || (_cache[4] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.exercises.writing.minWords", "Min words")) + ": " + toDisplayString$1(_ctx.question.minWords), 1)
            ])) : createCommentVNode("", true),
            _ctx.question.timeLimit ? (openBlock(), createElementBlock("div", _hoisted_13$t, [
              _cache[5] || (_cache[5] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.exercises.writing.timeLimit", "Time limit")) + ": " + toDisplayString$1(_ctx.question.timeLimit) + " " + toDisplayString$1(tf("common.minutes", "minutes")), 1)
            ])) : createCommentVNode("", true)
          ])
        ]),
        createBaseVNode("div", _hoisted_14$t, [
          createBaseVNode("div", _hoisted_15$p, [
            createBaseVNode("h4", _hoisted_16$o, toDisplayString$1(tf("grammar.practice.exercises.writing.yourResponse", "Your response")), 1),
            createBaseVNode("div", _hoisted_17$o, [
              createBaseVNode("div", _hoisted_18$n, [
                createBaseVNode("span", _hoisted_19$n, toDisplayString$1(tf("grammar.practice.exercises.writing.words", "Words")) + ":", 1),
                createBaseVNode("span", {
                  class: normalizeClass([
                    "font-medium",
                    wordCount.value >= (_ctx.question.minWords || 0) ? "text-green-600 dark:text-green-400" : "text-orange-600 dark:text-orange-400"
                  ])
                }, toDisplayString$1(wordCount.value), 3),
                _ctx.question.minWords ? (openBlock(), createElementBlock("span", _hoisted_20$n, " / " + toDisplayString$1(_ctx.question.minWords), 1)) : createCommentVNode("", true)
              ]),
              _ctx.question.timeLimit ? (openBlock(), createElementBlock("div", _hoisted_21$n, [
                createBaseVNode("span", _hoisted_22$l, toDisplayString$1(tf("grammar.practice.exercises.writing.timeLeft", "Time left")) + ":", 1),
                createBaseVNode("span", {
                  class: normalizeClass([
                    "font-medium font-mono",
                    timeRemaining.value <= 300 ? "text-red-600 dark:text-red-400" : "text-blue-600 dark:text-blue-400"
                  ])
                }, toDisplayString$1(formatTime(timeRemaining.value)), 3)
              ])) : createCommentVNode("", true)
            ])
          ]),
          withDirectives(createBaseVNode("textarea", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => userText.value = $event),
            disabled: timeExpired.value || isSubmitted.value,
            placeholder: getPlaceholderText(),
            class: "w-full h-80 px-4 py-3 border border-gray-300 dark:border-white/10 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white resize-none disabled:bg-gray-100 dark:disabled:bg-white/5 disabled:cursor-not-allowed",
            onInput: updateWordCount
          }, null, 40, _hoisted_23$l), [
            [vModelText, userText.value]
          ]),
          createBaseVNode("div", _hoisted_24$k, [
            createBaseVNode("button", {
              onClick: _cache[1] || (_cache[1] = ($event) => showTips.value = !showTips.value),
              class: "flex items-center space-x-1 hover:text-gray-800 dark:hover:text-white/80 transition-colors"
            }, [
              _cache[6] || (_cache[6] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.exercises.writing.tips", "Tips")), 1)
            ]),
            showTips.value ? (openBlock(), createElementBlock("div", _hoisted_25$k, [
              createBaseVNode("ul", _hoisted_26$i, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(writingTips.value, (tip) => {
                  return openBlock(), createElementBlock("li", {
                    key: tip,
                    class: "text-yellow-800 dark:text-yellow-200"
                  }, "  " + toDisplayString$1(tip), 1);
                }), 128))
              ])
            ])) : createCommentVNode("", true)
          ])
        ]),
        isSubmitted.value && feedback.value ? (openBlock(), createElementBlock("div", _hoisted_27$h, [
          createBaseVNode("h4", _hoisted_28$h, toDisplayString$1(tf("grammar.practice.exercises.writing.feedback", "Feedback")), 1),
          createBaseVNode("div", _hoisted_29$f, [
            createBaseVNode("div", _hoisted_30$e, [
              createBaseVNode("h5", _hoisted_31$e, toDisplayString$1(tf("grammar.practice.exercises.writing.overallScore", "Overall score")), 1),
              createBaseVNode("div", _hoisted_32$c, toDisplayString$1(feedback.value.overallScore) + "/100 ", 1)
            ]),
            createBaseVNode("div", _hoisted_33$c, [
              createBaseVNode("div", _hoisted_34$b, [
                createBaseVNode("div", _hoisted_35$b, toDisplayString$1(feedback.value.grammar), 1),
                createBaseVNode("div", _hoisted_36$a, toDisplayString$1(tf("grammar.practice.exercises.writing.grammar", "Grammar")), 1)
              ]),
              createBaseVNode("div", _hoisted_37$9, [
                createBaseVNode("div", _hoisted_38$9, toDisplayString$1(feedback.value.vocabulary), 1),
                createBaseVNode("div", _hoisted_39$7, toDisplayString$1(tf("grammar.practice.exercises.writing.vocabulary", "Vocabulary")), 1)
              ]),
              createBaseVNode("div", _hoisted_40$7, [
                createBaseVNode("div", _hoisted_41$6, toDisplayString$1(feedback.value.coherence), 1),
                createBaseVNode("div", _hoisted_42$5, toDisplayString$1(tf("grammar.practice.exercises.writing.coherence", "Coherence")), 1)
              ]),
              createBaseVNode("div", _hoisted_43$5, [
                createBaseVNode("div", _hoisted_44$5, toDisplayString$1(feedback.value.taskResponse), 1),
                createBaseVNode("div", _hoisted_45$4, toDisplayString$1(tf("grammar.practice.exercises.writing.taskResponse", "Task response")), 1)
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_46$4, [
            feedback.value.strengths.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_47$4, [
              createBaseVNode("h6", _hoisted_48$4, toDisplayString$1(tf("grammar.practice.exercises.writing.strengths", "Strengths")), 1),
              createBaseVNode("ul", _hoisted_49$4, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(feedback.value.strengths, (strength) => {
                  return openBlock(), createElementBlock("li", {
                    key: strength,
                    class: "text-green-700 dark:text-green-300 text-sm"
                  }, "  " + toDisplayString$1(strength), 1);
                }), 128))
              ])
            ])) : createCommentVNode("", true),
            feedback.value.improvements.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_50$4, [
              createBaseVNode("h6", _hoisted_51$3, toDisplayString$1(tf("grammar.practice.exercises.writing.improvements", "Areas for improvement")), 1),
              createBaseVNode("ul", _hoisted_52$3, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(feedback.value.improvements, (improvement) => {
                  return openBlock(), createElementBlock("li", {
                    key: improvement,
                    class: "text-orange-700 dark:text-orange-300 text-sm"
                  }, "  " + toDisplayString$1(improvement), 1);
                }), 128))
              ])
            ])) : createCommentVNode("", true),
            feedback.value.corrections.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_53$3, [
              createBaseVNode("h6", _hoisted_54$3, toDisplayString$1(tf("grammar.practice.exercises.writing.corrections", "Corrections")), 1),
              createBaseVNode("div", _hoisted_55$3, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(feedback.value.corrections, (correction) => {
                  return openBlock(), createElementBlock("div", {
                    key: correction.original,
                    class: "text-sm"
                  }, [
                    createBaseVNode("div", _hoisted_56$3, "  " + toDisplayString$1(correction.original), 1),
                    createBaseVNode("div", _hoisted_57$3, "  " + toDisplayString$1(correction.corrected), 1),
                    correction.explanation ? (openBlock(), createElementBlock("div", _hoisted_58$3, toDisplayString$1(correction.explanation), 1)) : createCommentVNode("", true)
                  ]);
                }), 128))
              ])
            ])) : createCommentVNode("", true)
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_59$3, [
          createBaseVNode("div", _hoisted_60$3, [
            !isSubmitted.value && userText.value.trim() ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: saveDraft,
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
            }, [
              _cache[7] || (_cache[7] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3-3m0 0l-3 3m3-3v12"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.exercises.writing.saveDraft", "Save draft")), 1)
            ])) : createCommentVNode("", true),
            !isSubmitted.value && userText.value.trim() ? (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: clearText,
              class: "flex items-center space-x-2 px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:text-red-700 dark:hover:text-red-300 transition-colors"
            }, [
              _cache[8] || (_cache[8] = createBaseVNode("svg", {
                class: "w-4 h-4",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                })
              ], -1)),
              createBaseVNode("span", null, toDisplayString$1(tf("grammar.practice.exercises.writing.clear", "Clear")), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_61$3, [
            !isSubmitted.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: submitForReview,
              disabled: !canSubmit.value,
              class: "px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            }, toDisplayString$1(isAnalyzing.value ? tf("grammar.practice.exercises.writing.analyzing", "Analyzing...") : tf("grammar.practice.exercises.writing.submit", "Submit for review")), 9, _hoisted_62$3)) : (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: nextQuestion,
              class: "px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            }, toDisplayString$1(_ctx.questionIndex === _ctx.totalQuestions - 1 ? tf("grammar.practice.finish", "Finish") : tf("grammar.practice.next", "Next")), 1))
          ])
        ])
      ]);
    };
  }
});

const WritingExercise = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$I
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$H = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 dark:bg-black/60 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$E = { class: "w-full max-h-[90vh] flex flex-col max-w-full sm:max-w-lg md:max-w-2xl lg:max-w-4xl" };
const _hoisted_3$C = { class: "px-6 py-4 border-b-0 dark:border-b dark:border-gray-custom flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$A = { class: "flex items-center justify-between" };
const _hoisted_5$y = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$w = { class: "px-6 py-4 flex-1 overflow-y-auto min-h-0" };
const _hoisted_7$v = { class: "space-y-6" };
const _hoisted_8$v = {
  class: "bg-white dark:bg-gray-custom border-0 dark:border dark:border-gray-custom rounded-lg p-4 animate-fade-in-up ring-1 ring-gray-100 dark:ring-0",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_9$u = { class: "text-md font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_10$t = { class: "grid grid-cols-1 md:grid-cols-2 gap-4" };
const _hoisted_11$t = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_12$s = { class: "block text-sm font-medium text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_13$s = ["placeholder"];
const _hoisted_14$s = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_15$o = { class: "block text-sm font-medium text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_16$n = ["placeholder"];
const _hoisted_17$n = {
  class: "md:col-span-2 animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_18$m = { class: "block text-sm font-medium text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_19$m = ["placeholder"];
const _hoisted_20$m = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_21$m = { class: "block text-sm font-medium text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_22$k = { value: "easy" };
const _hoisted_23$k = { value: "medium" };
const _hoisted_24$j = { value: "hard" };
const _hoisted_25$j = { class: "block text-sm font-medium text-gray-700 dark:text-white/80 mb-2" };
const _hoisted_26$h = ["placeholder"];
const _hoisted_27$g = {
  class: "flex justify-end mt-4 animate-fade-in-up",
  style: { "animation-delay": "0.7s" }
};
const _hoisted_28$g = { class: "text-md font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_29$e = { class: "grid grid-cols-1 md:grid-cols-2 gap-4" };
const _hoisted_30$d = { class: "flex items-start justify-between" };
const _hoisted_31$d = { class: "flex-1" };
const _hoisted_32$b = { class: "flex items-center space-x-2 mb-2" };
const _hoisted_33$b = { class: "font-medium text-gray-900 dark:text-white" };
const _hoisted_34$a = { class: "text-sm text-gray-600 dark:text-white/60 mb-2" };
const _hoisted_35$a = { class: "flex items-center space-x-4 text-xs text-gray-500 dark:text-white/60" };
const _hoisted_36$9 = { class: "flex items-center space-x-2 ml-4" };
const _hoisted_37$8 = ["onClick", "title"];
const _hoisted_38$8 = ["onClick", "title"];
const _hoisted_39$6 = ["onClick", "title"];
const _hoisted_40$6 = { class: "px-6 py-4 border-t-0 dark:border-t dark:border-gray-custom flex-shrink-0 bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_41$5 = { class: "flex justify-end space-x-3" };
const _sfc_main$H = /* @__PURE__ */ defineComponent({
  __name: "ExerciseManager",
  props: {
    modelValue: { type: Boolean },
    exerciseTypes: {}
  },
  emits: ["update:modelValue", "add-exercise", "edit-exercise", "delete-exercise", "save-exercises", "open-question-manager"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const tf = (key, fallback, params) => {
      const translated = params ? t(key, params) : t(key);
      const text = typeof translated === "string" ? translated : String(translated);
      if (text === key) return fallback;
      return text;
    };
    const newExercise = reactive({
      type: "",
      title: "",
      description: "",
      difficulty: "easy",
      duration: "",
      icon: "BookOpenIcon",
      colorClass: "bg-gray-500"
    });
    const closeModal = () => {
      emit("update:modelValue", false);
    };
    const addExerciseType = () => {
      if (!newExercise.type || !newExercise.title || !newExercise.description) {
        return;
      }
      const exerciseToAdd = {
        ...newExercise,
        icon: getIconForType(newExercise.type),
        colorClass: getColorForType(newExercise.type)
      };
      emit("add-exercise", exerciseToAdd);
      Object.assign(newExercise, {
        type: "",
        title: "",
        description: "",
        difficulty: "easy",
        duration: "",
        icon: "BookOpenIcon",
        colorClass: "bg-gray-500"
      });
    };
    const editExerciseType = (index) => {
      const exercise = props.exerciseTypes[index];
      Object.assign(newExercise, exercise);
      emit("edit-exercise", index, exercise);
    };
    const deleteExerciseType = (index) => {
      if (confirm(t("common.confirmDelete", "Are you sure you want to delete this?"))) {
        emit("delete-exercise", index);
      }
    };
    const saveExerciseTypes = () => {
      emit("save-exercises");
      closeModal();
    };
    const openQuestionManager = (exerciseType) => {
      emit("open-question-manager", exerciseType);
    };
    const getIconForType = (type) => {
      const iconMap = {
        "multiple-choice": "CheckCircleIcon",
        "fill-blank": "PencilIcon",
        "writing": "DocumentTextIcon",
        "listening": "SpeakerWaveIcon",
        "reading": "BookOpenIcon",
        "grammar": "AcademicCapIcon"
      };
      return iconMap[type] || "BookOpenIcon";
    };
    const getColorForType = (type) => {
      const colorMap = {
        "multiple-choice": "bg-gray-500",
        "fill-blank": "bg-green-500",
        "writing": "bg-purple-500",
        "listening": "bg-orange-500",
        "reading": "bg-indigo-500",
        "grammar": "bg-red-500"
      };
      return colorMap[type] || "bg-gray-500";
    };
    watch(() => props.modelValue, (newValue) => {
      if (!newValue) {
        Object.assign(newExercise, {
          type: "",
          title: "",
          description: "",
          difficulty: "easy",
          duration: "",
          icon: "BookOpenIcon",
          colorClass: "bg-gray-500"
        });
      }
    });
    const lockBodyScroll = () => {
      document.body.style.overflow = "hidden";
    };
    const unlockBodyScroll = () => {
      document.body.style.overflow = "";
    };
    watch(() => props.modelValue, (open) => {
      if (open) lockBodyScroll();
      else unlockBodyScroll();
    }, { immediate: true });
    onUnmounted(() => {
      unlockBodyScroll();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        appear: "",
        "enter-active-class": "transition-all duration-500 ease-out",
        "enter-from-class": "opacity-0",
        "enter-to-class": "opacity-100",
        "leave-active-class": "transition-all duration-300 ease-in",
        "leave-from-class": "opacity-100",
        "leave-to-class": "opacity-0"
      }, {
        default: withCtx(() => [
          _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$H, [
            createVNode(Transition, {
              appear: "",
              "enter-active-class": "transition-all duration-500 ease-out",
              "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
              "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
              "leave-active-class": "transition-all duration-300 ease-in",
              "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
              "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
            }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_2$E, [
                  createBaseVNode("div", {
                    class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border-0 dark:border dark:border-gray-custom flex flex-col h-full overflow-hidden transform transform-gpu will-change-transform",
                    onClick: _cache[5] || (_cache[5] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("div", _hoisted_3$C, [
                      createBaseVNode("div", _hoisted_4$A, [
                        createBaseVNode("h3", _hoisted_5$y, [
                          _cache[6] || (_cache[6] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                          createBaseVNode("span", null, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.title", "Exercise Manager")), 1)
                        ]),
                        createBaseVNode("button", {
                          onClick: closeModal,
                          class: "text-gray-400 hover:text-gray-600 dark:text-white/60 dark:hover:text-white transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-white/10",
                          "aria-label": "Close"
                        }, _cache[7] || (_cache[7] = [
                          createBaseVNode("svg", {
                            class: "w-6 h-6",
                            fill: "none",
                            stroke: "currentColor",
                            viewBox: "0 0 24 24"
                          }, [
                            createBaseVNode("path", {
                              "stroke-linecap": "round",
                              "stroke-linejoin": "round",
                              "stroke-width": "2",
                              d: "M6 18L18 6M6 6l12 12"
                            })
                          ], -1)
                        ]))
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_6$w, [
                      createBaseVNode("div", _hoisted_7$v, [
                        createBaseVNode("div", _hoisted_8$v, [
                          createBaseVNode("h4", _hoisted_9$u, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.addNew", "Add new exercise type")), 1),
                          createBaseVNode("div", _hoisted_10$t, [
                            createBaseVNode("div", _hoisted_11$t, [
                              createBaseVNode("label", _hoisted_12$s, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.exerciseType", "Exercise type")), 1),
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => newExercise.type = $event),
                                type: "text",
                                class: "w-full px-3 py-2 border-0 dark:border dark:border-gray-custom rounded-lg bg-white dark:bg-gray-custom text-gray-900 dark:text-white ring-1 ring-gray-200/50 dark:ring-0 shadow-sm dark:shadow-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 dark:hover:border-blue-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("grammar.practice.exerciseManager.typePlaceholder", "e.g. multiple-choice")
                              }, null, 8, _hoisted_13$s), [
                                [vModelText, newExercise.type]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_14$s, [
                              createBaseVNode("label", _hoisted_15$o, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.title", "Title")), 1),
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => newExercise.title = $event),
                                type: "text",
                                class: "w-full px-3 py-2 border-0 dark:border dark:border-gray-custom rounded-lg bg-white dark:bg-gray-custom text-gray-900 dark:text-white ring-1 ring-gray-200/50 dark:ring-0 shadow-sm dark:shadow-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 dark:hover:border-blue-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("grammar.practice.exerciseManager.titlePlaceholder", "Enter exercise title")
                              }, null, 8, _hoisted_16$n), [
                                [vModelText, newExercise.title]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_17$n, [
                              createBaseVNode("label", _hoisted_18$m, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.description", "Description")), 1),
                              withDirectives(createBaseVNode("textarea", {
                                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => newExercise.description = $event),
                                rows: "3",
                                class: "w-full px-3 py-2 border-0 dark:border dark:border-gray-custom rounded-lg bg-white dark:bg-gray-custom text-gray-900 dark:text-white ring-1 ring-gray-200/50 dark:ring-0 shadow-sm dark:shadow-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 dark:hover:border-blue-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("grammar.practice.exerciseManager.descriptionPlaceholder", "Briefly describe this exercise")
                              }, null, 8, _hoisted_19$m), [
                                [vModelText, newExercise.description]
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_20$m, [
                              createBaseVNode("label", _hoisted_21$m, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.difficulty", "Difficulty")), 1),
                              withDirectives(createBaseVNode("select", {
                                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => newExercise.difficulty = $event),
                                class: "w-full px-3 py-2 border-0 dark:border dark:border-gray-custom rounded-lg bg-white dark:bg-gray-custom text-gray-900 dark:text-white ring-1 ring-gray-200/50 dark:ring-0 shadow-sm dark:shadow-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 dark:hover:border-blue-500 transform hover:scale-[1.02] cursor-pointer"
                              }, [
                                createBaseVNode("option", _hoisted_22$k, toDisplayString$1(unref(t)("grammar.practice.settings.levels.easy", "Easy")), 1),
                                createBaseVNode("option", _hoisted_23$k, toDisplayString$1(unref(t)("grammar.practice.settings.levels.medium", "Medium")), 1),
                                createBaseVNode("option", _hoisted_24$j, toDisplayString$1(unref(t)("grammar.practice.settings.levels.hard", "Hard")), 1)
                              ], 512), [
                                [vModelSelect, newExercise.difficulty]
                              ])
                            ]),
                            createBaseVNode("div", null, [
                              createBaseVNode("label", _hoisted_25$j, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.duration", "Duration")), 1),
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => newExercise.duration = $event),
                                type: "text",
                                class: "w-full px-3 py-2 border-0 dark:border dark:border-gray-custom rounded-lg bg-white dark:bg-gray-custom text-gray-900 dark:text-white ring-1 ring-gray-200/50 dark:ring-0 shadow-sm dark:shadow-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 dark:hover:border-blue-500 transform hover:scale-[1.02]",
                                placeholder: unref(t)("grammar.practice.exerciseManager.durationPlaceholder", "e.g. 10-15 min")
                              }, null, 8, _hoisted_26$h), [
                                [vModelText, newExercise.duration]
                              ])
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_27$g, [
                            createBaseVNode("button", {
                              onClick: addExerciseType,
                              class: "px-5 py-2 text-sm font-medium text-white bg-gradient-to-r from-blue-500 to-blue-600 rounded-lg hover:from-blue-600 hover:to-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-300 hover:scale-105 hover:shadow-lg"
                            }, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.add", "Add")), 1)
                          ])
                        ]),
                        createBaseVNode("div", null, [
                          createBaseVNode("h4", _hoisted_28$g, toDisplayString$1(unref(t)("grammar.practice.exerciseManager.existing", "Existing exercise types")), 1),
                          createBaseVNode("div", _hoisted_29$e, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.exerciseTypes, (exercise, index) => {
                              return openBlock(), createElementBlock("div", {
                                key: exercise.type,
                                class: "bg-white dark:bg-gray-custom border-0 dark:border dark:border-gray-custom rounded-lg p-4 ring-1 ring-gray-100 dark:ring-0"
                              }, [
                                createBaseVNode("div", _hoisted_30$d, [
                                  createBaseVNode("div", _hoisted_31$d, [
                                    createBaseVNode("div", _hoisted_32$b, [
                                      (openBlock(), createBlock(resolveDynamicComponent(exercise.icon), {
                                        class: normalizeClass(["w-5 h-5", exercise.colorClass.replace("bg-", "text-")])
                                      }, null, 8, ["class"])),
                                      createBaseVNode("h5", _hoisted_33$b, toDisplayString$1(tf(`grammar.practice.exercises.${exercise.type}.title`, exercise.title)), 1)
                                    ]),
                                    createBaseVNode("p", _hoisted_34$a, toDisplayString$1(tf(`grammar.practice.exercises.${exercise.type}.description`, exercise.description)), 1),
                                    createBaseVNode("div", _hoisted_35$a, [
                                      createBaseVNode("span", null, toDisplayString$1(exercise.difficulty), 1),
                                      createBaseVNode("span", null, toDisplayString$1(exercise.duration), 1)
                                    ])
                                  ]),
                                  createBaseVNode("div", _hoisted_36$9, [
                                    createBaseVNode("button", {
                                      onClick: ($event) => openQuestionManager(exercise.type),
                                      class: "p-1 rounded text-green-600 dark:text-green-400 hover:bg-green-100 dark:hover:bg-green-900/30 transition-colors",
                                      title: unref(t)("grammar.practice.exerciseManager.manageQuestions", "Manage questions")
                                    }, _cache[8] || (_cache[8] = [
                                      createBaseVNode("svg", {
                                        class: "w-4 h-4",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                                        })
                                      ], -1)
                                    ]), 8, _hoisted_37$8),
                                    createBaseVNode("button", {
                                      onClick: ($event) => editExerciseType(index),
                                      class: "p-1 rounded text-blue-600 dark:text-blue-400 hover:bg-blue-100 dark:hover:bg-blue-900/30 transition-colors",
                                      title: unref(t)("common.edit", "Edit")
                                    }, _cache[9] || (_cache[9] = [
                                      createBaseVNode("svg", {
                                        class: "w-4 h-4",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                                        })
                                      ], -1)
                                    ]), 8, _hoisted_38$8),
                                    createBaseVNode("button", {
                                      onClick: ($event) => deleteExerciseType(index),
                                      class: "p-1 rounded text-red-600 dark:text-red-400 hover:bg-red-100 dark:hover:bg-red-900/30 transition-colors",
                                      title: unref(t)("common.delete", "Delete")
                                    }, _cache[10] || (_cache[10] = [
                                      createBaseVNode("svg", {
                                        class: "w-4 h-4",
                                        fill: "none",
                                        stroke: "currentColor",
                                        viewBox: "0 0 24 24"
                                      }, [
                                        createBaseVNode("path", {
                                          "stroke-linecap": "round",
                                          "stroke-linejoin": "round",
                                          "stroke-width": "2",
                                          d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                                        })
                                      ], -1)
                                    ]), 8, _hoisted_39$6)
                                  ])
                                ])
                              ]);
                            }), 128))
                          ])
                        ])
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_40$6, [
                      createBaseVNode("div", _hoisted_41$5, [
                        createBaseVNode("button", {
                          onClick: closeModal,
                          class: "px-6 py-2 text-gray-700 dark:text-white/80 bg-gray-100 dark:bg-gray-custom hover:bg-gray-200 dark:hover:bg-white/10 rounded-lg transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium"
                        }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                        createBaseVNode("button", {
                          onClick: saveExerciseTypes,
                          class: "px-6 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg hover:from-blue-600 hover:to-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-300 hover:scale-105 hover:shadow-lg font-medium"
                        }, toDisplayString$1(unref(t)("common.save", "Save")), 1)
                      ])
                    ])
                  ])
                ])
              ]),
              _: 1
            })
          ])) : createCommentVNode("", true)
        ]),
        _: 1
      });
    };
  }
});

const ExerciseManager = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$H
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$G = { class: "bg-white dark:bg-black shadow border-b border-gray-200 dark:border-gray-800" };
const _hoisted_2$D = { class: "max-w-4xl mx-auto py-3 sm:py-4 md:py-6 px-3 sm:px-4 md:px-6" };
const _hoisted_3$B = { class: "sm:hidden" };
const _hoisted_4$z = { class: "flex items-center justify-between mb-3" };
const _hoisted_5$x = { class: "flex items-center" };
const _hoisted_6$v = { class: "text-xl font-bold text-gray-900 dark:text-transparent bg-clip-text bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 dark:from-blue-400 dark:via-purple-400 dark:to-pink-400" };
const _hoisted_7$u = { class: "text-right" };
const _hoisted_8$u = { class: "text-xs text-gray-500 dark:text-white/60" };
const _hoisted_9$t = { class: "text-sm font-semibo ld text-gray-900 dark:text-white" };
const _hoisted_10$s = { class: "flex items-center justify-between" };
const _hoisted_11$s = { class: "flex items-center space-x-2" };
const _hoisted_12$r = ["title"];
const _hoisted_13$r = ["disabled", "aria-disabled", "title"];
const _hoisted_14$r = { class: "flex items-center space-x-2" };
const _hoisted_15$n = { class: "relative" };
const _hoisted_16$m = ["disabled", "aria-disabled", "title", "aria-label"];
const _hoisted_17$m = { class: "truncate" };
const _hoisted_18$l = {
  key: 0,
  class: "absolute right-0 mt-1 w-44 z-[9999] rounded-md shadow-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-[#0f0f0f] overflow-hidden"
};
const _hoisted_19$l = { class: "py-1 text-xs text-gray-900 dark:text-white" };
const _hoisted_20$l = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_21$l = ["title", "aria-label"];
const _hoisted_22$j = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_23$j = ["title", "aria-label"];
const _hoisted_24$i = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_25$i = ["title", "aria-label"];
const _hoisted_26$g = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_27$f = ["disabled", "aria-disabled", "title"];
const _hoisted_28$f = ["title", "aria-label"];
const _hoisted_29$d = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_30$c = ["disabled", "aria-disabled", "title"];
const _hoisted_31$c = ["title", "aria-label"];
const _hoisted_32$a = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_33$a = ["disabled", "aria-disabled", "title"];
const _hoisted_34$9 = ["title", "aria-label"];
const _hoisted_35$9 = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_36$8 = ["disabled", "aria-disabled", "title"];
const _hoisted_37$7 = ["title", "aria-label"];
const _hoisted_38$7 = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_39$5 = ["title"];
const _hoisted_40$5 = ["title", "aria-label"];
const _hoisted_41$4 = { class: "px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-2" };
const _hoisted_42$4 = ["title", "aria-label"];
const _hoisted_43$4 = ["disabled", "title"];
const _hoisted_44$4 = { class: "hidden sm:flex items-center justify-between" };
const _hoisted_45$3 = { class: "flex items-center" };
const _hoisted_46$3 = { class: "text-2xl md:text-3xl font-bold text-gray-900 dark:text-transparent bg-clip-text bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 dark:from-blue-400 dark:via-purple-400 dark:to-pink-400" };
const _hoisted_47$3 = { class: "mt-1 md:mt-2 text-sm md:text-base text-gray-600 dark:text-white/70" };
const _hoisted_48$3 = { class: "flex items-center space-x-3 md:space-x-4" };
const _hoisted_49$3 = ["title"];
const _hoisted_50$3 = { class: "flex items-center space-x-2 md:space-x-3" };
const _hoisted_51$2 = { class: "text-sm md:text-base text-gray-600 dark:text-white/70" };
const _hoisted_52$2 = ["disabled", "title"];
const _hoisted_53$2 = { class: "text-right" };
const _hoisted_54$2 = { class: "text-sm md:text-base text-gray-500 dark:text-white/60" };
const _hoisted_55$2 = { class: "text-lg md:text-xl font-semibold text-gray-900 dark:text-white" };
const _hoisted_56$2 = { class: "flex items-center space-x-2 md:space-x-3" };
const _hoisted_57$2 = { class: "relative" };
const _hoisted_58$2 = ["disabled", "aria-disabled", "title", "aria-label"];
const _hoisted_59$2 = { class: "truncate" };
const _hoisted_60$2 = {
  key: 0,
  class: "absolute right-0 mt-1 w-52 z-[9999] rounded-md shadow-xl border border-gray-200 dark:border-gray-700 bg-white dark:bg-[#0f0f0f] overflow-hidden"
};
const _hoisted_61$2 = { class: "py-1 text-sm text-gray-900 dark:text-white" };
const _hoisted_62$2 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_63$2 = ["title", "aria-label"];
const _hoisted_64$2 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_65$2 = ["title", "aria-label"];
const _hoisted_66$2 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_67$2 = ["title", "aria-label"];
const _hoisted_68$2 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_69$2 = ["disabled", "aria-disabled", "title"];
const _hoisted_70$2 = ["title", "aria-label"];
const _hoisted_71$2 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_72$2 = ["disabled", "aria-disabled", "title"];
const _hoisted_73$2 = ["title", "aria-label"];
const _hoisted_74$2 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_75$2 = ["disabled", "aria-disabled", "title"];
const _hoisted_76$2 = ["title", "aria-label"];
const _hoisted_77$2 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_78$1 = ["disabled", "aria-disabled", "title"];
const _hoisted_79$1 = ["title", "aria-label"];
const _hoisted_80$1 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_81$1 = ["title"];
const _hoisted_82$1 = ["title", "aria-label"];
const _hoisted_83$1 = { class: "px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10 flex items-center justify-between gap-3" };
const _hoisted_84$1 = ["title", "aria-label"];
const _hoisted_85$1 = ["disabled", "aria-disabled", "title"];
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "FlashcardHeader",
  props: {
    currentIndex: {},
    totalCards: {},
    practiceMode: {},
    shuffleEnabled: { type: Boolean },
    practiceStarted: { type: Boolean },
    imageQuizEnabled: { type: Boolean },
    listeningQuizEnabled: { type: Boolean },
    typingQuizEnabled: { type: Boolean },
    imageModeAvailable: { type: Boolean },
    pictionaryModeAvailable: { type: Boolean },
    flipTileModeAvailable: { type: Boolean },
    bubbleShooterModeAvailable: { type: Boolean },
    bubbleShooterVietnameseMode: { type: Boolean },
    snakeDoubleBaitEnabled: { type: Boolean },
    pictionaryDefinitionMode: { type: Boolean },
    scrambleWordsEnabled: { type: Boolean },
    wordsCrushEnabled: { type: Boolean },
    useFlipTileHints: { type: Boolean }
  },
  emits: ["go-back", "show-history", "change-practice-mode", "show-settings", "toggle-shuffle", "update:image-quiz-enabled", "update:listening-quiz-enabled", "update:typing-quiz-enabled", "update:bubble-shooter-vietnamese-mode", "update:snake-double-bait-enabled", "update:pictionary-definition-mode", "update:scramble-words-enabled", "update:words-crush-enabled", "update:use-flip-tile-hints"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const imageQuizEnabled = computed(() => props.imageQuizEnabled ?? false);
    const listeningQuizEnabled = computed(() => props.listeningQuizEnabled ?? false);
    const typingQuizEnabled = computed(() => props.typingQuizEnabled ?? false);
    const imageModeAvailable = computed(() => props.imageModeAvailable ?? true);
    const pictionaryModeAvailable = computed(() => props.pictionaryModeAvailable ?? true);
    const flipTileModeAvailable = computed(() => props.flipTileModeAvailable ?? true);
    const bubbleShooterModeAvailable = computed(() => props.bubbleShooterModeAvailable ?? true);
    const bubbleShooterVietnameseMode = computed(() => props.bubbleShooterVietnameseMode ?? false);
    const snakeDoubleBaitEnabled = computed(() => props.snakeDoubleBaitEnabled ?? false);
    const pictionaryDefinitionMode = computed(() => props.pictionaryDefinitionMode ?? false);
    const scrambleWordsEnabled = computed(() => props.scrambleWordsEnabled ?? false);
    const wordsCrushEnabled = computed(() => props.wordsCrushEnabled ?? false);
    const useFlipTileHints = computed(() => props.useFlipTileHints ?? false);
    const { t } = useI18n();
    const emit = __emit;
    const mobileDropdownOpen = ref(false);
    const desktopDropdownOpen = ref(false);
    const closeAll = () => {
      mobileDropdownOpen.value = false;
      desktopDropdownOpen.value = false;
    };
    const toggleMobileDropdown = () => {
      if (props.practiceStarted) return;
      mobileDropdownOpen.value = !mobileDropdownOpen.value;
      if (mobileDropdownOpen.value) desktopDropdownOpen.value = false;
    };
    const toggleDesktopDropdown = () => {
      if (props.practiceStarted) return;
      desktopDropdownOpen.value = !desktopDropdownOpen.value;
      if (desktopDropdownOpen.value) mobileDropdownOpen.value = false;
    };
    const selectMode = (mode) => {
      if (props.practiceStarted) {
        closeAll();
        return;
      }
      if (mode === "image" && !imageModeAvailable.value) {
        closeAll();
        return;
      }
      if (mode === "pictionary" && !pictionaryModeAvailable.value) {
        closeAll();
        return;
      }
      if (mode === "bubble-shooter" && !bubbleShooterModeAvailable.value) {
        closeAll();
        return;
      }
      emit("change-practice-mode", mode);
      closeAll();
    };
    const toggleImageQuizFromDropdown = () => {
      if (props.practiceStarted) return;
      if (!imageModeAvailable.value) return;
      emit("update:image-quiz-enabled", !imageQuizEnabled.value);
    };
    const toggleListeningQuizFromDropdown = () => {
      if (props.practiceStarted) return;
      emit("update:listening-quiz-enabled", !listeningQuizEnabled.value);
    };
    const toggleTypingQuizFromDropdown = () => {
      if (props.practiceStarted) return;
      emit("update:typing-quiz-enabled", !typingQuizEnabled.value);
    };
    const toggleSnakeDoubleBaitFromDropdown = () => {
      if (props.practiceStarted) return;
      emit("update:snake-double-bait-enabled", !snakeDoubleBaitEnabled.value);
    };
    const toggleBubbleShooterVietnameseMode = () => {
      if (props.practiceStarted) return;
      if (!bubbleShooterModeAvailable.value) return;
      emit("update:bubble-shooter-vietnamese-mode", !bubbleShooterVietnameseMode.value);
    };
    const togglePictionaryDefinitionModeFromDropdown = () => {
      if (props.practiceStarted) return;
      if (!pictionaryModeAvailable.value) return;
      emit("update:pictionary-definition-mode", !pictionaryDefinitionMode.value);
    };
    const toggleFlipTileHintsFromDropdown = () => {
      if (props.practiceStarted) return;
      if (!flipTileModeAvailable.value) return;
      emit("update:use-flip-tile-hints", !useFlipTileHints.value);
    };
    const toggleScrambleWordsFromDropdown = () => {
      if (props.practiceStarted) return;
      emit("update:scramble-words-enabled", !scrambleWordsEnabled.value);
    };
    const toggleWordsCrushFromDropdown = () => {
      if (props.practiceStarted) return;
      emit("update:words-crush-enabled", !wordsCrushEnabled.value);
    };
    const onShowSettings = () => {
      if (props.practiceStarted) return;
      closeAll();
      emit("show-settings");
    };
    const onClickOutside = (e) => {
      const target = e.target;
      if (!target.closest(".relative")) {
        closeAll();
      }
    };
    onMounted(() => {
      window.addEventListener("click", onClickOutside, { capture: true });
    });
    onBeforeUnmount(() => {
      window.removeEventListener("click", onClickOutside, { capture: true });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$G, [
        createBaseVNode("div", _hoisted_2$D, [
          createBaseVNode("div", _hoisted_3$B, [
            createBaseVNode("div", _hoisted_4$z, [
              createBaseVNode("div", _hoisted_5$x, [
                createBaseVNode("button", {
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("go-back")),
                  class: "mr-3 text-gray-500 dark:text-white/70 hover:text-gray-700 dark:hover:text-white"
                }, _cache[44] || (_cache[44] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)
                ])),
                createBaseVNode("div", null, [
                  createBaseVNode("h1", _hoisted_6$v, toDisplayString$1(unref(t)("flashcard.modes.flashcard", "Flashcard")), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_7$u, [
                createBaseVNode("p", _hoisted_8$u, toDisplayString$1(unref(t)("flashcard.header.progress", "Progress")), 1),
                createBaseVNode("p", _hoisted_9$t, toDisplayString$1(_ctx.currentIndex + 1) + "/" + toDisplayString$1(_ctx.totalCards), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_10$s, [
              createBaseVNode("div", _hoisted_11$s, [
                createBaseVNode("button", {
                  onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("show-history")),
                  class: "text-gray-500 dark:text-white/70 hover:text-gray-700 dark:hover:text-white",
                  title: unref(t)("flashcard.header.history", "History")
                }, _cache[45] || (_cache[45] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)
                ]), 8, _hoisted_12$r),
                createBaseVNode("button", {
                  onClick: onShowSettings,
                  disabled: _ctx.practiceStarted,
                  "aria-disabled": _ctx.practiceStarted ? "true" : "false",
                  class: normalizeClass(["text-gray-500 dark:text-white/70 hover:text-gray-700 dark:hover:text-white", _ctx.practiceStarted ? "opacity-50 cursor-not-allowed" : ""]),
                  title: _ctx.practiceStarted ? unref(t)("flashcard.settings.disabledDuringPractice", "Settings are disabled during practice") : unref(t)("flashcard.header.settings", "Settings")
                }, _cache[46] || (_cache[46] = [
                  createBaseVNode("svg", {
                    class: "w-5 h-5",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)
                ]), 10, _hoisted_13$r)
              ]),
              createBaseVNode("div", _hoisted_14$r, [
                createBaseVNode("div", _hoisted_15$n, [
                  createBaseVNode("button", {
                    type: "button",
                    onClick: toggleMobileDropdown,
                    class: normalizeClass(["relative pl-2 pr-8 py-1 text-xs border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0f0f0f] cursor-pointer text-gray-900 dark:text-white flex items-center min-w-[120px]", _ctx.practiceStarted ? "opacity-50 cursor-not-allowed" : ""]),
                    disabled: _ctx.practiceStarted,
                    "aria-disabled": _ctx.practiceStarted ? "true" : "false",
                    title: _ctx.practiceStarted ? unref(t)("flashcard.modes.change_disabled_during_practice", "Mode change is disabled during practice") : unref(t)("flashcard.header.selectMode", "Select mode"),
                    "aria-label": unref(t)("flashcard.header.selectMode", "Select mode")
                  }, [
                    createBaseVNode("span", _hoisted_17$m, toDisplayString$1(_ctx.practiceMode === "flashcard" ? unref(t)("flashcard.modes.flashcard", "Flashcard") : _ctx.practiceMode === "quiz" ? unref(t)("flashcard.modes.quiz", "Quiz") : _ctx.practiceMode === "typing" ? unref(t)("flashcard.modes.typing", "Typing") : _ctx.practiceMode === "listening" ? unref(t)("flashcard.modes.listening", "Listening") : _ctx.practiceMode === "image" ? unref(t)("flashcard.modes.image", "Image") : _ctx.practiceMode === "pictionary" ? unref(t)("flashcard.modes.pictionary", "Pictionary") : _ctx.practiceMode === "flip-tile" ? unref(t)("flashcard.modes.flipTile", "Flip Tile") : _ctx.practiceMode === "bubble-shooter" ? unref(t)("flashcard.modes.bubbleShooter", "Bubble Shooter") : _ctx.practiceMode === "snake-game" ? unref(t)("flashcard.modes.snakeGame", "Snake Hunt") : unref(t)("flashcard.modes.pronunciation", "Pronunciation")), 1),
                    _cache[47] || (_cache[47] = createBaseVNode("svg", {
                      class: "w-3.5 h-3.5 opacity-80 absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M5.23 7.21a.75.75 0 011.06.02L10 11.17l3.71-3.94a.75.75 0 111.08 1.04l-4.24 4.5a.75.75 0 01-1.08 0L5.21 8.27a.75.75 0 01.02-1.06z",
                        "clip-rule": "evenodd"
                      })
                    ], -1))
                  ], 10, _hoisted_16$m),
                  createVNode(Transition, {
                    name: "fade",
                    appear: ""
                  }, {
                    default: withCtx(() => [
                      mobileDropdownOpen.value && !_ctx.practiceStarted ? (openBlock(), createElementBlock("div", _hoisted_18$l, [
                        createBaseVNode("ul", _hoisted_19$l, [
                          createBaseVNode("li", _hoisted_20$l, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[2] || (_cache[2] = ($event) => selectMode("flashcard"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.flashcard", "Flashcard")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", scrambleWordsEnabled.value ? "bg-green-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[3] || (_cache[3] = withModifiers(($event) => toggleScrambleWordsFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.scrambleWords.toggle", "Scramble Words"),
                              "aria-label": unref(t)("flashcard.scrambleWords.toggle", "Scramble Words")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", scrambleWordsEnabled.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_21$l)
                          ]),
                          createBaseVNode("li", null, [
                            createBaseVNode("button", {
                              class: "w-full text-left px-3 py-2 hover:bg-gray-100 dark:hover:bg-white/10",
                              onClick: _cache[4] || (_cache[4] = ($event) => selectMode("quiz"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.quiz", "Quiz")), 1)
                          ]),
                          createBaseVNode("li", _hoisted_22$j, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[5] || (_cache[5] = ($event) => selectMode("typing"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.typing", "Typing")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", typingQuizEnabled.value ? "bg-purple-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[6] || (_cache[6] = withModifiers(($event) => toggleTypingQuizFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.typing.quizToggle", "Multiple Choice"),
                              "aria-label": unref(t)("flashcard.typing.quizToggle", "Multiple Choice")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", typingQuizEnabled.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_23$j)
                          ]),
                          createBaseVNode("li", _hoisted_24$i, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[7] || (_cache[7] = ($event) => selectMode("listening"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.listening", "Listening")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", listeningQuizEnabled.value ? "bg-cyan-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[8] || (_cache[8] = withModifiers(($event) => toggleListeningQuizFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.listening.quizToggle", "Multiple Choice"),
                              "aria-label": unref(t)("flashcard.listening.quizToggle", "Multiple Choice")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", listeningQuizEnabled.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_25$i)
                          ]),
                          createBaseVNode("li", _hoisted_26$g, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !imageModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[9] || (_cache[9] = ($event) => selectMode("image")),
                              disabled: !imageModeAvailable.value,
                              "aria-disabled": !imageModeAvailable.value ? "true" : "false",
                              title: !imageModeAvailable.value ? unref(t)("flashcard.image.unavailable", "Image mode is unavailable for the selected date") : unref(t)("flashcard.modes.image", "Image")
                            }, toDisplayString$1(unref(t)("flashcard.modes.image", "Image")), 11, _hoisted_27$f),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                imageModeAvailable.value ? imageQuizEnabled.value ? "bg-purple-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[10] || (_cache[10] = withModifiers(($event) => imageModeAvailable.value && toggleImageQuizFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.image.quizToggle", "Multiple Choice"),
                              "aria-label": unref(t)("flashcard.image.quizToggle", "Multiple Choice")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", imageQuizEnabled.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_28$f)
                          ]),
                          createBaseVNode("li", _hoisted_29$d, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !pictionaryModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[11] || (_cache[11] = ($event) => selectMode("pictionary")),
                              disabled: !pictionaryModeAvailable.value,
                              "aria-disabled": !pictionaryModeAvailable.value ? "true" : "false",
                              title: !pictionaryModeAvailable.value ? unref(t)("flashcard.pictionary.unavailable", "Pictionary mode is unavailable for the selected date") : unref(t)("flashcard.modes.pictionary", "Pictionary")
                            }, toDisplayString$1(unref(t)("flashcard.modes.pictionary", "Pictionary")), 11, _hoisted_30$c),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                pictionaryModeAvailable.value ? pictionaryDefinitionMode.value ? "bg-teal-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[12] || (_cache[12] = withModifiers(($event) => pictionaryModeAvailable.value && togglePictionaryDefinitionModeFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.pictionary.definitionToggle", "Definition Mode"),
                              "aria-label": unref(t)("flashcard.pictionary.definitionToggle", "Definition Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", pictionaryDefinitionMode.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_31$c)
                          ]),
                          createBaseVNode("li", _hoisted_32$a, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !flipTileModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[13] || (_cache[13] = ($event) => selectMode("flip-tile")),
                              disabled: !flipTileModeAvailable.value,
                              "aria-disabled": !flipTileModeAvailable.value ? "true" : "false",
                              title: !flipTileModeAvailable.value ? unref(t)("flashcard.flipTile.unavailable", "Flip Tile mode is unavailable for the selected date") : unref(t)("flashcard.modes.flipTile", "Flip Tile")
                            }, toDisplayString$1(unref(t)("flashcard.modes.flipTile", "Flip Tile")), 11, _hoisted_33$a),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                flipTileModeAvailable.value ? useFlipTileHints.value ? "bg-teal-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[14] || (_cache[14] = withModifiers(($event) => flipTileModeAvailable.value && toggleFlipTileHintsFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.flipTile.hintsToggle", "Use Definition Hints"),
                              "aria-label": unref(t)("flashcard.flipTile.hintsToggle", "Use Definition Hints")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", useFlipTileHints.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_34$9)
                          ]),
                          createBaseVNode("li", _hoisted_35$9, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !bubbleShooterModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[15] || (_cache[15] = ($event) => selectMode("bubble-shooter")),
                              disabled: !bubbleShooterModeAvailable.value,
                              "aria-disabled": !bubbleShooterModeAvailable.value ? "true" : "false",
                              title: !bubbleShooterModeAvailable.value ? unref(t)("flashcard.bubbleShooter.unavailable", "Bubble Shooter mode is disabled for dates with more than 8 vocabulary words") : unref(t)("flashcard.modes.bubbleShooter", "Bubble Shooter")
                            }, toDisplayString$1(unref(t)("flashcard.modes.bubbleShooter", "Bubble Shooter")), 11, _hoisted_36$8),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                bubbleShooterModeAvailable.value ? bubbleShooterVietnameseMode.value ? "bg-orange-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[16] || (_cache[16] = withModifiers(($event) => bubbleShooterModeAvailable.value && toggleBubbleShooterVietnameseMode(), ["stop"])),
                              title: unref(t)("flashcard.bubbleShooter.vietnameseModeToggle", "Vietnamese First Letter Mode"),
                              "aria-label": unref(t)("flashcard.bubbleShooter.vietnameseModeToggle", "Vietnamese First Letter Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", bubbleShooterVietnameseMode.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_37$7)
                          ]),
                          createBaseVNode("li", _hoisted_38$7, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[17] || (_cache[17] = ($event) => selectMode("snake-game")),
                              title: unref(t)("flashcard.modes.snakeGame", "Snake Hunt")
                            }, toDisplayString$1(unref(t)("flashcard.modes.snakeGame", "Snake Hunt")), 9, _hoisted_39$5),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                snakeDoubleBaitEnabled.value ? "bg-emerald-600" : "bg-gray-200 dark:bg-[#0a0a0a]",
                                _ctx.practiceStarted ? "opacity-50 cursor-not-allowed pointer-events-none" : ""
                              ]]),
                              onClick: _cache[18] || (_cache[18] = withModifiers(($event) => toggleSnakeDoubleBaitFromDropdown(), ["stop"])),
                              title: _ctx.practiceStarted ? unref(t)("flashcard.settings.disabledDuringPractice", "Settings are disabled during practice") : unref(t)("flashcard.snake.doubleBaitToggle", "Double Bait Mode"),
                              "aria-label": unref(t)("flashcard.snake.doubleBaitToggle", "Double Bait Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", snakeDoubleBaitEnabled.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_40$5)
                          ]),
                          createBaseVNode("li", _hoisted_41$4, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[19] || (_cache[19] = ($event) => selectMode("pronunciation"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.pronunciation", "Pronunciation")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-4 w-8 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", wordsCrushEnabled.value ? "bg-amber-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[20] || (_cache[20] = withModifiers(($event) => toggleWordsCrushFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.pronunciation.wordsCrushToggle", "Hidden Words Mode"),
                              "aria-label": unref(t)("flashcard.pronunciation.wordsCrushToggle", "Hidden Words Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform", wordsCrushEnabled.value ? "translate-x-4" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_42$4)
                          ])
                        ])
                      ])) : createCommentVNode("", true)
                    ]),
                    _: 1
                  })
                ]),
                createBaseVNode("button", {
                  onClick: _cache[21] || (_cache[21] = ($event) => _ctx.$emit("toggle-shuffle")),
                  disabled: _ctx.practiceStarted,
                  class: normalizeClass([
                    "relative inline-flex h-5 w-9 items-center rounded-full transition-colors",
                    _ctx.shuffleEnabled ? "bg-blue-600" : "bg-gray-200 dark:bg-gray-600",
                    _ctx.practiceStarted ? "opacity-50 cursor-not-allowed" : ""
                  ]),
                  title: _ctx.practiceStarted ? unref(t)("flashcard.settings.shuffle_disabled_during_practice", "Shuffle is disabled during practice") : unref(t)("flashcard.settings.shuffle", "Shuffle")
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass([
                      "inline-block h-3 w-3 transform rounded-full bg-white transition-transform",
                      _ctx.shuffleEnabled ? "translate-x-5" : "translate-x-1"
                    ])
                  }, null, 2)
                ], 10, _hoisted_43$4)
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_44$4, [
            createBaseVNode("div", _hoisted_45$3, [
              createBaseVNode("button", {
                onClick: _cache[22] || (_cache[22] = ($event) => _ctx.$emit("go-back")),
                class: "mr-4 text-gray-500 dark:text-white/70 hover:text-gray-700 dark:hover:text-white"
              }, _cache[48] || (_cache[48] = [
                createBaseVNode("svg", {
                  class: "w-6 h-6 md:w-7 md:h-7",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                    "clip-rule": "evenodd"
                  })
                ], -1)
              ])),
              createBaseVNode("div", null, [
                createBaseVNode("h1", _hoisted_46$3, toDisplayString$1(unref(t)("flashcard.modes.flashcard", "Flashcard")), 1),
                createBaseVNode("p", _hoisted_47$3, toDisplayString$1(unref(t)("flashcard.header.description", "Practice vocabulary with flashcards")), 1)
              ])
            ]),
            createBaseVNode("div", _hoisted_48$3, [
              createBaseVNode("button", {
                onClick: _cache[23] || (_cache[23] = ($event) => _ctx.$emit("show-history")),
                class: "text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300",
                title: unref(t)("flashcard.header.history", "History")
              }, _cache[49] || (_cache[49] = [
                createBaseVNode("svg", {
                  class: "w-6 h-6 md:w-7 md:h-7",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z",
                    "clip-rule": "evenodd"
                  })
                ], -1)
              ]), 8, _hoisted_49$3),
              createBaseVNode("div", _hoisted_50$3, [
                createBaseVNode("span", _hoisted_51$2, toDisplayString$1(unref(t)("flashcard.settings.shuffle", "Shuffle")), 1),
                createBaseVNode("button", {
                  onClick: _cache[24] || (_cache[24] = ($event) => _ctx.$emit("toggle-shuffle")),
                  disabled: _ctx.practiceStarted,
                  class: normalizeClass([
                    "relative inline-flex items-center rounded-full transition-colors",
                    "h-6 w-11 md:h-7 md:w-12",
                    _ctx.shuffleEnabled ? "bg-blue-600" : "bg-gray-200 dark:bg-gray-600",
                    _ctx.practiceStarted ? "opacity-50 cursor-not-allowed" : ""
                  ]),
                  title: _ctx.practiceStarted ? unref(t)("flashcard.settings.shuffle_disabled_during_practice", "Shuffle is disabled during practice") : unref(t)("flashcard.settings.shuffle", "Shuffle")
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass([
                      "inline-block transform rounded-full bg-white transition-transform",
                      "h-4 w-4 md:h-5 md:w-5",
                      _ctx.shuffleEnabled ? "translate-x-6 md:translate-x-6" : "translate-x-1"
                    ])
                  }, null, 2)
                ], 10, _hoisted_52$2)
              ]),
              createBaseVNode("div", _hoisted_53$2, [
                createBaseVNode("p", _hoisted_54$2, toDisplayString$1(unref(t)("flashcard.header.progress", "Progress")), 1),
                createBaseVNode("p", _hoisted_55$2, toDisplayString$1(_ctx.currentIndex + 1) + " / " + toDisplayString$1(_ctx.totalCards), 1)
              ]),
              createBaseVNode("div", _hoisted_56$2, [
                createBaseVNode("div", _hoisted_57$2, [
                  createBaseVNode("button", {
                    type: "button",
                    onClick: toggleDesktopDropdown,
                    class: normalizeClass(["relative pl-3 pr-10 py-1 md:pl-4 md:pr-12 md:py-2 text-sm md:text-base border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0f0f0f] cursor-pointer text-gray-900 dark:text-white flex items-center min-w-[140px]", _ctx.practiceStarted ? "opacity-50 cursor-not-allowed" : ""]),
                    disabled: _ctx.practiceStarted,
                    "aria-disabled": _ctx.practiceStarted ? "true" : "false",
                    title: _ctx.practiceStarted ? unref(t)("flashcard.modes.change_disabled_during_practice", "Mode change is disabled during practice") : unref(t)("flashcard.header.selectMode", "Select mode"),
                    "aria-label": unref(t)("flashcard.header.selectMode", "Select mode")
                  }, [
                    createBaseVNode("span", _hoisted_59$2, toDisplayString$1(_ctx.practiceMode === "flashcard" ? unref(t)("flashcard.modes.flashcard", "Flashcard") : _ctx.practiceMode === "quiz" ? unref(t)("flashcard.modes.quiz", "Quiz") : _ctx.practiceMode === "typing" ? unref(t)("flashcard.modes.typing", "Typing") : _ctx.practiceMode === "listening" ? unref(t)("flashcard.modes.listening", "Listening") : _ctx.practiceMode === "image" ? unref(t)("flashcard.modes.image", "Image") : _ctx.practiceMode === "pictionary" ? unref(t)("flashcard.modes.pictionary", "Pictionary") : _ctx.practiceMode === "flip-tile" ? unref(t)("flashcard.modes.flipTile", "Flip Tile") : _ctx.practiceMode === "bubble-shooter" ? unref(t)("flashcard.modes.bubbleShooter", "Bubble Shooter") : _ctx.practiceMode === "snake-game" ? unref(t)("flashcard.modes.snakeGame", "Snake Hunt") : unref(t)("flashcard.modes.pronunciation", "Pronunciation")), 1),
                    _cache[50] || (_cache[50] = createBaseVNode("svg", {
                      class: "w-4 h-4 opacity-80 absolute right-2 md:right-3 top-1/2 -translate-y-1/2 pointer-events-none",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M5.23 7.21a.75.75 0 011.06.02L10 11.17l3.71-3.94a.75.75 0 111.08 1.04l-4.24 4.5a.75.75 0 01-1.08 0L5.21 8.27a.75.75 0 01.02-1.06z",
                        "clip-rule": "evenodd"
                      })
                    ], -1))
                  ], 10, _hoisted_58$2),
                  createVNode(Transition, {
                    name: "fade",
                    appear: ""
                  }, {
                    default: withCtx(() => [
                      desktopDropdownOpen.value && !_ctx.practiceStarted ? (openBlock(), createElementBlock("div", _hoisted_60$2, [
                        createBaseVNode("ul", _hoisted_61$2, [
                          createBaseVNode("li", _hoisted_62$2, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[25] || (_cache[25] = ($event) => selectMode("flashcard"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.flashcard", "Flashcard")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", scrambleWordsEnabled.value ? "bg-green-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[26] || (_cache[26] = withModifiers(($event) => toggleScrambleWordsFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.scrambleWords.toggle", "Scramble Words"),
                              "aria-label": unref(t)("flashcard.scrambleWords.toggle", "Scramble Words")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", scrambleWordsEnabled.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_63$2)
                          ]),
                          createBaseVNode("li", null, [
                            createBaseVNode("button", {
                              class: "w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/10",
                              onClick: _cache[27] || (_cache[27] = ($event) => selectMode("quiz"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.quiz", "Quiz")), 1)
                          ]),
                          createBaseVNode("li", _hoisted_64$2, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[28] || (_cache[28] = ($event) => selectMode("typing"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.typing", "Typing")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", typingQuizEnabled.value ? "bg-purple-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[29] || (_cache[29] = withModifiers(($event) => toggleTypingQuizFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.typing.quizToggle", "Multiple Choice"),
                              "aria-label": unref(t)("flashcard.typing.quizToggle", "Multiple Choice")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", typingQuizEnabled.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_65$2)
                          ]),
                          createBaseVNode("li", _hoisted_66$2, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[30] || (_cache[30] = ($event) => selectMode("listening"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.listening", "Listening")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", listeningQuizEnabled.value ? "bg-cyan-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[31] || (_cache[31] = withModifiers(($event) => toggleListeningQuizFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.listening.quizToggle", "Multiple Choice"),
                              "aria-label": unref(t)("flashcard.listening.quizToggle", "Multiple Choice")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", listeningQuizEnabled.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_67$2)
                          ]),
                          createBaseVNode("li", _hoisted_68$2, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !imageModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[32] || (_cache[32] = ($event) => selectMode("image")),
                              disabled: !imageModeAvailable.value,
                              "aria-disabled": !imageModeAvailable.value ? "true" : "false",
                              title: !imageModeAvailable.value ? unref(t)("flashcard.image.unavailable", "Image mode is unavailable for the selected date") : unref(t)("flashcard.modes.image", "Image")
                            }, toDisplayString$1(unref(t)("flashcard.modes.image", "Image")), 11, _hoisted_69$2),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                imageModeAvailable.value ? imageQuizEnabled.value ? "bg-purple-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[33] || (_cache[33] = withModifiers(($event) => imageModeAvailable.value && toggleImageQuizFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.image.quizToggle", "Multiple Choice"),
                              "aria-label": unref(t)("flashcard.image.quizToggle", "Multiple Choice")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", imageQuizEnabled.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_70$2)
                          ]),
                          createBaseVNode("li", _hoisted_71$2, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !pictionaryModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[34] || (_cache[34] = ($event) => selectMode("pictionary")),
                              disabled: !pictionaryModeAvailable.value,
                              "aria-disabled": !pictionaryModeAvailable.value ? "true" : "false",
                              title: !pictionaryModeAvailable.value ? unref(t)("flashcard.pictionary.unavailable", "Pictionary mode is unavailable for the selected date") : unref(t)("flashcard.modes.pictionary", "Pictionary")
                            }, toDisplayString$1(unref(t)("flashcard.modes.pictionary", "Pictionary")), 11, _hoisted_72$2),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                pictionaryModeAvailable.value ? pictionaryDefinitionMode.value ? "bg-teal-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[35] || (_cache[35] = withModifiers(($event) => pictionaryModeAvailable.value && togglePictionaryDefinitionModeFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.pictionary.definitionToggle", "Definition Mode"),
                              "aria-label": unref(t)("flashcard.pictionary.definitionToggle", "Definition Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", pictionaryDefinitionMode.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_73$2)
                          ]),
                          createBaseVNode("li", _hoisted_74$2, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !flipTileModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[36] || (_cache[36] = ($event) => selectMode("flip-tile")),
                              disabled: !flipTileModeAvailable.value,
                              "aria-disabled": !flipTileModeAvailable.value ? "true" : "false",
                              title: !flipTileModeAvailable.value ? unref(t)("flashcard.flipTile.unavailable", "Flip Tile mode is unavailable for the selected date") : unref(t)("flashcard.modes.flipTile", "Flip Tile")
                            }, toDisplayString$1(unref(t)("flashcard.modes.flipTile", "Flip Tile")), 11, _hoisted_75$2),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                flipTileModeAvailable.value ? useFlipTileHints.value ? "bg-teal-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[37] || (_cache[37] = withModifiers(($event) => flipTileModeAvailable.value && toggleFlipTileHintsFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.flipTile.hintsToggle", "Use Definition Hints"),
                              "aria-label": unref(t)("flashcard.flipTile.hintsToggle", "Use Definition Hints")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", useFlipTileHints.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_76$2)
                          ]),
                          createBaseVNode("li", _hoisted_77$2, [
                            createBaseVNode("button", {
                              class: normalizeClass(["text-left flex-1 truncate", !bubbleShooterModeAvailable.value ? "opacity-50 cursor-not-allowed" : ""]),
                              onClick: _cache[38] || (_cache[38] = ($event) => selectMode("bubble-shooter")),
                              disabled: !bubbleShooterModeAvailable.value,
                              "aria-disabled": !bubbleShooterModeAvailable.value ? "true" : "false",
                              title: !bubbleShooterModeAvailable.value ? unref(t)("flashcard.bubbleShooter.unavailable", "Bubble Shooter mode is disabled for dates with more than 8 vocabulary words") : unref(t)("flashcard.modes.bubbleShooter", "Bubble Shooter")
                            }, toDisplayString$1(unref(t)("flashcard.modes.bubbleShooter", "Bubble Shooter")), 11, _hoisted_78$1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                bubbleShooterModeAvailable.value ? bubbleShooterVietnameseMode.value ? "bg-orange-600" : "bg-gray-200 dark:bg-[#0a0a0a]" : "opacity-50 cursor-not-allowed pointer-events-none bg-gray-200 dark:bg-[#0a0a0a]"
                              ]]),
                              onClick: _cache[39] || (_cache[39] = withModifiers(($event) => bubbleShooterModeAvailable.value && toggleBubbleShooterVietnameseMode(), ["stop"])),
                              title: unref(t)("flashcard.bubbleShooter.vietnameseModeToggle", "Vietnamese First Letter Mode"),
                              "aria-label": unref(t)("flashcard.bubbleShooter.vietnameseModeToggle", "Vietnamese First Letter Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", bubbleShooterVietnameseMode.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_79$1)
                          ]),
                          createBaseVNode("li", _hoisted_80$1, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[40] || (_cache[40] = ($event) => selectMode("snake-game")),
                              title: unref(t)("flashcard.modes.snakeGame", "Snake Hunt")
                            }, toDisplayString$1(unref(t)("flashcard.modes.snakeGame", "Snake Hunt")), 9, _hoisted_81$1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", [
                                snakeDoubleBaitEnabled.value ? "bg-emerald-600" : "bg-gray-200 dark:bg-[#0a0a0a]",
                                _ctx.practiceStarted ? "opacity-50 cursor-not-allowed pointer-events-none" : ""
                              ]]),
                              onClick: _cache[41] || (_cache[41] = withModifiers(($event) => toggleSnakeDoubleBaitFromDropdown(), ["stop"])),
                              title: _ctx.practiceStarted ? unref(t)("flashcard.settings.disabledDuringPractice", "Settings are disabled during practice") : unref(t)("flashcard.snake.doubleBaitToggle", "Double Bait Mode"),
                              "aria-label": unref(t)("flashcard.snake.doubleBaitToggle", "Double Bait Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", snakeDoubleBaitEnabled.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_82$1)
                          ]),
                          createBaseVNode("li", _hoisted_83$1, [
                            createBaseVNode("button", {
                              class: "text-left flex-1 truncate",
                              onClick: _cache[42] || (_cache[42] = ($event) => selectMode("pronunciation"))
                            }, toDisplayString$1(unref(t)("flashcard.modes.pronunciation", "Pronunciation")), 1),
                            createBaseVNode("button", {
                              class: normalizeClass(["relative inline-flex h-5 w-10 items-center rounded-full transition-colors border border-gray-300 dark:border-gray-600", wordsCrushEnabled.value ? "bg-amber-600" : "bg-gray-200 dark:bg-[#0a0a0a]"]),
                              onClick: _cache[43] || (_cache[43] = withModifiers(($event) => toggleWordsCrushFromDropdown(), ["stop"])),
                              title: unref(t)("flashcard.pronunciation.wordsCrushToggle", "Hidden Words Mode"),
                              "aria-label": unref(t)("flashcard.pronunciation.wordsCrushToggle", "Hidden Words Mode")
                            }, [
                              createBaseVNode("span", {
                                class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", wordsCrushEnabled.value ? "translate-x-5" : "translate-x-0.5"])
                              }, null, 2)
                            ], 10, _hoisted_84$1)
                          ])
                        ])
                      ])) : createCommentVNode("", true)
                    ]),
                    _: 1
                  })
                ]),
                createBaseVNode("button", {
                  onClick: onShowSettings,
                  disabled: _ctx.practiceStarted,
                  "aria-disabled": _ctx.practiceStarted ? "true" : "false",
                  class: normalizeClass(["text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300", _ctx.practiceStarted ? "opacity-50 cursor-not-allowed" : ""]),
                  title: _ctx.practiceStarted ? unref(t)("flashcard.settings.disabledDuringPractice", "Settings are disabled during practice") : unref(t)("flashcard.header.settings", "Settings")
                }, _cache[51] || (_cache[51] = [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 md:w-7 md:h-7",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)
                ]), 10, _hoisted_85$1)
              ])
            ])
          ])
        ])
      ]);
    };
  }
});

const FlashcardHeader = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$G
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$F = { class: "max-w-4xl mx-auto px-3 sm:px-4 md:px-6 py-2 sm:py-3 md:py-4" };
const _hoisted_2$C = { class: "w-full bg-gray-200 dark:bg-[#0f0f0f] rounded-full h-1.5 sm:h-2 md:h-3" };
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  __name: "FlashcardProgress",
  props: {
    progressPercentage: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$F, [
        createBaseVNode("div", _hoisted_2$C, [
          createBaseVNode("div", {
            class: "bg-blue-500 rounded-full transition-all duration-300 h-1.5 sm:h-2 md:h-3",
            style: normalizeStyle({ width: _ctx.progressPercentage + "%" })
          }, null, 4)
        ])
      ]);
    };
  }
});

const FlashcardProgress = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$F
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$E = { class: "bg-white dark:bg-[#0f0f0f] border-b border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_2$B = { class: "max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-4" };
const _hoisted_3$A = { class: "flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4" };
const _hoisted_4$y = { class: "flex flex-col sm:flex-row items-start sm:items-center gap-4" };
const _hoisted_5$w = { class: "flex items-center gap-2" };
const _hoisted_6$u = { class: "relative" };
const _hoisted_7$t = ["disabled", "aria-disabled", "title"];
const _hoisted_8$t = { class: "truncate" };
const _hoisted_9$s = {
  key: 0,
  class: "absolute bottom-full mb-1 w-full bg-white dark:bg-dark-bg border border-gray-300 dark:border-dark-bg-soft dark:border-2 rounded-md shadow-xl ring-1 ring-black ring-opacity-5 max-h-60 overflow-y-auto origin-bottom",
  style: { "z-index": "99999 !important" }
};
const _hoisted_10$r = ["onClick"];
const _hoisted_11$r = { class: "truncate" };
const _hoisted_12$q = { class: "ml-2 text-xs text-gray-500 dark:text-white/60 flex-shrink-0" };
const _hoisted_13$q = {
  key: 0,
  class: "text-sm text-gray-600 dark:text-white/70"
};
const _hoisted_14$q = { class: "flex items-center gap-1" };
const _sfc_main$E = /* @__PURE__ */ defineComponent({
  __name: "FlashcardDateFilter",
  props: {
    vocabularies: {},
    enabled: { type: Boolean },
    selectedDate: {},
    practiceStarted: { type: Boolean }
  },
  emits: ["update:enabled", "update:selectedDate"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t, locale } = useI18n();
    const isDropdownOpen = ref(false);
    computed(() => true);
    const localSelectedDate = computed({
      get: () => props.selectedDate,
      set: (value) => emit("update:selectedDate", value)
    });
    const availableDates = computed(() => {
      if (!props.vocabularies.length) return [];
      const grouped = groupVocabulariesByDate(props.vocabularies, locale.value);
      return grouped.map((group) => ({
        date: group.date,
        displayDate: group.displayDate,
        count: group.vocabularies.length
      }));
    });
    const toggleDropdown = () => {
      if (props.practiceStarted) return;
      isDropdownOpen.value = !isDropdownOpen.value;
    };
    const selectDate = (date) => {
      if (props.practiceStarted) return;
      localSelectedDate.value = date;
      isDropdownOpen.value = false;
    };
    const getSelectedDateDisplay = () => {
      if (!localSelectedDate.value) {
        return t("flashcard.dateFilter.allDates", "All dates");
      }
      const selectedGroup = availableDates.value.find((g) => g.date === localSelectedDate.value);
      if (!selectedGroup) {
        return t("flashcard.dateFilter.allDates", "All dates");
      }
      return `${selectedGroup.displayDate} (${selectedGroup.count})`;
    };
    const handleClickOutside = (event) => {
      const target = event.target;
      if (!target.closest(".relative")) {
        isDropdownOpen.value = false;
      }
    };
    const getFilterInfo = () => {
      if (!localSelectedDate.value) return "";
      const selectedGroup = availableDates.value.find((g) => g.date === localSelectedDate.value);
      if (!selectedGroup) return "";
      return t(
        "flashcard.dateFilter.info",
        { count: selectedGroup.count, date: selectedGroup.displayDate },
        `Showing ${selectedGroup.count} words from ${selectedGroup.displayDate}`
      );
    };
    watch(availableDates, (newDates) => {
      if (localSelectedDate.value && !newDates.some((d) => d.date === localSelectedDate.value)) {
        localSelectedDate.value = "";
      }
    });
    onMounted(() => {
      document.addEventListener("click", handleClickOutside);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleClickOutside);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$E, [
        createBaseVNode("div", _hoisted_2$B, [
          createBaseVNode("div", _hoisted_3$A, [
            createBaseVNode("div", _hoisted_4$y, [
              createBaseVNode("div", _hoisted_5$w, [
                _cache[2] || (_cache[2] = createBaseVNode("svg", {
                  class: "w-4 h-4 text-gray-500 dark:text-white/60",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z",
                    "clip-rule": "evenodd"
                  })
                ], -1)),
                createBaseVNode("div", _hoisted_6$u, [
                  createBaseVNode("button", {
                    type: "button",
                    onClick: toggleDropdown,
                    disabled: _ctx.practiceStarted,
                    "aria-disabled": _ctx.practiceStarted ? "true" : "false",
                    title: _ctx.practiceStarted ? unref(t)("flashcard.dateFilter.disabledDuringPractice", "Date filter is disabled during practice") : "",
                    class: "px-3 py-1.5 text-sm border border-gray-300 dark:border-dark-bg-soft dark:border-2 rounded-md bg-white dark:bg-dark-bg text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-400 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-between min-w-[200px] sm:min-w-[240px]"
                  }, [
                    createBaseVNode("span", _hoisted_8$t, toDisplayString$1(getSelectedDateDisplay()), 1),
                    (openBlock(), createElementBlock("svg", {
                      class: normalizeClass(["w-4 h-4 ml-2 transition-transform duration-200", { "rotate-180": isDropdownOpen.value }]),
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, _cache[1] || (_cache[1] = [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z",
                        "clip-rule": "evenodd"
                      }, null, -1)
                    ]), 2))
                  ], 8, _hoisted_7$t),
                  createVNode(Transition, {
                    "enter-active-class": "transform transition duration-100 ease-out",
                    "enter-from-class": "scale-95 opacity-0 translate-y-2",
                    "enter-to-class": "scale-100 opacity-100 translate-y-0",
                    "leave-active-class": "transform transition duration-75 ease-in",
                    "leave-from-class": "scale-100 opacity-100 translate-y-0",
                    "leave-to-class": "scale-95 opacity-0 translate-y-2"
                  }, {
                    default: withCtx(() => [
                      isDropdownOpen.value && !_ctx.practiceStarted ? (openBlock(), createElementBlock("div", _hoisted_9$s, [
                        createBaseVNode("button", {
                          type: "button",
                          onClick: _cache[0] || (_cache[0] = ($event) => selectDate("")),
                          class: normalizeClass(["w-full px-3 py-2 text-left text-sm hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors duration-150", {
                            "bg-blue-50 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400": localSelectedDate.value === ""
                          }])
                        }, toDisplayString$1(unref(t)("flashcard.dateFilter.allDates", "All dates")), 3),
                        (openBlock(true), createElementBlock(Fragment, null, renderList(availableDates.value, (group) => {
                          return openBlock(), createElementBlock("button", {
                            key: group.date,
                            type: "button",
                            onClick: ($event) => selectDate(group.date),
                            class: normalizeClass(["w-full px-3 py-2 text-left text-sm hover:bg-gray-100 dark:hover:bg-dark-bg-mute transition-colors duration-150 flex items-center justify-between", {
                              "bg-blue-50 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400": localSelectedDate.value === group.date
                            }])
                          }, [
                            createBaseVNode("span", _hoisted_11$r, toDisplayString$1(group.displayDate), 1),
                            createBaseVNode("span", _hoisted_12$q, " (" + toDisplayString$1(group.count) + ") ", 1)
                          ], 10, _hoisted_10$r);
                        }), 128))
                      ])) : createCommentVNode("", true)
                    ]),
                    _: 1
                  })
                ])
              ])
            ]),
            localSelectedDate.value ? (openBlock(), createElementBlock("div", _hoisted_13$q, [
              createBaseVNode("span", _hoisted_14$q, [
                _cache[3] || (_cache[3] = createBaseVNode("svg", {
                  class: "w-4 h-4",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z",
                    "clip-rule": "evenodd"
                  })
                ], -1)),
                createTextVNode(" " + toDisplayString$1(getFilterInfo()), 1)
              ])
            ])) : createCommentVNode("", true)
          ])
        ])
      ]);
    };
  }
});

const FlashcardDateFilter = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$E
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$D = { class: "perspective-1000" };
const _hoisted_2$A = { class: "flashcard-face flashcard-front absolute inset-0 bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 flex items-center justify-center p-4 sm:p-6 md:p-8" };
const _hoisted_3$z = { class: "text-center" };
const _hoisted_4$x = { class: "mb-3 sm:mb-4 md:mb-5" };
const _hoisted_5$v = { class: "px-2 py-1 sm:px-3 sm:py-1 md:px-4 md:py-2 xl:px-3 xl:py-1 2xl:px-3 2xl:py-1 bg-blue-100 dark:bg-gray-800 text-blue-800 dark:text-blue-300 text-xs sm:text-sm md:text-base xl:text-sm 2xl:text-sm font-medium rounded-full" };
const _hoisted_6$t = { class: "text-xl sm:text-2xl md:text-3xl font-bold text-gray-900 dark:text-white mb-3 sm:mb-4 md:mb-5" };
const _hoisted_7$s = { class: "text-sm sm:text-base md:text-lg text-gray-600 dark:text-gray-300 mb-4 sm:mb-5 md:mb-6" };
const _hoisted_8$s = { class: "text-xs sm:text-sm md:text-base text-gray-500 dark:text-gray-400" };
const _hoisted_9$r = { class: "text-base sm:text-lg md:text-xl xl:text-lg 2xl:text-xl font-bold text-gray-900 dark:text-white mb-2 sm:mb-3 md:mb-4 xl:mb-3 2xl:mb-3" };
const _hoisted_10$q = { class: "text-sm sm:text-base md:text-lg xl:text-base 2xl:text-lg text-gray-600 dark:text-gray-300 mb-4 sm:mb-5 md:mb-6 xl:mb-4 2xl:mb-5" };
const _hoisted_11$q = { class: "mb-4 sm:mb-5 md:mb-6 xl:mb-4 2xl:mb-5" };
const _hoisted_12$p = { class: "flex flex-wrap justify-center items-center gap-1 sm:gap-2 xl:gap-1.5 2xl:gap-2 mb-2 sm:mb-3 md:mb-4 xl:mb-3 2xl:mb-3 min-h-[3rem] xl:min-h-[2.5rem] 2xl:min-h-[3rem] max-w-full px-2 sm:px-0" };
const _hoisted_13$p = ["onClick"];
const _hoisted_14$p = {
  key: 0,
  class: "text-center max-w-full px-2"
};
const _hoisted_15$m = {
  key: 0,
  class: "text-green-600 dark:text-green-400"
};
const _hoisted_16$l = { class: "font-semibold text-sm sm:text-base mb-2" };
const _hoisted_17$l = { class: "bg-green-50 dark:bg-[#0f0f0f] border border-green-200 dark:border-dark-bg-mute rounded-lg p-3 sm:p-4" };
const _hoisted_18$k = { class: "text-green-700 dark:text-green-400 font-medium text-sm sm:text-base" };
const _hoisted_19$k = {
  key: 0,
  class: "text-green-600 dark:text-green-500 text-xs sm:text-sm mt-1 opacity-80"
};
const _hoisted_20$k = {
  key: 1,
  class: "text-red-600 dark:text-red-400"
};
const _hoisted_21$k = { class: "font-semibold text-sm sm:text-base mb-2" };
const _hoisted_22$i = { class: "bg-red-50 dark:bg-[#0f0f0f] border border-red-200 dark:border-dark-bg-mute rounded-lg p-3 sm:p-4" };
const _hoisted_23$i = { class: "text-red-700 dark:text-red-400 font-bold text-base sm:text-lg mb-1" };
const _hoisted_24$h = { class: "text-red-600 dark:text-red-500 text-sm sm:text-base" };
const _hoisted_25$h = {
  key: 0,
  class: "text-red-500 dark:text-red-600 text-xs sm:text-sm mt-1 opacity-80"
};
const _hoisted_26$f = { class: "flex justify-center flex-wrap gap-2 sm:gap-3 md:gap-4 xl:gap-2 2xl:gap-2.5 mb-4 sm:mb-5 md:mb-6 xl:mb-4 2xl:mb-4 px-2 sm:px-4 md:px-6 xl:px-4 2xl:px-6 max-w-full" };
const _hoisted_27$e = ["onClick", "disabled"];
const _hoisted_28$e = { class: "flex flex-wrap justify-center gap-1.5 xs:gap-2 sm:gap-3 md:gap-4 xl:gap-2 2xl:gap-3 px-2 sm:px-4 xl:px-2 2xl:px-4 max-w-full" };
const _hoisted_29$c = ["disabled", "title"];
const _hoisted_30$b = { class: "hidden xs:hidden sm:inline" };
const _hoisted_31$b = ["disabled"];
const _hoisted_32$9 = ["disabled"];
const _hoisted_33$9 = { class: "flashcard-face flashcard-back absolute inset-0 bg-gradient-to-br from-green-400 to-green-600 dark:from-green-700 dark:to-green-900 rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 flex items-center justify-center p-4 sm:p-6 md:p-8" };
const _hoisted_34$8 = { class: "text-center text-white" };
const _hoisted_35$8 = { class: "text-base sm:text-lg md:text-xl font-bold mb-3 sm:mb-4 md:mb-5" };
const _hoisted_36$7 = {
  key: 0,
  class: "text-sm sm:text-base md:text-lg mb-3 sm:mb-4 md:mb-5"
};
const _hoisted_37$6 = {
  key: 1,
  class: "text-xs sm:text-sm md:text-base mb-3 sm:mb-4 md:mb-5 leading-relaxed"
};
const _hoisted_38$6 = { class: "text-xs sm:text-sm md:text-base opacity-75" };
const MAX_SHUFFLE_HISTORY = 3;
const _sfc_main$D = /* @__PURE__ */ defineComponent({
  __name: "FlashcardCard",
  props: {
    currentCard: {},
    isFlipped: { type: Boolean },
    scrambleWordsEnabled: { type: Boolean },
    currentIndex: {},
    totalCards: {}
  },
  emits: ["flip-card", "next-card", "show-results", "scramble-answer"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const props = __props;
    const emit = __emit;
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    const { playAudio } = useVoiceStore();
    let autoAdvanceTimer = null;
    const clearAutoAdvanceTimer = () => {
      if (autoAdvanceTimer) {
        clearTimeout(autoAdvanceTimer);
        autoAdvanceTimer = null;
      }
    };
    const isSmallScreen = ref(false);
    const updateScreenSize = () => {
      if (typeof window !== "undefined") {
        isSmallScreen.value = window.innerWidth < 768;
      }
    };
    if (typeof window !== "undefined") {
      updateScreenSize();
      window.addEventListener("resize", updateScreenSize);
    }
    const assembledWord = ref([]);
    const availableLetters = ref([]);
    const scrambleAnswered = ref(false);
    const scrambleCorrect = ref(false);
    const previousShuffles = ref([]);
    const createAdvancedShuffle = (letters) => {
      const shuffled = [...letters];
      const passes = Math.max(3, Math.floor(letters.length / 2) + 1);
      for (let pass = 0; pass < passes; pass++) {
        const timeSeed = Date.now() + pass * 1e3;
        const randomSeed = Math.random() * 1e4;
        const passEntropy = (timeSeed + randomSeed) % 1;
        for (let i = shuffled.length - 1; i > 0; i--) {
          const baseRandom = Math.random();
          const timeRandom = Date.now() % 997 / 997;
          const passRandom = (pass + 1) / passes;
          const combinedRandom = (baseRandom + timeRandom + passRandom + passEntropy) % 1;
          const j = Math.floor(combinedRandom * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        if (pass % 2 === 0) {
          for (let i = 0; i < shuffled.length - 1; i++) {
            const entropy = (Math.random() + Date.now() % 101 / 100) % 1;
            if (entropy > 0.5) {
              const j = Math.min(i + 1 + Math.floor(Math.random() * 2), shuffled.length - 1);
              [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
          }
        }
      }
      return shuffled;
    };
    const isSimilarToPrevious = (current, previous) => {
      if (previous.length === 0) return false;
      return previous.some((prev) => {
        if (prev.length !== current.length) return false;
        let matches = 0;
        for (let i = 0; i < current.length; i++) {
          if (current[i] === prev[i]) matches++;
        }
        return matches / current.length > 0.6;
      });
    };
    const initializeScrambledLetters = () => {
      if (!props.currentCard || !props.scrambleWordsEnabled) return;
      const word = props.currentCard.word.toLowerCase();
      const letters = word.split("");
      const letterObjects = letters.map((char, index) => ({
        char: char.toUpperCase(),
        used: false,
        originalIndex: index
      }));
      let attempts = 0;
      let shuffledOrder;
      const maxAttempts = 10;
      do {
        shuffledOrder = createAdvancedShuffle(letters.map((char) => char.toUpperCase()));
        attempts++;
      } while (attempts < maxAttempts && isSimilarToPrevious(shuffledOrder, previousShuffles.value));
      previousShuffles.value.push(shuffledOrder);
      if (previousShuffles.value.length > MAX_SHUFFLE_HISTORY) {
        previousShuffles.value.shift();
      }
      const shuffledLetterObjects = [];
      const usedIndices = /* @__PURE__ */ new Set();
      shuffledOrder.forEach((char) => {
        const originalLetterIndex = letterObjects.findIndex(
          (obj, idx) => obj.char === char && !usedIndices.has(idx)
        );
        if (originalLetterIndex !== -1) {
          const originalLetterObj = letterObjects[originalLetterIndex];
          usedIndices.add(originalLetterIndex);
          shuffledLetterObjects.push({
            ...originalLetterObj,
            used: false
          });
        }
      });
      availableLetters.value = shuffledLetterObjects.length === letterObjects.length ? shuffledLetterObjects : letterObjects;
      assembledWord.value = [];
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
      console.log(" New shuffle created:", {
        word: props.currentCard.word,
        original: letters,
        shuffled: shuffledOrder,
        attempts,
        historySize: previousShuffles.value.length
      });
    };
    watch(() => props.currentCard, () => {
      clearAutoAdvanceTimer();
      if (props.scrambleWordsEnabled) {
        initializeScrambledLetters();
      }
    }, { immediate: true });
    watch(() => props.scrambleWordsEnabled, (enabled) => {
      clearAutoAdvanceTimer();
      if (enabled) {
        initializeScrambledLetters();
      } else {
        assembledWord.value = [];
        availableLetters.value = [];
        scrambleAnswered.value = false;
        scrambleCorrect.value = false;
        previousShuffles.value = [];
      }
    });
    const selectLetter = (index) => {
      if (availableLetters.value[index].used) return;
      if (scrambleAnswered.value && scrambleCorrect.value) return;
      assembledWord.value.push(availableLetters.value[index].char);
      availableLetters.value[index].used = true;
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
    };
    const removeLetter = (assembledIndex) => {
      if (scrambleAnswered.value && scrambleCorrect.value) return;
      const removedChar = assembledWord.value[assembledIndex];
      assembledWord.value.splice(assembledIndex, 1);
      const availableIndex = availableLetters.value.findIndex(
        (letter) => letter.char === removedChar && letter.used
      );
      if (availableIndex !== -1) {
        availableLetters.value[availableIndex].used = false;
      }
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
    };
    const clearAssembledWord = () => {
      if (scrambleAnswered.value && scrambleCorrect.value) return;
      availableLetters.value.forEach((letter) => {
        letter.used = false;
      });
      assembledWord.value = [];
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
    };
    const backspaceAssembledWord = () => {
      if (scrambleAnswered.value && scrambleCorrect.value) return;
      if (assembledWord.value.length === 0) return;
      const removedChar = assembledWord.value.pop();
      const availableIndex = availableLetters.value.findIndex(
        (letter) => letter.char === removedChar && letter.used
      );
      if (availableIndex !== -1) {
        availableLetters.value[availableIndex].used = false;
      }
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
    };
    const checkScrambleAnswer = async () => {
      if (assembledWord.value.length !== props.currentCard.word.length) return;
      const userAnswer = assembledWord.value.join("").toLowerCase();
      const correctAnswer = props.currentCard.word.toLowerCase();
      scrambleAnswered.value = true;
      scrambleCorrect.value = userAnswer === correctAnswer;
      clearAutoAdvanceTimer();
      const isLastCard = props.currentIndex !== void 0 && props.totalCards !== void 0 && props.currentIndex + 1 >= props.totalCards;
      console.log("Scramble Check Debug:", {
        currentIndex: props.currentIndex,
        totalCards: props.totalCards,
        isLastCard,
        isSmallScreen: isSmallScreen.value,
        scrambleCorrect: scrambleCorrect.value
      });
      emit("scramble-answer", scrambleCorrect.value);
      if (scrambleCorrect.value) {
        isCorrectAnswer.value = true;
        triggerFirework.value = true;
        triggerSound.value = true;
        try {
          await nextTick();
          await playAudio(props.currentCard.word);
        } catch (error) {
          console.warn("Voice playbook error:", error);
        }
        if (isSmallScreen.value) {
          console.log("Setting timer for correct answer:", isLastCard ? "show-results" : "next-card");
          autoAdvanceTimer = setTimeout(() => {
            console.log("Timer executed, emitting:", isLastCard ? "show-results" : "next-card");
            if (isLastCard) {
              emit("show-results");
            } else {
              emit("next-card");
            }
          }, 2500);
        }
      } else {
        isCorrectAnswer.value = false;
        triggerFirework.value = true;
        triggerSound.value = true;
        if (isSmallScreen.value) {
          console.log("Setting timer for incorrect answer:", isLastCard ? "show-results" : "next-card");
          autoAdvanceTimer = setTimeout(() => {
            console.log("Timer executed for incorrect, emitting:", isLastCard ? "show-results" : "next-card");
            if (isLastCard) {
              emit("show-results");
            } else {
              emit("next-card");
            }
          }, 2500);
        }
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$D, [
        createBaseVNode("div", {
          class: normalizeClass([["flashcard", { "flipped": _ctx.isFlipped }], "relative w-full cursor-pointer h-80 sm:h-96 md:h-[28rem] xl:h-[30rem] 2xl:h-[32rem] select-none"]),
          onClick: _cache[0] || (_cache[0] = ($event) => !_ctx.scrambleWordsEnabled && _ctx.$emit("flip-card")),
          onCopy: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["prevent"])),
          onCut: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["prevent"])),
          onContextmenu: _cache[3] || (_cache[3] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          createBaseVNode("div", _hoisted_2$A, [
            createBaseVNode("div", _hoisted_3$z, [
              createBaseVNode("div", _hoisted_4$x, [
                createBaseVNode("span", _hoisted_5$v, toDisplayString$1(unref(getTopicName)(_ctx.currentCard.category)), 1)
              ]),
              !_ctx.scrambleWordsEnabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("h2", _hoisted_6$t, toDisplayString$1(_ctx.currentCard.word), 1),
                createBaseVNode("p", _hoisted_7$s, toDisplayString$1(_ctx.currentCard.pronunciation), 1),
                createBaseVNode("p", _hoisted_8$s, toDisplayString$1(unref(t)("flashcard.card.flip_to_meaning", "Click to see meaning")), 1)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createBaseVNode("h3", _hoisted_9$r, toDisplayString$1(unref(t)("flashcard.scrambleWords.instruction", "Arrange the letters to form the word")), 1),
                createBaseVNode("p", _hoisted_10$q, toDisplayString$1(_ctx.currentCard.pronunciation), 1),
                createBaseVNode("div", _hoisted_11$q, [
                  createBaseVNode("div", _hoisted_12$p, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(assembledWord.value, (letter, index) => {
                      return openBlock(), createElementBlock("div", {
                        key: `assembled-${index}`,
                        class: "w-8 h-8 sm:w-10 sm:h-10 md:w-12 md:h-12 xl:w-10 xl:h-10 2xl:w-11 2xl:h-11 border-2 border-gray-300 dark:border-dark-bg-mute rounded-lg flex items-center justify-center bg-blue-50 dark:bg-[#0f0f0f] text-lg sm:text-xl md:text-2xl xl:text-xl 2xl:text-2xl font-bold text-gray-900 dark:text-white cursor-pointer hover:bg-blue-100 dark:hover:bg-[#1a1a1a] transition-colors",
                        onClick: ($event) => removeLetter(index)
                      }, toDisplayString$1(letter), 9, _hoisted_13$p);
                    }), 128)),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(Math.max(0, _ctx.currentCard.word.length - assembledWord.value.length), (n) => {
                      return openBlock(), createElementBlock("div", {
                        key: `empty-${n}`,
                        class: "w-8 h-8 sm:w-10 sm:h-10 md:w-12 md:h-12 xl:w-10 xl:h-10 2xl:w-11 2xl:h-11 border-2 border-dashed border-gray-300 dark:border-dark-bg-mute rounded-lg bg-gray-50 dark:bg-[#0f0f0f]"
                      });
                    }), 128))
                  ]),
                  scrambleAnswered.value ? (openBlock(), createElementBlock("div", _hoisted_14$p, [
                    scrambleCorrect.value ? (openBlock(), createElementBlock("div", _hoisted_15$m, [
                      createBaseVNode("p", _hoisted_16$l, "  " + toDisplayString$1(unref(t)("flashcard.scrambleWords.correct", "Correct!")), 1),
                      createBaseVNode("div", _hoisted_17$l, [
                        createBaseVNode("p", _hoisted_18$k, toDisplayString$1(_ctx.currentCard.meaning), 1),
                        _ctx.currentCard.partOfSpeech ? (openBlock(), createElementBlock("p", _hoisted_19$k, toDisplayString$1(unref(t)(`vocabulary.wordTypes.${_ctx.currentCard.partOfSpeech}`, _ctx.currentCard.partOfSpeech)), 1)) : createCommentVNode("", true)
                      ])
                    ])) : (openBlock(), createElementBlock("div", _hoisted_20$k, [
                      createBaseVNode("p", _hoisted_21$k, "  " + toDisplayString$1(unref(t)("flashcard.scrambleWords.incorrect", "Try again!")), 1),
                      createBaseVNode("div", _hoisted_22$i, [
                        createBaseVNode("p", _hoisted_23$i, toDisplayString$1(_ctx.currentCard.word.toUpperCase()), 1),
                        createBaseVNode("p", _hoisted_24$h, toDisplayString$1(_ctx.currentCard.meaning), 1),
                        _ctx.currentCard.partOfSpeech ? (openBlock(), createElementBlock("p", _hoisted_25$h, toDisplayString$1(unref(t)(`vocabulary.wordTypes.${_ctx.currentCard.partOfSpeech}`, _ctx.currentCard.partOfSpeech)), 1)) : createCommentVNode("", true)
                      ])
                    ]))
                  ])) : createCommentVNode("", true)
                ]),
                createBaseVNode("div", _hoisted_26$f, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(availableLetters.value, (letter, index) => {
                    return withDirectives((openBlock(), createElementBlock("button", {
                      key: `scrambled-${index}`,
                      class: "w-8 h-8 sm:w-10 sm:h-10 md:w-12 md:h-12 xl:w-10 xl:h-10 2xl:w-11 2xl:h-11 border-2 border-gray-400 dark:border-dark-bg-soft rounded-lg flex items-center justify-center bg-white dark:bg-[#0f0f0f] hover:bg-gray-100 dark:hover:bg-[#1a1a1a] text-lg sm:text-xl md:text-2xl xl:text-xl 2xl:text-2xl font-bold text-gray-900 dark:text-white cursor-pointer transition-all duration-200 hover:scale-105 active:scale-95",
                      onClick: ($event) => selectLetter(index),
                      disabled: scrambleAnswered.value && scrambleCorrect.value
                    }, toDisplayString$1(letter.char), 9, _hoisted_27$e)), [
                      [vShow, !letter.used]
                    ]);
                  }), 128))
                ]),
                createBaseVNode("div", _hoisted_28$e, [
                  createBaseVNode("button", {
                    onClick: backspaceAssembledWord,
                    class: "px-2 py-1 xs:px-2 xs:py-1.5 sm:px-3 sm:py-2 md:px-4 md:py-2.5 xl:px-3 xl:py-2 2xl:px-4 2xl:py-2.5 bg-orange-500 hover:bg-orange-600 dark:bg-orange-600 dark:hover:bg-orange-700 text-white text-xs sm:text-sm md:text-base xl:text-sm 2xl:text-base font-semibold rounded-md sm:rounded-lg transition-colors flex items-center gap-1 sm:gap-2 xl:gap-1 2xl:gap-2 min-w-0 flex-shrink-0",
                    disabled: assembledWord.value.length === 0 || scrambleAnswered.value && scrambleCorrect.value,
                    title: unref(t)("flashcard.scrambleWords.backspace", "Backspace")
                  }, [
                    _cache[4] || (_cache[4] = createBaseVNode("svg", {
                      class: "w-3 h-3 sm:w-4 sm:h-4 xl:w-3 xl:h-3 2xl:w-4 2xl:h-4",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M6.707 4.879A3 3 0 018.828 4H15a3 3 0 013 3v6a3 3 0 01-3 3H8.828a3 3 0 01-2.12-.879l-4.415-4.414a1 1 0 010-1.414l4.414-4.414zm4 3.707a1 1 0 00-1.414-1.414L8 8.586 6.707 7.293a1 1 0 10-1.414 1.414L6.586 10l-1.293 1.293a1 1 0 101.414 1.414L8 11.414l1.293 1.293a1 1 0 001.414-1.414L9.414 10l1.293-1.293z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)),
                    createBaseVNode("span", _hoisted_30$b, toDisplayString$1(unref(t)("flashcard.scrambleWords.backspace", "Backspace")), 1)
                  ], 8, _hoisted_29$c),
                  createBaseVNode("button", {
                    onClick: clearAssembledWord,
                    class: "px-2 py-1 xs:px-3 xs:py-1.5 sm:px-4 sm:py-2 md:px-5 md:py-2.5 xl:px-4 xl:py-2 2xl:px-5 2xl:py-2.5 bg-gray-500 hover:bg-gray-600 dark:bg-gray-600 dark:hover:bg-gray-700 text-white text-xs sm:text-sm md:text-base xl:text-sm 2xl:text-base font-semibold rounded-md sm:rounded-lg transition-colors min-w-0 flex-shrink-0",
                    disabled: assembledWord.value.length === 0 || scrambleAnswered.value && scrambleCorrect.value
                  }, toDisplayString$1(unref(t)("flashcard.scrambleWords.clear", "Clear")), 9, _hoisted_31$b),
                  createBaseVNode("button", {
                    onClick: checkScrambleAnswer,
                    class: "px-2 py-1 xs:px-3 xs:py-1.5 sm:px-4 sm:py-2 md:px-5 md:py-2.5 xl:px-4 xl:py-2 2xl:px-5 2xl:py-2.5 bg-blue-600 hover:bg-blue-700 text-white text-xs sm:text-sm md:text-base xl:text-sm 2xl:text-base font-semibold rounded-md sm:rounded-lg transition-colors min-w-0 flex-shrink-0",
                    disabled: assembledWord.value.length !== _ctx.currentCard.word.length || scrambleAnswered.value && scrambleCorrect.value
                  }, toDisplayString$1(unref(t)("flashcard.scrambleWords.check", "Check")), 9, _hoisted_32$9)
                ])
              ], 64))
            ])
          ]),
          createBaseVNode("div", _hoisted_33$9, [
            createBaseVNode("div", _hoisted_34$8, [
              createBaseVNode("h3", _hoisted_35$8, toDisplayString$1(_ctx.currentCard.meaning), 1),
              _ctx.currentCard.partOfSpeech ? (openBlock(), createElementBlock("p", _hoisted_36$7, toDisplayString$1(unref(t)(`vocabulary.wordTypes.${_ctx.currentCard.partOfSpeech}`, _ctx.currentCard.partOfSpeech)), 1)) : createCommentVNode("", true),
              _ctx.currentCard.example ? (openBlock(), createElementBlock("p", _hoisted_37$6, toDisplayString$1(_ctx.currentCard.example), 1)) : createCommentVNode("", true),
              createBaseVNode("p", _hoisted_38$6, toDisplayString$1(unref(t)("flashcard.card.flip_back", "Click to flip back")), 1)
            ])
          ])
        ], 34),
        createVNode(unref(FireworkSoundEffect), {
          ref_key: "fireworkEffect",
          ref: fireworkEffect,
          "trigger-firework": triggerFirework.value,
          "trigger-sound": triggerSound.value,
          "is-correct": isCorrectAnswer.value,
          onEffectComplete: resetTriggers
        }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
      ]);
    };
  }
});

const FlashcardCard = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["__scopeId", "data-v-e4d27939"]]);

const FlashcardCard$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: FlashcardCard
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$C = { class: "h-full flex flex-col" };
const _hoisted_2$z = { class: "text-center mb-4" };
const _hoisted_3$y = { class: "px-4 py-2 bg-yellow-100 dark:bg-gray-800 text-yellow-800 dark:text-yellow-300 text-sm font-medium rounded-full" };
const _hoisted_4$w = { class: "text-center mb-4 flex-shrink-0" };
const _hoisted_5$u = { class: "text-xl sm:text-2xl md:text-3xl font-bold text-gray-900 dark:text-white mb-2" };
const _hoisted_6$s = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_7$r = { class: "text-xs sm:text-sm md:text-base text-gray-500 dark:text-gray-400 mt-1" };
const _hoisted_8$r = { class: "flex-1 flex flex-col justify-center min-h-0" };
const _hoisted_9$q = { class: "flex items-center justify-center" };
const _hoisted_10$p = { class: "grid grid-cols-2 gap-3 w-full max-w-lg" };
const _hoisted_11$p = ["onClick", "disabled"];
const _hoisted_12$o = { class: "absolute top-2 left-2 w-6 h-6 rounded-full text-xs font-semibold flex items-center justify-center bg-gray-200 text-gray-700 dark:bg-white/10 dark:text-white/80" };
const _hoisted_13$o = { class: "text-center px-6" };
const _hoisted_14$o = {
  key: 0,
  class: "absolute top-2 right-2 text-green-500"
};
const _hoisted_15$l = {
  key: 1,
  class: "absolute top-2 right-2 text-red-500"
};
const _sfc_main$C = /* @__PURE__ */ defineComponent({
  __name: "FlashcardQuiz",
  props: {
    currentCard: {},
    quizOptions: {},
    selectedAnswer: {},
    quizAnswered: { type: Boolean }
  },
  emits: ["select-answer"],
  setup(__props, { emit: __emit }) {
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const { t } = useI18n();
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const props = __props;
    const emit = __emit;
    const getCorrectAnswer = () => {
      return props.currentCard.meaning.split(" - ")[0].trim();
    };
    const handleSelectAnswer = (answer) => {
      if (props.quizAnswered) return;
      emit("select-answer", answer);
      const correctAnswer = getCorrectAnswer();
      isCorrectAnswer.value = answer === correctAnswer;
      setTimeout(() => {
        triggerFirework.value = true;
        triggerSound.value = true;
      }, 100);
    };
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 p-8 h-96 select-none",
        onCopy: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createBaseVNode("div", _hoisted_1$C, [
          createBaseVNode("div", _hoisted_2$z, [
            createBaseVNode("span", _hoisted_3$y, toDisplayString$1(unref(getTopicName)(_ctx.currentCard.category)), 1)
          ]),
          createBaseVNode("div", _hoisted_4$w, [
            createBaseVNode("h2", _hoisted_5$u, toDisplayString$1(_ctx.currentCard.word), 1),
            createBaseVNode("p", _hoisted_6$s, toDisplayString$1(_ctx.currentCard.pronunciation), 1),
            createBaseVNode("p", _hoisted_7$r, toDisplayString$1(unref(t)("flashcard.quiz.instruction", "Choose the correct meaning:")), 1)
          ]),
          createBaseVNode("div", _hoisted_8$r, [
            createBaseVNode("div", _hoisted_9$q, [
              createBaseVNode("div", _hoisted_10$p, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.quizOptions, (option, index) => {
                  return openBlock(), createElementBlock("button", {
                    key: index,
                    onClick: ($event) => handleSelectAnswer(option),
                    class: normalizeClass([
                      "relative p-4 text-center rounded-lg border-2 transition-all duration-200 font-semibold text-sm min-h-[60px] flex items-center justify-center",
                      _ctx.quizAnswered ? option === getCorrectAnswer() ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300 border-green-300 dark:border-green-700" : option === _ctx.selectedAnswer ? "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-300 border-red-300 dark:border-red-700" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60 hover:shadow-sm hover:scale-[1.01] dark:hover:bg-white/5"
                    ]),
                    disabled: _ctx.quizAnswered
                  }, [
                    createBaseVNode("span", _hoisted_12$o, toDisplayString$1(String.fromCharCode(65 + index)), 1),
                    createBaseVNode("span", _hoisted_13$o, toDisplayString$1(option), 1),
                    _ctx.quizAnswered && option === getCorrectAnswer() ? (openBlock(), createElementBlock("span", _hoisted_14$o, _cache[3] || (_cache[3] = [
                      createBaseVNode("svg", {
                        class: "w-5 h-5",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)
                    ]))) : _ctx.quizAnswered && option === _ctx.selectedAnswer && option !== getCorrectAnswer() ? (openBlock(), createElementBlock("span", _hoisted_15$l, _cache[4] || (_cache[4] = [
                      createBaseVNode("svg", {
                        class: "w-5 h-5",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)
                    ]))) : createCommentVNode("", true)
                  ], 10, _hoisted_11$p);
                }), 128))
              ])
            ])
          ])
        ]),
        createVNode(unref(FireworkSoundEffect), {
          ref_key: "fireworkEffect",
          ref: fireworkEffect,
          "trigger-firework": triggerFirework.value,
          "trigger-sound": triggerSound.value,
          "is-correct": isCorrectAnswer.value,
          onEffectComplete: resetTriggers
        }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
      ], 32);
    };
  }
});

const FlashcardQuiz = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$C
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$B = { class: "h-full flex flex-col" };
const _hoisted_2$y = { class: "text-center mb-6" };
const _hoisted_3$x = { class: "px-4 py-2 bg-purple-100 dark:bg-gray-800 text-purple-800 dark:text-purple-300 text-sm font-medium rounded-full" };
const _hoisted_4$v = { class: "text-center mb-8" };
const _hoisted_5$t = { class: "text-2xl sm:text-3xl md:text-4xl font-bold text-gray-900 dark:text-white mb-4" };
const _hoisted_6$r = {
  key: 0,
  class: "text-base sm:text-lg md:text-xl text-gray-600 dark:text-gray-300"
};
const _hoisted_7$q = {
  key: 1,
  class: "text-base sm:text-lg md:text-xl text-gray-600 dark:text-gray-300"
};
const _hoisted_8$q = { class: "flex-1 flex flex-col justify-center" };
const _hoisted_9$p = {
  key: 0,
  class: "max-w-lg mx-auto w-full"
};
const _hoisted_10$o = { class: "relative" };
const _hoisted_11$o = ["value", "disabled", "placeholder"];
const _hoisted_12$n = {
  key: 0,
  class: "absolute right-3 top-1/2 transform -translate-y-1/2"
};
const _hoisted_13$n = {
  key: 0,
  class: "text-green-500"
};
const _hoisted_14$n = {
  key: 1,
  class: "text-red-500"
};
const _hoisted_15$k = {
  key: 0,
  class: "mt-4 text-center"
};
const _hoisted_16$k = { class: "text-gray-600 dark:text-gray-400 text-sm" };
const _hoisted_17$k = { class: "text-lg sm:text-xl md:text-2xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_18$j = {
  key: 1,
  class: "w-full px-2 sm:px-3 md:px-0"
};
const _hoisted_19$j = { class: "grid grid-cols-1 sm:grid-cols-2 gap-1.5 sm:gap-2 justify-items-stretch w-full" };
const _hoisted_20$j = ["onClick", "disabled"];
const _hoisted_21$j = { class: "inline-flex items-center justify-center w-5 h-5 rounded-full text-xs font-semibold bg-gray-200 text-gray-700 dark:bg-white/10 dark:text-white/80 shrink-0" };
const _hoisted_22$h = { class: "truncate overflow-hidden min-w-0" };
const _hoisted_23$h = {
  key: 0,
  class: "mt-3 sm:mt-4 text-center px-2"
};
const _hoisted_24$g = {
  key: 0,
  class: "text-green-600 dark:text-green-400 font-medium text-sm sm:text-base"
};
const _hoisted_25$g = {
  key: 1,
  class: "text-red-600 dark:text-red-400 font-medium text-sm sm:text-base break-words"
};
const _hoisted_26$e = { class: "font-bold" };
const _hoisted_27$d = { class: "text-center mt-6" };
const _hoisted_28$d = ["disabled"];
const _sfc_main$B = /* @__PURE__ */ defineComponent({
  __name: "FlashcardTyping",
  props: {
    currentCard: {},
    typingAnswer: {},
    typingAnswered: { type: Boolean },
    typingCorrect: { type: Boolean },
    typingQuizEnabled: { type: Boolean },
    typingQuizOptions: {},
    typingQuizSelected: {},
    typingQuizAnswered: { type: Boolean }
  },
  emits: ["update:typingAnswer", "check-answer", "select-typing-quiz-answer"],
  setup(__props, { emit: __emit }) {
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const { t } = useI18n();
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const props = __props;
    const emit = __emit;
    const stripDiacritics = (s) => s.replace(/[]/g, "w").replace(/[]/g, "W").normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(//g, "d").replace(//g, "D");
    const handleInput = (event) => {
      const target = event.target;
      const sanitized = stripDiacritics(target.value);
      if (sanitized !== target.value) {
        target.value = sanitized;
      }
      emit("update:typingAnswer", sanitized);
    };
    const getShortMeaning = (meaning) => {
      return meaning.split(" - ")[0].trim();
    };
    const handleCheckAnswer = () => {
      if (props.typingAnswered) return;
      emit("check-answer");
      setTimeout(() => {
        isCorrectAnswer.value = props.typingAnswer.toLowerCase().trim() === props.currentCard.word.toLowerCase();
        triggerFirework.value = true;
        triggerSound.value = true;
      }, 100);
    };
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    watch(() => props.typingAnswered, (newValue) => {
      if (newValue && !triggerFirework.value) {
        if (typeof props.typingCorrect === "boolean") {
          isCorrectAnswer.value = props.typingCorrect;
        } else {
          isCorrectAnswer.value = props.typingAnswer.toLowerCase().trim() === props.currentCard.word.toLowerCase();
        }
        setTimeout(() => {
          triggerFirework.value = true;
          triggerSound.value = true;
        }, 50);
      }
    });
    const onSelectTypingOption = (opt) => {
      if (!props.typingQuizAnswered) emit("select-typing-quiz-answer", opt);
    };
    const isOptionSelected = (opt) => props.typingQuizSelected === opt;
    const isOptionCorrect = (opt) => opt.trim().toLowerCase() === props.currentCard.word.trim().toLowerCase();
    const typingInput = ref(null);
    const focusTypingInput = async () => {
      await nextTick();
      try {
        typingInput.value?.focus({ preventScroll: true });
      } catch {
        typingInput.value?.focus();
      }
    };
    const ensureTypingFocus = () => {
      if (!props.typingQuizEnabled && !props.typingAnswered) {
        if (document.activeElement !== typingInput.value) {
          focusTypingInput();
        }
      }
    };
    const onTypingBlur = () => {
      ensureTypingFocus();
    };
    onMounted(() => {
      ensureTypingFocus();
    });
    watch(() => props.typingQuizEnabled, (val) => {
      if (!val) ensureTypingFocus();
    });
    watch(() => props.typingAnswered, (answered) => {
      if (!answered) ensureTypingFocus();
    });
    watch(() => props.currentCard, () => {
      ensureTypingFocus();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 p-8 h-96 select-none",
        onCopy: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createBaseVNode("div", _hoisted_1$B, [
          createBaseVNode("div", _hoisted_2$y, [
            createBaseVNode("span", _hoisted_3$x, toDisplayString$1(unref(getTopicName)(_ctx.currentCard.category)), 1)
          ]),
          createBaseVNode("div", _hoisted_4$v, [
            createBaseVNode("h2", _hoisted_5$t, toDisplayString$1(getShortMeaning(_ctx.currentCard.meaning)), 1),
            !_ctx.typingQuizEnabled ? (openBlock(), createElementBlock("p", _hoisted_6$r, toDisplayString$1(unref(t)("flashcard.typing.instruction", "Type the corresponding English word:")), 1)) : (openBlock(), createElementBlock("p", _hoisted_7$q, toDisplayString$1(unref(t)("flashcard.typing.instructionQuiz", "Choose the correct English word:")), 1))
          ]),
          createBaseVNode("div", _hoisted_8$q, [
            !_ctx.typingQuizEnabled ? (openBlock(), createElementBlock("div", _hoisted_9$p, [
              createBaseVNode("div", _hoisted_10$o, [
                createBaseVNode("input", {
                  ref_key: "typingInput",
                  ref: typingInput,
                  value: _ctx.typingAnswer,
                  onInput: handleInput,
                  onKeyup: withKeys(handleCheckAnswer, ["enter"]),
                  type: "text",
                  disabled: _ctx.typingAnswered,
                  class: "w-full p-3 text-center text-xl sm:text-2xl md:text-3xl border-2 border-gray-300 dark:border-gray-600 rounded-xl bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-4 focus:ring-purple-500/20 focus:border-purple-500 transition-all duration-200 disabled:bg-gray-100 dark:disabled:bg-gray-700 select-text",
                  placeholder: unref(t)("flashcard.typing.placeholder", "Type the word..."),
                  inputmode: "text",
                  autocomplete: "off",
                  autocapitalize: "none",
                  spellcheck: "false",
                  onBlur: onTypingBlur
                }, null, 40, _hoisted_11$o),
                _ctx.typingAnswered ? (openBlock(), createElementBlock("div", _hoisted_12$n, [
                  _ctx.typingAnswer.toLowerCase().trim() === _ctx.currentCard.word.toLowerCase() ? (openBlock(), createElementBlock("span", _hoisted_13$n, _cache[3] || (_cache[3] = [
                    createBaseVNode("svg", {
                      class: "w-8 h-8",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)
                  ]))) : (openBlock(), createElementBlock("span", _hoisted_14$n, _cache[4] || (_cache[4] = [
                    createBaseVNode("svg", {
                      class: "w-8 h-8",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)
                  ])))
                ])) : createCommentVNode("", true)
              ]),
              _ctx.typingAnswered && _ctx.typingAnswer.toLowerCase().trim() !== _ctx.currentCard.word.toLowerCase() ? (openBlock(), createElementBlock("div", _hoisted_15$k, [
                createBaseVNode("p", _hoisted_16$k, toDisplayString$1(unref(t)("flashcard.typing.correctAnswer", "Correct answer:")), 1),
                createBaseVNode("p", _hoisted_17$k, toDisplayString$1(_ctx.currentCard.word), 1)
              ])) : createCommentVNode("", true)
            ])) : (openBlock(), createElementBlock("div", _hoisted_18$j, [
              createBaseVNode("div", _hoisted_19$j, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.typingQuizOptions, (opt, idx) => {
                  return openBlock(), createElementBlock("button", {
                    key: idx,
                    onClick: ($event) => onSelectTypingOption(opt),
                    disabled: _ctx.typingQuizAnswered,
                    translate: "no",
                    class: normalizeClass(["notranslate px-3 py-1.5 sm:py-2 rounded-md border text-[13px] sm:text-sm transition-all duration-150 disabled:opacity-70 disabled:cursor-not-allowed text-left flex items-center gap-2 w-full min-w-0", [
                      _ctx.typingQuizAnswered ? isOptionCorrect(opt) ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300 border-green-300 dark:border-green-700" : isOptionSelected(opt) ? "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-300 border-red-300 dark:border-red-700" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60 hover:shadow-sm hover:scale-[1.01] dark:hover:bg-white/5"
                    ]])
                  }, [
                    createBaseVNode("span", _hoisted_21$j, toDisplayString$1(String.fromCharCode(65 + idx)), 1),
                    createBaseVNode("span", _hoisted_22$h, toDisplayString$1(opt), 1)
                  ], 10, _hoisted_20$j);
                }), 128))
              ]),
              _ctx.typingAnswered ? (openBlock(), createElementBlock("div", _hoisted_23$h, [
                _ctx.typingCorrect ? (openBlock(), createElementBlock("p", _hoisted_24$g, toDisplayString$1(unref(t)("flashcard.typing.correct", " Correct!")), 1)) : (openBlock(), createElementBlock("p", _hoisted_25$g, [
                  createTextVNode(toDisplayString$1(unref(t)("flashcard.typing.incorrect", " Correct answer:")) + " ", 1),
                  createBaseVNode("span", _hoisted_26$e, toDisplayString$1(_ctx.currentCard.word), 1)
                ]))
              ])) : createCommentVNode("", true)
            ]))
          ]),
          createBaseVNode("div", _hoisted_27$d, [
            !_ctx.typingAnswered && !_ctx.typingQuizEnabled ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: handleCheckAnswer,
              disabled: !_ctx.typingAnswer.trim(),
              class: "bg-purple-500 hover:bg-purple-600 disabled:bg-gray-300 dark:disabled:bg-gray-700 text-white px-8 py-3 rounded-full font-medium transition-colors"
            }, toDisplayString$1(unref(t)("common.check", "Check")), 9, _hoisted_28$d)) : createCommentVNode("", true)
          ])
        ]),
        createVNode(unref(FireworkSoundEffect), {
          ref_key: "fireworkEffect",
          ref: fireworkEffect,
          "trigger-firework": triggerFirework.value,
          "trigger-sound": triggerSound.value,
          "is-correct": isCorrectAnswer.value,
          onEffectComplete: resetTriggers
        }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
      ], 32);
    };
  }
});

const FlashcardTyping = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$B
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$A = { class: "h-full flex flex-col overflow-hidden" };
const _hoisted_2$x = { class: "mb-4 text-center" };
const _hoisted_3$w = { class: "px-3 py-1 bg-purple-100 dark:bg-dark-bg-mute text-purple-800 dark:text-purple-300 text-sm font-medium rounded-full" };
const _hoisted_4$u = { class: "flex-1 flex items-center justify-center mb-4 min-h-0" };
const _hoisted_5$s = {
  key: 0,
  class: "relative"
};
const _hoisted_6$q = ["src", "alt"];
const _hoisted_7$p = {
  key: 0,
  class: "absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-dark-bg-mute rounded-lg"
};
const _hoisted_8$p = { class: "text-center" };
const _hoisted_9$o = { class: "text-sm text-gray-500 dark:text-white/60 mt-2" };
const _hoisted_10$n = {
  key: 1,
  class: "flex items-center justify-center bg-gray-100 dark:bg-dark-bg-mute rounded-lg p-8 w-full max-w-sm"
};
const _hoisted_11$n = { class: "text-center" };
const _hoisted_12$m = { class: "text-sm text-gray-500 dark:text-white/60 mt-2" };
const _hoisted_13$m = { class: "space-y-3 flex-shrink-0" };
const _hoisted_14$m = { key: 0 };
const _hoisted_15$j = ["disabled", "placeholder"];
const _hoisted_16$j = { key: 1 };
const _hoisted_17$j = { class: "grid grid-cols-1 sm:grid-cols-2 gap-2 justify-items-center sm:justify-items-center justify-center mx-auto max-w-[560px] sm:max-w-[520px]" };
const _hoisted_18$i = ["onClick", "disabled"];
const _hoisted_19$i = { class: "inline-flex items-center justify-center w-5 h-5 rounded-full text-xs font-semibold bg-gray-200 text-gray-700 dark:bg-white/10 dark:text-white/80" };
const _hoisted_20$i = { class: "truncate" };
const _hoisted_21$i = {
  key: 2,
  class: "text-center space-y-2 max-h-32 overflow-y-auto"
};
const _hoisted_22$g = {
  key: 0,
  class: "w-4 h-4 mr-1",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_23$g = {
  key: 1,
  class: "w-4 h-4 mr-1",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_24$f = {
  key: 0,
  class: "text-center"
};
const _hoisted_25$f = { class: "text-sm text-gray-600 dark:text-white/70" };
const _hoisted_26$d = { class: "font-semibold text-gray-900 dark:text-white" };
const _hoisted_27$c = { class: "text-xs text-gray-500 dark:text-white/60 mt-1 line-clamp-2" };
const _hoisted_28$c = {
  key: 1,
  class: "text-center"
};
const _hoisted_29$b = { class: "text-sm text-gray-600 dark:text-white/70 line-clamp-2" };
const _hoisted_30$a = {
  key: 3,
  class: "text-center text-sm text-gray-500 dark:text-white/60"
};
const _hoisted_31$a = {
  key: 4,
  class: "text-center text-sm text-gray-500 dark:text-white/60"
};
const STORAGE_KEY_IMAGE_QUIZ = "flashcard_image_quiz_enabled";
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "FlashcardImage",
  props: {
    currentCard: {},
    imageAnswer: {},
    imageAnswered: { type: Boolean },
    imageCorrect: { type: Boolean },
    imageQuizEnabled: { type: Boolean },
    imageQuizOptions: {},
    imageQuizSelected: {},
    imageQuizAnswered: { type: Boolean }
  },
  emits: ["update:imageAnswer", "checkAnswer", "update:imageQuizEnabled", "select-image-quiz-answer"],
  setup(__props, { emit: __emit }) {
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const userAnswer = ref("");
    const imageError = ref(false);
    const imageTypingInput = ref(null);
    watch(() => props.imageAnswer, (newValue) => {
      userAnswer.value = newValue;
    });
    const stripDiacritics = (s) => s.replace(/[]/g, "w").replace(/[]/g, "W").normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(//g, "d").replace(//g, "D");
    watch(userAnswer, (newValue) => {
      const sanitized = stripDiacritics(newValue);
      if (sanitized !== newValue) {
        userAnswer.value = sanitized;
      }
      emit("update:imageAnswer", sanitized);
    });
    watch(() => props.currentCard, () => {
      imageError.value = false;
    });
    const handleImageError = () => {
      imageError.value = true;
    };
    const checkAnswer = () => {
      if (!props.imageAnswered && userAnswer.value.trim()) {
        emit("checkAnswer");
        setTimeout(() => {
          isCorrectAnswer.value = props.imageCorrect;
          triggerFirework.value = true;
          triggerSound.value = true;
        }, 100);
      }
    };
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    watch(() => props.imageAnswered, (newValue) => {
      if (newValue && !triggerFirework.value) {
        isCorrectAnswer.value = props.imageCorrect;
        setTimeout(() => {
          triggerFirework.value = true;
          triggerSound.value = true;
        }, 50);
      }
    });
    onMounted(() => {
      try {
        const saved = localStorage.getItem(STORAGE_KEY_IMAGE_QUIZ);
        if (saved !== null) {
          const val = saved === "true";
          if (val !== props.imageQuizEnabled) {
            emit("update:imageQuizEnabled", val);
          }
        }
      } catch (e) {
      }
      ensureImageTypingFocus();
    });
    watch(() => props.imageQuizEnabled, (newVal) => {
      try {
        localStorage.setItem(STORAGE_KEY_IMAGE_QUIZ, String(newVal));
      } catch (e) {
      }
      if (!newVal) ensureImageTypingFocus();
    });
    const onSelectImageOption = (opt) => {
      if (!props.imageQuizAnswered) {
        emit("select-image-quiz-answer", opt);
      }
    };
    const isOptionSelected = (opt) => props.imageQuizSelected === opt;
    const isOptionCorrect = (opt) => props.currentCard ? opt.trim().toLowerCase() === props.currentCard.word.trim().toLowerCase() : false;
    const focusImageTypingInput = async () => {
      await nextTick();
      try {
        imageTypingInput.value?.focus({ preventScroll: true });
      } catch {
        imageTypingInput.value?.focus();
      }
    };
    const ensureImageTypingFocus = () => {
      if (!props.imageQuizEnabled && !props.imageAnswered) {
        if (document.activeElement !== imageTypingInput.value) {
          focusImageTypingInput();
        }
      }
    };
    const onImageTypingBlur = () => {
      ensureImageTypingFocus();
    };
    watch(() => props.imageAnswered, (answered) => {
      if (!answered) ensureImageTypingFocus();
    });
    watch(() => props.currentCard, () => {
      ensureImageTypingFocus();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-dark-bg-mute p-6 min-h-96 max-h-[500px] select-none",
        onCopy: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[3] || (_cache[3] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createBaseVNode("div", _hoisted_1$A, [
          createBaseVNode("div", _hoisted_2$x, [
            createBaseVNode("span", _hoisted_3$w, toDisplayString$1(_ctx.currentCard?.category ? unref(getTopicName)(_ctx.currentCard.category) : ""), 1)
          ]),
          createBaseVNode("div", _hoisted_4$u, [
            _ctx.currentCard?.image ? (openBlock(), createElementBlock("div", _hoisted_5$s, [
              createBaseVNode("img", {
                src: _ctx.currentCard.image,
                alt: unref(t)("flashcard.image.imageAlt", "Flashcard image"),
                class: "max-w-full max-h-40 object-contain rounded-lg shadow-md border border-gray-200 dark:border-dark-bg-mute",
                onError: handleImageError
              }, null, 40, _hoisted_6$q),
              imageError.value ? (openBlock(), createElementBlock("div", _hoisted_7$p, [
                createBaseVNode("div", _hoisted_8$p, [
                  _cache[4] || (_cache[4] = createBaseVNode("svg", {
                    class: "mx-auto h-12 w-12 text-gray-400 dark:text-white/50",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    stroke: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 16m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                    })
                  ], -1)),
                  createBaseVNode("p", _hoisted_9$o, toDisplayString$1(unref(t)("flashcard.image.imageError", "Could not load image.")), 1)
                ])
              ])) : createCommentVNode("", true)
            ])) : (openBlock(), createElementBlock("div", _hoisted_10$n, [
              createBaseVNode("div", _hoisted_11$n, [
                _cache[5] || (_cache[5] = createBaseVNode("svg", {
                  class: "mx-auto h-16 w-16 text-gray-400 dark:text-white/50",
                  fill: "none",
                  viewBox: "0 0 24 24",
                  stroke: "currentColor"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 16m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                  })
                ], -1)),
                createBaseVNode("p", _hoisted_12$m, toDisplayString$1(unref(t)("flashcard.image.noImage", "No image available for this card.")), 1)
              ])
            ]))
          ]),
          createBaseVNode("div", _hoisted_13$m, [
            !_ctx.imageQuizEnabled ? (openBlock(), createElementBlock("div", _hoisted_14$m, [
              withDirectives(createBaseVNode("input", {
                ref_key: "imageTypingInput",
                ref: imageTypingInput,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => userAnswer.value = $event),
                onKeyup: withKeys(checkAnswer, ["enter"]),
                type: "text",
                disabled: _ctx.imageAnswered,
                placeholder: unref(t)("flashcard.image.placeholder", "Enter your answer..."),
                class: "w-full px-4 py-3 text-center text-lg border border-gray-300 dark:border-dark-bg-mute rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-white/50 disabled:opacity-50 disabled:cursor-not-allowed select-text",
                inputmode: "text",
                autocapitalize: "none",
                autocomplete: "off",
                spellcheck: "false",
                onBlur: onImageTypingBlur
              }, null, 40, _hoisted_15$j), [
                [vModelText, userAnswer.value]
              ])
            ])) : (openBlock(), createElementBlock("div", _hoisted_16$j, [
              createBaseVNode("div", _hoisted_17$j, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.imageQuizOptions, (opt, idx) => {
                  return openBlock(), createElementBlock("button", {
                    key: idx,
                    onClick: ($event) => onSelectImageOption(opt),
                    disabled: _ctx.imageQuizAnswered,
                    translate: "no",
                    class: normalizeClass(["notranslate px-3 py-2 rounded-md border text-[13px] sm:text-sm transition-all duration-150 disabled:opacity-70 disabled:cursor-not-allowed text-left flex items-center gap-2 w-full max-w-[260px] sm:max-w-[240px]", [
                      _ctx.imageQuizAnswered ? isOptionCorrect(opt) ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300 border-green-300 dark:border-green-700" : isOptionSelected(opt) ? "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-300 border-red-300 dark:border-red-700" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60 hover:shadow-sm hover:scale-[1.01] dark:hover:bg-white/5"
                    ]])
                  }, [
                    createBaseVNode("span", _hoisted_19$i, toDisplayString$1(String.fromCharCode(65 + idx)), 1),
                    createBaseVNode("span", _hoisted_20$i, toDisplayString$1(opt), 1)
                  ], 10, _hoisted_18$i);
                }), 128))
              ])
            ])),
            _ctx.imageAnswered ? (openBlock(), createElementBlock("div", _hoisted_21$i, [
              createBaseVNode("div", {
                class: normalizeClass([
                  "inline-flex items-center px-3 py-1 rounded-full text-sm font-medium",
                  _ctx.imageCorrect ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300" : "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-300"
                ])
              }, [
                _ctx.imageCorrect ? (openBlock(), createElementBlock("svg", _hoisted_22$g, _cache[6] || (_cache[6] = [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                    "clip-rule": "evenodd"
                  }, null, -1)
                ]))) : (openBlock(), createElementBlock("svg", _hoisted_23$g, _cache[7] || (_cache[7] = [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                    "clip-rule": "evenodd"
                  }, null, -1)
                ]))),
                createTextVNode(" " + toDisplayString$1(_ctx.imageCorrect ? unref(t)("common.correct", "Correct") : unref(t)("common.incorrect", "Incorrect")), 1)
              ], 2),
              !_ctx.imageCorrect ? (openBlock(), createElementBlock("div", _hoisted_24$f, [
                createBaseVNode("p", _hoisted_25$f, [
                  createTextVNode(toDisplayString$1(unref(t)("flashcard.image.correctAnswer", "Correct answer")) + ": ", 1),
                  createBaseVNode("span", _hoisted_26$d, toDisplayString$1(_ctx.currentCard?.word), 1)
                ]),
                createBaseVNode("p", _hoisted_27$c, toDisplayString$1(_ctx.currentCard?.meaning), 1)
              ])) : (openBlock(), createElementBlock("div", _hoisted_28$c, [
                createBaseVNode("p", _hoisted_29$b, toDisplayString$1(_ctx.currentCard?.meaning), 1)
              ]))
            ])) : createCommentVNode("", true),
            !_ctx.imageAnswered && !_ctx.imageQuizEnabled ? (openBlock(), createElementBlock("p", _hoisted_30$a, toDisplayString$1(unref(t)("flashcard.image.instruction", "Type the word for the image above and press Enter.")), 1)) : createCommentVNode("", true),
            !_ctx.imageAnswered && _ctx.imageQuizEnabled ? (openBlock(), createElementBlock("p", _hoisted_31$a, toDisplayString$1(unref(t)("flashcard.image.instructionQuiz", "Choose the correct word for the image.")), 1)) : createCommentVNode("", true)
          ])
        ]),
        createVNode(unref(FireworkSoundEffect), {
          ref_key: "fireworkEffect",
          ref: fireworkEffect,
          "trigger-firework": triggerFirework.value,
          "trigger-sound": triggerSound.value,
          "is-correct": isCorrectAnswer.value,
          onEffectComplete: resetTriggers
        }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
      ], 32);
    };
  }
});

const FlashcardImage = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$A
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$z = { class: "flex justify-center items-center gap-2 sm:gap-3 md:gap-4 mt-4 sm:mt-6 md:mt-8" };
const _hoisted_2$w = ["title"];
const _hoisted_3$v = ["disabled", "title"];
const _hoisted_4$t = ["title"];
const _hoisted_5$r = ["title"];
const _hoisted_6$p = ["disabled", "title"];
const _hoisted_7$o = ["disabled"];
const _hoisted_8$o = ["title"];
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  __name: "FlashcardControls",
  props: {
    practiceMode: {},
    currentIndex: {},
    totalCards: {},
    canProceed: { type: Boolean },
    practiceStarted: { type: Boolean },
    scrambleWordsEnabled: { type: Boolean },
    typingAnswer: {},
    typingAnswered: { type: Boolean },
    listeningAnswer: {},
    listeningAnswered: { type: Boolean },
    imageAnswer: {},
    imageAnswered: { type: Boolean }
  },
  emits: ["mark-difficult", "mark-easy", "previous-card", "next-card", "exit-practice"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$z, [
        _ctx.practiceMode === "flashcard" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("mark-difficult")),
            class: "bg-red-500 hover:bg-red-600 text-white p-2 sm:p-3 md:p-4 rounded-full transition-colors",
            title: unref(t)("practice.controls.difficult", "Mark as difficult")
          }, _cache[8] || (_cache[8] = [
            createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                "clip-rule": "evenodd"
              })
            ], -1)
          ]), 8, _hoisted_2$w),
          createBaseVNode("button", {
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("previous-card")),
            disabled: _ctx.currentIndex === 0,
            class: "bg-gray-500 hover:bg-gray-600 disabled:bg-gray-300 dark:disabled:bg-gray-700 text-white p-2 sm:p-3 md:p-4 rounded-full transition-colors",
            title: unref(t)("practice.controls.previous", "Previous")
          }, _cache[9] || (_cache[9] = [
            createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                "clip-rule": "evenodd"
              })
            ], -1)
          ]), 8, _hoisted_3$v),
          createBaseVNode("button", {
            onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("next-card")),
            class: normalizeClass(["bg-blue-500 hover:bg-blue-600 text-white px-3 py-2 sm:px-4 sm:py-2 md:px-6 md:py-3 rounded-full font-medium transition-colors text-xs sm:text-sm md:text-base", _ctx.scrambleWordsEnabled ? "hidden md:inline-flex" : ""])
          }, toDisplayString$1(_ctx.currentIndex === _ctx.totalCards - 1 ? unref(t)("practice.controls.complete", "Complete") : unref(t)("practice.controls.next", "Next")), 3),
          createBaseVNode("button", {
            onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("mark-easy")),
            class: "bg-green-500 hover:bg-green-600 text-white p-2 sm:p-3 md:p-4 rounded-full transition-colors",
            title: unref(t)("practice.controls.easy", "Mark as easy")
          }, _cache[10] || (_cache[10] = [
            createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                "clip-rule": "evenodd"
              })
            ], -1)
          ]), 8, _hoisted_4$t),
          _ctx.practiceStarted ? (openBlock(), createElementBlock("button", {
            key: 0,
            onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("exit-practice")),
            class: "bg-red-600 hover:bg-red-700 text-white p-2 sm:p-3 md:p-4 rounded-full transition-colors ml-2 sm:ml-3 md:ml-4",
            title: unref(t)("practice.controls.exit", "Exit Practice")
          }, _cache[11] || (_cache[11] = [
            createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M3 3a1 1 0 00-1 1v12a1 1 0 102 0V4a1 1 0 00-1-1zm10.293 9.293a1 1 0 001.414 1.414l3-3a1 1 0 000-1.414l-3-3a1 1 0 10-1.414 1.414L14.586 9H7a1 1 0 100 2h7.586l-1.293 1.293z",
                "clip-rule": "evenodd"
              })
            ], -1)
          ]), 8, _hoisted_5$r)) : createCommentVNode("", true)
        ], 64)) : ["quiz", "typing", "listening", "image", "pronunciation", "pictionary", "flip-tile"].includes(_ctx.practiceMode) ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("button", {
            onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("previous-card")),
            disabled: _ctx.currentIndex === 0,
            class: "bg-gray-500 hover:bg-gray-600 disabled:bg-gray-300 dark:disabled:bg-gray-700 text-white p-2 sm:p-3 md:p-4 rounded-full transition-colors",
            title: unref(t)("practice.controls.previous", "Previous")
          }, _cache[12] || (_cache[12] = [
            createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                "clip-rule": "evenodd"
              })
            ], -1)
          ]), 8, _hoisted_6$p),
          createBaseVNode("button", {
            onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("next-card")),
            disabled: !_ctx.canProceed,
            class: normalizeClass(["bg-blue-500 hover:bg-blue-600 disabled:bg-gray-300 dark:disabled:bg-gray-700 text-white px-3 py-2 sm:px-4 sm:py-2 md:px-6 md:py-3 rounded-full font-medium transition-colors text-xs sm:text-sm md:text-base", ["quiz", "typing", "listening", "image", "pictionary", "flip-tile"].includes(_ctx.practiceMode) ? "hidden md:inline-flex" : ""])
          }, toDisplayString$1(_ctx.currentIndex === _ctx.totalCards - 1 ? unref(t)("practice.controls.complete", "Complete") : unref(t)("practice.controls.next", "Next")), 11, _hoisted_7$o),
          _ctx.practiceStarted ? (openBlock(), createElementBlock("button", {
            key: 0,
            onClick: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("exit-practice")),
            class: "bg-red-600 hover:bg-red-700 text-white p-2 sm:p-3 md:p-4 rounded-full transition-colors ml-2 sm:ml-3 md:ml-4",
            title: unref(t)("practice.controls.exit", "Exit Practice")
          }, _cache[13] || (_cache[13] = [
            createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M3 3a1 1 0 00-1 1v12a1 1 0 102 0V4a1 1 0 00-1-1zm10.293 9.293a1 1 0 001.414 1.414l3-3a1 1 0 000-1.414l-3-3a1 1 0 10-1.414 1.414L14.586 9H7a1 1 0 100 2h7.586l-1.293 1.293z",
                "clip-rule": "evenodd"
              })
            ], -1)
          ]), 8, _hoisted_8$o)) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true)
      ]);
    };
  }
});

const FlashcardControls = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$z
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$y = { class: "practice-timer" };
const _hoisted_2$v = {
  key: 0,
  class: "flex items-center justify-center gap-1 sm:gap-2 md:gap-3 mb-3 sm:mb-4 md:mb-5"
};
const _hoisted_3$u = { class: "font-mono font-bold text-sm sm:text-base md:text-lg" };
const _hoisted_4$s = {
  key: 1,
  class: "text-center mb-4 sm:mb-5 md:mb-6"
};
const _hoisted_5$q = { class: "text-xs sm:text-sm md:text-base text-gray-500 dark:text-gray-400 mt-2" };
const _hoisted_6$o = {
  key: 0,
  class: "timeout-modal-overlay",
  style: { "position": "fixed !important", "top": "0 !important", "left": "0 !important", "right": "0 !important", "bottom": "0 !important", "z-index": "99999 !important", "background": "rgba(0,0,0,0.5) !important", "display": "flex !important", "align-items": "center !important", "justify-content": "center !important", "padding": "12px !important" }
};
const _hoisted_7$n = {
  style: { "position": "relative !important", "z-index": "100000 !important" },
  class: "timeout-modal-content flex items-center justify-center z-[9999] p-3 sm:p-4 md:p-6"
};
const _hoisted_8$n = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl p-4 sm:p-6 md:p-8 max-w-xs sm:max-w-sm md:max-w-md mx-auto text-center w-full" };
const _hoisted_9$n = { class: "text-lg sm:text-xl md:text-2xl font-bold text-gray-900 dark:text-white mb-2 sm:mb-3 md:mb-4" };
const _hoisted_10$m = { class: "text-sm sm:text-base md:text-lg text-gray-600 dark:text-gray-300 mb-4 sm:mb-5 md:mb-6 leading-relaxed" };
const _hoisted_11$m = { class: "flex gap-2 sm:gap-3 md:gap-4" };
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "PracticeTimer",
  props: {
    maxTime: { default: 30 },
    autoStart: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false }
  },
  emits: ["start", "timeout", "tick", "restart", "skip"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const timeLimitText = computed(() => {
      const translated = t("practice.timer.timeLimit", { seconds: props.maxTime });
      if (translated === "practice.timer.timeLimit") {
        return `Time limit: ${props.maxTime} seconds`;
      }
      return translated;
    });
    const remainingTime = ref(props.maxTime);
    const isActive = ref(false);
    const hasStarted = ref(false);
    const showTimeoutModal = ref(false);
    let timerId = null;
    computed(() => isActive.value && remainingTime.value > 0);
    const startPractice = () => {
      hasStarted.value = true;
      startTimer();
      emit("start");
    };
    const startTimer = () => {
      if (props.disabled) return;
      isActive.value = true;
      remainingTime.value = props.maxTime;
      timerId = setInterval(() => {
        if (remainingTime.value > 0) {
          remainingTime.value--;
          emit("tick", remainingTime.value);
        } else {
          handleTimeout();
        }
      }, 1e3);
    };
    const stopTimer = () => {
      if (timerId) {
        clearInterval(timerId);
        timerId = null;
      }
    };
    const resetTimer = () => {
      stopTimer();
      remainingTime.value = props.maxTime;
    };
    const handleTimeout = () => {
      stopTimer();
      showTimeoutModal.value = true;
      emit("timeout");
    };
    const restartPractice = () => {
      showTimeoutModal.value = false;
      resetTimer();
      startTimer();
      emit("restart");
    };
    const skipCard = () => {
      showTimeoutModal.value = false;
      stopTimer();
      isActive.value = false;
      emit("skip");
    };
    const nextCard = () => {
      if (hasStarted.value) {
        resetTimer();
        startTimer();
      }
    };
    const resetPractice = () => {
      stopTimer();
      isActive.value = false;
      hasStarted.value = false;
      remainingTime.value = props.maxTime;
      showTimeoutModal.value = false;
    };
    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
    };
    const getTimerClass = () => {
      if (remainingTime.value <= 5) return "timer-critical";
      if (remainingTime.value <= 10) return "timer-warning";
      return "timer-normal";
    };
    watch(() => props.disabled, (disabled) => {
      if (disabled) {
        stopTimer();
      }
    });
    watch(() => props.autoStart, (autoStart) => {
      if (autoStart && !hasStarted.value) {
        startPractice();
      }
    });
    watch(showTimeoutModal, (visible) => {
      if (visible) {
        document.body.classList.add("modal-open");
      } else {
        document.body.classList.remove("modal-open");
      }
    });
    onUnmounted(() => {
      stopTimer();
    });
    __expose({
      startTimer,
      stopTimer,
      resetTimer,
      nextCard,
      hasStarted,
      resetPractice
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$y, [
        isActive.value ? (openBlock(), createElementBlock("div", _hoisted_2$v, [
          createBaseVNode("div", {
            class: normalizeClass(["timer-display", getTimerClass()])
          }, [
            _cache[0] || (_cache[0] = createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z",
                "clip-rule": "evenodd"
              })
            ], -1)),
            createBaseVNode("span", _hoisted_3$u, toDisplayString$1(formatTime(remainingTime.value)), 1)
          ], 2)
        ])) : createCommentVNode("", true),
        !hasStarted.value ? (openBlock(), createElementBlock("div", _hoisted_4$s, [
          createBaseVNode("button", {
            onClick: startPractice,
            class: "bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 sm:px-6 sm:py-3 md:px-8 md:py-4 rounded-lg sm:rounded-xl md:rounded-2xl font-semibold text-sm sm:text-base md:text-lg transition-colors shadow-lg hover:shadow-xl"
          }, [
            _cache[1] || (_cache[1] = createBaseVNode("svg", {
              class: "w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6 inline-block mr-1 sm:mr-2 md:mr-3",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z",
                "clip-rule": "evenodd"
              })
            ], -1)),
            createTextVNode(" " + toDisplayString$1(unref(t)("practice.timer.startPractice", "Start Practice")), 1)
          ]),
          createBaseVNode("div", _hoisted_5$q, toDisplayString$1(timeLimitText.value), 1)
        ])) : createCommentVNode("", true),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          showTimeoutModal.value ? (openBlock(), createElementBlock("div", _hoisted_6$o, [
            createBaseVNode("div", _hoisted_7$n, [
              createBaseVNode("div", _hoisted_8$n, [
                _cache[2] || (_cache[2] = createBaseVNode("div", { class: "text-red-500 mb-3 sm:mb-4 md:mb-5" }, [
                  createBaseVNode("svg", {
                    class: "w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 mx-auto",
                    fill: "currentColor",
                    viewBox: "0 0 20 20"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z",
                      "clip-rule": "evenodd"
                    })
                  ])
                ], -1)),
                createBaseVNode("h3", _hoisted_9$n, toDisplayString$1(unref(t)("practice.timer.timeUp", "Time is up!")), 1),
                createBaseVNode("p", _hoisted_10$m, toDisplayString$1(unref(t)("practice.timer.timeUpMessage", "Your time is up. Would you like to try again or skip this card?")), 1),
                createBaseVNode("div", _hoisted_11$m, [
                  createBaseVNode("button", {
                    onClick: restartPractice,
                    class: "flex-1 bg-blue-500 hover:bg-blue-600 text-white px-3 py-2 sm:px-4 sm:py-2 md:px-5 md:py-3 rounded-lg font-medium transition-colors text-xs sm:text-sm md:text-base"
                  }, toDisplayString$1(unref(t)("practice.timer.tryAgain", "Try Again")), 1),
                  createBaseVNode("button", {
                    onClick: skipCard,
                    class: "flex-1 bg-gray-500 hover:bg-gray-600 text-white px-3 py-2 sm:px-4 sm:py-2 md:px-5 md:py-3 rounded-lg font-medium transition-colors text-xs sm:text-sm md:text-base"
                  }, toDisplayString$1(unref(t)("practice.timer.skip", "Skip")), 1)
                ])
              ])
            ])
          ])) : createCommentVNode("", true)
        ]))
      ]);
    };
  }
});

const PracticeTimer = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__scopeId", "data-v-1d84fe0e"]]);

const PracticeTimer$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: PracticeTimer
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$x = {
  key: 0,
  class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
};
const _hoisted_2$u = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl p-8 max-w-md mx-4 text-center" };
const _hoisted_3$t = { class: "text-lg sm:text-xl font-bold text-gray-900 dark:text-white mb-2" };
const _hoisted_4$r = { class: "text-sm sm:text-base text-gray-600 dark:text-white/80 mb-6" };
const _hoisted_5$p = { class: "flex gap-2 sm:gap-3" };
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "ExitWarningModal",
  props: {
    show: { type: Boolean }
  },
  emits: ["continue", "confirm"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$x, [
        createBaseVNode("div", _hoisted_2$u, [
          _cache[2] || (_cache[2] = createBaseVNode("div", { class: "text-orange-500 mb-4" }, [
            createBaseVNode("svg", {
              class: "w-16 h-16 mx-auto",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z",
                "clip-rule": "evenodd"
              })
            ])
          ], -1)),
          createBaseVNode("h3", _hoisted_3$t, toDisplayString$1(unref(t)("practice.exitWarning.title", "Leave Practice?")), 1),
          createBaseVNode("p", _hoisted_4$r, toDisplayString$1(unref(t)("practice.exitWarning.message", "Are you sure you want to leave? Your progress will be lost.")), 1),
          createBaseVNode("div", _hoisted_5$p, [
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => emit("continue")),
              class: "flex-1 bg-blue-500 hover:bg-blue-600 text-white px-2 sm:px-4 py-2 rounded-lg text-sm sm:text-base font-medium transition-colors"
            }, toDisplayString$1(unref(t)("practice.exitWarning.continue", "Stay")), 1),
            createBaseVNode("button", {
              onClick: _cache[1] || (_cache[1] = ($event) => emit("confirm")),
              class: "flex-1 bg-red-500 hover:bg-red-600 text-white px-2 sm:px-4 py-2 rounded-lg text-sm sm:text-base font-medium transition-colors"
            }, toDisplayString$1(unref(t)("practice.exitWarning.exit", "Leave")), 1)
          ])
        ])
      ])) : createCommentVNode("", true);
    };
  }
});

const ExitWarningModal = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$x
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$w = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-green-50 to-emerald-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_2$t = { class: "flex items-center justify-between" };
const _hoisted_3$s = { class: "text-lg sm:text-xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_4$q = { class: "px-6 py-6" };
const _hoisted_5$o = {
  class: "text-center mb-6 animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_6$n = { class: "text-gray-600 dark:text-gray-300" };
const _hoisted_7$m = { class: "grid grid-cols-1 gap-4 mb-6" };
const _hoisted_8$m = {
  class: "bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-4 animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_9$m = { class: "flex items-center justify-between" };
const _hoisted_10$l = { class: "flex items-center space-x-2" };
const _hoisted_11$l = { class: "font-medium text-green-700 dark:text-green-300" };
const _hoisted_12$l = { class: "text-2xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_13$l = {
  class: "bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4 animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_14$l = { class: "flex items-center justify-between" };
const _hoisted_15$i = { class: "flex items-center space-x-2" };
const _hoisted_16$i = { class: "font-medium text-red-700 dark:text-red-300" };
const _hoisted_17$i = { class: "text-2xl font-bold text-red-600 dark:text-red-400" };
const _hoisted_18$h = {
  class: "bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4 animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_19$h = { class: "flex items-center justify-between mb-2" };
const _hoisted_20$h = { class: "flex items-center space-x-2" };
const _hoisted_21$h = { class: "font-medium text-blue-700 dark:text-blue-300" };
const _hoisted_22$f = { class: "text-2xl font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_23$f = { class: "flex items-center justify-between" };
const _hoisted_24$e = { class: "font-medium text-gray-700 dark:text-gray-300" };
const _hoisted_25$e = { class: "space-y-3" };
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "CompletionModal",
  props: {
    show: { type: Boolean },
    stats: {},
    cardCount: {}
  },
  emits: ["restart", "go-back"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        "enter-active-class": "transition-all duration-500 ease-out",
        "enter-from-class": "opacity-0",
        "enter-to-class": "opacity-100",
        "leave-active-class": "transition-all duration-300 ease-in",
        "leave-from-class": "opacity-100",
        "leave-to-class": "opacity-0"
      }, {
        default: withCtx(() => [
          _ctx.show ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm",
            onWheel: _cache[4] || (_cache[4] = withModifiers(() => {
            }, ["prevent"])),
            onTouchmove: _cache[5] || (_cache[5] = withModifiers(() => {
            }, ["prevent"]))
          }, [
            createVNode(Transition, {
              "enter-active-class": "transition-all duration-500 ease-out",
              "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
              "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
              "leave-active-class": "transition-all duration-300 ease-in",
              "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
              "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
            }, {
              default: withCtx(() => [
                _ctx.show ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: "w-full max-w-md sm:max-w-lg bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 overflow-hidden transform",
                  onClick: _cache[3] || (_cache[3] = withModifiers(() => {
                  }, ["stop"]))
                }, [
                  createBaseVNode("div", _hoisted_1$w, [
                    createBaseVNode("div", _hoisted_2$t, [
                      createBaseVNode("h2", _hoisted_3$s, [
                        _cache[6] || (_cache[6] = createBaseVNode("span", { class: "w-2 h-2 bg-green-500 rounded-full animate-pulse" }, null, -1)),
                        createBaseVNode("span", null, toDisplayString$1(unref(t)("flashcard.completion.title", "Completed!")), 1)
                      ]),
                      createBaseVNode("button", {
                        onClick: _cache[0] || (_cache[0] = ($event) => emit("go-back")),
                        class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                      }, _cache[7] || (_cache[7] = [
                        createBaseVNode("svg", {
                          class: "w-6 h-6",
                          fill: "none",
                          stroke: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          createBaseVNode("path", {
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            "stroke-width": "2",
                            d: "M6 18L18 6M6 6l12 12"
                          })
                        ], -1)
                      ]))
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_4$q, [
                    _cache[11] || (_cache[11] = createBaseVNode("div", {
                      class: "flex justify-center mb-6 animate-fade-in-up",
                      style: { "animation-delay": "0.1s" }
                    }, [
                      createBaseVNode("div", { class: "flex items-center justify-center h-16 w-16 rounded-full bg-green-100 dark:bg-green-900 shadow-lg transform hover:scale-110 transition-all duration-300" }, [
                        createBaseVNode("svg", {
                          class: "h-8 w-8 text-green-600 dark:text-green-400",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", {
                            "fill-rule": "evenodd",
                            d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                            "clip-rule": "evenodd"
                          })
                        ])
                      ])
                    ], -1)),
                    createBaseVNode("div", _hoisted_5$o, [
                      createBaseVNode("p", _hoisted_6$n, toDisplayString$1(unref(t)("flashcard.completion.description", { count: _ctx.cardCount }, `You have completed ${_ctx.cardCount} flashcards.`)), 1)
                    ]),
                    createBaseVNode("div", _hoisted_7$m, [
                      createBaseVNode("div", _hoisted_8$m, [
                        createBaseVNode("div", _hoisted_9$m, [
                          createBaseVNode("div", _hoisted_10$l, [
                            _cache[8] || (_cache[8] = createBaseVNode("span", { class: "w-2 h-2 bg-green-500 rounded-full" }, null, -1)),
                            createBaseVNode("span", _hoisted_11$l, toDisplayString$1(unref(t)("flashcard.completion.correct", "Correct")), 1)
                          ]),
                          createBaseVNode("span", _hoisted_12$l, toDisplayString$1(_ctx.stats.correct), 1)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_13$l, [
                        createBaseVNode("div", _hoisted_14$l, [
                          createBaseVNode("div", _hoisted_15$i, [
                            _cache[9] || (_cache[9] = createBaseVNode("span", { class: "w-2 h-2 bg-red-500 rounded-full" }, null, -1)),
                            createBaseVNode("span", _hoisted_16$i, toDisplayString$1(unref(t)("flashcard.completion.incorrect", "Incorrect")), 1)
                          ]),
                          createBaseVNode("span", _hoisted_17$i, toDisplayString$1(_ctx.stats.incorrect), 1)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_18$h, [
                        createBaseVNode("div", _hoisted_19$h, [
                          createBaseVNode("div", _hoisted_20$h, [
                            _cache[10] || (_cache[10] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full" }, null, -1)),
                            createBaseVNode("span", _hoisted_21$h, toDisplayString$1(unref(t)("flashcard.completion.accuracy", "Accuracy")), 1)
                          ]),
                          createBaseVNode("span", _hoisted_22$f, toDisplayString$1(_ctx.stats.correct + _ctx.stats.incorrect > 0 ? Math.round(_ctx.stats.correct / (_ctx.stats.correct + _ctx.stats.incorrect) * 100) : 0) + "%", 1)
                        ]),
                        createBaseVNode("div", _hoisted_23$f, [
                          createBaseVNode("span", _hoisted_24$e, toDisplayString$1(unref(t)("flashcard.completion.result", "Result")) + ":", 1),
                          createBaseVNode("span", {
                            class: normalizeClass(["px-3 py-1 text-sm font-medium rounded-full transition-all duration-300 hover:scale-105", _ctx.stats.correct + _ctx.stats.incorrect > 0 && Math.round(_ctx.stats.correct / (_ctx.stats.correct + _ctx.stats.incorrect) * 100) >= 70 ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 shadow-green-200 dark:shadow-green-900" : "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200 shadow-red-200 dark:shadow-red-900"])
                          }, toDisplayString$1(_ctx.stats.correct + _ctx.stats.incorrect > 0 && Math.round(_ctx.stats.correct / (_ctx.stats.correct + _ctx.stats.incorrect) * 100) >= 70 ? unref(t)("flashcard.history.pass", "Pass") : unref(t)("flashcard.history.fail", "Fail")), 3)
                        ])
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_25$e, [
                      createBaseVNode("button", {
                        onClick: _cache[1] || (_cache[1] = ($event) => emit("restart")),
                        class: "w-full px-6 py-3 bg-blue-500 hover:bg-blue-600 text-white font-medium rounded-lg shadow-md transition-all duration-300 hover:scale-105 hover:shadow-lg transform hover:-translate-y-0.5 active:scale-95 animate-fade-in-up",
                        style: { "animation-delay": "0.6s" }
                      }, toDisplayString$1(unref(t)("common.restart", "Practice Again")), 1),
                      createBaseVNode("button", {
                        onClick: _cache[2] || (_cache[2] = ($event) => emit("go-back")),
                        class: "w-full px-6 py-3 bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 font-medium rounded-lg shadow-md transition-all duration-300 hover:scale-105 hover:shadow-lg transform hover:-translate-y-0.5 active:scale-95 animate-fade-in-up",
                        style: { "animation-delay": "0.7s" }
                      }, toDisplayString$1(unref(t)("common.back", "Back")), 1)
                    ])
                  ])
                ])) : createCommentVNode("", true)
              ]),
              _: 1
            })
          ], 32)) : createCommentVNode("", true)
        ]),
        _: 1
      });
    };
  }
});

const CompletionModal = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__scopeId", "data-v-8ac791bd"]]);

const CompletionModal$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: CompletionModal
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$v = {
  key: 0,
  class: "fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$s = { class: "w-full max-w-4xl max-h-[80vh]" };
const _hoisted_3$r = { class: "px-6 py-4 border-b border-gray-200 dark:border-dark-bg-mute flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] rounded-t-xl" };
const _hoisted_4$p = { class: "flex items-center justify-between" };
const _hoisted_5$n = { class: "text-xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$m = ["aria-label"];
const _hoisted_7$l = { class: "px-6 py-4 flex-1 overflow-y-auto min-h-0" };
const _hoisted_8$l = {
  key: 0,
  class: "text-center py-8"
};
const _hoisted_9$l = { class: "mt-2 text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_10$k = { class: "mt-1 text-sm text-gray-500 dark:text-white/70" };
const _hoisted_11$k = {
  key: 1,
  class: "space-y-4"
};
const _hoisted_12$k = { class: "flex justify-between items-start" };
const _hoisted_13$k = { class: "flex-1" };
const _hoisted_14$k = { class: "flex items-center space-x-2 mb-2" };
const _hoisted_15$h = { class: "text-sm text-gray-500 dark:text-white/70" };
const _hoisted_16$h = ["aria-disabled", "title", "aria-label", "onClick"];
const _hoisted_17$h = ["title", "aria-label", "onClick"];
const _hoisted_18$g = { class: "grid grid-cols-2 md:grid-cols-4 gap-4 text-sm" };
const _hoisted_19$g = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_20$g = { class: "ml-1 font-medium text-gray-900 dark:text-white" };
const _hoisted_21$g = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_22$e = { class: "ml-1 font-medium text-green-600 dark:text-green-400" };
const _hoisted_23$e = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_24$d = { class: "ml-1 font-medium text-red-600 dark:text-red-400" };
const _hoisted_25$d = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_26$c = { class: "ml-1 font-medium text-gray-900 dark:text-white" };
const _hoisted_27$b = { class: "mt-2" };
const _hoisted_28$b = { class: "text-gray-500 dark:text-white/70 text-sm" };
const _hoisted_29$a = { class: "flex flex-wrap gap-1 mt-1" };
const _hoisted_30$9 = { class: "text-right" };
const _hoisted_31$9 = { class: "text-lg font-bold text-gray-900 dark:text-white" };
const _hoisted_32$8 = { class: "text-xs text-gray-500 dark:text-white/70" };
const _hoisted_33$8 = { class: "mt-1" };
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "HistoryModal",
  props: {
    show: { type: Boolean },
    history: {},
    getModeColor: { type: Function },
    getModeText: { type: Function },
    formatDate: { type: Function },
    formatDuration: { type: Function },
    deleteSession: { type: Function }
  },
  emits: ["close", "open-details", "delete-session"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const { t } = useI18n();
    const hasSessionDetails = (sessionId, flag) => {
      if (flag) return true;
      try {
        return !!localStorage.getItem(`flashcard-session-details:${sessionId}`);
      } catch {
        return false;
      }
    };
    const getCategoryDisplay = (category) => {
      if (category.includes(".")) {
        const parts = category.split(".");
        const fallback = parts[parts.length - 1];
        if (category === "flashcard.modes.flashcard") return t(category, "Flashcard");
        if (category === "flashcard.modes.quiz") return t(category, "Quiz");
        if (category === "flashcard.modes.typing") return t(category, "Typing");
        if (category === "flashcard.modes.listening") return t(category, "Listening");
        if (category === "flashcard.modes.image") return t(category, "Image");
        if (category === "flashcard.modes.pronunciation") return t(category, "Pronunciation");
        return t(category, fallback.charAt(0).toUpperCase() + fallback.slice(1));
      }
      return category;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$v, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$s, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-dark-bg-mute flex flex-col max-h-[80vh] transform",
                      onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$r, [
                        createBaseVNode("div", _hoisted_4$p, [
                          createBaseVNode("h3", _hoisted_5$n, [
                            _cache[2] || (_cache[2] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("flashcard.history.title", "Practice History")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: _cache[0] || (_cache[0] = ($event) => emit("close")),
                            "aria-label": unref(t)("common.close", "Close"),
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-white/80 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-dark-bg-soft"
                          }, _cache[3] || (_cache[3] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]), 8, _hoisted_6$m)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_7$l, [
                        _ctx.history.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_8$l, [
                          _cache[4] || (_cache[4] = createBaseVNode("svg", {
                            class: "mx-auto h-12 w-12 text-gray-400 dark:text-white/40",
                            fill: "none",
                            viewBox: "0 0 24 24",
                            stroke: "currentColor"
                          }, [
                            createBaseVNode("path", {
                              "stroke-linecap": "round",
                              "stroke-linejoin": "round",
                              "stroke-width": "2",
                              d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                            })
                          ], -1)),
                          createBaseVNode("h3", _hoisted_9$l, toDisplayString$1(unref(t)("flashcard.history.empty.title", "No History Yet")), 1),
                          createBaseVNode("p", _hoisted_10$k, toDisplayString$1(unref(t)("flashcard.history.empty.description", "Complete a practice session to see your history here.")), 1)
                        ])) : (openBlock(), createElementBlock("div", _hoisted_11$k, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.history, (session) => {
                            return openBlock(), createElementBlock("div", {
                              key: session.id,
                              class: "bg-gray-50 dark:bg-dark-bg-mute rounded-lg p-4"
                            }, [
                              createBaseVNode("div", _hoisted_12$k, [
                                createBaseVNode("div", _hoisted_13$k, [
                                  createBaseVNode("div", _hoisted_14$k, [
                                    createBaseVNode("span", {
                                      class: normalizeClass(["px-2 py-1 text-xs font-medium rounded-full", _ctx.getModeColor(session.mode)])
                                    }, toDisplayString$1(_ctx.getModeText(session.mode)), 3),
                                    createBaseVNode("span", _hoisted_15$h, toDisplayString$1(_ctx.formatDate(session.date)), 1),
                                    createBaseVNode("button", {
                                      class: normalizeClass(["inline-flex items-center ml-1 px-2 py-1 rounded-md border border-blue-200 bg-blue-50 text-blue-600 hover:bg-blue-100 hover:text-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400/50 transition dark:text-blue-300 dark:bg-blue-900/30 dark:border-blue-800 dark:hover:bg-blue-900/40 dark:hover:text-blue-200", !hasSessionDetails(session.id, session.hasDetails) ? "opacity-50" : ""]),
                                      "aria-disabled": !hasSessionDetails(session.id, session.hasDetails),
                                      title: hasSessionDetails(session.id, session.hasDetails) ? unref(t)("flashcard.history.viewDetails", "View details") : unref(t)("flashcard.history.noDetails", "No details available"),
                                      "aria-label": unref(t)("flashcard.history.viewDetails", "View details"),
                                      onClick: ($event) => emit("open-details", session.id)
                                    }, _cache[5] || (_cache[5] = [
                                      createBaseVNode("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        class: "h-4 w-4",
                                        viewBox: "0 0 24 24",
                                        fill: "currentColor"
                                      }, [
                                        createBaseVNode("path", { d: "M12 5c-7.633 0-10 7-10 7s2.367 7 10 7 10-7 10-7-2.367-7-10-7Zm0 12a5 5 0 1 1 0-10 5 5 0 0 1 0 10Zm0-2a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" })
                                      ], -1)
                                    ]), 10, _hoisted_16$h),
                                    createBaseVNode("button", {
                                      class: "inline-flex items-center ml-1 px-2 py-1 rounded-md border border-red-200 bg-red-50 text-red-600 hover:bg-red-100 hover:text-red-700 focus:outline-none focus:ring-2 focus:ring-red-400/50 transition dark:text-red-300 dark:bg-red-900/30 dark:border-red-800 dark:hover:bg-red-900/40 dark:hover:text-red-200",
                                      title: unref(t)("flashcard.history.deleteSession", "Delete session"),
                                      "aria-label": unref(t)("flashcard.history.deleteSession", "Delete session"),
                                      onClick: ($event) => emit("delete-session", session.id)
                                    }, _cache[6] || (_cache[6] = [
                                      createBaseVNode("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        class: "h-4 w-4",
                                        viewBox: "0 0 24 24",
                                        fill: "currentColor"
                                      }, [
                                        createBaseVNode("path", { d: "M3 6h18m-2 0v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6m3 0V4c0-1 1-2 2-2h4c0-1 1-2 2-2v2m-6 5v6m4-6v6" })
                                      ], -1)
                                    ]), 8, _hoisted_17$h)
                                  ]),
                                  createBaseVNode("div", _hoisted_18$g, [
                                    createBaseVNode("div", null, [
                                      createBaseVNode("span", _hoisted_19$g, toDisplayString$1(unref(t)("flashcard.history.totalCards", "Total Cards")) + ":", 1),
                                      createBaseVNode("span", _hoisted_20$g, toDisplayString$1(session.totalCards), 1)
                                    ]),
                                    createBaseVNode("div", null, [
                                      createBaseVNode("span", _hoisted_21$g, toDisplayString$1(unref(t)("flashcard.history.correct", "Correct")) + ":", 1),
                                      createBaseVNode("span", _hoisted_22$e, toDisplayString$1(session.correctAnswers), 1)
                                    ]),
                                    createBaseVNode("div", null, [
                                      createBaseVNode("span", _hoisted_23$e, toDisplayString$1(unref(t)("flashcard.history.incorrect", "Incorrect")) + ":", 1),
                                      createBaseVNode("span", _hoisted_24$d, toDisplayString$1(session.incorrectAnswers), 1)
                                    ]),
                                    createBaseVNode("div", null, [
                                      createBaseVNode("span", _hoisted_25$d, toDisplayString$1(unref(t)("flashcard.history.duration", "Duration")) + ":", 1),
                                      createBaseVNode("span", _hoisted_26$c, toDisplayString$1(_ctx.formatDuration(session.duration)), 1)
                                    ])
                                  ]),
                                  createBaseVNode("div", _hoisted_27$b, [
                                    createBaseVNode("span", _hoisted_28$b, toDisplayString$1(unref(t)("flashcard.history.categories", "Categories")) + ":", 1),
                                    createBaseVNode("div", _hoisted_29$a, [
                                      (openBlock(true), createElementBlock(Fragment, null, renderList(session.categories, (category) => {
                                        return openBlock(), createElementBlock("span", {
                                          key: category,
                                          class: "px-2 py-1 text-xs bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 rounded"
                                        }, toDisplayString$1(getCategoryDisplay(category)), 1);
                                      }), 128))
                                    ])
                                  ])
                                ]),
                                createBaseVNode("div", _hoisted_30$9, [
                                  createBaseVNode("div", _hoisted_31$9, toDisplayString$1(Math.round(session.correctAnswers / session.totalCards * 100)) + "% ", 1),
                                  createBaseVNode("div", _hoisted_32$8, toDisplayString$1(unref(t)("flashcard.history.accuracy", "Accuracy")), 1),
                                  createBaseVNode("div", _hoisted_33$8, [
                                    createBaseVNode("span", {
                                      class: normalizeClass(["text-xs font-medium px-2 py-0.5 rounded-full", Math.round(session.correctAnswers / session.totalCards * 100) >= 70 ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" : "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200"])
                                    }, toDisplayString$1(Math.round(session.correctAnswers / session.totalCards * 100) >= 70 ? unref(t)("flashcard.history.pass", "Pass") : unref(t)("flashcard.history.fail", "Fail")), 3)
                                  ])
                                ])
                              ])
                            ]);
                          }), 128))
                        ]))
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const HistoryModal = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$v
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$u = {
  key: 0,
  class: "fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-[60] backdrop-blur-sm"
};
const _hoisted_2$r = { class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-dark-bg-mute flex flex-col max-h-[82vh]" };
const _hoisted_3$q = { class: "px-6 py-4 border-b border-gray-200 dark:border-dark-bg-mute flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] rounded-t-xl" };
const _hoisted_4$o = { class: "flex items-center justify-between" };
const _hoisted_5$m = { class: "text-lg md:text-xl font-semibold text-gray-900 dark:text-white flex items-center gap-2" };
const _hoisted_6$l = ["aria-label"];
const _hoisted_7$k = { class: "px-4 md:px-6 py-4 flex-1 overflow-y-auto min-h-0" };
const _hoisted_8$k = {
  key: 0,
  class: "text-center py-10"
};
const _hoisted_9$k = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_10$j = {
  key: 1,
  class: "space-y-4"
};
const _hoisted_11$j = { class: "grid grid-cols-2 md:grid-cols-4 gap-3 text-sm" };
const _hoisted_12$j = { class: "bg-blue-50 dark:bg-blue-900/30 rounded-lg p-3" };
const _hoisted_13$j = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_14$j = { class: "text-gray-900 dark:text-white font-semibold" };
const _hoisted_15$g = { class: "bg-green-50 dark:bg-green-900/30 rounded-lg p-3" };
const _hoisted_16$g = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_17$g = { class: "text-green-700 dark:text-green-400 font-semibold" };
const _hoisted_18$f = { class: "bg-red-50 dark:bg-red-900/30 rounded-lg p-3" };
const _hoisted_19$f = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_20$f = { class: "text-red-700 dark:text-red-400 font-semibold" };
const _hoisted_21$f = { class: "bg-indigo-50 dark:bg-indigo-900/30 rounded-lg p-3" };
const _hoisted_22$d = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_23$d = { class: "text-indigo-700 dark:text-indigo-300 font-semibold" };
const _hoisted_24$c = { class: "divide-y divide-gray-200 dark:divide-dark-bg-mute rounded-lg overflow-hidden border border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_25$c = { class: "flex items-start justify-between gap-3" };
const _hoisted_26$b = { class: "min-w-0" };
const _hoisted_27$a = { class: "flex items-center gap-2" };
const _hoisted_28$a = { class: "text-sm font-semibold text-gray-900 dark:text-white truncate" };
const _hoisted_29$9 = { class: "text-xs text-gray-500 dark:text-white/70 truncate" };
const _hoisted_30$8 = { class: "mt-1 text-sm" };
const _hoisted_31$8 = { class: "text-gray-500 dark:text-white/70" };
const _hoisted_32$7 = { class: "text-sm text-gray-500 dark:text-white/70" };
const _hoisted_33$7 = { class: "ml-1 text-gray-900 dark:text-white" };
const _hoisted_34$7 = {
  key: 0,
  class: "mt-3 space-y-2"
};
const _hoisted_35$7 = ["onClick"];
const _hoisted_36$6 = ["src", "alt"];
const _hoisted_37$5 = ["onClick"];
const _hoisted_38$5 = { class: "uppercase tracking-wider" };
const _hoisted_39$4 = {
  key: 1,
  class: "mt-3 space-y-3"
};
const _hoisted_40$4 = { class: "bg-gradient-to-r from-emerald-50 to-green-50 dark:from-emerald-900/20 dark:to-green-900/20 rounded-lg border border-emerald-200 dark:border-emerald-800/50 p-3 animate-fade-in-up" };
const _hoisted_41$3 = { class: "flex items-center gap-3" };
const _hoisted_42$3 = { class: "flex-shrink-0" };
const _hoisted_43$3 = {
  key: 0,
  class: "w-6 h-6 text-emerald-600 dark:text-emerald-400 animate-bounce",
  fill: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_44$3 = {
  key: 1,
  class: "w-6 h-6 text-red-600 dark:text-red-400 animate-ping",
  fill: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_45$2 = { class: "flex-1 min-w-0" };
const _hoisted_46$2 = { class: "flex items-center gap-2" };
const _hoisted_47$2 = { class: "text-xs text-gray-500 dark:text-white/70 mt-1" };
const _hoisted_48$2 = { class: "grid grid-cols-2 md:grid-cols-4 gap-3 mt-3 text-xs" };
const _hoisted_49$2 = { class: "bg-white dark:bg-[#0a0a0a] rounded-md p-2 border border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_50$2 = { class: "font-semibold text-gray-900 dark:text-white animate-counter" };
const _hoisted_51$1 = { class: "bg-white dark:bg-[#0a0a0a] rounded-md p-2 border border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_52$1 = { class: "font-semibold text-emerald-600 dark:text-emerald-400 animate-counter" };
const _hoisted_53$1 = { class: "bg-white dark:bg-[#0a0a0a] rounded-md p-2 border border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_54$1 = { class: "font-semibold text-blue-600 dark:text-blue-400 animate-counter" };
const _hoisted_55$1 = { class: "bg-white dark:bg-[#0a0a0a] rounded-md p-2 border border-gray-200 dark:border-dark-bg-mute" };
const _hoisted_56$1 = { class: "font-semibold text-red-600 dark:text-red-400 animate-counter" };
const _hoisted_57$1 = { class: "mt-3" };
const _hoisted_58$1 = { class: "mt-2 text-xs text-gray-500 dark:text-white/70 flex items-center gap-4" };
const _hoisted_59$1 = { key: 0 };
const _hoisted_60$1 = {
  key: 2,
  class: "text-xs text-gray-500 dark:text-white/70 mt-1"
};
const _hoisted_61$1 = { class: "flex items-center gap-2" };
const _hoisted_62$1 = {
  key: 0,
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  class: "w-4 h-4",
  fill: "currentColor"
};
const _hoisted_63$1 = {
  key: 1,
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  class: "w-4 h-4",
  fill: "currentColor"
};
const _hoisted_64$1 = { class: "text-xs text-gray-500 dark:text-white/70" };
const _hoisted_65$1 = {
  key: 0,
  class: "fixed inset-0 z-[70] bg-black/60 backdrop-blur-sm flex items-center justify-center p-4"
};
const _hoisted_66$1 = { class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-dark-bg-mute flex flex-col max-h-[86vh]" };
const _hoisted_67$1 = { class: "px-6 py-4 border-b border-gray-200 dark:border-dark-bg-mute flex-shrink-0 bg-gradient-to-r from-indigo-50 to-purple-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] rounded-t-xl" };
const _hoisted_68$1 = { class: "flex items-center justify-between" };
const _hoisted_69$1 = { class: "text-lg md:text-xl font-semibold text-gray-900 dark:text-white flex items-center gap-2" };
const _hoisted_70$1 = ["aria-label"];
const _hoisted_71$1 = { class: "p-4 md:p-6 overflow-y-auto min-h-0" };
const _hoisted_72$1 = { class: "flex flex-col md:flex-row gap-6 items-start" };
const _hoisted_73$1 = {
  key: 0,
  class: "flex-shrink-0"
};
const _hoisted_74$1 = ["src", "alt"];
const _hoisted_75$1 = { class: "flex-1" };
const _hoisted_76$1 = { class: "flex flex-wrap gap-2 items-center" };
const _hoisted_77$1 = { class: "uppercase tracking-wider" };
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "SessionDetailModal",
  props: {
    show: { type: Boolean },
    details: {}
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const SnakeReplay = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => SnakeReplay$1),true              ?void 0:void 0));
    const emit = __emit;
    const { t } = useI18n();
    const zoomOpen = ref(false);
    const zoomImage = ref(void 0);
    const zoomSlots = ref([]);
    const openZoom = (entry) => {
      const img = entry?.extra?.pictionary?.image;
      const s = (entry?.extra?.pictionary?.slots || []).map((x) => ({
        char: x.char,
        fixed: !!x.fixed,
        separator: !!x.separator
      }));
      zoomImage.value = img;
      zoomSlots.value = s;
      zoomOpen.value = true;
    };
    const closeZoom = () => {
      zoomOpen.value = false;
    };
    const getDirectionName = (direction) => {
      if (direction.x === 1) return " Right";
      if (direction.x === -1) return " Left";
      if (direction.y === 1) return " Down";
      if (direction.y === -1) return " Up";
      return " Stopped";
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$u, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-95 translate-y-4",
                "enter-to-class": "opacity-100 scale-100 translate-y-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0",
                "leave-to-class": "opacity-0 scale-95 translate-y-4"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: "w-full max-w-5xl max-h-[82vh]",
                    onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("div", _hoisted_2$r, [
                      createBaseVNode("div", _hoisted_3$q, [
                        createBaseVNode("div", _hoisted_4$o, [
                          createBaseVNode("h3", _hoisted_5$m, [
                            _cache[3] || (_cache[3] = createBaseVNode("span", { class: "w-2 h-2 bg-indigo-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("flashcard.history.details.title", "Session Details")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: _cache[0] || (_cache[0] = ($event) => emit("close")),
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-white/80 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-dark-bg-soft",
                            "aria-label": unref(t)("common.close", "Close")
                          }, _cache[4] || (_cache[4] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]), 8, _hoisted_6$l)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_7$k, [
                        !_ctx.details ? (openBlock(), createElementBlock("div", _hoisted_8$k, [
                          createBaseVNode("div", _hoisted_9$k, toDisplayString$1(unref(t)("flashcard.history.details.noData", "No details available for this session")), 1)
                        ])) : (openBlock(), createElementBlock("div", _hoisted_10$j, [
                          createBaseVNode("div", _hoisted_11$j, [
                            createBaseVNode("div", _hoisted_12$j, [
                              createBaseVNode("div", _hoisted_13$j, toDisplayString$1(unref(t)("flashcard.history.totalCards", "Total Cards")), 1),
                              createBaseVNode("div", _hoisted_14$j, toDisplayString$1(_ctx.details.total), 1)
                            ]),
                            createBaseVNode("div", _hoisted_15$g, [
                              createBaseVNode("div", _hoisted_16$g, toDisplayString$1(unref(t)("flashcard.history.correct", "Correct")), 1),
                              createBaseVNode("div", _hoisted_17$g, toDisplayString$1(_ctx.details.correct), 1)
                            ]),
                            createBaseVNode("div", _hoisted_18$f, [
                              createBaseVNode("div", _hoisted_19$f, toDisplayString$1(unref(t)("flashcard.history.incorrect", "Incorrect")), 1),
                              createBaseVNode("div", _hoisted_20$f, toDisplayString$1(_ctx.details.incorrect), 1)
                            ]),
                            createBaseVNode("div", _hoisted_21$f, [
                              createBaseVNode("div", _hoisted_22$d, toDisplayString$1(unref(t)("flashcard.modes.mode", "Mode")), 1),
                              createBaseVNode("div", _hoisted_23$d, toDisplayString$1(_ctx.details.mode), 1)
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_24$c, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.details.entries, (e, idx) => {
                              return openBlock(), createElementBlock("div", {
                                key: idx,
                                class: "p-3 md:p-4 bg-white dark:bg-gray-custom"
                              }, [
                                createBaseVNode("div", _hoisted_25$c, [
                                  createBaseVNode("div", _hoisted_26$b, [
                                    createBaseVNode("div", _hoisted_27$a, [
                                      createBaseVNode("span", _hoisted_28$a, toDisplayString$1(e.word), 1),
                                      createBaseVNode("span", _hoisted_29$9, " " + toDisplayString$1(e.meaningShort), 1)
                                    ]),
                                    createBaseVNode("div", _hoisted_30$8, [
                                      createBaseVNode("span", _hoisted_31$8, toDisplayString$1(unref(t)("flashcard.history.details.yourAnswer", "Your answer")) + ":", 1),
                                      createBaseVNode("span", {
                                        class: normalizeClass(["ml-1", e.isCorrect ? "text-green-700 dark:text-green-400" : "text-red-700 dark:text-red-400"])
                                      }, toDisplayString$1(e.userAnswer || unref(t)("flashcard.history.details.noAnswer", "No answer")), 3)
                                    ]),
                                    createBaseVNode("div", _hoisted_32$7, [
                                      createBaseVNode("span", null, toDisplayString$1(unref(t)("flashcard.history.details.correctAnswer", "Correct answer")) + ":", 1),
                                      createBaseVNode("span", _hoisted_33$7, toDisplayString$1(e.correctAnswer), 1)
                                    ]),
                                    e.mode === "pictionary" ? (openBlock(), createElementBlock("div", _hoisted_34$7, [
                                      e.extra?.pictionary?.image ? (openBlock(), createElementBlock("div", {
                                        key: 0,
                                        class: "flex items-center gap-3 cursor-zoom-in select-none",
                                        onClick: ($event) => openZoom(e)
                                      }, [
                                        createBaseVNode("img", {
                                          src: e.extra.pictionary.image,
                                          alt: unref(t)("flashcard.pictionary.imageAlt", "Pictionary image"),
                                          class: "w-24 h-24 object-contain rounded-lg border border-gray-200 dark:border-dark-bg-mute bg-white dark:bg-dark-bg-soft"
                                        }, null, 8, _hoisted_36$6)
                                      ], 8, _hoisted_35$7)) : createCommentVNode("", true),
                                      e.extra?.pictionary?.slots && e.extra.pictionary.slots.length ? (openBlock(), createElementBlock("div", {
                                        key: 1,
                                        class: "flex flex-wrap gap-1.5 items-center cursor-zoom-in select-none",
                                        onClick: ($event) => openZoom(e)
                                      }, [
                                        (openBlock(true), createElementBlock(Fragment, null, renderList(e.extra.pictionary.slots, (slot, sIdx) => {
                                          return openBlock(), createElementBlock(Fragment, null, [
                                            slot.separator ? (openBlock(), createElementBlock("div", {
                                              key: `sep-${sIdx}`,
                                              class: "px-1 text-base text-gray-700 dark:text-white/80 select-none"
                                            }, toDisplayString$1(slot.char), 1)) : (openBlock(), createElementBlock("div", {
                                              key: `box-${sIdx}`,
                                              class: normalizeClass(["w-8 h-10 sm:w-9 sm:h-11 flex items-center justify-center rounded-md border text-lg font-semibold bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white border-gray-300 dark:border-dark-bg-mute", slot.fixed ? "opacity-90" : ""])
                                            }, [
                                              createBaseVNode("span", _hoisted_38$5, toDisplayString$1(slot.char || ""), 1)
                                            ], 2))
                                          ], 64);
                                        }), 256))
                                      ], 8, _hoisted_37$5)) : createCommentVNode("", true)
                                    ])) : createCommentVNode("", true),
                                    e.mode === "snake-game" && e.extra?.snakeGame ? (openBlock(), createElementBlock("div", _hoisted_39$4, [
                                      createBaseVNode("div", _hoisted_40$4, [
                                        createBaseVNode("div", _hoisted_41$3, [
                                          createBaseVNode("div", _hoisted_42$3, [
                                            createBaseVNode("div", {
                                              class: normalizeClass(["w-10 h-10 rounded-full flex items-center justify-center animate-pulse", e.extra.snakeGame.wasCorrect ? "bg-emerald-100 dark:bg-emerald-900/50" : "bg-red-100 dark:bg-red-900/50"])
                                            }, [
                                              e.extra.snakeGame.wasCorrect ? (openBlock(), createElementBlock("svg", _hoisted_43$3, _cache[5] || (_cache[5] = [
                                                createBaseVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" }, null, -1)
                                              ]))) : (openBlock(), createElementBlock("svg", _hoisted_44$3, _cache[6] || (_cache[6] = [
                                                createBaseVNode("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }, null, -1)
                                              ])))
                                            ], 2)
                                          ]),
                                          createBaseVNode("div", _hoisted_45$2, [
                                            createBaseVNode("div", _hoisted_46$2, [
                                              createBaseVNode("span", {
                                                class: normalizeClass(["text-sm font-medium", e.extra.snakeGame.wasCorrect ? "text-emerald-700 dark:text-emerald-300" : "text-red-700 dark:text-red-300"])
                                              }, toDisplayString$1(e.extra.snakeGame.wasCorrect ? " Ate Correct Food" : " Ate Wrong Food"), 3),
                                              createBaseVNode("span", {
                                                class: normalizeClass(["text-xs px-2 py-0.5 rounded-full", e.extra.snakeGame.foodType === "primary" ? "bg-emerald-100 text-emerald-800 dark:bg-emerald-900/50 dark:text-emerald-200" : "bg-amber-100 text-amber-800 dark:bg-amber-900/50 dark:text-amber-200"])
                                              }, toDisplayString$1(e.extra.snakeGame.foodType === "primary" ? "Target Food" : "Decoy Food"), 3)
                                            ]),
                                            createBaseVNode("div", _hoisted_47$2, " Position: (" + toDisplayString$1(e.extra.snakeGame.position.x) + ", " + toDisplayString$1(e.extra.snakeGame.position.y) + ") ", 1)
                                          ])
                                        ]),
                                        createBaseVNode("div", _hoisted_48$2, [
                                          createBaseVNode("div", _hoisted_49$2, [
                                            _cache[7] || (_cache[7] = createBaseVNode("div", { class: "text-gray-500 dark:text-white/70" }, "Snake Length", -1)),
                                            createBaseVNode("div", _hoisted_50$2, toDisplayString$1(e.extra.snakeGame.snakeLength), 1)
                                          ]),
                                          createBaseVNode("div", _hoisted_51$1, [
                                            _cache[8] || (_cache[8] = createBaseVNode("div", { class: "text-gray-500 dark:text-white/70" }, "Game Score", -1)),
                                            createBaseVNode("div", _hoisted_52$1, toDisplayString$1(e.extra.snakeGame.gameScore), 1)
                                          ]),
                                          createBaseVNode("div", _hoisted_53$1, [
                                            _cache[9] || (_cache[9] = createBaseVNode("div", { class: "text-gray-500 dark:text-white/70" }, "Words Done", -1)),
                                            createBaseVNode("div", _hoisted_54$1, toDisplayString$1(e.extra.snakeGame.wordsCompleted), 1)
                                          ]),
                                          createBaseVNode("div", _hoisted_55$1, [
                                            _cache[10] || (_cache[10] = createBaseVNode("div", { class: "text-gray-500 dark:text-white/70" }, "Wrong Bites", -1)),
                                            createBaseVNode("div", _hoisted_56$1, toDisplayString$1(e.extra.snakeGame.wrongEatenCount), 1)
                                          ])
                                        ]),
                                        createBaseVNode("div", _hoisted_57$1, [
                                          _cache[11] || (_cache[11] = createBaseVNode("div", { class: "text-xs text-gray-500 dark:text-white/70 mb-2" }, "Snake Movement & Food Position:", -1)),
                                          createVNode(unref(SnakeReplay), {
                                            data: e.extra.snakeGame
                                          }, null, 8, ["data"]),
                                          createBaseVNode("div", _hoisted_58$1, [
                                            createBaseVNode("span", null, " Length: " + toDisplayString$1(e.extra.snakeGame.snakeLength), 1),
                                            e.extra.snakeGame.direction ? (openBlock(), createElementBlock("span", _hoisted_59$1, " Direction: " + toDisplayString$1(getDirectionName(e.extra.snakeGame.direction)), 1)) : createCommentVNode("", true)
                                          ])
                                        ])
                                      ])
                                    ])) : createCommentVNode("", true),
                                    e.notes ? (openBlock(), createElementBlock("div", _hoisted_60$1, toDisplayString$1(e.notes), 1)) : createCommentVNode("", true)
                                  ]),
                                  createBaseVNode("div", _hoisted_61$1, [
                                    createBaseVNode("span", {
                                      class: normalizeClass(["inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs", e.isCorrect ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" : "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200"])
                                    }, [
                                      e.isCorrect ? (openBlock(), createElementBlock("svg", _hoisted_62$1, _cache[12] || (_cache[12] = [
                                        createBaseVNode("path", { d: "M9 16.17 4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" }, null, -1)
                                      ]))) : (openBlock(), createElementBlock("svg", _hoisted_63$1, _cache[13] || (_cache[13] = [
                                        createBaseVNode("path", { d: "m19 6.41-1.41-1.41L12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }, null, -1)
                                      ]))),
                                      createBaseVNode("span", null, toDisplayString$1(e.isCorrect ? unref(t)("flashcard.history.correct", "Correct") : unref(t)("flashcard.history.incorrect", "Incorrect")), 1)
                                    ], 2),
                                    createBaseVNode("span", _hoisted_64$1, toDisplayString$1(new Date(e.timestamp).toLocaleString()), 1)
                                  ])
                                ])
                              ]);
                            }), 128))
                          ])
                        ]))
                      ])
                    ])
                  ])
                ]),
                _: 1
              }),
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0",
                "enter-to-class": "opacity-100",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100",
                "leave-to-class": "opacity-0"
              }, {
                default: withCtx(() => [
                  zoomOpen.value ? (openBlock(), createElementBlock("div", _hoisted_65$1, [
                    createVNode(Transition, {
                      "enter-active-class": "transition-all duration-500 ease-out",
                      "enter-from-class": "opacity-0 scale-95 translate-y-4",
                      "enter-to-class": "opacity-100 scale-100 translate-y-0",
                      "leave-active-class": "transition-all duration-300 ease-in",
                      "leave-from-class": "opacity-100 scale-100 translate-y-0",
                      "leave-to-class": "opacity-0 scale-95 translate-y-4"
                    }, {
                      default: withCtx(() => [
                        createBaseVNode("div", {
                          class: "w-full max-w-4xl max-h-[86vh]",
                          onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                          }, ["stop"]))
                        }, [
                          createBaseVNode("div", _hoisted_66$1, [
                            createBaseVNode("div", _hoisted_67$1, [
                              createBaseVNode("div", _hoisted_68$1, [
                                createBaseVNode("h3", _hoisted_69$1, [
                                  _cache[14] || (_cache[14] = createBaseVNode("span", { class: "w-2 h-2 bg-indigo-500 rounded-full animate-pulse" }, null, -1)),
                                  createBaseVNode("span", null, toDisplayString$1(unref(t)("flashcard.pictionary.preview", "Pictionary Preview")), 1)
                                ]),
                                createBaseVNode("button", {
                                  onClick: closeZoom,
                                  class: "text-gray-400 hover:text-gray-600 dark:hover:text-white/80 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-dark-bg-soft",
                                  "aria-label": unref(t)("common.close", "Close")
                                }, _cache[15] || (_cache[15] = [
                                  createBaseVNode("svg", {
                                    class: "w-6 h-6",
                                    fill: "none",
                                    stroke: "currentColor",
                                    viewBox: "0 0 24 24"
                                  }, [
                                    createBaseVNode("path", {
                                      "stroke-linecap": "round",
                                      "stroke-linejoin": "round",
                                      "stroke-width": "2",
                                      d: "M6 18L18 6M6 6l12 12"
                                    })
                                  ], -1)
                                ]), 8, _hoisted_70$1)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_71$1, [
                              createBaseVNode("div", _hoisted_72$1, [
                                zoomImage.value ? (openBlock(), createElementBlock("div", _hoisted_73$1, [
                                  createBaseVNode("img", {
                                    src: zoomImage.value,
                                    alt: unref(t)("flashcard.pictionary.imageAlt", "Pictionary image"),
                                    class: "w-[320px] h-[240px] md:w-[420px] md:h-[300px] object-contain rounded-lg border border-gray-200 dark:border-dark-bg-mute bg-white dark:bg-dark-bg-soft"
                                  }, null, 8, _hoisted_74$1)
                                ])) : createCommentVNode("", true),
                                createBaseVNode("div", _hoisted_75$1, [
                                  createBaseVNode("div", _hoisted_76$1, [
                                    (openBlock(true), createElementBlock(Fragment, null, renderList(zoomSlots.value, (slot, sIdx) => {
                                      return openBlock(), createElementBlock(Fragment, null, [
                                        slot.separator ? (openBlock(), createElementBlock("div", {
                                          key: `sep-${sIdx}`,
                                          class: "px-1 text-xl text-gray-700 dark:text-white/80 select-none"
                                        }, toDisplayString$1(slot.char), 1)) : (openBlock(), createElementBlock("div", {
                                          key: `box-${sIdx}`,
                                          class: normalizeClass(["w-12 h-14 sm:w-14 sm:h-16 flex items-center justify-center rounded-lg border text-2xl font-semibold bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white border-gray-300 dark:border-dark-bg-mute", slot.fixed ? "opacity-90" : ""])
                                        }, [
                                          createBaseVNode("span", _hoisted_77$1, toDisplayString$1(slot.char || ""), 1)
                                        ], 2))
                                      ], 64);
                                    }), 256))
                                  ])
                                ])
                              ])
                            ])
                          ])
                        ])
                      ]),
                      _: 1
                    })
                  ])) : createCommentVNode("", true)
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const SessionDetailModal = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$u
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$t = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$q = { class: "w-full max-w-md" };
const _hoisted_3$p = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] rounded-t-xl" };
const _hoisted_4$n = { class: "flex items-center justify-between" };
const _hoisted_5$l = { class: "text-lg font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$k = { class: "px-6 py-4" };
const _hoisted_7$j = { class: "space-y-4" };
const _hoisted_8$j = { class: "relative" };
const _hoisted_9$j = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_10$i = {
  key: 0,
  class: "absolute top-full left-0 right-0 mt-1 bg-white dark:bg-[#0a0a0a] border border-gray-300 dark:border-gray-700 rounded-md shadow-xl z-[99999] overflow-hidden"
};
const _hoisted_11$i = { class: "p-3 border-b border-gray-200 dark:border-gray-700" };
const _hoisted_12$i = ["placeholder"];
const _hoisted_13$i = { class: "max-h-[240px] overflow-y-auto" };
const _hoisted_14$i = ["onClick"];
const _hoisted_15$f = {
  key: 0,
  class: "px-3 py-2 text-sm text-gray-500 dark:text-gray-400 text-center"
};
const _hoisted_16$f = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_17$f = ["value"];
const _hoisted_18$e = { value: "" };
const _hoisted_19$e = ["value"];
const _hoisted_20$e = { class: "flex items-center" };
const _hoisted_21$e = ["checked"];
const _hoisted_22$c = { class: "text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_23$c = { class: "flex items-center" };
const _hoisted_24$b = ["checked"];
const _hoisted_25$b = { class: "text-sm text-gray-700 dark:text-gray-300" };
const _hoisted_26$a = { class: "flex justify-end space-x-3 mt-6" };
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "SettingsModal",
  props: {
    show: { type: Boolean },
    settings: {},
    localSettings: {},
    dateFilterEnabled: { type: Boolean },
    selectedDate: {}
  },
  emits: ["update:settings", "update:local-settings", "cancel", "apply"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const { getCategories, getLevels, allVocabularies } = useVocabularyStore();
    const levels = getLevels;
    const categoryDropdownOpen = ref(false);
    const categorySearchQuery = ref("");
    const categories = computed(() => {
      if (props.dateFilterEnabled && props.selectedDate) {
        const vocabulariesForDate = allVocabularies.value.filter((vocab) => {
          return vocab.createdAt && vocab.createdAt.startsWith(props.selectedDate);
        });
        const categoriesForDate = new Set(vocabulariesForDate.map((vocab) => vocab.category));
        return Array.from(categoriesForDate);
      }
      const categorySet = new Set(allVocabularies.value.map((v) => v.category));
      return Array.from(categorySet);
    });
    const filteredCategories = computed(() => {
      if (!categorySearchQuery.value) return categories.value;
      return categories.value.filter((category) => {
        const topicName = getTopicName(category).toLowerCase();
        return topicName.includes(categorySearchQuery.value.toLowerCase());
      });
    });
    const getSelectedCategoryDisplay = () => {
      if (!props.localSettings.category) {
        return t("flashcard.settings.all", "All");
      }
      return getTopicName(props.localSettings.category);
    };
    const toggleCategoryDropdown = () => {
      categoryDropdownOpen.value = !categoryDropdownOpen.value;
      if (categoryDropdownOpen.value) {
        categorySearchQuery.value = "";
      }
    };
    const selectCategory = (category) => {
      updateLocalSetting("category", { target: { value: category } });
      categoryDropdownOpen.value = false;
      categorySearchQuery.value = "";
    };
    const handleClickOutside = (event) => {
      const target = event.target;
      if (!target.closest(".relative")) {
        categoryDropdownOpen.value = false;
      }
    };
    watch(() => props.show, (newShow) => {
      if (!newShow) {
        categoryDropdownOpen.value = false;
        categorySearchQuery.value = "";
      }
    });
    onMounted(() => {
      document.addEventListener("click", handleClickOutside);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleClickOutside);
    });
    const updateLocalSetting = (key, event) => {
      const target = event.target;
      const value = target.type === "checkbox" ? target.checked : target.value;
      emit("update:local-settings", { ...props.localSettings, [key]: value });
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$t, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$q, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 transform",
                      onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$p, [
                        createBaseVNode("div", _hoisted_4$n, [
                          createBaseVNode("h3", _hoisted_5$l, [
                            _cache[10] || (_cache[10] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("flashcard.settings.title", "Flashcard Settings")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: _cache[0] || (_cache[0] = ($event) => emit("cancel")),
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[11] || (_cache[11] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_6$k, [
                        createBaseVNode("div", _hoisted_7$j, [
                          createBaseVNode("div", _hoisted_8$j, [
                            createBaseVNode("label", _hoisted_9$j, toDisplayString$1(unref(t)("flashcard.settings.category", "Category")), 1),
                            createBaseVNode("button", {
                              type: "button",
                              onClick: toggleCategoryDropdown,
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white text-left flex items-center justify-between hover:border-blue-300 dark:hover:border-blue-600 transition-colors"
                            }, [
                              createBaseVNode("span", null, toDisplayString$1(getSelectedCategoryDisplay()), 1),
                              (openBlock(), createElementBlock("svg", {
                                class: normalizeClass(["w-4 h-4 transition-transform duration-200", categoryDropdownOpen.value ? "rotate-180" : ""]),
                                fill: "currentColor",
                                viewBox: "0 0 20 20"
                              }, _cache[12] || (_cache[12] = [
                                createBaseVNode("path", {
                                  "fill-rule": "evenodd",
                                  d: "M5.23 7.21a.75.75 0 011.06.02L10 11.17l3.71-3.94a.75.75 0 111.08 1.04l-4.24 4.5a.75.75 0 01-1.08 0L5.21 8.27a.75.75 0 01.02-1.06z",
                                  "clip-rule": "evenodd"
                                }, null, -1)
                              ]), 2))
                            ]),
                            createVNode(Transition, {
                              "enter-active-class": "transition-all duration-200 ease-out",
                              "enter-from-class": "opacity-0 scale-95 translate-y-2",
                              "enter-to-class": "opacity-100 scale-100 translate-y-0",
                              "leave-active-class": "transition-all duration-150 ease-in",
                              "leave-from-class": "opacity-100 scale-100 translate-y-0",
                              "leave-to-class": "opacity-0 scale-95 translate-y-2"
                            }, {
                              default: withCtx(() => [
                                categoryDropdownOpen.value ? (openBlock(), createElementBlock("div", _hoisted_10$i, [
                                  createBaseVNode("div", _hoisted_11$i, [
                                    withDirectives(createBaseVNode("input", {
                                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => categorySearchQuery.value = $event),
                                      type: "text",
                                      placeholder: unref(t)("common.search", "Search") + "...",
                                      class: "w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0f0f0f] text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none",
                                      onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                                      }, ["stop"]))
                                    }, null, 8, _hoisted_12$i), [
                                      [vModelText, categorySearchQuery.value]
                                    ])
                                  ]),
                                  createBaseVNode("div", _hoisted_13$i, [
                                    createBaseVNode("div", {
                                      class: normalizeClass(["px-3 py-2 text-sm cursor-pointer hover:bg-blue-50 dark:hover:bg-blue-900/20 text-gray-900 dark:text-white transition-colors", _ctx.localSettings.category === "" ? "bg-blue-100 dark:bg-blue-900/30 font-medium" : ""]),
                                      onClick: _cache[3] || (_cache[3] = ($event) => selectCategory(""))
                                    }, toDisplayString$1(unref(t)("flashcard.settings.all", "All")), 3),
                                    (openBlock(true), createElementBlock(Fragment, null, renderList(filteredCategories.value, (category) => {
                                      return openBlock(), createElementBlock("div", {
                                        key: category,
                                        class: normalizeClass(["px-3 py-2 text-sm cursor-pointer hover:bg-blue-50 dark:hover:bg-blue-900/20 text-gray-900 dark:text-white transition-colors", _ctx.localSettings.category === category ? "bg-blue-100 dark:bg-blue-900/30 font-medium" : ""]),
                                        onClick: ($event) => selectCategory(category)
                                      }, toDisplayString$1(unref(getTopicName)(category)), 11, _hoisted_14$i);
                                    }), 128)),
                                    filteredCategories.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_15$f, toDisplayString$1(unref(t)("common.noResults", "No results found")), 1)) : createCommentVNode("", true)
                                  ])
                                ])) : createCommentVNode("", true)
                              ]),
                              _: 1
                            })
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("label", _hoisted_16$f, toDisplayString$1(unref(t)("flashcard.settings.level", "Level")), 1),
                            createBaseVNode("select", {
                              value: _ctx.localSettings.level,
                              onChange: _cache[4] || (_cache[4] = ($event) => updateLocalSetting("level", $event)),
                              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white"
                            }, [
                              createBaseVNode("option", _hoisted_18$e, toDisplayString$1(unref(t)("flashcard.settings.all", "All")), 1),
                              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(levels), (level) => {
                                return openBlock(), createElementBlock("option", {
                                  key: level,
                                  value: level
                                }, toDisplayString$1(unref(t)(`flashcard.settings.${level.toLowerCase()}`, level)), 9, _hoisted_19$e);
                              }), 128))
                            ], 40, _hoisted_17$f)
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("label", _hoisted_20$e, [
                              createBaseVNode("input", {
                                type: "checkbox",
                                checked: _ctx.localSettings.autoFlip,
                                onChange: _cache[5] || (_cache[5] = ($event) => updateLocalSetting("autoFlip", $event)),
                                class: "mr-2"
                              }, null, 40, _hoisted_21$e),
                              createBaseVNode("span", _hoisted_22$c, toDisplayString$1(unref(t)("flashcard.settings.autoFlip", "Auto-flip after answering")), 1)
                            ])
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("label", _hoisted_23$c, [
                              createBaseVNode("input", {
                                type: "checkbox",
                                checked: _ctx.localSettings.shuffleCards,
                                onChange: _cache[6] || (_cache[6] = ($event) => updateLocalSetting("shuffleCards", $event)),
                                class: "mr-2"
                              }, null, 40, _hoisted_24$b),
                              createBaseVNode("span", _hoisted_25$b, toDisplayString$1(unref(t)("flashcard.settings.shuffle", "Shuffle cards")), 1)
                            ])
                          ])
                        ]),
                        createBaseVNode("div", _hoisted_26$a, [
                          createBaseVNode("button", {
                            onClick: _cache[7] || (_cache[7] = ($event) => emit("cancel")),
                            class: "px-4 py-2 text-gray-700 dark:text-gray-300 border border-gray-300 dark:border-gray-700 rounded-md hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
                          }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                          createBaseVNode("button", {
                            onClick: _cache[8] || (_cache[8] = ($event) => emit("apply")),
                            class: "px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md transition-colors"
                          }, toDisplayString$1(unref(t)("common.apply", "Apply")), 1)
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const SettingsModal = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$t
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$s = {
  key: 1,
  class: "text-center h-full flex flex-col justify-start md:justify-center items-center gap-3 md:gap-4"
};
const _hoisted_2$p = { class: "mb-6" };
const _hoisted_3$o = { class: "px-2.5 py-0.5 bg-blue-100 dark:bg-dark-bg-mute text-blue-800 dark:text-blue-300 text-xs sm:text-sm font-medium rounded-full" };
const _hoisted_4$m = { class: "text-3xl sm:text-4xl md:text-5xl leading-tight font-bold text-gray-900 dark:text-white mb-3 md:mb-4 break-words" };
const _hoisted_5$k = { class: "text-base sm:text-lg md:text-xl text-gray-500 dark:text-white/70 mb-6 md:mb-8 break-words" };
const _hoisted_6$j = {
  key: 0,
  class: "text-red-500 dark:text-red-400"
};
const _hoisted_7$i = { key: 1 };
const _hoisted_8$i = ["disabled"];
const _hoisted_9$i = { class: "mt-5 sm:mt-6 md:mt-8" };
const _hoisted_10$h = {
  key: 0,
  class: "text-gray-600 dark:text-white/80 text-sm sm:text-base break-words"
};
const _hoisted_11$h = { class: "font-medium text-gray-800 dark:text-white" };
const _hoisted_12$h = {
  key: 1,
  class: "mt-4"
};
const _hoisted_13$h = {
  key: 0,
  class: "text-lg sm:text-xl md:text-2xl font-bold text-green-600 dark:text-green-400"
};
const _hoisted_14$h = {
  key: 1,
  class: "text-lg sm:text-xl md:text-2xl font-bold text-red-600 dark:text-red-400"
};
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "PronunciationMode",
  props: {
    card: {},
    isRecording: { type: Boolean },
    pronunciationResult: {},
    pronunciationAnswered: { type: Boolean },
    pronunciationCorrect: { type: Boolean },
    isSpeechRecognitionSupported: { type: Boolean },
    getTopicName: { type: Function },
    wordsCrushEnabled: { type: Boolean }
  },
  emits: ["start-recording", "game-completed", "play-audio"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const WordsCrushMode = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => WordsCrushMode$1),true              ?void 0:void 0));
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const props = __props;
    const emit = __emit;
    const handleStartRecording = () => {
      emit("start-recording");
    };
    const handleGameCompleted = (isCorrect) => {
      isCorrectAnswer.value = isCorrect;
      setTimeout(() => {
        triggerFirework.value = true;
        triggerSound.value = true;
      }, 50);
      emit("game-completed", isCorrect);
    };
    const handlePlayAudio = () => {
      emit("play-audio");
    };
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    watch(() => props.pronunciationAnswered, (newValue) => {
      if (newValue && !triggerFirework.value && !props.wordsCrushEnabled) {
        isCorrectAnswer.value = props.pronunciationCorrect;
        setTimeout(() => {
          triggerFirework.value = true;
          triggerSound.value = true;
        }, 50);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-dark-bg-mute p-4 sm:p-6 md:p-8 min-h-96 h-auto select-none overflow-hidden",
        onCopy: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        _ctx.wordsCrushEnabled && _ctx.card ? (openBlock(), createBlock(unref(WordsCrushMode), {
          key: 0,
          card: _ctx.card,
          "get-topic-name": _ctx.getTopicName,
          onGameCompleted: handleGameCompleted,
          onPlayAudio: handlePlayAudio
        }, null, 8, ["card", "get-topic-name"])) : (openBlock(), createElementBlock("div", _hoisted_1$s, [
          createBaseVNode("div", _hoisted_2$p, [
            createBaseVNode("span", _hoisted_3$o, toDisplayString$1(_ctx.card?.category ? _ctx.getTopicName(_ctx.card.category) : ""), 1)
          ]),
          createBaseVNode("h2", _hoisted_4$m, toDisplayString$1(_ctx.card?.word), 1),
          createBaseVNode("p", _hoisted_5$k, toDisplayString$1(_ctx.card?.pronunciation), 1),
          !_ctx.isSpeechRecognitionSupported ? (openBlock(), createElementBlock("div", _hoisted_6$j, toDisplayString$1(unref(t)("flashcard.pronunciation.microphoneError", "Microphone error! Please check microphone access permissions.")), 1)) : (openBlock(), createElementBlock("div", _hoisted_7$i, [
            createBaseVNode("button", {
              onClick: handleStartRecording,
              disabled: _ctx.isRecording,
              class: normalizeClass(["bg-red-500 hover:bg-red-600 text-white p-4 sm:p-5 md:p-6 rounded-full transition-colors disabled:opacity-50", { "animate-pulse": _ctx.isRecording }])
            }, _cache[3] || (_cache[3] = [
              createBaseVNode("svg", {
                class: "w-8 h-8",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", { d: "M7 4a3 3 0 016 0v6a3 3 0 11-6 0V4z" }),
                createBaseVNode("path", { d: "M5.5 9.5a.5.5 0 01.5.5v1a4 4 0 004 4h.5a.5.5 0 010 1h-.5a5 5 0 01-5-5v-1a.5.5 0 01.5-.5z" }),
                createBaseVNode("path", { d: "M10 18a5 5 0 005-5h-1a4 4 0 01-4 4v1z" })
              ], -1)
            ]), 10, _hoisted_8$i)
          ])),
          createBaseVNode("div", _hoisted_9$i, [
            _ctx.pronunciationResult ? (openBlock(), createElementBlock("p", _hoisted_10$h, [
              createTextVNode(toDisplayString$1(unref(t)("flashcard.pronunciation.yourRecording", "Your Recording")) + ": ", 1),
              createBaseVNode("span", _hoisted_11$h, toDisplayString$1(_ctx.pronunciationResult), 1)
            ])) : createCommentVNode("", true),
            _ctx.pronunciationAnswered ? (openBlock(), createElementBlock("div", _hoisted_12$h, [
              _ctx.pronunciationCorrect ? (openBlock(), createElementBlock("p", _hoisted_13$h, toDisplayString$1(unref(t)("flashcard.listening.correct", " Correct!")), 1)) : (openBlock(), createElementBlock("p", _hoisted_14$h, toDisplayString$1(unref(t)("flashcard.pronunciation.tryAgain", "Try Again!")), 1))
            ])) : createCommentVNode("", true)
          ])
        ])),
        createVNode(unref(FireworkSoundEffect), {
          ref_key: "fireworkEffect",
          ref: fireworkEffect,
          "trigger-firework": triggerFirework.value,
          "trigger-sound": triggerSound.value,
          "is-correct": isCorrectAnswer.value,
          onEffectComplete: resetTriggers
        }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
      ], 32);
    };
  }
});

const PronunciationMode = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$s
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$r = { class: "text-center h-full flex flex-col justify-center" };
const _hoisted_2$o = { class: "mb-6" };
const _hoisted_3$n = { class: "px-3 py-1 bg-blue-100 dark:bg-gray-800 text-blue-800 dark:text-blue-300 text-xs sm:text-sm md:text-base font-medium rounded-full" };
const _hoisted_4$l = { class: "mb-8" };
const _hoisted_5$j = {
  key: 0,
  class: "text-base sm:text-lg md:text-xl text-gray-600 dark:text-gray-300 mb-8"
};
const _hoisted_6$i = {
  key: 1,
  class: "text-base sm:text-lg md:text-xl text-gray-600 dark:text-gray-300 mb-8"
};
const _hoisted_7$h = {
  key: 2,
  class: "max-w-md mx-auto"
};
const _hoisted_8$h = ["value", "disabled", "placeholder"];
const _hoisted_9$h = {
  key: 0,
  class: "mt-4"
};
const _hoisted_10$g = {
  key: 0,
  class: "text-green-600 dark:text-green-400 font-medium"
};
const _hoisted_11$g = {
  key: 1,
  class: "text-red-600 dark:text-red-400 font-medium"
};
const _hoisted_12$g = { class: "text-sm text-gray-500 dark:text-gray-400 mt-2" };
const _hoisted_13$g = {
  key: 3,
  class: "w-full px-2 sm:px-3 md:px-0"
};
const _hoisted_14$g = { class: "grid grid-cols-1 grid-2-cols-480 sm:grid-cols-2 gap-1.5 sm:gap-3 justify-items-stretch w-full max-w-none" };
const _hoisted_15$e = ["onClick", "disabled"];
const _hoisted_16$e = { class: "inline-flex items-center justify-center w-5 h-5 rounded-full text-xs font-semibold bg-gray-200 text-gray-700 dark:bg-white/10 dark:text-white/80 shrink-0" };
const _hoisted_17$e = { class: "truncate overflow-hidden min-w-0" };
const _hoisted_18$d = {
  key: 0,
  class: "mt-4 text-center"
};
const _hoisted_19$d = {
  key: 0,
  class: "text-green-600 dark:text-green-400 font-medium"
};
const _hoisted_20$d = {
  key: 1,
  class: "text-red-600 dark:text-red-400 font-medium"
};
const _hoisted_21$d = { class: "text-sm text-gray-500 dark:text-gray-400 mt-2" };
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "ListeningMode",
  props: {
    card: {},
    listeningAnswer: {},
    listeningAnswered: { type: Boolean },
    listeningCorrect: { type: Boolean },
    listeningQuizEnabled: { type: Boolean },
    listeningQuizOptions: {},
    listeningQuizSelected: {},
    listeningQuizAnswered: { type: Boolean },
    getTopicName: { type: Function }
  },
  emits: ["update:listeningAnswer", "check-answer", "play-audio", "select-listening-quiz-answer"],
  setup(__props, { emit: __emit }) {
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const props = __props;
    const emit = __emit;
    const stripDiacritics = (s) => s.replace(/[]/g, "w").replace(/[]/g, "W").normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(//g, "d").replace(//g, "D");
    const listeningInput = ref(null);
    const focusListeningInput = async () => {
      await nextTick();
      try {
        listeningInput.value?.focus({ preventScroll: true });
      } catch {
        listeningInput.value?.focus();
      }
    };
    const ensureListeningFocus = () => {
      if (!props.listeningQuizEnabled && !props.listeningAnswered) {
        if (document.activeElement !== listeningInput.value) {
          focusListeningInput();
        }
      }
    };
    const onListeningBlur = () => {
      ensureListeningFocus();
    };
    const onInput = (event) => {
      const el = event.target;
      const sanitized = stripDiacritics(el.value);
      if (sanitized !== el.value) {
        el.value = sanitized;
      }
      emit("update:listeningAnswer", sanitized);
    };
    onMounted(() => {
      ensureListeningFocus();
    });
    const handleCheckAnswer = () => {
      if (props.listeningAnswered) return;
      emit("check-answer");
      setTimeout(() => {
        isCorrectAnswer.value = props.listeningCorrect;
        triggerFirework.value = true;
        triggerSound.value = true;
      }, 100);
    };
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    watch(() => props.listeningAnswered, (newValue) => {
      if (newValue && !triggerFirework.value) {
        isCorrectAnswer.value = props.listeningCorrect;
        setTimeout(() => {
          triggerFirework.value = true;
          triggerSound.value = true;
        }, 50);
      }
    });
    watch(() => props.listeningAnswered, (answered) => {
      if (!answered) ensureListeningFocus();
    });
    watch(() => props.card, () => {
      ensureListeningFocus();
    });
    watch(() => props.listeningQuizEnabled, (val) => {
      if (!val) ensureListeningFocus();
    });
    const { t } = useI18n();
    const onSelectListeningOption = (opt) => {
      if (!props.listeningQuizAnswered) {
        emit("select-listening-quiz-answer", opt);
      }
    };
    const isOptionSelected = (opt) => props.listeningQuizSelected === opt;
    const isOptionCorrect = (opt) => props.card ? opt.trim().toLowerCase() === props.card.word.trim().toLowerCase() : false;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 p-6 sm:p-8 h-auto sm:h-96 select-none",
        onCopy: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[3] || (_cache[3] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createBaseVNode("div", _hoisted_1$r, [
          createBaseVNode("div", _hoisted_2$o, [
            createBaseVNode("span", _hoisted_3$n, toDisplayString$1(_ctx.card?.category ? _ctx.getTopicName(_ctx.card.category) : ""), 1)
          ]),
          createBaseVNode("div", _hoisted_4$l, [
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => emit("play-audio")),
              class: "bg-blue-500 hover:bg-blue-600 text-white p-6 rounded-full transition-colors"
            }, _cache[4] || (_cache[4] = [
              createBaseVNode("svg", {
                class: "w-8 h-8",
                fill: "currentColor",
                viewBox: "0 0 20 20"
              }, [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.816L4.846 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.846l3.537-3.816a1 1 0 011.617.816zM16 8a2 2 0 11-4 0 2 2 0 014 0zm-2 6a4 4 0 100-8 4 4 0 000 8z",
                  "clip-rule": "evenodd"
                })
              ], -1)
            ]))
          ]),
          !_ctx.listeningQuizEnabled ? (openBlock(), createElementBlock("p", _hoisted_5$j, toDisplayString$1(unref(t)("flashcard.listening.instruction", "Listen and type the word you hear:")), 1)) : (openBlock(), createElementBlock("p", _hoisted_6$i, toDisplayString$1(unref(t)("flashcard.listening.instructionQuiz", "Choose the word you hear:")), 1)),
          !_ctx.listeningQuizEnabled ? (openBlock(), createElementBlock("div", _hoisted_7$h, [
            createBaseVNode("input", {
              ref_key: "listeningInput",
              ref: listeningInput,
              value: _ctx.listeningAnswer,
              onInput,
              onKeyup: withKeys(handleCheckAnswer, ["enter"]),
              type: "text",
              disabled: _ctx.listeningAnswered,
              class: "w-full p-4 text-center text-lg sm:text-xl md:text-2xl border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 select-text",
              placeholder: unref(t)("flashcard.listening.placeholder", "Type the word you hear..."),
              inputmode: "text",
              autocapitalize: "none",
              autocomplete: "off",
              spellcheck: "false",
              onBlur: onListeningBlur
            }, null, 40, _hoisted_8$h),
            _ctx.listeningAnswered ? (openBlock(), createElementBlock("div", _hoisted_9$h, [
              _ctx.listeningCorrect ? (openBlock(), createElementBlock("p", _hoisted_10$g, toDisplayString$1(unref(t)("flashcard.listening.correct", " Correct!")), 1)) : (openBlock(), createElementBlock("p", _hoisted_11$g, toDisplayString$1(unref(t)("flashcard.listening.incorrect", " Correct answer:")) + " " + toDisplayString$1(_ctx.card?.word), 1)),
              createBaseVNode("p", _hoisted_12$g, toDisplayString$1(_ctx.card?.meaning), 1)
            ])) : createCommentVNode("", true)
          ])) : (openBlock(), createElementBlock("div", _hoisted_13$g, [
            createBaseVNode("div", _hoisted_14$g, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.listeningQuizOptions, (opt, idx) => {
                return openBlock(), createElementBlock("button", {
                  key: idx,
                  onClick: ($event) => onSelectListeningOption(opt),
                  disabled: _ctx.listeningQuizAnswered,
                  translate: "no",
                  class: normalizeClass(["notranslate px-3 py-1.5 sm:py-2 rounded-md border text-[13px] sm:text-sm transition-all duration-150 disabled:opacity-70 disabled:cursor-not-allowed text-left flex items-center gap-2 w-full min-w-0", [
                    _ctx.listeningQuizAnswered ? isOptionCorrect(opt) ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300 border-green-300 dark:border-green-700" : isOptionSelected(opt) ? "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-300 border-red-300 dark:border-red-700" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60" : "bg-white dark:bg-gray-custom text-gray-900 dark:text-white border-gray-300 dark:border-gray-custom/60 hover:shadow-sm hover:scale-[1.01] dark:hover:bg-white/5"
                  ]])
                }, [
                  createBaseVNode("span", _hoisted_16$e, toDisplayString$1(String.fromCharCode(65 + idx)), 1),
                  createBaseVNode("span", _hoisted_17$e, toDisplayString$1(opt), 1)
                ], 10, _hoisted_15$e);
              }), 128))
            ]),
            _ctx.listeningAnswered ? (openBlock(), createElementBlock("div", _hoisted_18$d, [
              _ctx.listeningCorrect ? (openBlock(), createElementBlock("p", _hoisted_19$d, toDisplayString$1(unref(t)("flashcard.listening.correct", " Correct!")), 1)) : (openBlock(), createElementBlock("p", _hoisted_20$d, toDisplayString$1(unref(t)("flashcard.listening.incorrect", " Correct answer:")) + " " + toDisplayString$1(_ctx.card?.word), 1)),
              createBaseVNode("p", _hoisted_21$d, toDisplayString$1(_ctx.card?.meaning), 1)
            ])) : createCommentVNode("", true)
          ]))
        ]),
        createVNode(unref(FireworkSoundEffect), {
          ref_key: "fireworkEffect",
          ref: fireworkEffect,
          "trigger-firework": triggerFirework.value,
          "trigger-sound": triggerSound.value,
          "is-correct": isCorrectAnswer.value,
          onEffectComplete: resetTriggers
        }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
      ], 32);
    };
  }
});

const ListeningMode = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__scopeId", "data-v-849d04c0"]]);

const ListeningMode$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: ListeningMode
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$q = {
  key: 0,
  class: "grid grid-cols-3 gap-4 mt-8"
};
const _hoisted_2$n = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg p-4 text-center shadow border border-gray-200 dark:border-gray-800" };
const _hoisted_3$m = { class: "text-2xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_4$k = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_5$i = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg p-4 text-center shadow border border-gray-200 dark:border-gray-800" };
const _hoisted_6$h = { class: "text-2xl font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_7$g = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_8$g = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg p-4 text-center shadow border border-gray-200 dark:border-gray-800" };
const _hoisted_9$g = { class: "text-2xl font-bold text-red-600 dark:text-red-400" };
const _hoisted_10$f = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_11$f = {
  key: 1,
  class: "grid grid-cols-2 gap-4 mt-8"
};
const _hoisted_12$f = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg p-4 text-center shadow border border-gray-200 dark:border-gray-800" };
const _hoisted_13$f = { class: "text-2xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_14$f = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _hoisted_15$d = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg p-4 text-center shadow border border-gray-200 dark:border-gray-800" };
const _hoisted_16$d = { class: "text-2xl font-bold text-red-600 dark:text-red-400" };
const _hoisted_17$d = { class: "text-sm text-gray-600 dark:text-gray-300" };
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "PracticeStats",
  props: {
    stats: {},
    mode: {}
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return _ctx.mode === "flashcard" ? (openBlock(), createElementBlock("div", _hoisted_1$q, [
        createBaseVNode("div", _hoisted_2$n, [
          createBaseVNode("p", _hoisted_3$m, toDisplayString$1(_ctx.stats.easy), 1),
          createBaseVNode("p", _hoisted_4$k, toDisplayString$1(unref(t)("common.easy", "Easy")), 1)
        ]),
        createBaseVNode("div", _hoisted_5$i, [
          createBaseVNode("p", _hoisted_6$h, toDisplayString$1(_ctx.stats.reviewed), 1),
          createBaseVNode("p", _hoisted_7$g, toDisplayString$1(unref(t)("common.reviewed", "Reviewed")), 1)
        ]),
        createBaseVNode("div", _hoisted_8$g, [
          createBaseVNode("p", _hoisted_9$g, toDisplayString$1(_ctx.stats.difficult), 1),
          createBaseVNode("p", _hoisted_10$f, toDisplayString$1(unref(t)("common.difficult", "Difficult")), 1)
        ])
      ])) : (openBlock(), createElementBlock("div", _hoisted_11$f, [
        createBaseVNode("div", _hoisted_12$f, [
          createBaseVNode("p", _hoisted_13$f, toDisplayString$1(_ctx.stats.correct), 1),
          createBaseVNode("p", _hoisted_14$f, toDisplayString$1(unref(t)("common.correct", "Correct")), 1)
        ]),
        createBaseVNode("div", _hoisted_15$d, [
          createBaseVNode("p", _hoisted_16$d, toDisplayString$1(_ctx.stats.incorrect), 1),
          createBaseVNode("p", _hoisted_17$d, toDisplayString$1(unref(t)("common.incorrect", "Incorrect")), 1)
        ])
      ]));
    };
  }
});

const PracticeStats = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$q
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$p = { class: "text-center py-12" };
const _hoisted_2$m = { class: "mt-2 text-sm font-medium text-gray-900 dark:text-white" };
const _hoisted_3$l = { class: "mt-1 text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_4$j = { class: "mt-6" };
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "FlashcardEmptyState",
  emits: ["go-to-vocabulary"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$p, [
        _cache[1] || (_cache[1] = createBaseVNode("svg", {
          class: "mx-auto h-12 w-12 text-gray-400 dark:text-gray-500",
          fill: "none",
          viewBox: "0 0 24 24",
          stroke: "currentColor"
        }, [
          createBaseVNode("path", {
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            "stroke-width": "2",
            d: "M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"
          })
        ], -1)),
        createBaseVNode("h3", _hoisted_2$m, toDisplayString$1(unref(t)("flashcard.empty.title", "No flashcards to practice")), 1),
        createBaseVNode("p", _hoisted_3$l, toDisplayString$1(unref(t)("flashcard.empty.description", "Add some words to your vocabulary to get started.")), 1),
        createBaseVNode("div", _hoisted_4$j, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => emit("go-to-vocabulary")),
            class: "inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700"
          }, toDisplayString$1(unref(t)("flashcard.empty.action", "Add Vocabulary")), 1)
        ])
      ]);
    };
  }
});

const FlashcardEmptyState = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$p
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$o = { class: "h-full flex flex-col overflow-hidden" };
const _hoisted_2$l = { class: "mb-4 flex items-center justify-center gap-3" };
const _hoisted_3$k = { class: "px-3 py-1 bg-purple-100 dark:bg-dark-bg-mute text-purple-800 dark:text-purple-300 text-sm font-medium rounded-full" };
const _hoisted_4$i = { class: "flex items-center gap-2" };
const _hoisted_5$h = { class: "text-xs text-gray-600 dark:text-white/70" };
const _hoisted_6$g = ["aria-pressed", "title"];
const _hoisted_7$f = { class: "flex-1 flex items-center justify-center mb-4 min-h-0" };
const _hoisted_8$f = {
  key: 0,
  class: "flex items-center justify-center bg-gradient-to-br from-teal-50 to-cyan-50 dark:from-teal-900/30 dark:to-cyan-900/30 rounded-xl p-6 w-full max-w-lg border border-teal-200 dark:border-teal-700/50 shadow-sm"
};
const _hoisted_9$f = { class: "text-center space-y-3" };
const _hoisted_10$e = { class: "max-h-32 overflow-y-auto" };
const _hoisted_11$e = { class: "text-lg font-medium text-gray-900 dark:text-white leading-relaxed" };
const _hoisted_12$e = { class: "text-sm text-teal-600 dark:text-teal-400 font-medium" };
const _hoisted_13$e = {
  key: 0,
  class: "relative"
};
const _hoisted_14$e = ["src", "alt"];
const _hoisted_15$c = {
  key: 0,
  class: "absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-dark-bg-mute rounded-lg"
};
const _hoisted_16$c = { class: "text-center" };
const _hoisted_17$c = { class: "text-sm text-gray-500 dark:text-white/60 mt-2" };
const _hoisted_18$c = {
  key: 1,
  class: "flex items-center justify-center bg-gray-100 dark:bg-dark-bg-mute rounded-lg p-8 w-full max-w-sm"
};
const _hoisted_19$c = { class: "text-center" };
const _hoisted_20$c = { class: "text-sm text-gray-500 dark:text-white/60 mt-2" };
const _hoisted_21$c = { class: "flex-shrink-0" };
const _hoisted_22$b = { class: "flex flex-wrap gap-2 justify-center items-center" };
const _hoisted_23$b = {
  key: 0,
  class: "px-1 text-lg text-gray-700 dark:text-white/80 select-none"
};
const _hoisted_24$a = ["onClick", "onDragover", "onDrop"];
const _hoisted_25$a = {
  key: 0,
  class: "uppercase tracking-wider"
};
const _hoisted_26$9 = {
  key: 1,
  class: "caret-block",
  "aria-hidden": "true"
};
const _hoisted_27$9 = {
  key: 2,
  class: "uppercase tracking-wider"
};
const _hoisted_28$9 = {
  key: 0,
  class: "mt-3"
};
const _hoisted_29$8 = { class: "mb-2 flex justify-center" };
const _hoisted_30$7 = { class: "relative w-48 sm:w-56" };
const _hoisted_31$7 = ["placeholder"];
const _hoisted_32$6 = ["aria-label", "title"];
const _hoisted_33$6 = { class: "flex flex-wrap gap-2 justify-center" };
const _hoisted_34$6 = ["onDragstart"];
const _hoisted_35$6 = {
  key: 0,
  class: "text-center space-y-2 max-h-32 overflow-y-auto mt-3"
};
const _hoisted_36$5 = {
  key: 0,
  class: "w-4 h-4 mr-1",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_37$4 = {
  key: 1,
  class: "w-4 h-4 mr-1",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_38$4 = {
  key: 0,
  class: "text-center"
};
const _hoisted_39$3 = { class: "text-sm text-gray-600 dark:text-white/70" };
const _hoisted_40$3 = { class: "font-semibold text-gray-900 dark:text-white" };
const _hoisted_41$2 = { class: "text-xs text-gray-500 dark:text-white/60 mt-1 line-clamp-2" };
const _hoisted_42$2 = {
  key: 1,
  class: "text-center"
};
const _hoisted_43$2 = { class: "text-sm text-gray-600 dark:text-white/70 line-clamp-2" };
const _hoisted_44$2 = {
  key: 1,
  class: "text-center text-sm text-gray-500 dark:text-white/60 mt-3"
};
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "PictionaryMode",
  props: {
    card: {},
    pictionaryAnswer: {},
    pictionaryAnswered: { type: Boolean },
    pictionaryCorrect: { type: Boolean },
    definitionMode: { type: Boolean },
    getTopicName: { type: Function }
  },
  emits: ["update:pictionary-answer", "check-answer", "pictionary-snapshot"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const { playAudio } = useVoiceStore();
    const imageError = ref(false);
    const hiddenInput = ref(null);
    const isFocused = ref(false);
    const isComposing = ref(false);
    const dragMode = ref(false);
    const letterBank = Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
    const letterQuery = ref("");
    const filteredLetterBank = computed(() => {
      const q = letterQuery.value.trim().toUpperCase();
      if (!q) return letterBank;
      const onlyLetters = q.replace(/[^A-Z]/g, "");
      if (!onlyLetters) return letterBank;
      const set = new Set(onlyLetters.split(""));
      return letterBank.filter((ch) => set.has(ch));
    });
    const clearLetterQuery = () => {
      letterQuery.value = "";
    };
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const slots = ref([]);
    const normalizeWord = (w) => w.normalize("NFKC");
    const buildSlots = (word) => {
      const letters = normalizeWord(word);
      const arr = [];
      const isAlpha = (c) => /^[a-z]$/i.test(c);
      const meaningfulIndices = [];
      for (let i = 0; i < letters.length; i++) {
        const c = letters[i];
        if (isAlpha(c)) {
          meaningfulIndices.push(i);
        }
      }
      const alphaCount = meaningfulIndices.length;
      const hintCount = alphaCount <= 3 ? 1 : 2;
      const hintSet = /* @__PURE__ */ new Set();
      while (hintSet.size < Math.min(hintCount, alphaCount)) {
        const r = meaningfulIndices[Math.floor(Math.random() * alphaCount)];
        hintSet.add(r);
      }
      for (let i = 0; i < letters.length; i++) {
        const c = letters[i];
        if (!isAlpha(c)) {
          arr.push({ char: c, fixed: true, separator: true });
          continue;
        }
        if (hintSet.has(i)) {
          arr.push({ char: c.toUpperCase(), fixed: true });
        } else {
          arr.push({ char: "", fixed: false });
        }
      }
      slots.value = arr;
      pushAnswer();
    };
    const pushAnswer = () => {
      const answer = slots.value.map((s) => s.separator ? s.char : s.char || "").join("");
      emit("update:pictionary-answer", answer);
    };
    const emitSnapshot = () => {
      const snapshot = slots.value.map((s) => ({ char: s.char, fixed: s.fixed, separator: s.separator }));
      emit("pictionary-snapshot", { slots: snapshot });
    };
    const focusInput = async () => {
      await nextTick();
      try {
        hiddenInput.value?.focus({ preventScroll: true });
      } catch {
        hiddenInput.value?.focus();
      }
      isFocused.value = true;
    };
    const ensureFocusIfNeeded = () => {
      if (!props.pictionaryAnswered && !dragMode.value) {
        if (document.activeElement !== hiddenInput.value) {
          focusInput();
        }
      }
    };
    const onHiddenBlur = () => {
      isFocused.value = false;
      ensureFocusIfNeeded();
    };
    const nextEditableIndex = () => slots.value.findIndex((s) => !s.fixed && !s.char);
    const lastFilledEditableIndex = () => {
      for (let i = slots.value.length - 1; i >= 0; i--) {
        const s = slots.value[i];
        if (!s.fixed && s.char) return i;
      }
      return -1;
    };
    const stripDiacritics = (s) => s.replace(/[]/g, "w").replace(/[]/g, "W").normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(//g, "d").replace(//g, "D");
    const handleKeydown = (e) => {
      if (props.pictionaryAnswered) return;
      if (isComposing.value) return;
      const key = e.key;
      if (dragMode.value) {
        if (key === "Enter") {
          emitSnapshot();
          emit("check-answer");
        }
        return;
      }
      const alpha = stripDiacritics(key);
      if (/^[a-z]$/i.test(alpha)) {
        const idx = nextEditableIndex();
        if (idx !== -1) {
          slots.value[idx].char = alpha.toUpperCase();
          pushAnswer();
        }
        return;
      }
      if (key === "Backspace") {
        const idx = lastFilledEditableIndex();
        if (idx !== -1) {
          slots.value[idx].char = "";
          pushAnswer();
        }
      } else if (key === "Enter") {
        emitSnapshot();
        emit("check-answer");
      }
    };
    const handleBeforeInput = (e) => {
      if (props.pictionaryAnswered) return;
      if (isComposing.value) {
        return;
      }
      if (dragMode.value) {
        if (hiddenInput.value) hiddenInput.value.value = "";
        return;
      }
      const ie = e;
      const type = ie.inputType;
      if (type === "insertText") {
        const data = stripDiacritics(ie.data || "");
        if (/^[a-z]$/i.test(data)) {
          const idx = nextEditableIndex();
          if (idx !== -1) {
            slots.value[idx].char = data.toUpperCase();
            pushAnswer();
          }
        }
      } else if (type === "deleteContentBackward") {
        const idx = lastFilledEditableIndex();
        if (idx !== -1) {
          slots.value[idx].char = "";
          pushAnswer();
        }
      } else if (type === "insertLineBreak") {
        emitSnapshot();
        emit("check-answer");
      }
      if (hiddenInput.value) hiddenInput.value.value = "";
    };
    const handleInput = (e) => {
      if (isComposing.value) return;
      if (hiddenInput.value) hiddenInput.value.value = "";
    };
    const onCompositionStart = () => {
      isComposing.value = true;
    };
    const onCompositionUpdate = (e) => {
      const data = (e.data || "").toString();
      stripDiacritics(data);
    };
    const onCompositionEnd = (e) => {
      const dataRaw = (e.data || hiddenInput.value?.value || "").toString();
      const finalized = stripDiacritics(dataRaw).toUpperCase();
      for (const ch of finalized) {
        if (!/^[A-Z]$/.test(ch)) continue;
        const idx = nextEditableIndex();
        if (idx === -1) break;
        slots.value[idx].char = ch;
      }
      pushAnswer();
      if (hiddenInput.value) hiddenInput.value.value = "";
      isComposing.value = false;
    };
    const allEditableFilled = () => {
      return slots.value.every((s) => s.fixed || s.separator || !!s.char);
    };
    const maybeAutoCheck = () => {
      if (dragMode.value && !props.pictionaryAnswered && allEditableFilled()) {
        emitSnapshot();
        emit("check-answer");
      }
    };
    watch(() => props.card, (c) => {
      imageError.value = false;
      if (c?.word) buildSlots(c.word);
      ensureFocusIfNeeded();
    });
    onMounted(() => {
      if (props.card?.word) buildSlots(props.card.word);
      focusInput();
      document.addEventListener("visibilitychange", ensureFocusIfNeeded);
    });
    onBeforeUnmount(() => {
      document.removeEventListener("visibilitychange", ensureFocusIfNeeded);
    });
    const handleImageError = () => {
      imageError.value = true;
    };
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    watch(() => props.pictionaryAnswered, (newVal) => {
      if (newVal && !triggerFirework.value) {
        isCorrectAnswer.value = props.pictionaryCorrect;
        setTimeout(() => {
          triggerFirework.value = true;
          triggerSound.value = true;
        }, 50);
      }
      if (newVal && props.pictionaryCorrect && props.card?.word) {
        Promise.resolve(playAudio(props.card.word)).catch(() => {
        });
      }
      if (newVal) {
        isFocused.value = false;
      }
      if (!newVal) {
        ensureFocusIfNeeded();
      }
    });
    const toggleDragMode = () => {
      dragMode.value = !dragMode.value;
      if (!dragMode.value) {
        focusInput();
      } else {
        isFocused.value = false;
      }
    };
    const onLetterDragStart = (ch, ev) => {
      ev.dataTransfer?.setData("text/plain", ch);
      ev.dataTransfer?.setDragImage?.(createDragImage(ch), 12, 12);
    };
    const onSlotDragOver = (idx, _ev) => {
      const s = slots.value[idx];
      if (!s || s.fixed || s.separator) return;
    };
    const onSlotDrop = (idx, ev) => {
      const s = slots.value[idx];
      if (!s || s.fixed || s.separator) return;
      const ch = (ev.dataTransfer?.getData("text/plain") || "").toUpperCase();
      if (/^[A-Z]$/.test(ch)) {
        s.char = ch;
        pushAnswer();
        clearLetterQuery();
        maybeAutoCheck();
      }
    };
    const onSlotClick = (idx) => {
      const s = slots.value[idx];
      if (!s || s.separator || s.fixed) return;
      if (dragMode.value) {
        if (s.char) {
          s.char = "";
          pushAnswer();
        }
      } else {
        focusInput();
      }
    };
    const createDragImage = (ch) => {
      const el = document.createElement("div");
      el.textContent = ch;
      el.style.position = "absolute";
      el.style.top = "-1000px";
      el.style.left = "-1000px";
      el.style.padding = "6px 8px";
      el.style.fontWeight = "700";
      el.style.fontSize = "16px";
      el.style.borderRadius = "8px";
      el.style.background = "rgba(37,99,235,0.15)";
      el.style.color = "#1D4ED8";
      el.style.border = "1px solid rgba(37,99,235,0.35)";
      document.body.appendChild(el);
      setTimeout(() => document.body.removeChild(el), 0);
      return el;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-black rounded-xl shadow-2xl border border-gray-200 dark:border-dark-bg-mute p-6 min-h-96 max-h-[560px] select-none",
        onCopy: _cache[3] || (_cache[3] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[4] || (_cache[4] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[5] || (_cache[5] = withModifiers(() => {
        }, ["prevent"])),
        onClick: focusInput
      }, [
        createBaseVNode("div", _hoisted_1$o, [
          createBaseVNode("div", _hoisted_2$l, [
            createBaseVNode("span", _hoisted_3$k, toDisplayString$1(_ctx.card?.category ? _ctx.getTopicName(_ctx.card.category) : ""), 1),
            createBaseVNode("div", _hoisted_4$i, [
              createBaseVNode("span", _hoisted_5$h, toDisplayString$1(unref(t)("flashcard.pictionary.dragToggle", "Drag & Drop")), 1),
              createBaseVNode("button", {
                class: normalizeClass(["relative inline-flex h-5 w-9 items-center rounded-full transition-colors border border-gray-300 dark:border-dark-bg-mute", dragMode.value ? "bg-blue-600" : "bg-gray-200 dark:bg-dark-bg-soft"]),
                onClick: withModifiers(toggleDragMode, ["stop"]),
                "aria-pressed": dragMode.value ? "true" : "false",
                title: unref(t)("flashcard.pictionary.dragToggle", "Drag & Drop")
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(["inline-block h-4 w-4 transform rounded-full bg-white transition-transform", dragMode.value ? "translate-x-5" : "translate-x-1"])
                }, null, 2)
              ], 10, _hoisted_6$g)
            ])
          ]),
          createBaseVNode("div", _hoisted_7$f, [
            props.definitionMode ? (openBlock(), createElementBlock("div", _hoisted_8$f, [
              createBaseVNode("div", _hoisted_9$f, [
                _cache[6] || (_cache[6] = createBaseVNode("div", { class: "mx-auto w-12 h-12 bg-teal-100 dark:bg-teal-800/50 rounded-full flex items-center justify-center mb-4" }, [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 text-teal-600 dark:text-teal-400",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    stroke: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                    })
                  ])
                ], -1)),
                createBaseVNode("div", _hoisted_10$e, [
                  createBaseVNode("p", _hoisted_11$e, toDisplayString$1(_ctx.card?.meaning || unref(t)("flashcard.pictionary.noDefinition", "No definition available")), 1)
                ]),
                createBaseVNode("p", _hoisted_12$e, toDisplayString$1(unref(t)("flashcard.pictionary.definitionHint", "Guess the word from this definition")), 1)
              ])
            ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              _ctx.card?.image ? (openBlock(), createElementBlock("div", _hoisted_13$e, [
                createBaseVNode("img", {
                  src: _ctx.card.image,
                  alt: unref(t)("flashcard.pictionary.imageAlt", "Pictionary image"),
                  class: "max-w-full max-h-40 object-contain rounded-lg shadow-md border border-gray-200 dark:border-dark-bg-mute",
                  onError: handleImageError
                }, null, 40, _hoisted_14$e),
                imageError.value ? (openBlock(), createElementBlock("div", _hoisted_15$c, [
                  createBaseVNode("div", _hoisted_16$c, [
                    _cache[7] || (_cache[7] = createBaseVNode("svg", {
                      class: "mx-auto h-12 w-12 text-gray-400 dark:text-white/50",
                      fill: "none",
                      viewBox: "0 0 24 24",
                      stroke: "currentColor"
                    }, [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 16m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                      })
                    ], -1)),
                    createBaseVNode("p", _hoisted_17$c, toDisplayString$1(unref(t)("flashcard.image.imageError", "Could not load image.")), 1)
                  ])
                ])) : createCommentVNode("", true)
              ])) : (openBlock(), createElementBlock("div", _hoisted_18$c, [
                createBaseVNode("div", _hoisted_19$c, [
                  _cache[8] || (_cache[8] = createBaseVNode("svg", {
                    class: "mx-auto h-16 w-16 text-gray-400 dark:text-white/50",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    stroke: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 16m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                    })
                  ], -1)),
                  createBaseVNode("p", _hoisted_20$c, toDisplayString$1(unref(t)("flashcard.image.noImage", "No image available for this card.")), 1)
                ])
              ]))
            ], 64))
          ]),
          createBaseVNode("div", _hoisted_21$c, [
            createBaseVNode("div", _hoisted_22$b, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(slots.value, (slot, idx) => {
                return openBlock(), createElementBlock("div", { key: idx }, [
                  slot.separator ? (openBlock(), createElementBlock("div", _hoisted_23$b, toDisplayString$1(slot.char), 1)) : (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(["w-10 h-12 sm:w-12 sm:h-14 flex items-center justify-center rounded-md border text-xl sm:text-2xl font-semibold bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white border-gray-300 dark:border-dark-bg-mute transition-all duration-200", [
                      slot.fixed ? "opacity-90" : "cursor-pointer hover:bg-gray-50 dark:hover:bg-dark-bg-mute hover:border-blue-300 dark:hover:border-blue-600 hover:shadow-sm",
                      dragMode.value && !slot.fixed ? "ring-0" : ""
                    ]]),
                    onClick: ($event) => onSlotClick(idx),
                    onDragover: withModifiers(($event) => onSlotDragOver(idx), ["prevent"]),
                    onDrop: withModifiers(($event) => onSlotDrop(idx, $event), ["prevent"])
                  }, [
                    slot.char ? (openBlock(), createElementBlock("span", _hoisted_25$a, toDisplayString$1(slot.char), 1)) : !dragMode.value && isFocused.value && !_ctx.pictionaryAnswered && idx === nextEditableIndex() ? (openBlock(), createElementBlock("span", _hoisted_26$9)) : (openBlock(), createElementBlock("span", _hoisted_27$9, ""))
                  ], 42, _hoisted_24$a))
                ]);
              }), 128))
            ]),
            dragMode.value && !_ctx.pictionaryAnswered ? (openBlock(), createElementBlock("div", _hoisted_28$9, [
              createBaseVNode("div", _hoisted_29$8, [
                createBaseVNode("div", _hoisted_30$7, [
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => letterQuery.value = $event),
                    type: "text",
                    inputmode: "text",
                    autocomplete: "off",
                    spellcheck: "false",
                    placeholder: unref(t)("common.search", "Search"),
                    class: "w-full px-3 pr-8 py-1.5 text-sm rounded-md border bg-white text-gray-900 border-gray-300 dark:bg-dark-bg-soft dark:text-white dark:border-dark-bg-mute focus:outline-none focus:ring-2 focus:ring-blue-500",
                    onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                    }, ["stop"]))
                  }, null, 8, _hoisted_31$7), [
                    [vModelText, letterQuery.value]
                  ]),
                  createBaseVNode("button", {
                    type: "button",
                    class: normalizeClass(["absolute right-1.5 top-1/2 -translate-y-1/2 z-10 p-1 rounded text-gray-500 dark:text-white/70 hover:bg-gray-100 dark:hover:bg-white/10", { "opacity-40 pointer-events-none": !letterQuery.value }]),
                    onClick: withModifiers(clearLetterQuery, ["stop"]),
                    "aria-label": unref(t)("common.clear", "Clear"),
                    title: unref(t)("common.clear", "Clear")
                  }, _cache[9] || (_cache[9] = [
                    createBaseVNode("svg", {
                      class: "w-4 h-4",
                      viewBox: "0 0 20 20",
                      fill: "currentColor",
                      "aria-hidden": "true"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)
                  ]), 10, _hoisted_32$6)
                ])
              ]),
              createBaseVNode("div", _hoisted_33$6, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(filteredLetterBank.value, (ch) => {
                  return openBlock(), createElementBlock("button", {
                    key: ch,
                    class: "w-8 h-10 sm:w-9 sm:h-11 inline-flex items-center justify-center rounded-md text-base sm:text-lg font-semibold border bg-blue-50 text-blue-700 border-blue-200 dark:bg-dark-bg-soft dark:text-blue-300 dark:border-blue-900/40 hover:shadow transition",
                    draggable: "true",
                    onDragstart: ($event) => onLetterDragStart(ch, $event)
                  }, toDisplayString$1(ch), 41, _hoisted_34$6);
                }), 128))
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("input", {
              ref_key: "hiddenInput",
              ref: hiddenInput,
              type: "text",
              class: "fixed top-0 left-0 w-px h-px opacity-0",
              tabindex: "-1",
              "aria-hidden": "true",
              autocomplete: "off",
              autocapitalize: "off",
              spellcheck: "false",
              inputmode: "text",
              onBeforeinput: withModifiers(handleBeforeInput, ["stop", "prevent"]),
              onInput: withModifiers(handleInput, ["stop", "prevent"]),
              onKeydown: withModifiers(handleKeydown, ["stop", "prevent"]),
              onCompositionstart: onCompositionStart,
              onCompositionupdate: onCompositionUpdate,
              onCompositionend: onCompositionEnd,
              onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
              onBlur: onHiddenBlur
            }, null, 544)
          ]),
          _ctx.pictionaryAnswered ? (openBlock(), createElementBlock("div", _hoisted_35$6, [
            createBaseVNode("div", {
              class: normalizeClass([
                "inline-flex items-center px-3 py-1 rounded-full text-sm font-medium",
                _ctx.pictionaryCorrect ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300" : "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-300"
              ])
            }, [
              _ctx.pictionaryCorrect ? (openBlock(), createElementBlock("svg", _hoisted_36$5, _cache[10] || (_cache[10] = [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                  "clip-rule": "evenodd"
                }, null, -1)
              ]))) : (openBlock(), createElementBlock("svg", _hoisted_37$4, _cache[11] || (_cache[11] = [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 0 1 1.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 0 1 0-1.414z",
                  "clip-rule": "evenodd"
                }, null, -1)
              ]))),
              createTextVNode(" " + toDisplayString$1(_ctx.pictionaryCorrect ? unref(t)("common.correct", "Correct") : unref(t)("common.incorrect", "Incorrect")), 1)
            ], 2),
            !_ctx.pictionaryCorrect ? (openBlock(), createElementBlock("div", _hoisted_38$4, [
              createBaseVNode("p", _hoisted_39$3, [
                createTextVNode(toDisplayString$1(unref(t)("flashcard.image.correctAnswer", "Correct answer")) + ": ", 1),
                createBaseVNode("span", _hoisted_40$3, toDisplayString$1(_ctx.card?.word), 1)
              ]),
              createBaseVNode("p", _hoisted_41$2, toDisplayString$1(_ctx.card?.meaning), 1)
            ])) : (openBlock(), createElementBlock("div", _hoisted_42$2, [
              createBaseVNode("p", _hoisted_43$2, toDisplayString$1(_ctx.card?.meaning), 1)
            ]))
          ])) : createCommentVNode("", true),
          !_ctx.pictionaryAnswered ? (openBlock(), createElementBlock("p", _hoisted_44$2, toDisplayString$1(props.definitionMode ? dragMode.value ? unref(t)("flashcard.pictionary.dragInstructionDefinition", "Look at the definition above, drag letters into the boxes, then press Enter to check.") : unref(t)("flashcard.pictionary.instructionDefinition", "Look at the definition above, click the boxes and type to fill in the missing letters. Press Enter to check.") : dragMode.value ? unref(t)("flashcard.pictionary.dragInstruction", "Drag letters into the boxes, then press Enter to check.") : unref(t)("flashcard.pictionary.instruction", "Click the boxes and type to fill in the missing letters. Press Enter to check.")), 1)) : createCommentVNode("", true),
          createVNode(unref(FireworkSoundEffect), {
            ref_key: "fireworkEffect",
            ref: fireworkEffect,
            "trigger-firework": triggerFirework.value,
            "trigger-sound": triggerSound.value,
            "is-correct": isCorrectAnswer.value,
            onEffectComplete: resetTriggers
          }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
        ])
      ], 32);
    };
  }
});

const PictionaryMode = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__scopeId", "data-v-66235204"]]);

const PictionaryMode$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: PictionaryMode
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$n = { class: "h-full flex flex-col overflow-hidden" };
const _hoisted_2$k = { class: "mb-4 flex items-center justify-center gap-3" };
const _hoisted_3$j = { class: "px-3 py-1 bg-purple-100 dark:bg-dark-bg-mute text-purple-800 dark:text-purple-300 text-sm font-medium rounded-full" };
const _hoisted_4$h = { class: "flex items-center gap-2" };
const _hoisted_5$g = { class: "text-xs text-gray-600 dark:text-white/70" };
const _hoisted_6$f = { class: "flex-1 flex items-center justify-center mb-4 min-h-0" };
const _hoisted_7$e = {
  key: 0,
  class: "flex items-center justify-center bg-gradient-to-br from-teal-50 to-cyan-50 dark:from-teal-900/30 dark:to-cyan-900/30 rounded-xl p-6 w-full max-w-lg border border-teal-200 dark:border-teal-700/50 shadow-sm"
};
const _hoisted_8$e = { class: "text-center space-y-3" };
const _hoisted_9$e = { class: "max-h-32 overflow-y-auto" };
const _hoisted_10$d = { class: "text-lg font-medium text-gray-900 dark:text-white leading-relaxed" };
const _hoisted_11$d = {
  key: 1,
  class: "relative"
};
const _hoisted_12$d = ["src", "alt"];
const _hoisted_13$d = {
  key: 0,
  class: "absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-dark-bg-mute rounded-lg"
};
const _hoisted_14$d = { class: "text-center" };
const _hoisted_15$b = { class: "text-sm text-gray-500 dark:text-white/60 mt-2" };
const _hoisted_16$b = {
  key: 2,
  class: "flex items-center justify-center bg-gray-100 dark:bg-dark-bg-mute rounded-lg p-8 w-full max-w-sm"
};
const _hoisted_17$b = { class: "text-center" };
const _hoisted_18$b = { class: "text-sm text-gray-500 dark:text-white/60 mt-2" };
const _hoisted_19$b = { class: "flex-shrink-0 mb-4" };
const _hoisted_20$b = { class: "w-full max-w-full overflow-x-auto" };
const _hoisted_21$b = { class: "flex flex-wrap gap-2 xs:gap-1.5 sm:gap-2 md:gap-3 justify-center items-center min-w-fit px-1" };
const _hoisted_22$a = {
  key: 0,
  class: "px-1 text-sm xs:text-base sm:text-lg text-gray-700 dark:text-white/80 select-none"
};
const _hoisted_23$a = ["onClick"];
const _hoisted_24$9 = { class: "tile-face tile-back absolute inset-0 flex items-center justify-center rounded-lg border-2 bg-white dark:bg-dark-bg-soft border-green-400 dark:border-green-500 shadow-lg text-sm xs:text-base sm:text-xl md:text-2xl font-bold text-gray-900 dark:text-white" };
const _hoisted_25$9 = {
  key: 0,
  class: "flex-shrink-0 mb-4"
};
const _hoisted_26$8 = { class: "max-w-md mx-auto" };
const _hoisted_27$8 = { class: "relative" };
const _hoisted_28$8 = ["placeholder", "disabled"];
const _hoisted_29$7 = {
  key: 1,
  class: "text-center space-y-2 max-h-32 overflow-y-auto"
};
const _hoisted_30$6 = {
  key: 0,
  class: "w-4 h-4 mr-1",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_31$6 = {
  key: 1,
  class: "w-4 h-4 mr-1",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_32$5 = {
  key: 0,
  class: "text-center"
};
const _hoisted_33$5 = { class: "text-sm text-gray-600 dark:text-white/70" };
const _hoisted_34$5 = { class: "font-semibold text-gray-900 dark:text-white" };
const _hoisted_35$5 = { class: "text-xs text-gray-500 dark:text-white/60 mt-1 line-clamp-2" };
const _hoisted_36$4 = {
  key: 1,
  class: "text-center"
};
const _hoisted_37$3 = { class: "text-sm text-gray-600 dark:text-white/70 line-clamp-2" };
const _hoisted_38$3 = {
  key: 2,
  class: "text-center text-sm text-gray-500 dark:text-white/60 mt-3"
};
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "FlipTileMode",
  props: {
    card: {},
    flipTileAnswer: {},
    flipTileAnswered: { type: Boolean },
    flipTileCorrect: { type: Boolean },
    getTopicName: { type: Function },
    useHints: { type: Boolean }
  },
  emits: ["update:flip-tile-answer", "check-answer"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const { playAudio } = useVoiceStore();
    const useHints = computed(() => props.useHints ?? true);
    const imageError = ref(false);
    const answerInput = ref(null);
    const userAnswer = ref("");
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => FireworkSoundEffect$1),true              ?void 0:void 0));
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const tiles = ref([]);
    const normalizeWord = (w) => w.normalize("NFKC");
    const buildTiles = (word) => {
      const letters = normalizeWord(word);
      const arr = [];
      const isAlpha = (c) => /^[a-z]$/i.test(c);
      for (let i = 0; i < letters.length; i++) {
        const c = letters[i];
        if (!isAlpha(c)) {
          arr.push({ char: c, flipped: true, separator: true });
          continue;
        }
        arr.push({ char: c, flipped: false });
      }
      tiles.value = arr;
    };
    const flippedCount = computed(() => {
      return tiles.value.filter((tile) => tile.flipped && !tile.separator).length;
    });
    const totalLetterTiles = computed(() => tiles.value.filter((tile) => !tile.separator).length);
    const maxFlips = computed(() => totalLetterTiles.value <= 4 ? 1 : 2);
    const canFlipMore = computed(() => flippedCount.value < maxFlips.value);
    const onTileClick = (idx) => {
      const tile = tiles.value[idx];
      if (!tile || tile.separator || tile.flipped || props.flipTileAnswered) return;
      if (canFlipMore.value) {
        tile.flipped = true;
      }
    };
    const onAnswerInput = () => {
      emit("update:flip-tile-answer", userAnswer.value);
    };
    const checkAnswer = () => {
      if (!userAnswer.value.trim()) return;
      emit("check-answer");
    };
    const handleImageError = () => {
      imageError.value = true;
    };
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    watch(() => props.flipTileAnswered, (newVal) => {
      if (newVal) {
        tiles.value.forEach((tile) => {
          if (!tile.separator) tile.flipped = true;
        });
        if (!triggerFirework.value) {
          isCorrectAnswer.value = props.flipTileCorrect;
          setTimeout(() => {
            triggerFirework.value = true;
            triggerSound.value = true;
          }, 50);
        }
      }
      if (newVal && props.flipTileCorrect && props.card?.word) {
        Promise.resolve(playAudio(props.card.word)).catch(() => {
        });
      }
    });
    watch(() => props.card, (c) => {
      imageError.value = false;
      userAnswer.value = "";
      if (c?.word) {
        buildTiles(c.word);
      }
      nextTick(() => {
        answerInput.value?.focus();
      });
    });
    watch(() => props.flipTileAnswer, (newVal) => {
      if (newVal !== userAnswer.value) {
        userAnswer.value = newVal;
      }
    });
    onMounted(() => {
      if (props.card?.word) {
        buildTiles(props.card.word);
      }
      nextTick(() => {
        answerInput.value?.focus();
      });
    });
    const enforceInputFocus = () => {
      if (!props.flipTileAnswered) {
        setTimeout(() => {
          answerInput.value?.focus();
        }, 0);
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-dark-bg-mute p-6 min-h-96 max-h-[560px] select-none",
        onCopy: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[3] || (_cache[3] = withModifiers(() => {
        }, ["prevent"])),
        onMousedown: enforceInputFocus
      }, [
        createBaseVNode("div", _hoisted_1$n, [
          createBaseVNode("div", _hoisted_2$k, [
            createBaseVNode("span", _hoisted_3$j, toDisplayString$1(_ctx.card?.category ? _ctx.getTopicName(_ctx.card.category) : ""), 1),
            createBaseVNode("div", _hoisted_4$h, [
              createBaseVNode("span", _hoisted_5$g, toDisplayString$1(unref(t)("flashcard.flipTile.tilesFlipped", "Tiles flipped")) + ": " + toDisplayString$1(flippedCount.value) + "/" + toDisplayString$1(maxFlips.value), 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_6$f, [
            useHints.value || !_ctx.card?.image ? (openBlock(), createElementBlock("div", _hoisted_7$e, [
              createBaseVNode("div", _hoisted_8$e, [
                _cache[4] || (_cache[4] = createBaseVNode("div", { class: "mx-auto w-12 h-12 bg-teal-100 dark:bg-teal-800/50 rounded-full flex items-center justify-center mb-4" }, [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 text-teal-600 dark:text-teal-400",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    stroke: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                    })
                  ])
                ], -1)),
                createBaseVNode("div", _hoisted_9$e, [
                  createBaseVNode("p", _hoisted_10$d, toDisplayString$1(_ctx.card?.meaning || unref(t)("flashcard.flipTile.noDefinition", "No definition available")), 1)
                ])
              ])
            ])) : !useHints.value && _ctx.card?.image ? (openBlock(), createElementBlock("div", _hoisted_11$d, [
              createBaseVNode("img", {
                src: _ctx.card.image,
                alt: unref(t)("flashcard.flipTile.imageAlt", "Flip tile image"),
                class: "max-w-full max-h-40 object-contain rounded-lg shadow-md border border-gray-200 dark:border-dark-bg-mute filter blur-sm",
                onError: handleImageError
              }, null, 40, _hoisted_12$d),
              imageError.value ? (openBlock(), createElementBlock("div", _hoisted_13$d, [
                createBaseVNode("div", _hoisted_14$d, [
                  _cache[5] || (_cache[5] = createBaseVNode("svg", {
                    class: "mx-auto h-12 w-12 text-gray-400 dark:text-white/50",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    stroke: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 16m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2 2v12a2 2 0 002 2z"
                    })
                  ], -1)),
                  createBaseVNode("p", _hoisted_15$b, toDisplayString$1(unref(t)("flashcard.image.imageError", "Could not load image.")), 1)
                ])
              ])) : createCommentVNode("", true)
            ])) : (openBlock(), createElementBlock("div", _hoisted_16$b, [
              createBaseVNode("div", _hoisted_17$b, [
                _cache[6] || (_cache[6] = createBaseVNode("svg", {
                  class: "mx-auto h-16 w-16 text-gray-400 dark:text-white/50",
                  fill: "none",
                  viewBox: "0 0 24 24",
                  stroke: "currentColor"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 16m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2 2v12a2 2 0 002 2z"
                  })
                ], -1)),
                createBaseVNode("p", _hoisted_18$b, toDisplayString$1(unref(t)("flashcard.flipTile.noContent", "No content available for this card.")), 1)
              ])
            ]))
          ]),
          createBaseVNode("div", _hoisted_19$b, [
            createBaseVNode("div", _hoisted_20$b, [
              createBaseVNode("div", _hoisted_21$b, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(tiles.value, (tile, idx) => {
                  return openBlock(), createElementBlock("div", { key: idx }, [
                    tile.separator ? (openBlock(), createElementBlock("div", _hoisted_22$a, toDisplayString$1(tile.char), 1)) : (openBlock(), createElementBlock("div", {
                      key: 1,
                      class: normalizeClass(["relative w-8 h-10 xs:w-10 xs:h-12 sm:w-12 sm:h-14 md:w-14 md:h-16 transition-all duration-500 tile-3d flex-shrink-0", [{ "cursor-pointer": !tile.flipped && canFlipMore.value }, tile.flipped ? "is-flipped" : "hover:shadow-xl hover:scale-105"]]),
                      onClick: ($event) => onTileClick(idx)
                    }, [
                      _cache[7] || (_cache[7] = createBaseVNode("div", { class: "tile-face absolute inset-0 flex items-center justify-center rounded-lg border-2 bg-gradient-to-br from-blue-500 to-purple-600 dark:from-blue-600 dark:to-purple-700 border-blue-400 dark:border-blue-500 shadow-lg" }, [
                        createBaseVNode("div", { class: "text-white" }, [
                          createBaseVNode("svg", {
                            class: "w-3 h-3 xs:w-4 xs:h-4 sm:w-5 sm:h-5 md:w-6 md:h-6",
                            fill: "currentColor",
                            viewBox: "0 0 20 20"
                          }, [
                            createBaseVNode("path", {
                              "fill-rule": "evenodd",
                              d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z",
                              "clip-rule": "evenodd"
                            })
                          ])
                        ])
                      ], -1)),
                      createBaseVNode("div", _hoisted_24$9, toDisplayString$1(tile.char.toUpperCase()), 1)
                    ], 10, _hoisted_23$a))
                  ]);
                }), 128))
              ])
            ])
          ]),
          !_ctx.flipTileAnswered ? (openBlock(), createElementBlock("div", _hoisted_25$9, [
            createBaseVNode("div", _hoisted_26$8, [
              createBaseVNode("div", _hoisted_27$8, [
                withDirectives(createBaseVNode("input", {
                  ref_key: "answerInput",
                  ref: answerInput,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => userAnswer.value = $event),
                  type: "text",
                  placeholder: unref(t)("flashcard.flipTile.answerPlaceholder", "Type your answer..."),
                  class: "w-full px-4 py-3 text-lg font-medium text-center rounded-xl border-2 bg-white dark:bg-dark-bg-soft text-gray-900 dark:text-white border-gray-300 dark:border-dark-bg-mute focus:outline-none focus:border-blue-500 dark:focus:border-blue-400 focus:ring-2 focus:ring-blue-200 dark:focus:ring-blue-800/50 transition-all duration-200",
                  disabled: _ctx.flipTileAnswered,
                  onKeydown: withKeys(checkAnswer, ["enter"]),
                  onInput: onAnswerInput
                }, null, 40, _hoisted_28$8), [
                  [vModelText, userAnswer.value]
                ]),
                userAnswer.value.trim() ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  onClick: checkAnswer,
                  class: "absolute right-3 top-1/2 transform -translate-y-1/2 px-3 py-1 bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white text-sm font-medium rounded-lg transition-colors duration-200"
                }, toDisplayString$1(unref(t)("flashcard.flipTile.check", "Check")), 1)) : createCommentVNode("", true)
              ])
            ])
          ])) : createCommentVNode("", true),
          _ctx.flipTileAnswered ? (openBlock(), createElementBlock("div", _hoisted_29$7, [
            createBaseVNode("div", {
              class: normalizeClass([
                "inline-flex items-center px-3 py-1 rounded-full text-sm font-medium",
                _ctx.flipTileCorrect ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-300" : "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-300"
              ])
            }, [
              _ctx.flipTileCorrect ? (openBlock(), createElementBlock("svg", _hoisted_30$6, _cache[8] || (_cache[8] = [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                  "clip-rule": "evenodd"
                }, null, -1)
              ]))) : (openBlock(), createElementBlock("svg", _hoisted_31$6, _cache[9] || (_cache[9] = [
                createBaseVNode("path", {
                  "fill-rule": "evenodd",
                  d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                  "clip-rule": "evenodd"
                }, null, -1)
              ]))),
              createTextVNode(" " + toDisplayString$1(_ctx.flipTileCorrect ? unref(t)("common.correct", "Correct") : unref(t)("common.incorrect", "Incorrect")), 1)
            ], 2),
            !_ctx.flipTileCorrect ? (openBlock(), createElementBlock("div", _hoisted_32$5, [
              createBaseVNode("p", _hoisted_33$5, [
                createTextVNode(toDisplayString$1(unref(t)("flashcard.image.correctAnswer", "Correct answer")) + ": ", 1),
                createBaseVNode("span", _hoisted_34$5, toDisplayString$1(_ctx.card?.word), 1)
              ]),
              createBaseVNode("p", _hoisted_35$5, toDisplayString$1(_ctx.card?.meaning), 1)
            ])) : (openBlock(), createElementBlock("div", _hoisted_36$4, [
              createBaseVNode("p", _hoisted_37$3, toDisplayString$1(_ctx.card?.meaning), 1)
            ]))
          ])) : createCommentVNode("", true),
          !_ctx.flipTileAnswered ? (openBlock(), createElementBlock("p", _hoisted_38$3, toDisplayString$1(unref(t)("flashcard.flipTile.instruction", `Click on tiles to reveal letters (max ${maxFlips.value}), then type your answer and press Enter.`)), 1)) : createCommentVNode("", true),
          createVNode(unref(FireworkSoundEffect), {
            ref_key: "fireworkEffect",
            ref: fireworkEffect,
            "trigger-firework": triggerFirework.value,
            "trigger-sound": triggerSound.value,
            "is-correct": isCorrectAnswer.value,
            onEffectComplete: resetTriggers
          }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
        ])
      ], 32);
    };
  }
});

const FlipTileMode = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__scopeId", "data-v-315f8aba"]]);

const FlipTileMode$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: FlipTileMode
}, Symbol.toStringTag, { value: 'Module' }));

class GameStateManager {
  // Game State
  score = ref(0);
  wordsMatched = ref(0);
  gameOver = ref(false);
  bubbles = ref([]);
  shootingBubble = ref(null);
  currentShooterWord = ref("");
  currentShooterColor = ref("#FF6B6B");
  explosions = ref([]);
  particles = ref([]);
  screenShake = ref({ x: 0, y: 0, intensity: 0 });
  aimLine = ref({ visible: false, x: 0, y: 0 });
  shooterPosition = ref({ x: 400, y: 550 });
  rowAnimationActive = ref(false);
  // Private state for color mapping
  wordColorMap = /* @__PURE__ */ new Map();
  COLORS = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7", "#DDA0DD", "#98D8C8", "#FFB347"];
  // Game Management Methods
  resetGame() {
    this.score.value = 0;
    this.wordsMatched.value = 0;
    this.gameOver.value = false;
    this.bubbles.value = [];
    this.shootingBubble.value = null;
    this.explosions.value = [];
    this.particles.value = [];
    this.screenShake.value = { x: 0, y: 0, intensity: 0 };
    this.aimLine.value = { visible: false, x: 0, y: 0 };
    this.currentShooterWord.value = "";
    this.currentShooterColor.value = "#FF6B6B";
  }
  updateScore(points) {
    this.score.value += points;
  }
  incrementWordsMatched() {
    this.wordsMatched.value += 1;
  }
  setGameOver(gameOver) {
    this.gameOver.value = gameOver;
  }
  setRowAnimationActive(active) {
    this.rowAnimationActive.value = active;
  }
  // Bubble Management
  addBubble(bubble) {
    this.bubbles.value.push(bubble);
  }
  removeBubbles(bubbleIds) {
    this.bubbles.value = this.bubbles.value.filter(
      (bubble) => !bubbleIds.includes(bubble.id)
    );
  }
  setShootingBubble(bubble) {
    this.shootingBubble.value = bubble;
  }
  selectNextShooterWord(words) {
    if (words.length > 0) {
      const randomWord = words[Math.floor(Math.random() * words.length)];
      this.currentShooterWord.value = randomWord.word;
      this.currentShooterColor.value = this.getColorForWord(randomWord.word);
    }
  }
  // Visual Effects Management
  updateAimLine(position) {
    if (position) {
      this.aimLine.value = {
        visible: true,
        x: position.x,
        y: position.y
      };
    } else {
      this.aimLine.value.visible = false;
    }
  }
  addExplosion(explosion) {
    this.explosions.value.push(explosion);
  }
  updateExplosions() {
    this.explosions.value.forEach((explosion) => {
      if (!explosion.active) return;
      if (explosion.shockwave.radius < explosion.shockwave.maxRadius) {
        explosion.shockwave.radius += 2;
        explosion.shockwave.intensity = Math.max(0, 1 - explosion.shockwave.radius / explosion.shockwave.maxRadius);
      }
      let activeParticles = 0;
      explosion.particles.forEach((particle) => {
        if (particle.life > 0) {
          particle.x += particle.vx;
          particle.y += particle.vy;
          particle.rotation += particle.rotationSpeed;
          switch (particle.type) {
            case "burst":
              particle.vy += 0.15;
              particle.vx *= 0.96;
              particle.vy *= 0.96;
              particle.life -= 0.025;
              break;
            case "spark":
              particle.vy += 0.05;
              particle.vx *= 0.99;
              particle.vy *= 0.99;
              particle.life -= 0.04;
              break;
            case "glow":
              particle.vy += 0.08;
              particle.vx *= 0.97;
              particle.vy *= 0.97;
              particle.life -= 0.015;
              break;
          }
          activeParticles++;
        }
      });
      if (activeParticles === 0 && explosion.shockwave.radius >= explosion.shockwave.maxRadius) {
        explosion.active = false;
      }
    });
    this.updateScreenShake();
    this.explosions.value = this.explosions.value.filter((explosion) => explosion.active);
  }
  // Screen Shake Management
  addScreenShake(intensity) {
    this.screenShake.value.intensity = Math.max(this.screenShake.value.intensity, intensity);
  }
  updateScreenShake() {
    if (this.screenShake.value.intensity > 0) {
      this.screenShake.value.x = (Math.random() - 0.5) * this.screenShake.value.intensity;
      this.screenShake.value.y = (Math.random() - 0.5) * this.screenShake.value.intensity;
      this.screenShake.value.intensity *= 0.9;
      if (this.screenShake.value.intensity < 0.1) {
        this.screenShake.value.intensity = 0;
        this.screenShake.value.x = 0;
        this.screenShake.value.y = 0;
      }
    }
  }
  // Private helper method for color mapping
  getColorForWord(word) {
    if (!this.wordColorMap.has(word)) {
      let hash = 0;
      for (let i = 0; i < word.length; i++) {
        hash = (hash << 5) - hash + word.charCodeAt(i) & 4294967295;
      }
      const colorIndex = Math.abs(hash) % this.COLORS.length;
      this.wordColorMap.set(word, this.COLORS[colorIndex]);
    }
    return this.wordColorMap.get(word);
  }
}
const useGameStateManager = () => {
  return new GameStateManager();
};

class PhysicsEngine {
  BUBBLE_SIZE = 40;
  COLORS = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7", "#DDA0DD", "#98D8C8", "#FFB347"];
  // Small epsilon to treat tiny gaps as contact to avoid visible spacing
  CONTACT_EPS = 8;
  wordColorMap = /* @__PURE__ */ new Map();
  stateManager;
  constructor(stateManager) {
    this.stateManager = stateManager;
  }
  getColorForWord(word) {
    if (!this.wordColorMap.has(word)) {
      let hash = 0;
      for (let i = 0; i < word.length; i++) {
        hash = (hash << 5) - hash + word.charCodeAt(i) & 4294967295;
      }
      const colorIndex = Math.abs(hash) % this.COLORS.length;
      this.wordColorMap.set(word, this.COLORS[colorIndex]);
    }
    return this.wordColorMap.get(word);
  }
  checkCollision(bubble1, bubble2) {
    const dx = bubble2.x - bubble1.x;
    const dy = bubble2.y - bubble1.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance <= this.BUBBLE_SIZE;
  }
  animateShootingBubble(bubble, vx, vy, onLand, existingBubbles, canvasWidth = 800, canvasHeight = 600) {
    let bounceCount = 0;
    const maxBounces = 3;
    let currentVx = vx;
    let currentVy = vy;
    const animate = () => {
      bubble.x += currentVx;
      bubble.y += currentVy;
      if (existingBubbles) {
        for (const existing of existingBubbles) {
          const isAnimating = this.stateManager?.rowAnimationActive.value;
          const isNewRow = isAnimating && (existing.row ?? 0) < 0;
          const existingX = isNewRow ? existing.x : isAnimating && existing.stableX !== void 0 ? existing.stableX : existing.x;
          const existingY = isNewRow ? this.BUBBLE_SIZE / 2 : isAnimating && existing.stableY !== void 0 ? existing.stableY : existing.y;
          const dx0 = bubble.x - existingX;
          const dy0 = bubble.y - existingY;
          const dist0 = Math.sqrt(dx0 * dx0 + dy0 * dy0);
          const nearThreshold = this.BUBBLE_SIZE + this.CONTACT_EPS;
          const approaching = dx0 * currentVx + dy0 * currentVy <= 0;
          if (dist0 <= nearThreshold && approaching) {
            console.log("Collision/near-contact detected! Computing tangent and triple-contact placement");
            let dx = dx0;
            let dy = dy0;
            let dist = dist0;
            if (dist < 0.01) {
              dx = -currentVx || 0;
              dy = -currentVy || -1;
              const norm = Math.sqrt(dx * dx + dy * dy) || 1;
              dx /= norm;
              dy /= norm;
            } else {
              dx /= dist;
              dy /= dist;
            }
            const tangentX = existingX + dx * this.BUBBLE_SIZE;
            const tangentY = existingY + dy * this.BUBBLE_SIZE;
            bubble.x = tangentX;
            bubble.y = tangentY;
            if (existingBubbles) {
              this.snapToGrid(bubble, existingBubbles);
              this.forceToNearestFreeSeat(bubble, existingBubbles, canvasWidth, canvasHeight);
            } else {
              const verticalSpacing = this.BUBBLE_SIZE * Math.sqrt(3) / 2;
              const baseX = this.BUBBLE_SIZE / 2;
              const baseY = this.BUBBLE_SIZE / 2;
              bubble.row = Math.max(0, Math.round((bubble.y - baseY) / verticalSpacing));
              bubble.col = Math.max(0, Math.round((bubble.x - baseX) / this.BUBBLE_SIZE));
            }
            currentVx = 0;
            currentVy = 0;
            onLand(bubble);
            return;
          }
        }
      }
      if (bubble.x <= this.BUBBLE_SIZE / 2 || bubble.x >= canvasWidth - this.BUBBLE_SIZE / 2) {
        currentVx = -currentVx * 0.8;
        bounceCount++;
        bubble.x = Math.max(this.BUBBLE_SIZE / 2, Math.min(canvasWidth - this.BUBBLE_SIZE / 2, bubble.x));
      }
      if (bubble.y <= this.BUBBLE_SIZE / 2) {
        bubble.y = this.BUBBLE_SIZE / 2;
        const baseX = this.BUBBLE_SIZE / 2;
        const targetCol = Math.round((bubble.x - baseX) / this.BUBBLE_SIZE);
        bubble.x = baseX + targetCol * this.BUBBLE_SIZE;
        bubble.row = 0;
        bubble.col = Math.max(0, targetCol);
        currentVy = 0;
        bounceCount = maxBounces;
      }
      if (bubble.y >= canvasHeight - this.BUBBLE_SIZE / 2) {
        bubble.y = canvasHeight - this.BUBBLE_SIZE / 2;
        currentVy = 0;
        bounceCount = maxBounces;
      }
      if (bounceCount > 0 && currentVy > 2) {
        currentVy += 0.05;
      }
      const slowMoving = Math.abs(currentVx) < 3 && Math.abs(currentVy) < 3;
      const nearLeftWall = bubble.x <= this.BUBBLE_SIZE / 2 + 20;
      const nearRightWall = bubble.x >= canvasWidth - this.BUBBLE_SIZE / 2 - 20;
      const nearTopWall = bubble.y <= this.BUBBLE_SIZE / 2 + 20;
      const stickToWall = bounceCount > 0 && (slowMoving && (nearLeftWall || nearRightWall) || nearTopWall && Math.abs(currentVy) < 2);
      if (bubble.y <= this.BUBBLE_SIZE / 2 && currentVy <= 0 || bounceCount >= maxBounces || stickToWall) {
        if (existingBubbles && existingBubbles.length > 0) {
          const captureRadius = this.BUBBLE_SIZE + this.CONTACT_EPS;
          let nearest = null;
          let bestDist = Number.POSITIVE_INFINITY;
          for (const b of existingBubbles) {
            const isAnimating = this.stateManager?.rowAnimationActive.value;
            const isNewRow = isAnimating && (b.row ?? 0) < 0;
            const bx = isNewRow ? b.x : isAnimating && b.stableX !== void 0 ? b.stableX : b.x;
            const by = isNewRow ? this.BUBBLE_SIZE / 2 : isAnimating && b.stableY !== void 0 ? b.stableY : b.y;
            const dx = bubble.x - bx;
            const dy = bubble.y - by;
            const d = Math.sqrt(dx * dx + dy * dy);
            const dot = dx * currentVx + dy * currentVy;
            if (dot > 0) continue;
            if (d < captureRadius && d < bestDist) {
              nearest = b;
              bestDist = d;
            }
          }
          if (nearest) {
            const isAnimating2 = this.stateManager?.rowAnimationActive.value;
            const isNewRow2 = isAnimating2 && (nearest.row ?? 0) < 0;
            const nx = isNewRow2 ? nearest.x : isAnimating2 && nearest.stableX !== void 0 ? nearest.stableX : nearest.x;
            const ny = isNewRow2 ? this.BUBBLE_SIZE / 2 : isAnimating2 && nearest.stableY !== void 0 ? nearest.stableY : nearest.y;
            let ndx = bubble.x - nx;
            let ndy = bubble.y - ny;
            const nlen = Math.sqrt(ndx * ndx + ndy * ndy) || 1;
            ndx /= nlen;
            ndy /= nlen;
            const tangentX = nx + ndx * this.BUBBLE_SIZE;
            const tangentY = ny + ndy * this.BUBBLE_SIZE;
            const triple = this.findTripleContactPosition(
              nearest,
              existingBubbles,
              { x: tangentX, y: tangentY },
              canvasWidth,
              canvasHeight
            );
            const finalX = triple ? triple.x : tangentX;
            const finalY = triple ? triple.y : tangentY;
            bubble.x = finalX;
            bubble.y = finalY;
            this.snapToGrid(bubble, existingBubbles);
            this.forceToNearestFreeSeat(bubble, existingBubbles, canvasWidth, canvasHeight);
            onLand(bubble);
            return;
          }
        }
        onLand(bubble);
        return;
      }
      requestAnimationFrame(animate);
    };
    animate();
  }
  // Attempt to find a position where the new bubble touches the collided bubble
  // and one of its neighbors simultaneously (triple-contact). Returns null if none valid.
  findTripleContactPosition(collided, existingBubbles, tangentPoint, canvasWidth, canvasHeight) {
    const R = this.BUBBLE_SIZE;
    const rWall = this.BUBBLE_SIZE / 2;
    const intersections = (ax, ay, bx, by) => {
      const dx = bx - ax;
      const dy = by - ay;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < 1e-6 || d > 2 * R) return [];
      const a = d / 2;
      const h2 = R * R - a * a;
      if (h2 < -1e-6) return [];
      const h = h2 > 0 ? Math.sqrt(Math.max(0, h2)) : 0;
      const mx = ax + a * dx / d;
      const my = ay + a * dy / d;
      const rx = -dy * h / d;
      const ry = dx * h / d;
      return [
        { x: mx + rx, y: my + ry },
        { x: mx - rx, y: my - ry }
      ];
    };
    const inBounds = (x, y) => x >= rWall && x <= canvasWidth - rWall && y >= rWall && y <= canvasHeight - rWall;
    const positionFree = (x, y) => {
      for (const b of existingBubbles) {
        const dx = b.x - x;
        const dy = b.y - y;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < this.BUBBLE_SIZE - 0.1) return false;
      }
      return true;
    };
    const neighbors = existingBubbles.filter((b) => b !== collided).filter((b) => {
      const dx = b.x - collided.x;
      const dy = b.y - collided.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      return d > 0.5 * this.BUBBLE_SIZE && d < 1.5 * this.BUBBLE_SIZE;
    });
    let best = null;
    let bestScore = Number.POSITIVE_INFINITY;
    for (const nb of neighbors) {
      const pts = intersections(collided.x, collided.y, nb.x, nb.y);
      for (const p of pts) {
        if (!inBounds(p.x, p.y)) continue;
        if (!positionFree(p.x, p.y)) continue;
        const dx = p.x - tangentPoint.x;
        const dy = p.y - tangentPoint.y;
        const score = dx * dx + dy * dy;
        if (score < bestScore) {
          best = p;
          bestScore = score;
        }
      }
    }
    return best;
  }
  // Quantize the dynamic baseY to the nearest valid grid line to stabilize row/column mapping
  getQuantizedBaseY(existingBubbles) {
    if (!existingBubbles || existingBubbles.length === 0) return this.BUBBLE_SIZE / 2;
    const verticalSpacing = this.BUBBLE_SIZE * Math.sqrt(3) / 2;
    const baseRef = this.BUBBLE_SIZE / 2;
    const isAnimating = this.stateManager?.rowAnimationActive.value;
    if (isAnimating) {
      const stableRowBubbles = existingBubbles.filter((b) => (b.row ?? 0) >= 0);
      if (stableRowBubbles.length === 0) return baseRef;
      const minRow = Math.min(...stableRowBubbles.map((b) => b.row ?? 0));
      const quantized = baseRef + minRow * verticalSpacing;
      console.log("getQuantizedBaseY (ANIMATION): minRow =", minRow, "quantized baseY =", quantized);
      return quantized;
    } else {
      const minRow = Math.min(...existingBubbles.map((b) => b.row ?? 0));
      const quantized = baseRef + minRow * verticalSpacing;
      console.log("getQuantizedBaseY (NORMAL): minRow =", minRow, "quantized baseY =", quantized);
      return quantized;
    }
  }
  // Compute the pixel center for a given grid seat (row, col)
  getSeatCenter(row, col, existingBubbles) {
    const verticalSpacing = this.BUBBLE_SIZE * Math.sqrt(3) / 2;
    const baseX = this.BUBBLE_SIZE / 2;
    const baseY = this.getQuantizedBaseY(existingBubbles);
    const topOffset = this.getTopRowOffset(existingBubbles);
    const rowOffset = row % 2 === 0 ? topOffset : topOffset === 0 ? this.BUBBLE_SIZE / 2 : 0;
    const x = baseX + rowOffset + col * this.BUBBLE_SIZE;
    const y = baseY + row * verticalSpacing;
    return { x, y };
  }
  // Infer the current top-row horizontal offset (0 or B/2) from existing row-0 bubbles
  // Uses stableX during row animation to avoid drift.
  getTopRowOffset(existingBubbles) {
    const B = this.BUBBLE_SIZE;
    const baseX = B / 2;
    const isAnimating = this.stateManager?.rowAnimationActive.value;
    const row0 = existingBubbles.filter((b) => (b.row ?? 0) === 0);
    if (row0.length === 0) return 0;
    let sumEven = 0;
    let sumOdd = 0;
    for (const b of row0) {
      const bx = isAnimating && b.stableX !== void 0 ? b.stableX : b.x;
      const nearestEven = baseX + Math.round((bx - baseX) / B) * B;
      const nearestOdd = baseX + B / 2 + Math.round((bx - (baseX + B / 2)) / B) * B;
      sumEven += Math.abs(bx - nearestEven);
      sumOdd += Math.abs(bx - nearestOdd);
    }
    return sumEven <= sumOdd ? 0 : B / 2;
  }
  // Check if a seat (by center coords) is already occupied by an existing bubble
  isSeatOccupied(x, y, existingBubbles) {
    const seatTol = 0.25;
    const isAnimating = this.stateManager?.rowAnimationActive.value;
    for (const b of existingBubbles) {
      const bubbleX = isAnimating && b.stableX !== void 0 ? b.stableX : b.x;
      const bubbleY = isAnimating && b.stableY !== void 0 ? b.stableY : b.y;
      const dx = bubbleX - x;
      const dy = bubbleY - y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d <= seatTol) return true;
    }
    return false;
  }
  // Force bubble to its computed seat or the nearest free seat to avoid overlaps/mis-seating
  forceToNearestFreeSeat(bubble, existingBubbles, canvasWidth, canvasHeight) {
    const rWall = this.BUBBLE_SIZE / 2;
    const inBounds = (x, y) => x >= rWall && x <= canvasWidth - rWall && y >= rWall && y <= canvasHeight - rWall;
    let center = this.getSeatCenter(bubble.row, bubble.col, existingBubbles);
    if (inBounds(center.x, center.y) && !this.isSeatOccupied(center.x, center.y, existingBubbles)) {
      bubble.x = center.x;
      bubble.y = center.y;
      return;
    }
    let best = null;
    let bestScore = Number.POSITIVE_INFINITY;
    const MAX_DELTA = 2;
    for (let dr = -MAX_DELTA; dr <= MAX_DELTA; dr++) {
      const rr = Math.max(0, bubble.row + dr);
      for (let dc = -MAX_DELTA; dc <= MAX_DELTA; dc++) {
        const cc = Math.max(0, bubble.col + dc);
        center = this.getSeatCenter(rr, cc, existingBubbles);
        if (!inBounds(center.x, center.y)) continue;
        if (this.isSeatOccupied(center.x, center.y, existingBubbles)) continue;
        const dx = center.x - bubble.x;
        const dy = center.y - bubble.y;
        const score = dx * dx + dy * dy;
        if (score < bestScore) {
          bestScore = score;
          best = { row: rr, col: cc, x: center.x, y: center.y };
        }
      }
    }
    if (best) {
      bubble.row = best.row;
      bubble.col = best.col;
      bubble.x = best.x;
      bubble.y = best.y;
    } else {
      bubble.x = Math.max(rWall, Math.min(canvasWidth - rWall, center.x));
      bubble.y = Math.max(rWall, Math.min(canvasHeight - rWall, center.y));
    }
  }
  snapToGrid(bubble, existingBubbles) {
    console.log("Snapping bubble to grid. Current position:", bubble.x, bubble.y);
    const verticalSpacing = this.BUBBLE_SIZE * Math.sqrt(3) / 2;
    const baseX = this.BUBBLE_SIZE / 2;
    const baseY = this.getQuantizedBaseY(existingBubbles);
    const targetRow = Math.max(0, Math.round((bubble.y - baseY) / verticalSpacing));
    const topOffset = this.getTopRowOffset(existingBubbles);
    const offsetX = targetRow % 2 === 0 ? topOffset : topOffset === 0 ? this.BUBBLE_SIZE / 2 : 0;
    const targetCol = Math.max(0, Math.round((bubble.x - baseX - offsetX) / this.BUBBLE_SIZE));
    bubble.row = targetRow;
    bubble.col = targetCol;
    console.log("Grid coordinates assigned:", `row=${bubble.row}, col=${bubble.col}`, "Position preserved:", bubble.x, bubble.y);
  }
  lightenColor(color, amount) {
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * amount * 100);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 255) + amt;
    const B = (num & 255) + amt;
    return "#" + (16777216 + (R < 255 ? R < 1 ? 0 : R : 255) * 65536 + (G < 255 ? G < 1 ? 0 : G : 255) * 256 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
  }
}
const usePhysicsEngine = (stateManager) => {
  return new PhysicsEngine(stateManager);
};

class VisualEffects {
  BUBBLE_SIZE = 40;
  createBounceEffect(x, y) {
    const particlesArray = [];
    for (let i = 0; i < 4; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 1 + Math.random() * 2;
      particlesArray.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 1 + Math.random(),
        color: "#87CEEB",
        life: 0.5,
        maxLife: 0.5,
        type: "spark",
        rotation: 0,
        rotationSpeed: 0
      });
    }
    return {
      x,
      y,
      particles: particlesArray,
      active: true,
      shockwave: {
        radius: 0,
        maxRadius: this.BUBBLE_SIZE / 3,
        intensity: 0.3
      }
    };
  }
  createImpactEffect(x, y, color) {
    const particlesArray = [];
    for (let i = 0; i < 6; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 2 + Math.random() * 3;
      particlesArray.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 2 + Math.random() * 3,
        color,
        life: 0.8,
        maxLife: 0.8,
        type: "burst",
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.2
      });
    }
    return {
      x,
      y,
      particles: particlesArray,
      active: true,
      shockwave: {
        radius: 0,
        maxRadius: this.BUBBLE_SIZE,
        intensity: 0.6
      }
    };
  }
  createExplosion(x, y, color) {
    const particlesArray = [];
    for (let i = 0; i < 15; i++) {
      const angle = Math.PI * 2 * i / 15;
      const speed = 3 + Math.random() * 5;
      particlesArray.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 4 + Math.random() * 6,
        color,
        life: 1,
        maxLife: 1,
        type: "burst",
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.3
      });
    }
    for (let i = 0; i < 8; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 6 + Math.random() * 4;
      particlesArray.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 1 + Math.random() * 2,
        color: "#FFD700",
        life: 0.8,
        maxLife: 0.8,
        type: "spark",
        rotation: 0,
        rotationSpeed: 0
      });
    }
    for (let i = 0; i < 5; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 1 + Math.random() * 2;
      particlesArray.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 8 + Math.random() * 4,
        color: this.lightenColor(color, 0.3),
        life: 1.2,
        maxLife: 1.2,
        type: "glow",
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.1
      });
    }
    return {
      x,
      y,
      particles: particlesArray,
      active: true,
      shockwave: {
        radius: 0,
        maxRadius: this.BUBBLE_SIZE * 2,
        intensity: 1
      }
    };
  }
  updateParticles(particles) {
    particles.forEach((particle) => {
      if (particle.life > 0) {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.rotation += particle.rotationSpeed;
        switch (particle.type) {
          case "burst":
            particle.vy += 0.15;
            particle.vx *= 0.96;
            particle.vy *= 0.96;
            particle.life -= 0.025;
            break;
          case "spark":
            particle.vy += 0.05;
            particle.vx *= 0.99;
            particle.vy *= 0.99;
            particle.life -= 0.04;
            break;
          case "glow":
            particle.vy += 0.08;
            particle.vx *= 0.97;
            particle.vy *= 0.97;
            particle.life -= 0.015;
            break;
        }
      }
    });
  }
  lightenColor(color, amount) {
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * amount * 100);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 255) + amt;
    const B = (num & 255) + amt;
    return "#" + (16777216 + (R < 255 ? R < 1 ? 0 : R : 255) * 65536 + (G < 255 ? G < 1 ? 0 : G : 255) * 256 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
  }
}
const useVisualEffects = () => {
  return new VisualEffects();
};

class CanvasRenderer {
  canvasWidth = ref(800);
  canvasHeight = ref(600);
  gameCanvas = ref();
  ctx = null;
  BUBBLE_SIZE = 40;
  initializeCanvas() {
    if (!this.gameCanvas.value) return false;
    const canvas = this.gameCanvas.value;
    this.ctx = canvas.getContext("2d");
    if (!this.ctx) return false;
    const container = canvas.parentElement;
    if (container) {
      this.canvasWidth.value = container.clientWidth;
      this.canvasHeight.value = container.clientHeight;
      canvas.width = this.canvasWidth.value;
      canvas.height = this.canvasHeight.value;
    }
    return true;
  }
  setCanvasSize(width, height) {
    this.canvasWidth.value = width;
    this.canvasHeight.value = height;
    if (this.gameCanvas.value) {
      this.gameCanvas.value.width = width;
      this.gameCanvas.value.height = height;
    }
  }
  clearCanvas() {
    if (!this.ctx) return;
    this.ctx.clearRect(0, 0, this.canvasWidth.value, this.canvasHeight.value);
  }
  drawBackground() {
    if (!this.ctx) return;
    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvasHeight.value);
    gradient.addColorStop(0, "#1a1a2e");
    gradient.addColorStop(1, "#16213e");
    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.canvasWidth.value, this.canvasHeight.value);
  }
  drawBubble(bubble) {
    if (!this.ctx) return;
    const cx = Math.round(bubble.x * 2) / 2;
    const cy = Math.round(bubble.y * 2) / 2;
    const r = this.BUBBLE_SIZE / 2 - 1;
    this.ctx.save();
    this.ctx.shadowColor = bubble.color;
    this.ctx.shadowBlur = 6;
    const gradient = this.ctx.createRadialGradient(
      cx - this.BUBBLE_SIZE / 6,
      cy - this.BUBBLE_SIZE / 6,
      0,
      cx,
      cy,
      r
    );
    gradient.addColorStop(0, this.lightenColor(bubble.color, 0.3));
    gradient.addColorStop(1, bubble.color);
    this.ctx.fillStyle = gradient;
    this.ctx.beginPath();
    this.ctx.arc(cx, cy, r, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.strokeStyle = "#fff";
    this.ctx.lineWidth = 2;
    this.ctx.stroke();
    this.ctx.strokeStyle = "rgba(255,255,255,0.4)";
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.arc(cx, cy, r - 3, 0, Math.PI * 2);
    this.ctx.stroke();
    this.ctx.restore();
    this.ctx.save();
    this.ctx.shadowColor = "rgba(0,0,0,0.7)";
    this.ctx.shadowBlur = 3;
    this.ctx.shadowOffsetX = 1;
    this.ctx.shadowOffsetY = 1;
    this.ctx.fillStyle = "#fff";
    this.ctx.font = "bold 16px Arial";
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "middle";
    const text = bubble.displayText || bubble.word.charAt(0).toUpperCase();
    if (bubble.isBomb) {
      const time = Date.now() / 1e3;
      const pulse = 0.9 + 0.1 * Math.sin(time * 8);
      this.ctx.save();
      this.ctx.scale(pulse, pulse);
      this.ctx.fillStyle = "#FFA500";
      this.ctx.font = "bold 22px Arial";
      this.ctx.fillText("", cx / pulse, (cy - 2) / pulse);
      this.ctx.restore();
      this.ctx.fillStyle = "#fff";
      this.ctx.font = "bold 10px Arial";
      this.ctx.fillText(text, cx, cy + 14);
      this.ctx.strokeStyle = "#FF4444";
      this.ctx.lineWidth = 2;
      this.ctx.setLineDash([5, 5]);
      this.ctx.beginPath();
      this.ctx.arc(cx, cy, r + 5, 0, Math.PI * 2);
      this.ctx.stroke();
      this.ctx.setLineDash([]);
    } else {
      this.ctx.fillText(text, cx, cy);
    }
    this.ctx.restore();
  }
  drawShooter(position, word, color, displayText) {
    if (!this.ctx) return;
    this.ctx.save();
    const pulseIntensity = 0.8 + 0.2 * Math.sin(Date.now() * 8e-3);
    this.ctx.shadowColor = color;
    this.ctx.shadowBlur = 15 * pulseIntensity;
    const gradient = this.ctx.createRadialGradient(
      position.x - this.BUBBLE_SIZE / 6,
      position.y - this.BUBBLE_SIZE / 6,
      0,
      position.x,
      position.y,
      this.BUBBLE_SIZE / 2
    );
    gradient.addColorStop(0, color);
    gradient.addColorStop(1, color);
    this.ctx.fillStyle = gradient;
    this.ctx.beginPath();
    this.ctx.arc(position.x, position.y, this.BUBBLE_SIZE / 2, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.strokeStyle = "#fff";
    this.ctx.lineWidth = 3;
    this.ctx.stroke();
    this.ctx.strokeStyle = "rgba(255,255,255,0.3)";
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.arc(position.x, position.y, this.BUBBLE_SIZE / 2 - 4, 0, Math.PI * 2);
    this.ctx.stroke();
    this.ctx.restore();
    this.ctx.save();
    this.ctx.shadowColor = "rgba(0,0,0,0.8)";
    this.ctx.shadowBlur = 4;
    this.ctx.shadowOffsetX = 1;
    this.ctx.shadowOffsetY = 1;
    this.ctx.fillStyle = "#fff";
    this.ctx.font = "bold 18px Arial";
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "middle";
    const text = displayText || word.charAt(0).toUpperCase();
    this.ctx.fillText(text, position.x, position.y);
    this.ctx.restore();
  }
  drawShootingBubble(bubble) {
    if (!this.ctx) return;
    this.ctx.save();
    this.ctx.shadowColor = bubble.color;
    this.ctx.shadowBlur = 15;
    const pulseIntensity = 0.98 + 0.02 * Math.sin(Date.now() * 0.01);
    const sx = Math.round(bubble.x * 2) / 2;
    const sy = Math.round(bubble.y * 2) / 2;
    const r0 = this.BUBBLE_SIZE / 2 - 1;
    const gradient = this.ctx.createRadialGradient(
      sx - this.BUBBLE_SIZE / 5,
      sy - this.BUBBLE_SIZE / 5,
      0,
      sx,
      sy,
      r0
    );
    gradient.addColorStop(0, this.lightenColor(bubble.color, 0.5));
    gradient.addColorStop(1, bubble.color);
    this.ctx.fillStyle = gradient;
    this.ctx.beginPath();
    this.ctx.arc(sx, sy, r0 * pulseIntensity, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.strokeStyle = "#fff";
    this.ctx.lineWidth = 3;
    this.ctx.stroke();
    this.ctx.strokeStyle = "rgba(255,255,255,0.6)";
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.arc(sx, sy, (r0 - 3) * pulseIntensity, 0, Math.PI * 2);
    this.ctx.stroke();
    this.ctx.restore();
    this.ctx.save();
    this.ctx.shadowColor = "rgba(0,0,0,0.9)";
    this.ctx.shadowBlur = 5;
    this.ctx.shadowOffsetX = 1;
    this.ctx.shadowOffsetY = 1;
    this.ctx.fillStyle = "#fff";
    this.ctx.font = "bold 17px Arial";
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "middle";
    const text = bubble.displayText || bubble.word.charAt(0).toUpperCase();
    this.ctx.fillText(text, sx, sy);
    this.ctx.restore();
  }
  drawExplosions(explosions) {
    if (!this.ctx) return;
    explosions.forEach((explosion) => {
      if (!explosion.active || !this.ctx) return;
      if (explosion.shockwave.intensity > 0) {
        this.ctx.save();
        this.ctx.globalAlpha = explosion.shockwave.intensity * 0.3;
        this.ctx.strokeStyle = "#FFD700";
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(explosion.x, explosion.y, explosion.shockwave.radius, 0, Math.PI * 2);
        this.ctx.stroke();
        this.ctx.restore();
      }
      explosion.particles.forEach((particle) => {
        if (particle.life <= 0 || !this.ctx) return;
        const alpha = particle.life / particle.maxLife;
        this.ctx.save();
        this.ctx.translate(particle.x, particle.y);
        this.ctx.rotate(particle.rotation);
        this.ctx.globalAlpha = alpha;
        switch (particle.type) {
          case "burst":
            this.ctx.shadowColor = particle.color;
            this.ctx.shadowBlur = particle.size * 2;
            this.ctx.fillStyle = particle.color;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, particle.size * alpha, 0, Math.PI * 2);
            this.ctx.fill();
            break;
          case "spark":
            this.ctx.strokeStyle = particle.color;
            this.ctx.lineWidth = particle.size * alpha;
            this.ctx.lineCap = "round";
            this.ctx.beginPath();
            this.ctx.moveTo(-particle.size, 0);
            this.ctx.lineTo(particle.size, 0);
            this.ctx.stroke();
            break;
          case "glow":
            const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, particle.size * alpha);
            gradient.addColorStop(0, particle.color);
            gradient.addColorStop(1, "transparent");
            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, particle.size * alpha, 0, Math.PI * 2);
            this.ctx.fill();
            break;
        }
        this.ctx.restore();
      });
    });
  }
  drawAimLine(aimLine, shooterPosition) {
    if (!this.ctx || !aimLine.visible) return;
    const ctx = this.ctx;
    ctx.strokeStyle = "rgba(255,255,255,0.8)";
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    const leftX = this.BUBBLE_SIZE / 2;
    const rightX = this.canvasWidth.value - this.BUBBLE_SIZE / 2;
    const topY = this.BUBBLE_SIZE / 2;
    let px = shooterPosition.x;
    let py = shooterPosition.y;
    let vx = aimLine.x - shooterPosition.x;
    let vy = aimLine.y - shooterPosition.y;
    const len = Math.sqrt(vx * vx + vy * vy) || 1;
    vx /= len;
    vy /= len;
    if (vy > -0.01) vy = -0.01;
    ctx.beginPath();
    ctx.moveTo(px, py);
    let bounces = 0;
    const maxBounces = 2;
    let safeGuard = 0;
    while (bounces <= maxBounces && safeGuard++ < 10) {
      const tTop = (topY - py) / vy;
      let tWall = Number.POSITIVE_INFINITY;
      let wallX = px;
      if (vx > 0) {
        tWall = (rightX - px) / vx;
        wallX = rightX;
      } else if (vx < 0) {
        tWall = (leftX - px) / vx;
        wallX = leftX;
      }
      const tMin = Math.min(
        tTop > 0 ? tTop : Number.POSITIVE_INFINITY,
        tWall > 0 ? tWall : Number.POSITIVE_INFINITY
      );
      const nx = px + vx * tMin;
      const ny = py + vy * tMin;
      ctx.lineTo(nx, ny);
      if (tTop > 0 && tTop <= tMin + 1e-6) {
        break;
      }
      px = wallX;
      py = ny;
      vx = -vx;
      bounces++;
      ctx.moveTo(px, py);
    }
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.shadowColor = "#fff";
    ctx.shadowBlur = 10;
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
  lightenColor(color, amount) {
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * amount * 100);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 255) + amt;
    const B = (num & 255) + amt;
    return "#" + (16777216 + (R < 255 ? R < 1 ? 0 : R : 255) * 65536 + (G < 255 ? G < 1 ? 0 : G : 255) * 256 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
  }
}
const useCanvasRenderer = () => {
  return new CanvasRenderer();
};

class InputHandler {
  updateAim(event, canvas) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mouseX = (event.clientX - rect.left) * scaleX;
    const mouseY = (event.clientY - rect.top) * scaleY;
    console.log(`Mouse: ${event.clientX}, ${event.clientY} | Canvas: ${mouseX}, ${mouseY} | Scale: ${scaleX.toFixed(2)}, ${scaleY.toFixed(2)}`);
    const shooterX = canvas.width / 2;
    const shooterY = canvas.height - 50;
    const dx = mouseX - shooterX;
    const dy = mouseY - shooterY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (mouseY < shooterY - 20 && distance > 20) {
      return {
        x: mouseX,
        y: mouseY
      };
    }
    return null;
  }
  getShootingVector(event, canvas, shooterPosition) {
    const rect = canvas.getBoundingClientRect();
    if (!rect) return null;
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const targetX = (event.clientX - rect.left) * scaleX;
    const targetY = (event.clientY - rect.top) * scaleY;
    console.log(`Shooting at: ${targetX}, ${targetY} (scaled from ${event.clientX}, ${event.clientY})`);
    const BUBBLE_SIZE = 40;
    const leftX = BUBBLE_SIZE / 2;
    const rightX = canvas.width - BUBBLE_SIZE / 2;
    const topY = BUBBLE_SIZE / 2;
    let vx = targetX - shooterPosition.x;
    let vy = targetY - shooterPosition.y;
    const len0 = Math.sqrt(vx * vx + vy * vy) || 1;
    vx /= len0;
    vy /= len0;
    if (vy > -0.01) vy = -0.01;
    let px = shooterPosition.x;
    let py = shooterPosition.y;
    let bounces = 0;
    const maxBounces = 2;
    let endX = targetX;
    let endY = targetY;
    while (bounces <= maxBounces) {
      const tTop = (topY - py) / vy;
      let tWall = Number.POSITIVE_INFINITY;
      if (vx > 0) {
        tWall = (rightX - px) / vx;
      } else if (vx < 0) {
        tWall = (leftX - px) / vx;
      }
      const tMin = Math.min(
        tTop > 0 ? tTop : Number.POSITIVE_INFINITY,
        tWall > 0 ? tWall : Number.POSITIVE_INFINITY
      );
      endX = px + vx * tMin;
      endY = py + vy * tMin;
      break;
    }
    const dx = endX - shooterPosition.x;
    const dy = endY - shooterPosition.y;
    const distance = Math.sqrt(dx * dx + dy * dy) || 1;
    const speed = 8;
    const normalizedDx = dx / distance * speed;
    const normalizedDy = dy / distance * speed;
    console.log(`Direction (reflected): dx=${normalizedDx.toFixed(2)}, dy=${normalizedDy.toFixed(2)}`);
    return { vx: normalizedDx, vy: normalizedDy };
  }
}
const useInputHandler = () => {
  return new InputHandler();
};

class GameLogic {
  BUBBLE_SIZE = 40;
  COLORS = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7", "#DDA0DD", "#98D8C8", "#FFB347"];
  checkForMatches(newBubble, bubbles) {
    console.log("Checking matches for bubble:", newBubble.word, newBubble.x, newBubble.y);
    const visited = /* @__PURE__ */ new Set();
    const connectedBubbles = [];
    const findConnected = (bubble) => {
      if (visited.has(bubble.id)) return;
      visited.add(bubble.id);
      connectedBubbles.push(bubble);
      console.log("Found connected bubble:", bubble.word, bubble.x, bubble.y);
      bubbles.forEach((other) => {
        if (other.id !== bubble.id && !visited.has(other.id) && other.word === bubble.word) {
          const dx = other.x - bubble.x;
          const dy = other.y - bubble.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          console.log(`Distance between ${bubble.word} and ${other.word}: ${distance}, BUBBLE_SIZE: ${this.BUBBLE_SIZE}`);
          if (distance <= this.BUBBLE_SIZE * 1.2) {
            console.log("Found adjacent bubble:", other.word, other.x, other.y);
            findConnected(other);
          }
        }
      });
    };
    findConnected(newBubble);
    console.log(`Found ${connectedBubbles.length} connected bubbles:`, connectedBubbles.map((b) => b.word));
    const shouldRemove = connectedBubbles.length >= 3;
    if (shouldRemove) {
      console.log("MATCH FOUND! Removing bubbles:", connectedBubbles.map((b) => b.word));
    } else {
      console.log("No match - not enough connected bubbles");
    }
    return {
      matchedBubbles: connectedBubbles,
      shouldRemove
    };
  }
  removeFloatingBubbles(bubbles) {
    const topConnected = /* @__PURE__ */ new Set();
    const markTopConnected = (bubble) => {
      if (topConnected.has(bubble.id)) return;
      topConnected.add(bubble.id);
      bubbles.forEach((other) => {
        if (other.id !== bubble.id && !topConnected.has(other.id)) {
          const dx = other.x - bubble.x;
          const dy = other.y - bubble.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance <= this.BUBBLE_SIZE * 1.1) {
            markTopConnected(other);
          }
        }
      });
    };
    bubbles.forEach((bubble) => {
      if (bubble.row === 0) {
        markTopConnected(bubble);
      }
    });
    const remainingBubbles = bubbles.filter((bubble) => topConnected.has(bubble.id));
    const removedBubbles = bubbles.filter((bubble) => !topConnected.has(bubble.id));
    return {
      remainingBubbles,
      removedBubbles
    };
  }
  setupInitialBubbles(words, vietnameseMode = false) {
    const bubbles = [];
    const verticalSpacing = this.BUBBLE_SIZE * Math.sqrt(3) / 2;
    const baseX = this.BUBBLE_SIZE / 2;
    const baseY = this.BUBBLE_SIZE / 2;
    const bubblesPerRow = 8;
    for (let i = 0; i < words.length; i++) {
      const row = Math.floor(i / bubblesPerRow);
      const col = i % bubblesPerRow;
      const offsetX = row % 2 === 0 ? 0 : this.BUBBLE_SIZE / 2;
      const x = baseX + offsetX + col * this.BUBBLE_SIZE;
      const y = baseY + row * verticalSpacing;
      const bubble = {
        x,
        y,
        word: words[i].word,
        color: this.getColorForWord(words[i].word),
        // Use consistent color for same word
        id: `initial-${i}`,
        row,
        col,
        vietnameseMeaning: words[i].meaning,
        // Store Vietnamese meaning
        displayText: vietnameseMode && words[i].meaning ? words[i].meaning.substring(0, 2).toUpperCase() : words[i].word.charAt(0).toUpperCase()
        // Default to English first 1 letter
      };
      bubbles.push(bubble);
    }
    return bubbles;
  }
  isGameWon(bubbles) {
    return bubbles.length === 0;
  }
  calculateScore(matchedBubbles, floatingBubbles) {
    return matchedBubbles * 10 + floatingBubbles * 5;
  }
  getColorForWord(word) {
    let hash = 0;
    for (let i = 0; i < word.length; i++) {
      hash = (hash << 5) - hash + word.charCodeAt(i) & 4294967295;
    }
    const colorIndex = Math.abs(hash) % this.COLORS.length;
    return this.COLORS[colorIndex];
  }
}
const useGameLogic = () => {
  return new GameLogic();
};

class BubbleShooterGame {
  // Dependencies
  stateManager;
  audioSystem;
  physicsEngine;
  visualEffects;
  canvasRenderer;
  inputHandler;
  gameLogic;
  // Private properties
  animationFrame = null;
  currentWords = [];
  vietnameseMode = false;
  // Timed row insertion & animation state
  rowInsertTimer = null;
  ROW_INSERT_INTERVAL = 2e4;
  rowAnimationActive = false;
  // Bomb system
  bombHits = /* @__PURE__ */ new Map();
  // Track hits per bomb bubble
  rowAnimationStart = 0;
  rowAnimationDuration = 600;
  // ms
  rowShiftAmount = 34;
  // will be recalculated in constructor
  rowStartYMap = /* @__PURE__ */ new Map();
  rowStartXMap = /* @__PURE__ */ new Map();
  newRowBubbles = [];
  newRowDelays = /* @__PURE__ */ new Map();
  constructor() {
    this.stateManager = useGameStateManager();
    this.audioSystem = useAudioSystem();
    this.physicsEngine = usePhysicsEngine(this.stateManager);
    this.visualEffects = useVisualEffects();
    this.canvasRenderer = useCanvasRenderer();
    this.inputHandler = useInputHandler();
    this.gameLogic = useGameLogic();
    this.rowShiftAmount = this.physicsEngine.BUBBLE_SIZE * Math.sqrt(3) / 2;
  }
  // ===== Row Insertion Feature =====
  triggerRowInsertion() {
    if (this.rowAnimationActive || this.stateManager.gameOver.value) return;
    if (this.stateManager.shootingBubble.value) return;
    this.rowAnimationActive = true;
    this.stateManager.setRowAnimationActive(true);
    this.rowAnimationStart = performance.now();
    this.rowStartYMap.clear();
    this.rowStartXMap.clear();
    this.newRowBubbles = [];
    this.newRowDelays.clear();
    this.stateManager.bubbles.value.forEach((b) => {
      this.rowStartYMap.set(b.id, b.y);
      this.rowStartXMap.set(b.id, b.x);
      const verticalSpacing = this.physicsEngine.BUBBLE_SIZE * Math.sqrt(3) / 2;
      const baseX2 = this.physicsEngine.BUBBLE_SIZE / 2;
      const baseY = this.physicsEngine.BUBBLE_SIZE / 2;
      const offsetX2 = (b.row ?? 0) % 2 === 0 ? 0 : this.physicsEngine.BUBBLE_SIZE / 2;
      b.stableX = baseX2 + offsetX2 + (b.col ?? 0) * this.physicsEngine.BUBBLE_SIZE;
      b.stableY = baseY + (b.row ?? 0) * verticalSpacing;
    });
    const B = this.physicsEngine.BUBBLE_SIZE;
    const baseX = B / 2;
    const currentTop = this.stateManager.bubbles.value.filter((b) => (b.row ?? 0) === 0);
    const nearestGridX = (x, offsetX2) => {
      const colF = Math.round((x - (baseX + offsetX2)) / B);
      return baseX + offsetX2 + colF * B;
    };
    let sumEven = 0, sumOdd = 0;
    if (currentTop.length > 0) {
      currentTop.forEach((b) => {
        sumEven += Math.abs(b.x - nearestGridX(b.x, 0));
        sumOdd += Math.abs(b.x - nearestGridX(b.x, B / 2));
      });
    }
    const effOffsetRow1 = currentTop.length === 0 ? 0 : sumEven <= sumOdd ? 0 : B / 2;
    const desiredOffsetRow0 = effOffsetRow1 === 0 ? B / 2 : 0;
    const canvasW = this.canvasRenderer.canvasWidth.value || 800;
    const offsetX = desiredOffsetRow0;
    const Bsize = this.physicsEngine.BUBBLE_SIZE;
    const bubblesPerRow = Math.max(1, Math.floor((canvasW - 10 - offsetX) / Bsize));
    for (let col = 0; col < bubblesPerRow; col++) {
      const vocab = this.currentWords[Math.floor(Math.random() * Math.max(1, this.currentWords.length))];
      const word = vocab?.word || "";
      const color = this.physicsEngine.getColorForWord(word);
      const x = col * this.physicsEngine.BUBBLE_SIZE + this.physicsEngine.BUBBLE_SIZE / 2 + offsetX;
      const startY = -this.physicsEngine.BUBBLE_SIZE;
      const isBomb = Math.random() < 0.2;
      const bubble = {
        x,
        y: startY,
        word,
        color: isBomb ? "#FF4444" : color,
        // Bomb bubbles are red
        id: `row-${Date.now()}-${col}`,
        row: -1,
        col,
        vietnameseMeaning: vocab?.meaning || "",
        displayText: this.vietnameseMode && vocab?.meaning ? vocab.meaning.substring(0, 2).toUpperCase() : word.charAt(0).toUpperCase(),
        isBomb
      };
      this.stateManager.addBubble(bubble);
      this.newRowBubbles.push(bubble);
      this.newRowDelays.set(bubble.id, col * 60);
    }
  }
  updateRowInsertionAnimation() {
    if (!this.rowAnimationActive) return;
    const now = performance.now();
    const elapsed = now - this.rowAnimationStart;
    const t = Math.min(1, elapsed / this.rowAnimationDuration);
    const ease = 1 - Math.pow(1 - t, 3);
    this.stateManager.bubbles.value.forEach((b) => {
      if (this.newRowDelays.has(b.id)) return;
      const startY = this.rowStartYMap.get(b.id);
      const startX = this.rowStartXMap.get(b.id);
      if (startY != null) {
        b.y = startY + ease * this.rowShiftAmount;
      }
      if (startX != null) {
        b.x = startX;
      }
    });
    const targetTopY = this.physicsEngine.BUBBLE_SIZE / 2;
    const movingTopY = targetTopY + ease * this.rowShiftAmount;
    const epsilon = 1;
    const rowBelow = this.stateManager.bubbles.value.filter((b) => !this.newRowDelays.has(b.id) && (b.row ?? 0) === 0);
    let allNewSettled = true;
    for (const nb of this.newRowBubbles) {
      const delay = this.newRowDelays.get(nb.id) || 0;
      const localElapsed = Math.max(0, elapsed - delay);
      const tt = Math.min(1, localElapsed / Math.max(1, this.rowAnimationDuration - delay));
      const ease2 = 1 - Math.pow(1 - tt, 3);
      const startY = -this.physicsEngine.BUBBLE_SIZE;
      const plannedY = startY + (targetTopY - startY) * ease2;
      let allowed = movingTopY - this.rowShiftAmount - epsilon;
      if (rowBelow.length > 0) {
        let nearest = rowBelow[0];
        let bestDx = Math.abs(nearest.x - nb.x);
        for (let i = 1; i < rowBelow.length; i++) {
          const dx = Math.abs(rowBelow[i].x - nb.x);
          if (dx < bestDx) {
            bestDx = dx;
            nearest = rowBelow[i];
          }
        }
        const B = this.physicsEngine.BUBBLE_SIZE;
        const dxClamped = Math.min(bestDx, B);
        const dyMin = dxClamped >= B ? 0 : Math.sqrt(B * B - dxClamped * dxClamped);
        allowed = Math.min(allowed, nearest.y - dyMin - epsilon);
      }
      nb.y = Math.round(Math.min(plannedY, allowed) * 2) / 2;
      if (tt < 1) allNewSettled = false;
    }
    if (t >= 1 && allNewSettled) {
      this.stateManager.bubbles.value.forEach((b) => {
        if (this.newRowDelays.has(b.id)) return;
        const prevRow = b.row ?? 0;
        const nextRow = prevRow + 1;
        const startX = this.rowStartXMap.get(b.id);
        if (startX != null) b.x = startX;
        b.row = nextRow;
        const yExact = this.physicsEngine.BUBBLE_SIZE / 2 + nextRow * this.rowShiftAmount;
        b.y = Math.round(yExact * 2) / 2;
        const offsetX = nextRow % 2 === 0 ? 0 : this.physicsEngine.BUBBLE_SIZE / 2;
        const colF = Math.round(
          (b.x - (this.physicsEngine.BUBBLE_SIZE / 2 + offsetX)) / this.physicsEngine.BUBBLE_SIZE
        );
        b.col = Math.max(0, colF);
      });
      const B2 = this.physicsEngine.BUBBLE_SIZE;
      const baseX2 = B2 / 2;
      const currentTop2 = this.stateManager.bubbles.value.filter((b) => (b.row ?? 0) === 1);
      let sumEven2 = 0, sumOdd2 = 0;
      if (currentTop2.length > 0) {
        currentTop2.forEach((b) => {
          sumEven2 += Math.abs(b.x - (baseX2 + Math.round((b.x - baseX2) / B2) * B2));
          sumOdd2 += Math.abs(b.x - (baseX2 + B2 / 2 + Math.round((b.x - (baseX2 + B2 / 2)) / B2) * B2));
        });
      }
      const effOffsetRow1b = currentTop2.length === 0 ? 0 : sumEven2 <= sumOdd2 ? 0 : B2 / 2;
      const desiredOffsetRow0b = effOffsetRow1b === 0 ? B2 / 2 : 0;
      this.newRowBubbles.forEach((nb) => {
        const col0 = Math.round((nb.x - (baseX2 + desiredOffsetRow0b)) / B2);
        nb.col = Math.max(0, col0);
        nb.row = 0;
        nb.y = Math.round(targetTopY * 2) / 2;
      });
      this.stateManager.addScreenShake(4);
      this.audioSystem.playImpactSound();
      this.stateManager.bubbles.value.forEach((b) => {
        delete b.stableX;
        delete b.stableY;
      });
      this.rowAnimationActive = false;
      this.stateManager.setRowAnimationActive(false);
      this.rowStartYMap.clear();
      this.rowStartXMap.clear();
      this.newRowDelays.clear();
      this.newRowBubbles = [];
    }
  }
  initialize(canvas, words, vietnameseMode = false) {
    this.canvasRenderer.gameCanvas.value = canvas;
    this.currentWords = words;
    this.vietnameseMode = vietnameseMode;
    if (!this.canvasRenderer.initializeCanvas()) {
      console.error("Failed to initialize canvas");
      return;
    }
    this.stateManager.shooterPosition.value = {
      x: this.canvasRenderer.canvasWidth.value / 2,
      y: this.canvasRenderer.canvasHeight.value - 50
    };
    const initialBubbles = this.gameLogic.setupInitialBubbles(words, this.vietnameseMode);
    initialBubbles.forEach((bubble) => this.stateManager.addBubble(bubble));
    this.stateManager.selectNextShooterWord(words);
    this.startGameLoop();
    if (this.rowInsertTimer) window.clearInterval(this.rowInsertTimer);
    this.rowInsertTimer = window.setInterval(() => this.triggerRowInsertion(), this.ROW_INSERT_INTERVAL);
  }
  startGameLoop() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }
    const gameLoop = () => {
      this.updateRowInsertionAnimation();
      this.stateManager.updateExplosions();
      this.canvasRenderer.clearCanvas();
      const shake = this.stateManager.screenShake.value;
      const ctx = this.canvasRenderer.gameCanvas.value?.getContext("2d");
      if (ctx) {
        ctx.save();
        ctx.translate(shake.x, shake.y);
        this.canvasRenderer.drawBackground();
        this.stateManager.bubbles.value.forEach((bubble) => {
          this.canvasRenderer.drawBubble(bubble);
        });
        this.canvasRenderer.drawExplosions(this.stateManager.explosions.value);
        this.canvasRenderer.drawShooter(
          this.stateManager.shooterPosition.value,
          this.stateManager.currentShooterWord.value,
          this.stateManager.currentShooterColor.value,
          this.getShooterDisplayText()
        );
        if (this.stateManager.shootingBubble.value) {
          this.canvasRenderer.drawShootingBubble(this.stateManager.shootingBubble.value);
        }
        this.canvasRenderer.drawAimLine(
          this.stateManager.aimLine.value,
          this.stateManager.shooterPosition.value
        );
        ctx.restore();
      }
      if (this.gameLogic.isGameWon(this.stateManager.bubbles.value)) {
        this.stateManager.setGameOver(true);
        return;
      }
      if (!this.stateManager.gameOver.value) {
        this.animationFrame = requestAnimationFrame(gameLoop);
      }
    };
    gameLoop();
  }
  stopGameLoop() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
    if (this.rowInsertTimer) {
      window.clearInterval(this.rowInsertTimer);
      this.rowInsertTimer = null;
    }
  }
  updateAim(event) {
    const canvas = this.canvasRenderer.gameCanvas.value;
    if (!canvas || this.stateManager.shootingBubble.value) return;
    const aimPosition = this.inputHandler.updateAim(event, canvas);
    this.stateManager.updateAimLine(aimPosition);
  }
  shootBubble(event) {
    const canvas = this.canvasRenderer.gameCanvas.value;
    if (!canvas || this.stateManager.shootingBubble.value || !this.stateManager.currentShooterWord.value || this.rowAnimationActive) {
      return;
    }
    const shootingVector = this.inputHandler.getShootingVector(
      event,
      canvas,
      this.stateManager.shooterPosition.value
    );
    if (!shootingVector) return;
    this.stateManager.updateAimLine(null);
    const shooterWord = this.stateManager.currentShooterWord.value;
    const currentWordVocab = this.currentWords.find((vocab) => vocab.word === shooterWord);
    const bubble = {
      x: this.stateManager.shooterPosition.value.x,
      y: this.stateManager.shooterPosition.value.y,
      word: shooterWord,
      color: this.stateManager.currentShooterColor.value,
      id: `shooting-${Date.now()}`,
      row: -1,
      col: -1,
      vietnameseMeaning: currentWordVocab?.meaning || "",
      displayText: shooterWord.charAt(0).toUpperCase()
      // Shooter bubble always shows English first letter
    };
    this.stateManager.setShootingBubble(bubble);
    if (bubble.word) {
      this.audioSystem.playVocabularySound(bubble.word, "en");
    }
    this.physicsEngine.animateShootingBubble(
      bubble,
      shootingVector.vx,
      shootingVector.vy,
      (landedBubble) => this.handleBubbleLanded(landedBubble),
      this.stateManager.bubbles.value,
      // Pass existing bubbles for immediate collision detection
      this.canvasRenderer.canvasWidth.value,
      // Pass actual canvas width for responsive boundaries
      this.canvasRenderer.canvasHeight.value
      // Pass actual canvas height for responsive boundaries
    );
    this.stateManager.selectNextShooterWord(this.currentWords);
  }
  restartGame(words) {
    this.stopGameLoop();
    this.currentWords = words;
    this.stateManager.resetGame();
    const initialBubbles = this.gameLogic.setupInitialBubbles(words);
    initialBubbles.forEach((bubble) => this.stateManager.addBubble(bubble));
    this.stateManager.selectNextShooterWord(words);
    this.startGameLoop();
    if (this.rowInsertTimer) window.clearInterval(this.rowInsertTimer);
    this.rowInsertTimer = window.setInterval(() => this.triggerRowInsertion(), this.ROW_INSERT_INTERVAL);
  }
  updateVietnameseMode(enabled) {
    this.vietnameseMode = enabled;
    this.stateManager.bubbles.value.forEach((bubble) => {
      if (enabled && bubble.vietnameseMeaning) {
        bubble.displayText = bubble.vietnameseMeaning.substring(0, 2).toUpperCase();
      } else {
        bubble.displayText = bubble.word.charAt(0).toUpperCase();
      }
    });
  }
  getShooterDisplayText() {
    const word = this.stateManager.currentShooterWord.value;
    if (!word) return "";
    const vocab = this.currentWords.find((w) => w.word === word);
    if (this.vietnameseMode && vocab?.meaning) {
      return vocab.meaning.substring(0, 2).toUpperCase();
    } else {
      return word.charAt(0).toUpperCase();
    }
  }
  cleanup() {
    this.stopGameLoop();
  }
  handleBubbleLanded(bubble) {
    const impactEffect = this.visualEffects.createImpactEffect(bubble.x, bubble.y, bubble.color);
    this.stateManager.addExplosion(impactEffect);
    this.audioSystem.playImpactSound();
    this.stateManager.setShootingBubble(null);
    if (this.vietnameseMode && bubble.vietnameseMeaning) {
      bubble.displayText = bubble.vietnameseMeaning.substring(0, 2).toUpperCase();
    } else {
      bubble.displayText = bubble.word.charAt(0).toUpperCase();
    }
    this.physicsEngine.snapToGrid(bubble, this.stateManager.bubbles.value);
    this.stateManager.addBubble(bubble);
    this.checkBombHits(bubble);
    const matchResult = this.gameLogic.checkForMatches(bubble, this.stateManager.bubbles.value);
    if (matchResult.shouldRemove) {
      matchResult.matchedBubbles.forEach((matchedBubble) => {
        const explosion = this.visualEffects.createExplosion(
          matchedBubble.x,
          matchedBubble.y,
          matchedBubble.color
        );
        this.stateManager.addExplosion(explosion);
      });
      const bubbleIds = matchResult.matchedBubbles.map((b) => b.id);
      this.stateManager.removeBubbles(bubbleIds);
      const matchScore = this.gameLogic.calculateScore(matchResult.matchedBubbles.length, 0);
      this.stateManager.updateScore(matchScore);
      this.stateManager.incrementWordsMatched();
      this.audioSystem.playExplosionSound();
      this.stateManager.addScreenShake(8);
      this.handleFloatingBubbles();
    }
  }
  handleFloatingBubbles() {
    const floatingResult = this.gameLogic.removeFloatingBubbles(this.stateManager.bubbles.value);
    if (floatingResult.removedBubbles.length > 0) {
      floatingResult.removedBubbles.forEach((floatingBubble) => {
        const effect = this.visualEffects.createImpactEffect(
          floatingBubble.x,
          floatingBubble.y,
          floatingBubble.color
        );
        this.stateManager.addExplosion(effect);
      });
      this.stateManager.bubbles.value = floatingResult.remainingBubbles;
      const bonusScore = this.gameLogic.calculateScore(0, floatingResult.removedBubbles.length);
      this.stateManager.updateScore(bonusScore);
    }
  }
  checkBombHits(landedBubble) {
    const adjacentBombs = this.stateManager.bubbles.value.filter((bubble) => {
      if (!bubble.isBomb) return false;
      const dx = bubble.x - landedBubble.x;
      const dy = bubble.y - landedBubble.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance <= this.physicsEngine.BUBBLE_SIZE * 1.1;
    });
    adjacentBombs.forEach((bomb) => {
      const currentHits = this.bombHits.get(bomb.id) || 0;
      const newHits = currentHits + 1;
      this.bombHits.set(bomb.id, newHits);
      console.log(`Bomb ${bomb.id} hit ${newHits}/2 times`);
      if (newHits >= 2) {
        this.triggerMassiveExplosion(bomb);
        this.bombHits.delete(bomb.id);
      }
    });
  }
  triggerMassiveExplosion(bombBubble) {
    console.log(" MASSIVE BOMB EXPLOSION! DEVASTATION!");
    for (let i = 0; i < 3; i++) {
      const offsetX = (Math.random() - 0.5) * this.physicsEngine.BUBBLE_SIZE * 2;
      const offsetY = (Math.random() - 0.5) * this.physicsEngine.BUBBLE_SIZE * 2;
      const massiveExplosion = this.visualEffects.createExplosion(
        bombBubble.x + offsetX,
        bombBubble.y + offsetY,
        "#FF4444"
      );
      massiveExplosion.shockwave.maxRadius = this.physicsEngine.BUBBLE_SIZE * 12;
      massiveExplosion.particles.forEach((particle) => {
        particle.size *= 4;
        particle.maxLife *= 3;
        particle.vx *= 3;
        particle.vy *= 3;
      });
      this.stateManager.addExplosion(massiveExplosion);
    }
    for (let i = 0; i < 60; i++) {
      const angle = Math.PI * 2 * i / 60;
      const speed = 20 + Math.random() * 15;
      const explosionParticles = {
        x: bombBubble.x,
        y: bombBubble.y,
        particles: [{
          x: bombBubble.x,
          y: bombBubble.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          size: 12 + Math.random() * 8,
          color: ["#FF2222", "#FF4444", "#FF6666", "#FFAA44", "#FFFF44", "#FF8844"][Math.floor(Math.random() * 6)],
          life: 150,
          maxLife: 150,
          type: "burst",
          rotation: 0,
          rotationSpeed: (Math.random() - 0.5) * 0.5
        }],
        active: true,
        shockwave: {
          radius: 0,
          maxRadius: this.physicsEngine.BUBBLE_SIZE * 10,
          intensity: 1
        },
        radius: 0,
        maxRadius: this.physicsEngine.BUBBLE_SIZE * 10,
        intensity: 1
      };
      this.stateManager.addExplosion(explosionParticles);
    }
    const explosionRadius = this.physicsEngine.BUBBLE_SIZE * 6;
    const bubblesInRange = this.stateManager.bubbles.value.filter((bubble) => {
      const dx = bubble.x - bombBubble.x;
      const dy = bubble.y - bombBubble.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance <= explosionRadius;
    });
    const bubbleIds = bubblesInRange.map((b) => b.id);
    this.stateManager.removeBubbles(bubbleIds);
    bubblesInRange.forEach((bubble) => {
      if (bubble.isBomb) {
        this.bombHits.delete(bubble.id);
      }
    });
    this.stateManager.addScreenShake(35);
    this.audioSystem.playExplosionSound();
    setTimeout(() => this.audioSystem.playExplosionSound(), 100);
    setTimeout(() => this.audioSystem.playExplosionSound(), 200);
    this.stateManager.updateScore(1e3 + bubblesInRange.length * 50);
    console.log(` BOMB DEVASTATION: Destroyed ${bubblesInRange.length} bubbles!`);
    const floatingResult = this.gameLogic.removeFloatingBubbles(this.stateManager.bubbles.value);
    if (floatingResult.removedBubbles.length > 0) {
      this.stateManager.removeBubbles(floatingResult.removedBubbles.map((b) => b.id));
      const floatingScore = this.gameLogic.calculateScore(0, floatingResult.removedBubbles.length);
      this.stateManager.updateScore(floatingScore);
    }
  }
}
const useBubbleShooterGame = () => {
  return new BubbleShooterGame();
};

const _hoisted_1$m = { class: "bubble-shooter-game h-full min-h-[600px] sm:min-h-[500px] md:min-h-0 flex flex-col" };
const _hoisted_2$j = { class: "p-4 sm:p-6 md:p-8 bg-gradient-to-r from-purple-600 to-pink-600 dark:from-purple-800 dark:to-pink-800 text-white" };
const _hoisted_3$i = { class: "flex justify-between items-center" };
const _hoisted_4$g = { class: "text-lg sm:text-xl md:text-2xl font-bold" };
const _hoisted_5$f = { class: "text-sm sm:text-base opacity-90" };
const _hoisted_6$e = { class: "text-right" };
const _hoisted_7$d = { class: "text-2xl sm:text-3xl font-bold" };
const _hoisted_8$d = { class: "text-xs sm:text-sm opacity-90" };
const _hoisted_9$d = { class: "flex-1 min-h-[450px] sm:min-h-[350px] md:min-h-0 relative bg-gradient-to-b from-blue-100 to-blue-200 dark:from-[#0a0a0a] dark:to-[#0f0f0f] overflow-hidden" };
const _hoisted_10$c = ["viewBox"];
const _hoisted_11$c = ["x1", "y1", "x2", "y2"];
const _hoisted_12$c = { class: "absolute bottom-20 left-1/2 transform -translate-x-1/2 bg-white dark:bg-[#0a0a0a] rounded-lg px-4 py-2 shadow-lg border-2 border-purple-500" };
const _hoisted_13$c = { class: "text-center" };
const _hoisted_14$c = { class: "text-lg sm:text-xl font-bold text-gray-800 dark:text-white" };
const _hoisted_15$a = { class: "text-xs sm:text-sm text-gray-600 dark:text-white/70" };
const _hoisted_16$a = {
  key: 0,
  class: "absolute inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center p-4"
};
const _hoisted_17$a = { class: "bg-white dark:bg-[#0a0a0a] rounded-2xl p-6 sm:p-8 max-w-md w-full text-center shadow-2xl border border-gray-200 dark:border-[#0f0f0f]" };
const _hoisted_18$a = { class: "text-xl sm:text-2xl font-bold mb-2 text-gray-800 dark:text-white" };
const _hoisted_19$a = { class: "text-gray-600 dark:text-white/70 mb-4" };
const _hoisted_20$a = { class: "text-sm text-gray-500 dark:text-white/60 mb-6" };
const _hoisted_21$a = { class: "flex gap-3 justify-center" };
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "BubbleShooterMode",
  props: {
    words: {},
    vietnameseMode: { type: Boolean }
  },
  emits: ["game-complete"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const { t } = useI18n();
    const emit = __emit;
    const game = useBubbleShooterGame();
    const gameCanvas = ref();
    const canvasWidth = computed(() => game.canvasRenderer.canvasWidth.value);
    const canvasHeight = computed(() => game.canvasRenderer.canvasHeight.value);
    const score = computed(() => game.stateManager.score.value);
    const wordsMatched = computed(() => game.stateManager.wordsMatched.value);
    const gameOver = computed(() => game.stateManager.gameOver.value);
    const currentShooterWord = computed(() => game.stateManager.currentShooterWord.value);
    computed(() => {
      const word = game.stateManager.currentShooterWord.value;
      if (!word) return "";
      const vocab = props.words.find((w) => w.word === word);
      if (props.vietnameseMode && vocab?.meaning) {
        return vocab.meaning.substring(0, 2).toUpperCase();
      } else {
        return word.charAt(0).toUpperCase();
      }
    });
    const aimLine = computed(() => game.stateManager.aimLine.value);
    const shooterPosition = computed(() => game.stateManager.shooterPosition.value);
    const stopGameOverWatch = watch(
      () => game.stateManager.gameOver.value,
      (isGameOver) => {
        if (isGameOver) {
          emit("game-complete");
        }
      }
    );
    onMounted(async () => {
      await nextTick();
      if (!gameCanvas.value) return;
      game.initialize(gameCanvas.value, props.words, props.vietnameseMode);
    });
    watch(() => props.vietnameseMode, (newValue) => {
      game.updateVietnameseMode(newValue ?? false);
    });
    onUnmounted(() => {
      stopGameOverWatch();
      game.cleanup();
    });
    const updateAim = (event) => {
      game.updateAim(event);
    };
    const shootBubble = (event) => {
      game.shootBubble(event);
    };
    const restartGame = () => {
      game.stopGameLoop();
      game.stateManager.resetGame();
      if (gameCanvas.value) {
        game.initialize(gameCanvas.value, props.words);
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$m, [
        createBaseVNode("div", _hoisted_2$j, [
          createBaseVNode("div", _hoisted_3$i, [
            createBaseVNode("div", null, [
              createBaseVNode("h2", _hoisted_4$g, toDisplayString$1(unref(t)("flashcard.bubbleShooter.title", "Bubble Shooter")), 1),
              createBaseVNode("p", _hoisted_5$f, toDisplayString$1(unref(t)("flashcard.bubbleShooter.instruction", "Shoot bubbles to match 4 or more words!")), 1)
            ]),
            createBaseVNode("div", _hoisted_6$e, [
              createBaseVNode("div", _hoisted_7$d, toDisplayString$1(score.value), 1),
              createBaseVNode("div", _hoisted_8$d, toDisplayString$1(unref(t)("flashcard.bubbleShooter.score", "Score")), 1)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_9$d, [
          createBaseVNode("canvas", {
            ref_key: "gameCanvas",
            ref: gameCanvas,
            class: "w-full h-full cursor-crosshair",
            onClick: shootBubble,
            onMousemove: updateAim
          }, null, 544),
          aimLine.value.visible ? (openBlock(), createElementBlock("svg", {
            key: 0,
            class: "absolute inset-0 w-full h-full pointer-events-none",
            viewBox: `0 0 ${canvasWidth.value} ${canvasHeight.value}`
          }, [
            createBaseVNode("line", {
              x1: shooterPosition.value.x,
              y1: shooterPosition.value.y,
              x2: aimLine.value.x,
              y2: aimLine.value.y,
              stroke: "rgba(255,255,255,0.7)",
              "stroke-width": "2",
              "stroke-dasharray": "5,5"
            }, null, 8, _hoisted_11$c)
          ], 8, _hoisted_10$c)) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_12$c, [
            createBaseVNode("div", _hoisted_13$c, [
              createBaseVNode("div", _hoisted_14$c, toDisplayString$1(currentShooterWord.value), 1),
              createBaseVNode("div", _hoisted_15$a, toDisplayString$1(unref(t)("flashcard.bubbleShooter.currentWord", "Current Word")), 1)
            ])
          ]),
          createVNode(Transition, {
            name: "modal",
            appear: ""
          }, {
            default: withCtx(() => [
              gameOver.value ? (openBlock(), createElementBlock("div", _hoisted_16$a, [
                createBaseVNode("div", _hoisted_17$a, [
                  _cache[1] || (_cache[1] = createBaseVNode("div", { class: "w-16 h-16 sm:w-20 sm:h-20 mx-auto mb-4 bg-gradient-to-r from-green-400 to-blue-500 rounded-full flex items-center justify-center animate-pulse" }, [
                    createBaseVNode("svg", {
                      class: "w-8 h-8 sm:w-10 sm:h-10 text-white",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                        "clip-rule": "evenodd"
                      })
                    ])
                  ], -1)),
                  createBaseVNode("h3", _hoisted_18$a, toDisplayString$1(unref(t)("flashcard.bubbleShooter.gameComplete", "Game Complete!")), 1),
                  createBaseVNode("p", _hoisted_19$a, toDisplayString$1(unref(t)("flashcard.bubbleShooter.finalScore", { score: score.value })), 1),
                  createBaseVNode("p", _hoisted_20$a, toDisplayString$1(unref(t)("flashcard.bubbleShooter.wordsMatched", { count: wordsMatched.value })), 1),
                  createBaseVNode("div", _hoisted_21$a, [
                    createBaseVNode("button", {
                      onClick: restartGame,
                      class: "px-6 py-2 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-lg font-medium transform hover:scale-105 transition-all duration-200"
                    }, toDisplayString$1(unref(t)("flashcard.bubbleShooter.playAgain", "Play Again")), 1),
                    createBaseVNode("button", {
                      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("game-complete")),
                      class: "px-6 py-2 bg-gray-500 hover:bg-gray-600 dark:bg-[#0f0f0f] dark:hover:bg-[#1a1a1a] text-white rounded-lg font-medium transform hover:scale-105 transition-all duration-200"
                    }, toDisplayString$1(unref(t)("common.finish", "Finish")), 1)
                  ])
                ])
              ])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
});

const BubbleShooterMode = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-98a69fca"]]);

const BubbleShooterMode$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: BubbleShooterMode
}, Symbol.toStringTag, { value: 'Module' }));

class SnakeStateManager {
  snake = ref({
    body: [{ x: 10, y: 10 }],
    direction: { x: 0, y: 0 },
    currentWord: ""
  });
  food = ref(null);
  secondaryFood = ref(null);
  score = ref(0);
  gameOver = ref(false);
  gameRunning = ref(false);
  currentTargetWord = ref("");
  wordsCompleted = ref(0);
  gameSpeed = ref(150);
  // milliseconds between moves
  lastEatenFoodPos = ref(null);
  lastEatenWord = ref(null);
  doubleBaitMode = ref(false);
  wrongEatenCount = ref(0);
  isLastWord = false;
  words = [];
  vietnameseMode = false;
  usedWords = /* @__PURE__ */ new Set();
  // Audio context for sound effects
  audioContext = null;
  // Timeline recording callback
  onMoveCallback;
  resetGame() {
    this.snake.value = {
      body: [{ x: 10, y: 10 }],
      direction: { x: 0, y: 0 },
      currentWord: ""
    };
    this.food.value = null;
    this.secondaryFood.value = null;
    this.score.value = 0;
    this.gameOver.value = false;
    this.gameRunning.value = false;
    this.currentTargetWord.value = "";
    this.wordsCompleted.value = 0;
    this.usedWords.clear();
    this.lastEatenFoodPos.value = null;
    this.lastEatenWord.value = null;
    this.doubleBaitMode.value = false;
    this.wrongEatenCount.value = 0;
    this.isLastWord = false;
  }
  updateDirection(direction) {
    const currentDir = this.snake.value.direction;
    if (direction.x !== -currentDir.x || direction.y !== -currentDir.y) {
      this.snake.value.direction = direction;
    }
  }
  moveSnake() {
    if (!this.gameRunning.value || this.gameOver.value) return;
    const snake = this.snake.value;
    const head = { ...snake.body[0] };
    head.x += snake.direction.x;
    head.y += snake.direction.y;
    if (head.x < 0) head.x = 29;
    else if (head.x >= 30) head.x = 0;
    if (head.y < 0) head.y = 19;
    else if (head.y >= 20) head.y = 0;
    if (this.checkCollision()) {
      this.setGameOver();
      return;
    }
    snake.body.unshift(head);
    const headNow = this.snake.value.body[0];
    const hitPrimary = this.food.value && headNow.x === this.food.value.position.x && headNow.y === this.food.value.position.y;
    const hitSecondary = this.secondaryFood.value && headNow.x === this.secondaryFood.value.position.x && headNow.y === this.secondaryFood.value.position.y;
    if (hitPrimary) {
      this.incrementScore();
      this.wordsCompleted.value++;
      if (this.food.value) {
        this.lastEatenFoodPos.value = { ...this.food.value.position };
        this.lastEatenWord.value = this.food.value.word;
      }
      this.playEatFoodSound();
      if (this.isLastWord) {
        this.setGameOver();
        return;
      }
      this.generateFood(this.words, this.vietnameseMode);
    } else if (hitSecondary) {
      this.wrongEatenCount.value++;
      if (this.secondaryFood.value) {
        this.lastEatenFoodPos.value = { ...this.secondaryFood.value.position };
        this.lastEatenWord.value = this.secondaryFood.value.word;
      }
      snake.body.pop();
      this.generateFood(this.words, this.vietnameseMode);
    } else {
      snake.body.pop();
    }
    if (this.onMoveCallback) {
      this.onMoveCallback([...snake.body.map((seg) => ({ x: seg.x, y: seg.y }))], { x: snake.direction.x, y: snake.direction.y });
    }
  }
  generateFood(words, vietnameseMode) {
    this.words = words;
    this.vietnameseMode = vietnameseMode;
    if (words.length === 0) return;
    const availableWords = words.filter((w) => !this.usedWords.has(w.word));
    if (availableWords.length === 0) {
      this.setGameOver();
      return;
    }
    const targetWord = availableWords[Math.floor(Math.random() * availableWords.length)];
    this.usedWords.add(targetWord.word);
    this.currentTargetWord.value = targetWord.word;
    const remainingWords = words.filter((w) => !this.usedWords.has(w.word));
    if (remainingWords.length === 0) {
      this.isLastWord = true;
    } else {
      this.isLastWord = false;
    }
    const randomFreePos = (blocked = []) => {
      let pos;
      do {
        pos = {
          x: Math.floor(Math.random() * 25) + 2,
          // Grid 30x20, avoid edges
          y: Math.floor(Math.random() * 15) + 2
        };
      } while (this.snake.value.body.some((seg) => seg.x === pos.x && seg.y === pos.y) || blocked.some((b) => b.x === pos.x && b.y === pos.y));
      return pos;
    };
    const primaryPos = randomFreePos();
    this.food.value = {
      position: primaryPos,
      word: targetWord.word,
      firstLetter: vietnameseMode && targetWord.meaning ? targetWord.meaning.charAt(0).toUpperCase() : targetWord.word.charAt(0).toUpperCase(),
      meaning: targetWord.meaning
    };
    if (!this.doubleBaitMode.value) {
      this.secondaryFood.value = null;
      return;
    }
    const others = words.filter((w) => w.word !== targetWord.word);
    if (others.length === 0) {
      this.secondaryFood.value = null;
      return;
    }
    const wrong = others[Math.floor(Math.random() * others.length)];
    const secondaryPos = randomFreePos([primaryPos]);
    this.secondaryFood.value = {
      position: secondaryPos,
      word: wrong.word,
      firstLetter: vietnameseMode && wrong.meaning ? wrong.meaning.charAt(0).toUpperCase() : wrong.word.charAt(0).toUpperCase(),
      meaning: wrong.meaning
    };
  }
  checkCollision() {
    const head = this.snake.value.body[0];
    for (let i = 1; i < this.snake.value.body.length; i++) {
      if (head.x === this.snake.value.body[i].x && head.y === this.snake.value.body[i].y) {
        return true;
      }
    }
    return false;
  }
  checkFoodCollision() {
    if (!this.food.value) return false;
    const head = this.snake.value.body[0];
    return head.x === this.food.value.position.x && head.y === this.food.value.position.y;
  }
  incrementScore() {
    this.score.value += 10;
  }
  setGameOver() {
    this.gameOver.value = true;
    this.gameRunning.value = false;
  }
  setGameRunning(running) {
    this.gameRunning.value = running;
  }
  setDoubleBaitMode(enabled, words, vietnameseMode) {
    this.doubleBaitMode.value = enabled;
    if (words && typeof vietnameseMode === "boolean") {
      this.generateFood(words, vietnameseMode);
      return;
    }
    if (this.gameRunning.value && !this.gameOver.value) {
      this.generateFood(this.words, this.vietnameseMode);
    }
  }
  // Set timeline recording callback
  setTimelineCallback(callback) {
    this.onMoveCallback = callback;
  }
  initializeAudioContext() {
    if (!this.audioContext) {
      try {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      } catch (error) {
        console.warn("Web Audio API not supported:", error);
      }
    }
  }
  playEatFoodSound() {
    this.initializeAudioContext();
    if (!this.audioContext) return;
    try {
      const currentTime = this.audioContext.currentTime;
      const gainNode = this.audioContext.createGain();
      gainNode.connect(this.audioContext.destination);
      const frequencies = [261.63, 329.63, 392];
      frequencies.forEach((freq, index) => {
        const oscillator = this.audioContext.createOscillator();
        const noteGain = this.audioContext.createGain();
        oscillator.connect(noteGain);
        noteGain.connect(gainNode);
        oscillator.frequency.setValueAtTime(freq, currentTime);
        oscillator.type = "sine";
        const startTime = currentTime + index * 0.08;
        const endTime = startTime + 0.15;
        noteGain.gain.setValueAtTime(0, startTime);
        noteGain.gain.linearRampToValueAtTime(0.3, startTime + 0.02);
        noteGain.gain.exponentialRampToValueAtTime(0.01, endTime);
        oscillator.start(startTime);
        oscillator.stop(endTime);
      });
    } catch (error) {
      console.warn("Error playing eat food sound:", error);
    }
  }
}

class SnakeCanvasRenderer {
  canvasWidth = ref(600);
  canvasHeight = ref(400);
  gridSize = ref(20);
  canvas = null;
  ctx = null;
  // Simple particle system for explosion effect
  particles = [];
  // Tomato juice splatter stains (fade on the floor)
  stains = [];
  // Shock rings for a juicy burst feeling
  rings = [];
  initialize(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");
    canvas.width = this.canvasWidth.value;
    canvas.height = this.canvasHeight.value;
    const resizeObserver = new ResizeObserver(() => {
      this.handleResize();
    });
    resizeObserver.observe(canvas.parentElement || canvas);
  }
  // Draw a small label with the food meaning above the tile
  drawFoodLabel(food, variant) {
    if (!this.ctx) return;
    const ctx = this.ctx;
    const gridSize = this.gridSize.value;
    const x = food.position.x * gridSize;
    const y = food.position.y * gridSize;
    const text = (food.meaning || food.word || "").toString();
    if (!text) return;
    ctx.save();
    const bg = variant === "primary" ? "#065f46" : "#7c2d12";
    const stroke = variant === "primary" ? "#10b981" : "#f59e0b";
    const textColor = "#ffffff";
    ctx.font = `${Math.max(10, Math.floor(gridSize * 0.6))}px sans-serif`;
    const paddingX = 6;
    const metrics = ctx.measureText(text);
    const textWidth = metrics.width;
    const labelWidth = textWidth + paddingX * 2;
    const labelHeight = Math.max(gridSize * 0.7, 16);
    const labelX = x + gridSize / 2 - labelWidth / 2;
    const labelY = y - labelHeight - 6;
    const r = 6;
    ctx.beginPath();
    ctx.moveTo(labelX + r, labelY);
    ctx.lineTo(labelX + labelWidth - r, labelY);
    ctx.quadraticCurveTo(labelX + labelWidth, labelY, labelX + labelWidth, labelY + r);
    ctx.lineTo(labelX + labelWidth, labelY + labelHeight - r);
    ctx.quadraticCurveTo(labelX + labelWidth, labelY + labelHeight, labelX + labelWidth - r, labelY + labelHeight);
    ctx.lineTo(labelX + r, labelY + labelHeight);
    ctx.quadraticCurveTo(labelX, labelY + labelHeight, labelX, labelY + labelHeight - r);
    ctx.lineTo(labelX, labelY + r);
    ctx.quadraticCurveTo(labelX, labelY, labelX + r, labelY);
    ctx.closePath();
    ctx.fillStyle = bg;
    ctx.fill();
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = textColor;
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";
    ctx.fillText(text, labelX + labelWidth / 2, labelY + labelHeight / 2);
    ctx.restore();
  }
  handleResize() {
    if (!this.canvas) return;
    const container = this.canvas.parentElement;
    if (container) {
      const rect = container.getBoundingClientRect();
      const aspectRatio = 30 / 20;
      let width = Math.min(rect.width - 40, 600);
      let height = width / aspectRatio;
      if (height > rect.height - 40) {
        height = rect.height - 40;
        width = height * aspectRatio;
      }
      this.canvasWidth.value = width;
      this.canvasHeight.value = height;
      this.gridSize.value = width / 30;
      this.canvas.width = width;
      this.canvas.height = height;
    }
  }
  render(stateManager) {
    if (!this.ctx) return;
    this.clearCanvas();
    this.drawGrid();
    this.updateAndDrawStains();
    this.drawFood(stateManager.food.value, "primary");
    this.drawFood(stateManager.secondaryFood?.value || null, "secondary");
    if (stateManager.doubleBaitMode?.value) {
      if (stateManager.food.value) this.drawFoodLabel(stateManager.food.value, "primary");
      if (stateManager.secondaryFood?.value) this.drawFoodLabel(stateManager.secondaryFood.value, "secondary");
    }
    this.drawSnake(stateManager.snake.value);
    if (stateManager.lastEatenFoodPos.value) {
      const gs = this.gridSize.value;
      const cx = stateManager.lastEatenFoodPos.value.x * gs + gs / 2;
      const cy = stateManager.lastEatenFoodPos.value.y * gs + gs / 2;
      this.spawnExplosion(cx, cy);
      this.spawnSplatStains(cx, cy);
      this.spawnShockRing(cx, cy);
      stateManager.lastEatenFoodPos.value = null;
    }
    this.updateAndDrawParticles();
    this.updateAndDrawRings();
  }
  clearCanvas() {
    if (!this.ctx) return;
    this.ctx.fillStyle = "#0a0a0a";
    this.ctx.fillRect(0, 0, this.canvasWidth.value, this.canvasHeight.value);
  }
  drawGrid() {
    if (!this.ctx) return;
    this.ctx.strokeStyle = "#0f0f0f";
    this.ctx.lineWidth = 1;
    const gridSize = this.gridSize.value;
    for (let x = 0; x <= 30; x++) {
      this.ctx.beginPath();
      this.ctx.moveTo(x * gridSize, 0);
      this.ctx.lineTo(x * gridSize, this.canvasHeight.value);
      this.ctx.stroke();
    }
    for (let y = 0; y <= 20; y++) {
      this.ctx.beginPath();
      this.ctx.moveTo(0, y * gridSize);
      this.ctx.lineTo(this.canvasWidth.value, y * gridSize);
      this.ctx.stroke();
    }
  }
  drawSnake(snake) {
    if (!this.ctx) return;
    const gridSize = this.gridSize.value;
    snake.body.forEach((segment, index) => {
      if (!this.ctx) return;
      if (index === 0) {
        this.ctx.fillStyle = "#10b981";
      } else {
        this.ctx.fillStyle = "#059669";
      }
      this.ctx.fillRect(
        segment.x * gridSize + 1,
        segment.y * gridSize + 1,
        gridSize - 2,
        gridSize - 2
      );
      this.ctx.strokeStyle = "#047857";
      this.ctx.lineWidth = 2;
      this.ctx.strokeRect(
        segment.x * gridSize + 1,
        segment.y * gridSize + 1,
        gridSize - 2,
        gridSize - 2
      );
    });
  }
  drawFood(food, variant = "primary") {
    if (!this.ctx || !food) return;
    const gridSize = this.gridSize.value;
    const x = food.position.x * gridSize;
    const y = food.position.y * gridSize;
    this.ctx.fillStyle = variant === "secondary" ? "#f59e0b" : "#ef4444";
    this.ctx.beginPath();
    this.ctx.arc(x + gridSize / 2, y + gridSize / 2, gridSize * 0.35, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.fillStyle = "rgba(255,255,255,0.8)";
    this.ctx.beginPath();
    this.ctx.arc(x + gridSize / 2 - 3, y + gridSize / 2 - 3, gridSize * 0.12, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.fillStyle = "#111827";
    this.ctx.font = `${Math.floor(gridSize * 0.6)}px Inter, system-ui, -apple-system, Segoe UI, Roboto`;
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "middle";
    this.ctx.fillText(
      food.firstLetter,
      x + gridSize / 2,
      y + gridSize / 2
    );
  }
  // Particle helpers
  spawnExplosion(cx, cy) {
    const colors = ["#ef4444", "#dc2626", "#f43f5e", "#f59e0b"];
    const count = 20;
    for (let i = 0; i < count; i++) {
      const angle = Math.PI * 2 * i / count;
      const speed = 5 + Math.random() * 3;
      this.particles.push({
        x: cx,
        y: cy,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 0,
        maxLife: 6 + Math.floor(Math.random() * 5),
        // very short for instant burst
        radius: 1.5 + Math.random() * 1.5,
        color: colors[Math.floor(Math.random() * colors.length)]
      });
    }
    if (this.particles.length > 300) {
      this.particles.splice(0, this.particles.length - 300);
    }
  }
  updateAndDrawParticles() {
    if (!this.ctx) return;
    const gravity = 0;
    const friction = 1;
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.vx *= friction;
      p.vy = p.vy * friction + gravity;
      p.x += p.vx;
      p.y += p.vy;
      p.life++;
      const alpha = Math.max(0, 1 - p.life / p.maxLife);
      this.ctx.globalAlpha = alpha;
      this.ctx.fillStyle = p.color;
      this.ctx.beginPath();
      this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
      this.ctx.fill();
      this.ctx.globalAlpha = 1;
      if (p.life >= p.maxLife) {
        this.particles.splice(i, 1);
      }
    }
  }
  spawnSplatStains(cx, cy) {
    const stainColors = ["#b91c1c", "#dc2626", "#ef4444"];
    const splats = 3 + Math.floor(Math.random() * 3);
    for (let i = 0; i < splats; i++) {
      const offsetR = Math.random() * 10;
      const offsetA = Math.random() * Math.PI * 2;
      const sx = cx + Math.cos(offsetA) * offsetR;
      const sy = cy + Math.sin(offsetA) * offsetR;
      this.stains.push({
        x: sx,
        y: sy,
        radius: 6 + Math.random() * 8,
        alpha: 0.6,
        decay: 0.06 + Math.random() * 0.06,
        color: stainColors[Math.floor(Math.random() * stainColors.length)]
      });
    }
    if (this.stains.length > 80) {
      this.stains.splice(0, this.stains.length - 80);
    }
  }
  updateAndDrawStains() {
    if (!this.ctx) return;
    for (let i = this.stains.length - 1; i >= 0; i--) {
      const s = this.stains[i];
      this.ctx.globalAlpha = Math.max(0, s.alpha);
      this.ctx.fillStyle = s.color;
      this.ctx.beginPath();
      this.ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
      this.ctx.fill();
      this.ctx.globalAlpha = 1;
      s.alpha -= s.decay;
      if (s.alpha <= 0) {
        this.stains.splice(i, 1);
      }
    }
  }
  spawnShockRing(cx, cy) {
    this.rings.push({
      x: cx,
      y: cy,
      r: 2,
      maxR: 28,
      life: 0,
      maxLife: 10,
      color: "#ef4444"
    });
  }
  updateAndDrawRings() {
    if (!this.ctx) return;
    for (let i = this.rings.length - 1; i >= 0; i--) {
      const ring = this.rings[i];
      ring.life++;
      const t = ring.life / ring.maxLife;
      ring.r = 2 + (ring.maxR - 2) * t;
      const alpha = Math.max(0, 1 - t);
      this.ctx.globalAlpha = alpha;
      this.ctx.strokeStyle = ring.color;
      this.ctx.lineWidth = 2;
      this.ctx.beginPath();
      this.ctx.arc(ring.x, ring.y, ring.r, 0, Math.PI * 2);
      this.ctx.stroke();
      this.ctx.globalAlpha = 1;
      if (ring.life >= ring.maxLife) {
        this.rings.splice(i, 1);
      }
    }
  }
}

class SnakeGameEngine {
  gameLoopId = ref(null);
  lastTimestamp = 0;
  accumulatorMs = 0;
  startGameLoop(stateManager, renderer) {
    if (this.gameLoopId.value) return;
    this.lastTimestamp = performance.now();
    this.accumulatorMs = 0;
    const frame = (ts) => {
      const dt = ts - this.lastTimestamp;
      this.lastTimestamp = ts;
      this.accumulatorMs += dt;
      while (stateManager.gameRunning.value && !stateManager.gameOver.value && this.accumulatorMs >= stateManager.gameSpeed.value) {
        stateManager.moveSnake();
        this.accumulatorMs -= stateManager.gameSpeed.value;
      }
      renderer.render(stateManager);
      if (stateManager.gameRunning.value && !stateManager.gameOver.value) {
        this.gameLoopId.value = requestAnimationFrame(frame);
      } else {
        this.gameLoopId.value = null;
      }
    };
    this.gameLoopId.value = requestAnimationFrame(frame);
  }
  stopGameLoop() {
    if (this.gameLoopId.value) {
      cancelAnimationFrame(this.gameLoopId.value);
      this.gameLoopId.value = null;
    }
  }
}

class SnakeGame {
  stateManager;
  canvasRenderer;
  gameEngine;
  constructor() {
    this.stateManager = new SnakeStateManager();
    this.canvasRenderer = new SnakeCanvasRenderer();
    this.gameEngine = new SnakeGameEngine();
  }
  initialize(canvas, words, vietnameseMode = false) {
    this.canvasRenderer.initialize(canvas);
    this.stateManager.resetGame();
    this.stateManager.generateFood(words, vietnameseMode);
    this.canvasRenderer.render(this.stateManager);
  }
  startGame() {
    if (this.stateManager.gameRunning.value) return;
    this.stateManager.setGameRunning(true);
    this.stateManager.updateDirection({ x: 1, y: 0 });
    this.gameEngine.startGameLoop(this.stateManager, this.canvasRenderer);
  }
  stopGame() {
    this.stateManager.setGameRunning(false);
    this.gameEngine.stopGameLoop();
  }
  handleKeyPress(event) {
    if (!this.stateManager.gameRunning.value || this.stateManager.gameOver.value) return;
    const directions = {
      ArrowUp: { x: 0, y: -1 },
      ArrowDown: { x: 0, y: 1 },
      ArrowLeft: { x: -1, y: 0 },
      ArrowRight: { x: 1, y: 0 },
      w: { x: 0, y: -1 },
      s: { x: 0, y: 1 },
      a: { x: -1, y: 0 },
      d: { x: 1, y: 0 }
    };
    const direction = directions[event.key];
    if (direction) {
      event.preventDefault();
      this.stateManager.updateDirection(direction);
    }
  }
  updateVietnameseMode(_vietnameseMode) {
    if (this.stateManager.gameRunning.value && this.stateManager.food.value) ;
  }
  cleanup() {
    this.stopGame();
  }
}

function useSnakeGame() {
  return new SnakeGame();
}

const _hoisted_1$l = { class: "snake-game h-full min-h-[600px] sm:min-h-[500px] md:min-h-0 flex flex-col" };
const _hoisted_2$i = { class: "p-4 sm:p-6 md:p-8 bg-gradient-to-r from-green-600 to-emerald-600 dark:from-green-800 dark:to-emerald-800 text-white" };
const _hoisted_3$h = { class: "flex justify-between items-center" };
const _hoisted_4$f = { class: "text-lg sm:text-xl md:text-2xl font-bold" };
const _hoisted_5$e = { class: "text-sm sm:text-base opacity-90" };
const _hoisted_6$d = { class: "text-right" };
const _hoisted_7$c = { class: "text-2xl sm:text-3xl font-bold" };
const _hoisted_8$c = { class: "text-xs sm:text-sm opacity-90" };
const _hoisted_9$c = { class: "flex-1 min-h-[450px] sm:min-h-[350px] md:min-h-0 relative bg-gradient-to-b from-gray-100 to-gray-200 dark:from-[#0a0a0a] dark:to-[#0f0f0f] overflow-hidden" };
const _hoisted_10$b = { class: "text-center" };
const _hoisted_11$b = { class: "text-sm sm:text-base font-bold text-gray-800 dark:text-white" };
const _hoisted_12$b = {
  key: 0,
  class: "text-xs sm:text-sm text-gray-700 dark:text-white/80"
};
const _hoisted_13$b = { class: "text-[11px] sm:text-xs text-gray-600 dark:text-white/70" };
const _hoisted_14$b = {
  key: 1,
  class: "absolute top-4 left-4 bg-white/90 dark:bg-[#0a0a0a]/90 rounded-lg p-3 backdrop-blur-sm"
};
const _hoisted_15$9 = { class: "text-sm text-gray-700 dark:text-white" };
const _hoisted_16$9 = { class: "font-semibold mb-1" };
const _hoisted_17$9 = { class: "text-xs space-y-1" };
const _hoisted_18$9 = { class: "absolute top-4 right-4 bg-white/90 dark:bg-[#0a0a0a]/90 rounded-lg p-3 backdrop-blur-sm" };
const _hoisted_19$9 = { class: "text-center text-sm" };
const _hoisted_20$9 = { class: "text-xs text-gray-600 dark:text-white/70" };
const _hoisted_21$9 = { class: "text-lg font-bold text-green-600 dark:text-green-400" };
const _hoisted_22$9 = {
  key: 2,
  class: "absolute inset-0 flex items-center justify-center"
};
const _hoisted_23$9 = {
  class: "lg:hidden absolute bottom-3 left-0 right-0 flex items-center justify-center select-none",
  "aria-hidden": "false"
};
const _hoisted_24$8 = { class: "inline-flex flex-col items-center gap-2 bg-white/90 dark:bg-[#0a0a0a]/90 border border-gray-200 dark:border-[#0f0f0f] rounded-xl p-3 shadow-lg" };
const _hoisted_25$8 = ["aria-label"];
const _hoisted_26$7 = { class: "flex items-center gap-2" };
const _hoisted_27$7 = ["aria-label"];
const _hoisted_28$7 = ["aria-label"];
const _hoisted_29$6 = ["aria-label"];
const _hoisted_30$5 = {
  key: 0,
  class: "absolute inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center p-4"
};
const _hoisted_31$5 = { class: "bg-white dark:bg-[#0a0a0a] rounded-2xl p-6 sm:p-8 max-w-md w-full text-center shadow-2xl border border-gray-200 dark:border-[#0f0f0f]" };
const _hoisted_32$4 = { class: "text-xl sm:text-2xl font-bold mb-2 text-gray-800 dark:text-white" };
const _hoisted_33$4 = { class: "text-gray-600 dark:text-white/70 mb-4" };
const _hoisted_34$4 = { class: "text-sm text-gray-500 dark:text-white/60 mb-6" };
const _hoisted_35$4 = { class: "flex gap-3 justify-center" };
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "SnakeGameMode",
  props: {
    words: {},
    vietnameseMode: { type: Boolean },
    doubleBaitMode: { type: Boolean },
    recordTimeline: { type: Boolean }
  },
  emits: ["game-complete", "correct-food-eaten", "wrong-food-eaten"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const { t } = useI18n();
    const emit = __emit;
    const game = useSnakeGame();
    const gameCanvas = ref();
    computed(() => game.canvasRenderer.canvasWidth.value);
    computed(() => game.canvasRenderer.canvasHeight.value);
    const gridSize = computed(() => game.canvasRenderer.gridSize.value);
    const score = computed(() => game.stateManager.score.value);
    const wordsCompleted = computed(() => game.stateManager.wordsCompleted.value);
    const gameOver = computed(() => game.stateManager.gameOver.value);
    const gameRunning = computed(() => game.stateManager.gameRunning.value);
    const currentTargetWord = computed(() => game.stateManager.currentTargetWord.value);
    const snakeHead = computed(() => game.stateManager.snake.value.body[0]);
    const timelineFrames = ref([]);
    const handleTimelineFrame = (body, direction) => {
      if (!props.recordTimeline) return;
      timelineFrames.value.push({
        body: [...body],
        direction: { ...direction }
      });
    };
    watch(
      () => props.recordTimeline,
      (enabled) => {
        if (enabled) {
          game.stateManager.setTimelineCallback(handleTimelineFrame);
          timelineFrames.value = [];
        } else {
          game.stateManager.setTimelineCallback(void 0);
          timelineFrames.value = [];
        }
      }
    );
    const snakeHeadDisplayStyle = computed(() => {
      if (!snakeHead.value || !gameRunning.value) {
        return { display: "none" };
      }
      const x = snakeHead.value.x * gridSize.value + gridSize.value / 2;
      const y = snakeHead.value.y * gridSize.value - 40;
      return {
        left: `${x}px`,
        top: `${y}px`,
        transform: "translateX(-50%)",
        zIndex: "10"
      };
    });
    const currentTargetPronunciation = computed(() => {
      const w = currentTargetWord.value;
      if (!w) return "";
      const found = props.words.find((v) => v.word === w);
      return found?.pronunciation || "";
    });
    const currentTargetPronunciationDisplay = computed(() => {
      const raw = (currentTargetPronunciation.value || "").trim();
      if (!raw) return "";
      const stripped = raw.replace(/^\s*[\/\[\]()]+|[\/\[\]()]+\s*$/g, "");
      return stripped ? `/${stripped}/` : "";
    });
    const prevWordsCompleted = ref(0);
    const stopWordsWatch = watch(
      () => game.stateManager.wordsCompleted.value,
      (newVal, oldVal) => {
        if (typeof oldVal === "number" && newVal > oldVal) {
          const lastWord = game.stateManager.lastEatenWord?.value || "";
          const lastPosition = game.stateManager.lastEatenFoodPos?.value || { x: 0, y: 0 };
          const currentVocab = props.words.find((w) => w.word === lastWord);
          const details = {
            word: lastWord,
            meaningShort: currentVocab?.meaning || lastWord,
            position: lastPosition,
            snakeLength: game.stateManager.snake.value.body.length,
            gameScore: game.stateManager.score.value,
            wordsCompleted: game.stateManager.wordsCompleted.value,
            wrongEatenCount: game.stateManager.wrongEatenCount?.value ?? 0,
            snakeBody: [...game.stateManager.snake.value.body],
            direction: { ...game.stateManager.snake.value.direction },
            timelineFrames: props.recordTimeline && timelineFrames.value.length ? [...timelineFrames.value.map((f) => ({
              body: f.body.map((seg) => ({ x: seg.x, y: seg.y })),
              direction: { x: f.direction.x, y: f.direction.y }
            }))] : void 0
          };
          console.log("[DEBUG] Snake correct food details:", details);
          console.log("[DEBUG] Snake body:", details.snakeBody);
          console.log("[DEBUG] Snake direction:", details.direction);
          emit("correct-food-eaten", details);
          if (props.recordTimeline) timelineFrames.value = [];
          if (lastWord) {
            const { playAudio } = useVoiceStore();
            playAudio(lastWord).catch(() => {
            });
          }
        }
        prevWordsCompleted.value = newVal;
      }
    );
    const prevWrongEaten = ref(0);
    const stopWrongWatch = watch(
      () => game.stateManager.wrongEatenCount?.value,
      (newVal, oldVal) => {
        if (typeof newVal === "number" && typeof oldVal === "number" && newVal > oldVal) {
          const lastWord = game.stateManager.lastEatenWord?.value || "";
          const lastPosition = game.stateManager.lastEatenFoodPos?.value || { x: 0, y: 0 };
          const currentVocab = props.words.find((w) => w.word === lastWord);
          const details = {
            word: lastWord,
            meaningShort: currentVocab?.meaning || lastWord,
            position: lastPosition,
            snakeLength: game.stateManager.snake.value.body.length,
            gameScore: game.stateManager.score.value,
            wordsCompleted: game.stateManager.wordsCompleted.value,
            wrongEatenCount: newVal,
            snakeBody: [...game.stateManager.snake.value.body],
            direction: { ...game.stateManager.snake.value.direction },
            timelineFrames: props.recordTimeline && timelineFrames.value.length ? [...timelineFrames.value.map((f) => ({
              body: f.body.map((seg) => ({ x: seg.x, y: seg.y })),
              direction: { x: f.direction.x, y: f.direction.y }
            }))] : void 0
          };
          emit("wrong-food-eaten", details);
          if (props.recordTimeline) timelineFrames.value = [];
          if (lastWord) {
            const { playAudio } = useVoiceStore();
            playAudio(lastWord).catch(() => {
            });
          }
        }
        if (typeof newVal === "number") prevWrongEaten.value = newVal;
      }
    );
    const stopGameOverWatch = watch(
      () => game.stateManager.gameOver.value,
      (isGameOver) => {
        if (isGameOver) {
          emit("game-complete");
        }
      }
    );
    watch(() => props.vietnameseMode, (newValue) => {
      game.updateVietnameseMode(newValue ?? false);
      if (game.stateManager.gameRunning.value) {
        game.stateManager.generateFood(props.words, newValue ?? false);
      }
    });
    watch(() => props.doubleBaitMode, (enabled) => {
      if (game.stateManager.setDoubleBaitMode) {
        game.stateManager.setDoubleBaitMode(!!enabled, props.words, props.vietnameseMode ?? false);
      }
    });
    const focusCanvas = () => {
      if (gameCanvas.value) {
        gameCanvas.value.focus();
      }
    };
    const startGame = () => {
      game.startGame();
      focusCanvas();
    };
    const restartGame = () => {
      game.stopGame();
      game.stateManager.resetGame();
      if (gameCanvas.value) {
        game.initialize(gameCanvas.value, props.words, props.vietnameseMode);
        if (game.stateManager.setDoubleBaitMode) {
          game.stateManager.setDoubleBaitMode(!!props.doubleBaitMode, props.words, props.vietnameseMode ?? false);
        }
        if (props.recordTimeline) {
          game.stateManager.setTimelineCallback(handleTimelineFrame);
        } else {
          game.stateManager.setTimelineCallback(void 0);
        }
      }
    };
    const handleKeyPress = (event) => {
      game.handleKeyPress(event);
    };
    const changeDirection = (dx, dy) => {
      if (gameOver.value) return;
      const notRunning = !gameRunning.value;
      if (notRunning) {
        game.startGame();
      }
      game.stateManager.updateDirection({ x: dx, y: dy });
    };
    onMounted(async () => {
      await nextTick();
      if (!gameCanvas.value) return;
      game.initialize(gameCanvas.value, props.words, props.vietnameseMode);
      if (game.stateManager.setDoubleBaitMode) {
        game.stateManager.setDoubleBaitMode(!!props.doubleBaitMode, props.words, props.vietnameseMode ?? false);
      }
      if (props.recordTimeline) {
        game.stateManager.setTimelineCallback(handleTimelineFrame);
      } else {
        game.stateManager.setTimelineCallback(void 0);
      }
      document.addEventListener("keydown", handleKeyPress);
    });
    onUnmounted(() => {
      stopGameOverWatch();
      stopWordsWatch();
      stopWrongWatch();
      document.removeEventListener("keydown", handleKeyPress);
      game.cleanup();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$l, [
        createBaseVNode("div", _hoisted_2$i, [
          createBaseVNode("div", _hoisted_3$h, [
            createBaseVNode("div", null, [
              createBaseVNode("h2", _hoisted_4$f, toDisplayString$1(unref(t)("flashcard.snakeGame.title", "Snake Hunt")), 1),
              createBaseVNode("p", _hoisted_5$e, toDisplayString$1(unref(t)("flashcard.snakeGame.instruction", "Guide the snake to catch vocabulary letters!")), 1)
            ]),
            createBaseVNode("div", _hoisted_6$d, [
              createBaseVNode("div", _hoisted_7$c, toDisplayString$1(score.value), 1),
              createBaseVNode("div", _hoisted_8$c, toDisplayString$1(unref(t)("flashcard.snakeGame.score", "Score")), 1)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_9$c, [
          createBaseVNode("canvas", {
            ref_key: "gameCanvas",
            ref: gameCanvas,
            class: "w-full h-full border-2 border-gray-300 dark:border-[#0f0f0f]",
            tabindex: "0",
            onKeydown: handleKeyPress
          }, null, 544),
          currentTargetWord.value && gameRunning.value && !gameOver.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "absolute bg-white dark:bg-[#0a0a0a] rounded-lg px-3 py-2 shadow-lg border-2 border-green-500 pointer-events-none",
            style: normalizeStyle(snakeHeadDisplayStyle.value)
          }, [
            createBaseVNode("div", _hoisted_10$b, [
              createBaseVNode("div", _hoisted_11$b, toDisplayString$1(currentTargetWord.value), 1),
              currentTargetPronunciationDisplay.value ? (openBlock(), createElementBlock("div", _hoisted_12$b, toDisplayString$1(currentTargetPronunciationDisplay.value), 1)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_13$b, toDisplayString$1(unref(t)("flashcard.snakeGame.target", "Target")), 1)
            ])
          ], 4)) : createCommentVNode("", true),
          !gameRunning.value && !gameOver.value ? (openBlock(), createElementBlock("div", _hoisted_14$b, [
            createBaseVNode("div", _hoisted_15$9, [
              createBaseVNode("div", _hoisted_16$9, toDisplayString$1(unref(t)("flashcard.snakeGame.controls", "Controls")) + ":", 1),
              createBaseVNode("div", _hoisted_17$9, [
                createBaseVNode("div", null, toDisplayString$1(unref(t)("flashcard.snakeGame.arrowKeys", "Arrow Keys / WASD")), 1),
                createBaseVNode("div", null, toDisplayString$1(unref(t)("flashcard.snakeGame.clickToStart", "Click START to begin")), 1)
              ])
            ])
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_18$9, [
            createBaseVNode("div", _hoisted_19$9, [
              createBaseVNode("div", _hoisted_20$9, toDisplayString$1(unref(t)("flashcard.snakeGame.completed", "Completed")), 1),
              createBaseVNode("div", _hoisted_21$9, toDisplayString$1(wordsCompleted.value), 1)
            ])
          ]),
          !gameRunning.value && !gameOver.value ? (openBlock(), createElementBlock("div", _hoisted_22$9, [
            createBaseVNode("button", {
              onClick: startGame,
              class: "px-8 py-4 bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white rounded-2xl font-bold text-lg transform hover:scale-105 transition-all duration-200 shadow-2xl"
            }, toDisplayString$1(unref(t)("flashcard.snakeGame.start", "START HUNT")), 1)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_23$9, [
            createBaseVNode("div", _hoisted_24$8, [
              createBaseVNode("button", {
                type: "button",
                "aria-label": unref(t)("flashcard.snakeGame.up", "Up"),
                class: "w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 rounded-lg flex items-center justify-center bg-emerald-500 hover:bg-emerald-600 text-white shadow active:scale-95 transition",
                onClick: _cache[0] || (_cache[0] = ($event) => changeDirection(0, -1))
              }, _cache[5] || (_cache[5] = [
                createBaseVNode("svg", {
                  class: "w-6 h-6 sm:w-7 sm:h-7",
                  viewBox: "0 0 20 20",
                  fill: "currentColor"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M10 4a.75.75 0 01.53.22l5 5a.75.75 0 11-1.06 1.06L10.75 6.56V16a.75.75 0 01-1.5 0V6.56L5.53 10.28a.75.75 0 01-1.06-1.06l5-5A.75.75 0 0110 4z",
                    "clip-rule": "evenodd"
                  })
                ], -1)
              ]), 8, _hoisted_25$8),
              createBaseVNode("div", _hoisted_26$7, [
                createBaseVNode("button", {
                  type: "button",
                  "aria-label": unref(t)("flashcard.snakeGame.left", "Left"),
                  class: "w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 rounded-lg flex items-center justify-center bg-emerald-500 hover:bg-emerald-600 text-white shadow active:scale-95 transition",
                  onClick: _cache[1] || (_cache[1] = ($event) => changeDirection(-1, 0))
                }, _cache[6] || (_cache[6] = [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 sm:w-7 sm:h-7",
                    viewBox: "0 0 20 20",
                    fill: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M4 10a.75.75 0 01.22-.53l5-5a.75.75 0 111.06 1.06L6.56 9.25H16a.75.75 0 010 1.5H6.56l3.72 3.72a.75.75 0 11-1.06 1.06l-5-5A.75.75 0 014 10z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)
                ]), 8, _hoisted_27$7),
                createBaseVNode("button", {
                  type: "button",
                  "aria-label": unref(t)("flashcard.snakeGame.down", "Down"),
                  class: "w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 rounded-lg flex items-center justify-center bg-emerald-500 hover:bg-emerald-600 text-white shadow active:scale-95 transition",
                  onClick: _cache[2] || (_cache[2] = ($event) => changeDirection(0, 1))
                }, _cache[7] || (_cache[7] = [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 sm:w-7 sm:h-7",
                    viewBox: "0 0 20 20",
                    fill: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M10 16a.75.75 0 01-.53-.22l-5-5a.75.75 0 111.06-1.06l3.72 3.72V4a.75.75 0 011.5 0v9.44l3.72-3.72a.75.75 0 111.06 1.06l-5 5A.75.75 0 0110 16z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)
                ]), 8, _hoisted_28$7),
                createBaseVNode("button", {
                  type: "button",
                  "aria-label": unref(t)("flashcard.snakeGame.right", "Right"),
                  class: "w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 rounded-lg flex items-center justify-center bg-emerald-500 hover:bg-emerald-600 text-white shadow active:scale-95 transition",
                  onClick: _cache[3] || (_cache[3] = ($event) => changeDirection(1, 0))
                }, _cache[8] || (_cache[8] = [
                  createBaseVNode("svg", {
                    class: "w-6 h-6 sm:w-7 sm:h-7",
                    viewBox: "0 0 20 20",
                    fill: "currentColor"
                  }, [
                    createBaseVNode("path", {
                      "fill-rule": "evenodd",
                      d: "M16 10a.75.75 0 01-.22.53l-5 5a.75.75 0 11-1.06-1.06l3.72-3.72H4a.75.75 0 010-1.5h9.44L9.72 5.53a.75.75 0 111.06-1.06l5 5c.14.14.22.33.22.53z",
                      "clip-rule": "evenodd"
                    })
                  ], -1)
                ]), 8, _hoisted_29$6)
              ])
            ])
          ]),
          createVNode(Transition, {
            name: "modal",
            appear: ""
          }, {
            default: withCtx(() => [
              gameOver.value ? (openBlock(), createElementBlock("div", _hoisted_30$5, [
                createBaseVNode("div", _hoisted_31$5, [
                  _cache[9] || (_cache[9] = createBaseVNode("div", { class: "w-16 h-16 sm:w-20 sm:h-20 mx-auto mb-4 bg-gradient-to-r from-green-400 to-emerald-500 rounded-full flex items-center justify-center animate-pulse" }, [
                    createBaseVNode("svg", {
                      class: "w-8 h-8 sm:w-10 sm:h-10 text-white",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                        "clip-rule": "evenodd"
                      })
                    ])
                  ], -1)),
                  createBaseVNode("h3", _hoisted_32$4, toDisplayString$1(unref(t)("flashcard.snakeGame.gameComplete", "Hunt Complete!")), 1),
                  createBaseVNode("p", _hoisted_33$4, toDisplayString$1(unref(t)("flashcard.snakeGame.finalScore", { score: score.value }, `Final Score: ${score.value}`)), 1),
                  createBaseVNode("p", _hoisted_34$4, toDisplayString$1(unref(t)("flashcard.snakeGame.wordsHunted", { count: wordsCompleted.value }, `Words hunted: ${wordsCompleted.value}`)), 1),
                  createBaseVNode("div", _hoisted_35$4, [
                    createBaseVNode("button", {
                      onClick: restartGame,
                      class: "px-6 py-2 bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white rounded-lg font-medium transform hover:scale-105 transition-all duration-200"
                    }, toDisplayString$1(unref(t)("flashcard.snakeGame.playAgain", "Hunt Again")), 1),
                    createBaseVNode("button", {
                      onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("game-complete")),
                      class: "px-6 py-2 bg-gray-500 hover:bg-gray-600 dark:bg-[#0f0f0f] dark:hover:bg-[#1a1a1a] text-white rounded-lg font-medium transform hover:scale-105 transition-all duration-200"
                    }, toDisplayString$1(unref(t)("common.finish", "Finish")), 1)
                  ])
                ])
              ])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
});

const SnakeGameMode = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__scopeId", "data-v-43ecfa73"]]);

const SnakeGameMode$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: SnakeGameMode
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$k = { class: "bg-white dark:bg-[#0a0a0a] shadow" };
const _hoisted_2$h = { class: "max-w-4xl mx-auto py-6 px-4 sm:px-6 lg:px-8" };
const _hoisted_3$g = { class: "flex items-center justify-between" };
const _hoisted_4$e = { class: "flex items-center" };
const _hoisted_5$d = { class: "flex items-center space-x-4" };
const _hoisted_6$c = { class: "text-right" };
const _hoisted_7$b = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_8$b = { class: "text-right" };
const _hoisted_9$b = { class: "text-lg font-semibold text-gray-900 dark:text-white" };
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "QuizHeader",
  props: {
    timeRemaining: {},
    score: {}
  },
  emits: ["go-back"],
  setup(__props, { emit: __emit }) {
    const formatTime = (seconds) => {
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      return `${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$k, [
        createBaseVNode("div", _hoisted_2$h, [
          createBaseVNode("div", _hoisted_3$g, [
            createBaseVNode("div", _hoisted_4$e, [
              createBaseVNode("button", {
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("go-back")),
                class: "mr-4 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
              }, _cache[1] || (_cache[1] = [
                createBaseVNode("svg", {
                  class: "w-6 h-6",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                    "clip-rule": "evenodd"
                  })
                ], -1)
              ])),
              _cache[2] || (_cache[2] = createBaseVNode("div", null, [
                createBaseVNode("h1", { class: "text-3xl font-bold text-gray-900 dark:text-white" }, "Quiz"),
                createBaseVNode("p", { class: "mt-2 text-sm text-gray-600 dark:text-gray-400" }, "Kim tra kin thc ca bn")
              ], -1))
            ]),
            createBaseVNode("div", _hoisted_5$d, [
              createBaseVNode("div", _hoisted_6$c, [
                _cache[3] || (_cache[3] = createBaseVNode("p", { class: "text-sm text-gray-500 dark:text-gray-400" }, "Thi gian", -1)),
                createBaseVNode("p", _hoisted_7$b, toDisplayString$1(formatTime(_ctx.timeRemaining)), 1)
              ]),
              createBaseVNode("div", _hoisted_8$b, [
                _cache[4] || (_cache[4] = createBaseVNode("p", { class: "text-sm text-gray-500 dark:text-gray-400" }, "im", -1)),
                createBaseVNode("p", _hoisted_9$b, toDisplayString$1(_ctx.score), 1)
              ])
            ])
          ])
        ])
      ]);
    };
  }
});

const QuizHeader = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$k
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$j = { class: "max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-4" };
const _hoisted_2$g = { class: "flex justify-between text-sm text-gray-600 dark:text-gray-400 mb-2" };
const _hoisted_3$f = { class: "w-full bg-gray-200 rounded-full h-2" };
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "QuizProgress",
  props: {
    currentQuestionIndex: {},
    totalQuestions: {},
    progressPercentage: {}
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$j, [
        createBaseVNode("div", _hoisted_2$g, [
          createBaseVNode("span", null, toDisplayString$1(unref(t)("quiz.progress.question")) + " " + toDisplayString$1(_ctx.currentQuestionIndex + 1) + " / " + toDisplayString$1(_ctx.totalQuestions), 1),
          createBaseVNode("span", null, toDisplayString$1(Math.round(_ctx.progressPercentage)) + "%", 1)
        ]),
        createBaseVNode("div", _hoisted_3$f, [
          createBaseVNode("div", {
            class: "bg-purple-500 h-2 rounded-full transition-all duration-300",
            style: normalizeStyle({ width: _ctx.progressPercentage + "%" })
          }, null, 4)
        ])
      ]);
    };
  }
});

const QuizProgress = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$j
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$i = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg p-8 border border-gray-200 dark:border-gray-700" };
const _hoisted_2$f = { class: "text-center mb-8" };
const _hoisted_3$e = { class: "text-2xl font-bold text-gray-900 dark:text-white mb-4" };
const _hoisted_4$d = { class: "text-gray-600 dark:text-gray-400" };
const _hoisted_5$c = { class: "grid grid-cols-1 md:grid-cols-2 gap-6 mb-8" };
const _hoisted_6$b = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_7$a = { value: "vocabulary" };
const _hoisted_8$a = { value: "grammar" };
const _hoisted_9$a = { value: "mixed" };
const _hoisted_10$a = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_11$a = { value: "" };
const _hoisted_12$a = ["value"];
const _hoisted_13$a = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_14$a = { value: "5" };
const _hoisted_15$8 = { value: "10" };
const _hoisted_16$8 = { value: "15" };
const _hoisted_17$8 = { value: "20" };
const _hoisted_18$8 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" };
const _hoisted_19$8 = { value: "0" };
const _hoisted_20$8 = { value: "5" };
const _hoisted_21$8 = { value: "10" };
const _hoisted_22$8 = { value: "15" };
const _hoisted_23$8 = { class: "text-center" };
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "QuizSetup",
  props: {
    settings: {},
    availableLevels: {}
  },
  emits: ["start-quiz"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const localSettings = ref({ ...props.settings });
    watch(localSettings, (newSettings) => {
      emit("start-quiz", newSettings);
    }, { deep: true });
    const handleStartQuiz = () => {
      emit("start-quiz", localSettings.value);
    };
    const getLevelText = (level) => {
      switch (level) {
        case "beginner":
          return t("levels.beginner");
        case "intermediate":
          return t("levels.intermediate");
        case "advanced":
          return t("levels.advanced");
        default:
          return level;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$i, [
        createBaseVNode("div", _hoisted_2$f, [
          createBaseVNode("h2", _hoisted_3$e, toDisplayString$1(unref(t)("quiz.setup.title")), 1),
          createBaseVNode("p", _hoisted_4$d, toDisplayString$1(unref(t)("quiz.setup.description")), 1)
        ]),
        createBaseVNode("div", _hoisted_5$c, [
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_6$b, toDisplayString$1(unref(t)("quiz.setup.type")), 1),
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => localSettings.value.type = $event),
              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white"
            }, [
              createBaseVNode("option", _hoisted_7$a, toDisplayString$1(unref(t)("quiz.types.vocabulary")), 1),
              createBaseVNode("option", _hoisted_8$a, toDisplayString$1(unref(t)("quiz.types.grammar")), 1),
              createBaseVNode("option", _hoisted_9$a, toDisplayString$1(unref(t)("quiz.types.mixed")), 1)
            ], 512), [
              [vModelSelect, localSettings.value.type]
            ])
          ]),
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_10$a, toDisplayString$1(unref(t)("quiz.setup.level")), 1),
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => localSettings.value.level = $event),
              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white"
            }, [
              createBaseVNode("option", _hoisted_11$a, toDisplayString$1(unref(t)("quiz.setup.allLevels")), 1),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.availableLevels, (level) => {
                return openBlock(), createElementBlock("option", {
                  key: level,
                  value: level
                }, toDisplayString$1(getLevelText(level)), 9, _hoisted_12$a);
              }), 128))
            ], 512), [
              [vModelSelect, localSettings.value.level]
            ])
          ]),
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_13$a, toDisplayString$1(unref(t)("quiz.setup.questionCount")), 1),
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => localSettings.value.questionCount = $event),
              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white"
            }, [
              createBaseVNode("option", _hoisted_14$a, "5 " + toDisplayString$1(unref(t)("quiz.progress.question").toLowerCase()), 1),
              createBaseVNode("option", _hoisted_15$8, "10 " + toDisplayString$1(unref(t)("quiz.progress.question").toLowerCase()), 1),
              createBaseVNode("option", _hoisted_16$8, "15 " + toDisplayString$1(unref(t)("quiz.progress.question").toLowerCase()), 1),
              createBaseVNode("option", _hoisted_17$8, "20 " + toDisplayString$1(unref(t)("quiz.progress.question").toLowerCase()), 1)
            ], 512), [
              [vModelSelect, localSettings.value.questionCount]
            ])
          ]),
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_18$8, toDisplayString$1(unref(t)("quiz.setup.timeLimit")), 1),
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => localSettings.value.timeLimit = $event),
              class: "w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white"
            }, [
              createBaseVNode("option", _hoisted_19$8, toDisplayString$1(unref(t)("quiz.setup.unlimited")), 1),
              createBaseVNode("option", _hoisted_20$8, "5 " + toDisplayString$1(unref(t)("common.minutes")), 1),
              createBaseVNode("option", _hoisted_21$8, "10 " + toDisplayString$1(unref(t)("common.minutes")), 1),
              createBaseVNode("option", _hoisted_22$8, "15 " + toDisplayString$1(unref(t)("common.minutes")), 1)
            ], 512), [
              [vModelSelect, localSettings.value.timeLimit]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_23$8, [
          createBaseVNode("button", {
            onClick: handleStartQuiz,
            class: "bg-purple-500 hover:bg-purple-600 text-white font-medium py-3 px-8 rounded-lg transition-colors"
          }, toDisplayString$1(unref(t)("quiz.setup.start")), 1)
        ])
      ]);
    };
  }
});

const QuizSetup = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$i
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$h = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg p-8 border border-gray-200 dark:border-gray-700" };
const _hoisted_2$e = { class: "mb-8" };
const _hoisted_3$d = { class: "flex items-center justify-between mb-4" };
const _hoisted_4$c = { class: "px-3 py-1 bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200 text-sm font-medium rounded-full" };
const _hoisted_5$b = { class: "text-xl font-semibold text-gray-900 dark:text-white mb-6" };
const _hoisted_6$a = { class: "space-y-3" };
const _hoisted_7$9 = ["onClick"];
const _hoisted_8$9 = { class: "flex items-center" };
const _hoisted_9$9 = {
  key: 0,
  class: "text-white text-sm font-bold"
};
const _hoisted_10$9 = {
  key: 1,
  class: "text-gray-500 text-sm font-bold"
};
const _hoisted_11$9 = { class: "text-gray-900 dark:text-white" };
const _hoisted_12$9 = { class: "flex justify-between" };
const _hoisted_13$9 = ["disabled"];
const _hoisted_14$9 = ["disabled"];
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "QuizQuestion",
  props: {
    question: {},
    selectedAnswer: {},
    isFirstQuestion: { type: Boolean },
    isLastQuestion: { type: Boolean }
  },
  emits: ["select-answer", "previous-question", "next-question"],
  setup(__props, { emit: __emit }) {
    const getLevelColor = (level) => {
      switch (level) {
        case "beginner":
          return "bg-green-100 text-green-800";
        case "intermediate":
          return "bg-yellow-100 text-yellow-800";
        case "advanced":
          return "bg-red-100 text-red-800";
        default:
          return "bg-gray-100 text-gray-800";
      }
    };
    const { t } = useI18n();
    const getLevelText = (level) => {
      switch (level) {
        case "beginner":
          return t("levels.beginner");
        case "intermediate":
          return t("levels.intermediate");
        case "advanced":
          return t("levels.advanced");
        default:
          return level;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$h, [
        createBaseVNode("div", _hoisted_2$e, [
          createBaseVNode("div", _hoisted_3$d, [
            createBaseVNode("span", _hoisted_4$c, toDisplayString$1(_ctx.question.type === "vocabulary" ? unref(t)("quiz.types.vocabulary") : unref(t)("quiz.types.grammar")), 1),
            createBaseVNode("span", {
              class: normalizeClass([getLevelColor(_ctx.question.level), "px-3 py-1 text-sm font-medium rounded-full"])
            }, toDisplayString$1(getLevelText(_ctx.question.level)), 3)
          ]),
          createBaseVNode("h3", _hoisted_5$b, toDisplayString$1(_ctx.question.question), 1),
          createBaseVNode("div", _hoisted_6$a, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.question.options, (option, index) => {
              return openBlock(), createElementBlock("div", {
                key: index,
                onClick: ($event) => _ctx.$emit("select-answer", index),
                class: normalizeClass([
                  "p-4 border-2 rounded-lg cursor-pointer transition-all",
                  _ctx.selectedAnswer === index ? "border-purple-500 bg-purple-50 dark:bg-purple-900/20" : "border-gray-200 dark:border-gray-600 hover:border-gray-300 dark:hover:border-gray-500 hover:bg-gray-50 dark:hover:bg-gray-800"
                ])
              }, [
                createBaseVNode("div", _hoisted_8$9, [
                  createBaseVNode("div", {
                    class: normalizeClass([
                      "w-6 h-6 rounded-full border-2 mr-3 flex items-center justify-center",
                      _ctx.selectedAnswer === index ? "border-purple-500 bg-purple-500" : "border-gray-300"
                    ])
                  }, [
                    _ctx.selectedAnswer === index ? (openBlock(), createElementBlock("span", _hoisted_9$9, toDisplayString$1(String.fromCharCode(65 + index)), 1)) : (openBlock(), createElementBlock("span", _hoisted_10$9, toDisplayString$1(String.fromCharCode(65 + index)), 1))
                  ], 2),
                  createBaseVNode("span", _hoisted_11$9, toDisplayString$1(option), 1)
                ])
              ], 10, _hoisted_7$9);
            }), 128))
          ])
        ]),
        createBaseVNode("div", _hoisted_12$9, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("previous-question")),
            disabled: _ctx.isFirstQuestion,
            class: "bg-gray-500 hover:bg-gray-600 disabled:bg-gray-300 text-white font-medium py-2 px-6 rounded-lg transition-colors"
          }, toDisplayString$1(unref(t)("quiz.navigation.previous")), 9, _hoisted_13$9),
          createBaseVNode("button", {
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("next-question")),
            disabled: _ctx.selectedAnswer === null,
            class: "bg-purple-500 hover:bg-purple-600 disabled:bg-purple-300 text-white font-medium py-2 px-6 rounded-lg transition-colors"
          }, toDisplayString$1(_ctx.isLastQuestion ? unref(t)("quiz.navigation.finish") : unref(t)("quiz.navigation.next")), 9, _hoisted_14$9)
        ])
      ]);
    };
  }
});

const QuizQuestion = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$h
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$g = { class: "bg-white dark:bg-[#0a0a0a] rounded-xl shadow-lg p-8 border border-gray-200 dark:border-gray-700" };
const _hoisted_2$d = { class: "text-center mb-8" };
const _hoisted_3$c = { class: "text-3xl font-bold text-gray-900 dark:text-white mb-2" };
const _hoisted_4$b = { class: "text-gray-600 dark:text-gray-400" };
const _hoisted_5$a = { class: "grid grid-cols-1 md:grid-cols-3 gap-6 mb-8" };
const _hoisted_6$9 = { class: "text-center p-6 bg-green-50 dark:bg-green-900/20 rounded-lg" };
const _hoisted_7$8 = { class: "text-3xl font-bold text-green-600 dark:text-green-400" };
const _hoisted_8$8 = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_9$8 = { class: "text-center p-6 bg-blue-50 dark:bg-blue-900/20 rounded-lg" };
const _hoisted_10$8 = { class: "text-3xl font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_11$8 = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_12$8 = { class: "text-center p-6 bg-purple-50 dark:bg-purple-900/20 rounded-lg" };
const _hoisted_13$8 = { class: "text-3xl font-bold text-purple-600 dark:text-purple-400" };
const _hoisted_14$8 = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_15$7 = { class: "text-center mb-8" };
const _hoisted_16$7 = { class: "mb-8" };
const _hoisted_17$7 = { class: "text-lg font-semibold text-gray-900 dark:text-white mb-4" };
const _hoisted_18$7 = { class: "space-y-4" };
const _hoisted_19$7 = { class: "flex items-start justify-between mb-2" };
const _hoisted_20$7 = { class: "font-medium text-gray-900 dark:text-white" };
const _hoisted_21$7 = {
  key: 0,
  class: "text-green-600"
};
const _hoisted_22$7 = {
  key: 1,
  class: "text-red-600"
};
const _hoisted_23$7 = { class: "text-sm text-gray-600 dark:text-gray-400 mb-1" };
const _hoisted_24$7 = { class: "font-medium" };
const _hoisted_25$7 = {
  key: 0,
  class: "text-sm text-red-600"
};
const _hoisted_26$6 = { class: "font-medium" };
const _hoisted_27$6 = {
  key: 1,
  class: "text-sm text-gray-500 mt-2"
};
const _hoisted_28$6 = { class: "font-medium" };
const _hoisted_29$5 = { class: "flex justify-center space-x-4" };
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "QuizResults",
  props: {
    questions: {},
    userAnswers: {},
    score: {},
    correctAnswers: {},
    totalQuestions: {},
    accuracy: {}
  },
  emits: ["restart-quiz", "go-back"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$g, [
        createBaseVNode("div", _hoisted_2$d, [
          _cache[2] || (_cache[2] = createBaseVNode("div", { class: "mx-auto flex items-center justify-center h-16 w-16 rounded-full bg-green-100 dark:bg-green-900 mb-4" }, [
            createBaseVNode("svg", {
              class: "h-8 w-8 text-green-600 dark:text-green-400",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                "clip-rule": "evenodd"
              })
            ])
          ], -1)),
          createBaseVNode("h2", _hoisted_3$c, toDisplayString$1(unref(t)("quiz.results.completed")), 1),
          createBaseVNode("p", _hoisted_4$b, toDisplayString$1(unref(t)("quiz.results.yourResults")), 1)
        ]),
        createBaseVNode("div", _hoisted_5$a, [
          createBaseVNode("div", _hoisted_6$9, [
            createBaseVNode("p", _hoisted_7$8, toDisplayString$1(_ctx.score), 1),
            createBaseVNode("p", _hoisted_8$8, toDisplayString$1(unref(t)("quiz.results.score")), 1)
          ]),
          createBaseVNode("div", _hoisted_9$8, [
            createBaseVNode("p", _hoisted_10$8, toDisplayString$1(_ctx.correctAnswers) + "/" + toDisplayString$1(_ctx.totalQuestions), 1),
            createBaseVNode("p", _hoisted_11$8, toDisplayString$1(unref(t)("quiz.results.correct")), 1)
          ]),
          createBaseVNode("div", _hoisted_12$8, [
            createBaseVNode("p", _hoisted_13$8, toDisplayString$1(Math.round(_ctx.accuracy)) + "%", 1),
            createBaseVNode("p", _hoisted_14$8, toDisplayString$1(unref(t)("quiz.results.accuracy")), 1)
          ])
        ]),
        createBaseVNode("div", _hoisted_15$7, [
          createBaseVNode("span", {
            class: normalizeClass(["inline-block px-4 py-2 text-sm font-medium rounded-full", _ctx.accuracy >= 70 ? "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200" : "bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200"])
          }, toDisplayString$1(_ctx.accuracy >= 70 ? unref(t)("quiz.results.passed") : unref(t)("quiz.results.failed")) + " (" + toDisplayString$1(_ctx.accuracy >= 70 ? unref(t)("quiz.results.above") : unref(t)("quiz.results.below")) + " 70%) ", 3)
        ]),
        createBaseVNode("div", _hoisted_16$7, [
          createBaseVNode("h3", _hoisted_17$7, toDisplayString$1(unref(t)("quiz.results.reviewAnswers")), 1),
          createBaseVNode("div", _hoisted_18$7, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.questions, (question, index) => {
              return openBlock(), createElementBlock("div", {
                key: index,
                class: "border border-gray-200 dark:border-gray-600 rounded-lg p-4"
              }, [
                createBaseVNode("div", _hoisted_19$7, [
                  createBaseVNode("p", _hoisted_20$7, toDisplayString$1(index + 1) + ". " + toDisplayString$1(question.question), 1),
                  _ctx.userAnswers[index] === question.correctAnswer ? (openBlock(), createElementBlock("span", _hoisted_21$7, _cache[3] || (_cache[3] = [
                    createBaseVNode("svg", {
                      class: "w-5 h-5",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)
                  ]))) : (openBlock(), createElementBlock("span", _hoisted_22$7, _cache[4] || (_cache[4] = [
                    createBaseVNode("svg", {
                      class: "w-5 h-5",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)
                  ])))
                ]),
                createBaseVNode("p", _hoisted_23$7, [
                  createBaseVNode("span", _hoisted_24$7, toDisplayString$1(unref(t)("quiz.results.correctAnswer")) + ":", 1),
                  createTextVNode(" " + toDisplayString$1(question.options[question.correctAnswer]), 1)
                ]),
                _ctx.userAnswers[index] !== question.correctAnswer ? (openBlock(), createElementBlock("p", _hoisted_25$7, [
                  createBaseVNode("span", _hoisted_26$6, toDisplayString$1(unref(t)("quiz.results.yourAnswer")) + ":", 1),
                  createTextVNode(" " + toDisplayString$1(question.options[_ctx.userAnswers[index]] || unref(t)("quiz.results.noAnswer")), 1)
                ])) : createCommentVNode("", true),
                question.explanation ? (openBlock(), createElementBlock("p", _hoisted_27$6, [
                  createBaseVNode("span", _hoisted_28$6, toDisplayString$1(unref(t)("quiz.results.explanation")) + ":", 1),
                  createTextVNode(" " + toDisplayString$1(question.explanation), 1)
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])
        ]),
        createBaseVNode("div", _hoisted_29$5, [
          createBaseVNode("button", {
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("restart-quiz")),
            class: "bg-purple-500 hover:bg-purple-600 text-white font-medium py-2 px-6 rounded-lg transition-colors"
          }, toDisplayString$1(unref(t)("quiz.results.restartQuiz")), 1),
          createBaseVNode("button", {
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("go-back")),
            class: "bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-6 rounded-lg transition-colors"
          }, toDisplayString$1(unref(t)("common.goBack")), 1)
        ])
      ]);
    };
  }
});

const QuizResults = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$g
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$f = { class: "relative" };
const _hoisted_2$c = ["title"];
const _hoisted_3$b = {
  key: 0,
  class: "w-5 h-5 text-yellow-500 transition-transform duration-200 hover:rotate-12",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_4$a = {
  key: 1,
  class: "w-5 h-5 text-blue-400 transition-transform duration-200 hover:rotate-12",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_5$9 = {
  key: 2,
  class: "absolute inset-0 rounded-lg bg-blue-400 opacity-30 animate-ping"
};
const _hoisted_6$8 = {
  key: 0,
  class: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs font-medium text-white bg-gray-900 dark:bg-black dark:text-white dark:border dark:border-gray-600 rounded shadow-lg whitespace-nowrap z-50"
};
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "ThemeToggle",
  setup(__props) {
    const themeStore = useThemeStore();
    const isAnimating = ref(false);
    const showTooltip = ref(false);
    let tooltipTimer = null;
    const toggleTheme = () => {
      isAnimating.value = true;
      themeStore.toggleTheme();
      setTimeout(() => {
        isAnimating.value = false;
      }, 300);
    };
    const handleMouseEnter = () => {
      if (tooltipTimer) {
        clearTimeout(tooltipTimer);
      }
      tooltipTimer = setTimeout(() => {
        showTooltip.value = true;
      }, 500);
    };
    const handleMouseLeave = () => {
      if (tooltipTimer) {
        clearTimeout(tooltipTimer);
      }
      showTooltip.value = false;
    };
    const handleKeydown = (event) => {
      if ((event.ctrlKey || event.metaKey) && event.shiftKey && event.key === "T") {
        event.preventDefault();
        toggleTheme();
      }
    };
    onMounted(() => {
      const button = document.querySelector("[data-theme-toggle]");
      if (button) {
        button.addEventListener("mouseenter", handleMouseEnter);
        button.addEventListener("mouseleave", handleMouseLeave);
      }
      document.addEventListener("keydown", handleKeydown);
    });
    onUnmounted(() => {
      const button = document.querySelector("[data-theme-toggle]");
      if (button) {
        button.removeEventListener("mouseenter", handleMouseEnter);
        button.removeEventListener("mouseleave", handleMouseLeave);
      }
      document.removeEventListener("keydown", handleKeydown);
      if (tooltipTimer) {
        clearTimeout(tooltipTimer);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$f, [
        createBaseVNode("button", {
          onClick: toggleTheme,
          class: "relative inline-flex items-center justify-center w-10 h-10 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-black text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-900 transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400",
          title: unref(themeStore).themeLabel()
        }, [
          !unref(themeStore).isDarkMode ? (openBlock(), createElementBlock("svg", _hoisted_3$b, _cache[0] || (_cache[0] = [
            createBaseVNode("path", {
              "fill-rule": "evenodd",
              d: "M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z",
              "clip-rule": "evenodd"
            }, null, -1)
          ]))) : (openBlock(), createElementBlock("svg", _hoisted_4$a, _cache[1] || (_cache[1] = [
            createBaseVNode("path", { d: "M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z" }, null, -1)
          ]))),
          isAnimating.value ? (openBlock(), createElementBlock("span", _hoisted_5$9)) : createCommentVNode("", true)
        ], 8, _hoisted_2$c),
        showTooltip.value ? (openBlock(), createElementBlock("div", _hoisted_6$8, [
          createTextVNode(toDisplayString$1(unref(themeStore).themeLabel()) + " ", 1),
          _cache[2] || (_cache[2] = createBaseVNode("div", { class: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900 dark:border-t-black" }, null, -1))
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const ThemeToggle = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-4c550120"]]);

const ThemeToggle$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: ThemeToggle
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$e = {
  key: 0,
  class: "flex items-center"
};
const _hoisted_2$b = {
  key: 1,
  class: "flex items-center"
};
const _hoisted_3$a = {
  key: 2,
  class: "flex items-center"
};
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "LanguageSwitcher",
  setup(__props) {
    const currentLocale = computed(() => getLocale());
    const toggleLanguage = () => {
      toggleLocale();
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        onClick: toggleLanguage,
        class: "inline-flex items-center px-3 py-1.5 border border-gray-300 dark:border-dark-bg-mute rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-white bg-white dark:bg-dark-bg-soft hover:bg-gray-50 dark:hover:bg-dark-bg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
      }, [
        currentLocale.value === "en" ? (openBlock(), createElementBlock("span", _hoisted_1$e, _cache[0] || (_cache[0] = [
          createBaseVNode("img", {
            src: "https://flagcdn.com/w20/us.png",
            width: "20",
            height: "15",
            class: "mr-2",
            alt: "English"
          }, null, -1),
          createTextVNode(" EN ")
        ]))) : currentLocale.value === "vi" ? (openBlock(), createElementBlock("span", _hoisted_2$b, _cache[1] || (_cache[1] = [
          createBaseVNode("img", {
            src: "https://flagcdn.com/w20/vn.png",
            width: "20",
            height: "15",
            class: "mr-2",
            alt: "Ting Vit"
          }, null, -1),
          createTextVNode(" VI ")
        ]))) : (openBlock(), createElementBlock("span", _hoisted_3$a, _cache[2] || (_cache[2] = [
          createBaseVNode("img", {
            src: "https://flagcdn.com/w20/kr.png",
            width: "20",
            height: "15",
            class: "mr-2",
            alt: ""
          }, null, -1),
          createTextVNode(" KO ")
        ])))
      ]);
    };
  }
});

const LanguageSwitcher = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$e
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$d = ["title"];
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "MoveButton",
  props: {
    word: {},
    moveMode: { type: Boolean }
  },
  emits: ["move-vocabulary"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const props = __props;
    const emit = __emit;
    const handleMoveClick = () => {
      emit("move-vocabulary", {
        word: props.word,
        targetDate: "",
        sourceDate: props.word.createdAt
      });
    };
    return (_ctx, _cache) => {
      return _ctx.moveMode ? (openBlock(), createElementBlock("button", {
        key: 0,
        onClick: withModifiers(handleMoveClick, ["stop"]),
        class: "text-blue-500 hover:text-blue-600 dark:text-blue-400 dark:hover:text-blue-300 transition-colors",
        title: unref(t)("vocabulary.moveToDateGroup", "Move to another date group")
      }, _cache[0] || (_cache[0] = [
        createBaseVNode("svg", {
          class: "w-4 h-4",
          fill: "none",
          stroke: "currentColor",
          viewBox: "0 0 24 24"
        }, [
          createBaseVNode("path", {
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            "stroke-width": "2",
            d: "M13 7l5 5m0 0l-5 5m5-5H6"
          })
        ], -1)
      ]), 8, _hoisted_1$d)) : createCommentVNode("", true);
    };
  }
});

const _hoisted_1$c = { class: "flex flex-col lg:flex-row lg:items-center lg:justify-between xl:items-center xl:justify-between 2xl:items-center 2xl:justify-between space-y-3 lg:space-y-0" };
const _hoisted_2$a = { class: "flex-1" };
const _hoisted_3$9 = { class: "flex flex-col sm:flex-row sm:items-start xl:items-center 2xl:items-center space-y-3 sm:space-y-0 sm:space-x-4" };
const _hoisted_4$9 = {
  key: 0,
  class: "flex-shrink-0 self-center sm:self-start xl:self-center 2xl:self-center"
};
const _hoisted_5$8 = { class: "w-16 h-16 sm:w-20 sm:h-20 rounded-lg overflow-hidden border-2 border-gray-200 dark:border-gray-600" };
const _hoisted_6$7 = ["src", "alt"];
const _hoisted_7$7 = { class: "flex-1" };
const _hoisted_8$7 = { class: "text-base sm:text-lg font-semibold text-gray-900 dark:text-white" };
const _hoisted_9$7 = { class: "text-xs sm:text-sm text-gray-500 dark:text-gray-400" };
const _hoisted_10$7 = { class: "text-xs sm:text-sm text-gray-600 dark:text-gray-300 mt-1" };
const _hoisted_11$7 = { class: "flex items-center space-x-4 mt-2 text-xs text-gray-500 dark:text-gray-400" };
const _hoisted_12$7 = {
  key: 0,
  class: "flex items-center space-x-1"
};
const _hoisted_13$7 = {
  key: 1,
  class: "flex items-center space-x-1"
};
const _hoisted_14$7 = { class: "flex-2" };
const _hoisted_15$6 = { class: "flex items-center space-x-2" };
const _hoisted_16$6 = { class: "text-gray-700 dark:text-gray-300" };
const _hoisted_17$6 = {
  key: 0,
  class: "text-sm text-gray-500 dark:text-gray-400 mt-1"
};
const _hoisted_18$6 = { class: "font-medium" };
const _hoisted_19$6 = { class: "flex-shrink-0" };
const _hoisted_20$6 = { class: "text-xs text-gray-500 mt-1" };
const _hoisted_21$6 = { class: "flex items-center space-x-2 ml-4 xl:items-center 2xl:items-center" };
const _hoisted_22$6 = {
  class: "w-5 h-5",
  fill: "currentColor",
  viewBox: "0 0 20 20"
};
const _hoisted_23$6 = {
  key: 0,
  d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"
};
const _hoisted_24$6 = {
  key: 1,
  d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z",
  fill: "none",
  stroke: "currentColor"
};
const _hoisted_25$6 = {
  key: 0,
  class: "fixed inset-0 z-[9999] flex items-center justify-center bg-black bg-opacity-75 p-4 backdrop-blur-sm"
};
const _hoisted_26$5 = { class: "relative w-full max-w-2xl bg-white dark:bg-[#0a0a0a] rounded-lg overflow-hidden shadow-2xl h-[400px] sm:h-[500px] md:h-[600px] transform" };
const _hoisted_27$5 = { class: "w-full h-full flex items-center justify-center p-4" };
const _hoisted_28$5 = ["src", "alt"];
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "VocabularyCard",
  props: {
    word: {},
    moveMode: { type: Boolean }
  },
  emits: ["play-audio", "edit-word", "delete-word", "toggle-favorite", "view-details", "move-vocabulary"],
  setup(__props, { emit: __emit }) {
    const { t, locale } = useI18n();
    const isImageModalOpen = ref(false);
    const openImageModal = () => {
      isImageModalOpen.value = true;
      document.body.style.overflow = "hidden";
    };
    const closeImageModal = () => {
      isImageModalOpen.value = false;
      document.body.style.overflow = "";
    };
    const props = __props;
    const emit = __emit;
    onUnmounted(() => {
      if (isImageModalOpen.value) {
        document.body.style.overflow = "";
      }
    });
    const viewDetails = () => {
      emit("view-details", props.word);
    };
    const handleImageError = (event) => {
      const img = event.target;
      console.warn(`Failed to load image for word: ${props.word.word}`, img.src);
      const container = img.closest(".flex-shrink-0");
      if (container) {
        container.style.display = "none";
      }
    };
    const getLevelColor = (level) => {
      switch (level) {
        case "beginner":
          return "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200";
        case "intermediate":
          return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200";
        case "advanced":
          return "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200";
        default:
          return "bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200";
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", {
          class: "p-3 sm:p-4 md:p-6 hover:bg-gray-50 dark:hover:bg-gray-custom cursor-pointer",
          onClick: viewDetails
        }, [
          createBaseVNode("div", _hoisted_1$c, [
            createBaseVNode("div", _hoisted_2$a, [
              createBaseVNode("div", _hoisted_3$9, [
                _ctx.word.image ? (openBlock(), createElementBlock("div", _hoisted_4$9, [
                  createBaseVNode("div", _hoisted_5$8, [
                    createBaseVNode("img", {
                      src: _ctx.word.image,
                      alt: `${unref(t)("vocabulary.image.preview", "Image preview")} - ${_ctx.word.word}`,
                      class: "w-full h-full object-cover cursor-pointer",
                      onError: handleImageError,
                      onClick: withModifiers(openImageModal, ["stop"])
                    }, null, 40, _hoisted_6$7)
                  ])
                ])) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_7$7, [
                  createBaseVNode("h4", _hoisted_8$7, toDisplayString$1(_ctx.word.word), 1),
                  createBaseVNode("p", _hoisted_9$7, toDisplayString$1(_ctx.word.pronunciation), 1),
                  createBaseVNode("p", _hoisted_10$7, toDisplayString$1(_ctx.word.partOfSpeech), 1),
                  createBaseVNode("div", _hoisted_11$7, [
                    _ctx.word.createdAt ? (openBlock(), createElementBlock("div", _hoisted_12$7, [
                      _cache[5] || (_cache[5] = createBaseVNode("svg", {
                        class: "w-3 h-3",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)),
                      createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.createdAt", "Created at")) + ": " + toDisplayString$1(unref(getRelativeTime)(_ctx.word.createdAt, unref(t))), 1)
                    ])) : createCommentVNode("", true),
                    _ctx.word.updatedAt && _ctx.word.updatedAt !== _ctx.word.createdAt ? (openBlock(), createElementBlock("div", _hoisted_13$7, [
                      _cache[6] || (_cache[6] = createBaseVNode("svg", {
                        class: "w-3 h-3",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", { d: "M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" })
                      ], -1)),
                      createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.updatedAt", "Updated at")) + ": " + toDisplayString$1(unref(getRelativeTime)(_ctx.word.updatedAt, unref(t))), 1)
                    ])) : createCommentVNode("", true)
                  ])
                ]),
                createBaseVNode("div", _hoisted_14$7, [
                  createBaseVNode("div", _hoisted_15$6, [
                    createBaseVNode("p", _hoisted_16$6, toDisplayString$1(_ctx.word.meaning), 1),
                    createVNode(unref(_sfc_main$d), {
                      word: _ctx.word,
                      "move-mode": _ctx.moveMode,
                      onMoveVocabulary: _cache[0] || (_cache[0] = ($event) => emit("move-vocabulary", $event))
                    }, null, 8, ["word", "move-mode"])
                  ]),
                  _ctx.word.example ? (openBlock(), createElementBlock("p", _hoisted_17$6, [
                    createBaseVNode("span", _hoisted_18$6, toDisplayString$1(unref(t)("vocabulary.example", "Example")) + ":", 1),
                    createTextVNode(" " + toDisplayString$1(_ctx.word.example), 1)
                  ])) : createCommentVNode("", true)
                ]),
                createBaseVNode("div", _hoisted_19$6, [
                  createBaseVNode("span", {
                    class: normalizeClass([getLevelColor(_ctx.word.level), "px-2 py-1 text-xs font-medium rounded-full"])
                  }, toDisplayString$1(unref(t)(`vocabulary.levels.${_ctx.word.level}`, _ctx.word.level)), 3),
                  createBaseVNode("p", _hoisted_20$6, toDisplayString$1(unref(getTopicName)(_ctx.word.category, unref(t), unref(locale), _ctx.word)), 1)
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_21$6, [
              createBaseVNode("button", {
                onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.$emit("toggle-favorite", _ctx.word), ["stop"])),
                class: normalizeClass(["text-gray-500 hover:text-yellow-500", { "text-yellow-500": _ctx.word.favorite }])
              }, [
                (openBlock(), createElementBlock("svg", _hoisted_22$6, [
                  _ctx.word.favorite ? (openBlock(), createElementBlock("path", _hoisted_23$6)) : (openBlock(), createElementBlock("path", _hoisted_24$6))
                ]))
              ], 2),
              createBaseVNode("button", {
                onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.$emit("play-audio", _ctx.word.word), ["stop"])),
                class: "text-blue-500 hover:text-blue-600"
              }, _cache[7] || (_cache[7] = [
                createBaseVNode("svg", {
                  class: "w-5 h-5",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.816L4.846 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.846l3.537-3.816a1 1 0 011.617.816zM16 8a2 2 0 11-4 0 2 2 0 014 0zM14 8a2 2 0 012-2v4a2 2 0 01-2-2z",
                    "clip-rule": "evenodd"
                  })
                ], -1)
              ])),
              createBaseVNode("button", {
                onClick: _cache[3] || (_cache[3] = withModifiers(($event) => _ctx.$emit("edit-word", _ctx.word), ["stop"])),
                class: "text-gray-500 hover:text-gray-600"
              }, _cache[8] || (_cache[8] = [
                createBaseVNode("svg", {
                  class: "w-5 h-5",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
                ], -1)
              ])),
              createBaseVNode("button", {
                onClick: _cache[4] || (_cache[4] = withModifiers(($event) => _ctx.$emit("delete-word", _ctx.word), ["stop"])),
                class: "text-red-500 hover:text-red-600"
              }, _cache[9] || (_cache[9] = [
                createBaseVNode("svg", {
                  class: "w-5 h-5",
                  fill: "currentColor",
                  viewBox: "0 0 20 20"
                }, [
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M9 2a1 1 0 000 2h2a1 1 0 100-2H9z",
                    "clip-rule": "evenodd"
                  }),
                  createBaseVNode("path", {
                    "fill-rule": "evenodd",
                    d: "M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",
                    "clip-rule": "evenodd"
                  })
                ], -1)
              ]))
            ])
          ])
        ]),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          createVNode(Transition, {
            "enter-active-class": "transition-all duration-500 ease-out",
            "enter-from-class": "opacity-0",
            "enter-to-class": "opacity-100",
            "leave-active-class": "transition-all duration-300 ease-in",
            "leave-from-class": "opacity-100",
            "leave-to-class": "opacity-0"
          }, {
            default: withCtx(() => [
              isImageModalOpen.value ? (openBlock(), createElementBlock("div", _hoisted_25$6, [
                createVNode(Transition, {
                  "enter-active-class": "transition-all duration-500 ease-out",
                  "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                  "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                  "leave-active-class": "transition-all duration-300 ease-in",
                  "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                  "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_26$5, [
                      createBaseVNode("button", {
                        onClick: closeImageModal,
                        class: "absolute top-4 right-4 z-[10000] text-gray-600 dark:text-white hover:text-gray-800 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 bg-white dark:bg-[#0a0a0a] bg-opacity-80 dark:bg-opacity-80 rounded-full p-2 shadow-lg"
                      }, _cache[10] || (_cache[10] = [
                        createBaseVNode("svg", {
                          class: "w-6 h-6",
                          fill: "none",
                          stroke: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          createBaseVNode("path", {
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            "stroke-width": "2",
                            d: "M6 18L18 6M6 6l12 12"
                          })
                        ], -1)
                      ])),
                      createBaseVNode("div", _hoisted_27$5, [
                        createBaseVNode("img", {
                          src: _ctx.word.image,
                          alt: `${unref(t)("vocabulary.image.preview", "Image preview")} - ${_ctx.word.word}`,
                          class: "max-w-full max-h-full object-contain rounded-lg shadow-lg animate-fade-in-up",
                          style: { "animation-delay": "0.2s" }
                        }, null, 8, _hoisted_28$5)
                      ])
                    ])
                  ]),
                  _: 1
                })
              ])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ]))
      ]);
    };
  }
});

const VocabularyCard = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-facc0634"]]);

const VocabularyCard$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: VocabularyCard
}, Symbol.toStringTag, { value: 'Module' }));

function useDailyProgress() {
  const { practiceHistory } = useFlashcardHistory();
  const DAILY_TARGET = 10;
  const getDailyProgress = (targetDate) => {
    const target = new Date(targetDate);
    const targetDateString = target.toDateString();
    const sessionsForDate = practiceHistory.value.filter((session) => {
      const sessionDate = new Date(session.date);
      return sessionDate.toDateString() === targetDateString;
    });
    const uniqueWordsLearned = /* @__PURE__ */ new Set();
    sessionsForDate.forEach((session) => {
      const wordsInSession = session.correctAnswers;
      for (let i = 0; i < wordsInSession; i++) {
        uniqueWordsLearned.add(`${session.id}-${i}`);
      }
    });
    const wordsLearned = uniqueWordsLearned.size;
    const percentage = Math.min(wordsLearned / DAILY_TARGET * 100, 100);
    return {
      date: targetDate,
      wordsLearned,
      totalWords: DAILY_TARGET,
      percentage: Math.round(percentage),
      isCompleted: percentage >= 100
    };
  };
  const getMultipleDailyProgress = (dates) => {
    return dates.map((date) => getDailyProgress(date));
  };
  const getTodayProgress = () => {
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    return getDailyProgress(today);
  };
  const getWeeklyProgress = () => {
    const today = /* @__PURE__ */ new Date();
    const weekStart = new Date(today);
    weekStart.setDate(today.getDate() - today.getDay());
    const weekDates = [];
    for (let i = 0; i < 7; i++) {
      const date = new Date(weekStart);
      date.setDate(weekStart.getDate() + i);
      weekDates.push(date.toISOString().split("T")[0]);
    }
    const weeklyStats = getMultipleDailyProgress(weekDates);
    const totalWordsLearned = weeklyStats.reduce((sum, day) => sum + day.wordsLearned, 0);
    const totalTarget = DAILY_TARGET * 7;
    const weeklyPercentage = Math.min(totalWordsLearned / totalTarget * 100, 100);
    return {
      wordsLearned: totalWordsLearned,
      totalWords: totalTarget,
      percentage: Math.round(weeklyPercentage),
      daysCompleted: weeklyStats.filter((day) => day.isCompleted).length,
      dailyStats: weeklyStats
    };
  };
  const hasActivityForDate = (targetDate) => {
    const target = new Date(targetDate);
    const targetDateString = target.toDateString();
    return practiceHistory.value.some((session) => {
      const sessionDate = new Date(session.date);
      return sessionDate.toDateString() === targetDateString;
    });
  };
  return {
    DAILY_TARGET,
    getDailyProgress,
    getMultipleDailyProgress,
    getTodayProgress,
    getWeeklyProgress,
    hasActivityForDate
  };
}

const _hoisted_1$b = { class: "mb-3 xs:mb-4 sm:mb-6" };
const _hoisted_2$9 = { class: "sticky top-0 bg-gray-50 dark:bg-[#0f0f0f] px-2 xs:px-3 sm:px-4 md:px-6 py-2 xs:py-2.5 sm:py-3 border-b border-gray-200 dark:border-gray-700 z-10" };
const _hoisted_3$8 = { class: "sm:block md:hidden" };
const _hoisted_4$8 = { class: "flex items-center space-x-1 flex-1" };
const _hoisted_5$7 = { class: "p-0.5 rounded-md" };
const _hoisted_6$6 = { class: "text-xs sm:text-sm md:text-base lg:text-lg xl:text-base 2xl:text-lg font-semibold text-gray-700 dark:text-gray-300 flex items-center space-x-1" };
const _hoisted_7$6 = { class: "inline-flex items-center ml-1.5 xs:ml-2" };
const _hoisted_8$6 = { class: "relative inline-flex items-center cursor-pointer" };
const _hoisted_9$6 = ["disabled"];
const _hoisted_10$6 = { class: "text-xs sm:text-sm md:text-base lg:text-lg xl:text-base 2xl:text-lg text-gray-500 dark:text-gray-400" };
const _hoisted_11$6 = ["disabled"];
const _hoisted_12$6 = {
  key: 0,
  class: "flex items-center justify-center mb-3"
};
const _hoisted_13$6 = { class: "flex items-center space-x-1 w-full max-w-[280px]" };
const _hoisted_14$6 = ["placeholder"];
const _hoisted_15$5 = ["aria-label"];
const _hoisted_16$5 = ["aria-label"];
const _hoisted_17$5 = { key: 1 };
const _hoisted_18$5 = {
  key: 0,
  class: "flex items-center justify-center mb-1.5"
};
const _hoisted_19$5 = { class: "flex items-center space-x-1 px-2.5 py-1 bg-orange-50 dark:bg-orange-900/50 rounded-lg border border-orange-200 dark:border-orange-700 max-w-[180px]" };
const _hoisted_20$5 = { class: "relative flex-1 min-w-0" };
const _hoisted_21$5 = {
  key: 0,
  class: "absolute z-[9999] bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 dark:bg-gray-700 text-white text-xs rounded-lg shadow-lg whitespace-nowrap"
};
const _hoisted_22$5 = ["aria-label"];
const _hoisted_23$5 = { class: "grid grid-cols-2 gap-2 max-w-[280px] sm:max-w-[320px] mx-auto" };
const _hoisted_24$5 = ["aria-label"];
const _hoisted_25$5 = { class: "text-center leading-tight" };
const _hoisted_26$4 = {
  key: 1,
  class: "flex"
};
const _hoisted_27$4 = ["aria-label"];
const _hoisted_28$4 = { class: "text-center leading-tight" };
const _hoisted_29$4 = {
  key: 3,
  class: "flex"
};
const _hoisted_30$4 = { class: "hidden md:block" };
const _hoisted_31$4 = { class: "flex items-center space-x-2" };
const _hoisted_32$3 = { class: "p-1 rounded-md" };
const _hoisted_33$3 = { class: "text-xs xs:text-sm sm:text-sm md:text-base lg:text-base xl:text-sm 2xl:text-base font-semibold text-gray-700 dark:text-gray-300 flex items-center space-x-1 xs:space-x-1.5 sm:space-x-2" };
const _hoisted_34$3 = { class: "inline-flex items-center ml-1.5 xs:ml-2" };
const _hoisted_35$3 = { class: "relative inline-flex items-center cursor-pointer" };
const _hoisted_36$3 = { class: "hidden lg:flex items-center space-x-2" };
const _hoisted_37$2 = ["disabled"];
const _hoisted_38$2 = { class: "text-xs sm:text-sm md:text-base lg:text-lg xl:text-sm 2xl:text-base text-gray-500 dark:text-gray-400" };
const _hoisted_39$2 = ["disabled"];
const _hoisted_40$2 = { class: "relative inline-flex items-center cursor-pointer" };
const _hoisted_41$1 = { class: "text-xs sm:text-sm md:text-base lg:text-lg xl:text-sm 2xl:text-base text-gray-600 dark:text-gray-300" };
const _hoisted_42$1 = ["disabled"];
const _hoisted_43$1 = { class: "text-xs sm:text-sm md:text-base text-gray-500 dark:text-gray-400" };
const _hoisted_44$1 = ["disabled"];
const _hoisted_45$1 = {
  key: 0,
  class: "flex items-center space-x-2"
};
const _hoisted_46$1 = {
  key: 0,
  class: "flex items-center space-x-1 xs:space-x-1.5 sm:space-x-1.5 md:space-x-2 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 bg-orange-50 dark:bg-orange-900/50 rounded-full border border-orange-200 dark:border-orange-700"
};
const _hoisted_47$1 = { class: "relative" };
const _hoisted_48$1 = {
  key: 0,
  class: "absolute z-[9999] bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 dark:bg-gray-700 text-white text-xs rounded-lg shadow-lg whitespace-nowrap"
};
const _hoisted_49$1 = ["aria-label"];
const _hoisted_50$1 = ["aria-label"];
const _hoisted_51 = { class: "whitespace-nowrap" };
const _hoisted_52 = ["aria-label"];
const _hoisted_53 = {
  key: 1,
  class: "flex items-center space-x-1 xs:space-x-1.5 sm:space-x-2 w-full max-w-[150px] xs:max-w-[200px] sm:max-w-xs"
};
const _hoisted_54 = ["placeholder"];
const _hoisted_55 = ["aria-label"];
const _hoisted_56 = ["aria-label"];
const _hoisted_57 = { class: "hidden lg:block" };
const _hoisted_58 = { class: "flex-1 flex justify-center mx-1 xs:mx-2 sm:mx-4 min-w-0" };
const _hoisted_59 = {
  key: 0,
  class: "flex items-center space-x-1.5 xs:space-x-1.5 sm:space-x-2 flex-nowrap"
};
const _hoisted_60 = {
  key: 0,
  class: "flex items-center space-x-1 md:space-x-1.5 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 lg:py-1.5 xl:py-1.5 2xl:py-1.5 bg-orange-50 dark:bg-orange-900/50 rounded-full border border-orange-200 dark:border-orange-700 flex-shrink-0"
};
const _hoisted_61 = { class: "relative" };
const _hoisted_62 = {
  key: 0,
  class: "absolute z-[9999] bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 dark:bg-gray-700 text-white text-xs rounded-lg shadow-lg whitespace-nowrap"
};
const _hoisted_63 = ["aria-label"];
const _hoisted_64 = ["aria-label"];
const _hoisted_65 = ["aria-label"];
const _hoisted_66 = ["placeholder"];
const _hoisted_67 = ["aria-label"];
const _hoisted_68 = ["aria-label"];
const _hoisted_69 = {
  key: 0,
  class: "accordion-content"
};
const _hoisted_70 = {
  key: 0,
  class: "divide-y divide-gray-200 dark:divide-gray-700"
};
const _hoisted_71 = ["onMouseenter", "onMouseleave"];
const _hoisted_72 = { class: "bg-gray-50 dark:bg-gray-custom border-b border-gray-200 dark:border-gray-700" };
const _hoisted_73 = ["id", "onClick"];
const _hoisted_74 = { class: "flex items-center space-x-2" };
const _hoisted_75 = { class: "flex items-center space-x-1" };
const _hoisted_76 = { class: "text-sm font-medium text-gray-600 dark:text-gray-400" };
const _hoisted_77 = { class: "text-xs text-gray-500" };
const _hoisted_78 = ["onMouseenter"];
const _hoisted_79 = ["aria-label"];
const _hoisted_80 = { class: "text-xs font-semibold mb-2" };
const _hoisted_81 = {
  key: 0,
  class: "text-xs text-gray-600 dark:text-white/70"
};
const _hoisted_82 = ["onClick"];
const _hoisted_83 = { class: "text-gray-500 dark:text-white/60" };
const _hoisted_84 = ["onClick", "title"];
const _hoisted_85 = { class: "flex items-center justify-between text-xs" };
const _hoisted_86 = { class: "flex-1 flex justify-between sm:hidden" };
const _hoisted_87 = ["onClick", "disabled"];
const _hoisted_88 = ["onClick", "disabled"];
const _hoisted_89 = { class: "hidden sm:flex-1 sm:flex sm:items-center sm:justify-between" };
const _hoisted_90 = { class: "text-xs text-gray-700 dark:text-gray-300" };
const _hoisted_91 = { class: "relative z-0 inline-flex rounded-md shadow-sm -space-x-px" };
const _hoisted_92 = ["onClick", "disabled"];
const _hoisted_93 = { class: "sr-only" };
const _hoisted_94 = ["onClick", "disabled"];
const _hoisted_95 = ["onClick", "disabled"];
const _hoisted_96 = { class: "sr-only" };
const _hoisted_97 = {
  key: 0,
  class: "topic-accordion-content py-2"
};
const _hoisted_98 = { class: "divide-y divide-gray-200 dark:divide-gray-700" };
const _hoisted_99 = {
  key: 1,
  class: "divide-y divide-gray-200 dark:divide-gray-700"
};
const SHOW_ACTION_BUTTONS_KEY = "vocabulary-show-action-buttons-by-date";
const itemsPerCategoryPage = 5;
const TOPIC_PAGINATION_STORAGE_KEY = "vocabulary-topic-pagination-state";
const TOPICS_STORAGE_KEY = "vocabulary-group-topics";
const PENDING_OPEN_KEY = "open-date-topic-pending";
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "DateGroupAccordion",
  props: {
    group: {},
    defaultExpanded: { type: Boolean, default: false },
    accordionState: { default: () => ({}) },
    hoverToExpandEnabled: { type: Boolean, default: false },
    globalMoveMode: { type: Boolean, default: false }
  },
  emits: ["play-audio", "edit-word", "delete-word", "toggle-favorite", "view-details", "date-group-previous", "date-group-next", "accordion-toggle", "note-saved", "open-note-dialog", "open-add-vocabulary-dialog", "open-grammar-manager", "move-vocabulary", "request-available-dates", "navigate-to-date-topic", "batch-move-category"],
  setup(__props, { emit: __emit }) {
    const { t, locale } = useI18n();
    const VocabularyCard = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => VocabularyCard$1),true              ?void 0:void 0))
    );
    const VocabularyNoteButton$1 = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => VocabularyNoteButton),true              ?void 0:void 0))
    );
    const GrammarManagerButton$1 = defineAsyncComponent(() => loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => GrammarManagerButton),true              ?void 0:void 0))());
    const CircularProgress = defineAsyncComponent(
      loadComponentSafely(() => __vitePreload(() => Promise.resolve().then(() => CircularProgress$1),true              ?void 0:void 0))
    );
    const props = __props;
    const totalVocabularyCount = computed(() => {
      if (props.group.totalItems && props.group.totalItems > 0) {
        return props.group.totalItems;
      }
      if (props.group.topics && props.group.topics.length > 0) {
        return props.group.topics.reduce((total, topicGroup) => {
          return total + (topicGroup.vocabularies?.length || 0);
        }, 0);
      } else {
        return props.group.vocabularies?.length || 0;
      }
    });
    const isTodayGroup = computed(() => {
      const today = /* @__PURE__ */ new Date();
      const todayKey = getDateKey(today.toISOString());
      return props.group.date === todayKey;
    });
    const { getDailyProgress, DAILY_TARGET } = useDailyProgress();
    const dailyProgress = computed(() => getDailyProgress(props.group.date));
    const headerProgress = computed(() => {
      const count = totalVocabularyCount.value;
      const percentage = Math.min(count / DAILY_TARGET * 100, 100);
      return {
        percentage: Math.round(percentage),
        wordsLearned: dailyProgress.value.wordsLearned,
        totalWords: DAILY_TARGET
      };
    });
    computed(() => {
      const pctLabel = t("progress.percentage", "Percentage");
      const learnedLabel = t("progress.wordsLearned", "Words learned");
      return `${pctLabel}: ${dailyProgress.value.percentage}%  ${learnedLabel}: ${dailyProgress.value.wordsLearned}/${dailyProgress.value.totalWords}`;
    });
    const headerProgressTooltip = computed(() => {
      const pctLabel = t("progress.percentage", "Percentage");
      const vocabLabel = t("vocabulary.words", "Words");
      return `${pctLabel}: ${headerProgress.value.percentage}%  ${totalVocabularyCount.value}/${DAILY_TARGET} ${vocabLabel}`;
    });
    const vocabularyCountColor = computed(() => {
      const count = totalVocabularyCount.value;
      const group = Math.floor(count / 10);
      const colors = [
        // 0-9 words: Red
        { light: "text-red-600", dark: "dark:text-red-400" },
        // 10-19 words: Orange  
        { light: "text-orange-600", dark: "dark:text-orange-400" },
        // 20-29 words: Yellow
        { light: "text-yellow-600", dark: "dark:text-yellow-400" },
        // 30-39 words: Green
        { light: "text-green-600", dark: "dark:text-green-400" },
        // 40-49 words: Blue
        { light: "text-blue-600", dark: "dark:text-blue-400" },
        // 50+ words: Purple
        { light: "text-purple-600", dark: "dark:text-purple-400" }
      ];
      const colorIndex = Math.min(group, colors.length - 1);
      const color = colors[colorIndex];
      return `${color.light} ${color.dark}`;
    });
    const isTopicTruncated = computed(() => {
      if (!groupTopic.value) {
        return false;
      }
      if (topicSpanMobile.value) {
        return topicSpanMobile.value.scrollWidth > topicSpanMobile.value.clientWidth;
      }
      if (topicSpanDesktop.value) {
        return topicSpanDesktop.value.scrollWidth > topicSpanDesktop.value.clientWidth;
      }
      return false;
    });
    const isExpanded = ref(false);
    ref(false);
    ref(null);
    const accordionContent = ref();
    const accordionMaxHeight = ref(0);
    const showActionButtons = ref(true);
    const loadActionButtonsState = () => {
      try {
        const saved = localStorage.getItem(SHOW_ACTION_BUTTONS_KEY);
        if (saved !== null) {
          const allStates = JSON.parse(saved);
          if (typeof allStates === "object" && allStates[props.group.date] !== void 0) {
            showActionButtons.value = allStates[props.group.date];
          }
        }
      } catch (error) {
        console.warn("Failed to load action buttons state from localStorage:", error);
        showActionButtons.value = true;
      }
    };
    const saveActionButtonsState = () => {
      try {
        const saved = localStorage.getItem(SHOW_ACTION_BUTTONS_KEY);
        let allStates = {};
        if (saved !== null) {
          allStates = JSON.parse(saved);
        }
        allStates[props.group.date] = showActionButtons.value;
        localStorage.setItem(SHOW_ACTION_BUTTONS_KEY, JSON.stringify(allStates));
      } catch (error) {
        console.warn("Failed to save action buttons state to localStorage:", error);
      }
    };
    watch(showActionButtons, () => {
      saveActionButtonsState();
    });
    const expandedTopics = ref({});
    const topicPaginationState = ref({});
    const loadTopicPaginationState = () => {
      try {
        const stored = localStorage.getItem(TOPIC_PAGINATION_STORAGE_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch (error) {
        console.warn("Failed to load topic pagination state from localStorage:", error);
        return {};
      }
    };
    const saveTopicPaginationState = (state) => {
      try {
        localStorage.setItem(TOPIC_PAGINATION_STORAGE_KEY, JSON.stringify(state));
      } catch (error) {
        console.warn("Failed to save topic pagination state to localStorage:", error);
      }
    };
    const toggleTopicAccordion = (topic) => {
      expandedTopics.value[topic] = !expandedTopics.value[topic];
      if (!topicPaginationState.value[topic]) {
        topicPaginationState.value[topic] = { currentPage: 1 };
      }
    };
    const isTopicExpanded = (topic) => {
      return expandedTopics.value[topic] || false;
    };
    const getTopicCurrentPage = (topic) => {
      return topicPaginationState.value[topic]?.currentPage || 1;
    };
    const setTopicCurrentPage = (topic, page) => {
      if (!topicPaginationState.value[topic]) {
        topicPaginationState.value[topic] = { currentPage: 1 };
      }
      topicPaginationState.value[topic].currentPage = page;
      saveTopicPaginationState(topicPaginationState.value);
    };
    const getPaginatedTopicVocabularies = (topicGroup) => {
      const currentPage = getTopicCurrentPage(topicGroup.topic);
      const totalItems = topicGroup.vocabularies.length;
      const startIndex = (currentPage - 1) * itemsPerCategoryPage;
      const endIndex = startIndex + itemsPerCategoryPage;
      return {
        vocabularies: topicGroup.vocabularies.slice(startIndex, endIndex),
        currentPage,
        totalPages: Math.ceil(totalItems / itemsPerCategoryPage),
        totalItems,
        startIndex: startIndex + 1,
        endIndex: Math.min(endIndex, totalItems),
        hasNext: currentPage < Math.ceil(totalItems / itemsPerCategoryPage),
        hasPrevious: currentPage > 1
      };
    };
    const goToTopicPage = (topic, page) => {
      const totalItems = props.group.topics?.find((t2) => t2.topic === topic)?.vocabularies.length || 0;
      const totalPages = Math.ceil(totalItems / itemsPerCategoryPage);
      if (page >= 1 && page <= totalPages) {
        setTopicCurrentPage(topic, page);
      }
    };
    const nextTopicPage = (topic) => {
      const currentPage = getTopicCurrentPage(topic);
      const totalItems = props.group.topics?.find((t2) => t2.topic === topic)?.vocabularies.length || 0;
      const totalPages = Math.ceil(totalItems / itemsPerCategoryPage);
      if (currentPage < totalPages) {
        setTopicCurrentPage(topic, currentPage + 1);
      }
    };
    const previousTopicPage = (topic) => {
      const currentPage = getTopicCurrentPage(topic);
      if (currentPage > 1) {
        setTopicCurrentPage(topic, currentPage - 1);
      }
    };
    const getVisibleTopicPages = (currentPage, totalPages) => {
      if (totalPages <= 7) {
        return Array.from({ length: totalPages }, (_, i) => i + 1);
      }
      if (currentPage <= 4) {
        return [1, 2, 3, 4, 5, -1, totalPages];
      }
      if (currentPage >= totalPages - 3) {
        return [1, -1, totalPages - 4, totalPages - 3, totalPages - 2, totalPages - 1, totalPages];
      }
      return [1, -1, currentPage - 1, currentPage, currentPage + 1, -1, totalPages];
    };
    const hoverTimeouts = ref({});
    const handleTopicHover = (topic, isHovering) => {
      if (props.hoverToExpandEnabled) {
        if (hoverTimeouts.value[topic]) {
          clearTimeout(hoverTimeouts.value[topic]);
          delete hoverTimeouts.value[topic];
        }
        if (isHovering) {
          expandedTopics.value[topic] = true;
        } else {
          hoverTimeouts.value[topic] = setTimeout(() => {
            if (!isModalOpen()) {
              expandedTopics.value[topic] = false;
            }
            delete hoverTimeouts.value[topic];
          }, 200);
        }
      }
    };
    const isMouseOutsideVocabulary = ref(false);
    const handleVocabularyListMouseLeave = () => {
      if (props.hoverToExpandEnabled) {
        isMouseOutsideVocabulary.value = true;
        if (!isModalOpen()) {
          closeAllTopics();
        }
      }
    };
    const handleVocabularyListMouseEnter = () => {
      if (props.hoverToExpandEnabled) {
        isMouseOutsideVocabulary.value = false;
      }
    };
    const closeAllTopics = () => {
      Object.keys(expandedTopics.value).forEach((topic) => {
        expandedTopics.value[topic] = false;
      });
      Object.keys(hoverTimeouts.value).forEach((topic) => {
        if (hoverTimeouts.value[topic]) {
          clearTimeout(hoverTimeouts.value[topic]);
          delete hoverTimeouts.value[topic];
        }
      });
    };
    const isModalOpen = () => {
      const modalSelectors = [
        '[role="dialog"]',
        ".modal",
        ".dialog",
        '[data-headlessui-state="open"]',
        // HeadlessUI modals
        ".fixed.inset-0"
        // Common modal backdrop pattern
      ];
      return modalSelectors.some((selector) => {
        const elements = document.querySelectorAll(selector);
        return Array.from(elements).some((el) => {
          const style = window.getComputedStyle(el);
          return style.display !== "none" && style.visibility !== "hidden";
        });
      });
    };
    const showTopicInput = ref(false);
    const topicInputValue = ref("");
    const topicInput = ref();
    const groupTopic = ref("");
    const showTopicTooltip = ref(false);
    const topicSpanMobile = ref();
    const topicSpanDesktop = ref();
    const getStoredTopics = () => {
      try {
        const stored = localStorage.getItem(TOPICS_STORAGE_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch (error) {
        console.warn("Failed to load group topics from localStorage:", error);
        return {};
      }
    };
    const setStoredTopics = (topics) => {
      try {
        localStorage.setItem(TOPICS_STORAGE_KEY, JSON.stringify(topics));
      } catch (error) {
        console.warn("Failed to save group topics to localStorage:", error);
      }
    };
    const editTopic = () => {
      topicInputValue.value = groupTopic.value;
      showTopicInput.value = true;
      nextTick(() => {
        topicInput.value?.focus();
      });
    };
    const saveTopic = () => {
      const trimmedTopic = topicInputValue.value.trim();
      groupTopic.value = trimmedTopic;
      const storedTopics = getStoredTopics();
      if (trimmedTopic) {
        storedTopics[props.group.date] = trimmedTopic;
      } else {
        delete storedTopics[props.group.date];
      }
      setStoredTopics(storedTopics);
      showTopicInput.value = false;
      topicInputValue.value = "";
    };
    const cancelTopicInput = () => {
      showTopicInput.value = false;
      topicInputValue.value = "";
    };
    const handleMoveVocabulary = (data) => {
      emit("move-vocabulary", data);
    };
    const formatDateForDisplay = (dateStr) => {
      const date = new Date(dateStr);
      return date.toLocaleDateString(locale.value, {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    };
    const calculateHeight = async () => {
      if (!accordionContent.value) return;
      const innerElement = accordionContent.value.querySelector(".accordion-inner");
      if (innerElement) {
        const clone = innerElement.cloneNode(true);
        clone.style.visibility = "hidden";
        clone.style.position = "absolute";
        clone.style.height = "auto";
        clone.style.maxHeight = "none";
        clone.style.overflow = "visible";
        document.body.appendChild(clone);
        await nextTick();
        accordionMaxHeight.value = clone.scrollHeight + 24;
        document.body.removeChild(clone);
      }
    };
    const modalWatchInterval = ref(null);
    const startModalWatcher = () => {
      if (modalWatchInterval.value) return;
      modalWatchInterval.value = setInterval(() => {
        if (props.hoverToExpandEnabled && isMouseOutsideVocabulary.value && !isModalOpen()) {
          closeAllTopics();
        }
      }, 300);
    };
    const stopModalWatcher = () => {
      if (modalWatchInterval.value) {
        clearInterval(modalWatchInterval.value);
        modalWatchInterval.value = null;
      }
    };
    const toggleAccordion = () => {
      isExpanded.value = !isExpanded.value;
      emit("accordion-toggle", props.group.date, isExpanded.value);
    };
    const openAddVocabularyDialog = () => {
      emit("open-add-vocabulary-dialog", props.group.date);
    };
    const openGrammarManager = (date) => {
      emit("open-grammar-manager", date);
    };
    const handleBatchMoveCategory = (topicGroup) => {
      emit("batch-move-category", {
        topic: topicGroup.topic,
        words: topicGroup.vocabularies,
        sourceDate: props.group.date
      });
    };
    const availableDatesByTopic = ref({});
    const infoHoverTopic = ref(null);
    const handleInfoMouseEnter = (topic) => {
      infoHoverTopic.value = topic;
      emit("request-available-dates", { topic, currentDate: props.group.date });
    };
    const handleInfoMouseLeave = () => {
      setTimeout(() => {
        if (!isHoveringTooltip.value) {
          infoHoverTopic.value = null;
        }
      }, 120);
    };
    const handleAvailableDatesResponse = (e) => {
      const detail = e.detail;
      if (!detail) return;
      if (detail.currentDate !== props.group.date) return;
      availableDatesByTopic.value[detail.topic] = detail.availableDates || [];
    };
    const handleNavigateClick = (targetDate, topic) => {
      console.log(" Tooltip navigation:", { targetDate, topic, currentDate: props.group.date });
      infoHoverTopic.value = null;
      if (targetDate === props.group.date) {
        console.log(" Same date navigation - expanding locally");
        isExpanded.value = true;
        expandedTopics.value[topic] = true;
        nextTick(() => {
          const el = document.getElementById(`date-group-${props.group.date}-topic-${topic}`);
          if (el && typeof el.scrollIntoView === "function") {
            el.scrollIntoView({ behavior: "smooth", block: "center" });
          }
        });
      } else {
        console.log(" Cross-date navigation - emitting to parent");
        emit("navigate-to-date-topic", { date: targetDate, topic });
      }
    };
    const handleOpenDateTopic = (e) => {
      const detail = e.detail;
      console.log(" Received open-date-topic event:", { detail, currentDate: props.group.date });
      if (!detail) {
        console.log(" No detail in event");
        return;
      }
      if (detail.date !== props.group.date) {
        console.log(" Event not for this date group");
        return;
      }
      console.log(" Opening accordion for cross-date navigation:", detail.topic);
      isExpanded.value = true;
      expandedTopics.value[detail.topic] = true;
      emit("accordion-toggle", props.group.date, true);
      if (props.accordionState) {
        props.accordionState[props.group.date] = true;
      }
      nextTick(() => {
        setTimeout(() => {
          const el = document.getElementById(`date-group-${props.group.date}-topic-${detail.topic}`);
          if (el && typeof el.scrollIntoView === "function") {
            console.log(" Scrolling to topic element");
            el.scrollIntoView({ behavior: "smooth", block: "center" });
          } else {
            console.log(" Topic element not found:", `date-group-${props.group.date}-topic-${detail.topic}`);
          }
          try {
            sessionStorage.removeItem(PENDING_OPEN_KEY);
          } catch {
          }
        }, 100);
      });
    };
    const isHoveringTooltip = ref(false);
    const handleTooltipMouseEnter = () => {
      isHoveringTooltip.value = true;
    };
    const handleTooltipMouseLeave = () => {
      isHoveringTooltip.value = false;
      infoHoverTopic.value = null;
    };
    onMounted(async () => {
      loadActionButtonsState();
      topicPaginationState.value = loadTopicPaginationState();
      if (props.accordionState && typeof props.accordionState[props.group.date] === "boolean") {
        isExpanded.value = props.accordionState[props.group.date];
      }
      const storedTopics = getStoredTopics();
      if (storedTopics[props.group.date]) {
        groupTopic.value = storedTopics[props.group.date];
      }
      window.addEventListener("vocabulary-list-mouse-leave", handleVocabularyListMouseLeave);
      window.addEventListener("vocabulary-list-mouse-enter", handleVocabularyListMouseEnter);
      startModalWatcher();
      await nextTick();
      await calculateHeight();
      try {
        const raw = sessionStorage.getItem(PENDING_OPEN_KEY);
        if (raw) {
          const pending = JSON.parse(raw);
          if (pending && pending.date === props.group.date) {
            console.log(" Applying pending open on mount:", pending);
            isExpanded.value = true;
            expandedTopics.value[pending.topic] = true;
            emit("accordion-toggle", props.group.date, true);
            if (props.accordionState) {
              props.accordionState[props.group.date] = true;
            }
            nextTick(() => {
              setTimeout(() => {
                const el = document.getElementById(`date-group-${props.group.date}-topic-${pending.topic}`);
                if (el && typeof el.scrollIntoView === "function") {
                  el.scrollIntoView({ behavior: "smooth", block: "center" });
                }
              }, 100);
            });
            sessionStorage.removeItem(PENDING_OPEN_KEY);
          }
        }
      } catch (err) {
        console.warn("Failed to apply pending open-date-topic on mount:", err);
      }
      window.addEventListener("available-dates-response", handleAvailableDatesResponse);
      window.addEventListener("open-date-topic", handleOpenDateTopic);
    });
    onUnmounted(() => {
      window.removeEventListener("vocabulary-list-mouse-leave", handleVocabularyListMouseLeave);
      window.removeEventListener("vocabulary-list-mouse-enter", handleVocabularyListMouseEnter);
      stopModalWatcher();
      Object.keys(hoverTimeouts.value).forEach((topic) => {
        if (hoverTimeouts.value[topic]) {
          clearTimeout(hoverTimeouts.value[topic]);
        }
      });
      window.removeEventListener("available-dates-response", handleAvailableDatesResponse);
      window.removeEventListener("open-date-topic", handleOpenDateTopic);
    });
    const emit = __emit;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1$b, [
          createBaseVNode("div", _hoisted_2$9, [
            createBaseVNode("div", _hoisted_3$8, [
              createBaseVNode("div", {
                onClick: toggleAccordion,
                class: "flex items-center justify-between mb-2 cursor-pointer py-1 -mx-1 px-1 rounded hover:bg-gray-50 dark:hover:bg-gray-custom transition-colors"
              }, [
                createBaseVNode("div", _hoisted_4$8, [
                  createBaseVNode("div", _hoisted_5$7, [
                    (openBlock(), createElementBlock("svg", {
                      class: normalizeClass(["w-2.5 h-2.5 text-gray-500 dark:text-gray-400 transition-transform duration-200", { "transform rotate-90": isExpanded.value }]),
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, _cache[48] || (_cache[48] = [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                        "clip-rule": "evenodd"
                      }, null, -1)
                    ]), 2))
                  ]),
                  createBaseVNode("h4", _hoisted_6$6, [
                    _cache[49] || (_cache[49] = createBaseVNode("svg", {
                      class: "w-2.5 h-2.5",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)),
                    createBaseVNode("span", null, toDisplayString$1(_ctx.group.displayDate), 1),
                    createBaseVNode("span", {
                      class: normalizeClass(["text-xs xs:text-xs sm:text-sm md:text-sm lg:text-base xl:text-sm 2xl:text-base font-semibold transition-colors duration-300", vocabularyCountColor.value])
                    }, " (" + toDisplayString$1(totalVocabularyCount.value) + ") ", 3),
                    createBaseVNode("span", _hoisted_7$6, [
                      createVNode(unref(CircularProgress), {
                        percentage: headerProgress.value.percentage,
                        size: 26,
                        "stroke-width": 1.5,
                        "show-text": true,
                        title: headerProgressTooltip.value
                      }, null, 8, ["percentage", "title"])
                    ])
                  ])
                ]),
                createBaseVNode("div", {
                  class: "flex items-center space-x-1",
                  onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                  }, ["stop"]))
                }, [
                  createBaseVNode("label", _hoisted_8$6, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showActionButtons.value = $event),
                      class: "sr-only peer"
                    }, null, 512), [
                      [vModelCheckbox, showActionButtons.value]
                    ]),
                    _cache[50] || (_cache[50] = createBaseVNode("div", { class: "w-9 h-5 sm:w-11 sm:h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-1 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 sm:after:h-5 sm:after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600" }, null, -1))
                  ])
                ]),
                isExpanded.value && _ctx.group.totalPages && _ctx.group.totalPages > 1 ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: "flex items-center space-x-1",
                  onClick: _cache[4] || (_cache[4] = withModifiers(() => {
                  }, ["stop"]))
                }, [
                  createBaseVNode("button", {
                    onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("date-group-previous", _ctx.group.date)),
                    disabled: (_ctx.group.currentPage || 1) === 1,
                    class: "px-1.5 py-0.5 xs:px-2 xs:py-1 sm:px-3 sm:py-1 md:px-4 md:py-1.5 xl:px-4 xl:py-1.5 2xl:px-5 2xl:py-2 text-xs xs:text-xs sm:text-sm md:text-sm lg:text-base xl:text-base 2xl:text-lg border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                  }, "  ", 8, _hoisted_9$6),
                  createBaseVNode("span", _hoisted_10$6, toDisplayString$1(_ctx.group.currentPage || 1) + "/" + toDisplayString$1(_ctx.group.totalPages), 1),
                  createBaseVNode("button", {
                    onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("date-group-next", _ctx.group.date)),
                    disabled: (_ctx.group.currentPage || 1) === _ctx.group.totalPages,
                    class: "px-1.5 py-0.5 xs:px-2 xs:py-1 sm:px-3 sm:py-1 md:px-4 md:py-1.5 xl:px-4 xl:py-1.5 2xl:px-5 2xl:py-2 text-xs xs:text-xs sm:text-sm md:text-sm lg:text-base xl:text-base 2xl:text-lg border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                  }, "  ", 8, _hoisted_11$6)
                ])) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", {
                class: "w-full",
                onClick: _cache[10] || (_cache[10] = withModifiers(() => {
                }, ["stop"]))
              }, [
                showTopicInput.value ? (openBlock(), createElementBlock("div", _hoisted_12$6, [
                  createBaseVNode("div", _hoisted_13$6, [
                    withDirectives(createBaseVNode("input", {
                      ref_key: "topicInput",
                      ref: topicInput,
                      "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => topicInputValue.value = $event),
                      onKeyup: [
                        withKeys(saveTopic, ["enter"]),
                        withKeys(cancelTopicInput, ["escape"])
                      ],
                      type: "text",
                      placeholder: unref(t)("vocabulary.accordion.topicPlaceholder"),
                      class: "flex-1 px-3 py-2 text-xs border border-orange-300 dark:border-orange-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
                    }, null, 40, _hoisted_14$6), [
                      [vModelText, topicInputValue.value]
                    ]),
                    createBaseVNode("button", {
                      onClick: saveTopic,
                      class: "px-2 py-2 text-xs bg-orange-600 hover:bg-orange-700 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500 transition-colors",
                      "aria-label": unref(t)("vocabulary.accordion.saveTopic")
                    }, _cache[51] || (_cache[51] = [
                      createBaseVNode("svg", {
                        class: "w-3 h-3",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)
                    ]), 8, _hoisted_15$5),
                    createBaseVNode("button", {
                      onClick: cancelTopicInput,
                      class: "px-2 py-2 text-xs bg-gray-500 hover:bg-gray-600 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors dark:bg-blue-700 dark:hover:bg-blue-600 dark:focus:ring-blue-500",
                      "aria-label": unref(t)("vocabulary.accordion.cancelTopic")
                    }, _cache[52] || (_cache[52] = [
                      createBaseVNode("svg", {
                        class: "w-3 h-3",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)
                    ]), 8, _hoisted_16$5)
                  ])
                ])) : (openBlock(), createElementBlock("div", _hoisted_17$5, [
                  groupTopic.value ? (openBlock(), createElementBlock("div", _hoisted_18$5, [
                    createBaseVNode("div", _hoisted_19$5, [
                      _cache[55] || (_cache[55] = createBaseVNode("svg", {
                        class: "w-3 h-3 text-orange-600 dark:text-orange-400 flex-shrink-0",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)),
                      createBaseVNode("div", _hoisted_20$5, [
                        createBaseVNode("span", {
                          ref_key: "topicSpanMobile",
                          ref: topicSpanMobile,
                          class: "text-xs font-medium text-orange-700 dark:text-orange-300 truncate block cursor-default",
                          onMouseenter: _cache[6] || (_cache[6] = ($event) => showTopicTooltip.value = true),
                          onMouseleave: _cache[7] || (_cache[7] = ($event) => showTopicTooltip.value = false)
                        }, toDisplayString$1(groupTopic.value), 545),
                        showTopicTooltip.value && isTopicTruncated.value ? (openBlock(), createElementBlock("div", _hoisted_21$5, [
                          createTextVNode(toDisplayString$1(groupTopic.value) + " ", 1),
                          _cache[53] || (_cache[53] = createBaseVNode("div", { class: "absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-gray-900 dark:border-t-gray-700" }, null, -1))
                        ])) : createCommentVNode("", true)
                      ]),
                      createBaseVNode("button", {
                        onClick: withModifiers(editTopic, ["stop"]),
                        class: "text-orange-600 dark:text-orange-400 hover:text-orange-700 dark:hover:text-orange-300 focus:outline-none flex-shrink-0 p-0.5 rounded hover:bg-orange-100 dark:hover:bg-orange-800/50 transition-colors",
                        "aria-label": unref(t)("vocabulary.accordion.editTopic")
                      }, _cache[54] || (_cache[54] = [
                        createBaseVNode("svg", {
                          class: "w-3 h-3",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
                        ], -1)
                      ]), 8, _hoisted_22$5)
                    ])
                  ])) : createCommentVNode("", true),
                  createBaseVNode("div", _hoisted_23$5, [
                    !groupTopic.value ? (openBlock(), createElementBlock("button", {
                      key: 0,
                      onClick: _cache[8] || (_cache[8] = withModifiers(($event) => showTopicInput.value = true, ["stop"])),
                      class: "flex flex-col items-center justify-center p-2 sm:p-3 text-xs sm:text-sm font-medium text-orange-600 dark:text-orange-400 hover:text-orange-700 dark:hover:text-orange-300 hover:bg-orange-50 dark:hover:bg-orange-900/50 rounded-md border border-dashed border-orange-300 dark:border-orange-600 hover:border-orange-400 dark:hover:border-orange-500 transition-all duration-200 focus:outline-none focus:ring-1 focus:ring-orange-500 min-h-[56px] sm:min-h-[64px] hover:scale-[1.02]",
                      "aria-label": unref(t)("vocabulary.accordion.addTopic", "Add Topic")
                    }, [
                      _cache[56] || (_cache[56] = createBaseVNode("svg", {
                        class: "w-3.5 h-3.5 sm:w-4 sm:h-4 mb-0.5",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)),
                      createBaseVNode("span", _hoisted_25$5, toDisplayString$1(unref(t)("vocabulary.accordion.addTopic", "Add Topic")), 1)
                    ], 8, _hoisted_24$5)) : createCommentVNode("", true),
                    showActionButtons.value ? (openBlock(), createElementBlock("div", _hoisted_26$4, [
                      createVNode(unref(VocabularyNoteButton$1), {
                        date: _ctx.group.date,
                        "is-today": isTodayGroup.value,
                        class: normalizeClass("w-full flex flex-col items-center justify-center p-2 sm:p-3 text-xs sm:text-sm font-medium min-h-[56px] sm:min-h-[64px] hover:scale-[1.02] transition-all duration-200 rounded-md"),
                        onOpenNoteDialog: _cache[9] || (_cache[9] = () => emit("open-note-dialog", { date: _ctx.group.date, words: _ctx.group.vocabularies }))
                      }, null, 8, ["date", "is-today"])
                    ])) : createCommentVNode("", true),
                    showActionButtons.value ? (openBlock(), createElementBlock("button", {
                      key: 2,
                      onClick: withModifiers(openAddVocabularyDialog, ["stop"]),
                      class: "flex flex-col items-center justify-center p-2 sm:p-3 text-xs sm:text-sm font-medium text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 hover:bg-blue-50 dark:hover:bg-blue-900/50 rounded-md border border-dashed border-blue-300 dark:border-blue-600 hover:border-blue-400 dark:hover:border-blue-500 transition-all duration-200 focus:outline-none focus:ring-1 focus:ring-blue-500 min-h-[56px] sm:min-h-[64px] hover:scale-[1.02]",
                      "aria-label": unref(t)("vocabulary.addWord", "Add Word")
                    }, [
                      _cache[57] || (_cache[57] = createBaseVNode("svg", {
                        class: "w-3.5 h-3.5 sm:w-4 sm:h-4 mb-0.5",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)),
                      createBaseVNode("span", _hoisted_28$4, toDisplayString$1(unref(t)("vocabulary.addWord", "Add Word")), 1)
                    ], 8, _hoisted_27$4)) : createCommentVNode("", true),
                    showActionButtons.value ? (openBlock(), createElementBlock("div", _hoisted_29$4, [
                      createVNode(unref(GrammarManagerButton$1), {
                        date: _ctx.group.date,
                        class: normalizeClass("w-full flex flex-col items-center justify-center p-2 sm:p-3 text-xs sm:text-sm font-medium min-h-[56px] sm:min-h-[64px] hover:scale-[1.02] transition-all duration-200 rounded-md"),
                        onOpenGrammarManager: openGrammarManager
                      }, null, 8, ["date"])
                    ])) : createCommentVNode("", true)
                  ])
                ]))
              ])
            ]),
            createBaseVNode("div", _hoisted_30$4, [
              createBaseVNode("div", {
                onClick: toggleAccordion,
                class: "flex items-center justify-between cursor-pointer py-1 -mx-1 px-1 rounded hover:bg-gray-50 dark:hover:bg-gray-custom transition-colors"
              }, [
                createBaseVNode("div", _hoisted_31$4, [
                  createBaseVNode("div", _hoisted_32$3, [
                    (openBlock(), createElementBlock("svg", {
                      class: normalizeClass(["w-3 xs:w-3.5 sm:w-4 h-3 xs:h-3.5 sm:h-4 text-gray-500 dark:text-gray-400 transition-transform duration-200", { "transform rotate-90": isExpanded.value }]),
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, _cache[58] || (_cache[58] = [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                        "clip-rule": "evenodd"
                      }, null, -1)
                    ]), 2))
                  ]),
                  createBaseVNode("h4", _hoisted_33$3, [
                    _cache[59] || (_cache[59] = createBaseVNode("svg", {
                      class: "w-3 md:w-4 lg:w-4 xl:w-5 xl:h-5 2xl:w-6 2xl:h-6 h-3 md:h-4 lg:h-4",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)),
                    createBaseVNode("span", null, toDisplayString$1(_ctx.group.displayDate), 1),
                    createBaseVNode("span", {
                      class: normalizeClass(["text-xs xs:text-xs sm:text-sm md:text-sm lg:text-base xl:text-sm 2xl:text-base font-semibold transition-colors duration-300", vocabularyCountColor.value])
                    }, " (" + toDisplayString$1(totalVocabularyCount.value) + " " + toDisplayString$1(unref(t)("vocabulary.words", "words")) + ") ", 3),
                    createBaseVNode("span", _hoisted_34$3, [
                      createVNode(unref(CircularProgress), {
                        percentage: headerProgress.value.percentage,
                        size: 28,
                        "stroke-width": 1.5,
                        "show-text": true,
                        title: headerProgressTooltip.value
                      }, null, 8, ["percentage", "title"])
                    ])
                  ])
                ]),
                createBaseVNode("div", {
                  class: "lg:hidden flex items-center space-x-2",
                  onClick: _cache[12] || (_cache[12] = withModifiers(() => {
                  }, ["stop"]))
                }, [
                  createBaseVNode("label", _hoisted_35$3, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => showActionButtons.value = $event),
                      class: "sr-only peer"
                    }, null, 512), [
                      [vModelCheckbox, showActionButtons.value]
                    ]),
                    _cache[60] || (_cache[60] = createBaseVNode("div", { class: "w-7 h-4 bg-gray-200 peer-focus:outline-none peer-focus:ring-1 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-3 after:w-3 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600" }, null, -1))
                  ])
                ]),
                createBaseVNode("div", _hoisted_36$3, [
                  isExpanded.value && _ctx.group.totalPages && _ctx.group.totalPages > 1 ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: "flex items-center space-x-2",
                    onClick: _cache[15] || (_cache[15] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("button", {
                      onClick: _cache[13] || (_cache[13] = ($event) => _ctx.$emit("date-group-previous", _ctx.group.date)),
                      disabled: (_ctx.group.currentPage || 1) === 1,
                      class: "px-2 md:px-2 py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 xl:px-3 xl:py-1.5 2xl:px-4 2xl:py-2 text-xs xs:text-xs sm:text-sm md:text-sm lg:text-base xl:text-sm 2xl:text-base border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, toDisplayString$1(unref(t)("common.previous")), 9, _hoisted_37$2),
                    createBaseVNode("span", _hoisted_38$2, toDisplayString$1(_ctx.group.currentPage || 1) + " / " + toDisplayString$1(_ctx.group.totalPages), 1),
                    createBaseVNode("button", {
                      onClick: _cache[14] || (_cache[14] = ($event) => _ctx.$emit("date-group-next", _ctx.group.date)),
                      disabled: (_ctx.group.currentPage || 1) === _ctx.group.totalPages,
                      class: "px-2 md:px-2 py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 xl:px-3 xl:py-1.5 2xl:px-4 2xl:py-2 text-xs xs:text-xs sm:text-sm md:text-sm lg:text-base xl:text-sm 2xl:text-base border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, toDisplayString$1(unref(t)("common.next")), 9, _hoisted_39$2)
                  ])) : createCommentVNode("", true),
                  createBaseVNode("div", {
                    class: "flex items-center space-x-2",
                    onClick: _cache[17] || (_cache[17] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    createBaseVNode("label", _hoisted_40$2, [
                      withDirectives(createBaseVNode("input", {
                        type: "checkbox",
                        "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => showActionButtons.value = $event),
                        class: "sr-only peer"
                      }, null, 512), [
                        [vModelCheckbox, showActionButtons.value]
                      ]),
                      _cache[61] || (_cache[61] = createBaseVNode("div", { class: "w-9 h-5 sm:w-11 sm:h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 sm:after:h-5 sm:after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600" }, null, -1))
                    ]),
                    createBaseVNode("span", _hoisted_41$1, toDisplayString$1(unref(t)("common.actions", "Actions")), 1)
                  ])
                ])
              ]),
              isExpanded.value && _ctx.group.totalPages && _ctx.group.totalPages > 1 ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "lg:hidden flex items-center justify-center space-x-1 mt-2",
                onClick: _cache[20] || (_cache[20] = withModifiers(() => {
                }, ["stop"]))
              }, [
                createBaseVNode("button", {
                  onClick: _cache[18] || (_cache[18] = ($event) => _ctx.$emit("date-group-previous", _ctx.group.date)),
                  disabled: (_ctx.group.currentPage || 1) === 1,
                  class: "px-1.5 py-0.5 xs:px-2 xs:py-1 sm:px-3 sm:py-1 md:px-4 md:py-1.5 text-xs xs:text-xs sm:text-sm md:text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                }, "  ", 8, _hoisted_42$1),
                createBaseVNode("span", _hoisted_43$1, toDisplayString$1(_ctx.group.currentPage || 1) + "/" + toDisplayString$1(_ctx.group.totalPages), 1),
                createBaseVNode("button", {
                  onClick: _cache[19] || (_cache[19] = ($event) => _ctx.$emit("date-group-next", _ctx.group.date)),
                  disabled: (_ctx.group.currentPage || 1) === _ctx.group.totalPages,
                  class: "px-1.5 py-0.5 xs:px-2 xs:py-1 sm:px-3 sm:py-1 md:px-4 md:py-1.5 text-xs xs:text-xs sm:text-sm md:text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                }, "  ", 8, _hoisted_44$1)
              ])) : createCommentVNode("", true),
              createBaseVNode("div", {
                class: "lg:hidden flex items-center justify-center space-x-2 mt-2",
                onClick: _cache[26] || (_cache[26] = withModifiers(() => {
                }, ["stop"]))
              }, [
                !showTopicInput.value ? (openBlock(), createElementBlock("div", _hoisted_45$1, [
                  groupTopic.value ? (openBlock(), createElementBlock("div", _hoisted_46$1, [
                    _cache[64] || (_cache[64] = createBaseVNode("svg", {
                      class: "w-2.5 xs:w-3 sm:w-3 md:w-4 h-2.5 xs:h-3 sm:h-3 md:h-4 text-orange-600 dark:text-orange-400",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)),
                    createBaseVNode("div", _hoisted_47$1, [
                      createBaseVNode("span", {
                        ref: "topicSpanTablet",
                        class: "font-medium text-orange-700 dark:text-orange-300 truncate max-w-[80px] sm:max-w-none block cursor-default text-xs xs:text-xs sm:text-sm md:text-sm",
                        onMouseenter: _cache[21] || (_cache[21] = ($event) => showTopicTooltip.value = true),
                        onMouseleave: _cache[22] || (_cache[22] = ($event) => showTopicTooltip.value = false)
                      }, toDisplayString$1(groupTopic.value), 545),
                      showTopicTooltip.value && isTopicTruncated.value ? (openBlock(), createElementBlock("div", _hoisted_48$1, [
                        createTextVNode(toDisplayString$1(groupTopic.value) + " ", 1),
                        _cache[62] || (_cache[62] = createBaseVNode("div", { class: "absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-gray-900 dark:border-t-gray-700" }, null, -1))
                      ])) : createCommentVNode("", true)
                    ]),
                    createBaseVNode("button", {
                      onClick: withModifiers(editTopic, ["stop"]),
                      class: "text-orange-600 dark:text-orange-400 hover:text-orange-800 dark:hover:text-orange-200 focus:outline-none flex-shrink-0",
                      "aria-label": unref(t)("vocabulary.accordion.editTopic")
                    }, _cache[63] || (_cache[63] = [
                      createBaseVNode("svg", {
                        class: "w-2.5 xs:w-3 sm:w-3 md:w-4 h-2.5 xs:h-3 sm:h-3 md:h-4",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
                      ], -1)
                    ]), 8, _hoisted_49$1)
                  ])) : (openBlock(), createElementBlock("button", {
                    key: 1,
                    onClick: _cache[23] || (_cache[23] = withModifiers(($event) => showTopicInput.value = true, ["stop"])),
                    class: "flex items-center space-x-0.5 xs:space-x-1 sm:space-x-1 md:space-x-1.5 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 text-xs xs:text-xs sm:text-sm md:text-sm bg-orange-50 hover:bg-orange-100 dark:bg-orange-900/20 dark:hover:bg-orange-800/30 text-orange-600 dark:text-orange-400 rounded-full border border-orange-200 dark:border-orange-800 cursor-pointer transition-colors duration-150",
                    "aria-label": unref(t)("vocabulary.accordion.addTopic", "Add Topic")
                  }, [
                    _cache[65] || (_cache[65] = createBaseVNode("svg", {
                      class: "w-3 md:w-4 h-3 md:h-4",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)),
                    createBaseVNode("span", _hoisted_51, toDisplayString$1(unref(t)("vocabulary.accordion.addTopic", "Add Topic")), 1)
                  ], 8, _hoisted_50$1)),
                  showActionButtons.value ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    createVNode(unref(VocabularyNoteButton$1), {
                      date: _ctx.group.date,
                      "is-today": isTodayGroup.value,
                      onOpenNoteDialog: _cache[24] || (_cache[24] = () => emit("open-note-dialog", { date: _ctx.group.date, words: _ctx.group.vocabularies }))
                    }, null, 8, ["date", "is-today"]),
                    createBaseVNode("button", {
                      onClick: openAddVocabularyDialog,
                      class: "flex items-center space-x-1 md:space-x-1.5 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 text-xs md:text-sm font-medium text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 hover:bg-blue-50 dark:hover:bg-blue-900/50 rounded-full border border-dashed border-blue-300 dark:border-blue-600 hover:border-blue-400 dark:hover:border-blue-500 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500",
                      "aria-label": unref(t)("vocabulary.addWord", "Add Word")
                    }, [
                      _cache[66] || (_cache[66] = createBaseVNode("svg", {
                        class: "w-3 md:w-4 h-3 md:h-4",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)),
                      createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.addWord", "Add Word")), 1)
                    ], 8, _hoisted_52),
                    createVNode(unref(GrammarManagerButton$1), {
                      date: _ctx.group.date,
                      onOpenGrammarManager: openGrammarManager
                    }, null, 8, ["date"])
                  ], 64)) : createCommentVNode("", true)
                ])) : (openBlock(), createElementBlock("div", _hoisted_53, [
                  withDirectives(createBaseVNode("input", {
                    ref: "topicInputTablet",
                    "onUpdate:modelValue": _cache[25] || (_cache[25] = ($event) => topicInputValue.value = $event),
                    onKeyup: [
                      withKeys(saveTopic, ["enter"]),
                      withKeys(cancelTopicInput, ["escape"])
                    ],
                    type: "text",
                    placeholder: unref(t)("vocabulary.accordion.topicPlaceholder"),
                    class: "flex-1 px-2 xs:px-2 sm:px-2 md:px-2 py-0.5 xs:py-1 sm:py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 text-xs border border-orange-300 dark:border-orange-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
                  }, null, 40, _hoisted_54), [
                    [vModelText, topicInputValue.value]
                  ]),
                  createBaseVNode("button", {
                    onClick: saveTopic,
                    class: "px-1.5 xs:px-2 sm:px-2 md:px-2 py-0.5 xs:py-1 sm:py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 text-xs bg-orange-600 hover:bg-orange-700 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500 transition-colors",
                    "aria-label": unref(t)("vocabulary.accordion.saveTopic")
                  }, _cache[67] || (_cache[67] = [
                    createBaseVNode("svg", {
                      class: "w-3 h-3",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)
                  ]), 8, _hoisted_55),
                  createBaseVNode("button", {
                    onClick: cancelTopicInput,
                    class: "px-1.5 xs:px-2 sm:px-2 md:px-2 py-0.5 xs:py-1 sm:py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 text-xs bg-gray-500 hover:bg-gray-600 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors",
                    "aria-label": unref(t)("vocabulary.accordion.cancelTopic")
                  }, _cache[68] || (_cache[68] = [
                    createBaseVNode("svg", {
                      class: "w-3 h-3",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)
                  ]), 8, _hoisted_56)
                ]))
              ])
            ]),
            createBaseVNode("div", _hoisted_57, [
              createBaseVNode("div", {
                onClick: toggleAccordion,
                class: "flex items-center justify-between flex-wrap gap-1 cursor-pointer py-1 -mx-1 px-1 rounded hover:bg-gray-50 dark:hover:bg-gray-custom transition-colors"
              }, [
                createBaseVNode("div", _hoisted_58, [
                  !showTopicInput.value ? (openBlock(), createElementBlock("div", _hoisted_59, [
                    groupTopic.value ? (openBlock(), createElementBlock("div", _hoisted_60, [
                      _cache[71] || (_cache[71] = createBaseVNode("svg", {
                        class: "w-3 md:w-4 lg:w-4 xl:w-5 xl:h-5 2xl:w-6 2xl:h-6 h-3 md:h-4 lg:h-4 text-orange-600 dark:text-orange-400",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)),
                      createBaseVNode("div", _hoisted_61, [
                        createBaseVNode("span", {
                          ref_key: "topicSpanDesktop",
                          ref: topicSpanDesktop,
                          class: "text-xs md:text-sm lg:text-base xl:text-sm 2xl:text-base font-medium text-orange-700 dark:text-orange-300 truncate max-w-[80px] sm:max-w-none block cursor-default",
                          onMouseenter: _cache[27] || (_cache[27] = ($event) => showTopicTooltip.value = true),
                          onMouseleave: _cache[28] || (_cache[28] = ($event) => showTopicTooltip.value = false)
                        }, toDisplayString$1(groupTopic.value), 545),
                        showTopicTooltip.value && isTopicTruncated.value ? (openBlock(), createElementBlock("div", _hoisted_62, [
                          createTextVNode(toDisplayString$1(groupTopic.value) + " ", 1),
                          _cache[69] || (_cache[69] = createBaseVNode("div", { class: "absolute top-full left-1/2 transform -translate-x-1/2 border-4 border-transparent border-t-gray-900 dark:border-t-gray-700" }, null, -1))
                        ])) : createCommentVNode("", true)
                      ]),
                      createBaseVNode("button", {
                        onClick: withModifiers(editTopic, ["stop"]),
                        class: "text-orange-600 dark:text-orange-400 hover:text-orange-800 dark:hover:text-orange-200 focus:outline-none flex-shrink-0",
                        "aria-label": unref(t)("vocabulary.accordion.editTopic")
                      }, _cache[70] || (_cache[70] = [
                        createBaseVNode("svg", {
                          class: "w-3 md:w-4 lg:w-4 xl:w-5 xl:h-5 2xl:w-6 2xl:h-6 h-3 md:h-4 lg:h-4",
                          fill: "currentColor",
                          viewBox: "0 0 20 20"
                        }, [
                          createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
                        ], -1)
                      ]), 8, _hoisted_63)
                    ])) : (openBlock(), createElementBlock("button", {
                      key: 1,
                      onClick: _cache[29] || (_cache[29] = withModifiers(($event) => showTopicInput.value = true, ["stop"])),
                      class: "flex items-center space-x-1 md:space-x-1.5 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 text-xs md:text-sm lg:text-base xl:text-sm 2xl:text-base font-medium bg-orange-50 hover:bg-orange-100 dark:bg-orange-900/20 dark:hover:bg-orange-800/30 text-orange-600 dark:text-orange-400 rounded-full border border-dashed border-orange-200 dark:border-orange-800 hover:border-orange-400 dark:hover:border-orange-500 transition-colors focus:outline-none focus:ring-2 focus:ring-orange-500",
                      "aria-label": unref(t)("vocabulary.accordion.addTopic", "Add Topic")
                    }, [
                      _cache[72] || (_cache[72] = createBaseVNode("svg", {
                        class: "w-3 md:w-4 lg:w-4 xl:w-5 xl:h-5 2xl:w-6 2xl:h-6 h-3 md:h-4 lg:h-4",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)),
                      createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.accordion.addTopic", "Add Topic")), 1)
                    ], 8, _hoisted_64)),
                    showActionButtons.value ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                      createBaseVNode("div", {
                        class: "flex-shrink-0",
                        onClick: _cache[31] || (_cache[31] = withModifiers(() => {
                        }, ["stop"]))
                      }, [
                        createVNode(unref(VocabularyNoteButton$1), {
                          date: _ctx.group.date,
                          "is-today": isTodayGroup.value,
                          onOpenNoteDialog: _cache[30] || (_cache[30] = () => emit("open-note-dialog", { date: _ctx.group.date, words: _ctx.group.vocabularies }))
                        }, null, 8, ["date", "is-today"])
                      ]),
                      createBaseVNode("div", {
                        class: "flex-shrink-0",
                        onClick: _cache[32] || (_cache[32] = withModifiers(() => {
                        }, ["stop"]))
                      }, [
                        createBaseVNode("button", {
                          onClick: openAddVocabularyDialog,
                          class: "flex items-center space-x-1 md:space-x-1.5 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 text-xs md:text-sm lg:text-base xl:text-sm 2xl:text-base font-medium text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 hover:bg-blue-50 dark:hover:bg-blue-900/50 rounded-full border border-dashed border-blue-300 dark:border-blue-600 hover:border-blue-400 dark:hover:border-blue-500 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500",
                          "aria-label": unref(t)("vocabulary.addWord", "Add Word")
                        }, [
                          _cache[73] || (_cache[73] = createBaseVNode("svg", {
                            class: "w-3 md:w-4 lg:w-4 xl:w-5 xl:h-5 2xl:w-6 2xl:h-6 h-3 md:h-4 lg:h-4",
                            fill: "currentColor",
                            viewBox: "0 0 20 20"
                          }, [
                            createBaseVNode("path", {
                              "fill-rule": "evenodd",
                              d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
                              "clip-rule": "evenodd"
                            })
                          ], -1)),
                          createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.addWord", "Add Word")), 1)
                        ], 8, _hoisted_65)
                      ]),
                      createBaseVNode("div", {
                        class: "flex-shrink-0",
                        onClick: _cache[33] || (_cache[33] = withModifiers(() => {
                        }, ["stop"]))
                      }, [
                        createVNode(unref(GrammarManagerButton$1), {
                          date: _ctx.group.date,
                          onOpenGrammarManager: openGrammarManager
                        }, null, 8, ["date"])
                      ])
                    ], 64)) : createCommentVNode("", true)
                  ])) : (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: "flex items-center space-x-1 xs:space-x-1.5 sm:space-x-2 w-full max-w-[150px] xs:max-w-[200px] sm:max-w-xs",
                    onClick: _cache[35] || (_cache[35] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    withDirectives(createBaseVNode("input", {
                      ref_key: "topicInput",
                      ref: topicInput,
                      "onUpdate:modelValue": _cache[34] || (_cache[34] = ($event) => topicInputValue.value = $event),
                      onKeyup: [
                        withKeys(saveTopic, ["enter"]),
                        withKeys(cancelTopicInput, ["escape"])
                      ],
                      type: "text",
                      placeholder: unref(t)("vocabulary.accordion.topicPlaceholder"),
                      class: "flex-1 px-2 xs:px-2 sm:px-2 md:px-2 py-0.5 xs:py-1 sm:py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 text-xs border border-orange-300 dark:border-orange-600 rounded-md bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent"
                    }, null, 40, _hoisted_66), [
                      [vModelText, topicInputValue.value]
                    ]),
                    createBaseVNode("button", {
                      onClick: saveTopic,
                      class: "px-1.5 xs:px-2 sm:px-2 md:px-2 py-0.5 xs:py-1 sm:py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 text-xs bg-orange-600 hover:bg-orange-700 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500 transition-colors",
                      "aria-label": unref(t)("vocabulary.accordion.saveTopic")
                    }, _cache[74] || (_cache[74] = [
                      createBaseVNode("svg", {
                        class: "w-3 h-3",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)
                    ]), 8, _hoisted_67),
                    createBaseVNode("button", {
                      onClick: cancelTopicInput,
                      class: "px-1.5 xs:px-2 sm:px-2 md:px-2 py-0.5 xs:py-1 sm:py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 text-xs bg-gray-500 hover:bg-gray-600 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors",
                      "aria-label": unref(t)("vocabulary.accordion.cancelTopic")
                    }, _cache[75] || (_cache[75] = [
                      createBaseVNode("svg", {
                        class: "w-3 h-3",
                        fill: "currentColor",
                        viewBox: "0 0 20 20"
                      }, [
                        createBaseVNode("path", {
                          "fill-rule": "evenodd",
                          d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
                          "clip-rule": "evenodd"
                        })
                      ], -1)
                    ]), 8, _hoisted_68)
                  ]))
                ])
              ])
            ])
          ]),
          createVNode(Transition, { name: "accordion" }, {
            default: withCtx(() => [
              isExpanded.value ? (openBlock(), createElementBlock("div", _hoisted_69, [
                _ctx.group.topics && _ctx.group.topics.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_70, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.group.topics, (topicGroup) => {
                    return openBlock(), createElementBlock("div", {
                      key: topicGroup.topic,
                      class: "topic-group",
                      onMouseenter: ($event) => _ctx.hoverToExpandEnabled ? handleTopicHover(topicGroup.topic, true) : null,
                      onMouseleave: ($event) => _ctx.hoverToExpandEnabled ? handleTopicHover(topicGroup.topic, false) : null
                    }, [
                      createBaseVNode("div", _hoisted_72, [
                        createBaseVNode("div", {
                          id: `date-group-${_ctx.group.date}-topic-${topicGroup.topic}`,
                          class: "flex items-center justify-between px-6 py-3 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-custom/50",
                          onClick: ($event) => toggleTopicAccordion(topicGroup.topic)
                        }, [
                          createBaseVNode("div", _hoisted_74, [
                            (openBlock(), createElementBlock("svg", {
                              class: normalizeClass(["w-4 h-4 text-gray-400 dark:text-gray-500 transition-transform duration-200", { "transform rotate-90": isTopicExpanded(topicGroup.topic) }]),
                              fill: "currentColor",
                              viewBox: "0 0 20 20"
                            }, _cache[76] || (_cache[76] = [
                              createBaseVNode("path", {
                                "fill-rule": "evenodd",
                                d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                                "clip-rule": "evenodd"
                              }, null, -1)
                            ]), 2)),
                            createBaseVNode("div", _hoisted_75, [
                              createBaseVNode("h5", _hoisted_76, [
                                createTextVNode(toDisplayString$1(unref(getTopicName)(topicGroup.topic, unref(t), unref(locale))) + " ", 1),
                                createBaseVNode("span", _hoisted_77, "(" + toDisplayString$1(topicGroup.vocabularies.length) + ")", 1)
                              ]),
                              createBaseVNode("div", {
                                class: "relative",
                                onMouseenter: withModifiers(($event) => handleInfoMouseEnter(topicGroup.topic), ["stop"]),
                                onMouseleave: handleInfoMouseLeave,
                                onClick: _cache[36] || (_cache[36] = withModifiers(() => {
                                }, ["stop"]))
                              }, [
                                createBaseVNode("button", {
                                  type: "button",
                                  class: "p-1 text-blue-600 dark:text-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900/20 rounded-md",
                                  "aria-label": unref(t)("vocabulary.sameTopicDatesAria", "Show dates with same topic")
                                }, _cache[77] || (_cache[77] = [
                                  createBaseVNode("svg", {
                                    viewBox: "0 0 24 24",
                                    fill: "currentColor",
                                    class: "w-4 h-4"
                                  }, [
                                    createBaseVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm.75 15h-1.5v-6h1.5v6zm0-8h-1.5V7h1.5v2z" })
                                  ], -1)
                                ]), 8, _hoisted_79),
                                infoHoverTopic.value === topicGroup.topic ? (openBlock(), createElementBlock("div", {
                                  key: 0,
                                  class: "absolute left-full top-1/2 -translate-y-1/2 ml-3 w-64 rounded-lg shadow-xl ring-1 ring-black/5 bg-white text-gray-800 p-3 z-30 border border-gray-200 dark:bg-[#0a0a0a] dark:text-white dark:border dark:border-[#0f0f0f]",
                                  onMouseenter: handleTooltipMouseEnter,
                                  onMouseleave: handleTooltipMouseLeave
                                }, [
                                  _cache[78] || (_cache[78] = createBaseVNode("div", {
                                    class: "absolute -left-1.5 top-1/2 -translate-y-1/2 w-3 h-3 rotate-45 bg-white dark:bg-[#0a0a0a]",
                                    "aria-hidden": "true"
                                  }, null, -1)),
                                  createBaseVNode("div", _hoisted_80, toDisplayString$1(unref(t)("vocabulary.sameTopicDatesTitle", "Dates with same topic")), 1),
                                  !availableDatesByTopic.value[topicGroup.topic] || availableDatesByTopic.value[topicGroup.topic].length === 0 ? (openBlock(), createElementBlock("div", _hoisted_81, toDisplayString$1(unref(t)("vocabulary.sameTopicDatesEmpty", "No other dates found for this topic")), 1)) : (openBlock(), createElementBlock("ul", {
                                    key: 1,
                                    class: normalizeClass(["text-xs space-y-1 pr-1 overflow-y-auto", { "max-h-24": (availableDatesByTopic.value[topicGroup.topic]?.length || 0) >= 4 }])
                                  }, [
                                    (openBlock(true), createElementBlock(Fragment, null, renderList(availableDatesByTopic.value[topicGroup.topic], (d) => {
                                      return openBlock(), createElementBlock("li", {
                                        key: d.date,
                                        class: "flex items-center justify-between hover:bg-white dark:hover:bg-[#0f0f0f] rounded px-2 py-1 cursor-pointer",
                                        onClick: ($event) => handleNavigateClick(d.date, topicGroup.topic)
                                      }, [
                                        createBaseVNode("span", null, toDisplayString$1(formatDateForDisplay(d.date)), 1),
                                        createBaseVNode("span", _hoisted_83, "(" + toDisplayString$1(d.count) + ")", 1)
                                      ], 8, _hoisted_82);
                                    }), 128))
                                  ], 2))
                                ], 32)) : createCommentVNode("", true)
                              ], 40, _hoisted_78)
                            ])
                          ]),
                          _ctx.globalMoveMode && topicGroup.vocabularies.length > 0 ? (openBlock(), createElementBlock("button", {
                            key: 0,
                            onClick: withModifiers(($event) => handleBatchMoveCategory(topicGroup), ["stop"]),
                            class: "ml-auto mr-2 p-1.5 text-purple-600 dark:text-purple-400 hover:bg-purple-50 dark:hover:bg-purple-900/20 rounded-md transition-colors",
                            title: unref(t)("vocabulary.moveCategoryToAnotherDay", "Move all words in this category to another day")
                          }, _cache[79] || (_cache[79] = [
                            createBaseVNode("svg", {
                              class: "w-4 h-4",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"
                              })
                            ], -1)
                          ]), 8, _hoisted_84)) : createCommentVNode("", true)
                        ], 8, _hoisted_73),
                        isTopicExpanded(topicGroup.topic) && getPaginatedTopicVocabularies(topicGroup).totalPages > 1 ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          class: "px-6 pb-3",
                          onClick: _cache[37] || (_cache[37] = withModifiers(() => {
                          }, ["stop"]))
                        }, [
                          createBaseVNode("div", _hoisted_85, [
                            createBaseVNode("div", _hoisted_86, [
                              createBaseVNode("button", {
                                onClick: ($event) => previousTopicPage(topicGroup.topic),
                                disabled: !getPaginatedTopicVocabularies(topicGroup).hasPrevious,
                                class: "relative inline-flex items-center px-2 md:px-2 py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 border border-gray-300 dark:border-gray-600 text-xs font-medium rounded text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                              }, toDisplayString$1(unref(t)("common.previous")), 9, _hoisted_87),
                              createBaseVNode("button", {
                                onClick: ($event) => nextTopicPage(topicGroup.topic),
                                disabled: !getPaginatedTopicVocabularies(topicGroup).hasNext,
                                class: "ml-2 relative inline-flex items-center px-2 md:px-2 py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 border border-gray-300 dark:border-gray-600 text-xs font-medium rounded text-gray-700 dark:text-gray-300 bg-white dark:bg-[#0a0a0a] hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                              }, toDisplayString$1(unref(t)("common.next")), 9, _hoisted_88)
                            ]),
                            createBaseVNode("div", _hoisted_89, [
                              createBaseVNode("div", null, [
                                createBaseVNode("p", _hoisted_90, toDisplayString$1(unref(t)("vocabulary.showingCategoryItems", {
                                  start: getPaginatedTopicVocabularies(topicGroup).startIndex,
                                  end: getPaginatedTopicVocabularies(topicGroup).endIndex,
                                  total: getPaginatedTopicVocabularies(topicGroup).totalItems
                                }, `Showing ${getPaginatedTopicVocabularies(topicGroup).startIndex} to ${getPaginatedTopicVocabularies(topicGroup).endIndex} of ${getPaginatedTopicVocabularies(topicGroup).totalItems} items`)), 1)
                              ]),
                              createBaseVNode("div", null, [
                                createBaseVNode("nav", _hoisted_91, [
                                  createBaseVNode("button", {
                                    onClick: ($event) => previousTopicPage(topicGroup.topic),
                                    disabled: !getPaginatedTopicVocabularies(topicGroup).hasPrevious,
                                    class: "relative inline-flex items-center px-1.5 md:px-1.5 py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 rounded-l-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-xs font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                                  }, [
                                    createBaseVNode("span", _hoisted_93, toDisplayString$1(unref(t)("common.previous")), 1),
                                    _cache[80] || (_cache[80] = createBaseVNode("svg", {
                                      class: "h-3 w-3",
                                      fill: "currentColor",
                                      viewBox: "0 0 20 20"
                                    }, [
                                      createBaseVNode("path", {
                                        "fill-rule": "evenodd",
                                        d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
                                        "clip-rule": "evenodd"
                                      })
                                    ], -1))
                                  ], 8, _hoisted_92),
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(getVisibleTopicPages(getPaginatedTopicVocabularies(topicGroup).currentPage, getPaginatedTopicVocabularies(topicGroup).totalPages), (page) => {
                                    return openBlock(), createElementBlock("button", {
                                      key: `${topicGroup.topic}-${page}`,
                                      onClick: ($event) => page > 0 ? goToTopicPage(topicGroup.topic, page) : null,
                                      disabled: page === -1,
                                      class: normalizeClass([
                                        page === getPaginatedTopicVocabularies(topicGroup).currentPage ? "z-10 bg-blue-50 dark:bg-blue-900 border-blue-500 dark:border-blue-400 text-blue-600 dark:text-blue-300" : page === -1 ? "bg-white dark:bg-[#0a0a0a] border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-400 cursor-default" : "bg-white dark:bg-[#0a0a0a] border-gray-300 dark:border-gray-600 text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600",
                                        "relative inline-flex items-center px-2 md:px-2 py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 border text-xs font-medium"
                                      ])
                                    }, toDisplayString$1(page === -1 ? "..." : page), 11, _hoisted_94);
                                  }), 128)),
                                  createBaseVNode("button", {
                                    onClick: ($event) => nextTopicPage(topicGroup.topic),
                                    disabled: !getPaginatedTopicVocabularies(topicGroup).hasNext,
                                    class: "relative inline-flex items-center px-1.5 md:px-1.5 py-1 md:py-1.5 xl:py-1.5 2xl:py-1.5 rounded-r-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-[#0a0a0a] text-xs font-medium text-gray-500 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                                  }, [
                                    createBaseVNode("span", _hoisted_96, toDisplayString$1(unref(t)("common.next")), 1),
                                    _cache[81] || (_cache[81] = createBaseVNode("svg", {
                                      class: "h-3 w-3",
                                      fill: "currentColor",
                                      viewBox: "0 0 20 20"
                                    }, [
                                      createBaseVNode("path", {
                                        "fill-rule": "evenodd",
                                        d: "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z",
                                        "clip-rule": "evenodd"
                                      })
                                    ], -1))
                                  ], 8, _hoisted_95)
                                ])
                              ])
                            ])
                          ])
                        ])) : createCommentVNode("", true)
                      ]),
                      createVNode(Transition, { name: "topic-accordion" }, {
                        default: withCtx(() => [
                          isTopicExpanded(topicGroup.topic) ? (openBlock(), createElementBlock("div", _hoisted_97, [
                            createBaseVNode("div", _hoisted_98, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(getPaginatedTopicVocabularies(topicGroup).vocabularies, (word) => {
                                return openBlock(), createBlock(unref(VocabularyCard), {
                                  key: word.id,
                                  word,
                                  "move-mode": _ctx.globalMoveMode,
                                  onPlayAudio: _cache[38] || (_cache[38] = ($event) => _ctx.$emit("play-audio", $event)),
                                  onEditWord: _cache[39] || (_cache[39] = ($event) => _ctx.$emit("edit-word", $event)),
                                  onDeleteWord: _cache[40] || (_cache[40] = ($event) => _ctx.$emit("delete-word", $event)),
                                  onToggleFavorite: _cache[41] || (_cache[41] = ($event) => _ctx.$emit("toggle-favorite", $event)),
                                  onViewDetails: _cache[42] || (_cache[42] = ($event) => _ctx.$emit("view-details", $event)),
                                  onMoveVocabulary: handleMoveVocabulary
                                }, null, 8, ["word", "move-mode"]);
                              }), 128))
                            ])
                          ])) : createCommentVNode("", true)
                        ]),
                        _: 2
                      }, 1024)
                    ], 40, _hoisted_71);
                  }), 128))
                ])) : (openBlock(), createElementBlock("div", _hoisted_99, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.group.vocabularies, (word) => {
                    return openBlock(), createBlock(unref(VocabularyCard), {
                      key: word.id,
                      word,
                      "move-mode": _ctx.globalMoveMode,
                      onPlayAudio: _cache[43] || (_cache[43] = ($event) => _ctx.$emit("play-audio", $event)),
                      onEditWord: _cache[44] || (_cache[44] = ($event) => _ctx.$emit("edit-word", $event)),
                      onDeleteWord: _cache[45] || (_cache[45] = ($event) => _ctx.$emit("delete-word", $event)),
                      onToggleFavorite: _cache[46] || (_cache[46] = ($event) => _ctx.$emit("toggle-favorite", $event)),
                      onViewDetails: _cache[47] || (_cache[47] = ($event) => _ctx.$emit("view-details", $event)),
                      onMoveVocabulary: handleMoveVocabulary
                    }, null, 8, ["word", "move-mode"]);
                  }), 128))
                ]))
              ])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
});

const DateGroupAccordion = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-6105a4b6"]]);

const DateGroupAccordion$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: DateGroupAccordion
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$a = { class: "space-y-4" };
const _hoisted_2$8 = { class: "relative" };
const _hoisted_3$7 = {
  for: "image-upload",
  class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"
};
const _hoisted_4$7 = { class: "flex items-center space-x-4 mb-4" };
const _hoisted_5$6 = { key: 0 };
const _hoisted_6$5 = { class: "flex flex-col items-center space-y-2" };
const _hoisted_7$5 = { class: "text-sm text-gray-600 dark:text-gray-400" };
const _hoisted_8$5 = { class: "font-medium text-blue-600 dark:text-blue-400" };
const _hoisted_9$5 = { class: "text-xs text-gray-500 dark:text-gray-500" };
const _hoisted_10$5 = {
  key: 1,
  class: "space-y-3"
};
const _hoisted_11$5 = ["placeholder"];
const _hoisted_12$5 = ["disabled"];
const _hoisted_13$5 = {
  key: 0,
  class: "animate-spin -ml-1 mr-2 h-4 w-4 text-white",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _hoisted_14$5 = {
  key: 2,
  class: "space-y-3"
};
const _hoisted_15$4 = { class: "p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 text-sm" };
const _hoisted_16$4 = { class: "flex items-center space-x-2 mt-2" };
const _hoisted_17$4 = ["disabled"];
const _hoisted_18$4 = {
  key: 0,
  class: "animate-spin -ml-1 mr-2 h-4 w-4 text-white",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _hoisted_19$4 = {
  key: 1,
  class: "w-4 h-4",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_20$4 = {
  key: 0,
  class: "text-green-600 dark:text-green-400 text-sm"
};
const _hoisted_21$4 = { class: "p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-700 dark:text-gray-300 text-sm" };
const _hoisted_22$4 = { key: 0 };
const _hoisted_23$4 = {
  key: 1,
  class: "space-y-2"
};
const _hoisted_24$4 = { class: "flex items-center space-x-2" };
const _hoisted_25$4 = ["disabled"];
const _hoisted_26$3 = {
  key: 0,
  class: "animate-spin -ml-1 mr-2 h-4 w-4 text-white",
  fill: "none",
  viewBox: "0 0 24 24"
};
const _hoisted_27$3 = {
  key: 1,
  class: "w-4 h-4",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
};
const _hoisted_28$3 = {
  key: 0,
  class: "text-green-600 dark:text-green-400 text-sm"
};
const _hoisted_29$3 = {
  key: 1,
  class: "text-yellow-600 dark:text-yellow-400 text-sm"
};
const _hoisted_30$3 = {
  key: 3,
  class: "relative"
};
const _hoisted_31$3 = { class: "border-2 border-gray-200 dark:border-gray-600 rounded-lg overflow-hidden" };
const _hoisted_32$2 = ["src", "alt"];
const _hoisted_33$2 = { class: "flex items-center justify-between mt-2" };
const _hoisted_34$2 = { class: "flex items-center space-x-2" };
const _hoisted_35$2 = { class: "text-xs text-gray-500 dark:text-gray-400" };
const _hoisted_36$2 = { key: 0 };
const _hoisted_37$1 = { key: 1 };
const _hoisted_38$1 = {
  key: 4,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50"
};
const _hoisted_39$1 = { class: "bg-white dark:bg-[#0a0a0a] rounded-lg p-6 w-full max-w-md mx-4" };
const _hoisted_40$1 = { class: "text-lg font-medium text-gray-900 dark:text-white mb-4" };
const _hoisted_41 = { class: "space-y-4" };
const _hoisted_42 = ["placeholder"];
const _hoisted_43 = { class: "flex justify-end space-x-3" };
const _hoisted_44 = ["disabled"];
const _hoisted_45 = {
  key: 5,
  class: "absolute inset-0 bg-white dark:bg-[#0a0a0a] bg-opacity-75 flex items-center justify-center rounded-lg"
};
const _hoisted_46 = { class: "flex items-center space-x-2 text-blue-600 dark:text-blue-400" };
const _hoisted_47 = { class: "text-sm" };
const _hoisted_48 = {
  key: 0,
  class: "p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md"
};
const _hoisted_49 = { class: "flex items-center space-x-2" };
const _hoisted_50 = { class: "text-sm text-red-700 dark:text-red-300" };
const MAX_FILE_SIZE = 5 * 1024 * 1024;
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "ImageUpload",
  props: {
    modelValue: { default: null }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const fileInput = ref();
    const imagePreview = ref(null);
    const imageInfo = ref(null);
    const isDragOver = ref(false);
    const isProcessing = ref(false);
    const errorMessage = ref(null);
    const inputMethod = ref("upload");
    const imageUrl = ref("");
    const newImageUrl = ref("");
    const showUrlEdit = ref(false);
    const copyStatus = ref(null);
    const SUPPORTED_TYPES = ["image/jpeg", "image/png", "image/gif", "image/webp"];
    const handlePaste = async (e) => {
      try {
        const target = e.target;
        if (target && target.closest('input, textarea, [contenteditable="true"]')) return;
        if (inputMethod.value !== "copy") return;
        const cd = e.clipboardData;
        if (!cd) return;
        const items = cd.items;
        let imageFile = null;
        if (items && items.length) {
          for (let i = 0; i < items.length; i++) {
            const it = items[i];
            if (it.kind === "file" && it.type.startsWith("image/")) {
              const f = it.getAsFile();
              if (f) {
                imageFile = f;
                break;
              }
            }
          }
        }
        if (!imageFile && cd.files && cd.files.length > 0 && cd.files[0].type.startsWith("image/")) {
          imageFile = cd.files[0];
        }
        if (imageFile) {
          e.preventDefault();
          await processFile(imageFile);
          copyStatus.value = { type: "success", message: t("vocabulary.image.paste.success", "Image pasted!") || "Image pasted!" };
          return;
        }
        const text = cd.getData("text/plain");
        if (text && isValidImageUrl(text)) {
          e.preventDefault();
          imageUrl.value = text;
          await handleUrlInput();
          copyStatus.value = { type: "success", message: t("vocabulary.image.paste.success", "Image pasted!") || "Image pasted!" };
          return;
        }
        errorMessage.value = t("vocabulary.image.paste.noImage", "Clipboard does not contain an image");
      } catch (err) {
        console.error("Paste handler error:", err);
        errorMessage.value = t("vocabulary.image.paste.error", "Failed to paste from clipboard");
      }
    };
    onMounted(() => {
      if (inputMethod.value === "copy") {
        window.addEventListener("paste", handlePaste);
      }
    });
    watch(inputMethod, (val, oldVal) => {
      if (oldVal === "copy") {
        window.removeEventListener("paste", handlePaste);
      }
      if (val === "copy") {
        window.addEventListener("paste", handlePaste);
      }
    });
    onUnmounted(() => {
      window.removeEventListener("paste", handlePaste);
    });
    const triggerFileInput = () => {
      fileInput.value?.click();
    };
    const handleFileChange = (event) => {
      const target = event.target;
      const file = target.files?.[0];
      if (file) {
        processFile(file);
      }
    };
    const handleDragOver = (event) => {
      event.preventDefault();
      isDragOver.value = true;
    };
    const handleDragLeave = (event) => {
      event.preventDefault();
      isDragOver.value = false;
    };
    const handleDrop = (event) => {
      event.preventDefault();
      isDragOver.value = false;
      const files = event.dataTransfer?.files;
      if (files && files.length > 0) {
        processFile(files[0]);
      }
    };
    const processFile = async (file) => {
      errorMessage.value = null;
      if (!SUPPORTED_TYPES.includes(file.type)) {
        errorMessage.value = t("vocabulary.image.errors.unsupportedFormat", "Unsupported file format");
        return;
      }
      if (file.size > MAX_FILE_SIZE) {
        errorMessage.value = t("vocabulary.image.errors.fileTooLarge", "File size too large");
        return;
      }
      isProcessing.value = true;
      try {
        const base64 = await fileToBase64(file);
        imagePreview.value = base64;
        imageInfo.value = {
          name: file.name,
          size: file.size
        };
        emit("update:modelValue", base64);
      } catch (error) {
        console.error("Error processing image:", error);
        errorMessage.value = t("vocabulary.image.errors.processingFailed", "Failed to process image");
      } finally {
        isProcessing.value = false;
      }
    };
    const fileToBase64 = (file) => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => {
          const result = reader.result;
          resolve(result);
        };
        reader.onerror = (error) => reject(error);
      });
    };
    const dataUrlToBlob = async (dataUrl) => {
      const res = await fetch(dataUrl);
      return await res.blob();
    };
    const fetchImageBlob = async (url) => {
      const res = await fetch(url, { mode: "cors" });
      if (!res.ok) throw new Error("Fetch failed");
      return await res.blob();
    };
    const urlToBlobViaCanvas = (url) => {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          try {
            const canvas = document.createElement("canvas");
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            const ctx = canvas.getContext("2d");
            if (!ctx) return reject(new Error("Canvas not supported"));
            ctx.drawImage(img, 0, 0);
            canvas.toBlob((blob) => {
              if (blob) resolve(blob);
              else reject(new Error("Canvas toBlob failed"));
            });
          } catch (e) {
            reject(e);
          }
        };
        img.onerror = () => reject(new Error("Image load error"));
        img.src = url;
      });
    };
    const copyImageToClipboard = async () => {
      copyStatus.value = null;
      errorMessage.value = null;
      if (!imagePreview.value) {
        errorMessage.value = t("vocabulary.image.copy.noImage", "No image to copy. Please upload or load an image first.");
        return;
      }
      const hasClipboard = !!(navigator.clipboard && navigator.clipboard.write && window.ClipboardItem);
      if (!hasClipboard) {
        errorMessage.value = t("vocabulary.image.copy.unsupported", "Clipboard API for images is not supported in this browser.");
        return;
      }
      isProcessing.value = true;
      try {
        let blob;
        if (imagePreview.value.startsWith("data:")) {
          blob = await dataUrlToBlob(imagePreview.value);
        } else if (imagePreview.value.startsWith("http")) {
          try {
            blob = await fetchImageBlob(imagePreview.value);
          } catch {
            blob = await urlToBlobViaCanvas(imagePreview.value);
          }
        } else {
          throw new Error("Unknown image source");
        }
        const mime = blob.type || "image/png";
        const item = new window.ClipboardItem({ [mime]: blob });
        await navigator.clipboard.write([item]);
        copyStatus.value = { type: "success", message: t("vocabulary.image.copy.success", "Image copied to clipboard!") || "Image copied to clipboard!" };
      } catch (err) {
        console.error("Copy image failed:", err);
        errorMessage.value = t("vocabulary.image.copy.failed", "Failed to copy image. Some images cannot be copied due to browser or CORS restrictions.");
        if (imagePreview.value?.startsWith("http")) {
          copyStatus.value = { type: "warning", message: t("vocabulary.image.copy.corsNote", "Tip: Images from some websites block copying. Try uploading the image instead.") || "Tip: Images from some websites block copying. Try uploading the image instead." };
        }
      } finally {
        isProcessing.value = false;
        setTimeout(() => {
          copyStatus.value = null;
        }, 2500);
      }
    };
    const pasteImageFromClipboard = async () => {
      copyStatus.value = null;
      errorMessage.value = null;
      if (inputMethod.value !== "copy") return;
      const canRead = !!(navigator.clipboard && navigator.clipboard.read);
      isProcessing.value = true;
      try {
        if (canRead) {
          const items = await navigator.clipboard.read();
          for (const item of items) {
            const types = item.types || [];
            const imageType = types.find((t2) => t2.startsWith("image/"));
            if (imageType) {
              const blob = await item.getType(imageType);
              const ext = (blob.type.split("/")[1] || "png").replace(/[^a-z0-9]/gi, "");
              const file = new File([blob], `clipboard-${Date.now()}.${ext}`, { type: blob.type });
              await processFile(file);
              copyStatus.value = { type: "success", message: t("vocabulary.image.paste.success", "Image pasted!") || "Image pasted!" };
              return;
            }
          }
        }
        if (navigator.clipboard && navigator.clipboard.readText) {
          const text = await navigator.clipboard.readText();
          const url = text?.trim();
          if (url && isValidImageUrl(url)) {
            imageUrl.value = url;
            await handleUrlInput();
            copyStatus.value = { type: "success", message: t("vocabulary.image.paste.success", "Image pasted!") || "Image pasted!" };
            return;
          }
        }
        errorMessage.value = t("vocabulary.image.paste.noImage", "Clipboard does not contain an image");
      } catch (err) {
        console.error("pasteImageFromClipboard failed:", err);
        errorMessage.value = t("vocabulary.image.paste.error", "Failed to paste from clipboard");
      } finally {
        isProcessing.value = false;
        if (copyStatus.value?.type === "success") {
          setTimeout(() => {
            copyStatus.value = null;
          }, 2500);
        }
      }
    };
    const removeImage = () => {
      imagePreview.value = null;
      imageInfo.value = null;
      errorMessage.value = null;
      imageUrl.value = "";
      if (fileInput.value) {
        fileInput.value.value = "";
      }
      emit("update:modelValue", null);
    };
    const handleUrlInput = async () => {
      if (!imageUrl.value.trim()) {
        errorMessage.value = t("vocabulary.image.errors.emptyUrl");
        return;
      }
      if (!isValidImageUrl(imageUrl.value)) {
        errorMessage.value = t("vocabulary.image.errors.invalidUrl");
        return;
      }
      isProcessing.value = true;
      errorMessage.value = null;
      try {
        await validateImageUrl(imageUrl.value);
        imagePreview.value = imageUrl.value;
        imageInfo.value = null;
        emit("update:modelValue", imageUrl.value);
      } catch (error) {
        console.error("Error loading image from URL:", error);
        if (isValidImageUrl(imageUrl.value)) {
          imagePreview.value = imageUrl.value;
          imageInfo.value = null;
          emit("update:modelValue", imageUrl.value);
          errorMessage.value = t("vocabulary.image.errors.corsWarning");
        } else {
          errorMessage.value = t("vocabulary.image.errors.urlLoadFailed");
        }
      } finally {
        isProcessing.value = false;
      }
    };
    const handleUrlChange = async () => {
      if (!newImageUrl.value.trim()) {
        errorMessage.value = t("vocabulary.image.errors.emptyUrl");
        return;
      }
      if (!isValidImageUrl(newImageUrl.value)) {
        errorMessage.value = t("vocabulary.image.errors.invalidUrl");
        return;
      }
      isProcessing.value = true;
      errorMessage.value = null;
      try {
        await validateImageUrl(newImageUrl.value);
        imagePreview.value = newImageUrl.value;
        imageUrl.value = newImageUrl.value;
        emit("update:modelValue", newImageUrl.value);
        showUrlEdit.value = false;
        newImageUrl.value = "";
      } catch (error) {
        console.error("Error loading image from URL:", error);
        if (isValidImageUrl(newImageUrl.value)) {
          imagePreview.value = newImageUrl.value;
          imageUrl.value = newImageUrl.value;
          emit("update:modelValue", newImageUrl.value);
          showUrlEdit.value = false;
          newImageUrl.value = "";
          errorMessage.value = t("vocabulary.image.errors.corsWarning");
        } else {
          errorMessage.value = t("vocabulary.image.errors.urlLoadFailed");
        }
      } finally {
        isProcessing.value = false;
      }
    };
    const isValidImageUrl = (url) => {
      try {
        const urlObj = new URL(url);
        if (!["http:", "https:"].includes(urlObj.protocol)) {
          return false;
        }
        const imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".webp", ".bmp", ".svg"];
        const pathname = urlObj.pathname.toLowerCase();
        const hasImageExtension = imageExtensions.some((ext) => pathname.includes(ext));
        const commonImageHosts = [
          "imgur.com",
          "cloudinary.com",
          "unsplash.com",
          "pexels.com",
          "pixabay.com",
          "googleusercontent.com",
          "gstatic.com",
          "ggpht.com",
          // Google services
          "fbcdn.net",
          "cdninstagram.com",
          // Facebook/Instagram
          "twimg.com",
          // Twitter
          "amazonaws.com",
          "s3.",
          // AWS S3
          "githubusercontent.com",
          // GitHub
          "wikimedia.org",
          "wikipedia.org",
          // Wikipedia
          "flickr.com",
          "staticflickr.com",
          // Flickr
          "dropbox.com",
          "dropboxusercontent.com",
          // Dropbox
          "drive.google.com",
          // Google Drive
          "ibb.co",
          "postimg.cc",
          // Image hosting services
          "cdn.",
          "images.",
          "img.",
          "static.",
          "media."
          // Common CDN patterns
        ];
        const hasImageHost = commonImageHosts.some((host) => url.includes(host));
        const imageQueryParams = ["jpg", "jpeg", "png", "gif", "webp", "image", "img", "photo"];
        const queryString = urlObj.search.toLowerCase();
        const hasImageQuery = imageQueryParams.some((param) => queryString.includes(param));
        return hasImageExtension || hasImageHost || hasImageQuery;
      } catch {
        return false;
      }
    };
    const validateImageUrl = (url) => {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const timeout = setTimeout(() => {
          reject(new Error("Image load timeout"));
        }, 8e3);
        img.onload = () => {
          clearTimeout(timeout);
          resolve();
        };
        img.onerror = () => {
          clearTimeout(timeout);
          if (isValidImageUrl(url)) {
            console.warn("Image validation failed but URL looks valid, accepting anyway");
            resolve();
          } else {
            reject(new Error("Failed to load image"));
          }
        };
        img.src = url;
      });
    };
    const formatFileSize = (bytes) => {
      if (bytes === 0) return "0 Bytes";
      const k = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    };
    watch(
      () => props.modelValue,
      (newValue) => {
        if (newValue !== imagePreview.value) {
          imagePreview.value = newValue;
          if (!newValue) {
            imageInfo.value = null;
            errorMessage.value = null;
            imageUrl.value = "";
          } else {
            if (newValue.startsWith("http")) {
              inputMethod.value = "url";
              imageUrl.value = newValue;
            } else {
              inputMethod.value = "upload";
            }
          }
        }
      },
      { immediate: true }
    );
    watch(inputMethod, (newMethod) => {
      errorMessage.value = null;
    });
    onMounted(() => {
      if (props.modelValue) {
        imagePreview.value = props.modelValue;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$a, [
        createBaseVNode("div", _hoisted_2$8, [
          createBaseVNode("label", _hoisted_3$7, toDisplayString$1(unref(t)("vocabulary.image.title", "Image")), 1),
          createBaseVNode("div", _hoisted_4$7, [
            createBaseVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => inputMethod.value = "upload"),
              type: "button",
              class: normalizeClass([
                "px-4 py-2 text-sm font-medium rounded-lg transition-colors",
                inputMethod.value === "upload" ? "bg-blue-600 text-white" : "bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600"
              ])
            }, toDisplayString$1(unref(t)("vocabulary.image.upload", "Upload")), 3),
            createBaseVNode("button", {
              onClick: _cache[1] || (_cache[1] = ($event) => inputMethod.value = "url"),
              type: "button",
              class: normalizeClass([
                "px-4 py-2 text-sm font-medium rounded-lg transition-colors",
                inputMethod.value === "url" ? "bg-blue-600 text-white" : "bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600"
              ])
            }, toDisplayString$1(unref(t)("vocabulary.image.url", "URL")), 3),
            createBaseVNode("button", {
              onClick: _cache[2] || (_cache[2] = ($event) => inputMethod.value = "copy"),
              type: "button",
              class: normalizeClass([
                "px-4 py-2 text-sm font-medium rounded-lg transition-colors",
                inputMethod.value === "copy" ? "bg-blue-600 text-white" : "bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600"
              ])
            }, toDisplayString$1(unref(t)("vocabulary.image.copyTab", "Copy")), 3)
          ]),
          createBaseVNode("input", {
            id: "image-upload",
            ref_key: "fileInput",
            ref: fileInput,
            type: "file",
            accept: "image/*",
            onChange: handleFileChange,
            class: "hidden"
          }, null, 544),
          inputMethod.value === "upload" && !imagePreview.value ? (openBlock(), createElementBlock("div", _hoisted_5$6, [
            createBaseVNode("div", {
              onClick: triggerFileInput,
              onDragover: withModifiers(handleDragOver, ["prevent"]),
              onDragleave: withModifiers(handleDragLeave, ["prevent"]),
              onDrop: withModifiers(handleDrop, ["prevent"]),
              class: normalizeClass([
                "border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors",
                isDragOver.value ? "border-blue-500 bg-blue-50 dark:bg-blue-900/20" : "border-gray-300 dark:border-gray-600 hover:border-blue-400 dark:hover:border-blue-500",
                "bg-gray-50 dark:bg-[#0a0a0a]/50 hover:bg-gray-100 dark:hover:bg-gray-700/50"
              ])
            }, [
              createBaseVNode("div", _hoisted_6$5, [
                _cache[7] || (_cache[7] = createBaseVNode("svg", {
                  class: "w-8 h-8 text-gray-400 dark:text-gray-500",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                  })
                ], -1)),
                createBaseVNode("div", _hoisted_7$5, [
                  createBaseVNode("span", _hoisted_8$5, toDisplayString$1(unref(t)("vocabulary.image.clickToUpload", "Click to upload")), 1),
                  createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.image.orDragDrop", " or drag and drop")), 1)
                ]),
                createBaseVNode("p", _hoisted_9$5, toDisplayString$1(unref(t)("vocabulary.image.supportedFormats", "PNG, JPG, GIF up to 10MB")), 1)
              ])
            ], 34)
          ])) : createCommentVNode("", true),
          inputMethod.value === "url" && !imagePreview.value ? (openBlock(), createElementBlock("div", _hoisted_10$5, [
            createBaseVNode("div", null, [
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => imageUrl.value = $event),
                onBlur: handleUrlInput,
                onKeyup: withKeys(handleUrlInput, ["enter"]),
                type: "url",
                placeholder: unref(t)("vocabulary.image.urlPlaceholder", "Enter image URL"),
                class: "w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
              }, null, 40, _hoisted_11$5), [
                [vModelText, imageUrl.value]
              ])
            ]),
            createBaseVNode("button", {
              onClick: handleUrlInput,
              disabled: !imageUrl.value.trim() || isProcessing.value,
              type: "button",
              class: "w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white rounded-lg transition-colors flex items-center justify-center space-x-2"
            }, [
              isProcessing.value ? (openBlock(), createElementBlock("svg", _hoisted_13$5, _cache[8] || (_cache[8] = [
                createBaseVNode("circle", {
                  class: "opacity-25",
                  cx: "12",
                  cy: "12",
                  r: "10",
                  stroke: "currentColor",
                  "stroke-width": "4"
                }, null, -1),
                createBaseVNode("path", {
                  class: "opacity-75",
                  fill: "currentColor",
                  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                }, null, -1)
              ]))) : createCommentVNode("", true),
              createBaseVNode("span", null, toDisplayString$1(isProcessing.value ? unref(t)("vocabulary.image.loading", "Loading...") : unref(t)("vocabulary.image.loadFromUrl", "Load from URL")), 1)
            ], 8, _hoisted_12$5)
          ])) : createCommentVNode("", true),
          inputMethod.value === "copy" ? (openBlock(), createElementBlock("div", _hoisted_14$5, [
            createBaseVNode("div", _hoisted_15$4, [
              createBaseVNode("p", null, toDisplayString$1(unref(t)("vocabulary.image.paste.hint", "Press Ctrl+V to paste an image, or click the button:")), 1),
              createBaseVNode("div", _hoisted_16$4, [
                createBaseVNode("button", {
                  onClick: pasteImageFromClipboard,
                  type: "button",
                  class: "px-4 py-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white rounded-lg transition-colors flex items-center space-x-2",
                  disabled: isProcessing.value
                }, [
                  isProcessing.value ? (openBlock(), createElementBlock("svg", _hoisted_18$4, _cache[9] || (_cache[9] = [
                    createBaseVNode("circle", {
                      class: "opacity-25",
                      cx: "12",
                      cy: "12",
                      r: "10",
                      stroke: "currentColor",
                      "stroke-width": "4"
                    }, null, -1),
                    createBaseVNode("path", {
                      class: "opacity-75",
                      fill: "currentColor",
                      d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    }, null, -1)
                  ]))) : (openBlock(), createElementBlock("svg", _hoisted_19$4, _cache[10] || (_cache[10] = [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M8 16h8M8 12h8m8-5H8l-2-2H4a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7z"
                    }, null, -1)
                  ]))),
                  createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.image.paste.button", "Paste image from clipboard")), 1)
                ], 8, _hoisted_17$4),
                copyStatus.value && copyStatus.value.type === "success" ? (openBlock(), createElementBlock("span", _hoisted_20$4, toDisplayString$1(copyStatus.value.message), 1)) : createCommentVNode("", true)
              ])
            ]),
            createBaseVNode("div", _hoisted_21$4, [
              !imagePreview.value ? (openBlock(), createElementBlock("p", _hoisted_22$4, toDisplayString$1(unref(t)("vocabulary.image.copy.noImage", "No image to copy. Please upload or load an image first.")), 1)) : (openBlock(), createElementBlock("div", _hoisted_23$4, [
                createBaseVNode("p", null, toDisplayString$1(unref(t)("vocabulary.image.copy.description", "Copy the current image to your clipboard as an actual image, not just the URL.")), 1),
                createBaseVNode("div", _hoisted_24$4, [
                  createBaseVNode("button", {
                    onClick: copyImageToClipboard,
                    type: "button",
                    class: "px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white rounded-lg transition-colors flex items-center space-x-2",
                    disabled: isProcessing.value
                  }, [
                    isProcessing.value ? (openBlock(), createElementBlock("svg", _hoisted_26$3, _cache[11] || (_cache[11] = [
                      createBaseVNode("circle", {
                        class: "opacity-25",
                        cx: "12",
                        cy: "12",
                        r: "10",
                        stroke: "currentColor",
                        "stroke-width": "4"
                      }, null, -1),
                      createBaseVNode("path", {
                        class: "opacity-75",
                        fill: "currentColor",
                        d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                      }, null, -1)
                    ]))) : (openBlock(), createElementBlock("svg", _hoisted_27$3, _cache[12] || (_cache[12] = [
                      createBaseVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M8 16h8M8 12h8m-9 8h10a2 2 0 002-2V6a2 2 0 00-2-2H9l-3 3v11a2 2 0 002 2z"
                      }, null, -1)
                    ]))),
                    createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.image.copy.button", "Copy image to clipboard")), 1)
                  ], 8, _hoisted_25$4),
                  copyStatus.value && copyStatus.value.type === "success" ? (openBlock(), createElementBlock("span", _hoisted_28$3, toDisplayString$1(copyStatus.value.message), 1)) : copyStatus.value && copyStatus.value.type === "warning" ? (openBlock(), createElementBlock("span", _hoisted_29$3, toDisplayString$1(copyStatus.value.message), 1)) : createCommentVNode("", true)
                ])
              ]))
            ])
          ])) : createCommentVNode("", true),
          imagePreview.value ? (openBlock(), createElementBlock("div", _hoisted_30$3, [
            createBaseVNode("div", _hoisted_31$3, [
              createBaseVNode("img", {
                src: imagePreview.value,
                alt: unref(t)("vocabulary.image.preview", "Image preview"),
                class: "w-full h-48 object-cover"
              }, null, 8, _hoisted_32$2)
            ]),
            createBaseVNode("div", _hoisted_33$2, [
              createBaseVNode("div", _hoisted_34$2, [
                inputMethod.value === "upload" ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  onClick: triggerFileInput,
                  type: "button",
                  class: "px-3 py-1 text-sm bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors flex items-center space-x-1"
                }, [
                  _cache[13] || (_cache[13] = createBaseVNode("svg", {
                    class: "w-4 h-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
                    })
                  ], -1)),
                  createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.image.changeFile", "Change Image")), 1)
                ])) : createCommentVNode("", true),
                inputMethod.value === "url" ? (openBlock(), createElementBlock("button", {
                  key: 1,
                  onClick: _cache[4] || (_cache[4] = ($event) => showUrlEdit.value = true),
                  type: "button",
                  class: "px-3 py-1 text-sm bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors flex items-center space-x-1"
                }, [
                  _cache[14] || (_cache[14] = createBaseVNode("svg", {
                    class: "w-4 h-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"
                    })
                  ], -1)),
                  createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.image.changeUrl", "Change URL")), 1)
                ])) : createCommentVNode("", true),
                createBaseVNode("button", {
                  onClick: removeImage,
                  type: "button",
                  class: "px-3 py-1 text-sm bg-red-600 hover:bg-red-700 text-white rounded-md transition-colors flex items-center space-x-1"
                }, [
                  _cache[15] || (_cache[15] = createBaseVNode("svg", {
                    class: "w-4 h-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    createBaseVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                    })
                  ], -1)),
                  createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.image.remove", "Remove")), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_35$2, [
                imageInfo.value && inputMethod.value === "upload" ? (openBlock(), createElementBlock("div", _hoisted_36$2, toDisplayString$1(formatFileSize(imageInfo.value.size)), 1)) : createCommentVNode("", true),
                inputMethod.value === "url" ? (openBlock(), createElementBlock("div", _hoisted_37$1, toDisplayString$1(unref(t)("vocabulary.image.fromUrl", "From URL")), 1)) : createCommentVNode("", true)
              ])
            ])
          ])) : createCommentVNode("", true),
          showUrlEdit.value ? (openBlock(), createElementBlock("div", _hoisted_38$1, [
            createBaseVNode("div", _hoisted_39$1, [
              createBaseVNode("h3", _hoisted_40$1, toDisplayString$1(unref(t)("vocabulary.image.changeUrl", "Change URL")), 1),
              createBaseVNode("div", _hoisted_41, [
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => newImageUrl.value = $event),
                  onKeyup: withKeys(handleUrlChange, ["enter"]),
                  type: "url",
                  placeholder: unref(t)("vocabulary.image.urlPlaceholder", "Enter image URL"),
                  class: "w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400"
                }, null, 40, _hoisted_42), [
                  [vModelText, newImageUrl.value]
                ]),
                createBaseVNode("div", _hoisted_43, [
                  createBaseVNode("button", {
                    onClick: _cache[6] || (_cache[6] = ($event) => showUrlEdit.value = false),
                    type: "button",
                    class: "px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors"
                  }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                  createBaseVNode("button", {
                    onClick: handleUrlChange,
                    disabled: !newImageUrl.value.trim() || isProcessing.value,
                    type: "button",
                    class: "px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white rounded-lg transition-colors"
                  }, toDisplayString$1(isProcessing.value ? unref(t)("vocabulary.image.loading", "Loading...") : unref(t)("common.update", "Update")), 9, _hoisted_44)
                ])
              ])
            ])
          ])) : createCommentVNode("", true),
          isProcessing.value ? (openBlock(), createElementBlock("div", _hoisted_45, [
            createBaseVNode("div", _hoisted_46, [
              _cache[16] || (_cache[16] = createBaseVNode("svg", {
                class: "animate-spin w-5 h-5",
                fill: "none",
                viewBox: "0 0 24 24"
              }, [
                createBaseVNode("circle", {
                  class: "opacity-25",
                  cx: "12",
                  cy: "12",
                  r: "10",
                  stroke: "currentColor",
                  "stroke-width": "4"
                }),
                createBaseVNode("path", {
                  class: "opacity-75",
                  fill: "currentColor",
                  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                })
              ], -1)),
              createBaseVNode("span", _hoisted_47, toDisplayString$1(unref(t)("vocabulary.image.processing", "Processing...")), 1)
            ])
          ])) : createCommentVNode("", true)
        ]),
        errorMessage.value ? (openBlock(), createElementBlock("div", _hoisted_48, [
          createBaseVNode("div", _hoisted_49, [
            _cache[17] || (_cache[17] = createBaseVNode("svg", {
              class: "w-5 h-5 text-red-500",
              fill: "none",
              stroke: "currentColor",
              viewBox: "0 0 24 24"
            }, [
              createBaseVNode("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              })
            ], -1)),
            createBaseVNode("span", _hoisted_50, toDisplayString$1(errorMessage.value), 1)
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const ImageUpload = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$a
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$9 = {
  key: 0,
  class: "fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-[60000] backdrop-blur-sm"
};
const _hoisted_2$7 = { class: "w-full max-w-2xl max-h-[90vh]" };
const _hoisted_3$6 = { class: "px-5 py-4 border-b border-gray-200 dark:border-dark-bg-mute bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-dark-bg-soft dark:to-dark-bg-soft flex items-center justify-between" };
const _hoisted_4$6 = { class: "text-lg font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_5$5 = ["title", "aria-label"];
const _hoisted_6$4 = { class: "px-5 py-4 border-b border-gray-200 dark:border-dark-bg-mute bg-white dark:bg-dark-bg-soft sticky top-0 z-10" };
const _hoisted_7$4 = { class: "relative mb-4" };
const _hoisted_8$4 = ["placeholder"];
const _hoisted_9$4 = { class: "p-3 rounded-lg border border-gray-200 dark:border-dark-bg-mute bg-white dark:bg-dark-bg-mute mb-4" };
const _hoisted_10$4 = { class: "text-2xl md:text-3xl font-mono text-gray-900 dark:text-white break-words min-h-[2.5rem]" };
const _hoisted_11$4 = { class: "flex flex-wrap gap-2" };
const _hoisted_12$4 = ["title", "aria-label"];
const _hoisted_13$4 = ["title", "aria-label"];
const _hoisted_14$4 = ["title", "aria-label"];
const _hoisted_15$3 = ["title", "aria-label"];
const _hoisted_16$3 = { class: "px-5 py-4 space-y-4 overflow-y-auto flex-1 min-h-0" };
const _hoisted_17$3 = { class: "space-y-4" };
const _hoisted_18$3 = { class: "text-sm font-medium text-gray-600 dark:text-white/70 mb-2 flex items-center" };
const _hoisted_19$3 = { class: "grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 gap-2" };
const _hoisted_20$3 = ["onClick", "title"];
const _hoisted_21$3 = { class: "font-bold text-base" };
const _hoisted_22$3 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_23$3 = ["onClick", "title"];
const _hoisted_24$3 = { class: "text-sm font-medium text-gray-600 dark:text-white/70 mb-2 flex items-center" };
const _hoisted_25$3 = { class: "grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-2" };
const _hoisted_26$2 = ["onClick", "title"];
const _hoisted_27$2 = { class: "font-bold text-base" };
const _hoisted_28$2 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_29$2 = ["onClick", "title"];
const _hoisted_30$2 = { class: "pb-4" };
const _hoisted_31$2 = { class: "text-sm font-medium text-gray-600 dark:text-white/70 mb-2 flex items-center" };
const _hoisted_32$1 = { class: "grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 gap-2" };
const _hoisted_33$1 = ["onClick", "title"];
const _hoisted_34$1 = { class: "font-bold text-base" };
const _hoisted_35$1 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_36$1 = ["onClick", "title"];
const _hoisted_37 = { class: "px-5 py-4 border-t border-gray-200 dark:border-dark-bg-mute bg-white dark:bg-[#0a0a0a] sticky bottom-0 z-10" };
const _hoisted_38 = { class: "text-sm font-medium text-gray-600 dark:text-white/70 mb-2 flex items-center" };
const _hoisted_39 = { class: "flex flex-wrap gap-2" };
const _hoisted_40 = ["onClick"];
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "IpaPickerModal",
  props: {
    modelValue: { type: Boolean },
    initialValue: { default: "" }
  },
  emits: ["update:modelValue", "apply"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const { playAudio } = useVoiceStore();
    const ipaDraft = ref("");
    const searchQuery = ref("");
    const searchInputRef = ref(null);
    const IPA_VOWELS = [
      // Monophthongs (short/long where applicable)
      { symbol: "i", letter: "ee", description: 'Long "ee" sound as in "see"' },
      { symbol: "i", letter: "ee", description: 'Long "ee" sound as in "see"' },
      { symbol: "", letter: "i", description: 'Short "i" sound as in "sit"' },
      { symbol: "e", letter: "e", description: '"e" sound as in "bed"' },
      { symbol: "", letter: "e", description: 'Open "e" sound as in "bet"' },
      { symbol: "", letter: "a", description: '"a" sound as in "cat"' },
      { symbol: "u", letter: "oo", description: 'Long "oo" sound as in "boot"' },
      { symbol: "u", letter: "oo", description: 'Long "oo" sound as in "boot"' },
      { symbol: "", letter: "u", description: 'Short "u" sound as in "put"' },
      { symbol: "o", letter: "o", description: '"o" sound as in "go"' },
      { symbol: "", letter: "aw", description: '"aw" sound as in "saw"' },
      { symbol: "", letter: "o", description: 'Short "o" sound as in "lot"' },
      { symbol: "", letter: "a", description: '"a" sound as in "father"' },
      { symbol: "", letter: "u", description: '"u" sound as in "cup"' },
      { symbol: "", letter: "ur", description: '"ur" sound as in "bird"' },
      { symbol: "", letter: "ur", description: 'Long "ur" sound as in "bird"' },
      { symbol: "", letter: "er", description: 'R-colored "er" sound' },
      { symbol: "", letter: "er", description: 'Unstressed "er" sound' },
      { symbol: "", letter: "uh", description: 'Schwa - unstressed "uh" sound' }
    ];
    const IPA_DIPHTHONGS = [
      // Common diphthongs (BrE/AmE variants included)
      { symbol: "e", letter: "ay", description: '"ay" sound as in "day"' },
      { symbol: "a", letter: "i", description: '"i" sound as in "my"' },
      { symbol: "", letter: "oy", description: '"oy" sound as in "boy"' },
      { symbol: "a", letter: "ow", description: '"ow" sound as in "now"' },
      { symbol: "", letter: "o", description: '"o" sound as in "go" (British)' },
      { symbol: "o", letter: "o", description: '"o" sound as in "go" (American)' },
      { symbol: "", letter: "ear", description: '"ear" sound as in "near"' },
      { symbol: "e", letter: "air", description: '"air" sound as in "hair"' },
      { symbol: "", letter: "oor", description: '"oor" sound as in "poor"' }
    ];
    const IPA_CONSONANTS = [
      // Plosives
      { symbol: "p", letter: "p", description: '"p" sound as in "pat"' },
      { symbol: "b", letter: "b", description: '"b" sound as in "bat"' },
      { symbol: "t", letter: "t", description: '"t" sound as in "tap"' },
      { symbol: "d", letter: "d", description: '"d" sound as in "day"' },
      { symbol: "k", letter: "k", description: '"k" sound as in "cat"' },
      { symbol: "g", letter: "g", description: '"g" sound as in "go"' },
      // Fricatives
      { symbol: "f", letter: "f", description: '"f" sound as in "fat"' },
      { symbol: "v", letter: "v", description: '"v" sound as in "vat"' },
      { symbol: "", letter: "th", description: 'Voiceless "th" as in "think"' },
      { symbol: "", letter: "th", description: 'Voiced "th" as in "this"' },
      { symbol: "s", letter: "s", description: '"s" sound as in "sat"' },
      { symbol: "z", letter: "z", description: '"z" sound as in "zoo"' },
      { symbol: "", letter: "sh", description: '"sh" sound as in "she"' },
      { symbol: "", letter: "zh", description: '"zh" sound as in "measure"' },
      { symbol: "h", letter: "h", description: '"h" sound as in "hat"' },
      // Affricates
      { symbol: "t", letter: "ch", description: '"ch" sound as in "chair"' },
      { symbol: "d", letter: "j", description: '"j" sound as in "jar"' },
      // Nasals
      { symbol: "m", letter: "m", description: '"m" sound as in "mat"' },
      { symbol: "n", letter: "n", description: '"n" sound as in "net"' },
      { symbol: "", letter: "ng", description: '"ng" sound as in "sing"' },
      // Liquids
      { symbol: "l", letter: "l", description: '"l" sound as in "let"' },
      { symbol: "", letter: "l", description: 'Dark "l" sound' },
      { symbol: "r", letter: "r", description: 'Rolled "r" sound' },
      { symbol: "", letter: "r", description: 'English "r" sound as in "red"' },
      // Glides
      { symbol: "w", letter: "w", description: '"w" sound as in "wet"' },
      { symbol: "j", letter: "y", description: '"y" sound as in "yes"' },
      // Other
      { symbol: "", letter: "'", description: "Glottal stop" },
      { symbol: "", letter: "t", description: 'Flap "t" as in "butter" (American)' },
      { symbol: "", letter: "wh", description: 'Voiceless "wh" as in "what"' }
    ];
    const IPA_MARKS = ["", "", "", ".", " "];
    const filteredVowels = computed(() => {
      if (!searchQuery.value) return IPA_VOWELS;
      const query = searchQuery.value.toLowerCase();
      return IPA_VOWELS.filter(
        (vowel) => vowel.symbol.includes(query) || vowel.letter.toLowerCase().includes(query) || vowel.description.toLowerCase().includes(query)
      );
    });
    const filteredDiphthongs = computed(() => {
      if (!searchQuery.value) return IPA_DIPHTHONGS;
      const query = searchQuery.value.toLowerCase();
      return IPA_DIPHTHONGS.filter(
        (diphthong) => diphthong.symbol.includes(query) || diphthong.letter.toLowerCase().includes(query) || diphthong.description.toLowerCase().includes(query)
      );
    });
    const filteredConsonants = computed(() => {
      if (!searchQuery.value) return IPA_CONSONANTS;
      const query = searchQuery.value.toLowerCase();
      return IPA_CONSONANTS.filter(
        (consonant) => consonant.symbol.includes(query) || consonant.letter.toLowerCase().includes(query) || consonant.description.toLowerCase().includes(query)
      );
    });
    watch(() => props.modelValue, async (isOpen) => {
      if (isOpen) {
        ipaDraft.value = props.initialValue || "";
        searchQuery.value = "";
        await nextTick();
        setTimeout(() => {
          focusSearchInput();
        }, 100);
      }
    });
    const closeModal = () => {
      emit("update:modelValue", false);
    };
    const focusSearchInput = () => {
      if (searchInputRef.value) {
        searchInputRef.value.focus();
      }
    };
    const refocusSearchInput = () => {
      setTimeout(() => {
        focusSearchInput();
      }, 50);
    };
    const appendIpa = (symbol) => {
      ipaDraft.value += symbol;
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const clearIpa = () => {
      ipaDraft.value = "";
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const backspaceIpa = () => {
      if (!ipaDraft.value) return;
      ipaDraft.value = ipaDraft.value.slice(0, -1);
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const wrapWithSlashes = () => {
      const trimmed = ipaDraft.value.trim();
      if (!trimmed) {
        ipaDraft.value = "/ /";
      } else {
        const alreadyWrapped = trimmed.startsWith("/") && trimmed.endsWith("/");
        ipaDraft.value = alreadyWrapped ? trimmed : `/${trimmed.replace(/^\/+|\/+$/g, "")}/`;
      }
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const applyIpa = () => {
      emit("apply", ipaDraft.value.trim());
      closeModal();
    };
    const speakIPA = async (symbol, event) => {
      event.stopPropagation();
      const ipaToWord = {
        // Vowels
        "i": "see",
        "i": "see",
        "": "sit",
        "e": "bed",
        "": "bet",
        "": "cat",
        "u": "boot",
        "u": "boot",
        "": "put",
        "o": "go",
        "": "saw",
        "": "lot",
        "": "father",
        "": "cup",
        "": "bird",
        "": "bird",
        "": "bird",
        "": "butter",
        "": "about",
        // Diphthongs
        "e": "day",
        "a": "my",
        "": "boy",
        "a": "now",
        "": "go",
        "o": "go",
        "": "near",
        "e": "hair",
        "": "poor",
        // Consonants
        "p": "pat",
        "b": "bat",
        "t": "tap",
        "d": "day",
        "k": "cat",
        "g": "go",
        "f": "fat",
        "v": "vat",
        "": "think",
        "": "this",
        "s": "sat",
        "z": "zoo",
        "": "she",
        "": "measure",
        "h": "hat",
        "t": "chair",
        "d": "jar",
        "m": "mat",
        "n": "net",
        "": "sing",
        "l": "let",
        "": "call",
        "r": "red",
        "": "red",
        "w": "wet",
        "j": "yes",
        "": "button",
        "": "butter",
        "": "what"
      };
      const textToSpeak = ipaToWord[symbol] || symbol;
      try {
        await playAudio(textToSpeak);
      } catch (error) {
        console.warn("Failed to play IPA pronunciation:", error);
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$9, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$7, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-dark-bg-soft shadow-2xl rounded-xl border border-gray-200 dark:border-dark-bg-mute overflow-hidden transform flex flex-col max-h-[90vh]",
                      onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$6, [
                        createBaseVNode("h3", _hoisted_4$6, [
                          _cache[2] || (_cache[2] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                          createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.pronunciation.ipaPickerTitle", "IPA Picker")), 1)
                        ]),
                        createBaseVNode("button", {
                          type: "button",
                          onClick: closeModal,
                          class: "text-gray-400 hover:text-gray-600 dark:hover:text-white transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-dark-bg-mute",
                          title: unref(t)("common.close", "Close"),
                          "aria-label": unref(t)("common.close", "Close")
                        }, _cache[3] || (_cache[3] = [
                          createBaseVNode("svg", {
                            class: "w-6 h-6",
                            fill: "none",
                            stroke: "currentColor",
                            viewBox: "0 0 24 24"
                          }, [
                            createBaseVNode("path", {
                              "stroke-linecap": "round",
                              "stroke-linejoin": "round",
                              "stroke-width": "2",
                              d: "M6 18L18 6M6 6l12 12"
                            })
                          ], -1)
                        ]), 8, _hoisted_5$5)
                      ]),
                      createBaseVNode("div", _hoisted_6$4, [
                        createBaseVNode("div", _hoisted_7$4, [
                          _cache[4] || (_cache[4] = createBaseVNode("div", { class: "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none" }, [
                            createBaseVNode("svg", {
                              class: "h-5 w-5 text-gray-400",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                              })
                            ])
                          ], -1)),
                          withDirectives(createBaseVNode("input", {
                            ref_key: "searchInputRef",
                            ref: searchInputRef,
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
                            type: "text",
                            class: "block w-full pl-10 pr-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-dark-bg-mute dark:text-white",
                            placeholder: unref(t)("common.search", "Search IPA symbols..."),
                            onBlur: refocusSearchInput
                          }, null, 40, _hoisted_8$4), [
                            [vModelText, searchQuery.value]
                          ])
                        ]),
                        createBaseVNode("div", _hoisted_9$4, [
                          createBaseVNode("div", _hoisted_10$4, toDisplayString$1(ipaDraft.value || unref(t)("vocabulary.pronunciation.previewPlaceholder", "Start building IPA...")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_11$4, [
                          createBaseVNode("button", {
                            type: "button",
                            onClick: wrapWithSlashes,
                            class: "px-3 py-1.5 rounded-lg border border-gray-300 dark:border-dark-bg-mute text-gray-800 dark:text-white dark:bg-dark-bg-mute hover:bg-gray-100 dark:hover:bg-dark-bg-soft",
                            title: unref(t)("vocabulary.pronunciation.wrap", "Wrap with slashes"),
                            "aria-label": unref(t)("vocabulary.pronunciation.wrap", "Wrap with slashes")
                          }, " /.../ ", 8, _hoisted_12$4),
                          createBaseVNode("button", {
                            type: "button",
                            onClick: backspaceIpa,
                            class: "px-3 py-1.5 rounded-lg border border-gray-300 dark:border-dark-bg-mute text-gray-800 dark:text-white dark:bg-dark-bg-mute hover:bg-gray-100 dark:hover:bg-dark-bg-soft",
                            title: unref(t)("common.backspace", "Backspace"),
                            "aria-label": unref(t)("common.backspace", "Backspace")
                          }, toDisplayString$1(unref(t)("common.backspace", "Backspace")), 9, _hoisted_13$4),
                          createBaseVNode("button", {
                            type: "button",
                            onClick: clearIpa,
                            class: "px-3 py-1.5 rounded-lg border border-gray-300 dark:border-dark-bg-mute text-gray-800 dark:text-white dark:bg-dark-bg-mute hover:bg-gray-100 dark:hover:bg-dark-bg-soft",
                            title: unref(t)("common.clear", "Clear"),
                            "aria-label": unref(t)("common.clear", "Clear")
                          }, toDisplayString$1(unref(t)("common.clear", "Clear")), 9, _hoisted_14$4),
                          createBaseVNode("button", {
                            type: "button",
                            onClick: applyIpa,
                            class: "ml-auto px-3 py-1.5 rounded-lg bg-green-600 hover:bg-green-700 text-white",
                            title: unref(t)("common.apply", "Apply"),
                            "aria-label": unref(t)("common.apply", "Apply")
                          }, toDisplayString$1(unref(t)("common.apply", "Apply")), 9, _hoisted_15$3)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_16$3, [
                        createBaseVNode("div", _hoisted_17$3, [
                          createBaseVNode("div", null, [
                            createBaseVNode("div", _hoisted_18$3, [
                              _cache[5] || (_cache[5] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.pronunciation.vowels", "Vowels")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_19$3, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredVowels.value, (vowel) => {
                                return openBlock(), createElementBlock("div", {
                                  key: "v-" + vowel.symbol,
                                  class: "relative"
                                }, [
                                  createBaseVNode("button", {
                                    type: "button",
                                    onClick: ($event) => appendIpa(vowel.symbol),
                                    class: "w-full p-2 bg-blue-100 hover:bg-blue-200 dark:bg-blue-900 dark:hover:bg-blue-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm border border-gray-300 dark:border-dark-bg-mute",
                                    title: vowel.description
                                  }, [
                                    createBaseVNode("span", _hoisted_21$3, toDisplayString$1(vowel.symbol), 1),
                                    createBaseVNode("span", _hoisted_22$3, toDisplayString$1(vowel.letter), 1)
                                  ], 8, _hoisted_20$3),
                                  createBaseVNode("button", {
                                    type: "button",
                                    onClick: ($event) => speakIPA(vowel.symbol, $event),
                                    class: "absolute -top-1 -right-1 w-5 h-5 bg-green-500 hover:bg-green-600 text-white rounded-full flex items-center justify-center text-xs transition-all duration-200 hover:scale-110 shadow-md",
                                    title: `Pronounce ${vowel.symbol}`
                                  }, _cache[6] || (_cache[6] = [
                                    createBaseVNode("svg", {
                                      class: "w-3 h-3",
                                      fill: "currentColor",
                                      viewBox: "0 0 20 20"
                                    }, [
                                      createBaseVNode("path", {
                                        "fill-rule": "evenodd",
                                        d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.824L4.8 13.6H2a1 1 0 01-1-1V7.4a1 1 0 011-1h2.8l3.583-3.224a1 1 0 01.617-.176zM12 5a1 1 0 011.414 0L15 6.586l1.586-1.586a1 1 0 111.414 1.414L16.414 8 18 9.586a1 1 0 01-1.414 1.414L15 9.414 13.414 11A1 1 0 0112 9.586L13.586 8 12 6.414A1 1 0 0112 5z",
                                        "clip-rule": "evenodd"
                                      })
                                    ], -1)
                                  ]), 8, _hoisted_23$3)
                                ]);
                              }), 128))
                            ])
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("div", _hoisted_24$3, [
                              _cache[7] || (_cache[7] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.pronunciation.diphthongs", "Diphthongs")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_25$3, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredDiphthongs.value, (diphthong) => {
                                return openBlock(), createElementBlock("div", {
                                  key: "d-" + diphthong.symbol,
                                  class: "relative"
                                }, [
                                  createBaseVNode("button", {
                                    type: "button",
                                    onClick: ($event) => appendIpa(diphthong.symbol),
                                    class: "w-full p-2 bg-green-100 hover:bg-green-200 dark:bg-green-900 dark:hover:bg-green-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm border border-gray-300 dark:border-dark-bg-mute",
                                    title: diphthong.description
                                  }, [
                                    createBaseVNode("span", _hoisted_27$2, toDisplayString$1(diphthong.symbol), 1),
                                    createBaseVNode("span", _hoisted_28$2, toDisplayString$1(diphthong.letter), 1)
                                  ], 8, _hoisted_26$2),
                                  createBaseVNode("button", {
                                    type: "button",
                                    onClick: ($event) => speakIPA(diphthong.symbol, $event),
                                    class: "absolute -top-1 -right-1 w-5 h-5 bg-green-500 hover:bg-green-600 text-white rounded-full flex items-center justify-center text-xs transition-all duration-200 hover:scale-110 shadow-md",
                                    title: `Pronounce ${diphthong.symbol}`
                                  }, _cache[8] || (_cache[8] = [
                                    createBaseVNode("svg", {
                                      class: "w-3 h-3",
                                      fill: "currentColor",
                                      viewBox: "0 0 20 20"
                                    }, [
                                      createBaseVNode("path", {
                                        "fill-rule": "evenodd",
                                        d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.824L4.8 13.6H2a1 1 0 01-1-1V7.4a1 1 0 011-1h2.8l3.583-3.224a1 1 0 01.617-.176zM12 5a1 1 0 011.414 0L15 6.586l1.586-1.586a1 1 0 111.414 1.414L16.414 8 18 9.586a1 1 0 01-1.414 1.414L15 9.414 13.414 11A1 1 0 0112 9.586L13.586 8 12 6.414A1 1 0 0112 5z",
                                        "clip-rule": "evenodd"
                                      })
                                    ], -1)
                                  ]), 8, _hoisted_29$2)
                                ]);
                              }), 128))
                            ])
                          ]),
                          createBaseVNode("div", _hoisted_30$2, [
                            createBaseVNode("div", _hoisted_31$2, [
                              _cache[9] || (_cache[9] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.pronunciation.consonants", "Consonants")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_32$1, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredConsonants.value, (consonant) => {
                                return openBlock(), createElementBlock("div", {
                                  key: "c-" + consonant.symbol,
                                  class: "relative"
                                }, [
                                  createBaseVNode("button", {
                                    type: "button",
                                    onClick: ($event) => appendIpa(consonant.symbol),
                                    class: "w-full p-2 bg-purple-100 hover:bg-purple-200 dark:bg-purple-900 dark:hover:bg-purple-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm border border-gray-300 dark:border-dark-bg-mute",
                                    title: consonant.description
                                  }, [
                                    createBaseVNode("span", _hoisted_34$1, toDisplayString$1(consonant.symbol), 1),
                                    createBaseVNode("span", _hoisted_35$1, toDisplayString$1(consonant.letter), 1)
                                  ], 8, _hoisted_33$1),
                                  createBaseVNode("button", {
                                    type: "button",
                                    onClick: ($event) => speakIPA(consonant.symbol, $event),
                                    class: "absolute -top-1 -right-1 w-5 h-5 bg-green-500 hover:bg-green-600 text-white rounded-full flex items-center justify-center text-xs transition-all duration-200 hover:scale-110 shadow-md",
                                    title: `Pronounce ${consonant.symbol}`
                                  }, _cache[10] || (_cache[10] = [
                                    createBaseVNode("svg", {
                                      class: "w-3 h-3",
                                      fill: "currentColor",
                                      viewBox: "0 0 20 20"
                                    }, [
                                      createBaseVNode("path", {
                                        "fill-rule": "evenodd",
                                        d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.824L4.8 13.6H2a1 1 0 01-1-1V7.4a1 1 0 011-1h2.8l3.583-3.224a1 1 0 01.617-.176zM12 5a1 1 0 011.414 0L15 6.586l1.586-1.586a1 1 0 111.414 1.414L16.414 8 18 9.586a1 1 0 01-1.414 1.414L15 9.414 13.414 11A1 1 0 0112 9.586L13.586 8 12 6.414A1 1 0 0112 5z",
                                        "clip-rule": "evenodd"
                                      })
                                    ], -1)
                                  ]), 8, _hoisted_36$1)
                                ]);
                              }), 128))
                            ])
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_37, [
                        createBaseVNode("div", _hoisted_38, [
                          _cache[11] || (_cache[11] = createBaseVNode("span", { class: "w-1 h-4 bg-orange-500 rounded mr-2" }, null, -1)),
                          createTextVNode(" " + toDisplayString$1(unref(t)("vocabulary.pronunciation.marks", "Marks")), 1)
                        ]),
                        createBaseVNode("div", _hoisted_39, [
                          (openBlock(), createElementBlock(Fragment, null, renderList(IPA_MARKS, (mark) => {
                            return createBaseVNode("button", {
                              key: "m-" + mark,
                              type: "button",
                              onClick: ($event) => appendIpa(mark),
                              class: "px-3 py-2 bg-orange-100 hover:bg-orange-200 dark:bg-orange-900 dark:hover:bg-orange-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 border border-gray-300 dark:border-dark-bg-mute font-mono"
                            }, toDisplayString$1(mark === " " ? unref(t)("common.space", "Space") : mark), 9, _hoisted_40);
                          }), 64))
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const IpaPickerModal = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$9
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$8 = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$6 = { class: "w-full max-h-[90vh] flex flex-col max-w-full sm:max-w-lg md:max-w-2xl lg:max-w-4xl" };
const _hoisted_3$5 = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$5 = { class: "flex items-center justify-between" };
const _hoisted_5$4 = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$3 = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 bg-white dark:bg-[#0a0a0a] sticky top-0 z-10" };
const _hoisted_7$3 = { class: "relative mb-4" };
const _hoisted_8$3 = ["placeholder"];
const _hoisted_9$3 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_10$3 = { class: "relative" };
const _hoisted_11$3 = ["placeholder"];
const _hoisted_12$3 = ["title"];
const _hoisted_13$3 = ["title"];
const _hoisted_14$3 = { class: "px-6 py-4 flex-1 overflow-y-auto min-h-0" };
const _hoisted_15$2 = { class: "space-y-6" };
const _hoisted_16$2 = { class: "text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center" };
const _hoisted_17$2 = { class: "grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-2" };
const _hoisted_18$2 = ["onClick", "title"];
const _hoisted_19$2 = { class: "font-bold text-base" };
const _hoisted_20$2 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_21$2 = { class: "text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center" };
const _hoisted_22$2 = { class: "grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-2" };
const _hoisted_23$2 = ["onClick", "title"];
const _hoisted_24$2 = { class: "font-bold text-base" };
const _hoisted_25$2 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_26$1 = { class: "text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center" };
const _hoisted_27$1 = { class: "grid grid-cols-6 sm:grid-cols-8 md:grid-cols-10 gap-2" };
const _hoisted_28$1 = ["onClick"];
const _hoisted_29$1 = { class: "px-6 py-4 border-t border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gray-50 dark:bg-[#0a0a0a]" };
const _hoisted_30$1 = { class: "flex justify-between items-center space-x-3" };
const _hoisted_31$1 = { class: "flex space-x-3" };
const HANGEUL_START = 44032;
const JUNGSUNG_COUNT = 21;
const JONGSUNG_COUNT = 28;
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "KoreanInputHelper",
  props: {
    modelValue: { type: Boolean },
    initialValue: { default: "" }
  },
  emits: ["update:modelValue", "input-confirmed"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const currentInput = ref("");
    const searchQuery = ref("");
    const searchInputRef = ref(null);
    const koreanConsonants = [
      { char: "", romanization: "g/k", description: "g as in go, k as in sky" },
      { char: "", romanization: "n", description: "n as in no" },
      { char: "", romanization: "d/t", description: "d as in do, t as in stop" },
      { char: "", romanization: "r/l", description: "r as in run, l as in love" },
      { char: "", romanization: "m", description: "m as in moon" },
      { char: "", romanization: "b/p", description: "b as in boy, p as in spy" },
      { char: "", romanization: "s", description: "s as in see" },
      { char: "", romanization: "ng", description: "ng as in sing (silent at start)" },
      { char: "", romanization: "j", description: "j as in jump" },
      { char: "", romanization: "ch", description: "ch as in chair" },
      { char: "", romanization: "k", description: "k as in key" },
      { char: "", romanization: "t", description: "t as in top" },
      { char: "", romanization: "p", description: "p as in pie" },
      { char: "", romanization: "h", description: "h as in home" },
      { char: "", romanization: "kk", description: "stronger k sound" },
      { char: "", romanization: "tt", description: "stronger t sound" },
      { char: "", romanization: "pp", description: "stronger p sound" },
      { char: "", romanization: "ss", description: "stronger s sound" },
      { char: "", romanization: "jj", description: "stronger j sound" }
    ];
    const koreanVowels = [
      { char: "", romanization: "a", description: "a as in father" },
      { char: "", romanization: "ya", description: "ya as in yard" },
      { char: "", romanization: "eo", description: "uh as in up" },
      { char: "", romanization: "yeo", description: "yuh sound" },
      { char: "", romanization: "o", description: "o as in go" },
      { char: "", romanization: "yo", description: "yo as in yo-yo" },
      { char: "", romanization: "u", description: "u as in moon" },
      { char: "", romanization: "yu", description: "yu as in you" },
      { char: "", romanization: "eu", description: "uh sound (lips spread)" },
      { char: "", romanization: "i", description: "i as in machine" },
      { char: "", romanization: "ae", description: "ae as in cat" },
      { char: "", romanization: "yae", description: "yae sound" },
      { char: "", romanization: "e", description: "e as in red" },
      { char: "", romanization: "ye", description: "ye as in yes" },
      { char: "", romanization: "wa", description: "wa as in water" },
      { char: "", romanization: "wae", description: "wae sound" },
      { char: "", romanization: "oe", description: "we sound" },
      { char: "", romanization: "wo", description: "wo sound" },
      { char: "", romanization: "we", description: "we sound" },
      { char: "", romanization: "wi", description: "wi as in we" },
      { char: "", romanization: "ui", description: "ui sound" }
    ];
    const commonKoreanSyllables = [
      // Basic syllables ( )
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // Common particles & endings (  )
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // Frequent syllables (  )
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // Common verbs/adjectives (/)
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // Common nouns ()
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // Common adverbs ()
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // Numbers ()
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ];
    const chosungMap = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
    const jungsungMap = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
    const jongsungMap = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
    const isConsonant = (char) => {
      const code = char.charCodeAt(0);
      return code >= 12593 && code <= 12622;
    };
    const isVowel = (char) => {
      const code = char.charCodeAt(0);
      return code >= 12623 && code <= 12643;
    };
    const isSyllable = (char) => {
      const code = char.charCodeAt(0);
      return code >= 44032 && code <= 55203;
    };
    const decomposeSyllable = (syllable) => {
      const code = syllable.charCodeAt(0) - HANGEUL_START;
      const chosung = Math.floor(code / (JUNGSUNG_COUNT * JONGSUNG_COUNT));
      const jungsung = Math.floor(code % (JUNGSUNG_COUNT * JONGSUNG_COUNT) / JONGSUNG_COUNT);
      const jongsung = code % JONGSUNG_COUNT;
      return {
        chosung: chosungMap[chosung],
        jungsung: jungsungMap[jungsung],
        jongsung: jongsung > 0 ? jongsungMap[jongsung] : ""
      };
    };
    const composeSyllable = (chosung, jungsung, jongsung = "") => {
      const chosungIndex = chosungMap.indexOf(chosung);
      const jungsungIndex = jungsungMap.indexOf(jungsung);
      const jongsungIndex = jongsung ? jongsungMap.indexOf(jongsung) : 0;
      if (chosungIndex === -1 || jungsungIndex === -1 || jongsungIndex === -1) {
        return null;
      }
      const syllableCode = HANGEUL_START + chosungIndex * JUNGSUNG_COUNT * JONGSUNG_COUNT + jungsungIndex * JONGSUNG_COUNT + jongsungIndex;
      return String.fromCharCode(syllableCode);
    };
    const focusSearchInput = () => {
      if (searchInputRef.value) {
        searchInputRef.value.focus();
      }
    };
    const refocusSearchInput = () => {
      setTimeout(() => {
        focusSearchInput();
      }, 50);
    };
    const addCharacter = (character) => {
      const currentText = currentInput.value;
      if (isConsonant(character) || isVowel(character)) {
        const lastChar = currentText.slice(-1);
        if (lastChar && isSyllable(lastChar)) {
          const decomposed = decomposeSyllable(lastChar);
          if (isVowel(character) && decomposed.chosung && !decomposed.jungsung) {
            const newSyllable = composeSyllable(decomposed.chosung, character);
            if (newSyllable) {
              currentInput.value = currentText.slice(0, -1) + newSyllable;
              return;
            }
          } else if (isConsonant(character) && decomposed.chosung && decomposed.jungsung && !decomposed.jongsung) {
            const newSyllable = composeSyllable(decomposed.chosung, decomposed.jungsung, character);
            if (newSyllable) {
              currentInput.value = currentText.slice(0, -1) + newSyllable;
              return;
            }
          }
        } else if (lastChar && isConsonant(lastChar) && isVowel(character)) {
          const newSyllable = composeSyllable(lastChar, character);
          if (newSyllable) {
            currentInput.value = currentText.slice(0, -1) + newSyllable;
            return;
          }
        }
      }
      currentInput.value += character;
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const clearInput = () => {
      currentInput.value = "";
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const backspaceInput = () => {
      if (currentInput.value.length === 0) return;
      const currentText = currentInput.value;
      const lastChar = currentText.slice(-1);
      if (isSyllable(lastChar)) {
        const decomposed = decomposeSyllable(lastChar);
        if (decomposed.jongsung) {
          const newSyllable = composeSyllable(decomposed.chosung, decomposed.jungsung);
          if (newSyllable) {
            currentInput.value = currentText.slice(0, -1) + newSyllable;
            return;
          }
        } else if (decomposed.jungsung) {
          currentInput.value = currentText.slice(0, -1) + decomposed.chosung;
          return;
        }
      }
      currentInput.value = currentText.slice(0, -1);
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const closeDialog = () => {
      emit("update:modelValue", false);
    };
    const confirmInput = () => {
      emit("input-confirmed", currentInput.value);
      emit("update:modelValue", false);
    };
    const filteredConsonants = computed(() => {
      if (!searchQuery.value) return koreanConsonants;
      const query = searchQuery.value.toLowerCase();
      return koreanConsonants.filter(
        (consonant) => consonant.char.includes(query) || consonant.romanization.toLowerCase().includes(query) || consonant.description.toLowerCase().includes(query)
      );
    });
    const filteredVowels = computed(() => {
      if (!searchQuery.value) return koreanVowels;
      const query = searchQuery.value.toLowerCase();
      return koreanVowels.filter(
        (vowel) => vowel.char.includes(query) || vowel.romanization.toLowerCase().includes(query) || vowel.description.toLowerCase().includes(query)
      );
    });
    const filteredCommonSyllables = computed(() => {
      if (!searchQuery.value) return commonKoreanSyllables;
      const query = searchQuery.value.toLowerCase();
      return commonKoreanSyllables.filter((syllable) => syllable.includes(query));
    });
    watch(() => props.initialValue, (newValue) => {
      if (newValue !== void 0) {
        currentInput.value = newValue;
      }
    });
    watch(() => props.modelValue, async (isOpen) => {
      if (isOpen) {
        currentInput.value = props.initialValue || "";
        searchQuery.value = "";
        await nextTick();
        setTimeout(() => {
          focusSearchInput();
        }, 100);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$8, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$6, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 flex flex-col h-full overflow-hidden transform",
                      onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$5, [
                        createBaseVNode("div", _hoisted_4$5, [
                          createBaseVNode("h2", _hoisted_5$4, [
                            _cache[3] || (_cache[3] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("korean.inputHelper.title", "Korean Input Helper")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: closeDialog,
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[4] || (_cache[4] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_6$3, [
                        createBaseVNode("div", _hoisted_7$3, [
                          _cache[5] || (_cache[5] = createBaseVNode("div", { class: "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none" }, [
                            createBaseVNode("svg", {
                              class: "h-5 w-5 text-gray-400",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                              })
                            ])
                          ], -1)),
                          withDirectives(createBaseVNode("input", {
                            ref_key: "searchInputRef",
                            ref: searchInputRef,
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
                            type: "text",
                            class: "block w-full pl-10 pr-3 py-2 border border-gray-300 dark:border-dark-bg-mute rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-dark-bg-mute dark:text-white",
                            placeholder: unref(t)("common.search", "Search Korean characters..."),
                            onBlur: refocusSearchInput
                          }, null, 40, _hoisted_8$3), [
                            [vModelText, searchQuery.value]
                          ])
                        ]),
                        createBaseVNode("div", null, [
                          createBaseVNode("label", _hoisted_9$3, [
                            _cache[6] || (_cache[6] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                            createTextVNode(" " + toDisplayString$1(unref(t)("korean.inputHelper.preview", "Preview")), 1)
                          ]),
                          createBaseVNode("div", _hoisted_10$3, [
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => currentInput.value = $event),
                              type: "text",
                              class: "w-full px-3 py-2 pr-20 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-300 text-lg",
                              placeholder: unref(t)("korean.inputHelper.placeholder", "Type or click characters below..."),
                              readonly: ""
                            }, null, 8, _hoisted_11$3), [
                              [vModelText, currentInput.value]
                            ]),
                            currentInput.value ? (openBlock(), createElementBlock("button", {
                              key: 0,
                              onClick: backspaceInput,
                              class: "absolute right-12 top-1/2 -translate-y-1/2 w-8 h-6 bg-orange-500 hover:bg-orange-600 text-white rounded flex items-center justify-center text-xs font-bold transition-all duration-300 hover:scale-110",
                              title: unref(t)("common.backspace", "Backspace")
                            }, "  ", 8, _hoisted_12$3)) : createCommentVNode("", true),
                            currentInput.value ? (openBlock(), createElementBlock("button", {
                              key: 1,
                              onClick: clearInput,
                              class: "absolute right-2 top-1/2 -translate-y-1/2 w-6 h-6 bg-red-500 hover:bg-red-600 text-white rounded-full flex items-center justify-center text-xs font-bold transition-all duration-300 hover:scale-110",
                              title: unref(t)("common.clear", "Clear")
                            }, "  ", 8, _hoisted_13$3)) : createCommentVNode("", true)
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_14$3, [
                        createBaseVNode("div", _hoisted_15$2, [
                          createBaseVNode("div", null, [
                            createBaseVNode("h3", _hoisted_16$2, [
                              _cache[7] || (_cache[7] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("korean.inputHelper.consonants", "Consonants ()")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_17$2, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredConsonants.value, (consonant) => {
                                return openBlock(), createElementBlock("button", {
                                  key: consonant.char,
                                  onClick: ($event) => addCharacter(consonant.char),
                                  class: "p-2 bg-blue-100 hover:bg-blue-200 dark:bg-blue-900 dark:hover:bg-blue-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm",
                                  title: consonant.description
                                }, [
                                  createBaseVNode("span", _hoisted_19$2, toDisplayString$1(consonant.char), 1),
                                  createBaseVNode("span", _hoisted_20$2, toDisplayString$1(consonant.romanization), 1)
                                ], 8, _hoisted_18$2);
                              }), 128))
                            ])
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("h3", _hoisted_21$2, [
                              _cache[8] || (_cache[8] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("korean.inputHelper.vowels", "Vowels ()")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_22$2, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredVowels.value, (vowel) => {
                                return openBlock(), createElementBlock("button", {
                                  key: vowel.char,
                                  onClick: ($event) => addCharacter(vowel.char),
                                  class: "p-2 bg-green-100 hover:bg-green-200 dark:bg-green-900 dark:hover:bg-green-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm",
                                  title: vowel.description
                                }, [
                                  createBaseVNode("span", _hoisted_24$2, toDisplayString$1(vowel.char), 1),
                                  createBaseVNode("span", _hoisted_25$2, toDisplayString$1(vowel.romanization), 1)
                                ], 8, _hoisted_23$2);
                              }), 128))
                            ])
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("h3", _hoisted_26$1, [
                              _cache[9] || (_cache[9] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("korean.inputHelper.commonSyllables", "Common Syllables")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_27$1, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredCommonSyllables.value, (syllable) => {
                                return openBlock(), createElementBlock("button", {
                                  key: syllable,
                                  onClick: ($event) => addCharacter(syllable),
                                  class: "px-3 py-2 bg-purple-100 hover:bg-purple-200 dark:bg-purple-900 dark:hover:bg-purple-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 font-medium"
                                }, toDisplayString$1(syllable), 9, _hoisted_28$1);
                              }), 128))
                            ])
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_29$1, [
                        createBaseVNode("div", _hoisted_30$1, [
                          createBaseVNode("button", {
                            type: "button",
                            onClick: clearInput,
                            class: "px-4 py-2 text-sm font-medium text-gray-600 dark:text-gray-400 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition-all duration-300 hover:scale-105"
                          }, toDisplayString$1(unref(t)("common.clear", "Clear")), 1),
                          createBaseVNode("div", _hoisted_31$1, [
                            createBaseVNode("button", {
                              type: "button",
                              onClick: closeDialog,
                              class: "px-4 py-2 text-sm font-medium text-gray-600 dark:text-gray-400 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition-all duration-300 hover:scale-105"
                            }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                            createBaseVNode("button", {
                              type: "button",
                              onClick: confirmInput,
                              class: "px-4 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-lg transition-all duration-300 hover:scale-105 shadow-lg"
                            }, toDisplayString$1(unref(t)("common.confirm", "Confirm")), 1)
                          ])
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const KoreanInputHelper = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$8
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$7 = {
  key: 0,
  class: "fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50 backdrop-blur-sm"
};
const _hoisted_2$5 = { class: "w-full max-h-[90vh] flex flex-col max-w-full sm:max-w-lg md:max-w-2xl lg:max-w-4xl" };
const _hoisted_3$4 = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gradient-to-r from-green-50 to-emerald-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a]" };
const _hoisted_4$4 = { class: "flex items-center justify-between" };
const _hoisted_5$3 = { class: "text-lg sm:text-xl md:text-2xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$2 = { class: "px-6 py-4 border-b border-gray-200 dark:border-gray-700 bg-white dark:bg-[#0a0a0a] sticky top-0 z-10" };
const _hoisted_7$2 = { class: "relative mb-4" };
const _hoisted_8$2 = ["placeholder"];
const _hoisted_9$2 = { class: "block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center" };
const _hoisted_10$2 = { class: "relative" };
const _hoisted_11$2 = ["placeholder"];
const _hoisted_12$2 = ["title"];
const _hoisted_13$2 = ["title"];
const _hoisted_14$2 = { class: "px-6 py-4 flex-1 overflow-y-auto min-h-0" };
const _hoisted_15$1 = { class: "space-y-6" };
const _hoisted_16$1 = { class: "text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center" };
const _hoisted_17$1 = { class: "grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-2" };
const _hoisted_18$1 = ["onClick", "title"];
const _hoisted_19$1 = { class: "font-bold" };
const _hoisted_20$1 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_21$1 = { class: "text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center" };
const _hoisted_22$1 = { class: "grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-2" };
const _hoisted_23$1 = ["onClick", "title"];
const _hoisted_24$1 = { class: "font-bold" };
const _hoisted_25$1 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_26 = { class: "text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center" };
const _hoisted_27 = { class: "grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 gap-2" };
const _hoisted_28 = ["onClick", "title"];
const _hoisted_29 = { class: "font-bold" };
const _hoisted_30 = { class: "text-xs text-gray-600 dark:text-gray-400" };
const _hoisted_31 = { class: "text-md font-semibold text-gray-800 dark:text-gray-200 mb-3 flex items-center" };
const _hoisted_32 = { class: "flex flex-wrap gap-2" };
const _hoisted_33 = ["onClick", "title"];
const _hoisted_34 = { class: "px-6 py-4 border-t border-gray-200 dark:border-gray-700 flex-shrink-0 bg-gray-50 dark:bg-[#0a0a0a]" };
const _hoisted_35 = { class: "flex justify-between items-center space-x-3" };
const _hoisted_36 = { class: "flex space-x-3" };
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "KoreanPronunciationHelper",
  props: {
    modelValue: { type: Boolean },
    initialValue: { default: "" }
  },
  emits: ["update:modelValue", "pronunciation-confirmed"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const currentPronunciation = ref("");
    const searchQuery = ref("");
    const searchInputRef = ref(null);
    const koreanConsonantSounds = [
      { korean: "", romanization: "g/k", description: "g as in go, k as in sky" },
      { korean: "", romanization: "n", description: "n as in no" },
      { korean: "", romanization: "d/t", description: "d as in do, t as in stop" },
      { korean: "", romanization: "r/l", description: "r as in run, l as in love" },
      { korean: "", romanization: "m", description: "m as in moon" },
      { korean: "", romanization: "b/p", description: "b as in boy, p as in spy" },
      { korean: "", romanization: "s", description: "s as in see" },
      { korean: "", romanization: "ng", description: "ng as in sing" },
      { korean: "", romanization: "j", description: "j as in jump" },
      { korean: "", romanization: "ch", description: "ch as in chair" },
      { korean: "", romanization: "k", description: "k as in key" },
      { korean: "", romanization: "t", description: "t as in top" },
      { korean: "", romanization: "p", description: "p as in pie" },
      { korean: "", romanization: "h", description: "h as in home" },
      { korean: "", romanization: "kk", description: "stronger k sound" },
      { korean: "", romanization: "tt", description: "stronger t sound" },
      { korean: "", romanization: "pp", description: "stronger p sound" },
      { korean: "", romanization: "ss", description: "stronger s sound" },
      { korean: "", romanization: "jj", description: "stronger j sound" }
    ];
    const koreanVowelSounds = [
      { korean: "", romanization: "a", description: "a as in father" },
      { korean: "", romanization: "ya", description: "ya as in yard" },
      { korean: "", romanization: "eo", description: "uh as in up" },
      { korean: "", romanization: "yeo", description: "yuh sound" },
      { korean: "", romanization: "o", description: "o as in go" },
      { korean: "", romanization: "yo", description: "yo as in yo-yo" },
      { korean: "", romanization: "u", description: "u as in moon" },
      { korean: "", romanization: "yu", description: "yu as in you" },
      { korean: "", romanization: "eu", description: "uh sound (lips spread)" },
      { korean: "", romanization: "i", description: "i as in machine" },
      { korean: "", romanization: "ae", description: "ae as in cat" },
      { korean: "", romanization: "yae", description: "yae sound" },
      { korean: "", romanization: "e", description: "e as in red" },
      { korean: "", romanization: "ye", description: "ye as in yes" },
      { korean: "", romanization: "wa", description: "wa as in water" },
      { korean: "", romanization: "wae", description: "wae sound" },
      { korean: "", romanization: "oe", description: "we sound" },
      { korean: "", romanization: "wo", description: "wo sound" },
      { korean: "", romanization: "we", description: "we sound" },
      { korean: "", romanization: "wi", description: "wi as in we" },
      { korean: "", romanization: "ui", description: "ui sound" }
    ];
    const commonKoreanPatterns = [
      { korean: "", romanization: "an", description: "an sound" },
      { korean: "", romanization: "eum", description: "eum sound" },
      { korean: "", romanization: "i", description: "i sound" },
      { korean: "", romanization: "eun", description: "eun sound" },
      { korean: "", romanization: "eul", description: "eul sound" },
      { korean: "", romanization: "ui", description: "ui sound" },
      { korean: "", romanization: "e", description: "e sound" },
      { korean: "", romanization: "ge", description: "ge sound" },
      { korean: "", romanization: "se", description: "se sound" },
      { korean: "", romanization: "de", description: "de sound" },
      { korean: "", romanization: "ne", description: "ne sound" },
      { korean: "", romanization: "be", description: "be sound" }
    ];
    const specialChars = [
      { char: "-", description: "Syllable separator" },
      { char: "'", description: "Glottal stop" },
      { char: ":", description: "Long vowel marker" },
      { char: " ", description: "Space" },
      { char: "(", description: "Open parenthesis" },
      { char: ")", description: "Close parenthesis" },
      { char: "[", description: "Open bracket" },
      { char: "]", description: "Close bracket" }
    ];
    const filteredConsonantSounds = computed(() => {
      if (!searchQuery.value) return koreanConsonantSounds;
      const query = searchQuery.value.toLowerCase();
      return koreanConsonantSounds.filter(
        (sound) => sound.korean.includes(query) || sound.romanization.toLowerCase().includes(query) || sound.description.toLowerCase().includes(query)
      );
    });
    const filteredVowelSounds = computed(() => {
      if (!searchQuery.value) return koreanVowelSounds;
      const query = searchQuery.value.toLowerCase();
      return koreanVowelSounds.filter(
        (sound) => sound.korean.includes(query) || sound.romanization.toLowerCase().includes(query) || sound.description.toLowerCase().includes(query)
      );
    });
    const filteredCommonPatterns = computed(() => {
      if (!searchQuery.value) return commonKoreanPatterns;
      const query = searchQuery.value.toLowerCase();
      return commonKoreanPatterns.filter(
        (pattern) => pattern.korean.includes(query) || pattern.romanization.toLowerCase().includes(query) || pattern.description.toLowerCase().includes(query)
      );
    });
    const focusSearchInput = () => {
      if (searchInputRef.value) {
        searchInputRef.value.focus();
      }
    };
    const refocusSearchInput = () => {
      setTimeout(() => {
        focusSearchInput();
      }, 50);
    };
    const addSound = (sound) => {
      currentPronunciation.value += sound;
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const clearPronunciation = () => {
      currentPronunciation.value = "";
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const backspacePronunciation = () => {
      if (currentPronunciation.value.length > 0) {
        currentPronunciation.value = currentPronunciation.value.slice(0, -1);
      }
      setTimeout(() => {
        focusSearchInput();
      }, 10);
    };
    const closeDialog = () => {
      emit("update:modelValue", false);
    };
    const confirmPronunciation = () => {
      emit("pronunciation-confirmed", currentPronunciation.value);
      emit("update:modelValue", false);
    };
    watch(() => props.initialValue, (newValue) => {
      currentPronunciation.value = newValue;
    }, { immediate: true });
    watch(() => props.modelValue, async (isOpen) => {
      if (isOpen) {
        currentPronunciation.value = props.initialValue;
        searchQuery.value = "";
        await nextTick();
        setTimeout(() => {
          focusSearchInput();
        }, 100);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.modelValue ? (openBlock(), createElementBlock("div", _hoisted_1$7, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$5, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-gray-700 flex flex-col h-full overflow-hidden transform",
                      onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$4, [
                        createBaseVNode("div", _hoisted_4$4, [
                          createBaseVNode("h2", _hoisted_5$3, [
                            _cache[3] || (_cache[3] = createBaseVNode("span", { class: "w-2 h-2 bg-green-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("korean.pronunciationHelper.title", "Korean Pronunciation Helper")), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: closeDialog,
                            class: "text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                          }, _cache[4] || (_cache[4] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_6$2, [
                        createBaseVNode("div", _hoisted_7$2, [
                          _cache[5] || (_cache[5] = createBaseVNode("div", { class: "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none" }, [
                            createBaseVNode("svg", {
                              class: "h-5 w-5 text-gray-400",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                              })
                            ])
                          ], -1)),
                          withDirectives(createBaseVNode("input", {
                            ref_key: "searchInputRef",
                            ref: searchInputRef,
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
                            type: "text",
                            class: "block w-full pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-green-500 dark:bg-[#0a0a0a] dark:text-white",
                            placeholder: unref(t)("common.search", "Search Korean sounds..."),
                            onBlur: refocusSearchInput
                          }, null, 40, _hoisted_8$2), [
                            [vModelText, searchQuery.value]
                          ])
                        ]),
                        createBaseVNode("div", null, [
                          createBaseVNode("label", _hoisted_9$2, [
                            _cache[6] || (_cache[6] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                            createTextVNode(" " + toDisplayString$1(unref(t)("korean.pronunciationHelper.preview", "Pronunciation Preview")), 1)
                          ]),
                          createBaseVNode("div", _hoisted_10$2, [
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => currentPronunciation.value = $event),
                              type: "text",
                              class: "w-full px-3 py-2 pr-20 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition-all duration-300 text-lg",
                              placeholder: unref(t)("korean.pronunciationHelper.placeholder", "Click Korean sounds below..."),
                              readonly: ""
                            }, null, 8, _hoisted_11$2), [
                              [vModelText, currentPronunciation.value]
                            ]),
                            currentPronunciation.value ? (openBlock(), createElementBlock("button", {
                              key: 0,
                              onClick: backspacePronunciation,
                              class: "absolute right-12 top-1/2 -translate-y-1/2 w-8 h-6 bg-orange-500 hover:bg-orange-600 text-white rounded flex items-center justify-center text-xs font-bold transition-all duration-300 hover:scale-110",
                              title: unref(t)("common.backspace", "Backspace")
                            }, "  ", 8, _hoisted_12$2)) : createCommentVNode("", true),
                            currentPronunciation.value ? (openBlock(), createElementBlock("button", {
                              key: 1,
                              onClick: clearPronunciation,
                              class: "absolute right-2 top-1/2 -translate-y-1/2 w-6 h-6 bg-red-500 hover:bg-red-600 text-white rounded-full flex items-center justify-center text-xs font-bold transition-all duration-300 hover:scale-110",
                              title: unref(t)("common.clear", "Clear")
                            }, "  ", 8, _hoisted_13$2)) : createCommentVNode("", true)
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_14$2, [
                        createBaseVNode("div", _hoisted_15$1, [
                          createBaseVNode("div", null, [
                            createBaseVNode("h3", _hoisted_16$1, [
                              _cache[7] || (_cache[7] = createBaseVNode("span", { class: "w-1 h-4 bg-blue-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("korean.pronunciationHelper.consonantSounds", "Consonant Sounds ( )")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_17$1, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredConsonantSounds.value, (sound) => {
                                return openBlock(), createElementBlock("button", {
                                  key: sound.korean,
                                  onClick: ($event) => addSound(sound.romanization),
                                  class: "p-2 bg-blue-100 hover:bg-blue-200 dark:bg-blue-900 dark:hover:bg-blue-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm",
                                  title: sound.description
                                }, [
                                  createBaseVNode("span", _hoisted_19$1, toDisplayString$1(sound.korean), 1),
                                  createBaseVNode("span", _hoisted_20$1, toDisplayString$1(sound.romanization), 1)
                                ], 8, _hoisted_18$1);
                              }), 128))
                            ])
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("h3", _hoisted_21$1, [
                              _cache[8] || (_cache[8] = createBaseVNode("span", { class: "w-1 h-4 bg-green-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("korean.pronunciationHelper.vowelSounds", "Vowel Sounds ( )")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_22$1, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredVowelSounds.value, (sound) => {
                                return openBlock(), createElementBlock("button", {
                                  key: sound.korean,
                                  onClick: ($event) => addSound(sound.romanization),
                                  class: "p-2 bg-green-100 hover:bg-green-200 dark:bg-green-900 dark:hover:bg-green-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm",
                                  title: sound.description
                                }, [
                                  createBaseVNode("span", _hoisted_24$1, toDisplayString$1(sound.korean), 1),
                                  createBaseVNode("span", _hoisted_25$1, toDisplayString$1(sound.romanization), 1)
                                ], 8, _hoisted_23$1);
                              }), 128))
                            ])
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("h3", _hoisted_26, [
                              _cache[9] || (_cache[9] = createBaseVNode("span", { class: "w-1 h-4 bg-purple-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("korean.pronunciationHelper.commonPatterns", "Common Patterns")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_27, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredCommonPatterns.value, (pattern) => {
                                return openBlock(), createElementBlock("button", {
                                  key: pattern.korean,
                                  onClick: ($event) => addSound(pattern.romanization),
                                  class: "p-2 bg-purple-100 hover:bg-purple-200 dark:bg-purple-900 dark:hover:bg-purple-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 flex flex-col items-center text-sm",
                                  title: pattern.description
                                }, [
                                  createBaseVNode("span", _hoisted_29, toDisplayString$1(pattern.korean), 1),
                                  createBaseVNode("span", _hoisted_30, toDisplayString$1(pattern.romanization), 1)
                                ], 8, _hoisted_28);
                              }), 128))
                            ])
                          ]),
                          createBaseVNode("div", null, [
                            createBaseVNode("h3", _hoisted_31, [
                              _cache[10] || (_cache[10] = createBaseVNode("span", { class: "w-1 h-4 bg-yellow-500 rounded mr-2" }, null, -1)),
                              createTextVNode(" " + toDisplayString$1(unref(t)("korean.pronunciationHelper.specialChars", "Special Characters")), 1)
                            ]),
                            createBaseVNode("div", _hoisted_32, [
                              (openBlock(), createElementBlock(Fragment, null, renderList(specialChars, (char) => {
                                return createBaseVNode("button", {
                                  key: char.char,
                                  onClick: ($event) => addSound(char.char),
                                  class: "px-3 py-2 bg-yellow-100 hover:bg-yellow-200 dark:bg-yellow-900 dark:hover:bg-yellow-800 text-gray-800 dark:text-gray-200 rounded-lg transition-all duration-200 hover:scale-105 text-sm font-mono",
                                  title: char.description
                                }, toDisplayString$1(char.char), 9, _hoisted_33);
                              }), 64))
                            ])
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_34, [
                        createBaseVNode("div", _hoisted_35, [
                          createBaseVNode("button", {
                            type: "button",
                            onClick: clearPronunciation,
                            class: "px-4 py-2 text-sm font-medium text-gray-600 dark:text-gray-400 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition-all duration-300 hover:scale-105"
                          }, toDisplayString$1(unref(t)("common.clear", "Clear")), 1),
                          createBaseVNode("div", _hoisted_36, [
                            createBaseVNode("button", {
                              type: "button",
                              onClick: closeDialog,
                              class: "px-4 py-2 text-sm font-medium text-gray-600 dark:text-gray-400 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-lg transition-all duration-300 hover:scale-105"
                            }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                            createBaseVNode("button", {
                              type: "button",
                              onClick: confirmPronunciation,
                              class: "px-4 py-2 text-sm font-medium text-white bg-green-600 hover:bg-green-700 rounded-lg transition-all duration-300 hover:scale-105 shadow-lg"
                            }, toDisplayString$1(unref(t)("common.confirm", "Confirm")), 1)
                          ])
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const KoreanPronunciationHelper = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-6520a892"]]);

const KoreanPronunciationHelper$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: KoreanPronunciationHelper
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$6 = {
  key: 0,
  class: "fixed inset-0 bg-black/60 flex items-center justify-center p-4 z-[10000] backdrop-blur-sm"
};
const _hoisted_2$4 = { class: "w-full max-h-[90vh] flex flex-col max-w-full sm:max-w-lg md:max-w-2xl" };
const _hoisted_3$3 = {
  class: "px-6 py-4 border-b border-gray-200 dark:border-[#0f0f0f] flex-shrink-0 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] animate-fade-in-up",
  style: { "animation-delay": "0.1s" }
};
const _hoisted_4$3 = { class: "flex items-center justify-between" };
const _hoisted_5$2 = { class: "text-lg sm:text-xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2" };
const _hoisted_6$1 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.2s" }
};
const _hoisted_7$1 = {
  for: "rate",
  class: "block text-sm font-medium text-gray-700 dark:text-white/80"
};
const _hoisted_8$1 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.3s" }
};
const _hoisted_9$1 = {
  for: "pitch",
  class: "block text-sm font-medium text-gray-700 dark:text-white/80"
};
const _hoisted_10$1 = {
  class: "animate-fade-in-up",
  style: { "animation-delay": "0.4s" }
};
const _hoisted_11$1 = {
  for: "volume",
  class: "block text-sm font-medium text-gray-700 dark:text-white/80"
};
const _hoisted_12$1 = {
  class: "px-6 py-4 border-t border-gray-200 dark:border-[#0f0f0f] flex-shrink-0 bg-gradient-to-r from-gray-50 to-blue-50 dark:from-[#0a0a0a] dark:to-[#0a0a0a] animate-fade-in-up",
  style: { "animation-delay": "0.5s" }
};
const _hoisted_13$1 = { class: "flex justify-between items-center" };
const _hoisted_14$1 = { class: "space-x-3" };
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "VoiceSettingsModal",
  props: {
    show: { type: Boolean },
    voiceType: {},
    voiceName: {},
    initialSettings: {}
  },
  emits: ["close", "save", "reset"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const localSettings = ref({ ...props.initialSettings });
    const modalContentRef = ref(null);
    watch(() => props.initialSettings, (newSettings) => {
      if (newSettings) {
        localSettings.value = { ...newSettings };
      }
    }, { deep: true, immediate: true });
    watch(() => props.show, (isOpen) => {
      if (isOpen) {
        document.body.style.overflow = "hidden";
      } else {
        document.body.style.overflow = "";
      }
    }, { immediate: true });
    onUnmounted(() => {
      document.body.style.overflow = "";
    });
    const close = () => {
      emit("close");
    };
    const save = () => {
      emit("save", { voiceType: props.voiceType, settings: localSettings.value });
      close();
    };
    const resetToDefaults = () => {
      emit("reset", props.voiceType);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(Transition, {
          "enter-active-class": "transition-all duration-500 ease-out",
          "enter-from-class": "opacity-0",
          "enter-to-class": "opacity-100",
          "leave-active-class": "transition-all duration-300 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_1$6, [
              createVNode(Transition, {
                "enter-active-class": "transition-all duration-500 ease-out",
                "enter-from-class": "opacity-0 scale-90 translate-y-8 rotate-1",
                "enter-to-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-active-class": "transition-all duration-300 ease-in",
                "leave-from-class": "opacity-100 scale-100 translate-y-0 rotate-0",
                "leave-to-class": "opacity-0 scale-90 translate-y-8 rotate-1"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_2$4, [
                    createBaseVNode("div", {
                      class: "bg-white dark:bg-[#0a0a0a] shadow-2xl rounded-xl border border-gray-200 dark:border-[#0f0f0f] flex flex-col h-full overflow-hidden transform",
                      onClick: _cache[3] || (_cache[3] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("div", _hoisted_3$3, [
                        createBaseVNode("div", _hoisted_4$3, [
                          createBaseVNode("h2", _hoisted_5$2, [
                            _cache[4] || (_cache[4] = createBaseVNode("span", { class: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }, null, -1)),
                            createBaseVNode("span", null, toDisplayString$1(unref(t)("voice.settings.title", "Voice Settings")) + ": " + toDisplayString$1(_ctx.voiceName), 1)
                          ]),
                          createBaseVNode("button", {
                            onClick: close,
                            class: "text-gray-500 hover:text-gray-700 dark:text-white/70 dark:hover:text-white transition-all duration-300 hover:scale-110 hover:rotate-90 p-1 rounded-full hover:bg-gray-100 dark:hover:bg-black"
                          }, _cache[5] || (_cache[5] = [
                            createBaseVNode("svg", {
                              class: "w-6 h-6",
                              fill: "none",
                              stroke: "currentColor",
                              viewBox: "0 0 24 24"
                            }, [
                              createBaseVNode("path", {
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round",
                                "stroke-width": "2",
                                d: "M6 18L18 6M6 6l12 12"
                              })
                            ], -1)
                          ]))
                        ])
                      ]),
                      createBaseVNode("div", {
                        ref_key: "modalContentRef",
                        ref: modalContentRef,
                        class: "px-6 py-4 flex-1 overflow-y-auto min-h-0 space-y-6"
                      }, [
                        createBaseVNode("div", _hoisted_6$1, [
                          createBaseVNode("label", _hoisted_7$1, toDisplayString$1(unref(t)("voice.settings.rate", "Rate")) + " (" + toDisplayString$1(localSettings.value.rate.toFixed(2)) + ")", 1),
                          withDirectives(createBaseVNode("input", {
                            id: "rate",
                            type: "range",
                            min: "0.5",
                            max: "2",
                            step: "0.1",
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => localSettings.value.rate = $event),
                            class: "w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-[#0f0f0f]"
                          }, null, 512), [
                            [
                              vModelText,
                              localSettings.value.rate,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("div", _hoisted_8$1, [
                          createBaseVNode("label", _hoisted_9$1, toDisplayString$1(unref(t)("voice.settings.pitch", "Pitch")) + " (" + toDisplayString$1(localSettings.value.pitch.toFixed(2)) + ")", 1),
                          withDirectives(createBaseVNode("input", {
                            id: "pitch",
                            type: "range",
                            min: "0",
                            max: "2",
                            step: "0.1",
                            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => localSettings.value.pitch = $event),
                            class: "w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-[#0f0f0f]"
                          }, null, 512), [
                            [
                              vModelText,
                              localSettings.value.pitch,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ]),
                        createBaseVNode("div", _hoisted_10$1, [
                          createBaseVNode("label", _hoisted_11$1, toDisplayString$1(unref(t)("voice.settings.volume", "Volume")) + " (" + toDisplayString$1(localSettings.value.volume.toFixed(2)) + ")", 1),
                          withDirectives(createBaseVNode("input", {
                            id: "volume",
                            type: "range",
                            min: "0",
                            max: "1",
                            step: "0.1",
                            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => localSettings.value.volume = $event),
                            class: "w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-[#0f0f0f]"
                          }, null, 512), [
                            [
                              vModelText,
                              localSettings.value.volume,
                              void 0,
                              { number: true }
                            ]
                          ])
                        ])
                      ], 512),
                      createBaseVNode("div", _hoisted_12$1, [
                        createBaseVNode("div", _hoisted_13$1, [
                          createBaseVNode("button", {
                            onClick: resetToDefaults,
                            class: "px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 dark:bg-[#0a0a0a] dark:text-white/80 dark:hover:bg-black border dark:border-[#0f0f0f] transition-colors"
                          }, toDisplayString$1(unref(t)("common.resetToDefault", "Reset to Default")), 1),
                          createBaseVNode("div", _hoisted_14$1, [
                            createBaseVNode("button", {
                              onClick: close,
                              class: "px-4 py-2 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 dark:bg-[#0a0a0a] dark:text-white/80 dark:hover:bg-black border dark:border-[#0f0f0f] transition-colors"
                            }, toDisplayString$1(unref(t)("common.cancel", "Cancel")), 1),
                            createBaseVNode("button", {
                              onClick: save,
                              class: "px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors"
                            }, toDisplayString$1(unref(t)("common.save", "Save")), 1)
                          ])
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
});

const VoiceSettingsModal = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-2954474a"]]);

const VoiceSettingsModal$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: VoiceSettingsModal
}, Symbol.toStringTag, { value: 'Module' }));

// canvas-confetti v1.9.3 built on 2024-04-30T22:19:17.794Z
var module = {};

// source content
/* globals Map */

(function main(global, module, isWorker, workerSize) {
  var canUseWorker = !!(
    global.Worker &&
    global.Blob &&
    global.Promise &&
    global.OffscreenCanvas &&
    global.OffscreenCanvasRenderingContext2D &&
    global.HTMLCanvasElement &&
    global.HTMLCanvasElement.prototype.transferControlToOffscreen &&
    global.URL &&
    global.URL.createObjectURL);

  var canUsePaths = typeof Path2D === 'function' && typeof DOMMatrix === 'function';
  var canDrawBitmap = (function () {
    // this mostly supports ssr
    if (!global.OffscreenCanvas) {
      return false;
    }

    var canvas = new OffscreenCanvas(1, 1);
    var ctx = canvas.getContext('2d');
    ctx.fillRect(0, 0, 1, 1);
    var bitmap = canvas.transferToImageBitmap();

    try {
      ctx.createPattern(bitmap, 'no-repeat');
    } catch (e) {
      return false;
    }

    return true;
  })();

  function noop() {}

  // create a promise if it exists, otherwise, just
  // call the function directly
  function promise(func) {
    var ModulePromise = module.exports.Promise;
    var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;

    if (typeof Prom === 'function') {
      return new Prom(func);
    }

    func(noop, noop);

    return null;
  }

  var bitmapMapper = (function (skipTransform, map) {
    // see https://github.com/catdad/canvas-confetti/issues/209
    // creating canvases is actually pretty expensive, so we should create a
    // 1:1 map for bitmap:canvas, so that we can animate the confetti in
    // a performant manner, but also not store them forever so that we don't
    // have a memory leak
    return {
      transform: function(bitmap) {
        if (skipTransform) {
          return bitmap;
        }

        if (map.has(bitmap)) {
          return map.get(bitmap);
        }

        var canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
        var ctx = canvas.getContext('2d');
        ctx.drawImage(bitmap, 0, 0);

        map.set(bitmap, canvas);

        return canvas;
      },
      clear: function () {
        map.clear();
      }
    };
  })(canDrawBitmap, new Map());

  var raf = (function () {
    var TIME = Math.floor(1000 / 60);
    var frame, cancel;
    var frames = {};
    var lastFrameTime = 0;

    if (typeof requestAnimationFrame === 'function' && typeof cancelAnimationFrame === 'function') {
      frame = function (cb) {
        var id = Math.random();

        frames[id] = requestAnimationFrame(function onFrame(time) {
          if (lastFrameTime === time || lastFrameTime + TIME - 1 < time) {
            lastFrameTime = time;
            delete frames[id];

            cb();
          } else {
            frames[id] = requestAnimationFrame(onFrame);
          }
        });

        return id;
      };
      cancel = function (id) {
        if (frames[id]) {
          cancelAnimationFrame(frames[id]);
        }
      };
    } else {
      frame = function (cb) {
        return setTimeout(cb, TIME);
      };
      cancel = function (timer) {
        return clearTimeout(timer);
      };
    }

    return { frame: frame, cancel: cancel };
  }());

  var getWorker = (function () {
    var worker;
    var prom;
    var resolves = {};

    function decorate(worker) {
      function execute(options, callback) {
        worker.postMessage({ options: options || {}, callback: callback });
      }
      worker.init = function initWorker(canvas) {
        var offscreen = canvas.transferControlToOffscreen();
        worker.postMessage({ canvas: offscreen }, [offscreen]);
      };

      worker.fire = function fireWorker(options, size, done) {
        if (prom) {
          execute(options, null);
          return prom;
        }

        var id = Math.random().toString(36).slice(2);

        prom = promise(function (resolve) {
          function workerDone(msg) {
            if (msg.data.callback !== id) {
              return;
            }

            delete resolves[id];
            worker.removeEventListener('message', workerDone);

            prom = null;

            bitmapMapper.clear();

            done();
            resolve();
          }

          worker.addEventListener('message', workerDone);
          execute(options, id);

          resolves[id] = workerDone.bind(null, { data: { callback: id }});
        });

        return prom;
      };

      worker.reset = function resetWorker() {
        worker.postMessage({ reset: true });

        for (var id in resolves) {
          resolves[id]();
          delete resolves[id];
        }
      };
    }

    return function () {
      if (worker) {
        return worker;
      }

      if (!isWorker && canUseWorker) {
        var code = [
          'var CONFETTI, SIZE = {}, module = {};',
          '(' + main.toString() + ')(this, module, true, SIZE);',
          'onmessage = function(msg) {',
          '  if (msg.data.options) {',
          '    CONFETTI(msg.data.options).then(function () {',
          '      if (msg.data.callback) {',
          '        postMessage({ callback: msg.data.callback });',
          '      }',
          '    });',
          '  } else if (msg.data.reset) {',
          '    CONFETTI && CONFETTI.reset();',
          '  } else if (msg.data.resize) {',
          '    SIZE.width = msg.data.resize.width;',
          '    SIZE.height = msg.data.resize.height;',
          '  } else if (msg.data.canvas) {',
          '    SIZE.width = msg.data.canvas.width;',
          '    SIZE.height = msg.data.canvas.height;',
          '    CONFETTI = module.exports.create(msg.data.canvas);',
          '  }',
          '}',
        ].join('\n');
        try {
          worker = new Worker(URL.createObjectURL(new Blob([code])));
        } catch (e) {
          // eslint-disable-next-line no-console
          typeof console !== undefined && typeof console.warn === 'function' ? console.warn(' Could not load worker', e) : null;

          return null;
        }

        decorate(worker);
      }

      return worker;
    };
  })();

  var defaults = {
    particleCount: 50,
    angle: 90,
    spread: 45,
    startVelocity: 45,
    decay: 0.9,
    gravity: 1,
    drift: 0,
    ticks: 200,
    x: 0.5,
    y: 0.5,
    shapes: ['square', 'circle'],
    zIndex: 100,
    colors: [
      '#26ccff',
      '#a25afd',
      '#ff5e7e',
      '#88ff5a',
      '#fcff42',
      '#ffa62d',
      '#ff36ff'
    ],
    // probably should be true, but back-compat
    disableForReducedMotion: false,
    scalar: 1
  };

  function convert(val, transform) {
    return transform ? transform(val) : val;
  }

  function isOk(val) {
    return !(val === null || val === undefined);
  }

  function prop(options, name, transform) {
    return convert(
      options && isOk(options[name]) ? options[name] : defaults[name],
      transform
    );
  }

  function onlyPositiveInt(number){
    return number < 0 ? 0 : Math.floor(number);
  }

  function randomInt(min, max) {
    // [min, max)
    return Math.floor(Math.random() * (max - min)) + min;
  }

  function toDecimal(str) {
    return parseInt(str, 16);
  }

  function colorsToRgb(colors) {
    return colors.map(hexToRgb);
  }

  function hexToRgb(str) {
    var val = String(str).replace(/[^0-9a-f]/gi, '');

    if (val.length < 6) {
        val = val[0]+val[0]+val[1]+val[1]+val[2]+val[2];
    }

    return {
      r: toDecimal(val.substring(0,2)),
      g: toDecimal(val.substring(2,4)),
      b: toDecimal(val.substring(4,6))
    };
  }

  function getOrigin(options) {
    var origin = prop(options, 'origin', Object);
    origin.x = prop(origin, 'x', Number);
    origin.y = prop(origin, 'y', Number);

    return origin;
  }

  function setCanvasWindowSize(canvas) {
    canvas.width = document.documentElement.clientWidth;
    canvas.height = document.documentElement.clientHeight;
  }

  function setCanvasRectSize(canvas) {
    var rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
  }

  function getCanvas(zIndex) {
    var canvas = document.createElement('canvas');

    canvas.style.position = 'fixed';
    canvas.style.top = '0px';
    canvas.style.left = '0px';
    canvas.style.pointerEvents = 'none';
    canvas.style.zIndex = zIndex;

    return canvas;
  }

  function ellipse(context, x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {
    context.save();
    context.translate(x, y);
    context.rotate(rotation);
    context.scale(radiusX, radiusY);
    context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);
    context.restore();
  }

  function randomPhysics(opts) {
    var radAngle = opts.angle * (Math.PI / 180);
    var radSpread = opts.spread * (Math.PI / 180);

    return {
      x: opts.x,
      y: opts.y,
      wobble: Math.random() * 10,
      wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),
      velocity: (opts.startVelocity * 0.5) + (Math.random() * opts.startVelocity),
      angle2D: -radAngle + ((0.5 * radSpread) - (Math.random() * radSpread)),
      tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,
      color: opts.color,
      shape: opts.shape,
      tick: 0,
      totalTicks: opts.ticks,
      decay: opts.decay,
      drift: opts.drift,
      random: Math.random() + 2,
      tiltSin: 0,
      tiltCos: 0,
      wobbleX: 0,
      wobbleY: 0,
      gravity: opts.gravity * 3,
      ovalScalar: 0.6,
      scalar: opts.scalar,
      flat: opts.flat
    };
  }

  function updateFetti(context, fetti) {
    fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;
    fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;
    fetti.velocity *= fetti.decay;

    if (fetti.flat) {
      fetti.wobble = 0;
      fetti.wobbleX = fetti.x + (10 * fetti.scalar);
      fetti.wobbleY = fetti.y + (10 * fetti.scalar);

      fetti.tiltSin = 0;
      fetti.tiltCos = 0;
      fetti.random = 1;
    } else {
      fetti.wobble += fetti.wobbleSpeed;
      fetti.wobbleX = fetti.x + ((10 * fetti.scalar) * Math.cos(fetti.wobble));
      fetti.wobbleY = fetti.y + ((10 * fetti.scalar) * Math.sin(fetti.wobble));

      fetti.tiltAngle += 0.1;
      fetti.tiltSin = Math.sin(fetti.tiltAngle);
      fetti.tiltCos = Math.cos(fetti.tiltAngle);
      fetti.random = Math.random() + 2;
    }

    var progress = (fetti.tick++) / fetti.totalTicks;

    var x1 = fetti.x + (fetti.random * fetti.tiltCos);
    var y1 = fetti.y + (fetti.random * fetti.tiltSin);
    var x2 = fetti.wobbleX + (fetti.random * fetti.tiltCos);
    var y2 = fetti.wobbleY + (fetti.random * fetti.tiltSin);

    context.fillStyle = 'rgba(' + fetti.color.r + ', ' + fetti.color.g + ', ' + fetti.color.b + ', ' + (1 - progress) + ')';

    context.beginPath();

    if (canUsePaths && fetti.shape.type === 'path' && typeof fetti.shape.path === 'string' && Array.isArray(fetti.shape.matrix)) {
      context.fill(transformPath2D(
        fetti.shape.path,
        fetti.shape.matrix,
        fetti.x,
        fetti.y,
        Math.abs(x2 - x1) * 0.1,
        Math.abs(y2 - y1) * 0.1,
        Math.PI / 10 * fetti.wobble
      ));
    } else if (fetti.shape.type === 'bitmap') {
      var rotation = Math.PI / 10 * fetti.wobble;
      var scaleX = Math.abs(x2 - x1) * 0.1;
      var scaleY = Math.abs(y2 - y1) * 0.1;
      var width = fetti.shape.bitmap.width * fetti.scalar;
      var height = fetti.shape.bitmap.height * fetti.scalar;

      var matrix = new DOMMatrix([
        Math.cos(rotation) * scaleX,
        Math.sin(rotation) * scaleX,
        -Math.sin(rotation) * scaleY,
        Math.cos(rotation) * scaleY,
        fetti.x,
        fetti.y
      ]);

      // apply the transform matrix from the confetti shape
      matrix.multiplySelf(new DOMMatrix(fetti.shape.matrix));

      var pattern = context.createPattern(bitmapMapper.transform(fetti.shape.bitmap), 'no-repeat');
      pattern.setTransform(matrix);

      context.globalAlpha = (1 - progress);
      context.fillStyle = pattern;
      context.fillRect(
        fetti.x - (width / 2),
        fetti.y - (height / 2),
        width,
        height
      );
      context.globalAlpha = 1;
    } else if (fetti.shape === 'circle') {
      context.ellipse ?
        context.ellipse(fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) :
        ellipse(context, fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);
    } else if (fetti.shape === 'star') {
      var rot = Math.PI / 2 * 3;
      var innerRadius = 4 * fetti.scalar;
      var outerRadius = 8 * fetti.scalar;
      var x = fetti.x;
      var y = fetti.y;
      var spikes = 5;
      var step = Math.PI / spikes;

      while (spikes--) {
        x = fetti.x + Math.cos(rot) * outerRadius;
        y = fetti.y + Math.sin(rot) * outerRadius;
        context.lineTo(x, y);
        rot += step;

        x = fetti.x + Math.cos(rot) * innerRadius;
        y = fetti.y + Math.sin(rot) * innerRadius;
        context.lineTo(x, y);
        rot += step;
      }
    } else {
      context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));
      context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));
      context.lineTo(Math.floor(x2), Math.floor(y2));
      context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));
    }

    context.closePath();
    context.fill();

    return fetti.tick < fetti.totalTicks;
  }

  function animate(canvas, fettis, resizer, size, done) {
    var animatingFettis = fettis.slice();
    var context = canvas.getContext('2d');
    var animationFrame;
    var destroy;

    var prom = promise(function (resolve) {
      function onDone() {
        animationFrame = destroy = null;

        context.clearRect(0, 0, size.width, size.height);
        bitmapMapper.clear();

        done();
        resolve();
      }

      function update() {
        if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {
          size.width = canvas.width = workerSize.width;
          size.height = canvas.height = workerSize.height;
        }

        if (!size.width && !size.height) {
          resizer(canvas);
          size.width = canvas.width;
          size.height = canvas.height;
        }

        context.clearRect(0, 0, size.width, size.height);

        animatingFettis = animatingFettis.filter(function (fetti) {
          return updateFetti(context, fetti);
        });

        if (animatingFettis.length) {
          animationFrame = raf.frame(update);
        } else {
          onDone();
        }
      }

      animationFrame = raf.frame(update);
      destroy = onDone;
    });

    return {
      addFettis: function (fettis) {
        animatingFettis = animatingFettis.concat(fettis);

        return prom;
      },
      canvas: canvas,
      promise: prom,
      reset: function () {
        if (animationFrame) {
          raf.cancel(animationFrame);
        }

        if (destroy) {
          destroy();
        }
      }
    };
  }

  function confettiCannon(canvas, globalOpts) {
    var isLibCanvas = !canvas;
    var allowResize = !!prop(globalOpts || {}, 'resize');
    var hasResizeEventRegistered = false;
    var globalDisableForReducedMotion = prop(globalOpts, 'disableForReducedMotion', Boolean);
    var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, 'useWorker');
    var worker = shouldUseWorker ? getWorker() : null;
    var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;
    var initialized = (canvas && worker) ? !!canvas.__confetti_initialized : false;
    var preferLessMotion = typeof matchMedia === 'function' && matchMedia('(prefers-reduced-motion)').matches;
    var animationObj;

    function fireLocal(options, size, done) {
      var particleCount = prop(options, 'particleCount', onlyPositiveInt);
      var angle = prop(options, 'angle', Number);
      var spread = prop(options, 'spread', Number);
      var startVelocity = prop(options, 'startVelocity', Number);
      var decay = prop(options, 'decay', Number);
      var gravity = prop(options, 'gravity', Number);
      var drift = prop(options, 'drift', Number);
      var colors = prop(options, 'colors', colorsToRgb);
      var ticks = prop(options, 'ticks', Number);
      var shapes = prop(options, 'shapes');
      var scalar = prop(options, 'scalar');
      var flat = !!prop(options, 'flat');
      var origin = getOrigin(options);

      var temp = particleCount;
      var fettis = [];

      var startX = canvas.width * origin.x;
      var startY = canvas.height * origin.y;

      while (temp--) {
        fettis.push(
          randomPhysics({
            x: startX,
            y: startY,
            angle: angle,
            spread: spread,
            startVelocity: startVelocity,
            color: colors[temp % colors.length],
            shape: shapes[randomInt(0, shapes.length)],
            ticks: ticks,
            decay: decay,
            gravity: gravity,
            drift: drift,
            scalar: scalar,
            flat: flat
          })
        );
      }

      // if we have a previous canvas already animating,
      // add to it
      if (animationObj) {
        return animationObj.addFettis(fettis);
      }

      animationObj = animate(canvas, fettis, resizer, size , done);

      return animationObj.promise;
    }

    function fire(options) {
      var disableForReducedMotion = globalDisableForReducedMotion || prop(options, 'disableForReducedMotion', Boolean);
      var zIndex = prop(options, 'zIndex', Number);

      if (disableForReducedMotion && preferLessMotion) {
        return promise(function (resolve) {
          resolve();
        });
      }

      if (isLibCanvas && animationObj) {
        // use existing canvas from in-progress animation
        canvas = animationObj.canvas;
      } else if (isLibCanvas && !canvas) {
        // create and initialize a new canvas
        canvas = getCanvas(zIndex);
        document.body.appendChild(canvas);
      }

      if (allowResize && !initialized) {
        // initialize the size of a user-supplied canvas
        resizer(canvas);
      }

      var size = {
        width: canvas.width,
        height: canvas.height
      };

      if (worker && !initialized) {
        worker.init(canvas);
      }

      initialized = true;

      if (worker) {
        canvas.__confetti_initialized = true;
      }

      function onResize() {
        if (worker) {
          // TODO this really shouldn't be immediate, because it is expensive
          var obj = {
            getBoundingClientRect: function () {
              if (!isLibCanvas) {
                return canvas.getBoundingClientRect();
              }
            }
          };

          resizer(obj);

          worker.postMessage({
            resize: {
              width: obj.width,
              height: obj.height
            }
          });
          return;
        }

        // don't actually query the size here, since this
        // can execute frequently and rapidly
        size.width = size.height = null;
      }

      function done() {
        animationObj = null;

        if (allowResize) {
          hasResizeEventRegistered = false;
          global.removeEventListener('resize', onResize);
        }

        if (isLibCanvas && canvas) {
          if (document.body.contains(canvas)) {
            document.body.removeChild(canvas); 
          }
          canvas = null;
          initialized = false;
        }
      }

      if (allowResize && !hasResizeEventRegistered) {
        hasResizeEventRegistered = true;
        global.addEventListener('resize', onResize, false);
      }

      if (worker) {
        return worker.fire(options, size, done);
      }

      return fireLocal(options, size, done);
    }

    fire.reset = function () {
      if (worker) {
        worker.reset();
      }

      if (animationObj) {
        animationObj.reset();
      }
    };

    return fire;
  }

  // Make default export lazy to defer worker creation until called.
  var defaultFire;
  function getDefaultFire() {
    if (!defaultFire) {
      defaultFire = confettiCannon(null, { useWorker: true, resize: true });
    }
    return defaultFire;
  }

  function transformPath2D(pathString, pathMatrix, x, y, scaleX, scaleY, rotation) {
    var path2d = new Path2D(pathString);

    var t1 = new Path2D();
    t1.addPath(path2d, new DOMMatrix(pathMatrix));

    var t2 = new Path2D();
    // see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/DOMMatrix
    t2.addPath(t1, new DOMMatrix([
      Math.cos(rotation) * scaleX,
      Math.sin(rotation) * scaleX,
      -Math.sin(rotation) * scaleY,
      Math.cos(rotation) * scaleY,
      x,
      y
    ]));

    return t2;
  }

  function shapeFromPath(pathData) {
    if (!canUsePaths) {
      throw new Error('path confetti are not supported in this browser');
    }

    var path, matrix;

    if (typeof pathData === 'string') {
      path = pathData;
    } else {
      path = pathData.path;
      matrix = pathData.matrix;
    }

    var path2d = new Path2D(path);
    var tempCanvas = document.createElement('canvas');
    var tempCtx = tempCanvas.getContext('2d');

    if (!matrix) {
      // attempt to figure out the width of the path, up to 1000x1000
      var maxSize = 1000;
      var minX = maxSize;
      var minY = maxSize;
      var maxX = 0;
      var maxY = 0;
      var width, height;

      // do some line skipping... this is faster than checking
      // every pixel and will be mostly still correct
      for (var x = 0; x < maxSize; x += 2) {
        for (var y = 0; y < maxSize; y += 2) {
          if (tempCtx.isPointInPath(path2d, x, y, 'nonzero')) {
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
        }
      }

      width = maxX - minX;
      height = maxY - minY;

      var maxDesiredSize = 10;
      var scale = Math.min(maxDesiredSize/width, maxDesiredSize/height);

      matrix = [
        scale, 0, 0, scale,
        -Math.round((width/2) + minX) * scale,
        -Math.round((height/2) + minY) * scale
      ];
    }

    return {
      type: 'path',
      path: path,
      matrix: matrix
    };
  }

  function shapeFromText(textData) {
    var text,
        scalar = 1,
        color = '#000000',
        // see https://nolanlawson.com/2022/04/08/the-struggle-of-using-native-emoji-on-the-web/
        fontFamily = '"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", "EmojiOne Color", "Android Emoji", "Twemoji Mozilla", "system emoji", sans-serif';

    if (typeof textData === 'string') {
      text = textData;
    } else {
      text = textData.text;
      scalar = 'scalar' in textData ? textData.scalar : scalar;
      fontFamily = 'fontFamily' in textData ? textData.fontFamily : fontFamily;
      color = 'color' in textData ? textData.color : color;
    }

    // all other confetti are 10 pixels,
    // so this pixel size is the de-facto 100% scale confetti
    var fontSize = 10 * scalar;
    var font = '' + fontSize + 'px ' + fontFamily;

    var canvas = new OffscreenCanvas(fontSize, fontSize);
    var ctx = canvas.getContext('2d');

    ctx.font = font;
    var size = ctx.measureText(text);
    var width = Math.ceil(size.actualBoundingBoxRight + size.actualBoundingBoxLeft);
    var height = Math.ceil(size.actualBoundingBoxAscent + size.actualBoundingBoxDescent);

    var padding = 2;
    var x = size.actualBoundingBoxLeft + padding;
    var y = size.actualBoundingBoxAscent + padding;
    width += padding + padding;
    height += padding + padding;

    canvas = new OffscreenCanvas(width, height);
    ctx = canvas.getContext('2d');
    ctx.font = font;
    ctx.fillStyle = color;

    ctx.fillText(text, x, y);

    var scale = 1 / scalar;

    return {
      type: 'bitmap',
      // TODO these probably need to be transfered for workers
      bitmap: canvas.transferToImageBitmap(),
      matrix: [scale, 0, 0, scale, -width * scale / 2, -height * scale / 2]
    };
  }

  module.exports = function() {
    return getDefaultFire().apply(this, arguments);
  };
  module.exports.reset = function() {
    getDefaultFire().reset();
  };
  module.exports.create = confettiCannon;
  module.exports.shapeFromPath = shapeFromPath;
  module.exports.shapeFromText = shapeFromText;
}((function () {
  if (typeof window !== 'undefined') {
    return window;
  }

  if (typeof self !== 'undefined') {
    return self;
  }

  return this || {};
})(), module, false));

// end source content

const confetti = module.exports;
module.exports.create;

const _hoisted_1$5 = { class: "firework-sound-effect" };
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "FireworkSoundEffect",
  props: {
    triggerFirework: { type: Boolean, default: false },
    triggerSound: { type: Boolean, default: false },
    isCorrect: { type: Boolean, default: true },
    soundVolume: { default: 0.5 }
  },
  emits: ["effect-complete"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    toRefs(props);
    let audioContextInstance = null;
    const getAudioContext = () => {
      if (!audioContextInstance || audioContextInstance.state === "closed") {
        audioContextInstance = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContextInstance;
    };
    const createSuccessSound = () => {
      try {
        const audioContext = getAudioContext();
        if (audioContext.state === "suspended") {
          audioContext.resume();
        }
        const playNote = (frequency, startTime, duration) => {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          oscillator.frequency.setValueAtTime(frequency, startTime);
          oscillator.type = "sine";
          gainNode.gain.setValueAtTime(0, startTime);
          gainNode.gain.linearRampToValueAtTime(props.soundVolume * 0.4, startTime + 0.02);
          gainNode.gain.exponentialRampToValueAtTime(1e-3, startTime + duration);
          oscillator.start(startTime);
          oscillator.stop(startTime + duration);
          oscillator.onended = () => {
            oscillator.disconnect();
            gainNode.disconnect();
          };
        };
        const now = audioContext.currentTime;
        playNote(523.25, now, 0.5);
        playNote(659.25, now + 0.15, 0.5);
        playNote(783.99, now + 0.3, 0.6);
      } catch (error) {
        console.warn("Web Audio API not supported:", error);
      }
    };
    const createErrorSound = () => {
      try {
        const audioContext = getAudioContext();
        if (audioContext.state === "suspended") {
          audioContext.resume();
        }
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        const now = audioContext.currentTime;
        oscillator.frequency.setValueAtTime(400, now);
        oscillator.frequency.exponentialRampToValueAtTime(180, now + 0.8);
        oscillator.type = "sawtooth";
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(props.soundVolume * 0.5, now + 0.02);
        gainNode.gain.exponentialRampToValueAtTime(1e-3, now + 0.8);
        oscillator.start(now);
        oscillator.stop(now + 0.8);
        oscillator.onended = () => {
          oscillator.disconnect();
          gainNode.disconnect();
        };
      } catch (error) {
        console.warn("Web Audio API not supported:", error);
      }
    };
    const triggerFireworkEffect = () => {
      if (!props.triggerFirework) return;
      if (props.isCorrect) {
        confetti({
          particleCount: 100,
          spread: 70,
          origin: { y: 0.6 },
          colors: ["#00ff00", "#32cd32", "#7cfc00", "#adff2f", "#9aff9a"]
        });
        setTimeout(() => {
          confetti({
            particleCount: 50,
            angle: 60,
            spread: 55,
            origin: { x: 0, y: 0.8 },
            colors: ["#ffd700", "#ffff00", "#ffffe0", "#fffacd"]
          });
        }, 200);
        setTimeout(() => {
          confetti({
            particleCount: 50,
            angle: 120,
            spread: 55,
            origin: { x: 1, y: 0.8 },
            colors: ["#ff69b4", "#ff1493", "#ffb6c1", "#ffc0cb"]
          });
        }, 400);
      } else {
        confetti({
          particleCount: 30,
          spread: 45,
          origin: { y: 0.7 },
          colors: ["#ff4444", "#ff6666", "#ff8888", "#ffaaaa"],
          gravity: 1.2,
          scalar: 0.8
        });
      }
    };
    const playSoundEffect = () => {
      if (!props.triggerSound) return;
      try {
        if (props.isCorrect) {
          createSuccessSound();
        } else {
          createErrorSound();
        }
      } catch (error) {
        console.warn("Sound playback error:", error);
        playFallbackSound(props.isCorrect);
      }
    };
    const playFallbackSound = (isCorrect2) => {
      try {
        const audioContext = getAudioContext();
        if (audioContext.state === "suspended") {
          audioContext.resume();
        }
        const now = audioContext.currentTime;
        if (isCorrect2) {
          const frequencies = [523, 659, 784];
          frequencies.forEach((freq, index) => {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            const startTime = now + index * 0.15;
            oscillator.frequency.setValueAtTime(freq, startTime);
            oscillator.type = "sine";
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(props.soundVolume * 0.4, startTime + 0.02);
            gainNode.gain.exponentialRampToValueAtTime(1e-3, startTime + 0.4);
            oscillator.start(startTime);
            oscillator.stop(startTime + 0.4);
            oscillator.onended = () => {
              oscillator.disconnect();
              gainNode.disconnect();
            };
          });
        } else {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          oscillator.frequency.setValueAtTime(400, now);
          oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.6);
          oscillator.type = "sawtooth";
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(props.soundVolume * 0.5, now + 0.02);
          gainNode.gain.exponentialRampToValueAtTime(1e-3, now + 0.6);
          oscillator.start(now);
          oscillator.stop(now + 0.6);
          oscillator.onended = () => {
            oscillator.disconnect();
            gainNode.disconnect();
          };
        }
      } catch (error) {
        console.warn("Web Audio API fallback failed:", error);
      }
    };
    const triggerEffects = () => {
      if (props.triggerFirework || props.triggerSound) {
        triggerFireworkEffect();
        playSoundEffect();
        setTimeout(() => {
          emit("effect-complete");
        }, 1e3);
      }
    };
    const { triggerFirework, triggerSound, isCorrect } = toRefs(props);
    watch([triggerFirework, triggerSound], ([newFirework, newSound]) => {
      if (newFirework || newSound) {
        triggerEffects();
      }
    }, { immediate: false });
    onUnmounted(() => {
      if (audioContextInstance && audioContextInstance.state !== "closed") {
        setTimeout(() => {
          if (audioContextInstance && audioContextInstance.state !== "closed") {
            audioContextInstance.close();
            audioContextInstance = null;
          }
        }, 1e3);
      }
    });
    __expose({
      triggerEffects,
      triggerFireworkEffect,
      playSoundEffect
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$5);
    };
  }
});

const FireworkSoundEffect = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-146028e4"]]);

const FireworkSoundEffect$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: FireworkSoundEffect
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$4 = { class: "relative bg-gray-100 dark:bg-[#0a0a0a] rounded-md p-2 overflow-hidden" };
const _hoisted_2$3 = {
  class: "grid grid-cols-15 gap-px",
  style: { "grid-template-columns": "repeat(15, minmax(0, 1fr))" }
};
const _hoisted_3$2 = { class: "absolute inset-0 pointer-events-none" };
const _hoisted_4$2 = { class: "w-full h-full flex items-center justify-center" };
const _hoisted_5$1 = { class: "absolute inset-0 pointer-events-none" };
const gridW = 15;
const gridH = 10;
const cellSize = 8;
const gap = 1;
const padding = 8;
const stepInterval = 140;
const maxSteps = 18;
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "SnakeReplay",
  props: {
    data: {}
  },
  setup(__props) {
    const props = __props;
    const totalCells = gridW * gridH;
    const scalePos = (p) => ({ x: Math.floor(p.x / 2), y: Math.floor(p.y / 2) });
    const scaledFood = computed(() => scalePos(props.data.position));
    const state = reactive({
      head: scalePos(props.data.snakeBody[0] || { x: 0, y: 0 }),
      body: props.data.snakeBody.slice(1).map(scalePos),
      dir: { ...props.data.direction }
    });
    const head = computed(() => state.head);
    const renderBody = computed(() => state.body);
    const currentDirection = computed(() => state.dir);
    const baseCellClass = (index) => {
      const x = index % gridW;
      const y = Math.floor(index / gridW);
      if (x === scaledFood.value.x && y === scaledFood.value.y) {
        return props.data.wasCorrect ? "bg-emerald-300/70 dark:bg-emerald-700/60" : "bg-red-300/70 dark:bg-red-700/60";
      }
      return "bg-gray-200 dark:bg-dark-bg-soft hover:bg-gray-300 dark:hover:bg-dark-bg-soft";
    };
    const toPixel = (p) => ({
      left: `${padding + p.x * (cellSize + gap)}px`,
      top: `${padding + p.y * (cellSize + gap)}px`
    });
    const headStyle = (p) => ({
      position: "absolute",
      zIndex: 10,
      ...toPixel(p)
    });
    const segmentStyle = (p, idx) => ({
      position: "absolute",
      zIndex: 5,
      opacity: Math.max(0.35, 1 - idx * 0.1),
      transition: "left 120ms linear, top 120ms linear, opacity 300ms ease",
      ...toPixel(p)
    });
    const foodStyle = (p) => ({
      position: "absolute",
      ...toPixel(p)
    });
    const directionDotStyle = (d) => {
      let transform = "translate(-50%, -50%)";
      if (d.x === 1) transform += " translateX(25%)";
      else if (d.x === -1) transform += " translateX(-25%)";
      else if (d.y === 1) transform += " translateY(25%)";
      else if (d.y === -1) transform += " translateY(-25%)";
      return { position: "absolute", left: "50%", top: "50%", transform };
    };
    let rafId = null;
    let lastStep = 0;
    const inBounds = (p) => p.x >= 0 && p.y >= 0 && p.x < gridW && p.y < gridH;
    let frameIndex = 0;
    const nextStep = () => {
      const now = performance.now();
      if (now - lastStep < stepInterval) {
        rafId = requestAnimationFrame(nextStep);
        return;
      }
      lastStep = now;
      const hasTimeline = props.data.timelineFrames && props.data.timelineFrames.length > 0;
      if (hasTimeline) {
        const frames = props.data.timelineFrames;
        const f = frames[frameIndex % frames.length];
        const headSeg = f.body[0] || { x: 0, y: 0 };
        state.head = scalePos(headSeg);
        state.body = f.body.slice(1).map(scalePos);
        state.dir = { x: f.direction.x, y: f.direction.y };
        frameIndex = (frameIndex + 1) % frames.length;
      } else {
        const target = scaledFood.value;
        const dx = target.x - state.head.x;
        const dy = target.y - state.head.y;
        const step = { x: Math.sign(dx), y: Math.sign(dy) };
        const move = Math.abs(dx) >= Math.abs(dy) ? { x: step.x, y: 0 } : { x: 0, y: step.y };
        const newBody = [{ ...state.head }, ...state.body.slice(0, Math.max(0, state.body.length - 0))];
        state.body = newBody.slice(0, props.data.snakeBody.length - 1);
        const newHead = { x: state.head.x + move.x, y: state.head.y + move.y };
        state.dir = move;
        if (inBounds(newHead)) state.head = newHead;
        loopCounter.value++;
        const reached = state.head.x === target.x && state.head.y === target.y;
        if (reached || loopCounter.value >= maxSteps) {
          state.head = scalePos(props.data.snakeBody[0] || { x: 0, y: 0 });
          state.body = props.data.snakeBody.slice(1).map(scalePos);
          state.dir = { ...props.data.direction };
          loopCounter.value = 0;
        }
      }
      rafId = requestAnimationFrame(nextStep);
    };
    const loopCounter = ref(0);
    onMounted(() => {
      lastStep = performance.now();
      rafId = requestAnimationFrame(nextStep);
    });
    onUnmounted(() => {
      if (rafId) cancelAnimationFrame(rafId);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        createBaseVNode("div", _hoisted_2$3, [
          (openBlock(), createElementBlock(Fragment, null, renderList(totalCells, (i) => {
            return createBaseVNode("div", {
              key: i,
              class: normalizeClass(["w-2 h-2 transition-colors duration-300", baseCellClass(i - 1)])
            }, null, 2);
          }), 64))
        ]),
        createBaseVNode("div", _hoisted_3$2, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(renderBody.value, (seg, idx) => {
            return openBlock(), createElementBlock("div", {
              key: `seg-${idx}`,
              class: "w-2 h-2 rounded-sm bg-green-300 dark:bg-green-600",
              style: normalizeStyle(segmentStyle(seg, idx))
            }, null, 4);
          }), 128)),
          head.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "w-3 h-3 rounded-full bg-green-500 border border-green-300 animate-pulse",
            style: normalizeStyle(headStyle(head.value))
          }, [
            createBaseVNode("div", _hoisted_4$2, [
              createBaseVNode("div", {
                class: "w-1 h-1 bg-white rounded-full",
                style: normalizeStyle(directionDotStyle(currentDirection.value))
              }, null, 4)
            ])
          ], 4)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_5$1, [
          createBaseVNode("div", {
            class: normalizeClass(["w-3 h-3 rounded-full animate-ping", _ctx.data.wasCorrect ? "bg-emerald-400 dark:bg-emerald-500" : "bg-red-400 dark:bg-red-500"]),
            style: normalizeStyle(foodStyle(scaledFood.value))
          }, null, 6)
        ])
      ]);
    };
  }
});

const SnakeReplay = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-b407b167"]]);

const SnakeReplay$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: SnakeReplay
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$3 = { class: "mb-1" };
const _hoisted_2$2 = { class: "px-2 py-1 bg-purple-100 dark:bg-dark-bg-mute text-purple-800 dark:text-purple-300 text-xs font-medium rounded-full" };
const _hoisted_3$1 = { class: "text-lg sm:text-xl md:text-2xl xl:text-xl 2xl:text-2xl font-bold text-purple-900 dark:text-purple-300 mb-1 px-1 text-center" };
const _hoisted_4$1 = { class: "text-xs sm:text-sm xl:text-sm 2xl:text-sm text-gray-600 dark:text-white/70 mb-1 max-w-sm px-1 text-center" };
const _hoisted_5 = { class: "text-center mb-2" };
const _hoisted_6 = { class: "text-sm sm:text-base md:text-lg xl:text-base 2xl:text-lg text-gray-500 dark:text-white/70 break-words px-1" };
const _hoisted_7 = { class: "text-xs sm:text-sm text-gray-400 dark:text-white/60 mt-1" };
const _hoisted_8 = { class: "flex flex-wrap justify-center gap-1 sm:gap-1.5 mb-2 px-2 max-w-full" };
const _hoisted_9 = ["onUpdate:modelValue", "onInput", "onKeydown"];
const _hoisted_10 = {
  key: 1,
  class: "uppercase text-purple-700 dark:text-purple-300"
};
const _hoisted_11 = {
  key: 2,
  class: "uppercase text-yellow-600 dark:text-yellow-400"
};
const _hoisted_12 = {
  key: 1,
  class: "w-2 sm:w-3"
};
const _hoisted_13 = { class: "mb-0.5 xl:mb-0.5 2xl:mb-1" };
const _hoisted_14 = { class: "flex flex-wrap justify-center gap-2 px-1 mb-2" };
const _hoisted_15 = ["disabled"];
const _hoisted_16 = {
  key: 0,
  class: "px-1 text-center mt-0.5 xl:mt-0 2xl:mt-0.5 bg-gray-50 dark:bg-dark-bg-soft rounded py-1 xl:py-0.5 2xl:py-1"
};
const _hoisted_17 = {
  key: 0,
  class: "text-sm sm:text-base xl:text-base 2xl:text-lg font-bold text-green-600 dark:text-green-400 mb-0.5 xl:mb-0.5 2xl:mb-1"
};
const _hoisted_18 = {
  key: 1,
  class: "text-sm sm:text-base xl:text-base 2xl:text-lg font-bold text-red-600 dark:text-red-400 mb-0.5 xl:mb-0.5 2xl:mb-1"
};
const _hoisted_19 = { class: "space-y-0.5 xl:space-y-0 2xl:space-y-0.5 border-t border-gray-200 dark:border-dark-bg-mute pt-0.5 xl:pt-0 2xl:pt-0.5" };
const _hoisted_20 = { class: "text-sm xl:text-sm 2xl:text-base text-gray-700 dark:text-white/80" };
const _hoisted_21 = { class: "font-semibold" };
const _hoisted_22 = { class: "font-bold text-blue-600 dark:text-blue-400" };
const _hoisted_23 = { class: "text-sm xl:text-sm 2xl:text-base text-gray-700 dark:text-white/80" };
const _hoisted_24 = { class: "font-semibold" };
const _hoisted_25 = { class: "font-medium text-gray-900 dark:text-white" };
const maxHints = 2;
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "WordsCrushMode",
  props: {
    card: {},
    getTopicName: { type: Function }
  },
  emits: ["game-completed", "play-audio"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t } = useI18n();
    const wordSlots = ref([]);
    const gameCompleted = ref(false);
    const isCorrect = ref(false);
    const hintsUsed = ref(0);
    const letterInputs = ref([]);
    const createWordSlots = () => {
      if (!props.card?.word) return [];
      const word = props.card.word.toLowerCase();
      const slots = [];
      for (let i = 0; i < word.length; i++) {
        const char = word[i];
        if (char === " ") {
          slots.push({
            char: " ",
            separator: true,
            filled: false,
            userInput: "",
            correct: false,
            incorrect: false,
            revealed: false
          });
        } else {
          slots.push({
            char,
            separator: false,
            filled: false,
            userInput: "",
            correct: false,
            incorrect: false,
            revealed: false
          });
        }
      }
      const letterSlots = slots.filter((slot) => !slot.separator);
      const hideCount = Math.ceil(letterSlots.length * 0.5);
      const indicesToHide = [];
      while (indicesToHide.length < hideCount) {
        const randomIndex = Math.floor(Math.random() * letterSlots.length);
        const actualIndex = slots.findIndex((slot) => slot === letterSlots[randomIndex]);
        if (!indicesToHide.includes(actualIndex)) {
          indicesToHide.push(actualIndex);
        }
      }
      const shownLetterIndices = [];
      slots.forEach((slot, index) => {
        if (!slot.separator && !indicesToHide.includes(index)) {
          shownLetterIndices.push(index);
        }
      });
      const shownLetters = shownLetterIndices.map((index) => slots[index].char);
      const shuffledLetters = [...shownLetters].sort(() => Math.random() - 0.5);
      let shuffleIndex = 0;
      slots.forEach((slot, index) => {
        if (!slot.separator) {
          if (indicesToHide.includes(index)) ; else {
            slot.filled = true;
            slot.userInput = shuffledLetters[shuffleIndex];
            shuffleIndex++;
          }
        }
      });
      return slots;
    };
    const canCheckAnswer = computed(() => {
      return wordSlots.value.filter((slot) => !slot.separator && !slot.filled).every((slot) => slot.userInput.trim() !== "");
    });
    const initializeGame = () => {
      if (!props.card?.word) return;
      wordSlots.value = createWordSlots();
      gameCompleted.value = false;
      isCorrect.value = false;
      hintsUsed.value = 0;
      letterInputs.value = [];
    };
    const handleLetterInput = (index, event) => {
      const target = event.target;
      const value = target.value.toLowerCase();
      if (value && /^[a-zA-Z]$/.test(value)) {
        wordSlots.value[index].userInput = value;
        const nextEmptyIndex = wordSlots.value.findIndex(
          (slot, i) => i > index && !slot.separator && !slot.filled && slot.userInput === ""
        );
        if (nextEmptyIndex !== -1 && letterInputs.value[nextEmptyIndex]) {
          nextTick(() => {
            letterInputs.value[nextEmptyIndex].focus();
          });
        }
      } else if (value === "") {
        wordSlots.value[index].userInput = "";
      } else {
        target.value = "";
        wordSlots.value[index].userInput = "";
      }
    };
    const handleKeyDown = (index, event) => {
      if (event.key === "Backspace" && wordSlots.value[index].userInput === "") {
        const prevEmptyIndex = wordSlots.value.findIndex(
          (slot, i) => i < index && !slot.separator && !slot.filled
        );
        if (prevEmptyIndex !== -1) {
          const reversedIndex = [...wordSlots.value].reverse().findIndex((slot, i) => {
            const originalIndex = wordSlots.value.length - 1 - i;
            return originalIndex < index && !slot.separator && !slot.filled;
          });
          if (reversedIndex !== -1) {
            const actualIndex = wordSlots.value.length - 1 - reversedIndex;
            if (letterInputs.value[actualIndex]) {
              nextTick(() => {
                letterInputs.value[actualIndex].focus();
              });
            }
          }
        }
      } else if (event.key === "Enter") {
        checkAnswer();
      }
    };
    const checkAnswer = () => {
      if (!canCheckAnswer.value) return;
      let allCorrect = true;
      wordSlots.value.forEach((slot) => {
        if (!slot.separator && !slot.filled) {
          const isLetterCorrect = slot.userInput.toLowerCase() === slot.char.toLowerCase();
          slot.correct = isLetterCorrect;
          slot.incorrect = !isLetterCorrect;
          if (!isLetterCorrect) allCorrect = false;
        }
      });
      gameCompleted.value = true;
      isCorrect.value = allCorrect;
      emit("game-completed", allCorrect);
    };
    const revealHint = () => {
      if (hintsUsed.value >= maxHints) return;
      const emptySlots = wordSlots.value.filter((slot) => !slot.separator && !slot.filled && slot.userInput === "");
      if (emptySlots.length === 0) return;
      const randomSlot = emptySlots[Math.floor(Math.random() * emptySlots.length)];
      randomSlot.revealed = true;
      randomSlot.userInput = randomSlot.char;
      hintsUsed.value++;
    };
    const resetGame = () => {
      initializeGame();
    };
    const playPronunciation = () => {
      if (props.card?.word) {
        emit("play-audio", "vocabulary", props.card.word);
      }
    };
    onMounted(() => {
      initializeGame();
    });
    watch(() => props.card, () => {
      initializeGame();
    }, { deep: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "text-center w-full h-full flex flex-col justify-center items-center gap-1 sm:gap-2 p-2 sm:p-3 md:p-4 xl:p-3 2xl:p-4 overflow-hidden",
        onCopy: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["prevent"])),
        onCut: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onContextmenu: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createBaseVNode("div", _hoisted_1$3, [
          createBaseVNode("span", _hoisted_2$2, toDisplayString$1(_ctx.card?.category ? _ctx.getTopicName(_ctx.card.category) : ""), 1)
        ]),
        createBaseVNode("h2", _hoisted_3$1, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.title", "Words Crush: Anagram Challenge")), 1),
        createBaseVNode("p", _hoisted_4$1, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.instruction", "Fill in the missing letters to complete the word")), 1),
        createBaseVNode("div", _hoisted_5, [
          createBaseVNode("p", _hoisted_6, toDisplayString$1(_ctx.card?.pronunciation), 1),
          createBaseVNode("p", _hoisted_7, toDisplayString$1(_ctx.card?.meaning), 1)
        ]),
        createBaseVNode("div", _hoisted_8, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(wordSlots.value, (slot, index) => {
            return openBlock(), createElementBlock("div", {
              key: index,
              class: "relative"
            }, [
              !slot.separator ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(["w-8 h-8 sm:w-10 sm:h-10 md:w-12 md:h-12 xl:w-10 xl:h-10 2xl:w-11 2xl:h-11 border-2 border-purple-300 dark:border-purple-600 rounded-lg flex items-center justify-center text-sm sm:text-lg md:text-xl xl:text-lg 2xl:text-xl font-bold transition-all duration-200", {
                  "border-green-500 bg-green-50 dark:bg-green-900/20": slot.correct,
                  "border-red-500 bg-red-50 dark:bg-red-900/20": slot.incorrect,
                  "bg-white dark:bg-dark-bg": !slot.correct && !slot.incorrect && !slot.filled,
                  "bg-purple-50 dark:bg-purple-900/20 border-purple-500": slot.filled,
                  "bg-yellow-50 dark:bg-yellow-900/20 border-yellow-400": slot.revealed && !gameCompleted.value
                }])
              }, [
                !slot.filled && !slot.revealed ? withDirectives((openBlock(), createElementBlock("input", {
                  key: 0,
                  "onUpdate:modelValue": ($event) => slot.userInput = $event,
                  onInput: ($event) => handleLetterInput(index, $event),
                  onKeydown: ($event) => handleKeyDown(index, $event),
                  type: "text",
                  maxlength: "1",
                  class: "w-full h-full bg-transparent text-center text-sm sm:text-lg md:text-xl xl:text-lg 2xl:text-xl font-bold uppercase border-none outline-none text-gray-900 dark:text-white placeholder-gray-400 dark:placeholder-gray-500",
                  ref_for: true,
                  ref: "letterInput",
                  placeholder: "?"
                }, null, 40, _hoisted_9)), [
                  [vModelText, slot.userInput]
                ]) : slot.filled ? (openBlock(), createElementBlock("span", _hoisted_10, toDisplayString$1(slot.char), 1)) : (openBlock(), createElementBlock("span", _hoisted_11, toDisplayString$1(slot.char), 1))
              ], 2)) : (openBlock(), createElementBlock("div", _hoisted_12))
            ]);
          }), 128))
        ]),
        createBaseVNode("div", _hoisted_13, [
          createBaseVNode("button", {
            onClick: playPronunciation,
            class: "px-2 py-0.5 md:px-3 md:py-1 xl:px-3 xl:py-1 2xl:px-3 2xl:py-1 text-xs sm:text-sm xl:text-sm 2xl:text-sm bg-blue-600 hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800 text-white rounded font-medium transition-colors flex items-center gap-1"
          }, [
            _cache[3] || (_cache[3] = createBaseVNode("svg", {
              class: "w-3 h-3 xl:w-3 xl:h-3 2xl:w-3 2xl:h-3",
              fill: "currentColor",
              viewBox: "0 0 20 20"
            }, [
              createBaseVNode("path", {
                "fill-rule": "evenodd",
                d: "M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.773l-4.146-3.382a.5.5 0 00-.319-.118H2a1 1 0 01-1-1V8a1 1 0 011-1h1.918a.5.5 0 00.319-.118l4.146-3.382zM14 5a1 1 0 011 1v8a1 1 0 11-2 0V6a1 1 0 011-1zm2.025 1.13a1 1 0 011.414.057 7 7 0 010 9.816 1 1 0 11-1.471-1.358 5 5 0 000-7.1 1 1 0 01.057-1.415zM16.5 8.5a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1z",
                "clip-rule": "evenodd"
              })
            ], -1)),
            createTextVNode(" " + toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.playSound", "Play Sound")), 1)
          ])
        ]),
        createBaseVNode("div", _hoisted_14, [
          !gameCompleted.value ? (openBlock(), createElementBlock("button", {
            key: 0,
            onClick: checkAnswer,
            disabled: !canCheckAnswer.value,
            class: "px-3 py-1.5 text-sm bg-gradient-to-r from-purple-600 to-purple-700 hover:from-purple-700 hover:to-purple-800 text-white rounded-lg font-medium transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed shadow-lg"
          }, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.checkAnswer", "Check Answer")), 9, _hoisted_15)) : createCommentVNode("", true),
          !gameCompleted.value && hintsUsed.value < maxHints ? (openBlock(), createElementBlock("button", {
            key: 1,
            onClick: revealHint,
            class: "px-3 py-1.5 text-sm bg-gradient-to-r from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700 text-white rounded-lg font-medium transition-all duration-200 shadow-lg"
          }, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.hint", "Hint")) + " (" + toDisplayString$1(hintsUsed.value) + "/" + toDisplayString$1(maxHints) + ") ", 1)) : createCommentVNode("", true),
          createBaseVNode("button", {
            onClick: resetGame,
            class: "px-3 py-1.5 text-sm bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white rounded-lg font-medium transition-all duration-200 shadow-lg"
          }, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.reset", "Reset")), 1)
        ]),
        gameCompleted.value ? (openBlock(), createElementBlock("div", _hoisted_16, [
          isCorrect.value ? (openBlock(), createElementBlock("p", _hoisted_17, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.correct", " Correct!")), 1)) : (openBlock(), createElementBlock("p", _hoisted_18, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.tryAgain", "Try Again!")), 1)),
          createBaseVNode("div", _hoisted_19, [
            createBaseVNode("p", _hoisted_20, [
              createBaseVNode("span", _hoisted_21, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.correctWord", "Word")) + ":", 1),
              createBaseVNode("span", _hoisted_22, toDisplayString$1(_ctx.card?.word), 1)
            ]),
            createBaseVNode("p", _hoisted_23, [
              createBaseVNode("span", _hoisted_24, toDisplayString$1(unref(t)("flashcard.pronunciation.wordsCrush.meaning", "Meaning")) + ":", 1),
              createBaseVNode("span", _hoisted_25, toDisplayString$1(_ctx.card?.meaning), 1)
            ])
          ])
        ])) : createCommentVNode("", true)
      ], 32);
    };
  }
});

const WordsCrushMode = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-b9d619f0"]]);

const WordsCrushMode$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: WordsCrushMode
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$2 = ["aria-label"];
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "VocabularyNoteButton",
  props: {
    date: {},
    isToday: { type: Boolean }
  },
  emits: ["open-note-dialog"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const props = __props;
    const emit = __emit;
    const openNoteDialog = () => {
      emit("open-note-dialog", props.date);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        onClick: openNoteDialog,
        class: "flex items-center space-x-1 md:space-x-1.5 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 text-xs md:text-sm lg:text-base xl:text-sm 2xl:text-base font-medium text-green-600 dark:text-green-400 hover:text-green-800 dark:hover:text-green-200 hover:bg-green-50 dark:hover:bg-green-900/50 rounded-full border border-dashed border-green-300 dark:border-green-600 hover:border-green-400 dark:hover:border-green-500 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500",
        "aria-label": unref(t)("vocabulary.notes.manageNotes", "Manage Notes")
      }, [
        _cache[0] || (_cache[0] = createBaseVNode("svg", {
          class: "w-3 md:w-4 lg:w-4 xl:w-5 xl:h-5 2xl:w-6 2xl:h-6 h-3 md:h-4 lg:h-4",
          fill: "currentColor",
          viewBox: "0 0 20 20"
        }, [
          createBaseVNode("path", { d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" })
        ], -1)),
        createBaseVNode("span", null, toDisplayString$1(unref(t)("vocabulary.notes.manageNotes", "Manage Notes")), 1)
      ], 8, _hoisted_1$2);
    };
  }
});

const VocabularyNoteButton = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$2
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$1 = ["aria-label"];
const _hoisted_2$1 = { class: "hidden xs:inline" };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "GrammarManagerButton",
  props: {
    date: {}
  },
  emits: ["openGrammarManager"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const props = __props;
    const emit = __emit;
    const openGrammarManager = () => {
      emit("openGrammarManager", props.date);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        onClick: openGrammarManager,
        class: "flex items-center space-x-1 md:space-x-1.5 px-2 xs:px-2.5 sm:px-3 md:px-4 py-0.5 xs:py-1 sm:py-1 md:py-1.5 text-xs md:text-sm lg:text-base xl:text-sm 2xl:text-base font-medium text-purple-600 dark:text-purple-400 hover:text-purple-800 dark:hover:text-purple-200 hover:bg-purple-50 dark:hover:bg-purple-900/50 rounded-full border border-dashed border-purple-300 dark:border-purple-600 hover:border-purple-400 dark:hover:border-purple-500 transition-colors focus:outline-none focus:ring-2 focus:ring-purple-500",
        "aria-label": unref(t)("grammar.manager.manageGrammar", "Manage Grammar")
      }, [
        _cache[0] || (_cache[0] = createBaseVNode("svg", {
          class: "w-3 md:w-4 lg:w-4 xl:w-5 xl:h-5 2xl:w-6 2xl:h-6 h-3 md:h-4 lg:h-4",
          fill: "none",
          stroke: "currentColor",
          viewBox: "0 0 24 24"
        }, [
          createBaseVNode("path", {
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            "stroke-width": "2",
            d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
          })
        ], -1)),
        createBaseVNode("span", _hoisted_2$1, toDisplayString$1(unref(t)("grammar.manager.manageGrammar", "Manage Grammar")), 1)
      ], 8, _hoisted_1$1);
    };
  }
});

const GrammarManagerButton = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: _sfc_main$1
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1 = { class: "relative inline-flex items-center justify-center" };
const _hoisted_2 = ["width", "height", "viewBox"];
const _hoisted_3 = ["cx", "cy", "r", "stroke-width"];
const _hoisted_4 = ["cx", "cy", "r", "stroke-width", "stroke-dasharray", "stroke-dashoffset"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "CircularProgress",
  props: {
    percentage: { default: 0 },
    size: { default: 48 },
    strokeWidth: { default: 4 },
    color: { default: "" },
    showText: { type: Boolean, default: true },
    customText: { default: "" }
  },
  setup(__props) {
    const props = __props;
    const radius = computed(() => (props.size - props.strokeWidth) / 2);
    const circumference = computed(() => radius.value * 2 * Math.PI);
    const strokeDashoffset = computed(() => {
      const progress = Math.min(Math.max(props.percentage, 0), 100);
      return circumference.value - progress / 100 * circumference.value;
    });
    const progressColor = computed(() => {
      if (props.color) return props.color;
      if (props.percentage >= 100) {
        return "text-green-500 dark:text-green-400";
      } else if (props.percentage >= 70) {
        return "text-blue-500 dark:text-blue-400";
      } else if (props.percentage >= 40) {
        return "text-yellow-500 dark:text-yellow-400";
      } else {
        return "text-orange-500 dark:text-orange-400";
      }
    });
    const textColor = computed(() => {
      if (props.percentage >= 100) {
        return "text-green-600 dark:text-green-300";
      } else if (props.percentage >= 70) {
        return "text-blue-600 dark:text-blue-300";
      } else if (props.percentage >= 40) {
        return "text-yellow-600 dark:text-yellow-300";
      } else {
        return "text-orange-600 dark:text-orange-300";
      }
    });
    const textSizeClass = computed(() => {
      if (props.size <= 32) {
        return "text-xs";
      } else if (props.size <= 48) {
        return "text-sm";
      } else if (props.size <= 64) {
        return "text-base";
      } else {
        return "text-lg";
      }
    });
    const displayValue = computed(() => {
      if (props.customText) {
        return props.customText;
      }
      if (!props.showText) {
        return "";
      }
      return `${Math.round(props.percentage)}%`;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        (openBlock(), createElementBlock("svg", {
          width: _ctx.size,
          height: _ctx.size,
          class: "transform -rotate-90",
          viewBox: `0 0 ${_ctx.size} ${_ctx.size}`
        }, [
          createBaseVNode("circle", {
            cx: _ctx.size / 2,
            cy: _ctx.size / 2,
            r: radius.value,
            stroke: "currentColor",
            "stroke-width": _ctx.strokeWidth,
            fill: "transparent",
            class: "text-gray-200 dark:text-dark-bg-mute opacity-50"
          }, null, 8, _hoisted_3),
          createBaseVNode("circle", {
            cx: _ctx.size / 2,
            cy: _ctx.size / 2,
            r: radius.value,
            stroke: "currentColor",
            "stroke-width": _ctx.strokeWidth,
            fill: "transparent",
            "stroke-dasharray": circumference.value,
            "stroke-dashoffset": strokeDashoffset.value,
            class: normalizeClass([progressColor.value, "transition-all duration-500 ease-in-out"]),
            "stroke-linecap": "round"
          }, null, 10, _hoisted_4)
        ], 8, _hoisted_2)),
        createBaseVNode("div", {
          class: normalizeClass(["absolute inset-0 flex items-center justify-center z-10", textSizeClass.value])
        }, [
          createBaseVNode("span", {
            class: normalizeClass(["font-bold transition-colors duration-300 bg-white dark:bg-dark-bg rounded-full px-0.5 py-0.5 shadow-sm", textColor.value]),
            style: { "line-height": "1" }
          }, toDisplayString$1(displayValue.value), 3)
        ], 2)
      ]);
    };
  }
});

const CircularProgress = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-938779d2"]]);

const CircularProgress$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: CircularProgress
}, Symbol.toStringTag, { value: 'Module' }));
