{"version":3,"file":"BubbleShooterMode-CKr44QqY.js","sources":["../../src/views/practice/composables/bubble-shooter/useGameStateManager.ts","../../src/views/practice/composables/bubble-shooter/usePhysicsEngine.ts","../../src/views/practice/composables/bubble-shooter/useVisualEffects.ts","../../src/views/practice/composables/bubble-shooter/useCanvasRenderer.ts","../../src/views/practice/composables/bubble-shooter/useInputHandler.ts","../../src/views/practice/composables/bubble-shooter/useGameLogic.ts","../../src/views/practice/composables/bubble-shooter/useBubbleShooterGame.ts","../../src/views/practice/components/BubbleShooterMode.vue"],"sourcesContent":["import { ref, type Ref } from 'vue'\nimport type { \n  IGameStateManager, \n  Bubble, \n  Explosion, \n  Particle, \n  ScreenShake, \n  AimLine, \n  Position \n} from './interfaces'\nimport type { Vocabulary } from '@/composables/useVocabularyStore'\n\nexport class GameStateManager implements IGameStateManager {\n  // Game State\n  public readonly score: Ref<number> = ref(0)\n  public readonly wordsMatched: Ref<number> = ref(0)\n  public readonly gameOver: Ref<boolean> = ref(false)\n  public readonly bubbles: Ref<Bubble[]> = ref([])\n  public readonly shootingBubble: Ref<Bubble | null> = ref(null)\n  public readonly currentShooterWord: Ref<string> = ref('')\n  public readonly currentShooterColor: Ref<string> = ref('#FF6B6B')\n  public readonly explosions: Ref<Explosion[]> = ref([])\n  public readonly particles: Ref<Particle[]> = ref([])\n  public readonly screenShake: Ref<ScreenShake> = ref({ x: 0, y: 0, intensity: 0 })\n  public readonly aimLine: Ref<AimLine> = ref({ visible: false, x: 0, y: 0 })\n  public readonly shooterPosition: Ref<Position> = ref({ x: 400, y: 550 })\n  public readonly rowAnimationActive: Ref<boolean> = ref(false)\n\n  // Private state for color mapping\n  private readonly wordColorMap = new Map<string, string>()\n  private readonly COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#FFB347']\n\n  // Game Management Methods\n  public resetGame(): void {\n    this.score.value = 0\n    this.wordsMatched.value = 0\n    this.gameOver.value = false\n    this.bubbles.value = []\n    this.shootingBubble.value = null\n    this.explosions.value = []\n    this.particles.value = []\n    this.screenShake.value = { x: 0, y: 0, intensity: 0 }\n    this.aimLine.value = { visible: false, x: 0, y: 0 }\n    this.currentShooterWord.value = ''\n    this.currentShooterColor.value = '#FF6B6B'\n  }\n\n  public updateScore(points: number): void {\n    this.score.value += points\n  }\n\n  public incrementWordsMatched(): void {\n    this.wordsMatched.value += 1\n  }\n\n  public setGameOver(gameOver: boolean): void {\n    this.gameOver.value = gameOver\n  }\n\n  public setRowAnimationActive(active: boolean): void {\n    this.rowAnimationActive.value = active\n  }\n\n  // Bubble Management\n  public addBubble(bubble: Bubble): void {\n    this.bubbles.value.push(bubble)\n  }\n\n  public removeBubbles(bubbleIds: string[]): void {\n    this.bubbles.value = this.bubbles.value.filter(\n      bubble => !bubbleIds.includes(bubble.id)\n    )\n  }\n\n  public setShootingBubble(bubble: Bubble | null): void {\n    this.shootingBubble.value = bubble\n  }\n\n  public selectNextShooterWord(words: Vocabulary[]): void {\n    if (words.length > 0) {\n      const randomWord = words[Math.floor(Math.random() * words.length)]\n      this.currentShooterWord.value = randomWord.word\n      this.currentShooterColor.value = this.getColorForWord(randomWord.word)\n    }\n  }\n\n  // Visual Effects Management\n  public updateAimLine(position: Position | null): void {\n    if (position) {\n      this.aimLine.value = {\n        visible: true,\n        x: position.x,\n        y: position.y\n      }\n    } else {\n      this.aimLine.value.visible = false\n    }\n  }\n\n  public addExplosion(explosion: Explosion): void {\n    this.explosions.value.push(explosion)\n  }\n\n  public updateExplosions(): void {\n    this.explosions.value.forEach(explosion => {\n      if (!explosion.active) return\n      \n      // Update shockwave\n      if (explosion.shockwave.radius < explosion.shockwave.maxRadius) {\n        explosion.shockwave.radius += 2\n        explosion.shockwave.intensity = Math.max(0, 1 - (explosion.shockwave.radius / explosion.shockwave.maxRadius))\n      }\n      \n      let activeParticles = 0\n      explosion.particles.forEach(particle => {\n        if (particle.life > 0) {\n          // Update particle position\n          particle.x += particle.vx\n          particle.y += particle.vy\n          \n          // Update rotation\n          particle.rotation += particle.rotationSpeed\n          \n          // Apply different physics based on particle type\n          switch (particle.type) {\n            case 'burst':\n              particle.vy += 0.15 // More gravity\n              particle.vx *= 0.96 // More friction\n              particle.vy *= 0.96\n              particle.life -= 0.025\n              break\n            case 'spark':\n              particle.vy += 0.05 // Less gravity\n              particle.vx *= 0.99 // Less friction\n              particle.vy *= 0.99\n              particle.life -= 0.04 // Faster decay\n              break\n            case 'glow':\n              particle.vy += 0.08 // Medium gravity\n              particle.vx *= 0.97\n              particle.vy *= 0.97\n              particle.life -= 0.015 // Slower decay\n              break\n          }\n          \n          activeParticles++\n        }\n      })\n      \n      // Deactivate explosion when all particles are dead and shockwave is done\n      if (activeParticles === 0 && explosion.shockwave.radius >= explosion.shockwave.maxRadius) {\n        explosion.active = false\n      }\n    })\n    \n    // Update screen shake\n    this.updateScreenShake()\n    \n    // Remove inactive explosions\n    this.explosions.value = this.explosions.value.filter(explosion => explosion.active)\n  }\n\n  // Screen Shake Management\n  public addScreenShake(intensity: number): void {\n    this.screenShake.value.intensity = Math.max(this.screenShake.value.intensity, intensity)\n  }\n\n  public updateScreenShake(): void {\n    if (this.screenShake.value.intensity > 0) {\n      this.screenShake.value.x = (Math.random() - 0.5) * this.screenShake.value.intensity\n      this.screenShake.value.y = (Math.random() - 0.5) * this.screenShake.value.intensity\n      this.screenShake.value.intensity *= 0.9 // Decay\n      \n      if (this.screenShake.value.intensity < 0.1) {\n        this.screenShake.value.intensity = 0\n        this.screenShake.value.x = 0\n        this.screenShake.value.y = 0\n      }\n    }\n  }\n\n  // Private helper method for color mapping\n  private getColorForWord(word: string): string {\n    if (!this.wordColorMap.has(word)) {\n      // Assign a consistent color based on word hash to avoid random changes\n      let hash = 0\n      for (let i = 0; i < word.length; i++) {\n        hash = ((hash << 5) - hash + word.charCodeAt(i)) & 0xffffffff\n      }\n      const colorIndex = Math.abs(hash) % this.COLORS.length\n      this.wordColorMap.set(word, this.COLORS[colorIndex])\n    }\n    return this.wordColorMap.get(word)!\n  }\n}\n\nexport const useGameStateManager = (): IGameStateManager => {\n  return new GameStateManager()\n}\n","import type { IPhysicsEngine, IGameStateManager, Bubble } from './interfaces'\n\nexport class PhysicsEngine implements IPhysicsEngine {\n  public readonly BUBBLE_SIZE = 40\n  public readonly COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#FFB347']\n  // Small epsilon to treat tiny gaps as contact to avoid visible spacing\n  public readonly CONTACT_EPS = 8\n\n  private readonly wordColorMap = new Map<string, string>()\n  private stateManager?: IGameStateManager\n\n  constructor(stateManager?: IGameStateManager) {\n    this.stateManager = stateManager\n  }\n  \n  public getColorForWord(word: string): string {\n    if (!this.wordColorMap.has(word)) {\n      // Assign a consistent color based on word hash to avoid random changes\n      let hash = 0\n      for (let i = 0; i < word.length; i++) {\n        hash = ((hash << 5) - hash + word.charCodeAt(i)) & 0xffffffff\n      }\n      const colorIndex = Math.abs(hash) % this.COLORS.length\n      this.wordColorMap.set(word, this.COLORS[colorIndex])\n    }\n    return this.wordColorMap.get(word)!\n  }\n\n  public checkCollision(bubble1: Bubble, bubble2: Bubble): boolean {\n    const dx = bubble2.x - bubble1.x\n    const dy = bubble2.y - bubble1.y\n    const distance = Math.sqrt(dx * dx + dy * dy)\n    // Collision threshold at exactly one diameter - perfect tangency\n    return distance <= this.BUBBLE_SIZE\n  }\n\n  public animateShootingBubble(\n    bubble: Bubble,\n    vx: number,\n    vy: number,\n    onLand: (bubble: Bubble) => void,\n    existingBubbles?: Bubble[],\n    canvasWidth: number = 800,\n    canvasHeight: number = 600\n  ): void {\n    let bounceCount = 0\n    const maxBounces = 3\n    let currentVx = vx\n    let currentVy = vy\n    \n    const animate = () => {\n      bubble.x += currentVx\n      bubble.y += currentVy\n      \n      // CRITICAL FIX: Check collision with existing bubbles FIRST\n      if (existingBubbles) {\n        for (const existing of existingBubbles) {\n          // Use stable positions during animation for collision detection.\n          // SPECIAL CASE: for the newly inserted row (row < 0) while animating,\n          // use its final settled Y so shots interact with the row as if already at the ceiling line.\n          const isAnimating = this.stateManager?.rowAnimationActive.value\n          const isNewRow = isAnimating && (existing.row ?? 0) < 0\n          const existingX = isNewRow\n            ? existing.x\n            : (isAnimating && existing.stableX !== undefined ? existing.stableX : existing.x)\n          const existingY = isNewRow\n            ? this.BUBBLE_SIZE / 2\n            : (isAnimating && existing.stableY !== undefined ? existing.stableY : existing.y)\n          \n          // Compute distance and detect collision or near-contact when approaching/slow\n          const dx0 = bubble.x - existingX\n          const dy0 = bubble.y - existingY\n          const dist0 = Math.sqrt(dx0 * dx0 + dy0 * dy0)\n          // Near-contact detection - reduce threshold to avoid false collision with new rows\n          const nearThreshold = this.BUBBLE_SIZE + this.CONTACT_EPS\n\n          // Only consider near-contact if we are APPROACHING the existing bubble\n          const approaching = (dx0 * currentVx + dy0 * currentVy) <= 0\n\n          if (dist0 <= nearThreshold && approaching) {\n            console.log('Collision/near-contact detected! Computing tangent and triple-contact placement')\n\n            // Step 1: Find exact tangent direction relative to the collided bubble\n            let dx = dx0\n            let dy = dy0\n            let dist = dist0\n\n            if (dist < 0.01) {\n              // Use velocity direction for separation\n              dx = -currentVx || 0\n              dy = -currentVy || -1\n              const norm = Math.sqrt(dx * dx + dy * dy) || 1\n              dx /= norm\n              dy /= norm\n            } else {\n              dx /= dist\n              dy /= dist\n            }\n\n            // Step 2: Calculate perfect tangent position (centers one diameter apart)\n            // Use stable position for tangent calculation during animation\n            const tangentX = existingX + dx * this.BUBBLE_SIZE\n            const tangentY = existingY + dy * this.BUBBLE_SIZE\n\n            // Step 3: Use simple tangent position for now (disable triple-contact to fix grid alignment)\n            bubble.x = tangentX\n            bubble.y = tangentY\n\n            // Always snap to proper hex grid position after collision\n            if (existingBubbles) {\n              this.snapToGrid(bubble, existingBubbles)\n              // Force exact hex grid position to ensure proper alignment and avoid occupied seats\n              this.forceToNearestFreeSeat(bubble, existingBubbles, canvasWidth, canvasHeight)\n            } else {\n              const verticalSpacing = (this.BUBBLE_SIZE * Math.sqrt(3)) / 2\n              const baseX = this.BUBBLE_SIZE / 2\n              const baseY = this.BUBBLE_SIZE / 2\n              bubble.row = Math.max(0, Math.round((bubble.y - baseY) / verticalSpacing))\n              bubble.col = Math.max(0, Math.round((bubble.x - baseX) / this.BUBBLE_SIZE))\n            }\n\n            // Stop all movement to prevent sliding\n            currentVx = 0\n            currentVy = 0\n            \n            onLand(bubble)\n            return\n          }\n        }\n      }\n      \n      // Enhanced wall collision with bounce effect - FIXED: Use dynamic canvas dimensions\n      if (bubble.x <= this.BUBBLE_SIZE / 2 || bubble.x >= canvasWidth - this.BUBBLE_SIZE / 2) {\n        currentVx = -currentVx * 0.8 // Energy loss on bounce\n        bounceCount++\n        \n        // Clamp position to prevent getting stuck in walls - FIXED: Use dynamic canvas width\n        bubble.x = Math.max(this.BUBBLE_SIZE / 2, Math.min(canvasWidth - this.BUBBLE_SIZE / 2, bubble.x))\n      }\n      \n      // Top boundary - bubble sticks immediately (no bounce) with proper grid positioning\n      if (bubble.y <= this.BUBBLE_SIZE / 2) {\n        bubble.y = this.BUBBLE_SIZE / 2\n        \n        // ALWAYS snap to exact grid position for top row to ensure even spacing\n        const baseX = this.BUBBLE_SIZE / 2\n        const targetCol = Math.round((bubble.x - baseX) / this.BUBBLE_SIZE)\n        bubble.x = baseX + targetCol * this.BUBBLE_SIZE\n        bubble.row = 0\n        bubble.col = Math.max(0, targetCol)\n        \n        currentVy = 0\n        bounceCount = maxBounces // Force bubble to land\n      }\n      \n      // Bottom boundary check - prevent bubble from escaping - FIXED: Use dynamic canvas height\n      if (bubble.y >= canvasHeight - this.BUBBLE_SIZE / 2) {\n        // Force bubble to stick at bottom\n        bubble.y = canvasHeight - this.BUBBLE_SIZE / 2\n        currentVy = 0\n        bounceCount = maxBounces // Force stop\n      }\n      \n      // Remove problematic gravity - causes bubbles to bounce downward\n      // Only apply minimal gravity if bubble is falling freely (not after wall bounce)\n      if (bounceCount > 0 && currentVy > 2) {\n        currentVy += 0.05 // Much reduced gravity, only when already falling fast\n      }\n      \n      // Check if bubble should stick to walls (more aggressive sticking) - FIXED: Use dynamic canvas dimensions\n      const slowMoving = Math.abs(currentVx) < 3 && Math.abs(currentVy) < 3\n      const nearLeftWall = bubble.x <= this.BUBBLE_SIZE / 2 + 20\n      const nearRightWall = bubble.x >= canvasWidth - this.BUBBLE_SIZE / 2 - 20\n      const nearTopWall = bubble.y <= this.BUBBLE_SIZE / 2 + 20\n      const stickToWall = bounceCount > 0 && (\n        (slowMoving && (nearLeftWall || nearRightWall)) || \n        (nearTopWall && Math.abs(currentVy) < 2)\n      )\n      \n      if ((bubble.y <= this.BUBBLE_SIZE / 2 && currentVy <= 0) || bounceCount >= maxBounces || stickToWall) {\n        // Before finalizing landing, if we're near any existing bubble, snap to tangency (and try triple-contact)\n        if (existingBubbles && existingBubbles.length > 0) {\n          const captureRadius = this.BUBBLE_SIZE + this.CONTACT_EPS // capture near-miss seats consistently\n          let nearest: Bubble | null = null\n          let bestDist = Number.POSITIVE_INFINITY\n          for (const b of existingBubbles) {\n            const isAnimating = this.stateManager?.rowAnimationActive.value\n            const isNewRow = isAnimating && (b.row ?? 0) < 0\n            const bx = isNewRow ? b.x : (isAnimating && b.stableX !== undefined ? b.stableX : b.x)\n            const by = isNewRow ? this.BUBBLE_SIZE / 2 : (isAnimating && b.stableY !== undefined ? b.stableY : b.y)\n            const dx = bubble.x - bx\n            const dy = bubble.y - by\n            const d = Math.sqrt(dx * dx + dy * dy)\n            // Only capture if approaching this bubble (avoid grabbing moving/retreating targets)\n            const dot = dx * currentVx + dy * currentVy\n            if (dot > 0) continue\n            if (d < captureRadius && d < bestDist) {\n              nearest = b\n              bestDist = d\n            }\n          }\n\n          if (nearest) {\n            // Compute tangent point relative to the nearest bubble\n            const isAnimating2 = this.stateManager?.rowAnimationActive.value\n            const isNewRow2 = isAnimating2 && (nearest.row ?? 0) < 0\n            const nx = isNewRow2 ? nearest.x : (isAnimating2 && nearest.stableX !== undefined ? nearest.stableX : nearest.x)\n            const ny = isNewRow2 ? this.BUBBLE_SIZE / 2 : (isAnimating2 && nearest.stableY !== undefined ? nearest.stableY : nearest.y)\n            let ndx = bubble.x - nx\n            let ndy = bubble.y - ny\n            const nlen = Math.sqrt(ndx * ndx + ndy * ndy) || 1\n            ndx /= nlen\n            ndy /= nlen\n            const tangentX = nx + ndx * this.BUBBLE_SIZE\n            const tangentY = ny + ndy * this.BUBBLE_SIZE\n\n            // Try triple-contact slide using the nearest as the collided reference\n            const triple = this.findTripleContactPosition(\n              nearest,\n              existingBubbles,\n              { x: tangentX, y: tangentY },\n              canvasWidth,\n              canvasHeight\n            )\n            const finalX = triple ? triple.x : tangentX\n            const finalY = triple ? triple.y : tangentY\n\n            bubble.x = finalX\n            bubble.y = finalY\n            this.snapToGrid(bubble, existingBubbles)\n            // Force exact hex grid position to ensure proper alignment and avoid occupied seats\n            this.forceToNearestFreeSeat(bubble, existingBubbles, canvasWidth, canvasHeight)\n            \n            onLand(bubble)\n            return\n          }\n        }\n\n        // Bubble has landed - trigger callback\n        onLand(bubble)\n        return\n      }\n      \n      requestAnimationFrame(animate)\n    }\n    animate()\n  }\n\n  // Attempt to find a position where the new bubble touches the collided bubble\n  // and one of its neighbors simultaneously (triple-contact). Returns null if none valid.\n  private findTripleContactPosition(\n    collided: Bubble,\n    existingBubbles: Bubble[],\n    tangentPoint: { x: number; y: number },\n    canvasWidth: number,\n    canvasHeight: number\n  ): { x: number; y: number } | null {\n    const R = this.BUBBLE_SIZE // We use center-to-center distance equal to diameter for tangency\n    const rWall = this.BUBBLE_SIZE / 2\n\n    // Helper: circle-circle intersections where both radii are R\n    const intersections = (ax: number, ay: number, bx: number, by: number): { x: number; y: number }[] => {\n      const dx = bx - ax\n      const dy = by - ay\n      const d = Math.sqrt(dx * dx + dy * dy)\n      if (d < 1e-6 || d > 2 * R) return []\n      const a = d / 2\n      const h2 = R * R - a * a\n      if (h2 < -1e-6) return []\n      const h = h2 > 0 ? Math.sqrt(Math.max(0, h2)) : 0\n      const mx = ax + (a * dx) / d\n      const my = ay + (a * dy) / d\n      const rx = (-dy * h) / d\n      const ry = (dx * h) / d\n      return [\n        { x: mx + rx, y: my + ry },\n        { x: mx - rx, y: my - ry },\n      ]\n    }\n\n    // Helper: within canvas bounds considering radius\n    const inBounds = (x: number, y: number) => (\n      x >= rWall && x <= canvasWidth - rWall && y >= rWall && y <= canvasHeight - rWall\n    )\n\n    // Helper: ensure no overlap with other bubbles (allow exact tangency)\n    const positionFree = (x: number, y: number) => {\n      for (const b of existingBubbles) {\n        const dx = b.x - x\n        const dy = b.y - y\n        const d = Math.sqrt(dx * dx + dy * dy)\n        if (d < this.BUBBLE_SIZE - 0.1) return false\n      }\n      return true\n    }\n\n    // Consider neighbors of the collided bubble (those close to one diameter)\n    const neighbors = existingBubbles.filter(b => b !== collided).filter(b => {\n      const dx = b.x - collided.x\n      const dy = b.y - collided.y\n      const d = Math.sqrt(dx * dx + dy * dy)\n      return d > 0.5 * this.BUBBLE_SIZE && d < 1.5 * this.BUBBLE_SIZE\n    })\n\n    let best: { x: number; y: number } | null = null\n    let bestScore = Number.POSITIVE_INFINITY\n\n    for (const nb of neighbors) {\n      const pts = intersections(collided.x, collided.y, nb.x, nb.y)\n      for (const p of pts) {\n        if (!inBounds(p.x, p.y)) continue\n        if (!positionFree(p.x, p.y)) continue\n        // Score by proximity to tangent point (simulate sliding to nearest seat)\n        const dx = p.x - tangentPoint.x\n        const dy = p.y - tangentPoint.y\n        const score = dx * dx + dy * dy\n        if (score < bestScore) {\n          best = p\n          bestScore = score\n        }\n      }\n    }\n\n    return best\n  }\n\n  // Quantize the dynamic baseY to the nearest valid grid line to stabilize row/column mapping\n  private getQuantizedBaseY(existingBubbles: Bubble[]): number {\n    if (!existingBubbles || existingBubbles.length === 0) return this.BUBBLE_SIZE / 2\n    const verticalSpacing = (this.BUBBLE_SIZE * Math.sqrt(3)) / 2\n    const baseRef = this.BUBBLE_SIZE / 2\n    \n    // CRITICAL FIX: Check if row animation is active\n    const isAnimating = this.stateManager?.rowAnimationActive.value\n    \n    if (isAnimating) {\n      // During animation: Use the stable reference Y position of row 0 bubbles\n      // Filter out new row bubbles (negative row numbers) to get stable grid reference\n      const stableRowBubbles = existingBubbles.filter(b => (b.row ?? 0) >= 0)\n      if (stableRowBubbles.length === 0) return baseRef\n      \n      // Use the minimum actual row number (not animated position)\n      const minRow = Math.min(...stableRowBubbles.map(b => b.row ?? 0))\n      const quantized = baseRef + minRow * verticalSpacing\n      \n      console.log('getQuantizedBaseY (ANIMATION): minRow =', minRow, 'quantized baseY =', quantized)\n      return quantized\n    } else {\n      // Normal operation: Use row-based calculation\n      const minRow = Math.min(...existingBubbles.map(b => b.row ?? 0))\n      const quantized = baseRef + minRow * verticalSpacing\n      \n      console.log('getQuantizedBaseY (NORMAL): minRow =', minRow, 'quantized baseY =', quantized)\n      return quantized\n    }\n  }\n\n  // Compute the pixel center for a given grid seat (row, col)\n  private getSeatCenter(row: number, col: number, existingBubbles: Bubble[]): { x: number; y: number } {\n    const verticalSpacing = (this.BUBBLE_SIZE * Math.sqrt(3)) / 2\n    const baseX = this.BUBBLE_SIZE / 2\n    const baseY = this.getQuantizedBaseY(existingBubbles)\n    const topOffset = this.getTopRowOffset(existingBubbles)\n    const rowOffset = row % 2 === 0 ? topOffset : (topOffset === 0 ? this.BUBBLE_SIZE / 2 : 0)\n    const x = baseX + rowOffset + col * this.BUBBLE_SIZE\n    const y = baseY + row * verticalSpacing\n    return { x, y }\n  }\n\n  // Infer the current top-row horizontal offset (0 or B/2) from existing row-0 bubbles\n  // Uses stableX during row animation to avoid drift.\n  private getTopRowOffset(existingBubbles: Bubble[]): number {\n    const B = this.BUBBLE_SIZE\n    const baseX = B / 2\n    const isAnimating = this.stateManager?.rowAnimationActive.value\n    const row0 = existingBubbles.filter(b => (b.row ?? 0) === 0)\n    if (row0.length === 0) return 0\n    let sumEven = 0\n    let sumOdd = 0\n    for (const b of row0) {\n      const bx = isAnimating && b.stableX !== undefined ? b.stableX : b.x\n      const nearestEven = baseX + Math.round((bx - baseX) / B) * B\n      const nearestOdd = baseX + B / 2 + Math.round((bx - (baseX + B / 2)) / B) * B\n      sumEven += Math.abs(bx - nearestEven)\n      sumOdd  += Math.abs(bx - nearestOdd)\n    }\n    return sumEven <= sumOdd ? 0 : B / 2\n  }\n\n  // Check if a seat (by center coords) is already occupied by an existing bubble\n  private isSeatOccupied(x: number, y: number, existingBubbles: Bubble[]): boolean {\n    const seatTol = 0.25 // tolerance for seat center equality\n    const isAnimating = this.stateManager?.rowAnimationActive.value\n    \n    for (const b of existingBubbles) {\n      // Use stable positions during animation for accurate seat occupancy check\n      const bubbleX = isAnimating && b.stableX !== undefined ? b.stableX : b.x\n      const bubbleY = isAnimating && b.stableY !== undefined ? b.stableY : b.y\n      \n      const dx = bubbleX - x\n      const dy = bubbleY - y\n      const d = Math.sqrt(dx * dx + dy * dy)\n      if (d <= seatTol) return true\n    }\n    return false\n  }\n\n  // Force bubble to its computed seat or the nearest free seat to avoid overlaps/mis-seating\n  private forceToNearestFreeSeat(\n    bubble: Bubble,\n    existingBubbles: Bubble[],\n    canvasWidth: number,\n    canvasHeight: number\n  ): void {\n    const rWall = this.BUBBLE_SIZE / 2\n    const inBounds = (x: number, y: number) => (\n      x >= rWall && x <= canvasWidth - rWall && y >= rWall && y <= canvasHeight - rWall\n    )\n\n    // First try the intended seat\n    let center = this.getSeatCenter(bubble.row!, bubble.col!, existingBubbles)\n    if (inBounds(center.x, center.y) && !this.isSeatOccupied(center.x, center.y, existingBubbles)) {\n      bubble.x = center.x\n      bubble.y = center.y\n      return\n    }\n\n    // Search nearby seats within a small window for a free slot nearest to current position\n    let best: { row: number; col: number; x: number; y: number } | null = null\n    let bestScore = Number.POSITIVE_INFINITY\n    const MAX_DELTA = 2\n    for (let dr = -MAX_DELTA; dr <= MAX_DELTA; dr++) {\n      const rr = Math.max(0, bubble.row! + dr)\n      for (let dc = -MAX_DELTA; dc <= MAX_DELTA; dc++) {\n        const cc = Math.max(0, bubble.col! + dc)\n        center = this.getSeatCenter(rr, cc, existingBubbles)\n        if (!inBounds(center.x, center.y)) continue\n        if (this.isSeatOccupied(center.x, center.y, existingBubbles)) continue\n        const dx = center.x - bubble.x\n        const dy = center.y - bubble.y\n        const score = dx * dx + dy * dy\n        if (score < bestScore) {\n          bestScore = score\n          best = { row: rr, col: cc, x: center.x, y: center.y }\n        }\n      }\n    }\n\n    if (best) {\n      bubble.row = best.row\n      bubble.col = best.col\n      bubble.x = best.x\n      bubble.y = best.y\n    } else {\n      // Fallback: clamp to bounds at least\n      bubble.x = Math.max(rWall, Math.min(canvasWidth - rWall, center.x))\n      bubble.y = Math.max(rWall, Math.min(canvasHeight - rWall, center.y))\n    }\n  }\n\n  public snapToGrid(bubble: Bubble, existingBubbles: Bubble[]): void {\n    console.log('Snapping bubble to grid. Current position:', bubble.x, bubble.y)\n    \n    // Simplified approach: Keep bubble at its collision-corrected position \n    // and only assign grid coordinates (row/col) without moving it\n    const verticalSpacing = (this.BUBBLE_SIZE * Math.sqrt(3)) / 2\n    const baseX = this.BUBBLE_SIZE / 2  // Remove +5 to align with initial bubbles at edge\n    \n    // Use dynamic baseY to handle row insertion animation (same as collision logic)\n    const baseY = this.getQuantizedBaseY(existingBubbles)\n    \n    // Calculate row/col based on current position\n    const targetRow = Math.max(0, Math.round((bubble.y - baseY) / verticalSpacing))\n    \n    // Use inferred top-row offset so new-row animation maintains correct horizontal parity\n    const topOffset = this.getTopRowOffset(existingBubbles)\n    const offsetX = targetRow % 2 === 0 ? topOffset : (topOffset === 0 ? this.BUBBLE_SIZE / 2 : 0)\n    \n    const targetCol = Math.max(0, Math.round((bubble.x - baseX - offsetX) / this.BUBBLE_SIZE))\n    \n    // Only assign grid coordinates, don't move the bubble from its collision-corrected position\n    bubble.row = targetRow\n    bubble.col = targetCol\n    \n    console.log('Grid coordinates assigned:', `row=${bubble.row}, col=${bubble.col}`, 'Position preserved:', bubble.x, bubble.y)\n  }\n\n  public lightenColor(color: string, amount: number): string {\n    const num = parseInt(color.replace('#', ''), 16)\n    const amt = Math.round(2.55 * amount * 100)\n    const R = (num >> 16) + amt\n    const G = (num >> 8 & 0x00FF) + amt\n    const B = (num & 0x0000FF) + amt\n    return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000\n      + (G < 255 ? G < 1 ? 0 : G : 255) * 0x100\n      + (B < 255 ? B < 1 ? 0 : B : 255))\n      .toString(16).slice(1)\n  }\n}\n\nexport const usePhysicsEngine = (stateManager?: IGameStateManager): IPhysicsEngine => {\n  return new PhysicsEngine(stateManager)\n}\n","import type { IVisualEffects, Explosion, Particle } from './interfaces'\n\nexport class VisualEffects implements IVisualEffects {\n  private readonly BUBBLE_SIZE = 40\n\n  public createBounceEffect(x: number, y: number): Explosion {\n    const particlesArray: Particle[] = []\n    \n    // Create small bounce particles\n    for (let i = 0; i < 4; i++) {\n      const angle = Math.random() * Math.PI * 2\n      const speed = 1 + Math.random() * 2\n      \n      particlesArray.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size: 1 + Math.random(),\n        color: '#87CEEB',\n        life: 0.5,\n        maxLife: 0.5,\n        type: 'spark',\n        rotation: 0,\n        rotationSpeed: 0\n      })\n    }\n    \n    return {\n      x,\n      y,\n      particles: particlesArray,\n      active: true,\n      shockwave: {\n        radius: 0,\n        maxRadius: this.BUBBLE_SIZE / 3,\n        intensity: 0.3\n      }\n    }\n  }\n\n  public createImpactEffect(x: number, y: number, color: string): Explosion {\n    const particlesArray: Particle[] = []\n    \n    // Create impact particles\n    for (let i = 0; i < 6; i++) {\n      const angle = Math.random() * Math.PI * 2\n      const speed = 2 + Math.random() * 3\n      \n      particlesArray.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size: 2 + Math.random() * 3,\n        color,\n        life: 0.8,\n        maxLife: 0.8,\n        type: 'burst',\n        rotation: Math.random() * Math.PI * 2,\n        rotationSpeed: (Math.random() - 0.5) * 0.2\n      })\n    }\n    \n    return {\n      x,\n      y,\n      particles: particlesArray,\n      active: true,\n      shockwave: {\n        radius: 0,\n        maxRadius: this.BUBBLE_SIZE,\n        intensity: 0.6\n      }\n    }\n  }\n\n  public createExplosion(x: number, y: number, color: string): Explosion {\n    const particlesArray: Particle[] = []\n    \n    // Create burst particles (main explosion)\n    for (let i = 0; i < 15; i++) {\n      const angle = (Math.PI * 2 * i) / 15\n      const speed = 3 + Math.random() * 5\n      \n      particlesArray.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size: 4 + Math.random() * 6,\n        color,\n        life: 1,\n        maxLife: 1,\n        type: 'burst',\n        rotation: Math.random() * Math.PI * 2,\n        rotationSpeed: (Math.random() - 0.5) * 0.3\n      })\n    }\n    \n    // Create spark particles (faster, smaller)\n    for (let i = 0; i < 8; i++) {\n      const angle = Math.random() * Math.PI * 2\n      const speed = 6 + Math.random() * 4\n      \n      particlesArray.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size: 1 + Math.random() * 2,\n        color: '#FFD700',\n        life: 0.8,\n        maxLife: 0.8,\n        type: 'spark',\n        rotation: 0,\n        rotationSpeed: 0\n      })\n    }\n    \n    // Create glow particles (slower, bigger)\n    for (let i = 0; i < 5; i++) {\n      const angle = Math.random() * Math.PI * 2\n      const speed = 1 + Math.random() * 2\n      \n      particlesArray.push({\n        x,\n        y,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        size: 8 + Math.random() * 4,\n        color: this.lightenColor(color, 0.3),\n        life: 1.2,\n        maxLife: 1.2,\n        type: 'glow',\n        rotation: Math.random() * Math.PI * 2,\n        rotationSpeed: (Math.random() - 0.5) * 0.1\n      })\n    }\n    \n    return {\n      x,\n      y,\n      particles: particlesArray,\n      active: true,\n      shockwave: {\n        radius: 0,\n        maxRadius: this.BUBBLE_SIZE * 2,\n        intensity: 1\n      }\n    }\n  }\n\n  public updateParticles(particles: Particle[]): void {\n    particles.forEach(particle => {\n      if (particle.life > 0) {\n        // Update particle position\n        particle.x += particle.vx\n        particle.y += particle.vy\n        \n        // Update rotation\n        particle.rotation += particle.rotationSpeed\n        \n        // Apply different physics based on particle type\n        switch (particle.type) {\n          case 'burst':\n            particle.vy += 0.15 // More gravity\n            particle.vx *= 0.96 // More friction\n            particle.vy *= 0.96\n            particle.life -= 0.025\n            break\n          case 'spark':\n            particle.vy += 0.05 // Less gravity\n            particle.vx *= 0.99 // Less friction\n            particle.vy *= 0.99\n            particle.life -= 0.04 // Faster decay\n            break\n          case 'glow':\n            particle.vy += 0.08 // Medium gravity\n            particle.vx *= 0.97\n            particle.vy *= 0.97\n            particle.life -= 0.015 // Slower decay\n            break\n        }\n      }\n    })\n  }\n\n  private lightenColor(color: string, amount: number): string {\n    const num = parseInt(color.replace('#', ''), 16)\n    const amt = Math.round(2.55 * amount * 100)\n    const R = (num >> 16) + amt\n    const G = (num >> 8 & 0x00FF) + amt\n    const B = (num & 0x0000FF) + amt\n    return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000\n      + (G < 255 ? G < 1 ? 0 : G : 255) * 0x100\n      + (B < 255 ? B < 1 ? 0 : B : 255))\n      .toString(16).slice(1)\n  }\n}\n\nexport const useVisualEffects = (): IVisualEffects => {\n  return new VisualEffects()\n}\n","import { ref, type Ref } from 'vue'\nimport type { ICanvasRenderer, Bubble, Explosion, AimLine, Position } from './interfaces'\n\nexport class CanvasRenderer implements ICanvasRenderer {\n  public readonly canvasWidth: Ref<number> = ref(800)\n  public readonly canvasHeight: Ref<number> = ref(600)\n  public readonly gameCanvas: Ref<HTMLCanvasElement | undefined> = ref()\n\n  private ctx: CanvasRenderingContext2D | null = null\n  private readonly BUBBLE_SIZE = 40\n\n  public initializeCanvas(): boolean {\n    if (!this.gameCanvas.value) return false\n    \n    const canvas = this.gameCanvas.value\n    this.ctx = canvas.getContext('2d')\n    if (!this.ctx) return false\n\n    // Set canvas size\n    const container = canvas.parentElement\n    if (container) {\n      this.canvasWidth.value = container.clientWidth\n      this.canvasHeight.value = container.clientHeight\n      canvas.width = this.canvasWidth.value\n      canvas.height = this.canvasHeight.value\n    }\n\n    return true\n  }\n\n  public setCanvasSize(width: number, height: number): void {\n    this.canvasWidth.value = width\n    this.canvasHeight.value = height\n    if (this.gameCanvas.value) {\n      this.gameCanvas.value.width = width\n      this.gameCanvas.value.height = height\n    }\n  }\n\n  public clearCanvas(): void {\n    if (!this.ctx) return\n    this.ctx.clearRect(0, 0, this.canvasWidth.value, this.canvasHeight.value)\n  }\n\n  public drawBackground(): void {\n    if (!this.ctx) return\n    \n    // Draw background gradient\n    const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvasHeight.value)\n    gradient.addColorStop(0, '#1a1a2e')\n    gradient.addColorStop(1, '#16213e')\n    this.ctx.fillStyle = gradient\n    this.ctx.fillRect(0, 0, this.canvasWidth.value, this.canvasHeight.value)\n  }\n\n  public drawBubble(bubble: Bubble): void {\n    if (!this.ctx) return\n    \n    // Align to half-pixel to reduce anti-aliasing artifacts\n    const cx = Math.round(bubble.x * 2) / 2\n    const cy = Math.round(bubble.y * 2) / 2\n    // Render radius strictly below physical radius to avoid visual overlap\n    const r = this.BUBBLE_SIZE / 2 - 1\n    \n    // Add subtle bubble glow\n    this.ctx.save()\n    this.ctx.shadowColor = bubble.color\n    this.ctx.shadowBlur = 6\n    \n    // Draw bubble with gradient\n    const gradient = this.ctx.createRadialGradient(\n      cx - this.BUBBLE_SIZE / 6, cy - this.BUBBLE_SIZE / 6, 0,\n      cx, cy, r\n    )\n    gradient.addColorStop(0, this.lightenColor(bubble.color, 0.3))\n    gradient.addColorStop(1, bubble.color)\n    \n    this.ctx.fillStyle = gradient\n    this.ctx.beginPath()\n    this.ctx.arc(cx, cy, r, 0, Math.PI * 2)\n    this.ctx.fill()\n    \n    // Draw enhanced border with inner highlight\n    this.ctx.strokeStyle = '#fff'\n    this.ctx.lineWidth = 2\n    this.ctx.stroke()\n    \n    // Inner highlight\n    this.ctx.strokeStyle = 'rgba(255,255,255,0.4)'\n    this.ctx.lineWidth = 1\n    this.ctx.beginPath()\n    this.ctx.arc(cx, cy, r - 3, 0, Math.PI * 2)\n    this.ctx.stroke()\n    \n    this.ctx.restore()\n    \n    // Draw text with enhanced styling\n    this.ctx.save()\n    this.ctx.shadowColor = 'rgba(0,0,0,0.7)'\n    this.ctx.shadowBlur = 3\n    this.ctx.shadowOffsetX = 1\n    this.ctx.shadowOffsetY = 1\n    \n    this.ctx.fillStyle = '#fff'\n    this.ctx.font = 'bold 16px Arial'\n    this.ctx.textAlign = 'center'\n    this.ctx.textBaseline = 'middle'\n    \n    // Show display text (supports both English and Vietnamese mode)\n    const text = bubble.displayText || bubble.word.charAt(0).toUpperCase()\n    \n    if (bubble.isBomb) {\n      // Draw bomb icon with pulsing effect for bomb bubbles\n      const time = Date.now() / 1000\n      const pulse = 0.9 + 0.1 * Math.sin(time * 8) // Fast pulsing\n      \n      this.ctx.save()\n      this.ctx.scale(pulse, pulse)\n      this.ctx.fillStyle = '#FFA500' // Orange color (not gray, following rules)\n      this.ctx.font = 'bold 22px Arial'\n      this.ctx.fillText('ðŸ’£', cx / pulse, (cy - 2) / pulse)\n      this.ctx.restore()\n      \n      // Add small text indicator below bomb\n      this.ctx.fillStyle = '#fff'\n      this.ctx.font = 'bold 10px Arial'\n      this.ctx.fillText(text, cx, cy + 14)\n      \n      // Add danger indicator ring\n      this.ctx.strokeStyle = '#FF4444'\n      this.ctx.lineWidth = 2\n      this.ctx.setLineDash([5, 5])\n      this.ctx.beginPath()\n      this.ctx.arc(cx, cy, r + 5, 0, Math.PI * 2)\n      this.ctx.stroke()\n      this.ctx.setLineDash([])\n    } else {\n      // Normal text display\n      this.ctx.fillText(text, cx, cy)\n    }\n    this.ctx.restore()\n  }\n\n  public drawShooter(position: Position, word: string, color: string, displayText?: string): void {\n    if (!this.ctx) return\n    \n    // Enhanced shooter with pulsing effect\n    this.ctx.save()\n    \n    // Pulsing glow effect using current shooter color\n    const pulseIntensity = 0.8 + 0.2 * Math.sin(Date.now() * 0.008)\n    this.ctx.shadowColor = color\n    this.ctx.shadowBlur = 15 * pulseIntensity\n    \n    // Draw shooter base with gradient using current shooter color\n    const gradient = this.ctx.createRadialGradient(\n      position.x - this.BUBBLE_SIZE / 6, position.y - this.BUBBLE_SIZE / 6, 0,\n      position.x, position.y, this.BUBBLE_SIZE / 2\n    )\n    gradient.addColorStop(0, color)\n    gradient.addColorStop(1, color)\n    \n    this.ctx.fillStyle = gradient\n    this.ctx.beginPath()\n    this.ctx.arc(position.x, position.y, this.BUBBLE_SIZE / 2, 0, Math.PI * 2)\n    this.ctx.fill()\n    \n    // Enhanced border\n    this.ctx.strokeStyle = '#fff'\n    this.ctx.lineWidth = 3\n    this.ctx.stroke()\n    \n    // Inner highlight ring\n    this.ctx.strokeStyle = 'rgba(255,255,255,0.3)'\n    this.ctx.lineWidth = 1\n    this.ctx.beginPath()\n    this.ctx.arc(position.x, position.y, this.BUBBLE_SIZE / 2 - 4, 0, Math.PI * 2)\n    this.ctx.stroke()\n    \n    this.ctx.restore()\n    \n    // Draw current word with enhanced text styling\n    this.ctx.save()\n    this.ctx.shadowColor = 'rgba(0,0,0,0.8)'\n    this.ctx.shadowBlur = 4\n    this.ctx.shadowOffsetX = 1\n    this.ctx.shadowOffsetY = 1\n    \n    this.ctx.fillStyle = '#fff'\n    this.ctx.font = 'bold 18px Arial'\n    this.ctx.textAlign = 'center'\n    this.ctx.textBaseline = 'middle'\n    \n    // Use displayText if provided, otherwise fallback to first character\n    const text = displayText || word.charAt(0).toUpperCase()\n    \n    this.ctx.fillText(text, position.x, position.y)\n    this.ctx.restore()\n  }\n\n  public drawShootingBubble(bubble: Bubble): void {\n    if (!this.ctx) return\n    \n    // Draw shooting bubble with enhanced glow to show it's active\n    this.ctx.save()\n    \n    // Enhanced glow effect for shooting bubble\n    this.ctx.shadowColor = bubble.color\n    this.ctx.shadowBlur = 15\n    \n    // Pulsing effect (never exceeds static radius)\n    const pulseIntensity = 0.98 + 0.02 * Math.sin(Date.now() * 0.01)\n    \n    // Draw bubble with extra bright gradient\n    const sx = Math.round(bubble.x * 2) / 2\n    const sy = Math.round(bubble.y * 2) / 2\n    const r0 = this.BUBBLE_SIZE / 2 - 1\n    const gradient = this.ctx.createRadialGradient(\n      sx - this.BUBBLE_SIZE / 5, sy - this.BUBBLE_SIZE / 5, 0,\n      sx, sy, r0\n    )\n    gradient.addColorStop(0, this.lightenColor(bubble.color, 0.5))\n    gradient.addColorStop(1, bubble.color)\n    \n    this.ctx.fillStyle = gradient\n    this.ctx.beginPath()\n    this.ctx.arc(sx, sy, r0 * pulseIntensity, 0, Math.PI * 2)\n    this.ctx.fill()\n    \n    // Enhanced border for shooting bubble\n    this.ctx.strokeStyle = '#fff'\n    this.ctx.lineWidth = 3\n    this.ctx.stroke()\n    \n    // Extra bright inner highlight\n    this.ctx.strokeStyle = 'rgba(255,255,255,0.6)'\n    this.ctx.lineWidth = 1\n    this.ctx.beginPath()\n    this.ctx.arc(sx, sy, (r0 - 3) * pulseIntensity, 0, Math.PI * 2)\n    this.ctx.stroke()\n    \n    this.ctx.restore()\n    \n    // Draw text with enhanced styling\n    this.ctx.save()\n    this.ctx.shadowColor = 'rgba(0,0,0,0.9)'\n    this.ctx.shadowBlur = 5\n    this.ctx.shadowOffsetX = 1\n    this.ctx.shadowOffsetY = 1\n    \n    this.ctx.fillStyle = '#fff'\n    this.ctx.font = 'bold 17px Arial'\n    this.ctx.textAlign = 'center'\n    this.ctx.textBaseline = 'middle'\n    \n    // Use displayText if available, otherwise fallback to first character\n    const text = bubble.displayText || bubble.word.charAt(0).toUpperCase()\n    \n    this.ctx.fillText(text, sx, sy)\n    this.ctx.restore()\n  }\n\n  public drawExplosions(explosions: Explosion[]): void {\n    if (!this.ctx) return\n    \n    explosions.forEach(explosion => {\n      if (!explosion.active || !this.ctx) return\n      \n      // Draw shockwave\n      if (explosion.shockwave.intensity > 0) {\n        this.ctx.save()\n        this.ctx.globalAlpha = explosion.shockwave.intensity * 0.3\n        this.ctx.strokeStyle = '#FFD700'\n        this.ctx.lineWidth = 2\n        this.ctx.beginPath()\n        this.ctx.arc(explosion.x, explosion.y, explosion.shockwave.radius, 0, Math.PI * 2)\n        this.ctx.stroke()\n        this.ctx.restore()\n      }\n      \n      // Draw particles with enhanced effects\n      explosion.particles.forEach(particle => {\n        if (particle.life <= 0 || !this.ctx) return\n        \n        const alpha = particle.life / particle.maxLife\n        this.ctx.save()\n        this.ctx.translate(particle.x, particle.y)\n        this.ctx.rotate(particle.rotation)\n        this.ctx.globalAlpha = alpha\n        \n        // Different rendering based on particle type\n        switch (particle.type) {\n          case 'burst':\n            // Main explosion particles with glow\n            this.ctx.shadowColor = particle.color\n            this.ctx.shadowBlur = particle.size * 2\n            this.ctx.fillStyle = particle.color\n            this.ctx.beginPath()\n            this.ctx.arc(0, 0, particle.size * alpha, 0, Math.PI * 2)\n            this.ctx.fill()\n            break\n            \n          case 'spark':\n            // Fast, bright sparks\n            this.ctx.strokeStyle = particle.color\n            this.ctx.lineWidth = particle.size * alpha\n            this.ctx.lineCap = 'round'\n            this.ctx.beginPath()\n            this.ctx.moveTo(-particle.size, 0)\n            this.ctx.lineTo(particle.size, 0)\n            this.ctx.stroke()\n            break\n            \n          case 'glow':\n            // Soft glowing particles\n            const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, particle.size * alpha)\n            gradient.addColorStop(0, particle.color)\n            gradient.addColorStop(1, 'transparent')\n            this.ctx.fillStyle = gradient\n            this.ctx.beginPath()\n            this.ctx.arc(0, 0, particle.size * alpha, 0, Math.PI * 2)\n            this.ctx.fill()\n            break\n        }\n        \n        this.ctx.restore()\n      })\n    })\n  }\n\n  public drawAimLine(aimLine: AimLine, shooterPosition: Position): void {\n    if (!this.ctx || !aimLine.visible) return\n    \n    const ctx = this.ctx\n    ctx.strokeStyle = 'rgba(255,255,255,0.8)'\n    ctx.lineWidth = 2\n    ctx.setLineDash([5, 5])\n    \n    // Compute a reflective aim preview with up to 2 bounces on the side walls\n    const leftX = this.BUBBLE_SIZE / 2\n    const rightX = this.canvasWidth.value - this.BUBBLE_SIZE / 2\n    const topY = this.BUBBLE_SIZE / 2\n    \n    let px = shooterPosition.x\n    let py = shooterPosition.y\n    \n    // Direction vector from shooter to pointer\n    let vx = aimLine.x - shooterPosition.x\n    let vy = aimLine.y - shooterPosition.y\n    const len = Math.sqrt(vx * vx + vy * vy) || 1\n    vx /= len\n    vy /= len\n    \n    // Ensure pointing upwards for preview\n    if (vy > -0.01) vy = -0.01\n    \n    ctx.beginPath()\n    ctx.moveTo(px, py)\n    \n    let bounces = 0\n    const maxBounces = 2\n    let safeGuard = 0\n    while (bounces <= maxBounces && safeGuard++ < 10) {\n      // Time to hit top boundary\n      const tTop = (topY - py) / vy // vy is negative\n      \n      // Time to hit side wall\n      let tWall = Number.POSITIVE_INFINITY\n      let wallX = px\n      if (vx > 0) {\n        tWall = (rightX - px) / vx\n        wallX = rightX\n      } else if (vx < 0) {\n        tWall = (leftX - px) / vx\n        wallX = leftX\n      }\n      \n      // Choose the earliest positive intersection\n      const tMin = Math.min(\n        tTop > 0 ? tTop : Number.POSITIVE_INFINITY,\n        tWall > 0 ? tWall : Number.POSITIVE_INFINITY\n      )\n      \n      // End point for this segment\n      const nx = px + vx * tMin\n      const ny = py + vy * tMin\n      ctx.lineTo(nx, ny)\n      \n      // If we reached top, stop drawing\n      if (tTop > 0 && tTop <= tMin + 1e-6) {\n        break\n      }\n      \n      // Otherwise we hit a wall: reflect and continue\n      px = wallX\n      py = ny\n      vx = -vx\n      bounces++\n      \n      // Continue path from reflection point\n      ctx.moveTo(px, py)\n    }\n    \n    ctx.stroke()\n    ctx.setLineDash([])\n    \n    // Add aim line glow effect\n    ctx.shadowColor = '#fff'\n    ctx.shadowBlur = 10\n    ctx.stroke()\n    ctx.shadowBlur = 0\n  }\n\n  private lightenColor(color: string, amount: number): string {\n    const num = parseInt(color.replace('#', ''), 16)\n    const amt = Math.round(2.55 * amount * 100)\n    const R = (num >> 16) + amt\n    const G = (num >> 8 & 0x00FF) + amt\n    const B = (num & 0x0000FF) + amt\n    return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000\n      + (G < 255 ? G < 1 ? 0 : G : 255) * 0x100\n      + (B < 255 ? B < 1 ? 0 : B : 255))\n      .toString(16).slice(1)\n  }\n}\n\nexport const useCanvasRenderer = (): ICanvasRenderer => {\n  return new CanvasRenderer()\n}\n","import type { IInputHandler, Position } from './interfaces'\n\nexport class InputHandler implements IInputHandler {\n  public updateAim(event: MouseEvent, canvas: HTMLCanvasElement): Position | null {\n    // Get canvas bounding rect for accurate positioning across all screen sizes\n    const rect = canvas.getBoundingClientRect()\n    \n    // Calculate mouse position relative to canvas with responsive scaling\n    const scaleX = canvas.width / rect.width\n    const scaleY = canvas.height / rect.height\n    \n    // Accurate mouse coordinates for xs/sm/md/lg/xl screens\n    const mouseX = (event.clientX - rect.left) * scaleX\n    const mouseY = (event.clientY - rect.top) * scaleY\n    \n    console.log(`Mouse: ${event.clientX}, ${event.clientY} | Canvas: ${mouseX}, ${mouseY} | Scale: ${scaleX.toFixed(2)}, ${scaleY.toFixed(2)}`)\n    \n    // Calculate shooter position (assuming it's at bottom center)\n    const shooterX = canvas.width / 2\n    const shooterY = canvas.height - 50\n    \n    // Calculate distance for aim line\n    const dx = mouseX - shooterX\n    const dy = mouseY - shooterY\n    const distance = Math.sqrt(dx * dx + dy * dy)\n    \n    // Only show aim if mouse is above shooter (can't shoot backwards)\n    if (mouseY < shooterY - 20 && distance > 20) {\n      return {\n        x: mouseX,\n        y: mouseY\n      }\n    }\n    \n    return null\n  }\n\n  public getShootingVector(\n    event: MouseEvent, \n    canvas: HTMLCanvasElement, \n    shooterPosition: Position\n  ): { vx: number; vy: number } | null {\n    // Get canvas bounding rect for accurate positioning across all screen sizes  \n    const rect = canvas.getBoundingClientRect()\n    if (!rect) return null\n    \n    // Calculate responsive mouse position with proper scaling\n    const scaleX = canvas.width / rect.width\n    const scaleY = canvas.height / rect.height\n    \n    // Accurate target coordinates for xs/sm/md/lg/xl screens\n    const targetX = (event.clientX - rect.left) * scaleX\n    const targetY = (event.clientY - rect.top) * scaleY\n    \n    console.log(`Shooting at: ${targetX}, ${targetY} (scaled from ${event.clientX}, ${event.clientY})`)\n    \n    // Compute reflected aim identical to the on-screen preview (max 2 bounces)\n    const BUBBLE_SIZE = 40\n    const leftX = BUBBLE_SIZE / 2\n    const rightX = canvas.width - BUBBLE_SIZE / 2\n    const topY = BUBBLE_SIZE / 2\n\n    // Initial direction towards the mouse\n    let vx = targetX - shooterPosition.x\n    let vy = targetY - shooterPosition.y\n    const len0 = Math.sqrt(vx * vx + vy * vy) || 1\n    vx /= len0\n    vy /= len0\n    if (vy > -0.01) vy = -0.01 // ensure upward\n\n    // Simulate to find the first segment endpoint (earliest hit with wall or top)\n    let px = shooterPosition.x\n    let py = shooterPosition.y\n    let bounces = 0\n    const maxBounces = 2\n    let endX = targetX\n    let endY = targetY\n    while (bounces <= maxBounces) {\n      const tTop = (topY - py) / vy // vy < 0\n      let tWall = Number.POSITIVE_INFINITY\n      let hitRight = false\n      if (vx > 0) {\n        tWall = (rightX - px) / vx\n        hitRight = true\n      } else if (vx < 0) {\n        tWall = (leftX - px) / vx\n        hitRight = false\n      }\n      const tMin = Math.min(\n        tTop > 0 ? tTop : Number.POSITIVE_INFINITY,\n        tWall > 0 ? tWall : Number.POSITIVE_INFINITY\n      )\n      endX = px + vx * tMin\n      endY = py + vy * tMin\n      // Stop at first intersection (we only need the initial segment for launch)\n      break\n    }\n\n    // Final launch vector aims to the first-segment endpoint\n    const dx = endX - shooterPosition.x\n    const dy = endY - shooterPosition.y\n    const distance = Math.sqrt(dx * dx + dy * dy) || 1\n    const speed = 8\n    const normalizedDx = (dx / distance) * speed\n    const normalizedDy = (dy / distance) * speed\n\n    console.log(`Direction (reflected): dx=${normalizedDx.toFixed(2)}, dy=${normalizedDy.toFixed(2)}`)\n\n    return { vx: normalizedDx, vy: normalizedDy }\n  }\n}\n\nexport const useInputHandler = (): IInputHandler => {\n  return new InputHandler()\n}\n","import type { IGameLogic, Bubble } from './interfaces'\nimport type { Vocabulary } from '@/composables/useVocabularyStore'\n\nexport class GameLogic implements IGameLogic {\n  private readonly BUBBLE_SIZE = 40\n  private readonly COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#FFB347']\n\n  public checkForMatches(newBubble: Bubble, bubbles: Bubble[]): {\n    matchedBubbles: Bubble[]\n    shouldRemove: boolean\n  } {\n    console.log('Checking matches for bubble:', newBubble.word, newBubble.x, newBubble.y)\n    \n    // Find connected bubbles with same word (and implicitly same color)\n    const visited = new Set<string>()\n    const connectedBubbles: Bubble[] = []\n    \n    const findConnected = (bubble: Bubble) => {\n      if (visited.has(bubble.id)) return\n      visited.add(bubble.id)\n      connectedBubbles.push(bubble)\n      \n      console.log('Found connected bubble:', bubble.word, bubble.x, bubble.y)\n      \n      // Find adjacent bubbles with same word\n      bubbles.forEach(other => {\n        if (other.id !== bubble.id && !visited.has(other.id) && other.word === bubble.word) {\n          const dx = other.x - bubble.x\n          const dy = other.y - bubble.y\n          const distance = Math.sqrt(dx * dx + dy * dy)\n          \n          console.log(`Distance between ${bubble.word} and ${other.word}: ${distance}, BUBBLE_SIZE: ${this.BUBBLE_SIZE}`)\n          \n          // Check if bubbles are adjacent (touching) - more generous threshold\n          if (distance <= this.BUBBLE_SIZE * 1.2) {\n            console.log('Found adjacent bubble:', other.word, other.x, other.y)\n            findConnected(other)\n          }\n        }\n      })\n    }\n    \n    findConnected(newBubble)\n    \n    console.log(`Found ${connectedBubbles.length} connected bubbles:`, connectedBubbles.map(b => b.word))\n    \n    // If we found 3 or more connected bubbles with same word, remove them\n    const shouldRemove = connectedBubbles.length >= 3\n    if (shouldRemove) {\n      console.log('MATCH FOUND! Removing bubbles:', connectedBubbles.map(b => b.word))\n    } else {\n      console.log('No match - not enough connected bubbles')\n    }\n\n    return {\n      matchedBubbles: connectedBubbles,\n      shouldRemove\n    }\n  }\n\n  public removeFloatingBubbles(bubbles: Bubble[]): {\n    remainingBubbles: Bubble[]\n    removedBubbles: Bubble[]\n  } {\n    // Mark bubbles that are connected to top\n    const topConnected = new Set<string>()\n    \n    const markTopConnected = (bubble: Bubble) => {\n      if (topConnected.has(bubble.id)) return\n      topConnected.add(bubble.id)\n      \n      // Find adjacent bubbles\n      bubbles.forEach(other => {\n        if (other.id !== bubble.id && !topConnected.has(other.id)) {\n          const dx = other.x - bubble.x\n          const dy = other.y - bubble.y\n          const distance = Math.sqrt(dx * dx + dy * dy)\n          \n          if (distance <= this.BUBBLE_SIZE * 1.1) {\n            markTopConnected(other)\n          }\n        }\n      })\n    }\n    \n    // Start from top row bubbles\n    bubbles.forEach(bubble => {\n      if (bubble.row === 0) {\n        markTopConnected(bubble)\n      }\n    })\n    \n    // Separate remaining and floating bubbles\n    const remainingBubbles = bubbles.filter(bubble => topConnected.has(bubble.id))\n    const removedBubbles = bubbles.filter(bubble => !topConnected.has(bubble.id))\n    \n    return {\n      remainingBubbles,\n      removedBubbles\n    }\n  }\n\n  public setupInitialBubbles(words: Vocabulary[], vietnameseMode: boolean = false): Bubble[] {\n    const bubbles: Bubble[] = []\n    \n    // Use EXACT same spacing calculations as PhysicsEngine to ensure perfect alignment\n    const verticalSpacing = (this.BUBBLE_SIZE * Math.sqrt(3)) / 2\n    const baseX = this.BUBBLE_SIZE / 2  // Remove +5 to make bubbles touch left edge\n    const baseY = this.BUBBLE_SIZE / 2  // Remove +5 to make bubbles touch top edge\n    const bubblesPerRow = 8 // Maximum bubbles per row to fit screen\n    \n    for (let i = 0; i < words.length; i++) {\n      // Calculate row and column position\n      const row = Math.floor(i / bubblesPerRow)\n      const col = i % bubblesPerRow\n      \n      // Use EXACT same offset logic as PhysicsEngine\n      const offsetX = row % 2 === 0 ? 0 : this.BUBBLE_SIZE / 2\n      \n      // Calculate position using EXACT same formula as PhysicsEngine\n      const x = baseX + offsetX + col * this.BUBBLE_SIZE\n      const y = baseY + row * verticalSpacing\n      \n      const bubble: Bubble = {\n        x,\n        y,\n        word: words[i].word,\n        color: this.getColorForWord(words[i].word), // Use consistent color for same word\n        id: `initial-${i}`,\n        row,\n        col,\n        vietnameseMeaning: words[i].meaning, // Store Vietnamese meaning\n        displayText: vietnameseMode && words[i].meaning \n          ? words[i].meaning.substring(0, 2).toUpperCase() // Vietnamese first 2 letters if mode enabled\n          : words[i].word.charAt(0).toUpperCase() // Default to English first 1 letter\n      }\n      \n      bubbles.push(bubble)\n    }\n    \n    return bubbles\n  }\n\n  public isGameWon(bubbles: Bubble[]): boolean {\n    return bubbles.length === 0\n  }\n\n  public calculateScore(matchedBubbles: number, floatingBubbles: number): number {\n    return (matchedBubbles * 10) + (floatingBubbles * 5)\n  }\n\n  private getColorForWord(word: string): string {\n    // Use same logic as in GameStateManager for consistency\n    let hash = 0\n    for (let i = 0; i < word.length; i++) {\n      hash = ((hash << 5) - hash + word.charCodeAt(i)) & 0xffffffff\n    }\n    const colorIndex = Math.abs(hash) % this.COLORS.length\n    return this.COLORS[colorIndex]\n  }\n}\n\nexport const useGameLogic = (): IGameLogic => {\n  return new GameLogic()\n}\n","import { ref } from 'vue'\nimport type { \n  IBubbleShooterGame,\n  IGameStateManager,\n  IAudioSystem,\n  IPhysicsEngine,\n  IVisualEffects,\n  ICanvasRenderer,\n  IInputHandler,\n  IGameLogic,\n  Bubble\n} from './interfaces'\nimport type { Vocabulary } from '@/composables/useVocabularyStore'\nimport { useGameStateManager } from './useGameStateManager'\nimport { useAudioSystem } from './useAudioSystem'\nimport { usePhysicsEngine } from './usePhysicsEngine'\nimport { useVisualEffects } from './useVisualEffects'\nimport { useCanvasRenderer } from './useCanvasRenderer'\nimport { useInputHandler } from './useInputHandler'\nimport { useGameLogic } from './useGameLogic'\n\nexport class BubbleShooterGame implements IBubbleShooterGame {\n  // Dependencies\n  public readonly stateManager: IGameStateManager\n  public readonly audioSystem: IAudioSystem\n  public readonly physicsEngine: IPhysicsEngine\n  public readonly visualEffects: IVisualEffects\n  public readonly canvasRenderer: ICanvasRenderer\n  public readonly inputHandler: IInputHandler\n  public readonly gameLogic: IGameLogic\n\n  // Private properties\n  private animationFrame: number | null = null\n  private currentWords: Vocabulary[] = []\n  private vietnameseMode: boolean = false\n  \n  // Timed row insertion & animation state\n  private rowInsertTimer: number | null = null\n  private readonly ROW_INSERT_INTERVAL = 20000\n  private rowAnimationActive = false\n  \n  // Bomb system\n  private bombHits = new Map<string, number>() // Track hits per bomb bubble\n  private rowAnimationStart = 0\n  private readonly rowAnimationDuration = 600 // ms\n  private rowShiftAmount: number = 34 // will be recalculated in constructor\n  private rowStartYMap = new Map<string, number>()\n  private rowStartXMap = new Map<string, number>()\n  private newRowBubbles: Bubble[] = []\n  private newRowDelays = new Map<string, number>()\n\n  constructor() {\n    // Initialize state manager first\n    this.stateManager = useGameStateManager()\n    \n    // Initialize other dependencies, pass stateManager to physicsEngine\n    this.audioSystem = useAudioSystem()\n    this.physicsEngine = usePhysicsEngine(this.stateManager)\n    this.visualEffects = useVisualEffects()\n    this.canvasRenderer = useCanvasRenderer()\n    this.inputHandler = useInputHandler()\n    this.gameLogic = useGameLogic()\n\n    // Derive row shift from physics bubble size to match spacing\n    this.rowShiftAmount = (this.physicsEngine.BUBBLE_SIZE * Math.sqrt(3)) / 2\n  }\n\n  // ===== Row Insertion Feature =====\n  private triggerRowInsertion(): void {\n    if (this.rowAnimationActive || this.stateManager.gameOver.value) return\n    if (this.stateManager.shootingBubble.value) return\n    // Prepare animation state\n    this.rowAnimationActive = true\n    this.stateManager.setRowAnimationActive(true)\n    this.rowAnimationStart = performance.now()\n    this.rowStartYMap.clear()\n    this.rowStartXMap.clear()\n    this.newRowBubbles = []\n    this.newRowDelays.clear()\n\n    // Capture starting X,Y for existing bubbles and set stable positions\n    this.stateManager.bubbles.value.forEach(b => {\n      this.rowStartYMap.set(b.id, b.y)\n      this.rowStartXMap.set(b.id, b.x)\n      \n      // Set stable collision positions based on current grid positions\n      // These will remain fixed during animation for collision detection\n      const verticalSpacing = (this.physicsEngine.BUBBLE_SIZE * Math.sqrt(3)) / 2\n      const baseX = this.physicsEngine.BUBBLE_SIZE / 2\n      const baseY = this.physicsEngine.BUBBLE_SIZE / 2\n      const offsetX = (b.row ?? 0) % 2 === 0 ? 0 : this.physicsEngine.BUBBLE_SIZE / 2\n      \n      b.stableX = baseX + offsetX + (b.col ?? 0) * this.physicsEngine.BUBBLE_SIZE\n      b.stableY = baseY + (b.row ?? 0) * verticalSpacing\n    })\n\n    // Decide desired offset for the new top row (row 0) to complement current top row (which will become row 1)\n    const B = this.physicsEngine.BUBBLE_SIZE\n    const baseX = B / 2\n    const currentTop = this.stateManager.bubbles.value.filter(b => (b.row ?? 0) === 0)\n    const nearestGridX = (x: number, offsetX: number) => {\n      const colF = Math.round((x - (baseX + offsetX)) / B)\n      return baseX + offsetX + colF * B\n    }\n    let sumEven = 0, sumOdd = 0\n    if (currentTop.length > 0) {\n      currentTop.forEach(b => {\n        sumEven += Math.abs(b.x - nearestGridX(b.x, 0))\n        sumOdd  += Math.abs(b.x - nearestGridX(b.x, B / 2))\n      })\n    }\n    const effOffsetRow1 = currentTop.length === 0 ? 0 : (sumEven <= sumOdd ? 0 : B / 2)\n    const desiredOffsetRow0 = effOffsetRow1 === 0 ? B / 2 : 0\n\n    // Create new top row (left -> right staggered)\n    // Compute columns to span full canvas width (respect 5px margins on both sides)\n    const canvasW = this.canvasRenderer.canvasWidth.value || 800\n    const offsetX = desiredOffsetRow0\n    const Bsize = this.physicsEngine.BUBBLE_SIZE\n    const bubblesPerRow = Math.max(1, Math.floor((canvasW - 10 - offsetX) / Bsize))\n    for (let col = 0; col < bubblesPerRow; col++) {\n      const vocab = this.currentWords[Math.floor(Math.random() * Math.max(1, this.currentWords.length))]\n      const word = vocab?.word || 'Â·'\n      const color = this.physicsEngine.getColorForWord(word)\n      const x = col * this.physicsEngine.BUBBLE_SIZE + this.physicsEngine.BUBBLE_SIZE / 2 + offsetX  // Remove +5 to touch left edge\n      const startY = -this.physicsEngine.BUBBLE_SIZE // start above view\n      \n      // Random chance to create bomb bubble (20% chance for more excitement)\n      const isBomb = Math.random() < 0.2\n      \n      const bubble: Bubble = {\n        x,\n        y: startY,\n        word,\n        color: isBomb ? '#FF4444' : color, // Bomb bubbles are red\n        id: `row-${Date.now()}-${col}`,\n        row: -1,\n        col,\n        vietnameseMeaning: vocab?.meaning || '',\n        displayText: this.vietnameseMode && vocab?.meaning\n          ? vocab.meaning.substring(0, 2).toUpperCase()\n          : word.charAt(0).toUpperCase(),\n        isBomb\n      }\n      this.stateManager.addBubble(bubble)\n      this.newRowBubbles.push(bubble)\n      this.newRowDelays.set(bubble.id, col * 60) // ms stagger strictly left -> right\n    }\n  }\n\n  private updateRowInsertionAnimation(): void {\n    if (!this.rowAnimationActive) return\n\n    const now = performance.now()\n    const elapsed = now - this.rowAnimationStart\n    const t = Math.min(1, elapsed / this.rowAnimationDuration)\n    const ease = 1 - Math.pow(1 - t, 3) // easeOutCubic\n\n    // Move existing bubbles down by eased shift amount and freeze X to starting value\n    this.stateManager.bubbles.value.forEach(b => {\n      if (this.newRowDelays.has(b.id)) return // skip newly inserted row here\n      const startY = this.rowStartYMap.get(b.id)\n      const startX = this.rowStartXMap.get(b.id)\n      if (startY != null) {\n        b.y = startY + ease * this.rowShiftAmount\n      }\n      if (startX != null) {\n        b.x = startX // hard-freeze X to eliminate any lateral slide\n      }\n    })\n\n    // Drop new row from above to top line, left->right stagger\n    const targetTopY = this.physicsEngine.BUBBLE_SIZE / 2  // Remove +5 to touch top edge\n    // Ensure the new row never overlaps the moving row beneath during animation using per-bubble nearest neighbor clamp\n    const movingTopY = targetTopY + ease * this.rowShiftAmount\n    const epsilon = 1.0 // safety to avoid any visual overlap due to AA\n    const rowBelow = this.stateManager.bubbles.value.filter(b => !this.newRowDelays.has(b.id) && ((b.row ?? 0) === 0))\n    let allNewSettled = true\n    for (const nb of this.newRowBubbles) {\n      const delay = this.newRowDelays.get(nb.id) || 0\n      const localElapsed = Math.max(0, elapsed - delay)\n      const tt = Math.min(1, localElapsed / Math.max(1, this.rowAnimationDuration - delay))\n      const ease2 = 1 - Math.pow(1 - tt, 3)\n      const startY = -this.physicsEngine.BUBBLE_SIZE\n      const plannedY = startY + (targetTopY - startY) * ease2\n      // Base clamp using ideal hex separation relative to moving row position\n      let allowed = movingTopY - this.rowShiftAmount - epsilon\n      // Refine clamp using the nearest bubble in the moving row below\n      if (rowBelow.length > 0) {\n        let nearest = rowBelow[0]\n        let bestDx = Math.abs(nearest.x - nb.x)\n        for (let i = 1; i < rowBelow.length; i++) {\n          const dx = Math.abs(rowBelow[i].x - nb.x)\n          if (dx < bestDx) {\n            bestDx = dx\n            nearest = rowBelow[i]\n          }\n        }\n        const B = this.physicsEngine.BUBBLE_SIZE\n        const dxClamped = Math.min(bestDx, B)\n        const dyMin = dxClamped >= B ? 0 : Math.sqrt(B * B - dxClamped * dxClamped)\n        allowed = Math.min(allowed, nearest.y - dyMin - epsilon)\n      }\n      nb.y = Math.round(Math.min(plannedY, allowed) * 2) / 2\n      if (tt < 1) allNewSettled = false\n    }\n\n    // Finish\n    if (t >= 1 && allNewSettled) {\n      // Commit rows and exact positions\n      // Existing bubbles: increase row by 1 and snap Y to exact grid (avoid cumulative float error)\n      this.stateManager.bubbles.value.forEach(b => {\n        if (this.newRowDelays.has(b.id)) return\n        const prevRow = b.row ?? 0\n        const nextRow = prevRow + 1\n        // Restore exact starting X to guarantee no lateral drift\n        const startX = this.rowStartXMap.get(b.id)\n        if (startX != null) b.x = startX\n        b.row = nextRow\n        // Snap to exact Y grid based on row index (half-pixel aligned)\n        const yExact = (this.physicsEngine.BUBBLE_SIZE / 2) + nextRow * this.rowShiftAmount  // Remove +5\n        b.y = Math.round(yExact * 2) / 2\n        // Preserve X; recompute column under new parity based on current X\n        const offsetX = nextRow % 2 === 0 ? 0 : this.physicsEngine.BUBBLE_SIZE / 2\n        const colF = Math.round(\n          (b.x - (this.physicsEngine.BUBBLE_SIZE / 2 + offsetX)) / this.physicsEngine.BUBBLE_SIZE\n        )  // Remove +5\n        b.col = Math.max(0, colF)\n      })\n\n      // New row: set row=0 and ensure exact Y; preserve X and compute col using the same desired offset\n      const B2 = this.physicsEngine.BUBBLE_SIZE\n      const baseX2 = B2 / 2  // Remove +5 to align with edge\n      const currentTop2 = this.stateManager.bubbles.value.filter(b => (b.row ?? 0) === 1)\n      let sumEven2 = 0, sumOdd2 = 0\n      if (currentTop2.length > 0) {\n        currentTop2.forEach(b => {\n          sumEven2 += Math.abs(b.x - (baseX2 + Math.round((b.x - baseX2) / B2) * B2))\n          sumOdd2  += Math.abs(b.x - (baseX2 + B2 / 2 + Math.round((b.x - (baseX2 + B2 / 2)) / B2) * B2))\n        })\n      }\n      const effOffsetRow1b = currentTop2.length === 0 ? 0 : (sumEven2 <= sumOdd2 ? 0 : B2 / 2)\n      const desiredOffsetRow0b = effOffsetRow1b === 0 ? B2 / 2 : 0\n      this.newRowBubbles.forEach((nb) => {\n        const col0 = Math.round((nb.x - (baseX2 + desiredOffsetRow0b)) / B2)\n        nb.col = Math.max(0, col0)\n        nb.row = 0\n        // Commit exactly to grid Y to ensure zero gap with neighbors\n        nb.y = Math.round(targetTopY * 2) / 2\n      })\n\n      // Minor feedback\n      this.stateManager.addScreenShake(4)\n      this.audioSystem.playImpactSound()\n\n      // Clear stable positions now that animation is complete\n      this.stateManager.bubbles.value.forEach(b => {\n        delete b.stableX\n        delete b.stableY\n      })\n\n      // Reset animation state\n      this.rowAnimationActive = false\n      this.stateManager.setRowAnimationActive(false)\n      this.rowStartYMap.clear()\n      this.rowStartXMap.clear()\n      this.newRowDelays.clear()\n      this.newRowBubbles = []\n    }\n  }\n\n  public initialize(canvas: HTMLCanvasElement, words: Vocabulary[], vietnameseMode: boolean = false): void {\n    // Store canvas reference and words\n    this.canvasRenderer.gameCanvas.value = canvas\n    this.currentWords = words\n    this.vietnameseMode = vietnameseMode\n    \n    // Initialize canvas\n    if (!this.canvasRenderer.initializeCanvas()) {\n      console.error('Failed to initialize canvas')\n      return\n    }\n\n    // Update shooter position based on canvas size\n    this.stateManager.shooterPosition.value = { \n      x: this.canvasRenderer.canvasWidth.value / 2, \n      y: this.canvasRenderer.canvasHeight.value - 50 \n    }\n\n    // Setup initial game state with Vietnamese mode support\n    const initialBubbles = this.gameLogic.setupInitialBubbles(words, this.vietnameseMode)\n    initialBubbles.forEach(bubble => this.stateManager.addBubble(bubble))\n    \n    this.stateManager.selectNextShooterWord(words)\n    this.startGameLoop()\n\n    // Set up row insertion timer (every 20s add a new top row and shift others down)\n    if (this.rowInsertTimer) window.clearInterval(this.rowInsertTimer)\n    this.rowInsertTimer = window.setInterval(() => this.triggerRowInsertion(), this.ROW_INSERT_INTERVAL)\n  }\n\n  public startGameLoop(): void {\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame)\n    }\n    \n    const gameLoop = () => {\n      // Update timed row insertion animation\n      this.updateRowInsertionAnimation()\n\n      // Update explosions and particles\n      this.stateManager.updateExplosions()\n      \n      // Clear and draw everything\n      this.canvasRenderer.clearCanvas()\n      \n      // Apply screen shake\n      const shake = this.stateManager.screenShake.value\n      const ctx = this.canvasRenderer.gameCanvas.value?.getContext('2d')\n      if (ctx) {\n        ctx.save()\n        ctx.translate(shake.x, shake.y)\n        \n        // Draw background\n        this.canvasRenderer.drawBackground()\n        \n        // Draw all bubbles\n        this.stateManager.bubbles.value.forEach(bubble => {\n          this.canvasRenderer.drawBubble(bubble)\n        })\n        \n        // Draw explosions\n        this.canvasRenderer.drawExplosions(this.stateManager.explosions.value)\n        \n        // Draw shooter\n        this.canvasRenderer.drawShooter(\n          this.stateManager.shooterPosition.value,\n          this.stateManager.currentShooterWord.value,\n          this.stateManager.currentShooterColor.value,\n          this.getShooterDisplayText()\n        )\n        \n        // Draw shooting bubble if exists\n        if (this.stateManager.shootingBubble.value) {\n          this.canvasRenderer.drawShootingBubble(this.stateManager.shootingBubble.value)\n        }\n        \n        // Draw aim line\n        this.canvasRenderer.drawAimLine(\n          this.stateManager.aimLine.value,\n          this.stateManager.shooterPosition.value\n        )\n        \n        ctx.restore()\n      }\n      \n      // Check if game is won\n      if (this.gameLogic.isGameWon(this.stateManager.bubbles.value)) {\n        this.stateManager.setGameOver(true)\n        return\n      }\n      \n      if (!this.stateManager.gameOver.value) {\n        this.animationFrame = requestAnimationFrame(gameLoop)\n      }\n    }\n    \n    gameLoop()\n  }\n\n  public stopGameLoop(): void {\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame)\n      this.animationFrame = null\n    }\n    if (this.rowInsertTimer) {\n      window.clearInterval(this.rowInsertTimer)\n      this.rowInsertTimer = null\n    }\n  }\n\n  public updateAim(event: MouseEvent): void {\n    const canvas = this.canvasRenderer.gameCanvas.value\n    if (!canvas || this.stateManager.shootingBubble.value) return\n    \n    const aimPosition = this.inputHandler.updateAim(event, canvas)\n    this.stateManager.updateAimLine(aimPosition)\n  }\n\n  public shootBubble(event: MouseEvent): void {\n    const canvas = this.canvasRenderer.gameCanvas.value\n    if (!canvas || this.stateManager.shootingBubble.value || !this.stateManager.currentShooterWord.value || this.rowAnimationActive) {\n      return\n    }\n    \n    const shootingVector = this.inputHandler.getShootingVector(\n      event,\n      canvas,\n      this.stateManager.shooterPosition.value\n    )\n    \n    if (!shootingVector) return\n    \n    // Hide aim line immediately after shooting\n    this.stateManager.updateAimLine(null)\n    \n    // Get current shooter word BEFORE it changes\n    const shooterWord = this.stateManager.currentShooterWord.value\n    const currentWordVocab = this.currentWords.find(vocab => vocab.word === shooterWord)\n\n    // Create shooting bubble with Vietnamese mode support\n    const bubble: Bubble = {\n      x: this.stateManager.shooterPosition.value.x,\n      y: this.stateManager.shooterPosition.value.y,\n      word: shooterWord,\n      color: this.stateManager.currentShooterColor.value,\n      id: `shooting-${Date.now()}`,\n      row: -1,\n      col: -1,\n      vietnameseMeaning: currentWordVocab?.meaning || '',\n      displayText: shooterWord.charAt(0).toUpperCase() // Shooter bubble always shows English first letter\n    }\n    \n    // Set as shooting bubble\n    this.stateManager.setShootingBubble(bubble)\n\n    // Speak EXACTLY the created bubble's English word to avoid mismatch (independent of toggle)\n    if (bubble.word) {\n      this.audioSystem.playVocabularySound(bubble.word, 'en')\n    }\n    \n    // Animate bubble with physics - CRITICAL FIX: Pass existing bubbles AND canvas dimensions\n    this.physicsEngine.animateShootingBubble(\n      bubble,\n      shootingVector.vx,\n      shootingVector.vy,\n      (landedBubble: Bubble) => this.handleBubbleLanded(landedBubble),\n      this.stateManager.bubbles.value, // Pass existing bubbles for immediate collision detection\n      this.canvasRenderer.canvasWidth.value, // Pass actual canvas width for responsive boundaries\n      this.canvasRenderer.canvasHeight.value // Pass actual canvas height for responsive boundaries\n    )\n    \n    // Select next word for shooter\n    this.stateManager.selectNextShooterWord(this.currentWords)\n  }\n\n  public restartGame(words: Vocabulary[]): void {\n    this.stopGameLoop()\n    this.currentWords = words\n    this.stateManager.resetGame()\n    \n    // Setup initial bubbles\n    const initialBubbles = this.gameLogic.setupInitialBubbles(words)\n    initialBubbles.forEach(bubble => this.stateManager.addBubble(bubble))\n    \n    this.stateManager.selectNextShooterWord(words)\n    this.startGameLoop()\n\n    // Re-arm row insertion timer after restart\n    if (this.rowInsertTimer) window.clearInterval(this.rowInsertTimer)\n    this.rowInsertTimer = window.setInterval(() => this.triggerRowInsertion(), this.ROW_INSERT_INTERVAL)\n  }\n\n  public updateVietnameseMode(enabled: boolean): void {\n    this.vietnameseMode = enabled\n    // Update display text for existing bubbles based on mode\n    this.stateManager.bubbles.value.forEach(bubble => {\n      if (enabled && bubble.vietnameseMeaning) {\n        // Switch to Vietnamese first 2 letters\n        bubble.displayText = bubble.vietnameseMeaning.substring(0, 2).toUpperCase()\n      } else {\n        // Switch back to English first 1 letter\n        bubble.displayText = bubble.word.charAt(0).toUpperCase()\n      }\n    })\n  }\n\n  private getShooterDisplayText(): string {\n    const word = this.stateManager.currentShooterWord.value\n    if (!word) return ''\n    \n    // Find the vocabulary item for this word to get Vietnamese meaning\n    const vocab = this.currentWords.find(w => w.word === word)\n    \n    if (this.vietnameseMode && vocab?.meaning) {\n      // Vietnamese mode: show first 2 letters of Vietnamese meaning\n      return vocab.meaning.substring(0, 2).toUpperCase()\n    } else {\n      // Normal mode: show first 1 letter of English word\n      return word.charAt(0).toUpperCase()\n    }\n  }\n\n  public cleanup(): void {\n    this.stopGameLoop()\n  }\n\n  private handleBubbleLanded(bubble: Bubble): void {\n    // Create impact effect and play sound\n    const impactEffect = this.visualEffects.createImpactEffect(bubble.x, bubble.y, bubble.color)\n    this.stateManager.addExplosion(impactEffect)\n    this.audioSystem.playImpactSound()\n    \n    // Clear the shooting bubble as it's about to land\n    this.stateManager.setShootingBubble(null)\n    \n    // VIETNAMESE MODE: Convert bubble to show Vietnamese first 2 letters when landed\n    if (this.vietnameseMode && bubble.vietnameseMeaning) {\n      bubble.displayText = bubble.vietnameseMeaning.substring(0, 2).toUpperCase()\n    } else {\n      // NORMAL MODE: Show English first 1 letter\n      bubble.displayText = bubble.word.charAt(0).toUpperCase()\n    }\n    \n    // Snap to grid\n    this.physicsEngine.snapToGrid(bubble, this.stateManager.bubbles.value)\n    \n    // Add bubble to game state\n    this.stateManager.addBubble(bubble)\n    \n    // Check if landed bubble hit a bomb\n    this.checkBombHits(bubble)\n    \n    // Check for matches\n    const matchResult = this.gameLogic.checkForMatches(bubble, this.stateManager.bubbles.value)\n    \n    if (matchResult.shouldRemove) {\n      // Create explosion effects for matched bubbles\n      matchResult.matchedBubbles.forEach(matchedBubble => {\n        const explosion = this.visualEffects.createExplosion(\n          matchedBubble.x, \n          matchedBubble.y, \n          matchedBubble.color\n        )\n        this.stateManager.addExplosion(explosion)\n      })\n      \n      // Remove matched bubbles\n      const bubbleIds = matchResult.matchedBubbles.map(b => b.id)\n      this.stateManager.removeBubbles(bubbleIds)\n      \n      // Update score and stats\n      const matchScore = this.gameLogic.calculateScore(matchResult.matchedBubbles.length, 0)\n      this.stateManager.updateScore(matchScore)\n      this.stateManager.incrementWordsMatched()\n      \n      // Play explosion sound\n      this.audioSystem.playExplosionSound()\n      \n      // Add screen shake\n      this.stateManager.addScreenShake(8)\n      \n      // Check for floating bubbles\n      this.handleFloatingBubbles()\n    }\n  }\n\n  private handleFloatingBubbles(): void {\n    const floatingResult = this.gameLogic.removeFloatingBubbles(this.stateManager.bubbles.value)\n    \n    if (floatingResult.removedBubbles.length > 0) {\n      // Create effects for floating bubbles\n      floatingResult.removedBubbles.forEach(floatingBubble => {\n        const effect = this.visualEffects.createImpactEffect(\n          floatingBubble.x,\n          floatingBubble.y,\n          floatingBubble.color\n        )\n        this.stateManager.addExplosion(effect)\n      })\n      \n      // Update bubbles list\n      this.stateManager.bubbles.value = floatingResult.remainingBubbles\n      \n      // Bonus points for floating bubbles\n      const bonusScore = this.gameLogic.calculateScore(0, floatingResult.removedBubbles.length)\n      this.stateManager.updateScore(bonusScore)\n    }\n  }\n\n  private checkBombHits(landedBubble: Bubble): void {\n    // Find adjacent bomb bubbles to the landed bubble\n    const adjacentBombs = this.stateManager.bubbles.value.filter(bubble => {\n      if (!bubble.isBomb) return false\n      const dx = bubble.x - landedBubble.x\n      const dy = bubble.y - landedBubble.y\n      const distance = Math.sqrt(dx * dx + dy * dy)\n      return distance <= this.physicsEngine.BUBBLE_SIZE * 1.1 // Adjacent or touching\n    })\n\n    // Increment hit count for each adjacent bomb\n    adjacentBombs.forEach(bomb => {\n      const currentHits = this.bombHits.get(bomb.id) || 0\n      const newHits = currentHits + 1\n      this.bombHits.set(bomb.id, newHits)\n      \n      console.log(`Bomb ${bomb.id} hit ${newHits}/2 times`)\n      \n      if (newHits >= 2) {\n        // Trigger massive explosion!\n        this.triggerMassiveExplosion(bomb)\n        this.bombHits.delete(bomb.id) // Reset hit count\n      }\n    })\n  }\n\n  private triggerMassiveExplosion(bombBubble: Bubble): void {\n    console.log('ðŸ’¥ MASSIVE BOMB EXPLOSION! DEVASTATION!')\n    \n    // Create multiple massive explosion effects\n    for (let i = 0; i < 3; i++) {\n      const offsetX = (Math.random() - 0.5) * this.physicsEngine.BUBBLE_SIZE * 2\n      const offsetY = (Math.random() - 0.5) * this.physicsEngine.BUBBLE_SIZE * 2\n      const massiveExplosion = this.visualEffects.createExplosion(\n        bombBubble.x + offsetX, \n        bombBubble.y + offsetY, \n        '#FF4444'\n      )\n      \n      // Make it MUCH bigger and more intense\n      massiveExplosion.shockwave.maxRadius = this.physicsEngine.BUBBLE_SIZE * 12\n      massiveExplosion.particles.forEach(particle => {\n        particle.size *= 4\n        particle.maxLife *= 3\n        particle.vx *= 3\n        particle.vy *= 3\n      })\n      \n      this.stateManager.addExplosion(massiveExplosion)\n    }\n    \n    // Add MASSIVE particle storm\n    for (let i = 0; i < 60; i++) {\n      const angle = (Math.PI * 2 * i) / 60\n      const speed = 20 + Math.random() * 15\n      const explosionParticles = {\n        x: bombBubble.x,\n        y: bombBubble.y,\n        particles: [{\n          x: bombBubble.x,\n          y: bombBubble.y,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed,\n          size: 12 + Math.random() * 8,\n          color: ['#FF2222', '#FF4444', '#FF6666', '#FFAA44', '#FFFF44', '#FF8844'][Math.floor(Math.random() * 6)],\n          life: 150,\n          maxLife: 150,\n          type: 'burst' as const,\n          rotation: 0,\n          rotationSpeed: (Math.random() - 0.5) * 0.5\n        }],\n        active: true,\n        shockwave: {\n          radius: 0,\n          maxRadius: this.physicsEngine.BUBBLE_SIZE * 10,\n          intensity: 1\n        },\n        radius: 0,\n        maxRadius: this.physicsEngine.BUBBLE_SIZE * 10,\n        intensity: 1\n      }\n      this.stateManager.addExplosion(explosionParticles)\n    }\n    \n    // MASSIVE destruction radius - destroy everything in large area\n    const explosionRadius = this.physicsEngine.BUBBLE_SIZE * 6\n    const bubblesInRange = this.stateManager.bubbles.value.filter(bubble => {\n      const dx = bubble.x - bombBubble.x\n      const dy = bubble.y - bombBubble.y\n      const distance = Math.sqrt(dx * dx + dy * dy)\n      return distance <= explosionRadius\n    })\n    \n    // Remove bubbles in explosion range\n    const bubbleIds = bubblesInRange.map(b => b.id)\n    this.stateManager.removeBubbles(bubbleIds)\n    \n    // Clean up bomb hits for removed bubbles\n    bubblesInRange.forEach(bubble => {\n      if (bubble.isBomb) {\n        this.bombHits.delete(bubble.id)\n      }\n    })\n    \n    // EXTREME screen shake and multiple sound effects\n    this.stateManager.addScreenShake(35)\n    this.audioSystem.playExplosionSound()\n    // Play multiple explosion sounds for dramatic effect\n    setTimeout(() => this.audioSystem.playExplosionSound(), 100)\n    setTimeout(() => this.audioSystem.playExplosionSound(), 200)\n    \n    // MASSIVE bonus points\n    this.stateManager.updateScore(1000 + bubblesInRange.length * 50)\n    \n    console.log(`ðŸ’¥ BOMB DEVASTATION: Destroyed ${bubblesInRange.length} bubbles!`)\n    \n    // Check for floating bubbles after explosion\n    const floatingResult = this.gameLogic.removeFloatingBubbles(this.stateManager.bubbles.value)\n    if (floatingResult.removedBubbles.length > 0) {\n      this.stateManager.removeBubbles(floatingResult.removedBubbles.map(b => b.id))\n      const floatingScore = this.gameLogic.calculateScore(0, floatingResult.removedBubbles.length)\n      this.stateManager.updateScore(floatingScore)\n    }\n  }\n}\n\nexport const useBubbleShooterGame = (): IBubbleShooterGame => {\n  return new BubbleShooterGame()\n}\n","<template>\n  <div class=\"bubble-shooter-game h-full min-h-[600px] sm:min-h-[500px] md:min-h-0 flex flex-col\">\n    <!-- Game Header -->\n    <div class=\"p-4 sm:p-6 md:p-8 bg-gradient-to-r from-purple-600 to-pink-600 dark:from-purple-800 dark:to-pink-800 text-white\">\n      <div class=\"flex justify-between items-center\">\n        <div>\n          <h2 class=\"text-lg sm:text-xl md:text-2xl font-bold\">{{ t('flashcard.bubbleShooter.title', 'Bubble Shooter') }}</h2>\n          <p class=\"text-sm sm:text-base opacity-90\">{{ t('flashcard.bubbleShooter.instruction', 'Shoot bubbles to match 4 or more words!') }}</p>\n        </div>\n        <div class=\"text-right\">\n          <div class=\"text-2xl sm:text-3xl font-bold\">{{ score }}</div>\n          <div class=\"text-xs sm:text-sm opacity-90\">{{ t('flashcard.bubbleShooter.score', 'Score') }}</div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Game Area -->\n    <div class=\"flex-1 min-h-[450px] sm:min-h-[350px] md:min-h-0 relative bg-gradient-to-b from-blue-100 to-blue-200 dark:from-[#0a0a0a] dark:to-[#0f0f0f] overflow-hidden\">\n      <canvas\n        ref=\"gameCanvas\"\n        class=\"w-full h-full cursor-crosshair\"\n        @click=\"shootBubble\"\n        @mousemove=\"updateAim\"\n      ></canvas>\n      \n      <!-- Aim Line -->\n      <svg \n        v-if=\"aimLine.visible\"\n        class=\"absolute inset-0 w-full h-full pointer-events-none\"\n        :viewBox=\"`0 0 ${canvasWidth} ${canvasHeight}`\"\n      >\n        <line \n          :x1=\"shooterPosition.x\" \n          :y1=\"shooterPosition.y\"\n          :x2=\"aimLine.x\" \n          :y2=\"aimLine.y\"\n          stroke=\"rgba(255,255,255,0.7)\" \n          stroke-width=\"2\" \n          stroke-dasharray=\"5,5\"\n        />\n      </svg>\n\n      <!-- Current Word Display -->\n      <div class=\"absolute bottom-20 left-1/2 transform -translate-x-1/2 bg-white dark:bg-[#0a0a0a] rounded-lg px-4 py-2 shadow-lg border-2 border-purple-500\">\n        <div class=\"text-center\">\n          <div class=\"text-lg sm:text-xl font-bold text-gray-800 dark:text-white\">{{ currentShooterWord }}</div>\n          <div class=\"text-xs sm:text-sm text-gray-600 dark:text-white/70\">{{ t('flashcard.bubbleShooter.currentWord', 'Current Word') }}</div>\n        </div>\n      </div>\n\n      <!-- Game Over Modal -->\n      <transition name=\"modal\" appear>\n        <div v-if=\"gameOver\" class=\"absolute inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center p-4\">\n          <div class=\"bg-white dark:bg-[#0a0a0a] rounded-2xl p-6 sm:p-8 max-w-md w-full text-center shadow-2xl border border-gray-200 dark:border-[#0f0f0f]\">\n            <!-- Animated Success Icon -->\n            <div class=\"w-16 h-16 sm:w-20 sm:h-20 mx-auto mb-4 bg-gradient-to-r from-green-400 to-blue-500 rounded-full flex items-center justify-center animate-pulse\">\n              <svg class=\"w-8 h-8 sm:w-10 sm:h-10 text-white\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n                <path fill-rule=\"evenodd\" d=\"M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z\" clip-rule=\"evenodd\"/>\n              </svg>\n            </div>\n            \n            <h3 class=\"text-xl sm:text-2xl font-bold mb-2 text-gray-800 dark:text-white\">\n              {{ t('flashcard.bubbleShooter.gameComplete', 'Game Complete!') }}\n            </h3>\n            <p class=\"text-gray-600 dark:text-white/70 mb-4\">\n              {{ t('flashcard.bubbleShooter.finalScore', { score }) }}\n            </p>\n            <p class=\"text-sm text-gray-500 dark:text-white/60 mb-6\">\n              {{ t('flashcard.bubbleShooter.wordsMatched', { count: wordsMatched }) }}\n            </p>\n            \n            <div class=\"flex gap-3 justify-center\">\n              <button \n                @click=\"restartGame\"\n                class=\"px-6 py-2 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-lg font-medium transform hover:scale-105 transition-all duration-200\"\n              >\n                {{ t('flashcard.bubbleShooter.playAgain', 'Play Again') }}\n              </button>\n              <button \n                @click=\"$emit('game-complete')\"\n                class=\"px-6 py-2 bg-gray-500 hover:bg-gray-600 dark:bg-[#0f0f0f] dark:hover:bg-[#1a1a1a] text-white rounded-lg font-medium transform hover:scale-105 transition-all duration-200\"\n              >\n                {{ t('common.finish', 'Finish') }}\n              </button>\n            </div>\n          </div>\n        </div>\n      </transition>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, onMounted, onUnmounted, nextTick, computed, watch } from 'vue'\nimport { useI18n } from 'vue-i18n'\nimport type { Vocabulary } from '../../../composables/useVocabularyStore'\nimport { useBubbleShooterGame, type IBubbleShooterGame, type Bubble } from '../composables/bubble-shooter'\n\ninterface Props {\n  words: Vocabulary[]\n  vietnameseMode?: boolean\n}\n\nconst props = defineProps<Props>()\nconst { t } = useI18n()\n\nconst emit = defineEmits<{\n  'game-complete': []\n}>()\n\n// Initialize main game controller with OOP pattern\nconst game: IBubbleShooterGame = useBubbleShooterGame()\n\n// Expose reactive properties for template binding (keeping original interface)\nconst gameCanvas = ref<HTMLCanvasElement>()\nconst canvasWidth = computed(() => game.canvasRenderer.canvasWidth.value)\nconst canvasHeight = computed(() => game.canvasRenderer.canvasHeight.value)\nconst score = computed(() => game.stateManager.score.value)\nconst wordsMatched = computed(() => game.stateManager.wordsMatched.value)\nconst gameOver = computed(() => game.stateManager.gameOver.value)\nconst currentShooterWord = computed(() => game.stateManager.currentShooterWord.value)\nconst currentShooterDisplay = computed(() => {\n  const word = game.stateManager.currentShooterWord.value\n  if (!word) return ''\n  \n  // Find the vocabulary item for this word to get Vietnamese meaning\n  const vocab = props.words.find(w => w.word === word)\n  \n  if (props.vietnameseMode && vocab?.meaning) {\n    // Vietnamese mode: show first 2 letters of Vietnamese meaning\n    return vocab.meaning.substring(0, 2).toUpperCase()\n  } else {\n    // Normal mode: show first 1 letter of English word\n    return word.charAt(0).toUpperCase()\n  }\n})\nconst aimLine = computed(() => game.stateManager.aimLine.value)\nconst shooterPosition = computed(() => game.stateManager.shooterPosition.value)\n\n// Watch for game over to emit completion event\nconst stopGameOverWatch = watch(\n  () => game.stateManager.gameOver.value,\n  (isGameOver) => {\n    if (isGameOver) {\n      emit('game-complete')\n    }\n  }\n)\n\nonMounted(async () => {\n  await nextTick()\n  if (!gameCanvas.value) return\n  game.initialize(gameCanvas.value, props.words, props.vietnameseMode)\n})\n\n// Watch for Vietnamese mode changes during gameplay\nwatch(() => props.vietnameseMode, (newValue) => {\n  game.updateVietnameseMode(newValue ?? false)\n})\n\nonUnmounted(() => {\n  stopGameOverWatch()\n  game.cleanup()\n})\n\nconst updateAim = (event: MouseEvent) => {\n  game.updateAim(event)\n}\n\nconst shootBubble = (event: MouseEvent) => {\n  game.shootBubble(event)\n}\n\nconst restartGame = () => {\n  game.stopGameLoop()\n  game.stateManager.resetGame()\n  if (gameCanvas.value) {\n    game.initialize(gameCanvas.value, props.words)\n  }\n}\n</script>\n\n<style scoped>\n.modal-enter-active, .modal-leave-active {\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.modal-enter-from, .modal-leave-to {\n  opacity: 0;\n  transform: scale(0.9) translateY(20px);\n}\n\n.bubble-shooter-game {\n  user-select: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n}\n</style>\n"],"names":["baseX","offsetX","_openBlock","_createElementBlock","_createElementVNode","_toDisplayString","_unref","_createVNode","_Transition","$emit"],"mappings":";;;AAYO,MAAM,iBAA8C;AAAA;AAAA,EAEzC,QAAqB,IAAI,CAAC;AAAA,EAC1B,eAA4B,IAAI,CAAC;AAAA,EACjC,WAAyB,IAAI,KAAK;AAAA,EAClC,UAAyB,IAAI,EAAE;AAAA,EAC/B,iBAAqC,IAAI,IAAI;AAAA,EAC7C,qBAAkC,IAAI,EAAE;AAAA,EACxC,sBAAmC,IAAI,SAAS;AAAA,EAChD,aAA+B,IAAI,EAAE;AAAA,EACrC,YAA6B,IAAI,EAAE;AAAA,EACnC,cAAgC,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG,WAAW,GAAG;AAAA,EAChE,UAAwB,IAAI,EAAE,SAAS,OAAO,GAAG,GAAG,GAAG,GAAG;AAAA,EAC1D,kBAAiC,IAAI,EAAE,GAAG,KAAK,GAAG,KAAK;AAAA,EACvD,qBAAmC,IAAI,KAAK;AAAA;AAAA,EAG3C,mCAAmB,IAAA;AAAA,EACnB,SAAS,CAAC,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,SAAS;AAAA;AAAA,EAG1G,YAAkB;AACvB,SAAK,MAAM,QAAQ;AACnB,SAAK,aAAa,QAAQ;AAC1B,SAAK,SAAS,QAAQ;AACtB,SAAK,QAAQ,QAAQ,CAAA;AACrB,SAAK,eAAe,QAAQ;AAC5B,SAAK,WAAW,QAAQ,CAAA;AACxB,SAAK,UAAU,QAAQ,CAAA;AACvB,SAAK,YAAY,QAAQ,EAAE,GAAG,GAAG,GAAG,GAAG,WAAW,EAAA;AAClD,SAAK,QAAQ,QAAQ,EAAE,SAAS,OAAO,GAAG,GAAG,GAAG,EAAA;AAChD,SAAK,mBAAmB,QAAQ;AAChC,SAAK,oBAAoB,QAAQ;AAAA,EACnC;AAAA,EAEO,YAAY,QAAsB;AACvC,SAAK,MAAM,SAAS;AAAA,EACtB;AAAA,EAEO,wBAA8B;AACnC,SAAK,aAAa,SAAS;AAAA,EAC7B;AAAA,EAEO,YAAY,UAAyB;AAC1C,SAAK,SAAS,QAAQ;AAAA,EACxB;AAAA,EAEO,sBAAsB,QAAuB;AAClD,SAAK,mBAAmB,QAAQ;AAAA,EAClC;AAAA;AAAA,EAGO,UAAU,QAAsB;AACrC,SAAK,QAAQ,MAAM,KAAK,MAAM;AAAA,EAChC;AAAA,EAEO,cAAc,WAA2B;AAC9C,SAAK,QAAQ,QAAQ,KAAK,QAAQ,MAAM;AAAA,MACtC,CAAA,WAAU,CAAC,UAAU,SAAS,OAAO,EAAE;AAAA,IAAA;AAAA,EAE3C;AAAA,EAEO,kBAAkB,QAA6B;AACpD,SAAK,eAAe,QAAQ;AAAA,EAC9B;AAAA,EAEO,sBAAsB,OAA2B;AACtD,QAAI,MAAM,SAAS,GAAG;AACpB,YAAM,aAAa,MAAM,KAAK,MAAM,KAAK,OAAA,IAAW,MAAM,MAAM,CAAC;AACjE,WAAK,mBAAmB,QAAQ,WAAW;AAC3C,WAAK,oBAAoB,QAAQ,KAAK,gBAAgB,WAAW,IAAI;AAAA,IACvE;AAAA,EACF;AAAA;AAAA,EAGO,cAAc,UAAiC;AACpD,QAAI,UAAU;AACZ,WAAK,QAAQ,QAAQ;AAAA,QACnB,SAAS;AAAA,QACT,GAAG,SAAS;AAAA,QACZ,GAAG,SAAS;AAAA,MAAA;AAAA,IAEhB,OAAO;AACL,WAAK,QAAQ,MAAM,UAAU;AAAA,IAC/B;AAAA,EACF;AAAA,EAEO,aAAa,WAA4B;AAC9C,SAAK,WAAW,MAAM,KAAK,SAAS;AAAA,EACtC;AAAA,EAEO,mBAAyB;AAC9B,SAAK,WAAW,MAAM,QAAQ,CAAA,cAAa;AACzC,UAAI,CAAC,UAAU,OAAQ;AAGvB,UAAI,UAAU,UAAU,SAAS,UAAU,UAAU,WAAW;AAC9D,kBAAU,UAAU,UAAU;AAC9B,kBAAU,UAAU,YAAY,KAAK,IAAI,GAAG,IAAK,UAAU,UAAU,SAAS,UAAU,UAAU,SAAU;AAAA,MAC9G;AAEA,UAAI,kBAAkB;AACtB,gBAAU,UAAU,QAAQ,CAAA,aAAY;AACtC,YAAI,SAAS,OAAO,GAAG;AAErB,mBAAS,KAAK,SAAS;AACvB,mBAAS,KAAK,SAAS;AAGvB,mBAAS,YAAY,SAAS;AAG9B,kBAAQ,SAAS,MAAA;AAAA,YACf,KAAK;AACH,uBAAS,MAAM;AACf,uBAAS,MAAM;AACf,uBAAS,MAAM;AACf,uBAAS,QAAQ;AACjB;AAAA,YACF,KAAK;AACH,uBAAS,MAAM;AACf,uBAAS,MAAM;AACf,uBAAS,MAAM;AACf,uBAAS,QAAQ;AACjB;AAAA,YACF,KAAK;AACH,uBAAS,MAAM;AACf,uBAAS,MAAM;AACf,uBAAS,MAAM;AACf,uBAAS,QAAQ;AACjB;AAAA,UAAA;AAGJ;AAAA,QACF;AAAA,MACF,CAAC;AAGD,UAAI,oBAAoB,KAAK,UAAU,UAAU,UAAU,UAAU,UAAU,WAAW;AACxF,kBAAU,SAAS;AAAA,MACrB;AAAA,IACF,CAAC;AAGD,SAAK,kBAAA;AAGL,SAAK,WAAW,QAAQ,KAAK,WAAW,MAAM,OAAO,CAAA,cAAa,UAAU,MAAM;AAAA,EACpF;AAAA;AAAA,EAGO,eAAe,WAAyB;AAC7C,SAAK,YAAY,MAAM,YAAY,KAAK,IAAI,KAAK,YAAY,MAAM,WAAW,SAAS;AAAA,EACzF;AAAA,EAEO,oBAA0B;AAC/B,QAAI,KAAK,YAAY,MAAM,YAAY,GAAG;AACxC,WAAK,YAAY,MAAM,KAAK,KAAK,WAAW,OAAO,KAAK,YAAY,MAAM;AAC1E,WAAK,YAAY,MAAM,KAAK,KAAK,WAAW,OAAO,KAAK,YAAY,MAAM;AAC1E,WAAK,YAAY,MAAM,aAAa;AAEpC,UAAI,KAAK,YAAY,MAAM,YAAY,KAAK;AAC1C,aAAK,YAAY,MAAM,YAAY;AACnC,aAAK,YAAY,MAAM,IAAI;AAC3B,aAAK,YAAY,MAAM,IAAI;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGQ,gBAAgB,MAAsB;AAC5C,QAAI,CAAC,KAAK,aAAa,IAAI,IAAI,GAAG;AAEhC,UAAI,OAAO;AACX,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,gBAAS,QAAQ,KAAK,OAAO,KAAK,WAAW,CAAC,IAAK;AAAA,MACrD;AACA,YAAM,aAAa,KAAK,IAAI,IAAI,IAAI,KAAK,OAAO;AAChD,WAAK,aAAa,IAAI,MAAM,KAAK,OAAO,UAAU,CAAC;AAAA,IACrD;AACA,WAAO,KAAK,aAAa,IAAI,IAAI;AAAA,EACnC;AACF;AAEO,MAAM,sBAAsB,MAAyB;AAC1D,SAAO,IAAI,iBAAA;AACb;ACpMO,MAAM,cAAwC;AAAA,EACnC,cAAc;AAAA,EACd,SAAS,CAAC,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,SAAS;AAAA;AAAA,EAEhG,cAAc;AAAA,EAEb,mCAAmB,IAAA;AAAA,EAC5B;AAAA,EAER,YAAY,cAAkC;AAC5C,SAAK,eAAe;AAAA,EACtB;AAAA,EAEO,gBAAgB,MAAsB;AAC3C,QAAI,CAAC,KAAK,aAAa,IAAI,IAAI,GAAG;AAEhC,UAAI,OAAO;AACX,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,gBAAS,QAAQ,KAAK,OAAO,KAAK,WAAW,CAAC,IAAK;AAAA,MACrD;AACA,YAAM,aAAa,KAAK,IAAI,IAAI,IAAI,KAAK,OAAO;AAChD,WAAK,aAAa,IAAI,MAAM,KAAK,OAAO,UAAU,CAAC;AAAA,IACrD;AACA,WAAO,KAAK,aAAa,IAAI,IAAI;AAAA,EACnC;AAAA,EAEO,eAAe,SAAiB,SAA0B;AAC/D,UAAM,KAAK,QAAQ,IAAI,QAAQ;AAC/B,UAAM,KAAK,QAAQ,IAAI,QAAQ;AAC/B,UAAM,WAAW,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AAE5C,WAAO,YAAY,KAAK;AAAA,EAC1B;AAAA,EAEO,sBACL,QACA,IACA,IACA,QACA,iBACA,cAAsB,KACtB,eAAuB,KACjB;AACN,QAAI,cAAc;AAClB,UAAM,aAAa;AACnB,QAAI,YAAY;AAChB,QAAI,YAAY;AAEhB,UAAM,UAAU,MAAM;AACpB,aAAO,KAAK;AACZ,aAAO,KAAK;AAGZ,UAAI,iBAAiB;AACnB,mBAAW,YAAY,iBAAiB;AAItC,gBAAM,cAAc,KAAK,cAAc,mBAAmB;AAC1D,gBAAM,WAAW,gBAAgB,SAAS,OAAO,KAAK;AACtD,gBAAM,YAAY,WACd,SAAS,IACR,eAAe,SAAS,YAAY,SAAY,SAAS,UAAU,SAAS;AACjF,gBAAM,YAAY,WACd,KAAK,cAAc,IAClB,eAAe,SAAS,YAAY,SAAY,SAAS,UAAU,SAAS;AAGjF,gBAAM,MAAM,OAAO,IAAI;AACvB,gBAAM,MAAM,OAAO,IAAI;AACvB,gBAAM,QAAQ,KAAK,KAAK,MAAM,MAAM,MAAM,GAAG;AAE7C,gBAAM,gBAAgB,KAAK,cAAc,KAAK;AAG9C,gBAAM,cAAe,MAAM,YAAY,MAAM,aAAc;AAE3D,cAAI,SAAS,iBAAiB,aAAa;AACzC,oBAAQ,IAAI,iFAAiF;AAG7F,gBAAI,KAAK;AACT,gBAAI,KAAK;AACT,gBAAI,OAAO;AAEX,gBAAI,OAAO,MAAM;AAEf,mBAAK,CAAC,aAAa;AACnB,mBAAK,CAAC,aAAa;AACnB,oBAAM,OAAO,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE,KAAK;AAC7C,oBAAM;AACN,oBAAM;AAAA,YACR,OAAO;AACL,oBAAM;AACN,oBAAM;AAAA,YACR;AAIA,kBAAM,WAAW,YAAY,KAAK,KAAK;AACvC,kBAAM,WAAW,YAAY,KAAK,KAAK;AAGvC,mBAAO,IAAI;AACX,mBAAO,IAAI;AAGX,gBAAI,iBAAiB;AACnB,mBAAK,WAAW,QAAQ,eAAe;AAEvC,mBAAK,uBAAuB,QAAQ,iBAAiB,aAAa,YAAY;AAAA,YAChF,OAAO;AACL,oBAAM,kBAAmB,KAAK,cAAc,KAAK,KAAK,CAAC,IAAK;AAC5D,oBAAM,QAAQ,KAAK,cAAc;AACjC,oBAAM,QAAQ,KAAK,cAAc;AACjC,qBAAO,MAAM,KAAK,IAAI,GAAG,KAAK,OAAO,OAAO,IAAI,SAAS,eAAe,CAAC;AACzE,qBAAO,MAAM,KAAK,IAAI,GAAG,KAAK,OAAO,OAAO,IAAI,SAAS,KAAK,WAAW,CAAC;AAAA,YAC5E;AAGA,wBAAY;AACZ,wBAAY;AAEZ,mBAAO,MAAM;AACb;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAGA,UAAI,OAAO,KAAK,KAAK,cAAc,KAAK,OAAO,KAAK,cAAc,KAAK,cAAc,GAAG;AACtF,oBAAY,CAAC,YAAY;AACzB;AAGA,eAAO,IAAI,KAAK,IAAI,KAAK,cAAc,GAAG,KAAK,IAAI,cAAc,KAAK,cAAc,GAAG,OAAO,CAAC,CAAC;AAAA,MAClG;AAGA,UAAI,OAAO,KAAK,KAAK,cAAc,GAAG;AACpC,eAAO,IAAI,KAAK,cAAc;AAG9B,cAAM,QAAQ,KAAK,cAAc;AACjC,cAAM,YAAY,KAAK,OAAO,OAAO,IAAI,SAAS,KAAK,WAAW;AAClE,eAAO,IAAI,QAAQ,YAAY,KAAK;AACpC,eAAO,MAAM;AACb,eAAO,MAAM,KAAK,IAAI,GAAG,SAAS;AAElC,oBAAY;AACZ,sBAAc;AAAA,MAChB;AAGA,UAAI,OAAO,KAAK,eAAe,KAAK,cAAc,GAAG;AAEnD,eAAO,IAAI,eAAe,KAAK,cAAc;AAC7C,oBAAY;AACZ,sBAAc;AAAA,MAChB;AAIA,UAAI,cAAc,KAAK,YAAY,GAAG;AACpC,qBAAa;AAAA,MACf;AAGA,YAAM,aAAa,KAAK,IAAI,SAAS,IAAI,KAAK,KAAK,IAAI,SAAS,IAAI;AACpE,YAAM,eAAe,OAAO,KAAK,KAAK,cAAc,IAAI;AACxD,YAAM,gBAAgB,OAAO,KAAK,cAAc,KAAK,cAAc,IAAI;AACvE,YAAM,cAAc,OAAO,KAAK,KAAK,cAAc,IAAI;AACvD,YAAM,cAAc,cAAc,MAC/B,eAAe,gBAAgB,kBAC/B,eAAe,KAAK,IAAI,SAAS,IAAI;AAGxC,UAAK,OAAO,KAAK,KAAK,cAAc,KAAK,aAAa,KAAM,eAAe,cAAc,aAAa;AAEpG,YAAI,mBAAmB,gBAAgB,SAAS,GAAG;AACjD,gBAAM,gBAAgB,KAAK,cAAc,KAAK;AAC9C,cAAI,UAAyB;AAC7B,cAAI,WAAW,OAAO;AACtB,qBAAW,KAAK,iBAAiB;AAC/B,kBAAM,cAAc,KAAK,cAAc,mBAAmB;AAC1D,kBAAM,WAAW,gBAAgB,EAAE,OAAO,KAAK;AAC/C,kBAAM,KAAK,WAAW,EAAE,IAAK,eAAe,EAAE,YAAY,SAAY,EAAE,UAAU,EAAE;AACpF,kBAAM,KAAK,WAAW,KAAK,cAAc,IAAK,eAAe,EAAE,YAAY,SAAY,EAAE,UAAU,EAAE;AACrG,kBAAM,KAAK,OAAO,IAAI;AACtB,kBAAM,KAAK,OAAO,IAAI;AACtB,kBAAM,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AAErC,kBAAM,MAAM,KAAK,YAAY,KAAK;AAClC,gBAAI,MAAM,EAAG;AACb,gBAAI,IAAI,iBAAiB,IAAI,UAAU;AACrC,wBAAU;AACV,yBAAW;AAAA,YACb;AAAA,UACF;AAEA,cAAI,SAAS;AAEX,kBAAM,eAAe,KAAK,cAAc,mBAAmB;AAC3D,kBAAM,YAAY,iBAAiB,QAAQ,OAAO,KAAK;AACvD,kBAAM,KAAK,YAAY,QAAQ,IAAK,gBAAgB,QAAQ,YAAY,SAAY,QAAQ,UAAU,QAAQ;AAC9G,kBAAM,KAAK,YAAY,KAAK,cAAc,IAAK,gBAAgB,QAAQ,YAAY,SAAY,QAAQ,UAAU,QAAQ;AACzH,gBAAI,MAAM,OAAO,IAAI;AACrB,gBAAI,MAAM,OAAO,IAAI;AACrB,kBAAM,OAAO,KAAK,KAAK,MAAM,MAAM,MAAM,GAAG,KAAK;AACjD,mBAAO;AACP,mBAAO;AACP,kBAAM,WAAW,KAAK,MAAM,KAAK;AACjC,kBAAM,WAAW,KAAK,MAAM,KAAK;AAGjC,kBAAM,SAAS,KAAK;AAAA,cAClB;AAAA,cACA;AAAA,cACA,EAAE,GAAG,UAAU,GAAG,SAAA;AAAA,cAClB;AAAA,cACA;AAAA,YAAA;AAEF,kBAAM,SAAS,SAAS,OAAO,IAAI;AACnC,kBAAM,SAAS,SAAS,OAAO,IAAI;AAEnC,mBAAO,IAAI;AACX,mBAAO,IAAI;AACX,iBAAK,WAAW,QAAQ,eAAe;AAEvC,iBAAK,uBAAuB,QAAQ,iBAAiB,aAAa,YAAY;AAE9E,mBAAO,MAAM;AACb;AAAA,UACF;AAAA,QACF;AAGA,eAAO,MAAM;AACb;AAAA,MACF;AAEA,4BAAsB,OAAO;AAAA,IAC/B;AACA,YAAA;AAAA,EACF;AAAA;AAAA;AAAA,EAIQ,0BACN,UACA,iBACA,cACA,aACA,cACiC;AACjC,UAAM,IAAI,KAAK;AACf,UAAM,QAAQ,KAAK,cAAc;AAGjC,UAAM,gBAAgB,CAAC,IAAY,IAAY,IAAY,OAA2C;AACpG,YAAM,KAAK,KAAK;AAChB,YAAM,KAAK,KAAK;AAChB,YAAM,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AACrC,UAAI,IAAI,QAAQ,IAAI,IAAI,UAAU,CAAA;AAClC,YAAM,IAAI,IAAI;AACd,YAAM,KAAK,IAAI,IAAI,IAAI;AACvB,UAAI,KAAK,MAAO,QAAO,CAAA;AACvB,YAAM,IAAI,KAAK,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,EAAE,CAAC,IAAI;AAChD,YAAM,KAAK,KAAM,IAAI,KAAM;AAC3B,YAAM,KAAK,KAAM,IAAI,KAAM;AAC3B,YAAM,KAAM,CAAC,KAAK,IAAK;AACvB,YAAM,KAAM,KAAK,IAAK;AACtB,aAAO;AAAA,QACL,EAAE,GAAG,KAAK,IAAI,GAAG,KAAK,GAAA;AAAA,QACtB,EAAE,GAAG,KAAK,IAAI,GAAG,KAAK,GAAA;AAAA,MAAG;AAAA,IAE7B;AAGA,UAAM,WAAW,CAAC,GAAW,MAC3B,KAAK,SAAS,KAAK,cAAc,SAAS,KAAK,SAAS,KAAK,eAAe;AAI9E,UAAM,eAAe,CAAC,GAAW,MAAc;AAC7C,iBAAW,KAAK,iBAAiB;AAC/B,cAAM,KAAK,EAAE,IAAI;AACjB,cAAM,KAAK,EAAE,IAAI;AACjB,cAAM,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AACrC,YAAI,IAAI,KAAK,cAAc,IAAK,QAAO;AAAA,MACzC;AACA,aAAO;AAAA,IACT;AAGA,UAAM,YAAY,gBAAgB,OAAO,CAAA,MAAK,MAAM,QAAQ,EAAE,OAAO,CAAA,MAAK;AACxE,YAAM,KAAK,EAAE,IAAI,SAAS;AAC1B,YAAM,KAAK,EAAE,IAAI,SAAS;AAC1B,YAAM,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AACrC,aAAO,IAAI,MAAM,KAAK,eAAe,IAAI,MAAM,KAAK;AAAA,IACtD,CAAC;AAED,QAAI,OAAwC;AAC5C,QAAI,YAAY,OAAO;AAEvB,eAAW,MAAM,WAAW;AAC1B,YAAM,MAAM,cAAc,SAAS,GAAG,SAAS,GAAG,GAAG,GAAG,GAAG,CAAC;AAC5D,iBAAW,KAAK,KAAK;AACnB,YAAI,CAAC,SAAS,EAAE,GAAG,EAAE,CAAC,EAAG;AACzB,YAAI,CAAC,aAAa,EAAE,GAAG,EAAE,CAAC,EAAG;AAE7B,cAAM,KAAK,EAAE,IAAI,aAAa;AAC9B,cAAM,KAAK,EAAE,IAAI,aAAa;AAC9B,cAAM,QAAQ,KAAK,KAAK,KAAK;AAC7B,YAAI,QAAQ,WAAW;AACrB,iBAAO;AACP,sBAAY;AAAA,QACd;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA,EAGQ,kBAAkB,iBAAmC;AAC3D,QAAI,CAAC,mBAAmB,gBAAgB,WAAW,EAAG,QAAO,KAAK,cAAc;AAChF,UAAM,kBAAmB,KAAK,cAAc,KAAK,KAAK,CAAC,IAAK;AAC5D,UAAM,UAAU,KAAK,cAAc;AAGnC,UAAM,cAAc,KAAK,cAAc,mBAAmB;AAE1D,QAAI,aAAa;AAGf,YAAM,mBAAmB,gBAAgB,OAAO,QAAM,EAAE,OAAO,MAAM,CAAC;AACtE,UAAI,iBAAiB,WAAW,EAAG,QAAO;AAG1C,YAAM,SAAS,KAAK,IAAI,GAAG,iBAAiB,IAAI,CAAA,MAAK,EAAE,OAAO,CAAC,CAAC;AAChE,YAAM,YAAY,UAAU,SAAS;AAErC,cAAQ,IAAI,2CAA2C,QAAQ,qBAAqB,SAAS;AAC7F,aAAO;AAAA,IACT,OAAO;AAEL,YAAM,SAAS,KAAK,IAAI,GAAG,gBAAgB,IAAI,CAAA,MAAK,EAAE,OAAO,CAAC,CAAC;AAC/D,YAAM,YAAY,UAAU,SAAS;AAErC,cAAQ,IAAI,wCAAwC,QAAQ,qBAAqB,SAAS;AAC1F,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA,EAGQ,cAAc,KAAa,KAAa,iBAAqD;AACnG,UAAM,kBAAmB,KAAK,cAAc,KAAK,KAAK,CAAC,IAAK;AAC5D,UAAM,QAAQ,KAAK,cAAc;AACjC,UAAM,QAAQ,KAAK,kBAAkB,eAAe;AACpD,UAAM,YAAY,KAAK,gBAAgB,eAAe;AACtD,UAAM,YAAY,MAAM,MAAM,IAAI,YAAa,cAAc,IAAI,KAAK,cAAc,IAAI;AACxF,UAAM,IAAI,QAAQ,YAAY,MAAM,KAAK;AACzC,UAAM,IAAI,QAAQ,MAAM;AACxB,WAAO,EAAE,GAAG,EAAA;AAAA,EACd;AAAA;AAAA;AAAA,EAIQ,gBAAgB,iBAAmC;AACzD,UAAM,IAAI,KAAK;AACf,UAAM,QAAQ,IAAI;AAClB,UAAM,cAAc,KAAK,cAAc,mBAAmB;AAC1D,UAAM,OAAO,gBAAgB,OAAO,QAAM,EAAE,OAAO,OAAO,CAAC;AAC3D,QAAI,KAAK,WAAW,EAAG,QAAO;AAC9B,QAAI,UAAU;AACd,QAAI,SAAS;AACb,eAAW,KAAK,MAAM;AACpB,YAAM,KAAK,eAAe,EAAE,YAAY,SAAY,EAAE,UAAU,EAAE;AAClE,YAAM,cAAc,QAAQ,KAAK,OAAO,KAAK,SAAS,CAAC,IAAI;AAC3D,YAAM,aAAa,QAAQ,IAAI,IAAI,KAAK,OAAO,MAAM,QAAQ,IAAI,MAAM,CAAC,IAAI;AAC5E,iBAAW,KAAK,IAAI,KAAK,WAAW;AACpC,gBAAW,KAAK,IAAI,KAAK,UAAU;AAAA,IACrC;AACA,WAAO,WAAW,SAAS,IAAI,IAAI;AAAA,EACrC;AAAA;AAAA,EAGQ,eAAe,GAAW,GAAW,iBAAoC;AAC/E,UAAM,UAAU;AAChB,UAAM,cAAc,KAAK,cAAc,mBAAmB;AAE1D,eAAW,KAAK,iBAAiB;AAE/B,YAAM,UAAU,eAAe,EAAE,YAAY,SAAY,EAAE,UAAU,EAAE;AACvE,YAAM,UAAU,eAAe,EAAE,YAAY,SAAY,EAAE,UAAU,EAAE;AAEvE,YAAM,KAAK,UAAU;AACrB,YAAM,KAAK,UAAU;AACrB,YAAM,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AACrC,UAAI,KAAK,QAAS,QAAO;AAAA,IAC3B;AACA,WAAO;AAAA,EACT;AAAA;AAAA,EAGQ,uBACN,QACA,iBACA,aACA,cACM;AACN,UAAM,QAAQ,KAAK,cAAc;AACjC,UAAM,WAAW,CAAC,GAAW,MAC3B,KAAK,SAAS,KAAK,cAAc,SAAS,KAAK,SAAS,KAAK,eAAe;AAI9E,QAAI,SAAS,KAAK,cAAc,OAAO,KAAM,OAAO,KAAM,eAAe;AACzE,QAAI,SAAS,OAAO,GAAG,OAAO,CAAC,KAAK,CAAC,KAAK,eAAe,OAAO,GAAG,OAAO,GAAG,eAAe,GAAG;AAC7F,aAAO,IAAI,OAAO;AAClB,aAAO,IAAI,OAAO;AAClB;AAAA,IACF;AAGA,QAAI,OAAkE;AACtE,QAAI,YAAY,OAAO;AACvB,UAAM,YAAY;AAClB,aAAS,KAAK,CAAC,WAAW,MAAM,WAAW,MAAM;AAC/C,YAAM,KAAK,KAAK,IAAI,GAAG,OAAO,MAAO,EAAE;AACvC,eAAS,KAAK,CAAC,WAAW,MAAM,WAAW,MAAM;AAC/C,cAAM,KAAK,KAAK,IAAI,GAAG,OAAO,MAAO,EAAE;AACvC,iBAAS,KAAK,cAAc,IAAI,IAAI,eAAe;AACnD,YAAI,CAAC,SAAS,OAAO,GAAG,OAAO,CAAC,EAAG;AACnC,YAAI,KAAK,eAAe,OAAO,GAAG,OAAO,GAAG,eAAe,EAAG;AAC9D,cAAM,KAAK,OAAO,IAAI,OAAO;AAC7B,cAAM,KAAK,OAAO,IAAI,OAAO;AAC7B,cAAM,QAAQ,KAAK,KAAK,KAAK;AAC7B,YAAI,QAAQ,WAAW;AACrB,sBAAY;AACZ,iBAAO,EAAE,KAAK,IAAI,KAAK,IAAI,GAAG,OAAO,GAAG,GAAG,OAAO,EAAA;AAAA,QACpD;AAAA,MACF;AAAA,IACF;AAEA,QAAI,MAAM;AACR,aAAO,MAAM,KAAK;AAClB,aAAO,MAAM,KAAK;AAClB,aAAO,IAAI,KAAK;AAChB,aAAO,IAAI,KAAK;AAAA,IAClB,OAAO;AAEL,aAAO,IAAI,KAAK,IAAI,OAAO,KAAK,IAAI,cAAc,OAAO,OAAO,CAAC,CAAC;AAClE,aAAO,IAAI,KAAK,IAAI,OAAO,KAAK,IAAI,eAAe,OAAO,OAAO,CAAC,CAAC;AAAA,IACrE;AAAA,EACF;AAAA,EAEO,WAAW,QAAgB,iBAAiC;AACjE,YAAQ,IAAI,8CAA8C,OAAO,GAAG,OAAO,CAAC;AAI5E,UAAM,kBAAmB,KAAK,cAAc,KAAK,KAAK,CAAC,IAAK;AAC5D,UAAM,QAAQ,KAAK,cAAc;AAGjC,UAAM,QAAQ,KAAK,kBAAkB,eAAe;AAGpD,UAAM,YAAY,KAAK,IAAI,GAAG,KAAK,OAAO,OAAO,IAAI,SAAS,eAAe,CAAC;AAG9E,UAAM,YAAY,KAAK,gBAAgB,eAAe;AACtD,UAAM,UAAU,YAAY,MAAM,IAAI,YAAa,cAAc,IAAI,KAAK,cAAc,IAAI;AAE5F,UAAM,YAAY,KAAK,IAAI,GAAG,KAAK,OAAO,OAAO,IAAI,QAAQ,WAAW,KAAK,WAAW,CAAC;AAGzF,WAAO,MAAM;AACb,WAAO,MAAM;AAEb,YAAQ,IAAI,8BAA8B,OAAO,OAAO,GAAG,SAAS,OAAO,GAAG,IAAI,uBAAuB,OAAO,GAAG,OAAO,CAAC;AAAA,EAC7H;AAAA,EAEO,aAAa,OAAe,QAAwB;AACzD,UAAM,MAAM,SAAS,MAAM,QAAQ,KAAK,EAAE,GAAG,EAAE;AAC/C,UAAM,MAAM,KAAK,MAAM,OAAO,SAAS,GAAG;AAC1C,UAAM,KAAK,OAAO,MAAM;AACxB,UAAM,KAAK,OAAO,IAAI,OAAU;AAChC,UAAM,KAAK,MAAM,OAAY;AAC7B,WAAO,OAAO,YAAa,IAAI,MAAM,IAAI,IAAI,IAAI,IAAI,OAAO,SACvD,IAAI,MAAM,IAAI,IAAI,IAAI,IAAI,OAAO,OACjC,IAAI,MAAM,IAAI,IAAI,IAAI,IAAI,MAC5B,SAAS,EAAE,EAAE,MAAM,CAAC;AAAA,EACzB;AACF;AAEO,MAAM,mBAAmB,CAAC,iBAAqD;AACpF,SAAO,IAAI,cAAc,YAAY;AACvC;ACpfO,MAAM,cAAwC;AAAA,EAClC,cAAc;AAAA,EAExB,mBAAmB,GAAW,GAAsB;AACzD,UAAM,iBAA6B,CAAA;AAGnC,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,YAAM,QAAQ,KAAK,OAAA,IAAW,KAAK,KAAK;AACxC,YAAM,QAAQ,IAAI,KAAK,OAAA,IAAW;AAElC,qBAAe,KAAK;AAAA,QAClB;AAAA,QACA;AAAA,QACA,IAAI,KAAK,IAAI,KAAK,IAAI;AAAA,QACtB,IAAI,KAAK,IAAI,KAAK,IAAI;AAAA,QACtB,MAAM,IAAI,KAAK,OAAA;AAAA,QACf,OAAO;AAAA,QACP,MAAM;AAAA,QACN,SAAS;AAAA,QACT,MAAM;AAAA,QACN,UAAU;AAAA,QACV,eAAe;AAAA,MAAA,CAChB;AAAA,IACH;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,WAAW;AAAA,MACX,QAAQ;AAAA,MACR,WAAW;AAAA,QACT,QAAQ;AAAA,QACR,WAAW,KAAK,cAAc;AAAA,QAC9B,WAAW;AAAA,MAAA;AAAA,IACb;AAAA,EAEJ;AAAA,EAEO,mBAAmB,GAAW,GAAW,OAA0B;AACxE,UAAM,iBAA6B,CAAA;AAGnC,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,YAAM,QAAQ,KAAK,OAAA,IAAW,KAAK,KAAK;AACxC,YAAM,QAAQ,IAAI,KAAK,OAAA,IAAW;AAElC,qBAAe,KAAK;AAAA,QAClB;AAAA,QACA;AAAA,QACA,IAAI,KAAK,IAAI,KAAK,IAAI;AAAA,QACtB,IAAI,KAAK,IAAI,KAAK,IAAI;AAAA,QACtB,MAAM,IAAI,KAAK,OAAA,IAAW;AAAA,QAC1B;AAAA,QACA,MAAM;AAAA,QACN,SAAS;AAAA,QACT,MAAM;AAAA,QACN,UAAU,KAAK,OAAA,IAAW,KAAK,KAAK;AAAA,QACpC,gBAAgB,KAAK,OAAA,IAAW,OAAO;AAAA,MAAA,CACxC;AAAA,IACH;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,WAAW;AAAA,MACX,QAAQ;AAAA,MACR,WAAW;AAAA,QACT,QAAQ;AAAA,QACR,WAAW,KAAK;AAAA,QAChB,WAAW;AAAA,MAAA;AAAA,IACb;AAAA,EAEJ;AAAA,EAEO,gBAAgB,GAAW,GAAW,OAA0B;AACrE,UAAM,iBAA6B,CAAA;AAGnC,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,YAAM,QAAS,KAAK,KAAK,IAAI,IAAK;AAClC,YAAM,QAAQ,IAAI,KAAK,OAAA,IAAW;AAElC,qBAAe,KAAK;AAAA,QAClB;AAAA,QACA;AAAA,QACA,IAAI,KAAK,IAAI,KAAK,IAAI;AAAA,QACtB,IAAI,KAAK,IAAI,KAAK,IAAI;AAAA,QACtB,MAAM,IAAI,KAAK,OAAA,IAAW;AAAA,QAC1B;AAAA,QACA,MAAM;AAAA,QACN,SAAS;AAAA,QACT,MAAM;AAAA,QACN,UAAU,KAAK,OAAA,IAAW,KAAK,KAAK;AAAA,QACpC,gBAAgB,KAAK,OAAA,IAAW,OAAO;AAAA,MAAA,CACxC;AAAA,IACH;AAGA,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,YAAM,QAAQ,KAAK,OAAA,IAAW,KAAK,KAAK;AACxC,YAAM,QAAQ,IAAI,KAAK,OAAA,IAAW;AAElC,qBAAe,KAAK;AAAA,QAClB;AAAA,QACA;AAAA,QACA,IAAI,KAAK,IAAI,KAAK,IAAI;AAAA,QACtB,IAAI,KAAK,IAAI,KAAK,IAAI;AAAA,QACtB,MAAM,IAAI,KAAK,OAAA,IAAW;AAAA,QAC1B,OAAO;AAAA,QACP,MAAM;AAAA,QACN,SAAS;AAAA,QACT,MAAM;AAAA,QACN,UAAU;AAAA,QACV,eAAe;AAAA,MAAA,CAChB;AAAA,IACH;AAGA,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,YAAM,QAAQ,KAAK,OAAA,IAAW,KAAK,KAAK;AACxC,YAAM,QAAQ,IAAI,KAAK,OAAA,IAAW;AAElC,qBAAe,KAAK;AAAA,QAClB;AAAA,QACA;AAAA,QACA,IAAI,KAAK,IAAI,KAAK,IAAI;AAAA,QACtB,IAAI,KAAK,IAAI,KAAK,IAAI;AAAA,QACtB,MAAM,IAAI,KAAK,OAAA,IAAW;AAAA,QAC1B,OAAO,KAAK,aAAa,OAAO,GAAG;AAAA,QACnC,MAAM;AAAA,QACN,SAAS;AAAA,QACT,MAAM;AAAA,QACN,UAAU,KAAK,OAAA,IAAW,KAAK,KAAK;AAAA,QACpC,gBAAgB,KAAK,OAAA,IAAW,OAAO;AAAA,MAAA,CACxC;AAAA,IACH;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,WAAW;AAAA,MACX,QAAQ;AAAA,MACR,WAAW;AAAA,QACT,QAAQ;AAAA,QACR,WAAW,KAAK,cAAc;AAAA,QAC9B,WAAW;AAAA,MAAA;AAAA,IACb;AAAA,EAEJ;AAAA,EAEO,gBAAgB,WAA6B;AAClD,cAAU,QAAQ,CAAA,aAAY;AAC5B,UAAI,SAAS,OAAO,GAAG;AAErB,iBAAS,KAAK,SAAS;AACvB,iBAAS,KAAK,SAAS;AAGvB,iBAAS,YAAY,SAAS;AAG9B,gBAAQ,SAAS,MAAA;AAAA,UACf,KAAK;AACH,qBAAS,MAAM;AACf,qBAAS,MAAM;AACf,qBAAS,MAAM;AACf,qBAAS,QAAQ;AACjB;AAAA,UACF,KAAK;AACH,qBAAS,MAAM;AACf,qBAAS,MAAM;AACf,qBAAS,MAAM;AACf,qBAAS,QAAQ;AACjB;AAAA,UACF,KAAK;AACH,qBAAS,MAAM;AACf,qBAAS,MAAM;AACf,qBAAS,MAAM;AACf,qBAAS,QAAQ;AACjB;AAAA,QAAA;AAAA,MAEN;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,aAAa,OAAe,QAAwB;AAC1D,UAAM,MAAM,SAAS,MAAM,QAAQ,KAAK,EAAE,GAAG,EAAE;AAC/C,UAAM,MAAM,KAAK,MAAM,OAAO,SAAS,GAAG;AAC1C,UAAM,KAAK,OAAO,MAAM;AACxB,UAAM,KAAK,OAAO,IAAI,OAAU;AAChC,UAAM,KAAK,MAAM,OAAY;AAC7B,WAAO,OAAO,YAAa,IAAI,MAAM,IAAI,IAAI,IAAI,IAAI,OAAO,SACvD,IAAI,MAAM,IAAI,IAAI,IAAI,IAAI,OAAO,OACjC,IAAI,MAAM,IAAI,IAAI,IAAI,IAAI,MAC5B,SAAS,EAAE,EAAE,MAAM,CAAC;AAAA,EACzB;AACF;AAEO,MAAM,mBAAmB,MAAsB;AACpD,SAAO,IAAI,cAAA;AACb;ACxMO,MAAM,eAA0C;AAAA,EACrC,cAA2B,IAAI,GAAG;AAAA,EAClC,eAA4B,IAAI,GAAG;AAAA,EACnC,aAAiD,IAAA;AAAA,EAEzD,MAAuC;AAAA,EAC9B,cAAc;AAAA,EAExB,mBAA4B;AACjC,QAAI,CAAC,KAAK,WAAW,MAAO,QAAO;AAEnC,UAAM,SAAS,KAAK,WAAW;AAC/B,SAAK,MAAM,OAAO,WAAW,IAAI;AACjC,QAAI,CAAC,KAAK,IAAK,QAAO;AAGtB,UAAM,YAAY,OAAO;AACzB,QAAI,WAAW;AACb,WAAK,YAAY,QAAQ,UAAU;AACnC,WAAK,aAAa,QAAQ,UAAU;AACpC,aAAO,QAAQ,KAAK,YAAY;AAChC,aAAO,SAAS,KAAK,aAAa;AAAA,IACpC;AAEA,WAAO;AAAA,EACT;AAAA,EAEO,cAAc,OAAe,QAAsB;AACxD,SAAK,YAAY,QAAQ;AACzB,SAAK,aAAa,QAAQ;AAC1B,QAAI,KAAK,WAAW,OAAO;AACzB,WAAK,WAAW,MAAM,QAAQ;AAC9B,WAAK,WAAW,MAAM,SAAS;AAAA,IACjC;AAAA,EACF;AAAA,EAEO,cAAoB;AACzB,QAAI,CAAC,KAAK,IAAK;AACf,SAAK,IAAI,UAAU,GAAG,GAAG,KAAK,YAAY,OAAO,KAAK,aAAa,KAAK;AAAA,EAC1E;AAAA,EAEO,iBAAuB;AAC5B,QAAI,CAAC,KAAK,IAAK;AAGf,UAAM,WAAW,KAAK,IAAI,qBAAqB,GAAG,GAAG,GAAG,KAAK,aAAa,KAAK;AAC/E,aAAS,aAAa,GAAG,SAAS;AAClC,aAAS,aAAa,GAAG,SAAS;AAClC,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,SAAS,GAAG,GAAG,KAAK,YAAY,OAAO,KAAK,aAAa,KAAK;AAAA,EACzE;AAAA,EAEO,WAAW,QAAsB;AACtC,QAAI,CAAC,KAAK,IAAK;AAGf,UAAM,KAAK,KAAK,MAAM,OAAO,IAAI,CAAC,IAAI;AACtC,UAAM,KAAK,KAAK,MAAM,OAAO,IAAI,CAAC,IAAI;AAEtC,UAAM,IAAI,KAAK,cAAc,IAAI;AAGjC,SAAK,IAAI,KAAA;AACT,SAAK,IAAI,cAAc,OAAO;AAC9B,SAAK,IAAI,aAAa;AAGtB,UAAM,WAAW,KAAK,IAAI;AAAA,MACxB,KAAK,KAAK,cAAc;AAAA,MAAG,KAAK,KAAK,cAAc;AAAA,MAAG;AAAA,MACtD;AAAA,MAAI;AAAA,MAAI;AAAA,IAAA;AAEV,aAAS,aAAa,GAAG,KAAK,aAAa,OAAO,OAAO,GAAG,CAAC;AAC7D,aAAS,aAAa,GAAG,OAAO,KAAK;AAErC,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,UAAA;AACT,SAAK,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,KAAK,KAAK,CAAC;AACtC,SAAK,IAAI,KAAA;AAGT,SAAK,IAAI,cAAc;AACvB,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,OAAA;AAGT,SAAK,IAAI,cAAc;AACvB,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,UAAA;AACT,SAAK,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,KAAK,KAAK,CAAC;AAC1C,SAAK,IAAI,OAAA;AAET,SAAK,IAAI,QAAA;AAGT,SAAK,IAAI,KAAA;AACT,SAAK,IAAI,cAAc;AACvB,SAAK,IAAI,aAAa;AACtB,SAAK,IAAI,gBAAgB;AACzB,SAAK,IAAI,gBAAgB;AAEzB,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,OAAO;AAChB,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,eAAe;AAGxB,UAAM,OAAO,OAAO,eAAe,OAAO,KAAK,OAAO,CAAC,EAAE,YAAA;AAEzD,QAAI,OAAO,QAAQ;AAEjB,YAAM,OAAO,KAAK,IAAA,IAAQ;AAC1B,YAAM,QAAQ,MAAM,MAAM,KAAK,IAAI,OAAO,CAAC;AAE3C,WAAK,IAAI,KAAA;AACT,WAAK,IAAI,MAAM,OAAO,KAAK;AAC3B,WAAK,IAAI,YAAY;AACrB,WAAK,IAAI,OAAO;AAChB,WAAK,IAAI,SAAS,MAAM,KAAK,QAAQ,KAAK,KAAK,KAAK;AACpD,WAAK,IAAI,QAAA;AAGT,WAAK,IAAI,YAAY;AACrB,WAAK,IAAI,OAAO;AAChB,WAAK,IAAI,SAAS,MAAM,IAAI,KAAK,EAAE;AAGnC,WAAK,IAAI,cAAc;AACvB,WAAK,IAAI,YAAY;AACrB,WAAK,IAAI,YAAY,CAAC,GAAG,CAAC,CAAC;AAC3B,WAAK,IAAI,UAAA;AACT,WAAK,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,KAAK,KAAK,CAAC;AAC1C,WAAK,IAAI,OAAA;AACT,WAAK,IAAI,YAAY,EAAE;AAAA,IACzB,OAAO;AAEL,WAAK,IAAI,SAAS,MAAM,IAAI,EAAE;AAAA,IAChC;AACA,SAAK,IAAI,QAAA;AAAA,EACX;AAAA,EAEO,YAAY,UAAoB,MAAc,OAAe,aAA4B;AAC9F,QAAI,CAAC,KAAK,IAAK;AAGf,SAAK,IAAI,KAAA;AAGT,UAAM,iBAAiB,MAAM,MAAM,KAAK,IAAI,KAAK,IAAA,IAAQ,IAAK;AAC9D,SAAK,IAAI,cAAc;AACvB,SAAK,IAAI,aAAa,KAAK;AAG3B,UAAM,WAAW,KAAK,IAAI;AAAA,MACxB,SAAS,IAAI,KAAK,cAAc;AAAA,MAAG,SAAS,IAAI,KAAK,cAAc;AAAA,MAAG;AAAA,MACtE,SAAS;AAAA,MAAG,SAAS;AAAA,MAAG,KAAK,cAAc;AAAA,IAAA;AAE7C,aAAS,aAAa,GAAG,KAAK;AAC9B,aAAS,aAAa,GAAG,KAAK;AAE9B,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,UAAA;AACT,SAAK,IAAI,IAAI,SAAS,GAAG,SAAS,GAAG,KAAK,cAAc,GAAG,GAAG,KAAK,KAAK,CAAC;AACzE,SAAK,IAAI,KAAA;AAGT,SAAK,IAAI,cAAc;AACvB,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,OAAA;AAGT,SAAK,IAAI,cAAc;AACvB,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,UAAA;AACT,SAAK,IAAI,IAAI,SAAS,GAAG,SAAS,GAAG,KAAK,cAAc,IAAI,GAAG,GAAG,KAAK,KAAK,CAAC;AAC7E,SAAK,IAAI,OAAA;AAET,SAAK,IAAI,QAAA;AAGT,SAAK,IAAI,KAAA;AACT,SAAK,IAAI,cAAc;AACvB,SAAK,IAAI,aAAa;AACtB,SAAK,IAAI,gBAAgB;AACzB,SAAK,IAAI,gBAAgB;AAEzB,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,OAAO;AAChB,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,eAAe;AAGxB,UAAM,OAAO,eAAe,KAAK,OAAO,CAAC,EAAE,YAAA;AAE3C,SAAK,IAAI,SAAS,MAAM,SAAS,GAAG,SAAS,CAAC;AAC9C,SAAK,IAAI,QAAA;AAAA,EACX;AAAA,EAEO,mBAAmB,QAAsB;AAC9C,QAAI,CAAC,KAAK,IAAK;AAGf,SAAK,IAAI,KAAA;AAGT,SAAK,IAAI,cAAc,OAAO;AAC9B,SAAK,IAAI,aAAa;AAGtB,UAAM,iBAAiB,OAAO,OAAO,KAAK,IAAI,KAAK,IAAA,IAAQ,IAAI;AAG/D,UAAM,KAAK,KAAK,MAAM,OAAO,IAAI,CAAC,IAAI;AACtC,UAAM,KAAK,KAAK,MAAM,OAAO,IAAI,CAAC,IAAI;AACtC,UAAM,KAAK,KAAK,cAAc,IAAI;AAClC,UAAM,WAAW,KAAK,IAAI;AAAA,MACxB,KAAK,KAAK,cAAc;AAAA,MAAG,KAAK,KAAK,cAAc;AAAA,MAAG;AAAA,MACtD;AAAA,MAAI;AAAA,MAAI;AAAA,IAAA;AAEV,aAAS,aAAa,GAAG,KAAK,aAAa,OAAO,OAAO,GAAG,CAAC;AAC7D,aAAS,aAAa,GAAG,OAAO,KAAK;AAErC,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,UAAA;AACT,SAAK,IAAI,IAAI,IAAI,IAAI,KAAK,gBAAgB,GAAG,KAAK,KAAK,CAAC;AACxD,SAAK,IAAI,KAAA;AAGT,SAAK,IAAI,cAAc;AACvB,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,OAAA;AAGT,SAAK,IAAI,cAAc;AACvB,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,UAAA;AACT,SAAK,IAAI,IAAI,IAAI,KAAK,KAAK,KAAK,gBAAgB,GAAG,KAAK,KAAK,CAAC;AAC9D,SAAK,IAAI,OAAA;AAET,SAAK,IAAI,QAAA;AAGT,SAAK,IAAI,KAAA;AACT,SAAK,IAAI,cAAc;AACvB,SAAK,IAAI,aAAa;AACtB,SAAK,IAAI,gBAAgB;AACzB,SAAK,IAAI,gBAAgB;AAEzB,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,OAAO;AAChB,SAAK,IAAI,YAAY;AACrB,SAAK,IAAI,eAAe;AAGxB,UAAM,OAAO,OAAO,eAAe,OAAO,KAAK,OAAO,CAAC,EAAE,YAAA;AAEzD,SAAK,IAAI,SAAS,MAAM,IAAI,EAAE;AAC9B,SAAK,IAAI,QAAA;AAAA,EACX;AAAA,EAEO,eAAe,YAA+B;AACnD,QAAI,CAAC,KAAK,IAAK;AAEf,eAAW,QAAQ,CAAA,cAAa;AAC9B,UAAI,CAAC,UAAU,UAAU,CAAC,KAAK,IAAK;AAGpC,UAAI,UAAU,UAAU,YAAY,GAAG;AACrC,aAAK,IAAI,KAAA;AACT,aAAK,IAAI,cAAc,UAAU,UAAU,YAAY;AACvD,aAAK,IAAI,cAAc;AACvB,aAAK,IAAI,YAAY;AACrB,aAAK,IAAI,UAAA;AACT,aAAK,IAAI,IAAI,UAAU,GAAG,UAAU,GAAG,UAAU,UAAU,QAAQ,GAAG,KAAK,KAAK,CAAC;AACjF,aAAK,IAAI,OAAA;AACT,aAAK,IAAI,QAAA;AAAA,MACX;AAGA,gBAAU,UAAU,QAAQ,CAAA,aAAY;AACtC,YAAI,SAAS,QAAQ,KAAK,CAAC,KAAK,IAAK;AAErC,cAAM,QAAQ,SAAS,OAAO,SAAS;AACvC,aAAK,IAAI,KAAA;AACT,aAAK,IAAI,UAAU,SAAS,GAAG,SAAS,CAAC;AACzC,aAAK,IAAI,OAAO,SAAS,QAAQ;AACjC,aAAK,IAAI,cAAc;AAGvB,gBAAQ,SAAS,MAAA;AAAA,UACf,KAAK;AAEH,iBAAK,IAAI,cAAc,SAAS;AAChC,iBAAK,IAAI,aAAa,SAAS,OAAO;AACtC,iBAAK,IAAI,YAAY,SAAS;AAC9B,iBAAK,IAAI,UAAA;AACT,iBAAK,IAAI,IAAI,GAAG,GAAG,SAAS,OAAO,OAAO,GAAG,KAAK,KAAK,CAAC;AACxD,iBAAK,IAAI,KAAA;AACT;AAAA,UAEF,KAAK;AAEH,iBAAK,IAAI,cAAc,SAAS;AAChC,iBAAK,IAAI,YAAY,SAAS,OAAO;AACrC,iBAAK,IAAI,UAAU;AACnB,iBAAK,IAAI,UAAA;AACT,iBAAK,IAAI,OAAO,CAAC,SAAS,MAAM,CAAC;AACjC,iBAAK,IAAI,OAAO,SAAS,MAAM,CAAC;AAChC,iBAAK,IAAI,OAAA;AACT;AAAA,UAEF,KAAK;AAEH,kBAAM,WAAW,KAAK,IAAI,qBAAqB,GAAG,GAAG,GAAG,GAAG,GAAG,SAAS,OAAO,KAAK;AACnF,qBAAS,aAAa,GAAG,SAAS,KAAK;AACvC,qBAAS,aAAa,GAAG,aAAa;AACtC,iBAAK,IAAI,YAAY;AACrB,iBAAK,IAAI,UAAA;AACT,iBAAK,IAAI,IAAI,GAAG,GAAG,SAAS,OAAO,OAAO,GAAG,KAAK,KAAK,CAAC;AACxD,iBAAK,IAAI,KAAA;AACT;AAAA,QAAA;AAGJ,aAAK,IAAI,QAAA;AAAA,MACX,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEO,YAAY,SAAkB,iBAAiC;AACpE,QAAI,CAAC,KAAK,OAAO,CAAC,QAAQ,QAAS;AAEnC,UAAM,MAAM,KAAK;AACjB,QAAI,cAAc;AAClB,QAAI,YAAY;AAChB,QAAI,YAAY,CAAC,GAAG,CAAC,CAAC;AAGtB,UAAM,QAAQ,KAAK,cAAc;AACjC,UAAM,SAAS,KAAK,YAAY,QAAQ,KAAK,cAAc;AAC3D,UAAM,OAAO,KAAK,cAAc;AAEhC,QAAI,KAAK,gBAAgB;AACzB,QAAI,KAAK,gBAAgB;AAGzB,QAAI,KAAK,QAAQ,IAAI,gBAAgB;AACrC,QAAI,KAAK,QAAQ,IAAI,gBAAgB;AACrC,UAAM,MAAM,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE,KAAK;AAC5C,UAAM;AACN,UAAM;AAGN,QAAI,KAAK,MAAO,MAAK;AAErB,QAAI,UAAA;AACJ,QAAI,OAAO,IAAI,EAAE;AAEjB,QAAI,UAAU;AACd,UAAM,aAAa;AACnB,QAAI,YAAY;AAChB,WAAO,WAAW,cAAc,cAAc,IAAI;AAEhD,YAAM,QAAQ,OAAO,MAAM;AAG3B,UAAI,QAAQ,OAAO;AACnB,UAAI,QAAQ;AACZ,UAAI,KAAK,GAAG;AACV,iBAAS,SAAS,MAAM;AACxB,gBAAQ;AAAA,MACV,WAAW,KAAK,GAAG;AACjB,iBAAS,QAAQ,MAAM;AACvB,gBAAQ;AAAA,MACV;AAGA,YAAM,OAAO,KAAK;AAAA,QAChB,OAAO,IAAI,OAAO,OAAO;AAAA,QACzB,QAAQ,IAAI,QAAQ,OAAO;AAAA,MAAA;AAI7B,YAAM,KAAK,KAAK,KAAK;AACrB,YAAM,KAAK,KAAK,KAAK;AACrB,UAAI,OAAO,IAAI,EAAE;AAGjB,UAAI,OAAO,KAAK,QAAQ,OAAO,MAAM;AACnC;AAAA,MACF;AAGA,WAAK;AACL,WAAK;AACL,WAAK,CAAC;AACN;AAGA,UAAI,OAAO,IAAI,EAAE;AAAA,IACnB;AAEA,QAAI,OAAA;AACJ,QAAI,YAAY,EAAE;AAGlB,QAAI,cAAc;AAClB,QAAI,aAAa;AACjB,QAAI,OAAA;AACJ,QAAI,aAAa;AAAA,EACnB;AAAA,EAEQ,aAAa,OAAe,QAAwB;AAC1D,UAAM,MAAM,SAAS,MAAM,QAAQ,KAAK,EAAE,GAAG,EAAE;AAC/C,UAAM,MAAM,KAAK,MAAM,OAAO,SAAS,GAAG;AAC1C,UAAM,KAAK,OAAO,MAAM;AACxB,UAAM,KAAK,OAAO,IAAI,OAAU;AAChC,UAAM,KAAK,MAAM,OAAY;AAC7B,WAAO,OAAO,YAAa,IAAI,MAAM,IAAI,IAAI,IAAI,IAAI,OAAO,SACvD,IAAI,MAAM,IAAI,IAAI,IAAI,IAAI,OAAO,OACjC,IAAI,MAAM,IAAI,IAAI,IAAI,IAAI,MAC5B,SAAS,EAAE,EAAE,MAAM,CAAC;AAAA,EACzB;AACF;AAEO,MAAM,oBAAoB,MAAuB;AACtD,SAAO,IAAI,eAAA;AACb;AC1aO,MAAM,aAAsC;AAAA,EAC1C,UAAU,OAAmB,QAA4C;AAE9E,UAAM,OAAO,OAAO,sBAAA;AAGpB,UAAM,SAAS,OAAO,QAAQ,KAAK;AACnC,UAAM,SAAS,OAAO,SAAS,KAAK;AAGpC,UAAM,UAAU,MAAM,UAAU,KAAK,QAAQ;AAC7C,UAAM,UAAU,MAAM,UAAU,KAAK,OAAO;AAE5C,YAAQ,IAAI,UAAU,MAAM,OAAO,KAAK,MAAM,OAAO,cAAc,MAAM,KAAK,MAAM,aAAa,OAAO,QAAQ,CAAC,CAAC,KAAK,OAAO,QAAQ,CAAC,CAAC,EAAE;AAG1I,UAAM,WAAW,OAAO,QAAQ;AAChC,UAAM,WAAW,OAAO,SAAS;AAGjC,UAAM,KAAK,SAAS;AACpB,UAAM,KAAK,SAAS;AACpB,UAAM,WAAW,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AAG5C,QAAI,SAAS,WAAW,MAAM,WAAW,IAAI;AAC3C,aAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAG;AAAA,MAAA;AAAA,IAEP;AAEA,WAAO;AAAA,EACT;AAAA,EAEO,kBACL,OACA,QACA,iBACmC;AAEnC,UAAM,OAAO,OAAO,sBAAA;AACpB,QAAI,CAAC,KAAM,QAAO;AAGlB,UAAM,SAAS,OAAO,QAAQ,KAAK;AACnC,UAAM,SAAS,OAAO,SAAS,KAAK;AAGpC,UAAM,WAAW,MAAM,UAAU,KAAK,QAAQ;AAC9C,UAAM,WAAW,MAAM,UAAU,KAAK,OAAO;AAE7C,YAAQ,IAAI,gBAAgB,OAAO,KAAK,OAAO,iBAAiB,MAAM,OAAO,KAAK,MAAM,OAAO,GAAG;AAGlG,UAAM,cAAc;AACpB,UAAM,QAAQ,cAAc;AAC5B,UAAM,SAAS,OAAO,QAAQ,cAAc;AAC5C,UAAM,OAAO,cAAc;AAG3B,QAAI,KAAK,UAAU,gBAAgB;AACnC,QAAI,KAAK,UAAU,gBAAgB;AACnC,UAAM,OAAO,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE,KAAK;AAC7C,UAAM;AACN,UAAM;AACN,QAAI,KAAK,MAAO,MAAK;AAGrB,QAAI,KAAK,gBAAgB;AACzB,QAAI,KAAK,gBAAgB;AACzB,QAAI,UAAU;AACd,UAAM,aAAa;AACnB,QAAI,OAAO;AACX,QAAI,OAAO;AACX,WAAO,WAAW,YAAY;AAC5B,YAAM,QAAQ,OAAO,MAAM;AAC3B,UAAI,QAAQ,OAAO;AAEnB,UAAI,KAAK,GAAG;AACV,iBAAS,SAAS,MAAM;AAAA,MAE1B,WAAW,KAAK,GAAG;AACjB,iBAAS,QAAQ,MAAM;AAAA,MAEzB;AACA,YAAM,OAAO,KAAK;AAAA,QAChB,OAAO,IAAI,OAAO,OAAO;AAAA,QACzB,QAAQ,IAAI,QAAQ,OAAO;AAAA,MAAA;AAE7B,aAAO,KAAK,KAAK;AACjB,aAAO,KAAK,KAAK;AAEjB;AAAA,IACF;AAGA,UAAM,KAAK,OAAO,gBAAgB;AAClC,UAAM,KAAK,OAAO,gBAAgB;AAClC,UAAM,WAAW,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE,KAAK;AACjD,UAAM,QAAQ;AACd,UAAM,eAAgB,KAAK,WAAY;AACvC,UAAM,eAAgB,KAAK,WAAY;AAEvC,YAAQ,IAAI,6BAA6B,aAAa,QAAQ,CAAC,CAAC,QAAQ,aAAa,QAAQ,CAAC,CAAC,EAAE;AAEjG,WAAO,EAAE,IAAI,cAAc,IAAI,aAAA;AAAA,EACjC;AACF;AAEO,MAAM,kBAAkB,MAAqB;AAClD,SAAO,IAAI,aAAA;AACb;AC/GO,MAAM,UAAgC;AAAA,EAC1B,cAAc;AAAA,EACd,SAAS,CAAC,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,SAAS;AAAA,EAE1G,gBAAgB,WAAmB,SAGxC;AACA,YAAQ,IAAI,gCAAgC,UAAU,MAAM,UAAU,GAAG,UAAU,CAAC;AAGpF,UAAM,8BAAc,IAAA;AACpB,UAAM,mBAA6B,CAAA;AAEnC,UAAM,gBAAgB,CAAC,WAAmB;AACxC,UAAI,QAAQ,IAAI,OAAO,EAAE,EAAG;AAC5B,cAAQ,IAAI,OAAO,EAAE;AACrB,uBAAiB,KAAK,MAAM;AAE5B,cAAQ,IAAI,2BAA2B,OAAO,MAAM,OAAO,GAAG,OAAO,CAAC;AAGtE,cAAQ,QAAQ,CAAA,UAAS;AACvB,YAAI,MAAM,OAAO,OAAO,MAAM,CAAC,QAAQ,IAAI,MAAM,EAAE,KAAK,MAAM,SAAS,OAAO,MAAM;AAClF,gBAAM,KAAK,MAAM,IAAI,OAAO;AAC5B,gBAAM,KAAK,MAAM,IAAI,OAAO;AAC5B,gBAAM,WAAW,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AAE5C,kBAAQ,IAAI,oBAAoB,OAAO,IAAI,QAAQ,MAAM,IAAI,KAAK,QAAQ,kBAAkB,KAAK,WAAW,EAAE;AAG9G,cAAI,YAAY,KAAK,cAAc,KAAK;AACtC,oBAAQ,IAAI,0BAA0B,MAAM,MAAM,MAAM,GAAG,MAAM,CAAC;AAClE,0BAAc,KAAK;AAAA,UACrB;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAEA,kBAAc,SAAS;AAEvB,YAAQ,IAAI,SAAS,iBAAiB,MAAM,uBAAuB,iBAAiB,IAAI,CAAA,MAAK,EAAE,IAAI,CAAC;AAGpG,UAAM,eAAe,iBAAiB,UAAU;AAChD,QAAI,cAAc;AAChB,cAAQ,IAAI,kCAAkC,iBAAiB,IAAI,CAAA,MAAK,EAAE,IAAI,CAAC;AAAA,IACjF,OAAO;AACL,cAAQ,IAAI,yCAAyC;AAAA,IACvD;AAEA,WAAO;AAAA,MACL,gBAAgB;AAAA,MAChB;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEO,sBAAsB,SAG3B;AAEA,UAAM,mCAAmB,IAAA;AAEzB,UAAM,mBAAmB,CAAC,WAAmB;AAC3C,UAAI,aAAa,IAAI,OAAO,EAAE,EAAG;AACjC,mBAAa,IAAI,OAAO,EAAE;AAG1B,cAAQ,QAAQ,CAAA,UAAS;AACvB,YAAI,MAAM,OAAO,OAAO,MAAM,CAAC,aAAa,IAAI,MAAM,EAAE,GAAG;AACzD,gBAAM,KAAK,MAAM,IAAI,OAAO;AAC5B,gBAAM,KAAK,MAAM,IAAI,OAAO;AAC5B,gBAAM,WAAW,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AAE5C,cAAI,YAAY,KAAK,cAAc,KAAK;AACtC,6BAAiB,KAAK;AAAA,UACxB;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAGA,YAAQ,QAAQ,CAAA,WAAU;AACxB,UAAI,OAAO,QAAQ,GAAG;AACpB,yBAAiB,MAAM;AAAA,MACzB;AAAA,IACF,CAAC;AAGD,UAAM,mBAAmB,QAAQ,OAAO,CAAA,WAAU,aAAa,IAAI,OAAO,EAAE,CAAC;AAC7E,UAAM,iBAAiB,QAAQ,OAAO,CAAA,WAAU,CAAC,aAAa,IAAI,OAAO,EAAE,CAAC;AAE5E,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEO,oBAAoB,OAAqB,iBAA0B,OAAiB;AACzF,UAAM,UAAoB,CAAA;AAG1B,UAAM,kBAAmB,KAAK,cAAc,KAAK,KAAK,CAAC,IAAK;AAC5D,UAAM,QAAQ,KAAK,cAAc;AACjC,UAAM,QAAQ,KAAK,cAAc;AACjC,UAAM,gBAAgB;AAEtB,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AAErC,YAAM,MAAM,KAAK,MAAM,IAAI,aAAa;AACxC,YAAM,MAAM,IAAI;AAGhB,YAAM,UAAU,MAAM,MAAM,IAAI,IAAI,KAAK,cAAc;AAGvD,YAAM,IAAI,QAAQ,UAAU,MAAM,KAAK;AACvC,YAAM,IAAI,QAAQ,MAAM;AAExB,YAAM,SAAiB;AAAA,QACrB;AAAA,QACA;AAAA,QACA,MAAM,MAAM,CAAC,EAAE;AAAA,QACf,OAAO,KAAK,gBAAgB,MAAM,CAAC,EAAE,IAAI;AAAA;AAAA,QACzC,IAAI,WAAW,CAAC;AAAA,QAChB;AAAA,QACA;AAAA,QACA,mBAAmB,MAAM,CAAC,EAAE;AAAA;AAAA,QAC5B,aAAa,kBAAkB,MAAM,CAAC,EAAE,UACpC,MAAM,CAAC,EAAE,QAAQ,UAAU,GAAG,CAAC,EAAE,YAAA,IACjC,MAAM,CAAC,EAAE,KAAK,OAAO,CAAC,EAAE,YAAA;AAAA;AAAA,MAAY;AAG1C,cAAQ,KAAK,MAAM;AAAA,IACrB;AAEA,WAAO;AAAA,EACT;AAAA,EAEO,UAAU,SAA4B;AAC3C,WAAO,QAAQ,WAAW;AAAA,EAC5B;AAAA,EAEO,eAAe,gBAAwB,iBAAiC;AAC7E,WAAQ,iBAAiB,KAAO,kBAAkB;AAAA,EACpD;AAAA,EAEQ,gBAAgB,MAAsB;AAE5C,QAAI,OAAO;AACX,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,cAAS,QAAQ,KAAK,OAAO,KAAK,WAAW,CAAC,IAAK;AAAA,IACrD;AACA,UAAM,aAAa,KAAK,IAAI,IAAI,IAAI,KAAK,OAAO;AAChD,WAAO,KAAK,OAAO,UAAU;AAAA,EAC/B;AACF;AAEO,MAAM,eAAe,MAAkB;AAC5C,SAAO,IAAI,UAAA;AACb;AC/IO,MAAM,kBAAgD;AAAA;AAAA,EAE3C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGR,iBAAgC;AAAA,EAChC,eAA6B,CAAA;AAAA,EAC7B,iBAA0B;AAAA;AAAA,EAG1B,iBAAgC;AAAA,EACvB,sBAAsB;AAAA,EAC/B,qBAAqB;AAAA;AAAA,EAGrB,+BAAe,IAAA;AAAA;AAAA,EACf,oBAAoB;AAAA,EACX,uBAAuB;AAAA;AAAA,EAChC,iBAAyB;AAAA;AAAA,EACzB,mCAAmB,IAAA;AAAA,EACnB,mCAAmB,IAAA;AAAA,EACnB,gBAA0B,CAAA;AAAA,EAC1B,mCAAmB,IAAA;AAAA,EAE3B,cAAc;AAEZ,SAAK,eAAe,oBAAA;AAGpB,SAAK,cAAc,eAAA;AACnB,SAAK,gBAAgB,iBAAiB,KAAK,YAAY;AACvD,SAAK,gBAAgB,iBAAA;AACrB,SAAK,iBAAiB,kBAAA;AACtB,SAAK,eAAe,gBAAA;AACpB,SAAK,YAAY,aAAA;AAGjB,SAAK,iBAAkB,KAAK,cAAc,cAAc,KAAK,KAAK,CAAC,IAAK;AAAA,EAC1E;AAAA;AAAA,EAGQ,sBAA4B;AAClC,QAAI,KAAK,sBAAsB,KAAK,aAAa,SAAS,MAAO;AACjE,QAAI,KAAK,aAAa,eAAe,MAAO;AAE5C,SAAK,qBAAqB;AAC1B,SAAK,aAAa,sBAAsB,IAAI;AAC5C,SAAK,oBAAoB,YAAY,IAAA;AACrC,SAAK,aAAa,MAAA;AAClB,SAAK,aAAa,MAAA;AAClB,SAAK,gBAAgB,CAAA;AACrB,SAAK,aAAa,MAAA;AAGlB,SAAK,aAAa,QAAQ,MAAM,QAAQ,CAAA,MAAK;AAC3C,WAAK,aAAa,IAAI,EAAE,IAAI,EAAE,CAAC;AAC/B,WAAK,aAAa,IAAI,EAAE,IAAI,EAAE,CAAC;AAI/B,YAAM,kBAAmB,KAAK,cAAc,cAAc,KAAK,KAAK,CAAC,IAAK;AAC1E,YAAMA,SAAQ,KAAK,cAAc,cAAc;AAC/C,YAAM,QAAQ,KAAK,cAAc,cAAc;AAC/C,YAAMC,YAAW,EAAE,OAAO,KAAK,MAAM,IAAI,IAAI,KAAK,cAAc,cAAc;AAE9E,QAAE,UAAUD,SAAQC,YAAW,EAAE,OAAO,KAAK,KAAK,cAAc;AAChE,QAAE,UAAU,SAAS,EAAE,OAAO,KAAK;AAAA,IACrC,CAAC;AAGD,UAAM,IAAI,KAAK,cAAc;AAC7B,UAAM,QAAQ,IAAI;AAClB,UAAM,aAAa,KAAK,aAAa,QAAQ,MAAM,OAAO,CAAA,OAAM,EAAE,OAAO,OAAO,CAAC;AACjF,UAAM,eAAe,CAAC,GAAWA,aAAoB;AACnD,YAAM,OAAO,KAAK,OAAO,KAAK,QAAQA,aAAY,CAAC;AACnD,aAAO,QAAQA,WAAU,OAAO;AAAA,IAClC;AACA,QAAI,UAAU,GAAG,SAAS;AAC1B,QAAI,WAAW,SAAS,GAAG;AACzB,iBAAW,QAAQ,CAAA,MAAK;AACtB,mBAAW,KAAK,IAAI,EAAE,IAAI,aAAa,EAAE,GAAG,CAAC,CAAC;AAC9C,kBAAW,KAAK,IAAI,EAAE,IAAI,aAAa,EAAE,GAAG,IAAI,CAAC,CAAC;AAAA,MACpD,CAAC;AAAA,IACH;AACA,UAAM,gBAAgB,WAAW,WAAW,IAAI,IAAK,WAAW,SAAS,IAAI,IAAI;AACjF,UAAM,oBAAoB,kBAAkB,IAAI,IAAI,IAAI;AAIxD,UAAM,UAAU,KAAK,eAAe,YAAY,SAAS;AACzD,UAAM,UAAU;AAChB,UAAM,QAAQ,KAAK,cAAc;AACjC,UAAM,gBAAgB,KAAK,IAAI,GAAG,KAAK,OAAO,UAAU,KAAK,WAAW,KAAK,CAAC;AAC9E,aAAS,MAAM,GAAG,MAAM,eAAe,OAAO;AAC5C,YAAM,QAAQ,KAAK,aAAa,KAAK,MAAM,KAAK,OAAA,IAAW,KAAK,IAAI,GAAG,KAAK,aAAa,MAAM,CAAC,CAAC;AACjG,YAAM,OAAO,OAAO,QAAQ;AAC5B,YAAM,QAAQ,KAAK,cAAc,gBAAgB,IAAI;AACrD,YAAM,IAAI,MAAM,KAAK,cAAc,cAAc,KAAK,cAAc,cAAc,IAAI;AACtF,YAAM,SAAS,CAAC,KAAK,cAAc;AAGnC,YAAM,SAAS,KAAK,OAAA,IAAW;AAE/B,YAAM,SAAiB;AAAA,QACrB;AAAA,QACA,GAAG;AAAA,QACH;AAAA,QACA,OAAO,SAAS,YAAY;AAAA;AAAA,QAC5B,IAAI,OAAO,KAAK,IAAA,CAAK,IAAI,GAAG;AAAA,QAC5B,KAAK;AAAA,QACL;AAAA,QACA,mBAAmB,OAAO,WAAW;AAAA,QACrC,aAAa,KAAK,kBAAkB,OAAO,UACvC,MAAM,QAAQ,UAAU,GAAG,CAAC,EAAE,gBAC9B,KAAK,OAAO,CAAC,EAAE,YAAA;AAAA,QACnB;AAAA,MAAA;AAEF,WAAK,aAAa,UAAU,MAAM;AAClC,WAAK,cAAc,KAAK,MAAM;AAC9B,WAAK,aAAa,IAAI,OAAO,IAAI,MAAM,EAAE;AAAA,IAC3C;AAAA,EACF;AAAA,EAEQ,8BAAoC;AAC1C,QAAI,CAAC,KAAK,mBAAoB;AAE9B,UAAM,MAAM,YAAY,IAAA;AACxB,UAAM,UAAU,MAAM,KAAK;AAC3B,UAAM,IAAI,KAAK,IAAI,GAAG,UAAU,KAAK,oBAAoB;AACzD,UAAM,OAAO,IAAI,KAAK,IAAI,IAAI,GAAG,CAAC;AAGlC,SAAK,aAAa,QAAQ,MAAM,QAAQ,CAAA,MAAK;AAC3C,UAAI,KAAK,aAAa,IAAI,EAAE,EAAE,EAAG;AACjC,YAAM,SAAS,KAAK,aAAa,IAAI,EAAE,EAAE;AACzC,YAAM,SAAS,KAAK,aAAa,IAAI,EAAE,EAAE;AACzC,UAAI,UAAU,MAAM;AAClB,UAAE,IAAI,SAAS,OAAO,KAAK;AAAA,MAC7B;AACA,UAAI,UAAU,MAAM;AAClB,UAAE,IAAI;AAAA,MACR;AAAA,IACF,CAAC;AAGD,UAAM,aAAa,KAAK,cAAc,cAAc;AAEpD,UAAM,aAAa,aAAa,OAAO,KAAK;AAC5C,UAAM,UAAU;AAChB,UAAM,WAAW,KAAK,aAAa,QAAQ,MAAM,OAAO,CAAA,MAAK,CAAC,KAAK,aAAa,IAAI,EAAE,EAAE,MAAO,EAAE,OAAO,OAAO,CAAE;AACjH,QAAI,gBAAgB;AACpB,eAAW,MAAM,KAAK,eAAe;AACnC,YAAM,QAAQ,KAAK,aAAa,IAAI,GAAG,EAAE,KAAK;AAC9C,YAAM,eAAe,KAAK,IAAI,GAAG,UAAU,KAAK;AAChD,YAAM,KAAK,KAAK,IAAI,GAAG,eAAe,KAAK,IAAI,GAAG,KAAK,uBAAuB,KAAK,CAAC;AACpF,YAAM,QAAQ,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC;AACpC,YAAM,SAAS,CAAC,KAAK,cAAc;AACnC,YAAM,WAAW,UAAU,aAAa,UAAU;AAElD,UAAI,UAAU,aAAa,KAAK,iBAAiB;AAEjD,UAAI,SAAS,SAAS,GAAG;AACvB,YAAI,UAAU,SAAS,CAAC;AACxB,YAAI,SAAS,KAAK,IAAI,QAAQ,IAAI,GAAG,CAAC;AACtC,iBAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,gBAAM,KAAK,KAAK,IAAI,SAAS,CAAC,EAAE,IAAI,GAAG,CAAC;AACxC,cAAI,KAAK,QAAQ;AACf,qBAAS;AACT,sBAAU,SAAS,CAAC;AAAA,UACtB;AAAA,QACF;AACA,cAAM,IAAI,KAAK,cAAc;AAC7B,cAAM,YAAY,KAAK,IAAI,QAAQ,CAAC;AACpC,cAAM,QAAQ,aAAa,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,YAAY,SAAS;AAC1E,kBAAU,KAAK,IAAI,SAAS,QAAQ,IAAI,QAAQ,OAAO;AAAA,MACzD;AACA,SAAG,IAAI,KAAK,MAAM,KAAK,IAAI,UAAU,OAAO,IAAI,CAAC,IAAI;AACrD,UAAI,KAAK,EAAG,iBAAgB;AAAA,IAC9B;AAGA,QAAI,KAAK,KAAK,eAAe;AAG3B,WAAK,aAAa,QAAQ,MAAM,QAAQ,CAAA,MAAK;AAC3C,YAAI,KAAK,aAAa,IAAI,EAAE,EAAE,EAAG;AACjC,cAAM,UAAU,EAAE,OAAO;AACzB,cAAM,UAAU,UAAU;AAE1B,cAAM,SAAS,KAAK,aAAa,IAAI,EAAE,EAAE;AACzC,YAAI,UAAU,KAAM,GAAE,IAAI;AAC1B,UAAE,MAAM;AAER,cAAM,SAAU,KAAK,cAAc,cAAc,IAAK,UAAU,KAAK;AACrE,UAAE,IAAI,KAAK,MAAM,SAAS,CAAC,IAAI;AAE/B,cAAM,UAAU,UAAU,MAAM,IAAI,IAAI,KAAK,cAAc,cAAc;AACzE,cAAM,OAAO,KAAK;AAAA,WACf,EAAE,KAAK,KAAK,cAAc,cAAc,IAAI,YAAY,KAAK,cAAc;AAAA,QAAA;AAE9E,UAAE,MAAM,KAAK,IAAI,GAAG,IAAI;AAAA,MAC1B,CAAC;AAGD,YAAM,KAAK,KAAK,cAAc;AAC9B,YAAM,SAAS,KAAK;AACpB,YAAM,cAAc,KAAK,aAAa,QAAQ,MAAM,OAAO,CAAA,OAAM,EAAE,OAAO,OAAO,CAAC;AAClF,UAAI,WAAW,GAAG,UAAU;AAC5B,UAAI,YAAY,SAAS,GAAG;AAC1B,oBAAY,QAAQ,CAAA,MAAK;AACvB,sBAAY,KAAK,IAAI,EAAE,KAAK,SAAS,KAAK,OAAO,EAAE,IAAI,UAAU,EAAE,IAAI,GAAG;AAC1E,qBAAY,KAAK,IAAI,EAAE,KAAK,SAAS,KAAK,IAAI,KAAK,OAAO,EAAE,KAAK,SAAS,KAAK,MAAM,EAAE,IAAI,GAAG;AAAA,QAChG,CAAC;AAAA,MACH;AACA,YAAM,iBAAiB,YAAY,WAAW,IAAI,IAAK,YAAY,UAAU,IAAI,KAAK;AACtF,YAAM,qBAAqB,mBAAmB,IAAI,KAAK,IAAI;AAC3D,WAAK,cAAc,QAAQ,CAAC,OAAO;AACjC,cAAM,OAAO,KAAK,OAAO,GAAG,KAAK,SAAS,uBAAuB,EAAE;AACnE,WAAG,MAAM,KAAK,IAAI,GAAG,IAAI;AACzB,WAAG,MAAM;AAET,WAAG,IAAI,KAAK,MAAM,aAAa,CAAC,IAAI;AAAA,MACtC,CAAC;AAGD,WAAK,aAAa,eAAe,CAAC;AAClC,WAAK,YAAY,gBAAA;AAGjB,WAAK,aAAa,QAAQ,MAAM,QAAQ,CAAA,MAAK;AAC3C,eAAO,EAAE;AACT,eAAO,EAAE;AAAA,MACX,CAAC;AAGD,WAAK,qBAAqB;AAC1B,WAAK,aAAa,sBAAsB,KAAK;AAC7C,WAAK,aAAa,MAAA;AAClB,WAAK,aAAa,MAAA;AAClB,WAAK,aAAa,MAAA;AAClB,WAAK,gBAAgB,CAAA;AAAA,IACvB;AAAA,EACF;AAAA,EAEO,WAAW,QAA2B,OAAqB,iBAA0B,OAAa;AAEvG,SAAK,eAAe,WAAW,QAAQ;AACvC,SAAK,eAAe;AACpB,SAAK,iBAAiB;AAGtB,QAAI,CAAC,KAAK,eAAe,oBAAoB;AAC3C,cAAQ,MAAM,6BAA6B;AAC3C;AAAA,IACF;AAGA,SAAK,aAAa,gBAAgB,QAAQ;AAAA,MACxC,GAAG,KAAK,eAAe,YAAY,QAAQ;AAAA,MAC3C,GAAG,KAAK,eAAe,aAAa,QAAQ;AAAA,IAAA;AAI9C,UAAM,iBAAiB,KAAK,UAAU,oBAAoB,OAAO,KAAK,cAAc;AACpF,mBAAe,QAAQ,CAAA,WAAU,KAAK,aAAa,UAAU,MAAM,CAAC;AAEpE,SAAK,aAAa,sBAAsB,KAAK;AAC7C,SAAK,cAAA;AAGL,QAAI,KAAK,eAAgB,QAAO,cAAc,KAAK,cAAc;AACjE,SAAK,iBAAiB,OAAO,YAAY,MAAM,KAAK,oBAAA,GAAuB,KAAK,mBAAmB;AAAA,EACrG;AAAA,EAEO,gBAAsB;AAC3B,QAAI,KAAK,gBAAgB;AACvB,2BAAqB,KAAK,cAAc;AAAA,IAC1C;AAEA,UAAM,WAAW,MAAM;AAErB,WAAK,4BAAA;AAGL,WAAK,aAAa,iBAAA;AAGlB,WAAK,eAAe,YAAA;AAGpB,YAAM,QAAQ,KAAK,aAAa,YAAY;AAC5C,YAAM,MAAM,KAAK,eAAe,WAAW,OAAO,WAAW,IAAI;AACjE,UAAI,KAAK;AACP,YAAI,KAAA;AACJ,YAAI,UAAU,MAAM,GAAG,MAAM,CAAC;AAG9B,aAAK,eAAe,eAAA;AAGpB,aAAK,aAAa,QAAQ,MAAM,QAAQ,CAAA,WAAU;AAChD,eAAK,eAAe,WAAW,MAAM;AAAA,QACvC,CAAC;AAGD,aAAK,eAAe,eAAe,KAAK,aAAa,WAAW,KAAK;AAGrE,aAAK,eAAe;AAAA,UAClB,KAAK,aAAa,gBAAgB;AAAA,UAClC,KAAK,aAAa,mBAAmB;AAAA,UACrC,KAAK,aAAa,oBAAoB;AAAA,UACtC,KAAK,sBAAA;AAAA,QAAsB;AAI7B,YAAI,KAAK,aAAa,eAAe,OAAO;AAC1C,eAAK,eAAe,mBAAmB,KAAK,aAAa,eAAe,KAAK;AAAA,QAC/E;AAGA,aAAK,eAAe;AAAA,UAClB,KAAK,aAAa,QAAQ;AAAA,UAC1B,KAAK,aAAa,gBAAgB;AAAA,QAAA;AAGpC,YAAI,QAAA;AAAA,MACN;AAGA,UAAI,KAAK,UAAU,UAAU,KAAK,aAAa,QAAQ,KAAK,GAAG;AAC7D,aAAK,aAAa,YAAY,IAAI;AAClC;AAAA,MACF;AAEA,UAAI,CAAC,KAAK,aAAa,SAAS,OAAO;AACrC,aAAK,iBAAiB,sBAAsB,QAAQ;AAAA,MACtD;AAAA,IACF;AAEA,aAAA;AAAA,EACF;AAAA,EAEO,eAAqB;AAC1B,QAAI,KAAK,gBAAgB;AACvB,2BAAqB,KAAK,cAAc;AACxC,WAAK,iBAAiB;AAAA,IACxB;AACA,QAAI,KAAK,gBAAgB;AACvB,aAAO,cAAc,KAAK,cAAc;AACxC,WAAK,iBAAiB;AAAA,IACxB;AAAA,EACF;AAAA,EAEO,UAAU,OAAyB;AACxC,UAAM,SAAS,KAAK,eAAe,WAAW;AAC9C,QAAI,CAAC,UAAU,KAAK,aAAa,eAAe,MAAO;AAEvD,UAAM,cAAc,KAAK,aAAa,UAAU,OAAO,MAAM;AAC7D,SAAK,aAAa,cAAc,WAAW;AAAA,EAC7C;AAAA,EAEO,YAAY,OAAyB;AAC1C,UAAM,SAAS,KAAK,eAAe,WAAW;AAC9C,QAAI,CAAC,UAAU,KAAK,aAAa,eAAe,SAAS,CAAC,KAAK,aAAa,mBAAmB,SAAS,KAAK,oBAAoB;AAC/H;AAAA,IACF;AAEA,UAAM,iBAAiB,KAAK,aAAa;AAAA,MACvC;AAAA,MACA;AAAA,MACA,KAAK,aAAa,gBAAgB;AAAA,IAAA;AAGpC,QAAI,CAAC,eAAgB;AAGrB,SAAK,aAAa,cAAc,IAAI;AAGpC,UAAM,cAAc,KAAK,aAAa,mBAAmB;AACzD,UAAM,mBAAmB,KAAK,aAAa,KAAK,CAAA,UAAS,MAAM,SAAS,WAAW;AAGnF,UAAM,SAAiB;AAAA,MACrB,GAAG,KAAK,aAAa,gBAAgB,MAAM;AAAA,MAC3C,GAAG,KAAK,aAAa,gBAAgB,MAAM;AAAA,MAC3C,MAAM;AAAA,MACN,OAAO,KAAK,aAAa,oBAAoB;AAAA,MAC7C,IAAI,YAAY,KAAK,IAAA,CAAK;AAAA,MAC1B,KAAK;AAAA,MACL,KAAK;AAAA,MACL,mBAAmB,kBAAkB,WAAW;AAAA,MAChD,aAAa,YAAY,OAAO,CAAC,EAAE,YAAA;AAAA;AAAA,IAAY;AAIjD,SAAK,aAAa,kBAAkB,MAAM;AAG1C,QAAI,OAAO,MAAM;AACf,WAAK,YAAY,oBAAoB,OAAO,MAAM,IAAI;AAAA,IACxD;AAGA,SAAK,cAAc;AAAA,MACjB;AAAA,MACA,eAAe;AAAA,MACf,eAAe;AAAA,MACf,CAAC,iBAAyB,KAAK,mBAAmB,YAAY;AAAA,MAC9D,KAAK,aAAa,QAAQ;AAAA;AAAA,MAC1B,KAAK,eAAe,YAAY;AAAA;AAAA,MAChC,KAAK,eAAe,aAAa;AAAA;AAAA,IAAA;AAInC,SAAK,aAAa,sBAAsB,KAAK,YAAY;AAAA,EAC3D;AAAA,EAEO,YAAY,OAA2B;AAC5C,SAAK,aAAA;AACL,SAAK,eAAe;AACpB,SAAK,aAAa,UAAA;AAGlB,UAAM,iBAAiB,KAAK,UAAU,oBAAoB,KAAK;AAC/D,mBAAe,QAAQ,CAAA,WAAU,KAAK,aAAa,UAAU,MAAM,CAAC;AAEpE,SAAK,aAAa,sBAAsB,KAAK;AAC7C,SAAK,cAAA;AAGL,QAAI,KAAK,eAAgB,QAAO,cAAc,KAAK,cAAc;AACjE,SAAK,iBAAiB,OAAO,YAAY,MAAM,KAAK,oBAAA,GAAuB,KAAK,mBAAmB;AAAA,EACrG;AAAA,EAEO,qBAAqB,SAAwB;AAClD,SAAK,iBAAiB;AAEtB,SAAK,aAAa,QAAQ,MAAM,QAAQ,CAAA,WAAU;AAChD,UAAI,WAAW,OAAO,mBAAmB;AAEvC,eAAO,cAAc,OAAO,kBAAkB,UAAU,GAAG,CAAC,EAAE,YAAA;AAAA,MAChE,OAAO;AAEL,eAAO,cAAc,OAAO,KAAK,OAAO,CAAC,EAAE,YAAA;AAAA,MAC7C;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,wBAAgC;AACtC,UAAM,OAAO,KAAK,aAAa,mBAAmB;AAClD,QAAI,CAAC,KAAM,QAAO;AAGlB,UAAM,QAAQ,KAAK,aAAa,KAAK,CAAA,MAAK,EAAE,SAAS,IAAI;AAEzD,QAAI,KAAK,kBAAkB,OAAO,SAAS;AAEzC,aAAO,MAAM,QAAQ,UAAU,GAAG,CAAC,EAAE,YAAA;AAAA,IACvC,OAAO;AAEL,aAAO,KAAK,OAAO,CAAC,EAAE,YAAA;AAAA,IACxB;AAAA,EACF;AAAA,EAEO,UAAgB;AACrB,SAAK,aAAA;AAAA,EACP;AAAA,EAEQ,mBAAmB,QAAsB;AAE/C,UAAM,eAAe,KAAK,cAAc,mBAAmB,OAAO,GAAG,OAAO,GAAG,OAAO,KAAK;AAC3F,SAAK,aAAa,aAAa,YAAY;AAC3C,SAAK,YAAY,gBAAA;AAGjB,SAAK,aAAa,kBAAkB,IAAI;AAGxC,QAAI,KAAK,kBAAkB,OAAO,mBAAmB;AACnD,aAAO,cAAc,OAAO,kBAAkB,UAAU,GAAG,CAAC,EAAE,YAAA;AAAA,IAChE,OAAO;AAEL,aAAO,cAAc,OAAO,KAAK,OAAO,CAAC,EAAE,YAAA;AAAA,IAC7C;AAGA,SAAK,cAAc,WAAW,QAAQ,KAAK,aAAa,QAAQ,KAAK;AAGrE,SAAK,aAAa,UAAU,MAAM;AAGlC,SAAK,cAAc,MAAM;AAGzB,UAAM,cAAc,KAAK,UAAU,gBAAgB,QAAQ,KAAK,aAAa,QAAQ,KAAK;AAE1F,QAAI,YAAY,cAAc;AAE5B,kBAAY,eAAe,QAAQ,CAAA,kBAAiB;AAClD,cAAM,YAAY,KAAK,cAAc;AAAA,UACnC,cAAc;AAAA,UACd,cAAc;AAAA,UACd,cAAc;AAAA,QAAA;AAEhB,aAAK,aAAa,aAAa,SAAS;AAAA,MAC1C,CAAC;AAGD,YAAM,YAAY,YAAY,eAAe,IAAI,CAAA,MAAK,EAAE,EAAE;AAC1D,WAAK,aAAa,cAAc,SAAS;AAGzC,YAAM,aAAa,KAAK,UAAU,eAAe,YAAY,eAAe,QAAQ,CAAC;AACrF,WAAK,aAAa,YAAY,UAAU;AACxC,WAAK,aAAa,sBAAA;AAGlB,WAAK,YAAY,mBAAA;AAGjB,WAAK,aAAa,eAAe,CAAC;AAGlC,WAAK,sBAAA;AAAA,IACP;AAAA,EACF;AAAA,EAEQ,wBAA8B;AACpC,UAAM,iBAAiB,KAAK,UAAU,sBAAsB,KAAK,aAAa,QAAQ,KAAK;AAE3F,QAAI,eAAe,eAAe,SAAS,GAAG;AAE5C,qBAAe,eAAe,QAAQ,CAAA,mBAAkB;AACtD,cAAM,SAAS,KAAK,cAAc;AAAA,UAChC,eAAe;AAAA,UACf,eAAe;AAAA,UACf,eAAe;AAAA,QAAA;AAEjB,aAAK,aAAa,aAAa,MAAM;AAAA,MACvC,CAAC;AAGD,WAAK,aAAa,QAAQ,QAAQ,eAAe;AAGjD,YAAM,aAAa,KAAK,UAAU,eAAe,GAAG,eAAe,eAAe,MAAM;AACxF,WAAK,aAAa,YAAY,UAAU;AAAA,IAC1C;AAAA,EACF;AAAA,EAEQ,cAAc,cAA4B;AAEhD,UAAM,gBAAgB,KAAK,aAAa,QAAQ,MAAM,OAAO,CAAA,WAAU;AACrE,UAAI,CAAC,OAAO,OAAQ,QAAO;AAC3B,YAAM,KAAK,OAAO,IAAI,aAAa;AACnC,YAAM,KAAK,OAAO,IAAI,aAAa;AACnC,YAAM,WAAW,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AAC5C,aAAO,YAAY,KAAK,cAAc,cAAc;AAAA,IACtD,CAAC;AAGD,kBAAc,QAAQ,CAAA,SAAQ;AAC5B,YAAM,cAAc,KAAK,SAAS,IAAI,KAAK,EAAE,KAAK;AAClD,YAAM,UAAU,cAAc;AAC9B,WAAK,SAAS,IAAI,KAAK,IAAI,OAAO;AAElC,cAAQ,IAAI,QAAQ,KAAK,EAAE,QAAQ,OAAO,UAAU;AAEpD,UAAI,WAAW,GAAG;AAEhB,aAAK,wBAAwB,IAAI;AACjC,aAAK,SAAS,OAAO,KAAK,EAAE;AAAA,MAC9B;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,wBAAwB,YAA0B;AACxD,YAAQ,IAAI,yCAAyC;AAGrD,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,YAAM,WAAW,KAAK,OAAA,IAAW,OAAO,KAAK,cAAc,cAAc;AACzE,YAAM,WAAW,KAAK,OAAA,IAAW,OAAO,KAAK,cAAc,cAAc;AACzE,YAAM,mBAAmB,KAAK,cAAc;AAAA,QAC1C,WAAW,IAAI;AAAA,QACf,WAAW,IAAI;AAAA,QACf;AAAA,MAAA;AAIF,uBAAiB,UAAU,YAAY,KAAK,cAAc,cAAc;AACxE,uBAAiB,UAAU,QAAQ,CAAA,aAAY;AAC7C,iBAAS,QAAQ;AACjB,iBAAS,WAAW;AACpB,iBAAS,MAAM;AACf,iBAAS,MAAM;AAAA,MACjB,CAAC;AAED,WAAK,aAAa,aAAa,gBAAgB;AAAA,IACjD;AAGA,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,YAAM,QAAS,KAAK,KAAK,IAAI,IAAK;AAClC,YAAM,QAAQ,KAAK,KAAK,OAAA,IAAW;AACnC,YAAM,qBAAqB;AAAA,QACzB,GAAG,WAAW;AAAA,QACd,GAAG,WAAW;AAAA,QACd,WAAW,CAAC;AAAA,UACV,GAAG,WAAW;AAAA,UACd,GAAG,WAAW;AAAA,UACd,IAAI,KAAK,IAAI,KAAK,IAAI;AAAA,UACtB,IAAI,KAAK,IAAI,KAAK,IAAI;AAAA,UACtB,MAAM,KAAK,KAAK,OAAA,IAAW;AAAA,UAC3B,OAAO,CAAC,WAAW,WAAW,WAAW,WAAW,WAAW,SAAS,EAAE,KAAK,MAAM,KAAK,OAAA,IAAW,CAAC,CAAC;AAAA,UACvG,MAAM;AAAA,UACN,SAAS;AAAA,UACT,MAAM;AAAA,UACN,UAAU;AAAA,UACV,gBAAgB,KAAK,OAAA,IAAW,OAAO;AAAA,QAAA,CACxC;AAAA,QACD,QAAQ;AAAA,QACR,WAAW;AAAA,UACT,QAAQ;AAAA,UACR,WAAW,KAAK,cAAc,cAAc;AAAA,UAC5C,WAAW;AAAA,QAAA;AAAA,QAEb,QAAQ;AAAA,QACR,WAAW,KAAK,cAAc,cAAc;AAAA,QAC5C,WAAW;AAAA,MAAA;AAEb,WAAK,aAAa,aAAa,kBAAkB;AAAA,IACnD;AAGA,UAAM,kBAAkB,KAAK,cAAc,cAAc;AACzD,UAAM,iBAAiB,KAAK,aAAa,QAAQ,MAAM,OAAO,CAAA,WAAU;AACtE,YAAM,KAAK,OAAO,IAAI,WAAW;AACjC,YAAM,KAAK,OAAO,IAAI,WAAW;AACjC,YAAM,WAAW,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AAC5C,aAAO,YAAY;AAAA,IACrB,CAAC;AAGD,UAAM,YAAY,eAAe,IAAI,CAAA,MAAK,EAAE,EAAE;AAC9C,SAAK,aAAa,cAAc,SAAS;AAGzC,mBAAe,QAAQ,CAAA,WAAU;AAC/B,UAAI,OAAO,QAAQ;AACjB,aAAK,SAAS,OAAO,OAAO,EAAE;AAAA,MAChC;AAAA,IACF,CAAC;AAGD,SAAK,aAAa,eAAe,EAAE;AACnC,SAAK,YAAY,mBAAA;AAEjB,eAAW,MAAM,KAAK,YAAY,mBAAA,GAAsB,GAAG;AAC3D,eAAW,MAAM,KAAK,YAAY,mBAAA,GAAsB,GAAG;AAG3D,SAAK,aAAa,YAAY,MAAO,eAAe,SAAS,EAAE;AAE/D,YAAQ,IAAI,kCAAkC,eAAe,MAAM,WAAW;AAG9E,UAAM,iBAAiB,KAAK,UAAU,sBAAsB,KAAK,aAAa,QAAQ,KAAK;AAC3F,QAAI,eAAe,eAAe,SAAS,GAAG;AAC5C,WAAK,aAAa,cAAc,eAAe,eAAe,IAAI,CAAA,MAAK,EAAE,EAAE,CAAC;AAC5E,YAAM,gBAAgB,KAAK,UAAU,eAAe,GAAG,eAAe,eAAe,MAAM;AAC3F,WAAK,aAAa,YAAY,aAAa;AAAA,IAC7C;AAAA,EACF;AACF;AAEO,MAAM,uBAAuB,MAA0B;AAC5D,SAAO,IAAI,kBAAA;AACb;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7lBA,UAAM,QAAQ;AACd,UAAM,EAAE,EAAA,IAAM,QAAA;AAEd,UAAM,OAAO;AAKb,UAAM,OAA2B,qBAAA;AAGjC,UAAM,aAAa,IAAA;AACnB,UAAM,cAAc,SAAS,MAAM,KAAK,eAAe,YAAY,KAAK;AACxE,UAAM,eAAe,SAAS,MAAM,KAAK,eAAe,aAAa,KAAK;AAC1E,UAAM,QAAQ,SAAS,MAAM,KAAK,aAAa,MAAM,KAAK;AAC1D,UAAM,eAAe,SAAS,MAAM,KAAK,aAAa,aAAa,KAAK;AACxE,UAAM,WAAW,SAAS,MAAM,KAAK,aAAa,SAAS,KAAK;AAChE,UAAM,qBAAqB,SAAS,MAAM,KAAK,aAAa,mBAAmB,KAAK;AACtD,aAAS,MAAM;AAC3C,YAAM,OAAO,KAAK,aAAa,mBAAmB;AAClD,UAAI,CAAC,KAAM,QAAO;AAGlB,YAAM,QAAQ,MAAM,MAAM,KAAK,CAAA,MAAK,EAAE,SAAS,IAAI;AAEnD,UAAI,MAAM,kBAAkB,OAAO,SAAS;AAE1C,eAAO,MAAM,QAAQ,UAAU,GAAG,CAAC,EAAE,YAAA;AAAA,MACvC,OAAO;AAEL,eAAO,KAAK,OAAO,CAAC,EAAE,YAAA;AAAA,MACxB;AAAA,IACF,CAAC;AACD,UAAM,UAAU,SAAS,MAAM,KAAK,aAAa,QAAQ,KAAK;AAC9D,UAAM,kBAAkB,SAAS,MAAM,KAAK,aAAa,gBAAgB,KAAK;AAG9E,UAAM,oBAAoB;AAAA,MACxB,MAAM,KAAK,aAAa,SAAS;AAAA,MACjC,CAAC,eAAe;AACd,YAAI,YAAY;AACd,eAAK,eAAe;AAAA,QACtB;AAAA,MACF;AAAA,IAAA;AAGF,cAAU,YAAY;AACpB,YAAM,SAAA;AACN,UAAI,CAAC,WAAW,MAAO;AACvB,WAAK,WAAW,WAAW,OAAO,MAAM,OAAO,MAAM,cAAc;AAAA,IACrE,CAAC;AAGD,UAAM,MAAM,MAAM,gBAAgB,CAAC,aAAa;AAC9C,WAAK,qBAAqB,YAAY,KAAK;AAAA,IAC7C,CAAC;AAED,gBAAY,MAAM;AAChB,wBAAA;AACA,WAAK,QAAA;AAAA,IACP,CAAC;AAED,UAAM,YAAY,CAAC,UAAsB;AACvC,WAAK,UAAU,KAAK;AAAA,IACtB;AAEA,UAAM,cAAc,CAAC,UAAsB;AACzC,WAAK,YAAY,KAAK;AAAA,IACxB;AAEA,UAAM,cAAc,MAAM;AACxB,WAAK,aAAA;AACL,WAAK,aAAa,UAAA;AAClB,UAAI,WAAW,OAAO;AACpB,aAAK,WAAW,WAAW,OAAO,MAAM,KAAK;AAAA,MAC/C;AAAA,IACF;;AAlLE,aAAAC,UAAA,GAAAC,mBAwFM,OAxFN,YAwFM;AAAA,QAtFJC,gBAWM,OAXN,YAWM;AAAA,UAVJA,gBASM,OATN,YASM;AAAA,YARJA,gBAGM,OAAA,MAAA;AAAA,cAFJA,gBAAoH,MAApH,YAAoHC,gBAA5DC,MAAA,CAAA,EAAC,iCAAA,gBAAA,CAAA,GAAA,CAAA;AAAA,cACzDF,gBAAwI,KAAxI,YAAwIC,gBAA1FC,MAAA,CAAA,EAAC,uCAAA,yCAAA,CAAA,GAAA,CAAA;AAAA,YAAA;YAEjDF,gBAGM,OAHN,YAGM;AAAA,cAFJA,gBAA6D,OAA7D,YAA6DC,gBAAd,MAAA,KAAK,GAAA,CAAA;AAAA,cACpDD,gBAAkG,OAAlG,YAAkGC,gBAApDC,MAAA,CAAA,EAAC,iCAAA,OAAA,CAAA,GAAA,CAAA;AAAA,YAAA;;;QAMrDF,gBAuEM,OAvEN,YAuEM;AAAA,UAtEJA,gBAKU,UAAA;AAAA,qBAJJ;AAAA,YAAJ,KAAI;AAAA,YACJ,OAAM;AAAA,YACL,SAAO;AAAA,YACP,aAAW;AAAA,UAAA;UAKN,QAAA,MAAQ,wBADhBD,mBAcM,OAAA;AAAA;YAZJ,OAAM;AAAA,YACL,SAAO,OAAS,YAAA,KAAW,IAAI,aAAA,KAAY;AAAA,UAAA;YAE5CC,gBAQE,QAAA;AAAA,cAPC,IAAI,gBAAA,MAAgB;AAAA,cACpB,IAAI,gBAAA,MAAgB;AAAA,cACpB,IAAI,QAAA,MAAQ;AAAA,cACZ,IAAI,QAAA,MAAQ;AAAA,cACb,QAAO;AAAA,cACP,gBAAa;AAAA,cACb,oBAAiB;AAAA,YAAA;;UAKrBA,gBAKM,OALN,aAKM;AAAA,YAJJA,gBAGM,OAHN,aAGM;AAAA,cAFJA,gBAAsG,OAAtG,aAAsGC,gBAA3B,mBAAA,KAAkB,GAAA,CAAA;AAAA,cAC7FD,gBAAqI,OAArI,aAAqIC,gBAAjEC,MAAA,CAAA,EAAC,uCAAA,cAAA,CAAA,GAAA,CAAA;AAAA,YAAA;;UAKzEC,YAoCaC,YAAA;AAAA,YApCD,MAAK;AAAA,YAAQ,QAAA;AAAA,UAAA;6BACvB,MAkCM;AAAA,cAlCK,SAAA,SAAXN,UAAA,GAAAC,mBAkCM,OAlCN,aAkCM;AAAA,gBAjCJC,gBAgCM,OAhCN,aAgCM;AAAA,4CA9BJA,gBAIM,OAAA,EAJD,OAAM,oJAAgJ;AAAA,oBACzJA,gBAEM,OAAA;AAAA,sBAFD,OAAM;AAAA,sBAAqC,MAAK;AAAA,sBAAe,SAAQ;AAAA,oBAAA;sBAC1EA,gBAAsK,QAAA;AAAA,wBAAhK,aAAU;AAAA,wBAAU,GAAE;AAAA,wBAAqH,aAAU;AAAA,sBAAA;;;kBAI/JA,gBAEK,MAFL,aAEKC,gBADAC,MAAA,CAAA,EAAC,wCAAA,gBAAA,CAAA,GAAA,CAAA;AAAA,kBAENF,gBAEI,KAFJ,aAEIC,gBADCC,MAAA,CAAA,iDAA0C,MAAA,MAAA,CAAK,CAAA,GAAA,CAAA;AAAA,kBAEpDF,gBAEI,KAFJ,aAEIC,gBADCC,MAAA,CAAA,mDAAmD,aAAA,MAAA,CAAY,CAAA,GAAA,CAAA;AAAA,kBAGpEF,gBAaM,OAbN,aAaM;AAAA,oBAZJA,gBAKS,UAAA;AAAA,sBAJN,SAAO;AAAA,sBACR,OAAM;AAAA,oBAAA,mBAEHE,MAAA,CAAA,EAAC,qCAAA,YAAA,CAAA,GAAA,CAAA;AAAA,oBAENF,gBAKS,UAAA;AAAA,sBAJN,+CAAOK,KAAAA,MAAK,eAAA;AAAA,sBACb,OAAM;AAAA,oBAAA,mBAEHH,MAAA,CAAA,EAAC,iBAAA,QAAA,CAAA,GAAA,CAAA;AAAA,kBAAA;;;;;;;;;;;;"}