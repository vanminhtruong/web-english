const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/FireworkSoundEffect-xQS5rqAq.js","assets/vendor-kzGOnAa-.js","assets/index-CVcMrQRh.js","assets/vendor-toast-DUxYViPJ.js","assets/vendor-toast-jG2HNJHr.css","assets/index-c-kh2r7U.css","assets/FireworkSoundEffect-Z17vpFMM.css"])))=>i.map(i=>d[i]);
import { d as useVoiceStore, g as getTopicName, _ as __vitePreload, a as _export_sfc } from "./index-CVcMrQRh.js";
import { d as defineComponent, H as useI18n, A as ref, K as watch, c as createElementBlock, v as openBlock, f as createBaseVNode, y as createVNode, t as toDisplayString, u as unref, F as Fragment, e as createCommentVNode, j as renderList, C as withDirectives, E as vShow, i as withModifiers, n as normalizeClass, D as defineAsyncComponent, q as nextTick } from "./vendor-kzGOnAa-.js";
import "./vendor-toast-DUxYViPJ.js";
const _hoisted_1 = { class: "perspective-1000" };
const _hoisted_2 = { class: "flashcard-face flashcard-front absolute inset-0 bg-white dark:bg-[#0a0a0a] rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 flex items-center justify-center p-4 sm:p-6 md:p-8" };
const _hoisted_3 = { class: "text-center" };
const _hoisted_4 = { class: "mb-3 sm:mb-4 md:mb-5" };
const _hoisted_5 = { class: "px-2 py-1 sm:px-3 sm:py-1 md:px-4 md:py-2 xl:px-3 xl:py-1 2xl:px-3 2xl:py-1 bg-blue-100 dark:bg-gray-800 text-blue-800 dark:text-blue-300 text-xs sm:text-sm md:text-base xl:text-sm 2xl:text-sm font-medium rounded-full" };
const _hoisted_6 = { class: "text-xl sm:text-2xl md:text-3xl font-bold text-gray-900 dark:text-white mb-3 sm:mb-4 md:mb-5" };
const _hoisted_7 = { class: "text-sm sm:text-base md:text-lg text-gray-600 dark:text-gray-300 mb-4 sm:mb-5 md:mb-6" };
const _hoisted_8 = { class: "text-xs sm:text-sm md:text-base text-gray-500 dark:text-gray-400" };
const _hoisted_9 = { class: "text-base sm:text-lg md:text-xl xl:text-lg 2xl:text-xl font-bold text-gray-900 dark:text-white mb-2 sm:mb-3 md:mb-4 xl:mb-3 2xl:mb-3" };
const _hoisted_10 = { class: "text-sm sm:text-base md:text-lg xl:text-base 2xl:text-lg text-gray-600 dark:text-gray-300 mb-4 sm:mb-5 md:mb-6 xl:mb-4 2xl:mb-5" };
const _hoisted_11 = { class: "mb-4 sm:mb-5 md:mb-6 xl:mb-4 2xl:mb-5" };
const _hoisted_12 = { class: "flex flex-wrap justify-center items-center gap-1 sm:gap-2 xl:gap-1.5 2xl:gap-2 mb-2 sm:mb-3 md:mb-4 xl:mb-3 2xl:mb-3 min-h-[3rem] xl:min-h-[2.5rem] 2xl:min-h-[3rem] max-w-full px-2 sm:px-0" };
const _hoisted_13 = ["onClick"];
const _hoisted_14 = {
  key: 0,
  class: "text-center max-w-full px-2"
};
const _hoisted_15 = {
  key: 0,
  class: "text-green-600 dark:text-green-400"
};
const _hoisted_16 = { class: "font-semibold text-sm sm:text-base mb-2" };
const _hoisted_17 = { class: "bg-green-50 dark:bg-[#0f0f0f] border border-green-200 dark:border-dark-bg-mute rounded-lg p-3 sm:p-4" };
const _hoisted_18 = { class: "text-green-700 dark:text-green-400 font-medium text-sm sm:text-base" };
const _hoisted_19 = {
  key: 0,
  class: "text-green-600 dark:text-green-500 text-xs sm:text-sm mt-1 opacity-80"
};
const _hoisted_20 = {
  key: 1,
  class: "text-red-600 dark:text-red-400"
};
const _hoisted_21 = { class: "font-semibold text-sm sm:text-base mb-2" };
const _hoisted_22 = { class: "bg-red-50 dark:bg-[#0f0f0f] border border-red-200 dark:border-dark-bg-mute rounded-lg p-3 sm:p-4" };
const _hoisted_23 = { class: "text-red-700 dark:text-red-400 font-bold text-base sm:text-lg mb-1" };
const _hoisted_24 = { class: "text-red-600 dark:text-red-500 text-sm sm:text-base" };
const _hoisted_25 = {
  key: 0,
  class: "text-red-500 dark:text-red-600 text-xs sm:text-sm mt-1 opacity-80"
};
const _hoisted_26 = { class: "flex justify-center flex-wrap gap-2 sm:gap-3 md:gap-4 xl:gap-2 2xl:gap-2.5 mb-4 sm:mb-5 md:mb-6 xl:mb-4 2xl:mb-4 px-2 sm:px-4 md:px-6 xl:px-4 2xl:px-6 max-w-full" };
const _hoisted_27 = ["onClick", "disabled"];
const _hoisted_28 = { class: "flex flex-wrap justify-center gap-1.5 xs:gap-2 sm:gap-3 md:gap-4 xl:gap-2 2xl:gap-3 px-2 sm:px-4 xl:px-2 2xl:px-4 max-w-full" };
const _hoisted_29 = ["disabled", "title"];
const _hoisted_30 = { class: "hidden xs:hidden sm:inline" };
const _hoisted_31 = ["disabled"];
const _hoisted_32 = ["disabled"];
const _hoisted_33 = { class: "flashcard-face flashcard-back absolute inset-0 bg-gradient-to-br from-green-400 to-green-600 dark:from-green-700 dark:to-green-900 rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 flex items-center justify-center p-4 sm:p-6 md:p-8" };
const _hoisted_34 = { class: "text-center text-white" };
const _hoisted_35 = { class: "text-base sm:text-lg md:text-xl font-bold mb-3 sm:mb-4 md:mb-5" };
const _hoisted_36 = {
  key: 0,
  class: "text-sm sm:text-base md:text-lg mb-3 sm:mb-4 md:mb-5"
};
const _hoisted_37 = {
  key: 1,
  class: "text-xs sm:text-sm md:text-base mb-3 sm:mb-4 md:mb-5 leading-relaxed"
};
const _hoisted_38 = { class: "text-xs sm:text-sm md:text-base opacity-75" };
const MAX_SHUFFLE_HISTORY = 3;
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "FlashcardCard",
  props: {
    currentCard: {},
    isFlipped: { type: Boolean },
    scrambleWordsEnabled: { type: Boolean },
    currentIndex: {},
    totalCards: {}
  },
  emits: ["flip-card", "next-card", "show-results", "scramble-answer"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const props = __props;
    const emit = __emit;
    const FireworkSoundEffect = defineAsyncComponent(() => __vitePreload(() => import("./FireworkSoundEffect-xQS5rqAq.js"), true ? __vite__mapDeps([0,1,2,3,4,5,6]) : void 0));
    const triggerFirework = ref(false);
    const triggerSound = ref(false);
    const isCorrectAnswer = ref(false);
    const fireworkEffect = ref();
    const resetTriggers = () => {
      triggerFirework.value = false;
      triggerSound.value = false;
    };
    const { playAudio } = useVoiceStore();
    let autoAdvanceTimer = null;
    const clearAutoAdvanceTimer = () => {
      if (autoAdvanceTimer) {
        clearTimeout(autoAdvanceTimer);
        autoAdvanceTimer = null;
      }
    };
    const isSmallScreen = ref(false);
    const updateScreenSize = () => {
      if (typeof window !== "undefined") {
        isSmallScreen.value = window.innerWidth < 768;
      }
    };
    if (typeof window !== "undefined") {
      updateScreenSize();
      window.addEventListener("resize", updateScreenSize);
    }
    const assembledWord = ref([]);
    const availableLetters = ref([]);
    const scrambleAnswered = ref(false);
    const scrambleCorrect = ref(false);
    const previousShuffles = ref([]);
    const createAdvancedShuffle = (letters) => {
      const shuffled = [...letters];
      const passes = Math.max(3, Math.floor(letters.length / 2) + 1);
      for (let pass = 0; pass < passes; pass++) {
        const timeSeed = Date.now() + pass * 1e3;
        const randomSeed = Math.random() * 1e4;
        const passEntropy = (timeSeed + randomSeed) % 1;
        for (let i = shuffled.length - 1; i > 0; i--) {
          const baseRandom = Math.random();
          const timeRandom = Date.now() % 997 / 997;
          const passRandom = (pass + 1) / passes;
          const combinedRandom = (baseRandom + timeRandom + passRandom + passEntropy) % 1;
          const j = Math.floor(combinedRandom * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        if (pass % 2 === 0) {
          for (let i = 0; i < shuffled.length - 1; i++) {
            const entropy = (Math.random() + Date.now() % 101 / 100) % 1;
            if (entropy > 0.5) {
              const j = Math.min(i + 1 + Math.floor(Math.random() * 2), shuffled.length - 1);
              [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
          }
        }
      }
      return shuffled;
    };
    const isSimilarToPrevious = (current, previous) => {
      if (previous.length === 0) return false;
      return previous.some((prev) => {
        if (prev.length !== current.length) return false;
        let matches = 0;
        for (let i = 0; i < current.length; i++) {
          if (current[i] === prev[i]) matches++;
        }
        return matches / current.length > 0.6;
      });
    };
    const initializeScrambledLetters = () => {
      if (!props.currentCard || !props.scrambleWordsEnabled) return;
      const word = props.currentCard.word.toLowerCase();
      const letters = word.split("");
      const letterObjects = letters.map((char, index) => ({
        char: char.toUpperCase(),
        used: false,
        originalIndex: index
      }));
      let attempts = 0;
      let shuffledOrder;
      const maxAttempts = 10;
      do {
        shuffledOrder = createAdvancedShuffle(letters.map((char) => char.toUpperCase()));
        attempts++;
      } while (attempts < maxAttempts && isSimilarToPrevious(shuffledOrder, previousShuffles.value));
      previousShuffles.value.push(shuffledOrder);
      if (previousShuffles.value.length > MAX_SHUFFLE_HISTORY) {
        previousShuffles.value.shift();
      }
      const shuffledLetterObjects = [];
      const usedIndices = /* @__PURE__ */ new Set();
      shuffledOrder.forEach((char) => {
        const originalLetterIndex = letterObjects.findIndex(
          (obj, idx) => obj.char === char && !usedIndices.has(idx)
        );
        if (originalLetterIndex !== -1) {
          const originalLetterObj = letterObjects[originalLetterIndex];
          usedIndices.add(originalLetterIndex);
          shuffledLetterObjects.push({
            ...originalLetterObj,
            used: false
          });
        }
      });
      availableLetters.value = shuffledLetterObjects.length === letterObjects.length ? shuffledLetterObjects : letterObjects;
      assembledWord.value = [];
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
      console.log("🎲 New shuffle created:", {
        word: props.currentCard.word,
        original: letters,
        shuffled: shuffledOrder,
        attempts,
        historySize: previousShuffles.value.length
      });
    };
    watch(() => props.currentCard, () => {
      clearAutoAdvanceTimer();
      if (props.scrambleWordsEnabled) {
        initializeScrambledLetters();
      }
    }, { immediate: true });
    watch(() => props.scrambleWordsEnabled, (enabled) => {
      clearAutoAdvanceTimer();
      if (enabled) {
        initializeScrambledLetters();
      } else {
        assembledWord.value = [];
        availableLetters.value = [];
        scrambleAnswered.value = false;
        scrambleCorrect.value = false;
        previousShuffles.value = [];
      }
    });
    const selectLetter = (index) => {
      if (availableLetters.value[index].used) return;
      if (scrambleAnswered.value && scrambleCorrect.value) return;
      assembledWord.value.push(availableLetters.value[index].char);
      availableLetters.value[index].used = true;
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
    };
    const removeLetter = (assembledIndex) => {
      if (scrambleAnswered.value && scrambleCorrect.value) return;
      const removedChar = assembledWord.value[assembledIndex];
      assembledWord.value.splice(assembledIndex, 1);
      const availableIndex = availableLetters.value.findIndex(
        (letter) => letter.char === removedChar && letter.used
      );
      if (availableIndex !== -1) {
        availableLetters.value[availableIndex].used = false;
      }
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
    };
    const clearAssembledWord = () => {
      if (scrambleAnswered.value && scrambleCorrect.value) return;
      availableLetters.value.forEach((letter) => {
        letter.used = false;
      });
      assembledWord.value = [];
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
    };
    const backspaceAssembledWord = () => {
      if (scrambleAnswered.value && scrambleCorrect.value) return;
      if (assembledWord.value.length === 0) return;
      const removedChar = assembledWord.value.pop();
      const availableIndex = availableLetters.value.findIndex(
        (letter) => letter.char === removedChar && letter.used
      );
      if (availableIndex !== -1) {
        availableLetters.value[availableIndex].used = false;
      }
      scrambleAnswered.value = false;
      scrambleCorrect.value = false;
    };
    const checkScrambleAnswer = async () => {
      if (assembledWord.value.length !== props.currentCard.word.length) return;
      const userAnswer = assembledWord.value.join("").toLowerCase();
      const correctAnswer = props.currentCard.word.toLowerCase();
      scrambleAnswered.value = true;
      scrambleCorrect.value = userAnswer === correctAnswer;
      clearAutoAdvanceTimer();
      const isLastCard = props.currentIndex !== void 0 && props.totalCards !== void 0 && props.currentIndex + 1 >= props.totalCards;
      console.log("Scramble Check Debug:", {
        currentIndex: props.currentIndex,
        totalCards: props.totalCards,
        isLastCard,
        isSmallScreen: isSmallScreen.value,
        scrambleCorrect: scrambleCorrect.value
      });
      emit("scramble-answer", scrambleCorrect.value);
      if (scrambleCorrect.value) {
        isCorrectAnswer.value = true;
        triggerFirework.value = true;
        triggerSound.value = true;
        try {
          await nextTick();
          await playAudio(props.currentCard.word);
        } catch (error) {
          console.warn("Voice playbook error:", error);
        }
        if (isSmallScreen.value) {
          console.log("Setting timer for correct answer:", isLastCard ? "show-results" : "next-card");
          autoAdvanceTimer = setTimeout(() => {
            console.log("Timer executed, emitting:", isLastCard ? "show-results" : "next-card");
            if (isLastCard) {
              emit("show-results");
            } else {
              emit("next-card");
            }
          }, 2500);
        }
      } else {
        isCorrectAnswer.value = false;
        triggerFirework.value = true;
        triggerSound.value = true;
        if (isSmallScreen.value) {
          console.log("Setting timer for incorrect answer:", isLastCard ? "show-results" : "next-card");
          autoAdvanceTimer = setTimeout(() => {
            console.log("Timer executed for incorrect, emitting:", isLastCard ? "show-results" : "next-card");
            if (isLastCard) {
              emit("show-results");
            } else {
              emit("next-card");
            }
          }, 2500);
        }
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("div", {
          class: normalizeClass([["flashcard", { "flipped": _ctx.isFlipped }], "relative w-full cursor-pointer h-80 sm:h-96 md:h-[28rem] xl:h-[30rem] 2xl:h-[32rem] select-none"]),
          onClick: _cache[0] || (_cache[0] = ($event) => !_ctx.scrambleWordsEnabled && _ctx.$emit("flip-card")),
          onCopy: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["prevent"])),
          onCut: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["prevent"])),
          onContextmenu: _cache[3] || (_cache[3] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          createBaseVNode("div", _hoisted_2, [
            createBaseVNode("div", _hoisted_3, [
              createBaseVNode("div", _hoisted_4, [
                createBaseVNode("span", _hoisted_5, toDisplayString(unref(getTopicName)(_ctx.currentCard.category)), 1)
              ]),
              !_ctx.scrambleWordsEnabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("h2", _hoisted_6, toDisplayString(_ctx.currentCard.word), 1),
                createBaseVNode("p", _hoisted_7, toDisplayString(_ctx.currentCard.pronunciation), 1),
                createBaseVNode("p", _hoisted_8, toDisplayString(unref(t)("flashcard.card.flip_to_meaning", "Click to see meaning")), 1)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createBaseVNode("h3", _hoisted_9, toDisplayString(unref(t)("flashcard.scrambleWords.instruction", "Arrange the letters to form the word")), 1),
                createBaseVNode("p", _hoisted_10, toDisplayString(_ctx.currentCard.pronunciation), 1),
                createBaseVNode("div", _hoisted_11, [
                  createBaseVNode("div", _hoisted_12, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(assembledWord.value, (letter, index) => {
                      return openBlock(), createElementBlock("div", {
                        key: `assembled-${index}`,
                        class: "w-8 h-8 sm:w-10 sm:h-10 md:w-12 md:h-12 xl:w-10 xl:h-10 2xl:w-11 2xl:h-11 border-2 border-gray-300 dark:border-dark-bg-mute rounded-lg flex items-center justify-center bg-blue-50 dark:bg-[#0f0f0f] text-lg sm:text-xl md:text-2xl xl:text-xl 2xl:text-2xl font-bold text-gray-900 dark:text-white cursor-pointer hover:bg-blue-100 dark:hover:bg-[#1a1a1a] transition-colors",
                        onClick: ($event) => removeLetter(index)
                      }, toDisplayString(letter), 9, _hoisted_13);
                    }), 128)),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(Math.max(0, _ctx.currentCard.word.length - assembledWord.value.length), (n) => {
                      return openBlock(), createElementBlock("div", {
                        key: `empty-${n}`,
                        class: "w-8 h-8 sm:w-10 sm:h-10 md:w-12 md:h-12 xl:w-10 xl:h-10 2xl:w-11 2xl:h-11 border-2 border-dashed border-gray-300 dark:border-dark-bg-mute rounded-lg bg-gray-50 dark:bg-[#0f0f0f]"
                      });
                    }), 128))
                  ]),
                  scrambleAnswered.value ? (openBlock(), createElementBlock("div", _hoisted_14, [
                    scrambleCorrect.value ? (openBlock(), createElementBlock("div", _hoisted_15, [
                      createBaseVNode("p", _hoisted_16, " ✅ " + toDisplayString(unref(t)("flashcard.scrambleWords.correct", "Correct!")), 1),
                      createBaseVNode("div", _hoisted_17, [
                        createBaseVNode("p", _hoisted_18, toDisplayString(_ctx.currentCard.meaning), 1),
                        _ctx.currentCard.partOfSpeech ? (openBlock(), createElementBlock("p", _hoisted_19, toDisplayString(unref(t)(`vocabulary.wordTypes.${_ctx.currentCard.partOfSpeech}`, _ctx.currentCard.partOfSpeech)), 1)) : createCommentVNode("", true)
                      ])
                    ])) : (openBlock(), createElementBlock("div", _hoisted_20, [
                      createBaseVNode("p", _hoisted_21, " ❌ " + toDisplayString(unref(t)("flashcard.scrambleWords.incorrect", "Try again!")), 1),
                      createBaseVNode("div", _hoisted_22, [
                        createBaseVNode("p", _hoisted_23, toDisplayString(_ctx.currentCard.word.toUpperCase()), 1),
                        createBaseVNode("p", _hoisted_24, toDisplayString(_ctx.currentCard.meaning), 1),
                        _ctx.currentCard.partOfSpeech ? (openBlock(), createElementBlock("p", _hoisted_25, toDisplayString(unref(t)(`vocabulary.wordTypes.${_ctx.currentCard.partOfSpeech}`, _ctx.currentCard.partOfSpeech)), 1)) : createCommentVNode("", true)
                      ])
                    ]))
                  ])) : createCommentVNode("", true)
                ]),
                createBaseVNode("div", _hoisted_26, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(availableLetters.value, (letter, index) => {
                    return withDirectives((openBlock(), createElementBlock("button", {
                      key: `scrambled-${index}`,
                      class: "w-8 h-8 sm:w-10 sm:h-10 md:w-12 md:h-12 xl:w-10 xl:h-10 2xl:w-11 2xl:h-11 border-2 border-gray-400 dark:border-dark-bg-soft rounded-lg flex items-center justify-center bg-white dark:bg-[#0f0f0f] hover:bg-gray-100 dark:hover:bg-[#1a1a1a] text-lg sm:text-xl md:text-2xl xl:text-xl 2xl:text-2xl font-bold text-gray-900 dark:text-white cursor-pointer transition-all duration-200 hover:scale-105 active:scale-95",
                      onClick: ($event) => selectLetter(index),
                      disabled: scrambleAnswered.value && scrambleCorrect.value
                    }, toDisplayString(letter.char), 9, _hoisted_27)), [
                      [vShow, !letter.used]
                    ]);
                  }), 128))
                ]),
                createBaseVNode("div", _hoisted_28, [
                  createBaseVNode("button", {
                    onClick: backspaceAssembledWord,
                    class: "px-2 py-1 xs:px-2 xs:py-1.5 sm:px-3 sm:py-2 md:px-4 md:py-2.5 xl:px-3 xl:py-2 2xl:px-4 2xl:py-2.5 bg-orange-500 hover:bg-orange-600 dark:bg-orange-600 dark:hover:bg-orange-700 text-white text-xs sm:text-sm md:text-base xl:text-sm 2xl:text-base font-semibold rounded-md sm:rounded-lg transition-colors flex items-center gap-1 sm:gap-2 xl:gap-1 2xl:gap-2 min-w-0 flex-shrink-0",
                    disabled: assembledWord.value.length === 0 || scrambleAnswered.value && scrambleCorrect.value,
                    title: unref(t)("flashcard.scrambleWords.backspace", "Backspace")
                  }, [
                    _cache[4] || (_cache[4] = createBaseVNode("svg", {
                      class: "w-3 h-3 sm:w-4 sm:h-4 xl:w-3 xl:h-3 2xl:w-4 2xl:h-4",
                      fill: "currentColor",
                      viewBox: "0 0 20 20"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M6.707 4.879A3 3 0 018.828 4H15a3 3 0 013 3v6a3 3 0 01-3 3H8.828a3 3 0 01-2.12-.879l-4.415-4.414a1 1 0 010-1.414l4.414-4.414zm4 3.707a1 1 0 00-1.414-1.414L8 8.586 6.707 7.293a1 1 0 10-1.414 1.414L6.586 10l-1.293 1.293a1 1 0 101.414 1.414L8 11.414l1.293 1.293a1 1 0 001.414-1.414L9.414 10l1.293-1.293z",
                        "clip-rule": "evenodd"
                      })
                    ], -1)),
                    createBaseVNode("span", _hoisted_30, toDisplayString(unref(t)("flashcard.scrambleWords.backspace", "Backspace")), 1)
                  ], 8, _hoisted_29),
                  createBaseVNode("button", {
                    onClick: clearAssembledWord,
                    class: "px-2 py-1 xs:px-3 xs:py-1.5 sm:px-4 sm:py-2 md:px-5 md:py-2.5 xl:px-4 xl:py-2 2xl:px-5 2xl:py-2.5 bg-gray-500 hover:bg-gray-600 dark:bg-gray-600 dark:hover:bg-gray-700 text-white text-xs sm:text-sm md:text-base xl:text-sm 2xl:text-base font-semibold rounded-md sm:rounded-lg transition-colors min-w-0 flex-shrink-0",
                    disabled: assembledWord.value.length === 0 || scrambleAnswered.value && scrambleCorrect.value
                  }, toDisplayString(unref(t)("flashcard.scrambleWords.clear", "Clear")), 9, _hoisted_31),
                  createBaseVNode("button", {
                    onClick: checkScrambleAnswer,
                    class: "px-2 py-1 xs:px-3 xs:py-1.5 sm:px-4 sm:py-2 md:px-5 md:py-2.5 xl:px-4 xl:py-2 2xl:px-5 2xl:py-2.5 bg-blue-600 hover:bg-blue-700 text-white text-xs sm:text-sm md:text-base xl:text-sm 2xl:text-base font-semibold rounded-md sm:rounded-lg transition-colors min-w-0 flex-shrink-0",
                    disabled: assembledWord.value.length !== _ctx.currentCard.word.length || scrambleAnswered.value && scrambleCorrect.value
                  }, toDisplayString(unref(t)("flashcard.scrambleWords.check", "Check")), 9, _hoisted_32)
                ])
              ], 64))
            ])
          ]),
          createBaseVNode("div", _hoisted_33, [
            createBaseVNode("div", _hoisted_34, [
              createBaseVNode("h3", _hoisted_35, toDisplayString(_ctx.currentCard.meaning), 1),
              _ctx.currentCard.partOfSpeech ? (openBlock(), createElementBlock("p", _hoisted_36, toDisplayString(unref(t)(`vocabulary.wordTypes.${_ctx.currentCard.partOfSpeech}`, _ctx.currentCard.partOfSpeech)), 1)) : createCommentVNode("", true),
              _ctx.currentCard.example ? (openBlock(), createElementBlock("p", _hoisted_37, toDisplayString(_ctx.currentCard.example), 1)) : createCommentVNode("", true),
              createBaseVNode("p", _hoisted_38, toDisplayString(unref(t)("flashcard.card.flip_back", "Click to flip back")), 1)
            ])
          ])
        ], 34),
        createVNode(unref(FireworkSoundEffect), {
          ref_key: "fireworkEffect",
          ref: fireworkEffect,
          "trigger-firework": triggerFirework.value,
          "trigger-sound": triggerSound.value,
          "is-correct": isCorrectAnswer.value,
          onEffectComplete: resetTriggers
        }, null, 8, ["trigger-firework", "trigger-sound", "is-correct"])
      ]);
    };
  }
});
const FlashcardCard = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-e4d27939"]]);
export {
  FlashcardCard as default
};
//# sourceMappingURL=FlashcardCard-v0VATeTR.js.map
