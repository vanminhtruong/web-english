{"version":3,"file":"SnakeGameMode-DwHB70kO.js","sources":["../../src/views/practice/composables/snake-game/SnakeStateManager.ts","../../src/views/practice/composables/snake-game/SnakeCanvasRenderer.ts","../../src/views/practice/composables/snake-game/SnakeGameEngine.ts","../../src/views/practice/composables/snake-game/SnakeGame.ts","../../src/views/practice/composables/snake-game/index.ts","../../src/views/practice/components/SnakeGameMode.vue"],"sourcesContent":["import { ref } from 'vue'\nimport type { Vocabulary } from '../../../../composables/useVocabularyStore'\nimport type { ISnakeStateManager, Snake, Food, Position } from './types'\n\nclass SnakeStateManager implements ISnakeStateManager {\n  snake = ref<Snake>({\n    body: [{ x: 10, y: 10 }],\n    direction: { x: 0, y: 0 },\n    currentWord: ''\n  })\n  \n  food = ref<Food | null>(null)\n  secondaryFood = ref<Food | null>(null)\n  score = ref(0)\n  gameOver = ref(false)\n  gameRunning = ref(false)\n  currentTargetWord = ref('')\n  wordsCompleted = ref(0)\n  gameSpeed = ref(150) // milliseconds between moves\n  lastEatenFoodPos = ref<Position | null>(null)\n  lastEatenWord = ref<string | null>(null)\n  doubleBaitMode = ref(false)\n  wrongEatenCount = ref(0)\n  private isLastWord: boolean = false\n\n  private words: Vocabulary[] = []           \n  private vietnameseMode: boolean = false\n  private usedWords: Set<string> = new Set()\n\n  // Audio context for sound effects\n  private audioContext: AudioContext | null = null\n  // Timeline recording callback\n  private onMoveCallback?: (body: Position[], direction: Position) => void\n\n  resetGame() {\n    this.snake.value = {\n      body: [{ x: 10, y: 10 }],\n      direction: { x: 0, y: 0 },\n      currentWord: ''\n    }\n    this.food.value = null\n    this.secondaryFood.value = null\n    this.score.value = 0\n    this.gameOver.value = false\n    this.gameRunning.value = false\n    this.currentTargetWord.value = ''\n    this.wordsCompleted.value = 0\n    this.usedWords.clear()\n    this.lastEatenFoodPos.value = null\n    this.lastEatenWord.value = null\n    this.doubleBaitMode.value = false\n    this.wrongEatenCount.value = 0\n    this.isLastWord = false\n  }\n\n  updateDirection(direction: Position) {\n    // Prevent reverse direction\n    const currentDir = this.snake.value.direction\n    if (direction.x !== -currentDir.x || direction.y !== -currentDir.y) {\n      this.snake.value.direction = direction\n    }\n  }\n\n  moveSnake() {\n    if (!this.gameRunning.value || this.gameOver.value) return\n\n    const snake = this.snake.value\n    const head = { ...snake.body[0] }\n    \n    // Move head in current direction\n    head.x += snake.direction.x\n    head.y += snake.direction.y\n\n    // Wrap-around on walls (canvas 30x20 grid)\n    if (head.x < 0) head.x = 29\n    else if (head.x >= 30) head.x = 0\n    if (head.y < 0) head.y = 19\n    else if (head.y >= 20) head.y = 0\n\n    // Check self collision after wrapping\n    if (this.checkCollision()) {\n      this.setGameOver()\n      return\n    }\n\n    snake.body.unshift(head)\n\n    // Handle collisions with primary/secondary foods for single or double bait modes\n    const headNow = this.snake.value.body[0]\n    const hitPrimary = this.food.value && headNow.x === this.food.value.position.x && headNow.y === this.food.value.position.y\n    const hitSecondary = this.secondaryFood.value && headNow.x === this.secondaryFood.value.position.x && headNow.y === this.secondaryFood.value.position.y\n\n    if (hitPrimary) {\n      // Correct food eaten\n      this.incrementScore()\n      this.wordsCompleted.value++\n      if (this.food.value) {\n        this.lastEatenFoodPos.value = { ...this.food.value.position }\n        this.lastEatenWord.value = this.food.value.word\n      }\n      this.playEatFoodSound()\n      \n      // Check if this was the last word before generating new food  \n      if (this.isLastWord) {\n        // All words completed, end game immediately\n        // The wordsCompleted++ above will be handled by the Vue watcher\n        this.setGameOver()\n        return\n      }\n      \n      // Grow snake (no tail pop)\n      this.generateFood(this.words, this.vietnameseMode)\n    } else if (hitSecondary) {\n      // Wrong food eaten\n      this.wrongEatenCount.value++\n      if (this.secondaryFood.value) {\n        this.lastEatenFoodPos.value = { ...this.secondaryFood.value.position }\n        this.lastEatenWord.value = this.secondaryFood.value.word\n      }\n      // Do not grow snake: remove tail\n      snake.body.pop()\n      // Regenerate foods\n      this.generateFood(this.words, this.vietnameseMode)\n    } else {\n      // No food eaten -> move normally\n      snake.body.pop()\n    }\n  \n    // Emit timeline frame after each successful move\n    if (this.onMoveCallback) {\n      this.onMoveCallback([...snake.body.map(seg => ({ x: seg.x, y: seg.y }))], { x: snake.direction.x, y: snake.direction.y })\n    }\n  }\n\n  generateFood(words: Vocabulary[], vietnameseMode: boolean) {\n    this.words = words\n    this.vietnameseMode = vietnameseMode\n\n    if (words.length === 0) return\n\n    // Filter unused words\n    const availableWords = words.filter(w => !this.usedWords.has(w.word))\n    if (availableWords.length === 0) {\n      // All words used, complete game\n      this.setGameOver()\n      return\n    }\n\n    // Select target word\n    const targetWord = availableWords[Math.floor(Math.random() * availableWords.length)]\n    this.usedWords.add(targetWord.word)\n    this.currentTargetWord.value = targetWord.word\n\n    // Check if this was the last word after adding to usedWords\n    const remainingWords = words.filter(w => !this.usedWords.has(w.word))\n    if (remainingWords.length === 0) {\n      // This was the last word, game will end after this food is eaten\n      this.isLastWord = true\n    } else {\n      this.isLastWord = false\n    }\n\n    // Utility: random free position not on snake and not conflicting with provided list\n    const randomFreePos = (blocked: Position[] = []): Position => {\n      let pos: Position\n      do {\n        pos = {\n          x: Math.floor(Math.random() * 25) + 2, // Grid 30x20, avoid edges\n          y: Math.floor(Math.random() * 15) + 2\n        }\n      } while (\n        this.snake.value.body.some(seg => seg.x === pos.x && seg.y === pos.y) ||\n        blocked.some(b => b.x === pos.x && b.y === pos.y)\n      )\n      return pos\n    }\n\n    // Create primary (correct) food\n    const primaryPos = randomFreePos()\n    this.food.value = {\n      position: primaryPos,\n      word: targetWord.word,\n      firstLetter: vietnameseMode && targetWord.meaning\n        ? targetWord.meaning.charAt(0).toUpperCase()\n        : targetWord.word.charAt(0).toUpperCase(),\n      meaning: targetWord.meaning\n    }\n\n    // If double bait disabled -> clear secondary and exit\n    if (!this.doubleBaitMode.value) {\n      this.secondaryFood.value = null\n      return\n    }\n\n    // Choose a wrong word distinct from target\n    const others = words.filter(w => w.word !== targetWord.word)\n    if (others.length === 0) {\n      this.secondaryFood.value = null\n      return\n    }\n    const wrong = others[Math.floor(Math.random() * others.length)]\n\n    // Generate secondary food position distinct from primary\n    const secondaryPos = randomFreePos([primaryPos])\n    this.secondaryFood.value = {\n      position: secondaryPos,\n      word: wrong.word,\n      firstLetter: vietnameseMode && wrong.meaning\n        ? wrong.meaning.charAt(0).toUpperCase()\n        : wrong.word.charAt(0).toUpperCase(),\n      meaning: wrong.meaning\n    }\n  }\n\n  checkCollision(): boolean {\n    const head = this.snake.value.body[0]\n\n    // Only self collision (walls wrap-around handled in moveSnake)\n    for (let i = 1; i < this.snake.value.body.length; i++) {\n      if (head.x === this.snake.value.body[i].x && head.y === this.snake.value.body[i].y) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  checkFoodCollision(): boolean {\n    if (!this.food.value) return false\n    \n    const head = this.snake.value.body[0]\n    return head.x === this.food.value.position.x && head.y === this.food.value.position.y\n  }\n\n  incrementScore() {\n    this.score.value += 10\n  }\n\n  setGameOver() {\n    this.gameOver.value = true\n    this.gameRunning.value = false\n  }\n\n  setGameRunning(running: boolean) {\n    this.gameRunning.value = running\n  }\n\n  setDoubleBaitMode(enabled: boolean, words?: Vocabulary[], vietnameseMode?: boolean) {\n    this.doubleBaitMode.value = enabled\n    // If words/mode provided, regenerate immediately (handles pre-start toggle)\n    if (words && typeof vietnameseMode === 'boolean') {\n      this.generateFood(words, vietnameseMode)\n      return\n    }\n    // Otherwise, when toggled during a running game, regenerate with existing state\n    if (this.gameRunning.value && !this.gameOver.value) {\n      this.generateFood(this.words, this.vietnameseMode)\n    }\n  }\n\n  // Set timeline recording callback\n  setTimelineCallback(callback?: (body: Position[], direction: Position) => void) {\n    this.onMoveCallback = callback\n  }\n\n  private initializeAudioContext() {\n    if (!this.audioContext) {\n      try {\n        this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)()\n      } catch (error) {\n        console.warn('Web Audio API not supported:', error)\n      }\n    }\n  }\n\n  private playEatFoodSound() {\n    this.initializeAudioContext()\n    \n    if (!this.audioContext) return\n\n    try {\n      // Create a pleasant eating sound - ascending notes (C-E-G major chord)\n      const currentTime = this.audioContext.currentTime\n      const gainNode = this.audioContext.createGain()\n      gainNode.connect(this.audioContext.destination)\n\n      // Play three quick notes in sequence (major chord)\n      const frequencies = [261.63, 329.63, 392.00] // C4, E4, G4\n      \n      frequencies.forEach((freq, index) => {\n        const oscillator = this.audioContext!.createOscillator()\n        const noteGain = this.audioContext!.createGain()\n        \n        oscillator.connect(noteGain)\n        noteGain.connect(gainNode)\n        \n        oscillator.frequency.setValueAtTime(freq, currentTime)\n        oscillator.type = 'sine' // Pleasant sine wave\n        \n        // Quick attack and decay for each note\n        const startTime = currentTime + (index * 0.08)\n        const endTime = startTime + 0.15\n        \n        noteGain.gain.setValueAtTime(0, startTime)\n        noteGain.gain.linearRampToValueAtTime(0.3, startTime + 0.02)\n        noteGain.gain.exponentialRampToValueAtTime(0.01, endTime)\n        \n        oscillator.start(startTime)\n        oscillator.stop(endTime)\n      })\n      \n    } catch (error) {\n      console.warn('Error playing eat food sound:', error)\n    }\n  }\n}\n\nexport default SnakeStateManager\n","import { ref } from 'vue'\nimport type { ISnakeCanvasRenderer, ISnakeStateManager, Food, Snake } from './types'\n\nclass SnakeCanvasRenderer implements ISnakeCanvasRenderer {\n  canvasWidth = ref(600)\n  canvasHeight = ref(400)\n  gridSize = ref(20)\n  \n  private canvas: HTMLCanvasElement | null = null\n  private ctx: CanvasRenderingContext2D | null = null\n\n  // Simple particle system for explosion effect\n  private particles: Array<{\n    x: number\n    y: number\n    vx: number\n    vy: number\n    life: number\n    maxLife: number\n    radius: number\n    color: string\n  }> = []\n\n  // Tomato juice splatter stains (fade on the floor)\n  private stains: Array<{\n    x: number\n    y: number\n    radius: number\n    alpha: number\n    decay: number\n    color: string\n  }> = []\n\n  // Shock rings for a juicy burst feeling\n  private rings: Array<{\n    x: number\n    y: number\n    r: number\n    maxR: number\n    life: number\n    maxLife: number\n    color: string\n  }> = []\n\n  initialize(canvas: HTMLCanvasElement) {\n    this.canvas = canvas\n    this.ctx = canvas.getContext('2d')\n    \n    // Set canvas size\n    canvas.width = this.canvasWidth.value\n    canvas.height = this.canvasHeight.value\n    \n    // Handle resize\n    const resizeObserver = new ResizeObserver(() => {\n      this.handleResize()\n    })\n    resizeObserver.observe(canvas.parentElement || canvas)\n  }\n\n  // Draw a small label with the food meaning above the tile\n  private drawFoodLabel(food: Food, variant: 'primary' | 'secondary') {\n    if (!this.ctx) return\n    const ctx = this.ctx\n    const gridSize = this.gridSize.value\n    const x = food.position.x * gridSize\n    const y = food.position.y * gridSize\n\n    const text = (food.meaning || food.word || '').toString()\n    if (!text) return\n\n    ctx.save()\n    // Style: background and stroke depend on variant, dark-mode safe\n    const bg = variant === 'primary' ? '#065f46' : '#7c2d12' // emerald-800 / amber-900-like\n    const stroke = variant === 'primary' ? '#10b981' : '#f59e0b' // emerald-500 / amber-500\n    const textColor = '#ffffff'\n\n    ctx.font = `${Math.max(10, Math.floor(gridSize * 0.6))}px sans-serif`\n    const paddingX = 6\n    const paddingY = 4\n    const metrics = ctx.measureText(text)\n    const textWidth = metrics.width\n    const labelWidth = textWidth + paddingX * 2\n    const labelHeight = Math.max(gridSize * 0.7, 16)\n    const labelX = x + gridSize / 2 - labelWidth / 2\n    const labelY = y - labelHeight - 6 // 6px above the tile\n\n    // Background rounded rect\n    const r = 6\n    ctx.beginPath()\n    ctx.moveTo(labelX + r, labelY)\n    ctx.lineTo(labelX + labelWidth - r, labelY)\n    ctx.quadraticCurveTo(labelX + labelWidth, labelY, labelX + labelWidth, labelY + r)\n    ctx.lineTo(labelX + labelWidth, labelY + labelHeight - r)\n    ctx.quadraticCurveTo(labelX + labelWidth, labelY + labelHeight, labelX + labelWidth - r, labelY + labelHeight)\n    ctx.lineTo(labelX + r, labelY + labelHeight)\n    ctx.quadraticCurveTo(labelX, labelY + labelHeight, labelX, labelY + labelHeight - r)\n    ctx.lineTo(labelX, labelY + r)\n    ctx.quadraticCurveTo(labelX, labelY, labelX + r, labelY)\n    ctx.closePath()\n    ctx.fillStyle = bg\n    ctx.fill()\n    ctx.strokeStyle = stroke\n    ctx.lineWidth = 2\n    ctx.stroke()\n\n    // Text\n    ctx.fillStyle = textColor\n    ctx.textBaseline = 'middle'\n    ctx.textAlign = 'center'\n    ctx.fillText(text, labelX + labelWidth / 2, labelY + labelHeight / 2)\n\n    ctx.restore()\n  }\n\n  private handleResize() {\n    if (!this.canvas) return\n    \n    const container = this.canvas.parentElement\n    if (container) {\n      const rect = container.getBoundingClientRect()\n      const aspectRatio = 30 / 20 // Grid ratio\n      \n      let width = Math.min(rect.width - 40, 600)\n      let height = width / aspectRatio\n      \n      if (height > rect.height - 40) {\n        height = rect.height - 40\n        width = height * aspectRatio\n      }\n      \n      this.canvasWidth.value = width\n      this.canvasHeight.value = height\n      this.gridSize.value = width / 30\n      \n      this.canvas.width = width\n      this.canvas.height = height\n    }\n  }\n\n  render(stateManager: ISnakeStateManager) {\n    if (!this.ctx) return\n    \n    this.clearCanvas()\n    this.drawGrid()\n    // Stains below food/snake so they look on the ground\n    this.updateAndDrawStains()\n    // Draw primary and secondary foods if available\n    this.drawFood(stateManager.food.value, 'primary')\n    this.drawFood(stateManager.secondaryFood?.value || null, 'secondary')\n    // If double bait mode is enabled, show meaning labels above foods\n    if ((stateManager as any).doubleBaitMode?.value) {\n      if (stateManager.food.value) this.drawFoodLabel(stateManager.food.value, 'primary')\n      if (stateManager.secondaryFood?.value) this.drawFoodLabel(stateManager.secondaryFood.value, 'secondary')\n    }\n    this.drawSnake(stateManager.snake.value)\n\n    // Spawn explosion particles if a food was just eaten\n    if (stateManager.lastEatenFoodPos.value) {\n      const gs = this.gridSize.value\n      const cx = stateManager.lastEatenFoodPos.value.x * gs + gs / 2\n      const cy = stateManager.lastEatenFoodPos.value.y * gs + gs / 2\n      this.spawnExplosion(cx, cy)\n      this.spawnSplatStains(cx, cy)\n      this.spawnShockRing(cx, cy)\n      // Reset the flag so we only spawn once per eat\n      stateManager.lastEatenFoodPos.value = null\n    }\n\n    // Update and draw particles on top\n    this.updateAndDrawParticles()\n    // Draw shock rings last\n    this.updateAndDrawRings()\n  }\n\n  clearCanvas() {\n    if (!this.ctx) return\n    // Dark mode compliant background (no gray). Use project dark base.\n    this.ctx.fillStyle = '#0a0a0a'\n    this.ctx.fillRect(0, 0, this.canvasWidth.value, this.canvasHeight.value)\n  }\n\n  private drawGrid() {\n    if (!this.ctx) return\n    \n    // Subtle grid lines without using gray in dark mode\n    this.ctx.strokeStyle = '#0f0f0f'\n    this.ctx.lineWidth = 1\n    \n    const gridSize = this.gridSize.value\n    \n    // Vertical lines\n    for (let x = 0; x <= 30; x++) {\n      this.ctx.beginPath()\n      this.ctx.moveTo(x * gridSize, 0)\n      this.ctx.lineTo(x * gridSize, this.canvasHeight.value)\n      this.ctx.stroke()\n    }\n    \n    // Horizontal lines  \n    for (let y = 0; y <= 20; y++) {\n      this.ctx.beginPath()\n      this.ctx.moveTo(0, y * gridSize)\n      this.ctx.lineTo(this.canvasWidth.value, y * gridSize)\n      this.ctx.stroke()\n    }\n  }\n\n  private drawSnake(snake: Snake) {\n    if (!this.ctx) return\n    \n    const gridSize = this.gridSize.value\n    \n    snake.body.forEach((segment, index) => {\n      if (!this.ctx) return // Add null check inside loop\n      \n      // Snake body color\n      if (index === 0) {\n        // Head - brighter green\n        this.ctx.fillStyle = '#10b981'\n      } else {\n        // Body - darker green\n        this.ctx.fillStyle = '#059669'\n      }\n      \n      this.ctx.fillRect(\n        segment.x * gridSize + 1,\n        segment.y * gridSize + 1,\n        gridSize - 2,\n        gridSize - 2\n      )\n      \n      // Add border\n      this.ctx.strokeStyle = '#047857'\n      this.ctx.lineWidth = 2\n      this.ctx.strokeRect(\n        segment.x * gridSize + 1,\n        segment.y * gridSize + 1,\n        gridSize - 2,\n        gridSize - 2\n      )\n    })\n  }\n\n  private drawFood(food: Food | null, variant: 'primary' | 'secondary' = 'primary') {\n    if (!this.ctx || !food) return\n    \n    const gridSize = this.gridSize.value\n    const x = food.position.x * gridSize\n    const y = food.position.y * gridSize\n\n    // Food - tomato circle with glossy highlight\n    // Use distinct color for secondary (wrong) food\n    this.ctx.fillStyle = variant === 'secondary' ? '#f59e0b' : '#ef4444'\n    this.ctx.beginPath()\n    this.ctx.arc(x + gridSize / 2, y + gridSize / 2, gridSize * 0.35, 0, Math.PI * 2)\n    this.ctx.fill()\n    \n    // Food glossy highlight\n    this.ctx.fillStyle = 'rgba(255,255,255,0.8)'\n    this.ctx.beginPath()\n    this.ctx.arc(x + gridSize / 2 - 3, y + gridSize / 2 - 3, gridSize * 0.12, 0, Math.PI * 2)\n    this.ctx.fill()\n\n    // Letter inside food\n    this.ctx.fillStyle = '#111827'\n    this.ctx.font = `${Math.floor(gridSize * 0.6)}px Inter, system-ui, -apple-system, Segoe UI, Roboto`\n    this.ctx.textAlign = 'center'\n    this.ctx.textBaseline = 'middle'\n    this.ctx.fillText(\n      food.firstLetter,\n      x + gridSize / 2,\n      y + gridSize / 2\n    )\n  }\n\n  // Particle helpers\n  private spawnExplosion(cx: number, cy: number) {\n    // Emit a burst of particles with project-friendly colors (no gray)\n    // Tomato palette: juicy reds with some amber highlights\n    const colors = ['#ef4444', '#dc2626', '#f43f5e', '#f59e0b']\n    const count = 20\n    for (let i = 0; i < count; i++) {\n      const angle = (Math.PI * 2 * i) / count\n      const speed = 5.0 + Math.random() * 3.0\n      this.particles.push({\n        x: cx,\n        y: cy,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed,\n        life: 0,\n        maxLife: 6 + Math.floor(Math.random() * 5), // very short for instant burst\n        radius: 1.5 + Math.random() * 1.5,\n        color: colors[Math.floor(Math.random() * colors.length)]\n      })\n    }\n    // Cap total particles to keep performance good on mobile\n    if (this.particles.length > 300) {\n      this.particles.splice(0, this.particles.length - 300)\n    }\n  }\n\n  private updateAndDrawParticles() {\n    if (!this.ctx) return\n    const gravity = 0.0\n    const friction = 1.0\n    for (let i = this.particles.length - 1; i >= 0; i--) {\n      const p = this.particles[i]\n      // Update\n      p.vx *= friction\n      p.vy = p.vy * friction + gravity\n      p.x += p.vx\n      p.y += p.vy\n      p.life++\n\n      // Draw with fade-out\n      const alpha = Math.max(0, 1 - p.life / p.maxLife)\n      this.ctx.globalAlpha = alpha\n      this.ctx.fillStyle = p.color\n      this.ctx.beginPath()\n      this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2)\n      this.ctx.fill()\n      this.ctx.globalAlpha = 1\n\n      // Remove dead particles\n      if (p.life >= p.maxLife) {\n        this.particles.splice(i, 1)\n      }\n    }\n  }\n\n  private spawnSplatStains(cx: number, cy: number) {\n    // A few larger stains that fade quickly (simulate tomato juice landing)\n    const stainColors = ['#b91c1c', '#dc2626', '#ef4444']\n    const splats = 3 + Math.floor(Math.random() * 3)\n    for (let i = 0; i < splats; i++) {\n      const offsetR = Math.random() * 10\n      const offsetA = Math.random() * Math.PI * 2\n      const sx = cx + Math.cos(offsetA) * offsetR\n      const sy = cy + Math.sin(offsetA) * offsetR\n      this.stains.push({\n        x: sx,\n        y: sy,\n        radius: 6 + Math.random() * 8,\n        alpha: 0.6,\n        decay: 0.06 + Math.random() * 0.06,\n        color: stainColors[Math.floor(Math.random() * stainColors.length)]\n      })\n    }\n    // Limit stain list\n    if (this.stains.length > 80) {\n      this.stains.splice(0, this.stains.length - 80)\n    }\n  }\n\n  private updateAndDrawStains() {\n    if (!this.ctx) return\n    for (let i = this.stains.length - 1; i >= 0; i--) {\n      const s = this.stains[i]\n      // Draw blurred-like soft circle via alpha fill\n      this.ctx.globalAlpha = Math.max(0, s.alpha)\n      this.ctx.fillStyle = s.color\n      this.ctx.beginPath()\n      this.ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2)\n      this.ctx.fill()\n      this.ctx.globalAlpha = 1\n\n      s.alpha -= s.decay\n      if (s.alpha <= 0) {\n        this.stains.splice(i, 1)\n      }\n    }\n  }\n\n  private spawnShockRing(cx: number, cy: number) {\n    // Single quick ring that expands and fades\n    this.rings.push({\n      x: cx,\n      y: cy,\n      r: 2,\n      maxR: 28,\n      life: 0,\n      maxLife: 10,\n      color: '#ef4444'\n    })\n  }\n\n  private updateAndDrawRings() {\n    if (!this.ctx) return\n    for (let i = this.rings.length - 1; i >= 0; i--) {\n      const ring = this.rings[i]\n      ring.life++\n      const t = ring.life / ring.maxLife\n      ring.r = 2 + (ring.maxR - 2) * t\n      const alpha = Math.max(0, 1 - t)\n      this.ctx.globalAlpha = alpha\n      this.ctx.strokeStyle = ring.color\n      this.ctx.lineWidth = 2\n      this.ctx.beginPath()\n      this.ctx.arc(ring.x, ring.y, ring.r, 0, Math.PI * 2)\n      this.ctx.stroke()\n      this.ctx.globalAlpha = 1\n      if (ring.life >= ring.maxLife) {\n        this.rings.splice(i, 1)\n      }\n    }\n  }\n}\n\nexport default SnakeCanvasRenderer\n","import { ref } from 'vue'\nimport type { ISnakeGameEngine, ISnakeStateManager, ISnakeCanvasRenderer } from './types'\n\nclass SnakeGameEngine implements ISnakeGameEngine {\n  gameLoopId = ref<number | null>(null)\n  private lastTimestamp: number = 0\n  private accumulatorMs: number = 0\n\n  startGameLoop(stateManager: ISnakeStateManager, renderer: ISnakeCanvasRenderer) {\n    if (this.gameLoopId.value) return\n\n    this.lastTimestamp = performance.now()\n    this.accumulatorMs = 0\n\n    const frame = (ts: number) => {\n      const dt = ts - this.lastTimestamp\n      this.lastTimestamp = ts\n      this.accumulatorMs += dt\n\n      // Move the snake at its configured interval (can move multiple times if lag)\n      while (\n        stateManager.gameRunning.value &&\n        !stateManager.gameOver.value &&\n        this.accumulatorMs >= stateManager.gameSpeed.value\n      ) {\n        stateManager.moveSnake()\n        this.accumulatorMs -= stateManager.gameSpeed.value\n      }\n\n      // Always render every frame for smooth particle animation\n      renderer.render(stateManager)\n\n      if (stateManager.gameRunning.value && !stateManager.gameOver.value) {\n        this.gameLoopId.value = requestAnimationFrame(frame)\n      } else {\n        this.gameLoopId.value = null\n      }\n    }\n\n    this.gameLoopId.value = requestAnimationFrame(frame)\n  }\n\n  stopGameLoop() {\n    if (this.gameLoopId.value) {\n      cancelAnimationFrame(this.gameLoopId.value)\n      this.gameLoopId.value = null\n    }\n  }\n}\n\nexport default SnakeGameEngine\n","import type { Vocabulary } from '../../../../composables/useVocabularyStore'\nimport SnakeStateManager from './SnakeStateManager'\nimport SnakeCanvasRenderer from './SnakeCanvasRenderer'\nimport SnakeGameEngine from './SnakeGameEngine'\nimport type { ISnakeGame, ISnakeStateManager, ISnakeCanvasRenderer, ISnakeGameEngine } from './types'\n\nclass SnakeGame implements ISnakeGame {\n  stateManager: ISnakeStateManager\n  canvasRenderer: ISnakeCanvasRenderer\n  gameEngine: ISnakeGameEngine\n\n  constructor() {\n    this.stateManager = new SnakeStateManager()\n    this.canvasRenderer = new SnakeCanvasRenderer()\n    this.gameEngine = new SnakeGameEngine()\n  }\n\n  initialize(canvas: HTMLCanvasElement, words: Vocabulary[], vietnameseMode: boolean = false) {\n    this.canvasRenderer.initialize(canvas)\n    this.stateManager.resetGame()\n    this.stateManager.generateFood(words, vietnameseMode)\n    this.canvasRenderer.render(this.stateManager)\n  }\n\n  startGame() {\n    if (this.stateManager.gameRunning.value) return\n    \n    this.stateManager.setGameRunning(true)\n    // Start moving right\n    this.stateManager.updateDirection({ x: 1, y: 0 })\n    this.gameEngine.startGameLoop(this.stateManager, this.canvasRenderer)\n  }\n\n  stopGame() {\n    this.stateManager.setGameRunning(false)\n    this.gameEngine.stopGameLoop()\n  }\n\n  handleKeyPress(event: KeyboardEvent) {\n    if (!this.stateManager.gameRunning.value || this.stateManager.gameOver.value) return\n\n    const directions = {\n      ArrowUp: { x: 0, y: -1 },\n      ArrowDown: { x: 0, y: 1 },\n      ArrowLeft: { x: -1, y: 0 },\n      ArrowRight: { x: 1, y: 0 },\n      w: { x: 0, y: -1 },\n      s: { x: 0, y: 1 },\n      a: { x: -1, y: 0 },\n      d: { x: 1, y: 0 }\n    }\n\n    const direction = directions[event.key as keyof typeof directions]\n    if (direction) {\n      event.preventDefault()\n      this.stateManager.updateDirection(direction)\n    }\n  }\n\n  updateVietnameseMode(_vietnameseMode: boolean) {\n    // Regenerate food with new mode if game is running\n    if (this.stateManager.gameRunning.value && this.stateManager.food.value) {\n      // We need words to regenerate food, but we don't store them in state\n      // This will be handled by the component when mode changes\n    }\n  }\n\n  cleanup() {\n    this.stopGame()\n  }\n}\n\nexport default SnakeGame\n\nexport function useSnakeGameFactory(): ISnakeGame {\n  return new SnakeGame()\n}\n","// Snake Game Interfaces (OOP pattern)\nexport * from './types'\n\n// Snake Game Factory\nimport SnakeGame from './SnakeGame'\n\nexport function useSnakeGame() {\n  return new SnakeGame()\n}\n","<template>\n  <div class=\"snake-game h-full min-h-[600px] sm:min-h-[500px] md:min-h-0 flex flex-col\">\n    <!-- Game Header -->\n    <div class=\"p-4 sm:p-6 md:p-8 bg-gradient-to-r from-green-600 to-emerald-600 dark:from-green-800 dark:to-emerald-800 text-white\">\n      <div class=\"flex justify-between items-center\">\n        <div>\n          <h2 class=\"text-lg sm:text-xl md:text-2xl font-bold\">{{ t('flashcard.snakeGame.title', 'Snake Hunt') }}</h2>\n          <p class=\"text-sm sm:text-base opacity-90\">{{ t('flashcard.snakeGame.instruction', 'Guide the snake to catch vocabulary letters!') }}</p>\n        </div>\n        <div class=\"text-right\">\n          <div class=\"text-2xl sm:text-3xl font-bold\">{{ score }}</div>\n          <div class=\"text-xs sm:text-sm opacity-90\">{{ t('flashcard.snakeGame.score', 'Score') }}</div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Game Area -->\n    <div class=\"flex-1 min-h-[450px] sm:min-h-[350px] md:min-h-0 relative bg-gradient-to-b from-gray-100 to-gray-200 dark:from-[#0a0a0a] dark:to-[#0f0f0f] overflow-hidden\">\n      <canvas\n        ref=\"gameCanvas\"\n        class=\"w-full h-full border-2 border-gray-300 dark:border-[#0f0f0f]\"\n        tabindex=\"0\"\n        @keydown=\"handleKeyPress\"\n      ></canvas>\n      \n      <!-- Current Target Word Display (on snake head) -->\n      <div \n        v-if=\"currentTargetWord && gameRunning && !gameOver\"\n        class=\"absolute bg-white dark:bg-[#0a0a0a] rounded-lg px-3 py-2 shadow-lg border-2 border-green-500 pointer-events-none\"\n        :style=\"snakeHeadDisplayStyle\"\n      >\n        <div class=\"text-center\">\n          <div class=\"text-sm sm:text-base font-bold text-gray-800 dark:text-white\">{{ currentTargetWord }}</div>\n          <div v-if=\"currentTargetPronunciationDisplay\" class=\"text-xs sm:text-sm text-gray-700 dark:text-white/80\">{{ currentTargetPronunciationDisplay }}</div>\n          <div class=\"text-[11px] sm:text-xs text-gray-600 dark:text-white/70\">{{ t('flashcard.snakeGame.target', 'Target') }}</div>\n        </div>\n      </div>\n\n      <!-- Controls Instruction -->\n      <div v-if=\"!gameRunning && !gameOver\" class=\"absolute top-4 left-4 bg-white/90 dark:bg-[#0a0a0a]/90 rounded-lg p-3 backdrop-blur-sm\">\n        <div class=\"text-sm text-gray-700 dark:text-white\">\n          <div class=\"font-semibold mb-1\">{{ t('flashcard.snakeGame.controls', 'Controls') }}:</div>\n          <div class=\"text-xs space-y-1\">\n            <div>{{ t('flashcard.snakeGame.arrowKeys', 'Arrow Keys / WASD') }}</div>\n            <div>{{ t('flashcard.snakeGame.clickToStart', 'Click START to begin') }}</div>\n          </div>\n        </div>\n      </div>\n\n      <!-- Game Stats -->\n      <div class=\"absolute top-4 right-4 bg-white/90 dark:bg-[#0a0a0a]/90 rounded-lg p-3 backdrop-blur-sm\">\n        <div class=\"text-center text-sm\">\n          <div class=\"text-xs text-gray-600 dark:text-white/70\">{{ t('flashcard.snakeGame.completed', 'Completed') }}</div>\n          <div class=\"text-lg font-bold text-green-600 dark:text-green-400\">{{ wordsCompleted }}</div>\n        </div>\n      </div>\n\n      <!-- Start Game Button -->\n      <div v-if=\"!gameRunning && !gameOver\" class=\"absolute inset-0 flex items-center justify-center\">\n        <button \n          @click=\"startGame\"\n          class=\"px-8 py-4 bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white rounded-2xl font-bold text-lg transform hover:scale-105 transition-all duration-200 shadow-2xl\"\n        >\n          {{ t('flashcard.snakeGame.start', 'START HUNT') }}\n        </button>\n      </div>\n\n      <!-- Touch Controls (visible on xs/sm/md only) -->\n      <div\n        class=\"lg:hidden absolute bottom-3 left-0 right-0 flex items-center justify-center select-none\"\n        aria-hidden=\"false\"\n      >\n        <div class=\"inline-flex flex-col items-center gap-2 bg-white/90 dark:bg-[#0a0a0a]/90 border border-gray-200 dark:border-[#0f0f0f] rounded-xl p-3 shadow-lg\">\n          <!-- Up -->\n          <button\n            type=\"button\"\n            :aria-label=\"t('flashcard.snakeGame.up', 'Up')\"\n            class=\"w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 rounded-lg flex items-center justify-center bg-emerald-500 hover:bg-emerald-600 text-white shadow active:scale-95 transition\"\n            @click=\"changeDirection(0, -1)\"\n          >\n            <svg class=\"w-6 h-6 sm:w-7 sm:h-7\" viewBox=\"0 0 20 20\" fill=\"currentColor\"><path fill-rule=\"evenodd\" d=\"M10 4a.75.75 0 01.53.22l5 5a.75.75 0 11-1.06 1.06L10.75 6.56V16a.75.75 0 01-1.5 0V6.56L5.53 10.28a.75.75 0 01-1.06-1.06l5-5A.75.75 0 0110 4z\" clip-rule=\"evenodd\"/></svg>\n          </button>\n          <!-- Middle row: Left / Down / Right -->\n          <div class=\"flex items-center gap-2\">\n            <button\n              type=\"button\"\n              :aria-label=\"t('flashcard.snakeGame.left', 'Left')\"\n              class=\"w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 rounded-lg flex items-center justify-center bg-emerald-500 hover:bg-emerald-600 text-white shadow active:scale-95 transition\"\n              @click=\"changeDirection(-1, 0)\"\n            >\n              <svg class=\"w-6 h-6 sm:w-7 sm:h-7\" viewBox=\"0 0 20 20\" fill=\"currentColor\"><path fill-rule=\"evenodd\" d=\"M4 10a.75.75 0 01.22-.53l5-5a.75.75 0 111.06 1.06L6.56 9.25H16a.75.75 0 010 1.5H6.56l3.72 3.72a.75.75 0 11-1.06 1.06l-5-5A.75.75 0 014 10z\" clip-rule=\"evenodd\"/></svg>\n            </button>\n            <button\n              type=\"button\"\n              :aria-label=\"t('flashcard.snakeGame.down', 'Down')\"\n              class=\"w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 rounded-lg flex items-center justify-center bg-emerald-500 hover:bg-emerald-600 text-white shadow active:scale-95 transition\"\n              @click=\"changeDirection(0, 1)\"\n            >\n              <svg class=\"w-6 h-6 sm:w-7 sm:h-7\" viewBox=\"0 0 20 20\" fill=\"currentColor\"><path fill-rule=\"evenodd\" d=\"M10 16a.75.75 0 01-.53-.22l-5-5a.75.75 0 111.06-1.06l3.72 3.72V4a.75.75 0 011.5 0v9.44l3.72-3.72a.75.75 0 111.06 1.06l-5 5A.75.75 0 0110 16z\" clip-rule=\"evenodd\"/></svg>\n            </button>\n            <button\n              type=\"button\"\n              :aria-label=\"t('flashcard.snakeGame.right', 'Right')\"\n              class=\"w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 rounded-lg flex items-center justify-center bg-emerald-500 hover:bg-emerald-600 text-white shadow active:scale-95 transition\"\n              @click=\"changeDirection(1, 0)\"\n            >\n              <svg class=\"w-6 h-6 sm:w-7 sm:h-7\" viewBox=\"0 0 20 20\" fill=\"currentColor\"><path fill-rule=\"evenodd\" d=\"M16 10a.75.75 0 01-.22.53l-5 5a.75.75 0 11-1.06-1.06l3.72-3.72H4a.75.75 0 010-1.5h9.44L9.72 5.53a.75.75 0 111.06-1.06l5 5c.14.14.22.33.22.53z\" clip-rule=\"evenodd\"/></svg>\n            </button>\n          </div>\n        </div>\n      </div>\n\n      <!-- Game Over Modal -->\n      <transition name=\"modal\" appear>\n        <div v-if=\"gameOver\" class=\"absolute inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center p-4\">\n          <div class=\"bg-white dark:bg-[#0a0a0a] rounded-2xl p-6 sm:p-8 max-w-md w-full text-center shadow-2xl border border-gray-200 dark:border-[#0f0f0f]\">\n            <!-- Animated Success Icon -->\n            <div class=\"w-16 h-16 sm:w-20 sm:h-20 mx-auto mb-4 bg-gradient-to-r from-green-400 to-emerald-500 rounded-full flex items-center justify-center animate-pulse\">\n              <svg class=\"w-8 h-8 sm:w-10 sm:h-10 text-white\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n                <path fill-rule=\"evenodd\" d=\"M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z\" clip-rule=\"evenodd\"/>\n              </svg>\n            </div>\n            \n            <h3 class=\"text-xl sm:text-2xl font-bold mb-2 text-gray-800 dark:text-white\">\n              {{ t('flashcard.snakeGame.gameComplete', 'Hunt Complete!') }}\n            </h3>\n            <p class=\"text-gray-600 dark:text-white/70 mb-4\">\n              {{ t('flashcard.snakeGame.finalScore', { score }, `Final Score: ${score}`) }}\n            </p>\n            <p class=\"text-sm text-gray-500 dark:text-white/60 mb-6\">\n              {{ t('flashcard.snakeGame.wordsHunted', { count: wordsCompleted }, `Words hunted: ${wordsCompleted}`) }}\n            </p>\n            \n            <div class=\"flex gap-3 justify-center\">\n              <button \n                @click=\"restartGame\"\n                class=\"px-6 py-2 bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white rounded-lg font-medium transform hover:scale-105 transition-all duration-200\"\n              >\n                {{ t('flashcard.snakeGame.playAgain', 'Hunt Again') }}\n              </button>\n              <button \n                @click=\"$emit('game-complete')\"\n                class=\"px-6 py-2 bg-gray-500 hover:bg-gray-600 dark:bg-[#0f0f0f] dark:hover:bg-[#1a1a1a] text-white rounded-lg font-medium transform hover:scale-105 transition-all duration-200\"\n              >\n                {{ t('common.finish', 'Finish') }}\n              </button>\n            </div>\n          </div>\n        </div>\n      </transition>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, onMounted, onUnmounted, nextTick, computed, watch } from 'vue'\nimport { useI18n } from 'vue-i18n'\nimport type { Vocabulary } from '../../../composables/useVocabularyStore'\nimport { useSnakeGame, type ISnakeGame } from '../composables/snake-game'\nimport { useVoiceStore } from '../../../stores/voiceStore'\n\ninterface Props {\n  words: Vocabulary[]\n  vietnameseMode?: boolean\n  // Enable dual-food mode (correct + incorrect bait)\n  doubleBaitMode?: boolean\n  // When enabled, record per-frame snake states for accurate replay timeline\n  recordTimeline?: boolean\n}\n\nconst props = defineProps<Props>()\nconst { t } = useI18n()\n\nconst emit = defineEmits<{\n  'game-complete': []\n  'correct-food-eaten': [details: {\n    word: string\n    meaningShort: string\n    position: { x: number; y: number }\n    snakeLength: number\n    gameScore: number\n    wordsCompleted: number\n    wrongEatenCount: number\n    snakeBody: { x: number; y: number }[]\n    direction: { x: number; y: number }\n    timelineFrames?: Array<{ body: { x: number; y: number }[]; direction: { x: number; y: number } }>\n  }]\n  'wrong-food-eaten': [details: {\n    word: string\n    meaningShort: string\n    position: { x: number; y: number }\n    snakeLength: number\n    gameScore: number\n    wordsCompleted: number\n    wrongEatenCount: number\n    snakeBody: { x: number; y: number }[]\n    direction: { x: number; y: number }\n    timelineFrames?: Array<{ body: { x: number; y: number }[]; direction: { x: number; y: number } }>\n  }]\n}>()\n\n// Initialize main game controller with OOP pattern\nconst game: ISnakeGame = useSnakeGame()\n\n// Expose reactive properties for template binding\nconst gameCanvas = ref<HTMLCanvasElement>()\nconst canvasWidth = computed(() => game.canvasRenderer.canvasWidth.value)\nconst canvasHeight = computed(() => game.canvasRenderer.canvasHeight.value)\nconst gridSize = computed(() => game.canvasRenderer.gridSize.value)\nconst score = computed(() => game.stateManager.score.value)\nconst wordsCompleted = computed(() => game.stateManager.wordsCompleted.value)\nconst gameOver = computed(() => game.stateManager.gameOver.value)\nconst gameRunning = computed(() => game.stateManager.gameRunning.value)\nconst currentTargetWord = computed(() => game.stateManager.currentTargetWord.value)\nconst snakeHead = computed(() => game.stateManager.snake.value.body[0])\n\n// Timeline recording for accurate replay\nconst timelineFrames = ref<Array<{ body: { x: number; y: number }[]; direction: { x: number; y: number } }>>([])  \n\n// Timeline callback for recording actual move frames\nconst handleTimelineFrame = (body: { x: number; y: number }[], direction: { x: number; y: number }) => {\n  if (!props.recordTimeline) return\n  timelineFrames.value.push({\n    body: [...body],\n    direction: { ...direction }\n  })\n}\n\n// Watch recordTimeline prop changes to update callback during runtime\nwatch(\n  () => props.recordTimeline,\n  (enabled) => {\n    if (enabled) {\n      game.stateManager.setTimelineCallback(handleTimelineFrame)\n      timelineFrames.value = [] // Clear any existing frames\n    } else {\n      game.stateManager.setTimelineCallback(undefined)\n      timelineFrames.value = []\n    }\n  }\n)\n\n\n\n// Calculate snake head position for word display\nconst snakeHeadDisplayStyle = computed(() => {\n  if (!snakeHead.value || !gameRunning.value) {\n    return { display: 'none' }\n  }\n  \n  const x = snakeHead.value.x * gridSize.value + gridSize.value / 2\n  const y = snakeHead.value.y * gridSize.value - 40 // Above the head\n  \n  return {\n    left: `${x}px`,\n    top: `${y}px`,\n    transform: 'translateX(-50%)',\n    zIndex: '10'\n  }\n})\n\n// Resolve pronunciation for the current target word\nconst currentTargetPronunciation = computed(() => {\n  const w = currentTargetWord.value\n  if (!w) return ''\n  const found = props.words.find(v => v.word === w)\n  return found?.pronunciation || ''\n})\n\n// Display pronunciation with exactly one leading and trailing slash\nconst currentTargetPronunciationDisplay = computed(() => {\n  const raw = (currentTargetPronunciation.value || '').trim()\n  if (!raw) return ''\n  // Remove any leading/trailing slashes, brackets or whitespace\n  const stripped = raw.replace(/^\\s*[\\/\\[\\]()]+|[\\/\\[\\]()]+\\s*$/g, '')\n  return stripped ? `/${stripped}/` : ''\n})\n\n// Emit events whenever correct or wrong eaten counters increment\nconst prevWordsCompleted = ref<number>(0)\nconst stopWordsWatch = watch(\n  () => game.stateManager.wordsCompleted.value,\n  (newVal, oldVal) => {\n    if (typeof oldVal === 'number' && newVal > oldVal) {\n      // Get details for session tracking\n      const lastWord = (game.stateManager as any).lastEatenWord?.value as string | undefined || ''\n      const lastPosition = (game.stateManager as any).lastEatenFoodPos?.value as { x: number; y: number } || { x: 0, y: 0 }\n      const currentVocab = props.words.find(w => w.word === lastWord)\n      \n      const details = {\n        word: lastWord,\n        meaningShort: currentVocab?.meaning || lastWord,\n        position: lastPosition,\n        snakeLength: game.stateManager.snake.value.body.length,\n        gameScore: game.stateManager.score.value,\n        wordsCompleted: game.stateManager.wordsCompleted.value,\n        wrongEatenCount: (game.stateManager as any).wrongEatenCount?.value as number ?? 0,\n        snakeBody: [...game.stateManager.snake.value.body],\n        direction: { ...game.stateManager.snake.value.direction },\n        timelineFrames: props.recordTimeline && timelineFrames.value.length\n          ? [...timelineFrames.value.map(f => ({\n              body: f.body.map(seg => ({ x: seg.x, y: seg.y })),\n              direction: { x: f.direction.x, y: f.direction.y }\n            }))]\n          : undefined\n      }\n      \n      console.log('[DEBUG] Snake correct food details:', details)\n      console.log('[DEBUG] Snake body:', details.snakeBody)\n      console.log('[DEBUG] Snake direction:', details.direction)\n      \n      emit('correct-food-eaten', details)\n      if (props.recordTimeline) timelineFrames.value = []\n      \n      // Speak the eaten word using selected voice\n      if (lastWord) {\n        const { playAudio } = useVoiceStore()\n        // Fire and forget; internal store handles support/errors\n        playAudio(lastWord).catch(() => {})\n      }\n    }\n    prevWordsCompleted.value = newVal\n  }\n)\n\n// Watch wrong eaten counter\nconst prevWrongEaten = ref<number>(0)\nconst stopWrongWatch = watch(\n  () => (game.stateManager as any).wrongEatenCount?.value,\n  (newVal, oldVal) => {\n    if (typeof newVal === 'number' && typeof oldVal === 'number' && newVal > oldVal) {\n      // Get details for session tracking\n      const lastWord = (game.stateManager as any).lastEatenWord?.value as string | undefined || ''\n      const lastPosition = (game.stateManager as any).lastEatenFoodPos?.value as { x: number; y: number } || { x: 0, y: 0 }\n      const currentVocab = props.words.find(w => w.word === lastWord)\n      \n      const details = {\n        word: lastWord,\n        meaningShort: currentVocab?.meaning || lastWord,\n        position: lastPosition,\n        snakeLength: game.stateManager.snake.value.body.length,\n        gameScore: game.stateManager.score.value,\n        wordsCompleted: game.stateManager.wordsCompleted.value,\n        wrongEatenCount: newVal,\n        snakeBody: [...game.stateManager.snake.value.body],\n        direction: { ...game.stateManager.snake.value.direction },\n        timelineFrames: props.recordTimeline && timelineFrames.value.length\n          ? [...timelineFrames.value.map(f => ({\n              body: f.body.map(seg => ({ x: seg.x, y: seg.y })),\n              direction: { x: f.direction.x, y: f.direction.y }\n            }))]\n          : undefined\n      }\n      \n      emit('wrong-food-eaten', details)\n      // Reset timeline after emitting wrong food eaten to start fresh for next food\n      if (props.recordTimeline) timelineFrames.value = []\n      \n      // Speak the eaten word (wrong pick) too\n      if (lastWord) {\n        const { playAudio } = useVoiceStore()\n        playAudio(lastWord).catch(() => {})\n      }\n    }\n    if (typeof newVal === 'number') prevWrongEaten.value = newVal\n  }\n)\n\n// Watch for game over to emit completion event\nconst stopGameOverWatch = watch(\n  () => game.stateManager.gameOver.value,\n  (isGameOver) => {\n    if (isGameOver) {\n      emit('game-complete')\n    }\n  }\n)\n\n// Watch for Vietnamese mode changes during gameplay\nwatch(() => props.vietnameseMode, (newValue) => {\n  game.updateVietnameseMode(newValue ?? false)\n  // Regenerate food with new mode\n  if (game.stateManager.gameRunning.value) {\n    game.stateManager.generateFood(props.words, newValue ?? false)\n  }\n})\n\n// Watch for double bait mode changes and update state manager\nwatch(() => props.doubleBaitMode, (enabled) => {\n  if ((game.stateManager as any).setDoubleBaitMode) {\n    ;(game.stateManager as any).setDoubleBaitMode(!!enabled, props.words, props.vietnameseMode ?? false)\n  }\n})\n\n// Focus canvas for keyboard events\nconst focusCanvas = () => {\n  if (gameCanvas.value) {\n    gameCanvas.value.focus()\n  }\n}\n\nconst startGame = () => {\n  game.startGame()\n  focusCanvas()\n}\n\nconst restartGame = () => {\n  game.stopGame()\n  game.stateManager.resetGame()\n  if (gameCanvas.value) {\n    game.initialize(gameCanvas.value, props.words, props.vietnameseMode)\n    // Re-apply double bait mode on restart so both foods show immediately if enabled\n    if ((game.stateManager as any).setDoubleBaitMode) {\n      ;(game.stateManager as any).setDoubleBaitMode(!!props.doubleBaitMode, props.words, props.vietnameseMode ?? false)\n    }\n    // Re-setup timeline callback if enabled\n    if (props.recordTimeline) {\n      game.stateManager.setTimelineCallback(handleTimelineFrame)\n    } else {\n      game.stateManager.setTimelineCallback(undefined)\n    }\n  }\n}\n\nconst handleKeyPress = (event: KeyboardEvent) => {\n  game.handleKeyPress(event)\n}\n\n// Touch controls direction change\nconst changeDirection = (dx: number, dy: number) => {\n  if (gameOver.value) return\n  // If not running, start the game first then set desired direction\n  const notRunning = !gameRunning.value\n  if (notRunning) {\n    game.startGame()\n  }\n  game.stateManager.updateDirection({ x: dx, y: dy })\n}\n\nonMounted(async () => {\n  await nextTick()\n  if (!gameCanvas.value) return\n  \n  game.initialize(gameCanvas.value, props.words, props.vietnameseMode)\n  // Initialize double bait mode on mount\n  if ((game.stateManager as any).setDoubleBaitMode) {\n    ;(game.stateManager as any).setDoubleBaitMode(!!props.doubleBaitMode, props.words, props.vietnameseMode ?? false)\n  }\n  \n  // Set up timeline recording callback if enabled\n  if (props.recordTimeline) {\n    game.stateManager.setTimelineCallback(handleTimelineFrame)\n  } else {\n    game.stateManager.setTimelineCallback(undefined)\n  }\n  \n  // Add global keyboard listener\n  document.addEventListener('keydown', handleKeyPress)\n})\n\nonUnmounted(() => {\n  stopGameOverWatch()\n  stopWordsWatch()\n  stopWrongWatch()\n  document.removeEventListener('keydown', handleKeyPress)\n  game.cleanup()\n})\n</script>\n\n<style scoped>\n.modal-enter-active, .modal-leave-active {\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.modal-enter-from, .modal-leave-to {\n  opacity: 0;\n  transform: scale(0.9) translateY(20px);\n}\n\n.snake-game {\n  user-select: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n}\n\ncanvas:focus {\n  outline: 2px solid #10b981;\n  outline-offset: -2px;\n}\n</style>\n"],"names":["_openBlock","_createElementBlock","_createElementVNode","_toDisplayString","_unref","_createVNode","_Transition","$emit"],"mappings":"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"}